E)
    return thaiWordBreak->Init(szFileName, szFileNameSentStruct, szFileNameTrigram);
#else
    return thaiWordBreak->Init(szFileName, szFileNameTrigram);
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   ThaiWordBreakInitResource
//
//  Synopsis:   Initialize Thai Word Break - initialize variables of Thai Word Break.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/2000 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
PTEC WINAPI ThaiWordBreakInitResource(LPBYTE pThaiDic, LPBYTE pThaiTrigram, BOOL fSkipHeader)
{
	if (thaiWordBreak == NULL)
	{
		thaiWordBreak = new CThaiWordBreak;
		if (thaiWordBreak == NULL)
			return retcode(ptecIOErrorMainLex, ptecFileRead);
	}

    return thaiWordBreak->InitRc(pThaiDic, pThaiTrigram, fSkipHeader);
}

//+---------------------------------------------------------------------------
//
//  Function:   ThaiWordBreakTerminate
//
//  Synopsis:   Terminate Thai Word Break - does the cleanup for Thai Word Break.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void WINAPI ThaiWordBreakTerminate()
{
	if (thaiWordBreak)
	{
	    thaiWordBreak->UnInit();
		delete thaiWordBreak;
		thaiWordBreak = NULL;
	}
}

//+---------------------------------------------------------------------------
//
//  Function:   ThaiWordBreakSearch
//
//  Synopsis:   Search to see if the word is in.
//
//  Arguments:  szWord - the word to search for
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL WINAPI ThaiWordBreakSearch(const WCHAR* szWord, DWORD* pdwPOS)
{
	if (thaiWordBreak == NULL)
		return FALSE;

    return thaiWordBreak->Find(szWord, pdwPOS);
}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_FindWordBreak
//
//  Synopsis:   Search to see if the word is in.
//
//  Arguments:  szWord - the word to search for
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int WINAPI THWB_FindWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakLen, unsigned int mode)
{
	if (thaiWordBreak == NULL)
		return 0;

    return thaiWordBreak->FindWordBreak(wzString,iStringLen, pBreakPos, iBreakLen, (BYTE) mode, true);
}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_IndexWordBreak
//
//  Synopsis:   Search to see if the word is in.
//
//  Arguments:  szWord - the word to search for
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int WINAPI THWB_IndexWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,THWB_STRUCT* pThwb_Struct,unsigned int iBreakLen)
{
	if (thaiWordBreak == NULL)
		return 0;

    return thaiWordBreak->IndexWordBreak(wzString,iStringLen, pBreakPos, pThwb_Struct, iBreakLen);
}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_FindAltWord
//
//  Synopsis:
//
//  Arguments:
//		pBreakPos - array of 5 byte.
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int WINAPI THWB_FindAltWord(WCHAR* wzWord,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos)
{
	if (thaiWordBreak == NULL)
		return 0;

    return thaiWordBreak->FindAltWord(wzWord,iWordLen,Alt,pBreakPos);

}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_CreateThwbStruct
//
//  Synopsis:   
//
//  Arguments:  
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
THWB_STRUCT* WINAPI THWB_CreateThwbStruct(unsigned int iNumStruct)
{
	unsigned int i = 0;
	THWB_STRUCT* pThwb_Struct = NULL;
	pThwb_Struct = new THWB_STRUCT[iNumStruct];

	if (pThwb_Struct)
	{
		for(i=0;i < iNumStruct; i++)
		{
			pThwb_Struct[i].fThai = false;
			pThwb_Struct[i].alt = 0;
		}
	}
	return pThwb_Struct;
}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_DeleteThwbStruct
//
//  Synopsis:   
//
//  Arguments:  
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void WINAPI THWB_DeleteThwbStruct(THWB_STRUCT* pThwb_Struct)
{
	if (pThwb_Struct)
		delete pThwb_Struct;
	pThwb_Struct = NULL;
}



//+---------------------------------------------------------------------------
//
//  Function:   ThaiSoundEx
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int WINAPI ThaiSoundEx(WCHAR* word)
{
//        ::MessageBoxW(0,L"Soundex called",L"THWB",MB_OK);
//        return 0;
	if (thaiWordBreak == NULL)
		return 0;
    return thaiWordBreak->Soundex(word);
}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_CreateWordBreaker
//
//  Synopsis:   
//
//  Arguments:  
//
//  Modifies:
//
//  History:    created 11/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD_PTR WINAPI THWB_CreateWordBreaker()
{
	if (thaiWordBreak == NULL)
		return 0;

    return thaiWordBreak->CreateWordBreaker();
}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_FindWordBreak
//
//  Synopsis:   Search to see if the word is in.
//
//  Arguments:  szWord - the word to search for
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int WINAPI THWB_FindWB(DWORD_PTR dwBreaker, WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakLen, unsigned int mode)
{
	if (thaiWordBreak == NULL)
		return 0;

    return thaiWordBreak->FindWordBreak(dwBreaker, wzString,iStringLen, pBreakPos, iBreakLen, (BYTE) mode, true);
}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_DeleteWordBreaker
//
//  Synopsis:   
//
//  Arguments:  
//
//  Modifies:
//
//  History:    created 11/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL WINAPI THWB_DeleteWordBreaker(DWORD_PTR dwBreaker)
{
	if (thaiWordBreak == NULL)
		return 0;

    return thaiWordBreak->DeleteWordBreaker(dwBreaker);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\trie.cpp ===
#if !defined(LANGUAGE_IDENTIFICATION)
#   include "precomp.h"
#endif
#include "trie.h"
#ifdef LANGUAGE_IDENTIFICATION
#   include "mymalloc.h"
#endif

#ifndef WINCE
#   include "assert.h"
#else
#   define assert(x)
#endif

#include "thwbplat.h"

/******************************Public*Routine******************************\
* TrieInit
*
* Given a pointer to a resource or mapped file of a mapped file this
* function allocates and initializes the trie structure.
*
* Returns NULL for failure, trie control structure pointer for success.
*
**************************************************************************/

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte)
{
    LPWORD lpwTables;
    TRIECTRL *lpTrieCtrl;
    LPTRIESTATS lpTrieStats;

    lpTrieStats = (LPTRIESTATS) lpByte;

	//MessageBoxW(0,L"Step#1",L"Trie.C",MB_OK);
    if (lpTrieStats == NULL)
        return(NULL);

    // Check the version number.  This code currently only supports version 1 tries
	//MessageBoxW(0,L"Step#2",L"Trie.C",MB_OK);
    if (lpTrieStats->version > 1)
        return NULL;

    //
    // Allocate space for the control structure and the table of SR offsets
    //
	lpTrieCtrl = new TRIECTRL();
    if (!lpTrieCtrl)
        return NULL;

    //
    // Allocate space for the complete header, copy the fixed part and read in the rest
    //
    lpByte += lpTrieStats->cbHeader;
    lpTrieCtrl->lpTrieStats = lpTrieStats;

    //
    // Set up the table pointers (all these tables are inside the TRIECTRL allocation)
    //

    lpwTables = (LPWORD)(lpTrieStats+1);

    lpTrieCtrl->lpwCharFlagsCodes = lpwTables;
    lpwTables += lpTrieStats->cCharFlagsCodesMax;

    if ((DWORD_PTR) lpwTables & 0x02)                           // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwTagsCodes = lpwTables;
    lpwTables += lpTrieStats->cTagsCodesMax;

    if ((DWORD_PTR) lpwTables & 0x02)                           // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwMRPointersCodes = lpwTables;
    lpwTables += lpTrieStats->cMRPointersCodesMax;

    if ((DWORD_PTR) lpwTables & 0x02)                           // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwSROffsetsCodes = lpwTables;
    lpwTables += lpTrieStats->cSROffsetsCodesMax;

    if ((DWORD_PTR) lpwTables & 0x02)                           // Deal with possible data mis-alignment
        lpwTables++;

	lpTrieCtrl->lpCharFlags = (LPCHARFLAGS)lpwTables;
	lpwTables = (LPWORD)(lpTrieCtrl->lpCharFlags + lpTrieStats->cUniqueCharFlags);

	lpTrieCtrl->lpwTags = (DWORD *)lpwTables;
	lpwTables += (2 * lpTrieStats->cUniqueTags);

	lpTrieCtrl->lpwMRPointers = (DWORD *) lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueMRPointers);

    lpTrieCtrl->lpwSROffsets = (DWORD *) lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueSROffsets);

    //
    // These tables should exactly fill the allocation
    //

    assert((LPBYTE)lpwTables == (LPBYTE)lpTrieStats + lpTrieStats->cbHeader);

    //
    // Init trie pointers
    //

    lpTrieCtrl->lpbTrie = (LPBYTE)lpByte;

    return (TRIECTRL *)lpTrieCtrl;
}

/******************************Public*Routine******************************\
* TrieFree
*
* Free the resources allocated for the control structure.
*
\**************************************************************************/

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl)
{
    //
    // Finally free the control structure and all the tables.  STILL MUST FREE THIS FOR ROM
    //
//    NLGFreeMemory(lpTrieCtrl);
	if (lpTrieCtrl)
		delete lpTrieCtrl;
}

/* Deompress a single symbol using base-256 huffman from a compressed data structure. piSymbol
points to a space to hold the decompressed value, which is an index to a frequency-ordered
table of symbols (0 is most frequent).  pcCodes is a table of code lengths returned from
HuffmanComputeTable.  pbData is a pointer to memory that contains the encoded data.  The
return value is the number of bytes decoded. */

int DecompressSymbol(WORD *piSymbol, const WORD *pcCodes, const unsigned char *pbData)
{
        int cBytes = 0;
        WORD wCode = 0, wiSymbol = 0;

        /* At each stage in this loop, we're trying to see if we've got a length-n code.
        dwCode is which length-n code it would have to be.  If there aren't that many length-n codes,
        we have to try n+1.  To do that, we subtract the number of length-n codes and shift in
        the next byte. dwiSymbol is the symbol number of the first length-n code. */

    while (1)
    {
                wCode += *pbData++;
                ++cBytes;
        if (wCode < *pcCodes)
        {
                        break;
                }
                wiSymbol += *pcCodes;
                wCode -= *pcCodes++;
                wCode <<= 8;
        }

        /* Now that dwCode is a valid number of a length-cBytes code, we can just add it to
        dwiSymbol, because we've already added the counts of the shorter codes to it. */

        wiSymbol += wCode;

        *piSymbol = wiSymbol;

        return cBytes;
}

DWORD Get3ByteAddress(const BYTE *pb)
{
        return ((((pb[0] << 8) | pb[1]) << 8) | pb[2]) & 0x00ffffff;
}

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
    TRIESTATS  *lpTrieStats;
    DWORD       wOffset;
    DWORD       wOffset2;
    WORD        wCode;
    DWORD       dwCode;
    BYTE        wMask;
    BYTE        bMask;
    int         iTag;

    lpTrieStats = lpTrieCtrl->lpTrieStats;

    /* If this is an initial call, use the first byte in the first SR segment */

    if (lpTrieScan->wFlags == 0)
    {
        lpTrieScan->lpbSRDown = 0;
        lpTrieScan->lpbNode = lpTrieCtrl->lpbTrie;
        }

        /* Decompress the char/flags */

        lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwCharFlagsCodes, lpTrieScan->lpbNode);
        lpTrieScan->wch      = lpTrieCtrl->lpCharFlags[wCode].wch;
        lpTrieScan->wFlags   = lpTrieCtrl->lpCharFlags[wCode].wFlags;

        // Decompress skip enumeration

        if (lpTrieScan->wFlags & TRIE_NODE_SKIP_COUNT)
        {
        // Values greater than 127 are really 15 or 21 bit values.

            dwCode = (DWORD) *lpTrieScan->lpbNode++;

            if (dwCode >= 0x00c0)
            {
                dwCode  = ((dwCode & 0x003f) << 15);
                dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
                dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
            }
            else if (dwCode >= 0x0080)
                dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

            lpTrieScan->cSkipWords = dwCode;
        }

        /* Code to decompress enumeration goes here */

        if (lpTrieScan->wFlags & TRIE_NODE_COUNT)
        {
        // Values greater than 127 are really 15 or 21 bit values.

            dwCode = (DWORD) *lpTrieScan->lpbNode++;

            if (dwCode >= 0x00c0)
            {
                dwCode  = ((dwCode & 0x003f) << 15);
                dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
                dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
            }
            else if (dwCode >= 0x0080)
                dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

            lpTrieScan->cWords = dwCode;

        // Decompress the tagged enumeration counts

            wMask = 1;
            for (iTag = 0; iTag < MAXTAGS; iTag++)
            {
                if (lpTrieCtrl->lpTrieStats->wEnumMask & wMask)
                {
                // Values greater than 127 are really 15 or 21 bit values.

                    dwCode = (DWORD) *lpTrieScan->lpbNode++;

                    if (dwCode >= 0x00c0)
                    {
                        dwCode  = ((dwCode & 0x003f) << 15);
                        dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
                        dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
                    }
                    else if (dwCode >= 0x0080)
                        dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

                    lpTrieScan->aTags[iTag].cTag = dwCode;
                }
                else
                    lpTrieScan->aTags[iTag].cTag = 0;

                wMask <<= 1;
            }
        }
        else
                lpTrieScan->cWords = 0;

        // Any tagged data for this node follows the counts

        lpTrieScan->wMask = 0;

        if (lpTrieScan->wFlags & TRIE_NODE_TAGGED)
        {
        // If there is only one tagged field, the mask byte won't be stored

                if (lpTrieCtrl->lpTrieStats->cTagFields == 1)
                        bMask = lpTrieCtrl->lpTrieStats->wDataMask;
                else
                        bMask = *lpTrieScan->lpbNode++;

        // Now that we know which elements are stored here, pull them in their proper place

                wMask = 1;
                for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
                {
                        if (lpTrieCtrl->lpTrieStats->wDataMask & bMask & wMask)
                        {
                                lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwTagsCodes, lpTrieScan->lpbNode);
                                lpTrieScan->aTags[iTag].dwData = lpTrieCtrl->lpwTags[wCode];
                                lpTrieScan->wMask |= wMask;
                        }

                        bMask  &= ~wMask;
                        wMask <<= 1;
                }
        }

        // There are two flavors of right pointers: Multiref and Skip.

        if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
        {
            if (lpTrieScan->wFlags & TRIE_NODE_SKIP)
            {
                lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,lpTrieScan->lpbNode);
                wOffset2 = lpTrieCtrl->lpwSROffsets[wCode];     // Only add this after entire node is decompressed
            }
            else
            {
                /* Multiref: The down pointer is encoded directly */

                lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwMRPointersCodes, lpTrieScan->lpbNode);
                lpTrieScan->lpbRight = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
            }
        }
        else
                lpTrieScan->lpbRight = NULL;

        // There are 4 kinds of down pointer: Absolute, Inline, Multiref, and Singleref Offset.
        // Each requires different decompression

        if (lpTrieScan->wFlags & TRIE_DOWN_ABS)
        {
                // Immediate.  The next 3 bytes are the absolute offset from the base of the trie.

                lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + Get3ByteAddress(lpTrieScan->lpbNode);
                lpTrieScan->lpbNode += 3;
        }
        else if (lpTrieScan->wFlags & TRIE_DOWN_INLINE)
        {
                /* Inline: The down pointer points to the next sequential byte (so it isn't stored) */

                assert(lpTrieScan->wFlags&TRIE_NODE_END);

                lpTrieScan->lpbSRDown = lpTrieScan->lpbDown = lpTrieScan->lpbNode;
        }
        else if (lpTrieScan->wFlags & TRIE_DOWN_MULTI)
        {
                /* Multiref: The down pointer is encoded directly */

                lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwMRPointersCodes,
                        lpTrieScan->lpbNode);

                lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
        }
        else if (lpTrieScan->wFlags & TRIE_NODE_DOWN)
        {
                /* SR Offset.  The down pointer is encoded as an offset from the LAST downpointer
                into this singleref segment.  So we have to keep the old one around so we can add to it */

                lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,
                        lpTrieScan->lpbNode);

                if (lpTrieScan->lpbSRDown == 0)
                {
                        lpTrieScan->lpbSRDown = lpTrieScan->lpbNode;  // We offset from the end of the first node when going into a new state.
                }

                wOffset = lpTrieCtrl->lpwSROffsets[wCode];
                lpTrieScan->lpbSRDown += wOffset;
                lpTrieScan->lpbDown = lpTrieScan->lpbSRDown;
        }
        else
                lpTrieScan->lpbDown = NULL;

    // We couldn't deal with this until now, since skip pointers are always delta encoded from the end of node

        if ((lpTrieScan->wFlags & (TRIE_NODE_RIGHT | TRIE_NODE_SKIP)) == (TRIE_NODE_RIGHT | TRIE_NODE_SKIP))
            lpTrieScan->lpbRight = lpTrieScan->lpbNode + wOffset2;

} // TrieDecompressNode

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
// Are we at EOS?

    if (lpTrieScan->wFlags & TRIE_NODE_END)
    {
    // Is this is a hard EOS?

        if (!(lpTrieScan->wFlags & TRIE_NODE_SKIP))
        {
        // If we can follow a right pointer, do so, else fail

            if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
                lpTrieScan->lpbNode = lpTrieScan->lpbRight;
            else
                return FALSE;
        }

    // Either we're at a soft EOS or we've followed a right pointer.
    // Both these require us to reset the SRDown for proper decompression

        lpTrieScan->lpbSRDown = 0;
    }

// Decompress the node at return success

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

BOOL WINAPI TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch)
{
// If this is the last node in the normal or skip state, quit here

    if (lpTrieScan->wFlags & TRIE_NODE_END)
        return FALSE;

// If there isn't a right pointer or if the target letter is alphabetically less then
// the current letter scan right normally.  Otherwise, follow the skip pointer.

    if (!(lpTrieScan->wFlags & TRIE_NODE_RIGHT) || (wch < lpTrieScan->wch))
        return TrieGetNextNode(lpTrieCtrl, lpTrieScan);

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode   = lpTrieScan->lpbRight;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
        /* Flags can't normally be zero; that always means "top node" */

    if (lpTrieScan->wFlags == 0)
    {
        TrieDecompressNode(lpTrieCtrl, lpTrieScan);
        return TRUE;
    }

    if (!(lpTrieScan->wFlags & TRIE_NODE_DOWN))
        return FALSE;

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode = lpTrieScan->lpbDown;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;

} // TrieGetNextState

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguish a valid word from a valid prefix, caller must test
wFlags for TRIE_NODE_VALID. */

BOOL WINAPI TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t far* lpwszWord)
{
    /* Start at the root of the trie and loop through all the letters in the word */

    memset(lpTrieScan,0,sizeof(*lpTrieScan));

    while (*lpwszWord)
    {
        /* Each new letter means we need to go to a new state.  If there is none,
                the word is not in this trie */

        if (!TrieGetNextState(lpTrieCtrl, lpTrieScan))
            return FALSE;

        /* Now we walk across the state looking for this character.  If we don't find
        it, this word is not in this trie */

        while (lpTrieScan->wch != *lpwszWord)
        {
            if (!TrieSkipNextNode(lpTrieCtrl, lpTrieScan, *lpwszWord))
                return FALSE;
        }

        ++lpwszWord;
    }

    return TRUE;

} // TrieCheckWord

// Find the index to the word in the trie.

DWORD CountWords(TRIECTRL *ptc, TRIESCAN *pts)
{
    TRIESCAN        ts     = *pts;
    DWORD           cWords = 0;

    if (!TrieGetNextState(ptc, &ts))
            return cWords;

    do
    {
        if (ts.wFlags & TRIE_NODE_VALID)
            cWords++;

        cWords += CountWords(ptc, &ts);
    } while (TrieGetNextNode(ptc, &ts));

    return cWords;
}

int WINAPI TrieWordToIndex(TRIECTRL *ptc, wchar_t *pwszWord)
{
    TRIESCAN    ts;
    int         ich = 0;
    int         index = 0;
    BOOL        bValid;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
            return FALSE;

    do
    {
        bValid = ts.wFlags & TRIE_NODE_VALID;

    // Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
    // If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

        // If we reached the end of word at a valid state, return the index

            if ((pwszWord[ich] == L'\0') && ts.wFlags & TRIE_NODE_VALID)
                return index;

        // Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return -1;
        }
        else
        {
        // Now, follow the skip pointer if exist and the alphabetic character is greater then
        // the pivot point. Otherwise, goto the next node.  Add the sub tree count.  If it's cached
        // use it, otherwise compute it recursively.

            if ((ts.wFlags & TRIE_NODE_SKIP_COUNT) && (pwszWord[ich] > ts.wch))
            {
                index += ts.cSkipWords;

            // This can't fail if TRIE_NODE_SKIP_COUNT is set

                TrieSkipNextNode(ptc, &ts, pwszWord[ich]);
            }
            else
            {
                index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

                if (!TrieGetNextNode(ptc, &ts))
                    return -1;
            }
        }

    // If the node we just visited was valid, increment the index

        if (bValid)
            index++;

    } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc)
{
    TRIESCAN        ts;
    int             ich = 0;
    DWORD           cWords;
    DWORD           cSkips;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
    // If we're at the end of the buffer, fail

        if (ich + 1 >= cwc)
            return FALSE;

    // Remember this node's character

        pwszWord[ich] = ts.wch;

    // If we're on a valid word AND we've reached the index we're looking for, exit the loop

        if (ts.wFlags & TRIE_NODE_VALID)
        {
            if (!nIndex)
                break;

            nIndex--;
        }

    // Get the count of words in this subtree.

        cWords = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);
        cSkips = (ts.wFlags & TRIE_NODE_SKIP_COUNT) ? ts.cSkipWords : 0x7fffffff;

    // Scan to the right until the word count of the subtree would be greater than or equal to the index
    // we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.
    // If we can use a skip count, do so.

        if (nIndex < cWords)
        {
            if (!TrieGetNextState(ptc, &ts))
                return FALSE;

            ich++;                                  // Advance the character position
        }
        else
        {
            if (nIndex >= cSkips)
            {
                nIndex -= cSkips;

                ts.lpbSRDown = 0;
                ts.lpbNode = ts.lpbRight;

                TrieDecompressNode(ptc, &ts);
            }
            else
            {
                nIndex -= cWords;

                if (!TrieGetNextNode(ptc, &ts))
                    return FALSE;
            }
        }

    } while (TRUE);

    pwszWord[++ich] = L'\0';                        // Null terminate the string
    return ts.wFlags & TRIE_NODE_VALID;             // Return validity
}

int WINAPI TriePrefixToRange(TRIECTRL *ptc, const wchar_t *pwszWord, int *piStart)
{
        TRIESCAN        ts;
        int                     ich = 0;
        int                     cnt;
        BOOL            bValid;

        memset(&ts, 0, sizeof(TRIESCAN));
   *piStart = 0;

        if (!TrieGetNextState(ptc, &ts))
                return 0;

        // Deal with special case of empty string

        if (pwszWord && !*pwszWord)
                return ptc->lpTrieStats->cWords;

        do
        {
        // Get the count of words below this prefix

                cnt = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

        // If the node we just arrived at is valid, increment the count

                bValid = ts.wFlags & TRIE_NODE_VALID;

        // Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
        // If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

                if (ts.wch == pwszWord[ich])
                {
                        ich++;

                // If we reached the end of prefix, return the count remaining below

                        if (pwszWord[ich] == L'\0')
                        {
                                if (bValid)
                                        cnt++;

                                return cnt;
                        }

                // Try going down a level

                        if (!TrieGetNextState(ptc, &ts))
                                return 0;
                }
                else
                {
                // Add the sub tree count.

                   *piStart += cnt;

                // Try the next letter in this state

                        if (!TrieGetNextNode(ptc, &ts))
                                return 0;
                }

                if (bValid)
                        (*piStart)++;

        } while (TRUE);
}

// TAGS

// Find the index to the word in the trie.

DWORD CountTags(TRIECTRL *ptc, TRIESCAN *pts, DWORD wMask, int iTag)
{
        TRIESCAN        ts    = *pts;
        DWORD           cTags = 0;

        if (!TrieGetNextState(ptc, &ts))
                return cTags;

        do
        {
                if (ts.wFlags & wMask)
                        cTags++;

                cTags += CountTags(ptc, &ts, wMask, iTag);
        } while (TrieGetNextNode(ptc, &ts));

        return cTags;
}

int WINAPI TrieWordToTagIndex(TRIECTRL *ptc, const wchar_t *pwszWord, int iTag)
{
        TRIESCAN        ts;
        int                     ich = 0;
        int                     index = 0;
        BOOL            bValid;
        DWORD           wMask = 1 << iTag;

        memset(&ts, 0, sizeof(TRIESCAN));

        if (!TrieGetNextState(ptc, &ts))
                return FALSE;

        do
        {
                bValid = ts.wFlags & wMask;

        // Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
        // If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

                if (ts.wch == pwszWord[ich])
                {
                        ich++;

                // If we reached the end of word at a valid state, return the index

                        if ((pwszWord[ich] == L'\0') && ts.wFlags & wMask)
                                return index;

                // Try going down a level

                        if (!TrieGetNextState(ptc, &ts))
                                return -1;
                }
                else
                {
                // Add the sub tree count.  If it's cached use it, otherwise compute it recursively.

                        index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

                        if (!TrieGetNextNode(ptc, &ts))
                                return -1;
                }

        // If the node we just visited was valid, increment the index

                if (bValid)
                        index++;
        } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieTagIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc, int iTag)
{
        TRIESCAN        ts;
        int                     ich = 0;
        DWORD           cTags;
        DWORD           wMask = 1 << iTag;

        memset(&ts, 0, sizeof(TRIESCAN));

        if (!TrieGetNextState(ptc, &ts))
                return FALSE;

        do
        {
        // If we're at the end of the buffer, fail

                if (ich + 1 >= cwc)
                        return FALSE;

        // Remember this node's character

                pwszWord[ich] = ts.wch;

        // If we're on a valid word AND we've reached the index we're looking for, exit the loop

                if (ts.wFlags & wMask)
                {
                        if (!nIndex)
                                break;

                        nIndex--;
                }

        // Get the count of words in this subtree.

                cTags = (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

        // Scan to the right until the word count of the subtree would be greater than or equal to the index
        // we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.

                if (nIndex < cTags)
                {
                        if (!TrieGetNextState(ptc, &ts))
                                return FALSE;

                        ich++;                                                  // Advance the character position
                }
                else
                {
                        nIndex -= cTags;

                        if (!TrieGetNextNode(ptc, &ts))
                                return FALSE;
                }
        } while (TRUE);

        pwszWord[++ich] = L'\0';                        // Null terminate the string
        return ts.wFlags & wMask;                       // Return validity
}

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                        // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                        // Returned values
        BYTE       *pbValid                     // Mask for valid return values
)
{
        TRIESCAN        ts;
        int             iTag;
        WORD            wMask;
        BYTE            bMask = ptc->lpTrieStats->wTagsMask;

        if (!TrieCheckWord(ptc, &ts, pwszWord))
                return FALSE;

        if (ts.wFlags & TRIE_NODE_TAGGED)
        {
                wMask = 1;
                for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
                {
                        if (ts.wMask & wMask)
                        {
                                pdw[iTag] = ts.aTags[iTag].dwData;
                                bMask |= wMask;
                        }

                        wMask <<= 1;
                }
        }

   *pbValid = (BYTE) wMask;

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\trie.h ===
#ifndef TRIE_H
#define TRIE_H

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; lpbNode points to the first byte of the next node in this state, and
lpbDown points to the first byte referenced by the down pointer, if any */

typedef struct tagTAGDATA
{
	DWORD	cTag;			// Count of tagged nodes below this node in the subtree
	DWORD	dwData;			// Stored tagged data for this node
} TAGDATA;

#define MAXTAGS 1
#if MAXTAGS > 8
#error No more than 8 tags are allowed
#endif

typedef struct tagTRIESCAN
{
	WCHAR	wch;			// Unicode character
	WORD	wFlags;			// see below
	WORD	wMask;			// which tags are valid
	WORD	__pad0;			// 
	DWORD	cWords;			// Words in subtree (only valid if TRIE_NODE_COUNT is set)
	DWORD	cSkipWords;		// Words in subtrees ignored when following a skip pointer
	LPBYTE	lpbNode;		// Address of next byte within the compressed trie
	LPBYTE	lpbDown;		// Address referenced by down pointer, if any
	LPBYTE	lpbRight;		// Address referenced by right pointer, if any
	LPBYTE	lpbSRDown;		// Last single-ref address referenced
	TAGDATA	aTags[MAXTAGS];	// The list of tag counts/data
} TRIESCAN, *PTRIESCAN, *LPTRIESCAN;

// Trie node flags, only the lower 16 bits of the flags are saved in the trie

#define TRIE_NODE_VALID         0x00000001      // wch is the last letter of a valid word
#define TRIE_NODE_END           0x00000002      // Last node in the state (no more alternatives to wch)
#define TRIE_NODE_COUNT         0x00000004		// The count of words in the subtree is stored in the node
#define TRIE_NODE_TAGGED        0x00000008      // The node has tagged data
#define TRIE_NODE_DOWN          0x00000010      // iDown is valid (word so far is a valid prefix)
#define TRIE_NODE_RIGHT         0x00000020      // iRight is valid (word connects to a substate)
#define TRIE_DOWN_INLINE        0x00000040      // iDown omitted, since it points to next node in memory
#define TRIE_DOWN_MULTI         0x00000080      // iDown is a second reference or worse
#define TRIE_DOWN_ABS           0x00000100		// iDown is an absolute immediate offset into the trie
#define	TRIE_NODE_SKIP			0x00000200		// Either iRight is a skip pointer or EOS is a 'soft' EOS
#define	TRIE_NODE_SKIP_COUNT	0x00000400		// cSkipWords is valid

/* Macro to access the data in the node, works for dawgs and tries */

#define DAWGDATA(pdawg)       ((pdawg)->wch)
#define DAWGDOWNFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_DOWN)
#define DAWGENDFLAG(pdawg)    ((pdawg)->wFlags & TRIE_NODE_END)
#define DAWGWORDFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_VALID)

/* Fixed-length part of the compressed trie header */

typedef struct tagTRIESTATS
{
	WORD	version;						// Version of this particular compressed trie
	WORD	__pad0;							//
	BYTE	wTagsMask;						// Which tags are in use
	BYTE	wEnumMask;						// Which tags have enumeration
	BYTE	wDataMask;						// Which tags have stored data
	BYTE	cTagFields;						// Total tags in use
	WORD	cMaxWord;						// Number of characters in longest word
	WORD	cMaxState;						// Number of nodes in longest state (max alternatives)
	WORD	cCharFlagsCodesMax;             // Bytes in longest char/flags code
	WORD	cTagsCodesMax;                  // Bytes in longest tagged data code
	WORD	cMRPointersCodesMax;			// Bytes in longest MR pointer code
	WORD	cSROffsetsCodesMax;             // Bytes in longest Single-ref code
	DWORD	cWords;							// Number of words in dictionary
	DWORD	cUniqueSROffsets;               // Unique offsets in Single-ref segment
	DWORD	cUniqueCharFlags;               // Unique char/flags pairs
	DWORD	cUniqueTags;                    // Unique tagged data values
	DWORD	cUniqueMRPointers;              // Unique multi-ref pointers
	DWORD	cbHeader;						// Bytes in header & tables
	DWORD	cbTrie;							// Bytes in trie
} TRIESTATS, *PTRIESTATS, *LPTRIESTATS;

/* Primary unit of a node.  Nodes usually contain a pointer too */

typedef struct tagCHARFLAGS {
        wchar_t wch;
        short wFlags;
} CHARFLAGS, *PCHARFLAGS, *LPCHARFLAGS;

/* Control structure used to decompress the trie */

typedef struct tagTRIECTRL
{
	TRIESTATS  *lpTrieStats;				// Pointer to base of header segment
	WORD       *lpwCharFlagsCodes;			// decoding table for Char/flags
	WORD       *lpwTagsCodes;				// decoding table for tagged data
	WORD       *lpwMRPointersCodes;			// decoding table for multiref pointers
	WORD       *lpwSROffsetsCodes;			// decoding table for singleref offsets
	CHARFLAGS  *lpCharFlags;				// table to convert codes to char/flags
	DWORD      *lpwTags;					// table to convert codes to tagged data
	DWORD      *lpwMRPointers;				// table to convert codes to multiref pointers
	DWORD      *lpwSROffsets;				// table to convert codes to Singleref offsets
	BYTE       *lpbTrie;					// Pointer to the trie.
} TRIECTRL, *PTRIECTRL, *LPTRIECTRL;

/* Useful Constants */

#define TRIE_MAX_DEPTH          128     // We'll fail on any words longer than this

// The prototypes below are plain C     (this is required for use with C++)

/* Given a pointer to a mapped file or resource containing a compressed trie,
read the trie into memory, making all the allocations required */

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte);

/* Free all the allocations associated with a trie */

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl);

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI
TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

BOOL WINAPI
TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch);

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI
TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguisha valid word from a valid prefix, caller must test
wFlags for fTrieNodeValid. */

BOOL WINAPI
TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t * lpwszWord);

/* Walk the trie from pTrieNode, calling pfnTrieWord on every valid word.  pvParam is passed through
to pfnTrieWord.  If pfnTrieWord returns non-zero, the enumeration stops.  lpwszWord must point to a
space of cwchTrieWordMax+1 wchar_t's.  To walk the entire trie, set *pTrieScan to all zeros.  Returns
the number of words traversed. pfnTrieWord may be null if all you want is the count of words. */

int WINAPI
TrieEnumerate(
        LPTRIECTRL lpTrieCtrl,          // Trie to enumerate
        LPTRIESCAN lpTrieScan,  // structure holding starting point, all-zero for whole trie
        wchar_t *pwszWord,                      // buffer to hold words being enumerated
        void *pvParam,                          // parameter to pass to pfnTrieWord
        int (*pfnTrieWord)(wchar_t *pwszWord, void *pvParam)
);

int WINAPI
TrieWordToIndex(
        TRIECTRL   *ptc,                        // Trie in which to find word index
        wchar_t    *pwszWord            // Word for which we're looking
);

BOOL WINAPI
TrieIndexToWord(
        TRIECTRL   *ptc,                        // Trie in which to find indexed word
        DWORD           nIndex,                 // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int                     cwc                             // Max characters in buffer (including NULL)
);

int WINAPI
TrieWordToTagIndex(
        TRIECTRL   *ptc,                        // Trie in which to find word index
        const wchar_t    *pwszWord,				// Word for which we're looking
        int                     tag				// Which tag to enumerate
);

BOOL WINAPI
TrieTagIndexToWord(
        TRIECTRL   *ptc,                        // Trie in which to find indexed word
        DWORD           nIndex,                 // Index for which we're looking
        wchar_t    *pwszWord,					// Returned word
        int                     cwc,			// Max characters in buffer (including NULL)
        int                     tag             // Which tag to enumerate
);

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                        // Trie in which to find word
        wchar_t    *pwszWord,					// Word for which we're looking
        DWORD      *pdw,                        // Returned values
        BYTE       *pbValid                     // Mask for valid return values
);

int WINAPI
TriePrefixToRange(
        TRIECTRL   *ptc,                        // Trie in which to find prefix range
        const wchar_t    *pwszWord,				// Prefix for which we're looking
        int                *piStart				// Start of range with this prefix
);

/**** Subroutines for traversing Directed Acyclic Word Graphs ****/

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; iDown indexes the first node in the state wch transitions to. DAWG is a special
kind of trie: a "Directed Acyclic Word Graph," essentially an ending-compressed trie. */

typedef struct tagDAWGNODE
{
    DWORD   wch;            // Unicode character
    DWORD   wFlags;         // see below
    DWORD   cWords;         // Words below this node in the subtree
	DWORD	cSkipWords;		// Words below skipped nodes
    DWORD   iDown;          // Offset of first node in next state
    DWORD   iRight;         // Offset to first node in next substate
    DWORD   cTags[8];       // Count of tagged nodes below this node in the subtree
    DWORD   dwData[8];      // Stored tagged data for this node
} DAWGNODE, *PDAWGNODE, *LPDAWGNODE;

/* Given a trie and a pointer to a node in it, find the next node in that state.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. Returns a pointer to the new node, NULL if there is
no next node (i.e. if this is the end of a state).*/

DAWGNODE * WINAPI DawgGetNextNode(void *pTrie, DAWGNODE *pTrieNode);

/* From this node, find the first node in the state it points to.  This is equivalent
to traversing a down pointer or extending the word one letter and finding the first
alternative.  Returns a pointer to the first node in the new state, NULL if there is
no down pointer. To find the first state in the trie, use pTrieNode == NULL */

DAWGNODE * WINAPI DawgGetNextState(void *pTrie, DAWGNODE *pTrieNode);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns a pointer to the terminal node in pTrie Returns
NULL if there is no path through the trie that corresponds to pwszWord. To distinguish
a valid word from a valid prefix, caller must test wFlags for fTrieNodeValid. */

DAWGNODE * WINAPI DawgCheckWord(void *pTrie, wchar_t *pwszWord);

/* Walk the trie from pTrieNode, calling pfnTrieWord on every valid word.  pvParam is passed through
to pfnTrieWord.  If pfnTrieWord returns non-zero, the enumeration stops.  pwszWord must point to a
space of cwchTrieWordMax+1 wchar_t's.  To walk the entire trie, pass NULL for pTrieNode. Returns
the number of words traversed. pfnTrieWord may be null if all you want is the count of words. */

int WINAPI
DawgEnumerate(
        void *pTrie,                            // Trie to enumerate
        DAWGNODE *pTrieNodeStart,       // point to enumerate from, NULL if all
        wchar_t *pwszWord,                      // buffer to hold words being enumerated
        void *pvParam,                          // parameter to pass to pfnTrieWord
        int (*pfnTrieWord)(wchar_t *pwszWord, void *pvParam)
);

// end plain C Prototypes

#ifdef __cplusplus
}
#endif

#endif // TRIE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\unidef.h ===
//------------------------------------------------------------------------------------------
//	UNIDEF.h
//
//	This file contains many definition uses for the purpose of cross platform.
//
//------------------------------------------------------------------------------------------

#ifndef UNIDEF_H
#define UNIDEF_H

#ifdef UNDER_CE
#define NULL 0
#endif

#endif // UNIDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\wb_asserts.h ===
#ifndef _WORDBREAKASSERT_H_
#define _WORDBREAKASSERT_H_

#include <windows.h>

#if defined(__cplusplus)
extern "C" {
#endif

// Debugging stuff goes here
#if defined(_DEBUGXX)

#include <stdio.h>
void __cdecl AssertCore(BOOL f, char *pChErrorT, char *pchFile, int nLine);
#define Assert(_f_, _pChErrorT_) AssertCore(_f_, _pChErrorT_, __FILE__ , __LINE__)
BOOL FAlertContinue(char *pchAlert);

#else

#define Assert(_f_, _pChErrorT_)
#define FAlertContinue(_pchAlert_) TRUE
#endif


#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\wb_asserts.c ===
#include "WB_Asserts.h"

//||||||||||||||||||||||||||||||| D E B U G  S T U F F |||||||||||||||||||||||||||||||||||||

#if defined(_DEBUGXX)


#include <stdio.h>


BOOL FAlertContinue(char *pchAlert)
{
    int iMsgBoxRetVal = MessageBoxA(NULL, "Continue", pchAlert, MB_YESNO|MB_ICONEXCLAMATION);
    
    return (IDYES == iMsgBoxRetVal);
}

BOOL g_fDebugAssertsOff = FALSE;

void AssertCore(BOOL f, char *pChErrorT, char *pchFile, int nLine)
{
if ((!g_fDebugAssertsOff) && (!f))
	{
	int iMsgBoxRetVal;
	char pChError[256];

	sprintf(pChError,"%s ! %s : %d",pChErrorT, pchFile, nLine);

	iMsgBoxRetVal = MessageBoxA(NULL, " Assertion Failure: thwb.dll. YES=Go On, NO=DEBUG, CANCEL=Asserts OFF", pChError, MB_YESNOCANCEL|MB_ICONEXCLAMATION);

	if (IDNO == iMsgBoxRetVal)
		{
		__asm int 3
		}
	else if (IDCANCEL == iMsgBoxRetVal)
		{
		g_fDebugAssertsOff = TRUE;
		}
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\wzmanip.h ===
#if !defined(WZMANIP_H)
#include <windows.h>

#define WZMANIP_H
WCHAR * Wzncpy(WCHAR* wzTo, const WCHAR* wzFrom, unsigned int cchTo);
char * Szncpy(char* wzTo, const char* wzFrom, unsigned int cchTo);
WCHAR* WznCat(WCHAR* wzTo, const WCHAR* wzFrom, unsigned int cchTo);
char* SznCat(char* wzTo, const char* wzFrom, unsigned int cchTo);
int MsoWzDecodeInt(WCHAR* rgwch, int cch, int w, int wBase);
int MsoWzDecodeUint(WCHAR* rgwch, int cch, unsigned u, int wBase);
int MsoSzDecodeInt(char* rgch, int cch, int w, int wBase);
int MsoSzDecodeUint(char* rgch, int cch, unsigned u, int wBase);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\vendor.h ===
/*------------------------------------------------------------
    vendor.h - Unified vendor include file

        2/5/97  dougp   created

    Note:  The Natural Language Group maintains this file.
        Please contact us with change requests.
------------------------------------------------------------*/

#if !defined(VENDOR_H)
#define VENDOR_H

/* unified codes */
// I originally used an enum here - but RC doesn't like it

typedef int VENDORID;   // vendorid

#define  vendoridSoftArt            1
#define  vendoridInso               2

  // these came from the original list from the speller
  // but don't conflict with any others - so they are safe for all tools
#define vendoridInformatic         17     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define vendoridAmebis             18     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define vendoridLogos              19     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define vendoridDatecs             20     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define vendoridFilosoft           21     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define vendoridLingsoft           22     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define vendoridPolderland         23     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */


#define  vendoridMicrosoft          64
#define  vendoridSynapse            65              /* Synapse - French(Spelling:Mssp3fr.lex, Mssp3fr.dll) */
#define  vendoridFotonija           66              /* Fotonija - Lithuanian(Spelling:Mssp_lt.lex, Msplt32.dll) - added 3/25/97 */
#define  vendoridFotonja        vendoridFotonija                /* To make up for earlier misspelling */
#define  vendoridHizkia             67              /* Hizkia -Basque (Spelling:Mssp_eu.lex, Mspeu32.dll) - added 5/21/97 */
#define  vendoridExpertSystem       68              /* ExpertSystem - Italian(Spelling:Mssp3lt.lex, Mssp3lt.dll) - added 7/17/97 */
#define  vendoridWYSIWYG            69      /* Various languages as an addon - 2/2/98 */

  // next five added at Ireland's request 3/27/98
#define  vendoridSYS                70  // Croatian - Spelling:Mssp_cr.lex, Mspcr32.dll
#define  vendoridTilde              71  // Latvian - Spelling:Mssp_lv.lex, Msplv32.dll
#define  vendoridSignum             72  // Spanish - Spelling:Mssp3es.lex, Mssp3es.dll
#define  vendoridProLing            73  // Ukrainian - Spelling:Mssp3ua.lex, Mssp3ua.dll
#define  vendoridItautecPhilcoSA    74  // Brazilian - Spelling:mssp3PB.lex, Mssp3PB.dll

#define vendoridPriberam             75     /* Priberam Informtica - Portuguese - 7/13/98 */
#define vendoridTranquility     76  /* Tranquility Software - Vietnamese - 7/22/98 */

#define vendoridColtec          77  /* Coltec - Arabic - added 8/17/98 */

/*************** legacy codes ******************/

/* Spell Engine Id's */
#define sidSA    vendoridSoftArt      /* Reserved */
#define sidInso  vendoridInso      /* Inso */
#define sidHM    sidInso      /* Inso was Houghton Mifflin */
#define sidML    3      /* MicroLytics */
#define sidLS    4      /* LanSer Data */
#define sidCT    5      /* Center of Educational Technology */
#define sidHS    6      /* HSoft - Turkish(mssp_tr.lex, Msptr32.dll)*/
#define sidMO    7      /* Morphologic - Romanian(Mssp_ro.lex, Msthro32.dll) and Hungarian(Mssp_hu.lex, Msphu32.dll) */
#define sidTI    8      /* TIP - Polish(Mssp_pl.lex, Mspl32.dll) */
#define sidTIP sidTI
#define sidKF    9      /* Korean Foreign Language University */
#define sidKFL sidKF
#define sidPI    10     /* Priberam Informatica Lince - Portuguese(Mssp3PT.lex, Mssp3PT.dll) */
#define sidPIL sidPI
#define sidColtec   11  /* Coltec (Arabic) */
#define sidGS    sidColtec     /* Glyph Systems - this was an error */
#define sidRA    12     /* Radiar (Romansch) */
#define sidIN    13     /* Intracom - Greek(Mssp_el.lex, Mspel32.dll) */
#define sidSY    14     /* Sylvan */
#define sidHI    15     /* Hizkia (obsolete - use vendoridHizkia) */
#define sidFO    16     /* Forma - Slovak(Mssp_sk.lex, Mspsk32.dll) */
#define sidIF    vendoridInformatic     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define sidAM    vendoridAmebis     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define sidLO    vendoridLogos     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define sidDT    vendoridDatecs     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define sidFS    vendoridFilosoft     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define sidLI    vendoridLingsoft     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define sidPL    vendoridPolderland     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */

  /* Thesaurus Engine Id's */
#define teidSA    vendoridSoftArt
#define teidInso  vendoridInso    /* Inso */
#define teidHM    teidInso    /* Inso was Houghton-Mifflin */
#define teidIF    3    /* Informatic */
#define teidIN    4    /* Intracom */
#define teidMO    5    /* MorphoLogic */
#define teidTI    6    /* TiP */
#define teidPI    7    /* Priberam Informatica Lince */
#define teidAM    8    /* Amebis */
#define teidDT    9    /* Datecs */
#define teidES   10    /* Expert System */
#define teidFS   11    /* Filosoft */
#define teidFO   12    /* Forma */
#define teidHS   13    /* HSoft */
#define teidLI   14    /* Lingsoft */
#define teidLO   15    /* Logos */
#define teidPL   16    /* Polderland */

/* HYphenation Engine ID's */
#define hidSA    vendoridSoftArt
#define hidHM    vendoridInso      /* Houghton Mifflin */
#define hidML    3      /* MicroLytics */
#define hidLS    4      /* LanSer Data */
#define hidFO    5      /* Forma */
#define hidIF    6      /* Informatic */
#define hidAM    7      /* Amebis */
#define hidDT    8      /* Datecs */
#define hidFS    9      /* Filosoft */
#define hidHS   10      /* HSoft */
#define hidLI   11      /* Lingsoft */
#define hidLO   12      /* Logos */
#define hidMO   13      /* MorphoLogic */
#define hidPL   14      /* Polderland */
#define hidTI   15      /* TiP */

/* Grammar Id Engine Defines */
#define geidHM    1    /* Houghton-Mifflin */
#define geidRF    2    /* Reference */
#define geidES    3    /* Expert System */
#define geidLD    4    /* Logidisque */
#define geidSMK   5    /* Sumitomo Kinzoku (Japanese) */
#define geidIF    6    /* Informatic */
#define geidMO    7    /* MorphoLogic */
#define geidMS    8    /* Microsoft Reserved */
#define geidNO    9    /* Novell */
#define geidCTI  10    /* CTI (Greek) */
#define geidAME  11    /* Amebis (Solvenian) */
#define geidTIP  12    /* TIP (Polish) */

#endif  /* VENDOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\ctplus0.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
//  File:       ctplus.h
//
//  Contents:   Local definitions for ctplus.c
//
//  History:    23-May-96   pathal      Created.
//              11-Nov-97   Weibz       Add Thai char
//
//---------------------------------------------------------------------------

#ifndef _CTPLUS_0_H_
#define _CTPLUS_0_H_

#define HC       0x01                             // Hiragana char
#define IC       0x02                             // Ideograph char
#define KC       0x03                             // Katakana char
#define WS       0x04                             // Word seperator
#define VC       0x05                             // Hankaku (variant) char
#define PS       0x06                             // Phrase seperator
#define CH       0x07                             // Code page 0 - ASCII Char.

BYTE
GetCharType(WCHAR wc);

// Declare character types transitions
// Intuitively frequency ordered
//
typedef enum _CT {
   CT_START       = 0x00,
   CT_HIRAGANA    = 0x01,
   CT_KANJI       = 0x02,
   CT_KATAKANA    = 0x03,
   CT_WORD_SEP    = 0x04,
   CT_HANKAKU     = 0x05,
   CT_PHRASE_SEP  = 0x06,
   CT_ROMAJI      = 0x07,
} CT;


// Declare node types transitions
// Intuitively frequency ordered
//
typedef enum _WT {
   WT_START       = 0x00,
   WT_WORD_SEP    = 0x01,
   WT_PHRASE_SEP  = 0x02,
   WT_ROMAJI      = 0x03,
   WT_REACHEND    = 0x04,
} WT;


#define CT_MAX    0x08

#endif // _CTPLUS_0_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\sth\wzmanip.cpp ===
#include "wzmanip.h"
#include <assert.h>

//////////////////////////////////////////////////////////////////////////
// Wzncpy
//
// Copies the lesser of len(wzFrom) or n characters (n includes the
// null terminator) from wzFrom to wzTo.
WCHAR * Wzncpy(WCHAR* wzTo, const WCHAR* wzFrom, unsigned int cchTo)
{
	if (cchTo <= 0 || !wzTo || !wzFrom)
		return wzTo;
	
	unsigned int cchFrom = (unsigned int) (wcslen(wzFrom) + 1);

	if (cchTo >= cchFrom)
	{
		memmove(wzTo, wzFrom, cchFrom*2);
		return wzTo + cchFrom - 1;
	}
	else
	{
		cchFrom = cchTo - 1;
		memmove(wzTo, wzFrom, cchFrom*2);
		wzTo[cchFrom] = 0;
		return wzTo+cchFrom;
	}

}

//////////////////////////////////////////////////////////////////////////
// Szncpy
//
// Copies the lesser of len(szFrom) or n characters (n includes the
// null terminator) from wzFrom to szTo.
char * Szncpy(char* szTo, const char* szFrom, unsigned int cchTo)
{
	if (cchTo <= 0 || !szTo || !szFrom)
		return szTo;
	
	unsigned int cchFrom = (unsigned int)(strlen(szFrom) + 1);

	if (cchTo >= cchFrom)
	{
		memmove(szTo, szFrom, cchFrom);
		return szTo + cchFrom - 1;
	}
	else
	{
		cchFrom = cchTo - 1;
		memmove(szTo, szFrom, cchFrom);
		szTo[cchFrom] = 0;
		return szTo+cchFrom;
	}

}

//////////////////////////////////////////////////////////////////////////
// WznCat
//
// Append wzFrom onto wzTo.
WCHAR* WznCat(WCHAR* wzTo, const WCHAR* wzFrom, unsigned int cchTo)
{
	while (*wzTo != L'\0')
	{
		wzTo++;
		cchTo--;
	}
	if (cchTo <= 0)
	{
		return wzTo;
	}

	unsigned int cchFrom = (unsigned int)(wcslen(wzFrom) + 1);

	if (cchTo >= cchFrom)
	{
		memmove(wzTo, wzFrom, cchFrom*sizeof(WCHAR));
		return wzTo + cchFrom - 1;
	}
	else
	{
		cchFrom = cchTo - 1;
		memmove(wzTo, wzFrom, cchFrom*sizeof(WCHAR));
		wzTo[cchFrom] = 0;
		return wzTo+cchFrom;
	}
}

//////////////////////////////////////////////////////////////////////////
// SznCat
//
// Append szFrom onto szTo.
char* SznCat(char* szTo, const char* szFrom, unsigned int cchTo)
{
	while (*szTo != L'\0')
	{
		szTo++;
		cchTo--;
	}
	if (cchTo <= 0)
	{
		return szTo;
	}

	unsigned int cchFrom = (unsigned int)(strlen(szFrom) + 1);

	if (cchTo >= cchFrom)
	{
		memmove(szTo, szFrom, cchFrom);
		return szTo + cchFrom - 1;
	}
	else
	{
		cchFrom = cchTo - 1;
		memmove(szTo, szFrom, cchFrom);
		szTo[cchFrom] = 0;
		return szTo+cchFrom;
	}
}


//
/*------------------------------------------------------------------------
	MsoWzDecodeUInt

	Decodes the integer w into Unicode text in base wBase.
	Returns the length of the text decoded.
---------------------------------------------------------------- RICKP -*/
const char rgchHex[] = "0123456789ABCDEF";
int MsoWzDecodeUint(WCHAR* rgwch, int cch, unsigned u, int wBase)
{
	assert(wBase >= 2 && wBase <= 16);

	if (cch == 1)
		*rgwch = 0;
	if (cch <= 1)
		return 0;

	if (u == 0)
		{
		rgwch[0] = L'0';
		rgwch[1] = 0;
		return 1;
		}

	int cDigits = 0;
	unsigned uT = u;

	while(uT)
		{
		cDigits++;
		uT /= wBase;
		};
	if (cDigits >= cch)
		return 0;
	rgwch += cDigits;
	*rgwch-- = 0;
	uT = u;
	while(uT)
		{
		*rgwch-- = rgchHex[uT % wBase];
		uT /= wBase;
		};

	return cDigits;
}


/*------------------------------------------------------------------------
	MsoWzDecodeInt

	Decodes the signed integer w into ASCII text in base wBase. The string
	is stored in the rgch buffer, which is assumed to be large enough to hold
	the number's text and a null terminator. Returns the length of the text
	decoded.
---------------------------------------------------------------- RICKP -*/
int MsoWzDecodeInt(WCHAR* rgwch, int cch, int w, int wBase)
{
	if (cch <= 0)
		{
		assert(cch == 0);
		return 0;
		};

	if (w < 0)
		{
		*rgwch = '-';
		return MsoWzDecodeUint(rgwch+1, cch-1, -w, wBase) + 1;
		}
	return MsoWzDecodeUint(rgwch, cch, w, wBase);

}

/*------------------------------------------------------------------------
	MsoSzDecodeUint

	Decodes the unsigned integer u into ASCII text in base wBase. The string
	is stored in the rgch buffer, which is assumed to be large enough to hold
	the number's text and a null terminator. Returns the length of the text
	decoded.
---------------------------------------------------------------- RICKP -*/
int MsoSzDecodeUint(char* rgch, int cch, unsigned u, int wBase)
{
	assert(wBase >= 2 && wBase <= 16);

	if (cch == 1)
		*rgch = 0;
	if (cch <= 1)
		return 0;

	if (u == 0)
		{
		rgch[0] = '0';
		rgch[1] = 0;
		return 1;
		}

	int cDigits = 0;
	unsigned uT = u;

	while(uT)
		{
		cDigits++;
		uT /= wBase;
		};
	if (cDigits >= cch)
		return 0;
	rgch += cDigits;
	*rgch-- = 0;
	uT = u;
	while(uT)
		{
		*rgch-- = rgchHex[uT % wBase];
		uT /= wBase;
		};

	return cDigits;
}

/*------------------------------------------------------------------------
	MsoSzDecodeInt

	Decodes the signed integer w into ASCII text in base wBase. The string
	is stored in the rgch buffer, which is assumed to be large enough to hold
	the number's text and a null terminator. Returns the length of the text
	decoded.
---------------------------------------------------------------- RICKP -*/
int MsoSzDecodeInt(char* rgch, int cch, int w, int wBase)
{
	if (cch <= 0)
		{
		assert(cch == 0);
		return 0;
		};

	if (w < 0)
		{
		*rgch = '-';
		return MsoSzDecodeUint(rgch+1, cch-1, -w, wBase) + 1;
		}
	return MsoSzDecodeUint(rgch, cch, w, wBase);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\init.cxx ===
//  ----------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  Routine:    DllMain
//
//  Description:
//
//  Returns:    True if successful, else False.
//  History:    Weibz, 10-Nov-1997,  created it.
//
//---------------------------------------------------------------------------

#include <pch.cxx>
#include "thwbint.h"
#include "resource.h"
CRITICAL_SECTION ThCritSect;

//SCRIPTITEMIZE   ScriptItemize;
//SCRIPTBREAK     ScriptBreak;
HMODULE         hUsp;

BOOL InitWordBreakEngine(HINSTANCE hInstance)
{
	LPBYTE lpLexicon = NULL;
	LPBYTE lpTrigram = NULL;
	HGLOBAL hLexicon = NULL;
	HGLOBAL hTrigram = NULL;
	HRSRC hrsrcLexicon = FindResource(hInstance,(LPSTR) MAKEINTRESOURCE(IDR_LEXICON1),"LEXICON");
	HRSRC hrsrcTrigram = FindResource(hInstance,(LPSTR) MAKEINTRESOURCE(IDR_LEXICON2),"LEXICON");

	// Check if we were able to find resource.
	if (NULL == hrsrcLexicon || NULL == hrsrcTrigram)
	{
		assert(false);
		return FALSE;
	}

	hLexicon = LoadResource(hInstance, hrsrcLexicon);
	hTrigram = LoadResource(hInstance, hrsrcTrigram);

	// Check if we were able to load resource.
	if (NULL == hLexicon || NULL == hTrigram)
	{
		assert(false);
		return FALSE;
	}

	lpLexicon = (LPBYTE) LockResource(hLexicon);
	lpTrigram = (LPBYTE) LockResource(hTrigram);

	if (ThaiWordBreakInitResource(lpLexicon,lpTrigram, FALSE) != ptecNoErrors)
	{
		assert(false);
		return FALSE;
	}

	return TRUE;
}


BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{

    CHAR      szUSPPath[MAX_PATH];

    switch(dwReason) 
    {
       case DLL_PROCESS_ATTACH : 
          DisableThreadLibraryCalls(hDLL);
          InitializeCriticalSection (&ThCritSect);

/*
          GetSystemDirectory ( szUSPPath, MAX_PATH );

          strcat ( szUSPPath, "\\USP.DLL" );
          hUsp = LoadLibrary (szUSPPath);

          if ( hUsp == NULL ) 
             return FALSE;

          ScriptItemize = (SCRIPTITEMIZE)GetProcAddress(hUsp,"ScriptItemize");
          ScriptBreak = (SCRIPTBREAK) GetProcAddress(hUsp,"ScriptBreak");

          if ( (ScriptItemize==NULL) || (ScriptBreak==NULL) )
             return FALSE;
*/
		  return InitWordBreakEngine(hDLL);
          break ;

       case DLL_THREAD_ATTACH:
            break;
       case DLL_THREAD_DETACH:
            break;
       case DLL_PROCESS_DETACH  :
/*            
            if (hUsp != NULL )
               FreeLibrary(hUsp);
              
            hUsp = NULL;
*/
			ThaiWordBreakTerminate();
            DeleteCriticalSection (&ThCritSect);
            break ;
      }   //switch
 
      return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\ctplus0.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999.
//
//  File:       ctplus.c
//
//  Contents:   Contains character type (orthography) data and routine
//                    to get at it.
//
//  History:    23-May-96   pathal      Created.
//              11-Nov-97   weibz       Add Thai char support
//
//---------------------------------------------------------------------------


//#include <windows.h>
//#include "ctplus0.h"

#include "pch.cxx"


//----------------------------------------------------------------------------
//  s_abBreakList
//
//  This array starts at -1, so that EOF can be found in the array.  It
//  depends on (EOF == -1) being true.  Also, all references to it must be
//  of the form (s_abCharTypeList+1)[x]
//
//  000
//  EOF
//
//  001-080
//  The lower 7F entries from the ASCII Code Page (0000-00ff) are mapped in place
//  (ex. UNICODE 0009 (HT) == 009)
//      The word characters are: $,0-9,A-Z,_,a-z
//      The word separators are: bs,tab,lf,vtab,cr,spc,
//                               ",#,%,&,',(,),*,+,comma,-,/,
//                               :,;,<,=,>,@,[,],`
//      The phrase seperators are: !,.,?,\,^,{,|,},~
//
//  NOTE: Symbols are treated as WS or PS.
//
//  081-0FF
//  The lower 7E entries from the Half Width Variant Code Page (FF00-FF7F) are
//  mapped to 081-0FF.
//
//  100-1FF
//  The lower FF entries from the General Punctuation Code Page (2000-2044) are
//  mapped to 100-1ff.
//
//  200-2FF
//  The lower FF entries from the CJK Auxiliary Code Page (3000-30FF) are mapped
//  to 200-2ff.
//
// pathal - 5/20/96
// Special default character processing for selection
// The following is a list of white space characters that T-Hammer will not right select on:
//          0x0009 (tab), 0x0020 (ansi space), 0x2005 (narrow space, 0x3000 (wide space)
// (Note: see AnalyzeHPBs for special end SPB processing of adjacent white space)
// The following is a list of nls characters to be treated as text by T-Hammer:
//      (in other words T-Hammer will neither right nor left-select on them):
//          0x001F (non-required hyphen), 0x0027 (single quote), 0x2019 (right quote),
//          0x200C (non-width optional break), 0x200D (non-width no break)
//----------------------------------------------------------------------------

const BYTE
s_abCharTypeList[0x301] =
    {
        (BYTE) -1,                                       // EOF (-1)
        PS,PS,PS,PS,PS,PS,PS,PS, WS,WS,WS,WS,PS,WS,PS,PS, // 000 - 015
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,CH,PS, // 016 - 031
        WS,PS,WS,WS,CH,CH,WS,PS,                          // sp ! " # $ % & '
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  0 1 2 3 4 5 6 7
        CH,CH,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  @ A B C D E F G
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  H I J K M L N O
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  P Q R S T U V Y
        CH,CH,CH,WS,PS,WS,PS,CH,                          //  X Y Z [ \ ] ^ _
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  ` a b c d e f g
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  h i j k m l n o
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  p q r s t u v y
        CH,CH,CH,PS,PS,PS,CH,PS,                          //  x y z { | } ~ del
        WS,PS,WS,WS,CH,CH,WS,WS,                          //  FF00-FF07 (sp ! " # $ % & ')
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  0 1 2 3 4 5 6 7
        VC,VC,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  @ A B C D E F G
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  H I J K M L N O
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  P Q R S T U V Y
        VC,VC,VC,WS,VC,WS,PS,VC,                          //  X Y Z [ \ ] ^ _
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  ` a b c d e f g
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  h i j k m l n o
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  p q r s t u v y
        VC,VC,VC,PS,PS,PS,VC,PS,                          //  x y z { | } ~ del
        VC,PS,WS,WS,WS,WS,VC,VC,                          //  FF60-FF67
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF68-FF6F
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF77
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF7E
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2000-2007
        WS,WS,WS,WS,CH,CH,WS,WS,                          //  2008-200F
        WS,CH,WS,WS,WS,KC,PS,WS,                          //  2010-2017
        WS,CH,WS,WS,WS,WS,WS,WS,                          //  2018-201F
        WS,WS,PS,PS,PS,PS,PS,CH,                          //  2020-2027
        PS,PS,CH,CH,CH,CH,CH,PS,                          //  2028-202F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2030-2037
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2038-203F
        WS,WS,WS,PS,WS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2040-204F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2050-205F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2060-206F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2070-207F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2080-208F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2090-209F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20A0-20AF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20B0-20BF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20C0-20CF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20D0-20DF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20E0-20EF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20F0-20FF
        WS,WS,PS,HC,HC,IC,IC,HC,                          //  3000-3007
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3008-300F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3010-3017
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3018-301F
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3020-3027
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3028-302F
        WS,HC,IC,HC,IC,HC,HC,HC,                          //  3030-3037
        PS,PS,PS,PS,PS,PS,PS,WS,                          //  3038-303F
        WS,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3040-304F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3050-305F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3060-306F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3070-307F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3080-308F
        HC,HC,HC,HC,HC,PS,PS,PS,                          //  3090-3097
        PS,HC,HC,WS,WS,HC,HC,PS,                          //  3098-309F
        WS,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30A0-30AF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30B0-30BF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30C0-30CF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30D0-30DF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30E0-30EF
        KC,KC,KC,KC,KC,KC,IC,PS,                          //  30F0-30F7
        PS,PS,PS,WS,KC,KC,KC,PS,                          //  30F8-30FF
    };

//
// Type C1 bits are:
//
//   C1_UPPER                  0x0001      // upper case
//   C1_LOWER                  0x0002      // lower case
//   C1_DIGIT                  0x0004      // decimal digits             1
//   C1_SPACE                  0x0008      // spacing characters         2
//   C1_PUNCT                  0x0010      // punctuation characters     4
//   C1_CNTRL                  0x0020      // control characters         8
//   C1_BLANK                  0x0040      // blank characters          10
//   C1_XDIGIT                 0x0080      // other digits              20
//   C1_ALPHA                  0x0100      // any linguistic character  40
//
// But since I don't care about C1_UPPER and C1_LOWER I can right-shift
// the output of GetStringTypeEx and keep a 128 Byte lookup table.
//
// The precedence rules are: (Alpha, XDigit, Digit) --> CH
//                           (Punct) --> PS
//                           (Space, Blank, Control) --> WS
//

const BYTE
s_abCTypeList[128] =
    {
      WS, CH, WS, CH, PS, CH, WS, CH,   // 00 - 07
      WS, CH, WS, CH, PS, CH, WS, CH,   // 08 - 0F
      WS, CH, WS, CH, PS, CH, WS, CH,   // 10 - 17
      WS, CH, WS, CH, PS, CH, WS, CH,   // 18 - 1F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 40 - 47
      CH, CH, CH, CH, CH, CH, CH, CH,   // 48 - 4F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 50 - 57
      CH, CH, CH, CH, CH, CH, CH, CH,   // 58 - 5F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 60 - 67
      CH, CH, CH, CH, CH, CH, CH, CH,   // 68 - 6F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 70 - 77
      CH, CH, CH, CH, CH, CH, CH, CH,   // 78 - 7F
    };

//+---------------------------------------------------------------------------
//
//  Synopsis:   Returns the type of a character
//
//  Arguments:  [c]   -- Unicode Character
//
//  Returns:    type, one of CH, WS, PS, EOF
//
//  History:    10-Sep-97   Weibz
//
//  Notes:      This returns the type of a character, using the static
//              array s_abCharTypeList.  It adds 1 so that EOF (-1) can be in
//              the array, and accessed normally.
//
//              This is not done by overloading the [] opeator, because in
//              future versions it will not necessarly be a table lookup.
//
//  See above (typeof comments) for an explanation of the mapping
//
//----------------------------------------------------------------------------
BYTE
GetCharType(WCHAR wc )
{
    WCHAR wc2;

    // Map interesting stuff (0000, 2000, 3000, FF00) to the table range,
    // 0x0000 - 0x0300.
    //
    wc2 = (wc & 0x00FF);

    switch (wc & 0xFF00) {

        case 0xFF00:  // Half-Width Variants
            if (wc2 & 0x80) {
                return(VC);  // including Hangul
            }
            wc2 |=  0x0080;
            break;

        case 0xFE00:  // Small Variants
            if ((wc2 <= 0x006B) && (wc2 != 0x0069)) {
                return(WS);
            }
            // Treat Small $ and arabic symbols as CH
            return(CH);
            // break;

        case 0x3000:  // CJK Auxiliary
            wc2 |=  0x0200;
            break;

        case 0x2000:  // General Punctuation
            wc2 |=  0x0100;
            break;

        case 0x0000:  // Code page 0
            // Use System NLS map for code page 0
            if (wc2 & 0x80)
            {
                WORD wCharType = 0;

                GetStringTypeExW( MAKELANGID( LANG_THAI, SUBLANG_DEFAULT ),
                                  CT_CTYPE1,
                                  &wc2,
                                  1,
                                  &wCharType );
                return s_abCTypeList[wCharType >> 2];
            }
            break;

        default:
            //
            // Treat the whole CJK Range as Kanji
            //
            if ((wc >= 0x4E00) && (wc <= 0x9FFF)) {
                return(IC);
            }

            //
            // Treat All Gaiji as Kanji Char, too
            //
            if ((wc >= 0xE000) && (wc < 0xE758)) {
                return(IC);
            }

            //
            // Treat all CJK symbols as word separators
            // NOTE: This means that the stemmer must be smart about searching
            // for zipcodes when given one with a preceding zipcode char.
            //
            if ((wc >= 0x3200) && (wc <= 0x33DD)) {
                return(WS);
            }

            // If it's not interesting return CH as default;
            return(CH);
            // break;
    }

    return( (s_abCharTypeList+1)[wc2] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:     weibz,   10-Sep-1997   created 
//
//--------------------------------------------------------------------------
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>


#include <cierror.h>
#include <query.h>
#include <except.hxx>

#include <assert.h>

#include <usp10.h>

#include  "ctplus0.h"

#undef Assert
#define Assert(a)

// Base services
//

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\exports.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       exports.cxx
//
//  Contents:   Code to export word breaker class factories
//
//  History:     weibz,   11-10-1997   created 
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include <classid.hxx>
#include <wbclassf.hxx>
#include <stemcf.hxx>

long gulcInstances = 0;

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE
DllGetClassObject(
    REFCLSID   cid,
    REFIID     iid,
    void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

//    __try {

        switch ( cid.Data1 ) {

        // Thai language wordbreaker
        //
		case 0xB66F590A:
        case 0xcca22cf4:
           if ( cid == CLSID_Thai_Default_WBreaker ) {
             pResult = (IUnknown *) new CWordBreakerCF(
                MAKELCID( MAKELANGID(LANG_THAI, SUBLANG_DEFAULT),
                SORT_DEFAULT ));
			 if (pResult) {
				sc = pResult->QueryInterface( iid, ppvObj );
				pResult->Release(); // Release extra refcount from QueryInterface
			 }
			 else
				 sc = E_NOINTERFACE;
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Thai language stemmer
        //
		case 0x52CC7D83:
        case 0xcedc01c7:
           if ( cid == CLSID_Thai_Default_Stemmer )
           {
             pResult = (IUnknown *) new CStemmerCF(
                MAKELCID( MAKELANGID(LANG_THAI, SUBLANG_DEFAULT),
                SORT_DEFAULT ));
			 if (pResult) {
				sc = pResult->QueryInterface( iid, ppvObj );

				pResult->Release(); // Release extra refcount from QueryInterface
			 }
			 else
				 sc = E_NOINTERFACE;
           }
           else
              sc = E_NOINTERFACE;
           break;

        default:
             sc = E_NOINTERFACE;
        }
 /*   } __except(1) {

        if ( pResult )
            pResult->Release();

        sc = E_UNEXPECTED;
    }  */

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:     weibz,   11-10-1997   created 
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( gulcInstances <= 0 )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\iwbreak.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       IWBreak.cxx
//
//  Contents:   Thai  Word Breaker glue code
//
//  History:   weibz,   10-Nov-1997   created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#include <filterr.h>
#include "iwbreak.hxx"
#include "thwbint.h"
#define MAX_BREAKS 255
#define WB_NORMAL 1
extern  long            gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::CWordBreaker
//
//  Synopsis:   Constructor for the CWordBreaker class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CWordBreaker::CWordBreaker( LCID lcid )
        : _cRefs(1),
          _lcid(lcid)
{

    InterlockedIncrement( &gulcInstances );

}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::~CWordBreaker
//
//  Synopsis:   Destructor for the CWordBreaker class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CWordBreaker::~CWordBreaker()
{
   InterlockedDecrement( &gulcInstances );


}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::QueryInterface( REFIID riid, void  ** ppvObject)
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IWordBreaker == riid )
        *ppvObject = (IUnknown *)(IWordBreaker *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject =  (IUnknown *)this;
    else
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp ) 
        delete this;


    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Init
//
//  Synopsis:   Initialize word-breaker
//
//  Arguments:  [fQuery]         -- TRUE if query-time
//              [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::Init(
    BOOL fQuery,
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{
    if ( NULL == pfLicense ) {
       return E_INVALIDARG;
    }


    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *pfLicense = TRUE;
    _fQuery = fQuery;
    _ulMaxTokenSize = ulMaxTokenSize;


    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::ComposePhrase
//
//  Synopsis:   Convert a noun and a modifier into a phrase.
//
//  Arguments:  [pwcNoun] -- pointer to noun.
//              [cwcNoun] -- count of chars in pwcNoun
//              [pwcModifier] -- pointer to word modifying pwcNoun
//              [cwcModifier] -- count of chars in pwcModifier
//              [ulAttachmentType] -- relationship between pwcNoun &pwcModifier
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::ComposePhrase(
    WCHAR const *pwcNoun,
    ULONG cwcNoun,
    WCHAR const *pwcModifier,
    ULONG cwcModifier,
    ULONG ulAttachmentType,
    WCHAR *pwcPhrase,
    ULONG *pcwcPhrase )
{
    //
    // Need to code in later
    //
    if ( _fQuery )
        return( E_NOTIMPL );
    else
        return ( WBREAK_E_QUERY_ONLY );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::GetLicenseToUse(
    const WCHAR **ppwcsLicense )
{

    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1998";


    if ( NULL == ppwcsLicense )  {
       return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *ppwcsLicense = wcsCopyright;
    return( S_OK );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::BreakText
//
//  Synopsis:   Break input stream into words.
//
//  Arguments:  [pTextSource] -- source of Unicode text
//              [pWordSink] -- sink for collecting words
//              [pPhraseSink] -- sink for collecting phrases
//
//  History:    10-Nov-1997, WeibZ,       Created.
//
//  Notes:      Since the input buffer may be greater than MAX_II_BUFFER_LEN
//              we process the buffer in chunks of length MAX_II_BUFFER_LEN.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CWordBreaker::BreakText( TEXT_SOURCE *pTextSource,
                                                 IWordSink *pWordSink,
                                                 IPhraseSink *pPhraseSink )
{
    SCODE                               sc = S_OK;
    ULONG                               cwc;
    SCRIPT_ITEM                 *pItems, *pItem_Next, *pItem_org;
    SCRIPT_ANALYSIS             *psa;
    PCWSTR                              pwcInChars;
    INT                                 iItems;
    BOOL                                bItemProc;
    PCWSTR                              pwcChars;
    INT                                 cChars;
    HRESULT                             retUSP;
        BOOL                            fSucceeded = true;

    if ( NULL == pTextSource ) {
       return E_INVALIDARG;
    }

    if ( NULL == pWordSink )
    {
        // BUGBUG, propagate the null word sink error code
        return sc;
    }


    if ( 0 != pPhraseSink )
    {
        // ignore the phrase sink for now
        // return sc;
    }

    if (pTextSource->iEnd == pTextSource->iCur) {
       return S_OK;
    }

    Assert( pTextSource->iCur < pTextSource->iEnd );


    __try 
    {
        do
                {

            if ( pTextSource->iCur >= pTextSource->iEnd )
               continue;

            cwc = pTextSource->iEnd - pTextSource->iCur;
            pwcInChars = pTextSource->awcBuffer + pTextSource->iCur;
            
            
            pItems = (SCRIPT_ITEM *)LocalAlloc(LPTR,sizeof(SCRIPT_ITEM)*(cwc+1));

            if ( !pItems) {

                return E_UNEXPECTED;
            }

            pItem_org = pItems; 

           
            iItems = 0; 
            retUSP = ScriptItemize(pwcInChars,cwc,cwc+1, NULL, NULL, 
                                   pItems, &iItems);

            if (retUSP != S_OK) {
                LocalFree(pItem_org);
                return  E_UNEXPECTED;
            }

            while  ( iItems > 1 ) {
                                pItem_Next = pItems + 1;
                                pwcChars =  pwcInChars + pItems->iCharPos;
                                cChars   =  pItem_Next->iCharPos - pItems->iCharPos;

                                sc = ProcessItem(       pwcChars,
                                                                        cChars,
                                                                        pItems,
                                                                        FALSE,   // no need to keep chars
                                                                        pTextSource,
                                                                        pWordSink, 
                                                                        pPhraseSink);

                                if ( ( FAILED( sc ) ) &&
                                         ( FILTER_E_NO_MORE_VALUES != sc ) &&
                                         ( FILTER_E_NO_TEXT != sc ) &&
                                         ( FILTER_E_NO_VALUES != sc ) &&
                                         ( FILTER_E_NO_MORE_TEXT != sc ) &&
                                         ( FILTER_E_END_OF_CHUNKS != sc ) &&
                                         ( FILTER_E_EMBEDDING_UNAVAILABLE != sc ) &&
                                         ( WBREAK_E_END_OF_TEXT != sc ) ) {
                                        LocalFree(pItem_org);
                                        return  sc;
                                }

                                sc = S_OK;

                                pItems++;
                                iItems--;

            }

            //  special handle for the last item
            if ( iItems == 1 ) {

                                pwcChars = pwcInChars + pItems->iCharPos;
                                cChars = pTextSource->iEnd - pTextSource->iCur; 

                                sc = ProcessItem(pwcChars,
                                                                        cChars,
                                                                        pItems,
                                                                        TRUE,  // need to keep chars
                                                                        pTextSource,
                                                                        pWordSink,
                                                                        pPhraseSink);

                                if ( ( FAILED( sc ) ) &&
                                         ( FILTER_E_NO_MORE_VALUES != sc ) &&
                                         ( FILTER_E_NO_TEXT != sc ) &&
                                         ( FILTER_E_NO_VALUES != sc ) &&
                                         ( FILTER_E_NO_MORE_TEXT != sc ) &&
                                         ( FILTER_E_END_OF_CHUNKS != sc ) &&
                                         ( FILTER_E_EMBEDDING_UNAVAILABLE != sc ) &&
                                         ( WBREAK_E_END_OF_TEXT != sc ) ) {
                                        LocalFree(pItem_org);
                                        return  sc;
                                }

                                sc = S_OK;
                        }

            if (pItem_org)
               LocalFree(pItem_org);

                        // O11.17064. Under low memory it is possible to pfnFillTextBuffer to failed.
                        // We will need to return the error of TextSource for loging to Sharepoint.
                        sc = pTextSource->pfnFillTextBuffer(pTextSource);
                        fSucceeded = SUCCEEDED(sc);             

                        if ( ( FAILED( sc ) ) &&
                                 ( FILTER_E_NO_MORE_VALUES != sc ) &&
                                 ( FILTER_E_NO_TEXT != sc ) &&
                                 ( FILTER_E_NO_VALUES != sc ) &&
                                 ( FILTER_E_NO_MORE_TEXT != sc ) &&
                                 ( FILTER_E_END_OF_CHUNKS != sc ) &&
                                 ( FILTER_E_EMBEDDING_UNAVAILABLE != sc ) &&
                                 ( WBREAK_E_END_OF_TEXT != sc ) ) {
                                return sc;
                                }

                        sc = S_OK;

        } while (fSucceeded);


        if ( pTextSource->iCur < pTextSource->iEnd ) {

            cwc = pTextSource->iEnd - pTextSource->iCur;
            pwcInChars = pTextSource->awcBuffer + pTextSource->iCur;
            
            pItems = (SCRIPT_ITEM *)LocalAlloc(LPTR,sizeof(SCRIPT_ITEM)*(cwc+1));

            if ( !pItems ) {

                return E_UNEXPECTED;
            }

            pItem_org = pItems;


            iItems = 0; 
            retUSP = ScriptItemize(pwcInChars,cwc,cwc+1, NULL, NULL,
                                   pItems, &iItems);

            if (retUSP != S_OK) {
                LocalFree(pItem_org);
                return  E_UNEXPECTED;
            }

            while  ( iItems > 1 ) {
                                pItem_Next = pItems + 1;
                                pwcChars =  pwcInChars + pItems->iCharPos;
                                cChars   =  pItem_Next->iCharPos - pItems->iCharPos;
                                
                                sc = ProcessItem(pwcChars,
                                                                        cChars,
                                                                        pItems,
                                                                        FALSE,  // no need to keep chars
                                                                        pTextSource,
                                                                        pWordSink,
                                                                        pPhraseSink);

                                if ( ( FAILED( sc ) ) &&
                                         ( FILTER_E_NO_MORE_VALUES != sc ) &&
                                         ( FILTER_E_NO_TEXT != sc ) &&
                                         ( FILTER_E_NO_VALUES != sc ) &&
                                         ( FILTER_E_NO_MORE_TEXT != sc ) &&
                                         ( FILTER_E_END_OF_CHUNKS != sc ) &&
                                         ( FILTER_E_EMBEDDING_UNAVAILABLE != sc ) &&
                                         ( WBREAK_E_END_OF_TEXT != sc ) ) {
                                        LocalFree(pItem_org);
                                        return  sc;
                                }

                                sc = S_OK;

                                pItems++;
                                iItems--;
                        }

            if ( iItems == 1 ) {
                                
                                pwcChars = pwcInChars + pItems->iCharPos;
                                cChars = pTextSource->iEnd - pTextSource->iCur;

                                sc = ProcessItem(pwcChars,
                                                                        cChars,
                                                                        pItems,
                                                                        FALSE,    // no need to keep chars
                                                                        pTextSource,
                                                                        pWordSink,
                                                                        pPhraseSink);

                                if ( ( FAILED( sc ) ) &&
                                         ( FILTER_E_NO_MORE_VALUES != sc ) &&
                                         ( FILTER_E_NO_TEXT != sc ) &&
                                         ( FILTER_E_NO_VALUES != sc ) &&
                                         ( FILTER_E_NO_MORE_TEXT != sc ) &&
                                         ( FILTER_E_END_OF_CHUNKS != sc ) &&
                                         ( FILTER_E_EMBEDDING_UNAVAILABLE != sc ) &&
                                         ( WBREAK_E_END_OF_TEXT != sc ) ) {
                                        LocalFree(pItem_org);
                                        return  sc;
                                }

                                sc = S_OK;
                        }

            if ( pItem_org ) 
               LocalFree(pItem_org);
        }

    } __except(1) {

       sc = E_UNEXPECTED;
   }

    return sc;
}

SCODE CWordBreaker::ProcessItem( 
                     PCWSTR        pwcChars,
                     INT           cChars,
                     SCRIPT_ITEM   *pItems,
                     BOOL          fKeep,
                     TEXT_SOURCE  *pTextSource,     
                     IWordSink    *pWordSink,
                     IPhraseSink  *pPhraseSink )
{
    INT                                         iChar,i;
    INT                                         iWord, iWordStart, iWordLen;
    const SCRIPT_PROPERTIES **pScript_Properties;
    DWORD                                       LangID;
    WORD                                        iScript;
    HRESULT                                     retUSP;
        SCODE                                   scRetVal = S_OK;

    ScriptGetProperties(&pScript_Properties, NULL);

    iScript = pItems->a.eScript;

    LangID = (pScript_Properties[iScript])->langid;

    switch (LangID) {
       case LANG_THAI:
                        {
                        BYTE*   pBreakPos;
                        int             iNumberOfBreak = 0;
                        int             i;
                        WCHAR*  pwch = (WCHAR*) pwcChars;
                        THWB_STRUCT* pThwbStruct = NULL;

                        pBreakPos = new BYTE[cChars];

                        if ( pBreakPos == NULL ) 
                                return  FALSE;

                        pThwbStruct = THWB_CreateThwbStruct(cChars);
                        
                        pBreakPos[0] = 0;
                        iNumberOfBreak = THWB_IndexWordBreak(pwch,cChars, pBreakPos, pThwbStruct,cChars);

                        for (i=0;i < iNumberOfBreak; i++)
                                {

                                // Search index alternate words.
                                // If not query create Alternate word.
                                if (pThwbStruct[i].alt != 0 && !_fQuery)
                                        {
                                        int             iNumAltWord = 0, k;
                                        BYTE    pAltBreakPos[5];
                                        WCHAR*  word1 = pwch;
                                        int             indexWord1 = 0;

                                        
                                        // Find Alternate words
                                        iNumAltWord = THWB_FindAltWord(word1,pBreakPos[i], pThwbStruct[i].alt, pAltBreakPos);
                                        
                                        // Put alternate words.
                                        for(k=0; k<iNumAltWord;k++)
                                                {
                                                scRetVal = pWordSink->PutAltWord(pAltBreakPos[k],&word1[indexWord1],pBreakPos[i],pTextSource->iCur);
                                                indexWord1 += pAltBreakPos[k];
                                                }                       
                                        }

                                // if PutAltWord not okay return.
                                if (scRetVal != S_OK)
                                        break;

                                if (*pwch >= THAI_Ko_Kai && *pwch <= THAI_Vowel_MaiYaMok)
                                        scRetVal = pWordSink->PutWord(pBreakPos[i], pwch,       pBreakPos[i], pTextSource->iCur);
                                
                                if (scRetVal != S_OK)
                                        break;


                                pTextSource->iCur += pBreakPos[i];

                                pwch += pBreakPos[i];
                                }

                        if (pBreakPos)
                                delete pBreakPos;

                        // Prefix bug 1055941 - clear allocated memory.
                        THWB_DeleteThwbStruct(pThwbStruct);

                        break;
                        }

       case LANG_ENGLISH :   // handle English chars 

            { 
                BYTE        ct;
                BOOL        fRomanWord = FALSE;
                CONST WCHAR *pwcInput;
                WT          Type;

                Type =  WT_START;

                pwcInput = pwcChars;
                iWordStart = 0;

                for (iChar=0; iChar< cChars; iChar++, pwcInput++)
                                        {
                    ct = GetCharType(*pwcInput);

                    if ( (ct != WS) && (ct != PS) )
                       ct = CH;


                    switch (ct) {
                      case CH :
                           if (!fRomanWord) {
                               iWordStart = iChar; 
                               fRomanWord = TRUE;
                               Type = WT_ROMAJI;
                           }
                           break;
                      case WS :
                           if (fRomanWord) {
                              iWordLen = iChar - iWordStart; 

                              scRetVal = pWordSink->PutWord(iWordLen, pwcChars+iWordStart, iWordLen, pTextSource->iCur);

                              pTextSource->iCur += iWordLen;
                              fRomanWord = FALSE;
                           }
                           
                           Type = WT_WORD_SEP;
                           pTextSource->iCur++;
                           break;

                      case PS :
                           if (fRomanWord) {
                              iWordLen = iChar - iWordStart;

                              scRetVal = pWordSink->PutWord(iWordLen, pwcChars+iWordStart, iWordLen, pTextSource->iCur);

                              pTextSource->iCur += iWordLen;
                              fRomanWord = FALSE;
                           }
                           
                           Type = WT_PHRASE_SEP;
                           scRetVal = pWordSink->PutBreak(WORDREP_BREAK_EOS);
                           pTextSource->iCur++;
                           break;
                                        }

                                        if (scRetVal != S_OK)
                                                break;
                }

                if ((Type == WT_WORD_SEP) || (Type == WT_PHRASE_SEP))
                   break;
                
                if ( fKeep )
                   break;
                                
                                if (scRetVal != S_OK)
                                        break;
              
                iWordLen =cChars - iWordStart;
                scRetVal = pWordSink->PutWord(iWordLen, pwcChars+iWordStart, iWordLen,pTextSource->iCur);
                pTextSource->iCur += iWordLen;

                                if (scRetVal != S_OK)
                                        {
                                        break;
                                        }

            }

            break;


       default:

               pTextSource->iCur += cChars;
               break;
    }

    return scRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\thwbplat.h ===
//+---------------------------------------------------------------------------
//
//
//  THWBPLAT.H - contain different definition use in Thai Word Break.
//
//  History:
//      created 3/00 aarayas
//
//  2000 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _THWBPLAT_H_
#define _THWBPLAT_H_

#ifdef _OFFICE_
#define DWORD_PTR DWORD
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\proofbase.h ===
/********************************************************************
  ProofBase.h - Base API definitions for CSAPI, CTAPI, & CHAPI
    Speller, Thesaurus, and Hyphenator

  Version 3.0 - all api's

    History:
    5/97    DougP   Created
    12/97   DougP   Copied from ProofAPI.h and Separated into tool section files
	5/99	aarayas	Copied Vendor.h into proofbase to elminate many files to copied for Thai wordbreak.

    The Natural Language Group maintains this file.

The end user license agreement (EULA) for CSAPI, CHAPI, or CTAPI covers this source file.  Do not disclose it to third parties.

You are not entitled to any support or assistance from Microsoft Corporation regarding your use of this program.

 1997-1998 Microsoft Corporation.  All rights reserved.
********************************************************************/

#if !defined(PROOFBASE_H)
#define PROOFBASE_H

#pragma pack(push, proofapi_h, 8)   // default alignment

// The Following code was taken from NLG group vendor.h
#if !defined(VENDOR_H)
#define VENDOR_H

/* unified codes */
// I originally used an enum here - but RC doesn't like it

typedef int VENDORID;   // vendorid

#define  vendoridSoftArt            1
#define  vendoridInso               2

  // these came from the original list from the speller
  // but don't conflict with any others - so they are safe for all tools
#define vendoridInformatic         17     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define vendoridAmebis             18     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define vendoridLogos              19     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define vendoridDatecs             20     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define vendoridFilosoft           21     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define vendoridLingsoft           22     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define vendoridPolderland         23     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */


#define  vendoridMicrosoft          64
#define  vendoridSynapse            65              /* Synapse - French(Spelling:Mssp3fr.lex, Mssp3fr.dll) */
#define  vendoridFotonija           66              /* Fotonija - Lithuanian(Spelling:Mssp_lt.lex, Msplt32.dll) - added 3/25/97 */
#define  vendoridFotonja        vendoridFotonija                /* To make up for earlier misspelling */
#define  vendoridHizkia             67              /* Hizkia -Basque (Spelling:Mssp_eu.lex, Mspeu32.dll) - added 5/21/97 */
#define  vendoridExpertSystem       68              /* ExpertSystem - Italian(Spelling:Mssp3lt.lex, Mssp3lt.dll) - added 7/17/97 */
#define  vendoridWYSIWYG            69      /* Various languages as an addon - 2/2/98 */

  // next five added at Ireland's request 3/27/98
#define  vendoridSYS                70  // Croatian - Spelling:Mssp_cr.lex, Mspcr32.dll
#define  vendoridTilde              71  // Latvian - Spelling:Mssp_lv.lex, Msplv32.dll
#define  vendoridSignum             72  // Spanish - Spelling:Mssp3es.lex, Mssp3es.dll
#define  vendoridProLing            73  // Ukrainian - Spelling:Mssp3ua.lex, Mssp3ua.dll
#define  vendoridItautecPhilcoSA    74  // Brazilian - Spelling:mssp3PB.lex, Mssp3PB.dll

#define vendoridPriberam             75     /* Priberam Informtica - Portuguese - 7/13/98 */
#define vendoridTranquility     76  /* Tranquility Software - Vietnamese - 7/22/98 */

#define vendoridColtec          77  /* Coltec - Arabic - added 8/17/98 */

/*************** legacy codes ******************/

/* Spell Engine Id's */
#define sidSA    vendoridSoftArt      /* Reserved */
#define sidInso  vendoridInso      /* Inso */
#define sidHM    sidInso      /* Inso was Houghton Mifflin */
#define sidML    3      /* MicroLytics */
#define sidLS    4      /* LanSer Data */
#define sidCT    5      /* Center of Educational Technology */
#define sidHS    6      /* HSoft - Turkish(mssp_tr.lex, Msptr32.dll)*/
#define sidMO    7      /* Morphologic - Romanian(Mssp_ro.lex, Msthro32.dll) and Hungarian(Mssp_hu.lex, Msphu32.dll) */
#define sidTI    8      /* TIP - Polish(Mssp_pl.lex, Mspl32.dll) */
#define sidTIP sidTI
#define sidKF    9      /* Korean Foreign Language University */
#define sidKFL sidKF
#define sidPI    10     /* Priberam Informatica Lince - Portuguese(Mssp3PT.lex, Mssp3PT.dll) */
#define sidPIL sidPI
#define sidColtec   11  /* Coltec (Arabic) */
#define sidGS    sidColtec     /* Glyph Systems - this was an error */
#define sidRA    12     /* Radiar (Romansch) */
#define sidIN    13     /* Intracom - Greek(Mssp_el.lex, Mspel32.dll) */
#define sidSY    14     /* Sylvan */
#define sidHI    15     /* Hizkia (obsolete - use vendoridHizkia) */
#define sidFO    16     /* Forma - Slovak(Mssp_sk.lex, Mspsk32.dll) */
#define sidIF    vendoridInformatic     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define sidAM    vendoridAmebis     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define sidLO    vendoridLogos     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define sidDT    vendoridDatecs     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define sidFS    vendoridFilosoft     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define sidLI    vendoridLingsoft     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define sidPL    vendoridPolderland     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */

  /* Thesaurus Engine Id's */
#define teidSA    vendoridSoftArt
#define teidInso  vendoridInso    /* Inso */
#define teidHM    teidInso    /* Inso was Houghton-Mifflin */
#define teidIF    3    /* Informatic */
#define teidIN    4    /* Intracom */
#define teidMO    5    /* MorphoLogic */
#define teidTI    6    /* TiP */
#define teidPI    7    /* Priberam Informatica Lince */
#define teidAM    8    /* Amebis */
#define teidDT    9    /* Datecs */
#define teidES   10    /* Expert System */
#define teidFS   11    /* Filosoft */
#define teidFO   12    /* Forma */
#define teidHS   13    /* HSoft */
#define teidLI   14    /* Lingsoft */
#define teidLO   15    /* Logos */
#define teidPL   16    /* Polderland */

/* HYphenation Engine ID's */
#define hidSA    vendoridSoftArt
#define hidHM    vendoridInso      /* Houghton Mifflin */
#define hidML    3      /* MicroLytics */
#define hidLS    4      /* LanSer Data */
#define hidFO    5      /* Forma */
#define hidIF    6      /* Informatic */
#define hidAM    7      /* Amebis */
#define hidDT    8      /* Datecs */
#define hidFS    9      /* Filosoft */
#define hidHS   10      /* HSoft */
#define hidLI   11      /* Lingsoft */
#define hidLO   12      /* Logos */
#define hidMO   13      /* MorphoLogic */
#define hidPL   14      /* Polderland */
#define hidTI   15      /* TiP */

/* Grammar Id Engine Defines */
#define geidHM    1    /* Houghton-Mifflin */
#define geidRF    2    /* Reference */
#define geidES    3    /* Expert System */
#define geidLD    4    /* Logidisque */
#define geidSMK   5    /* Sumitomo Kinzoku (Japanese) */
#define geidIF    6    /* Informatic */
#define geidMO    7    /* MorphoLogic */
#define geidMS    8    /* Microsoft Reserved */
#define geidNO    9    /* Novell */
#define geidCTI  10    /* CTI (Greek) */
#define geidAME  11    /* Amebis (Solvenian) */
#define geidTIP  12    /* TIP (Polish) */

#endif  /* VENDOR_H */


  // you may wish to include lid.h for some convenient langid defs
#if !defined(lidUnknown)
#   define lidUnknown   0xffff
#endif

/*************************************************************
     PART 1 - Structure Defs
**************************************************************/
/* -------------- Common Section (Speller, Hyphenator, and Thesaurus) --------- */

/* hardcoded ordinals are the exported dll entry points */
// individual def files have these as well so be sure to change them
// if you change these
#define idllProofVersion        20
#define idllProofInit           21
#define idllProofTerminate      22
#define idllProofOpenLex        23
#define idllProofCloseLex       24
#define idllProofSetOptions     25
#define idllProofGetOptions     26

typedef unsigned long PTEC;     // ptec

/******************* Proofing Tool Error Codes ************************/
    /* Major Error Codes in low two bytes (WORD) of PTEC */
enum {
    ptecNoErrors,
    ptecOOM,            /* memory error */
    ptecModuleError,    /* Something wrong with parameters, or state of spell module. */
    ptecIOErrorMainLex,  /* Read,write,or share error with Main Dictionary. */
    ptecIOErrorUserLex,  /* Read,write,or share error with User Dictionary. */
    ptecNotSupported,   /* No support for requested operation */
    ptecBufferTooSmall, /* Insufficient room for return info */
    ptecNotFound,       /* Hyphenator and Thesaurus only */
    ptecModuleNotLoaded,    /* underlying module not loaded (Glue Dll's) */
};

/* Minor Error Codes in high two bytes of PTEC */
/* (Not set unless major code also set) */
enum {
    ptecModuleAlreadyBusy=128,  /* For non-reentrant code */
    ptecInvalidID,              /* Not yet inited or already terminated.*/
    ptecInvalidWsc,             /* Illegal values in WSC struct (speller only) */
    ptecInvalidMainLex,     /* Mdr not registered with session */
    ptecInvalidUserLex,     /* Udr not registered with session */
    ptecInvalidCmd,             /* Command unknown */
    ptecInvalidFormat,          /* Specified dictionary not correct format */
    ptecOperNotMatchedUserLex,  /* Illegal operation for user dictionary type. */
    ptecFileRead,               /* Generic read error */
    ptecFileWrite,              /* Generic write error */
    ptecFileCreate,             /* Generic create error */
    ptecFileShare,              /* Generic share error */
    ptecModuleNotTerminated,    /* Module not able to be terminated completely.*/
    ptecUserLexFull,            /* Could not update Udr without exceeding limit.*/
    ptecInvalidEntry,           /* invalid chars in string(s) */
    ptecEntryTooLong,           /* Entry too long, or invalid chars in string(s) */
    ptecMainLexCountExceeded,   /* Too many Mdr references */
    ptecUserLexCountExceeded,   /* Too many udr references */
    ptecFileOpenError,          /* Generic Open error */
    ptecFileTooLargeError,      /* Generic file too large error */
    ptecUserLexReadOnly,        /* Attempt to add to or write RO udr */
    ptecProtectModeOnly,        /* (obsolete) */
    ptecInvalidLanguage,        /* requested language not available */
};


#define ProofMajorErr(x) LOWORD(x)
#define ProofMinorErr(x) HIWORD(x)

/************* Structure def macros *************
Smoke and mirrors to allow initialization of some members when
using C++
***********************************/
#if !defined(__cplusplus)
#   define STRUCTUREBEGIN(x) typedef struct {
#   define STRUCTUREEND0(x) } x;
#   define STRUCTUREEND1(x, y) } x;
#   define STRUCTUREEND2(x, y, z) } x;
#   define STRUCTUREEND3(x, y, z, w) } x;
#else
#   define STRUCTUREBEGIN(x) struct x {
#   define STRUCTUREEND0(x) };
#   define STRUCTUREEND1(x, y) public: x() : y {} };
#   define STRUCTUREEND2(x, y, z) public: x() : y, z {} };
#   define STRUCTUREEND3(x, y, z, w) public: x() : y, z, w {} };
#endif

typedef DWORD PROOFVERNO;   // version

  /* Proof Information Structure - return info from ToolVersion */
STRUCTUREBEGIN(PROOFINFO)   // info
    WCHAR           *pwszCopyright; /* pointer to copyright buffer -
                                            can be NULL if size is zero */
    PROOFVERNO  versionAPI;   /* API */
    PROOFVERNO  versionVendor;  /* includes buildnumber */
    VENDORID        vendorid;   /* from vendor.h */
      /* size of copyright buffer in chars - client sets */
    DWORD           cchCopyright;   /* no error if too small or zero */
    DWORD           xcap;   /* tool dependent */
STRUCTUREEND2(PROOFINFO, pwszCopyright(0), cchCopyright(0))

/* xcap is the bitwise-or of */
enum {
    xcapNULL                    =   0x00000000,
    xcapWildCardSupport         =   0x00000001, // Speller only
    xcapMultiLexSupport         =   0x00000002,
    xcapUserLexSupport          =   0x00000008, // a must for spellers
    xcapLongDefSupport          =   0x00000010, // Thesaurus only
    xcapExampleSentenceSupport  =   0x00000020, // Thesaurus only
    xcapLemmaSupport            =   0x00000040, // Thesaurus only
    xcapAnagramSupport          =   0x00000100, // Speller only
};  // xcap

typedef void * PROOFLEX;    // lex

typedef enum {
    lxtChangeOnce=0,
    lxtChangeAlways,
    lxtUser,
    lxtExclude,
    lxtMain,
    lxtMax,
    lxtIgnoreAlways=lxtUser,
} PROOFLEXTYPE; // lxt


  // note this API does not support external user dictionaries with
  // Change (lxtChangeAlways or lxtChangeOnce) properties
  // It does support either UserLex (the norm) or Exclude types
  // Opening a udr with type Exclude automatically makes it apply to
  // the entire session
STRUCTUREBEGIN(PROOFLEXIN)  /* Dictionary Input Info - lxin - all parameters in only */
    const WCHAR     *pwszLex;   // full path of dictionary to open
    BOOL            fCreate;    /* create if not already exist? (UDR's only) */
    PROOFLEXTYPE    lxt;    /* lxtMain, lxtUser, or lxtExclude (Speller UDR's only) */
    LANGID          lidExpected;    // expected LANGID of dictionary
STRUCTUREEND3(PROOFLEXIN, lidExpected(lidUnknown), fCreate(TRUE), lxt(lxtMain))


STRUCTUREBEGIN(PROOFLEXOUT)    /* Dictionary Output Info - lxout */
    WCHAR       *pwszCopyright; /* pointer to copyright buffer (MDR only)
                                        -- can be NULL if size (below) is zero -
								pointer is in, contents out */
    PROOFLEX    lex;            /* [out] id for use in subsequent calls */
    DWORD       cchCopyright;   /* [in] client sets - no error if too small or zero */
    PROOFVERNO  version;        /* [out] version of lexfile - includes buildnumber */
    BOOL        fReadonly;      /* [out] set if can't be written on */
    LANGID      lid;            /* [out] LANGID actually used */
STRUCTUREEND2(PROOFLEXOUT, pwszCopyright(0), cchCopyright(0))

typedef void *PROOFID;  // id (or sid, hid, or tid)

#define PROOFMAJORVERSION(x)            (HIBYTE(HIWORD(x)))
#define PROOFMINORVERSION(x)            (LOBYTE(HIWORD(x)))
#define PROOFMAJORMINORVERSION(x)       (HIWORD(x))
#define PROOFBUILDNO(x)                 (LOWORD(x))
#define PROOFMAKEVERSION1(major, minor, buildno)    (MAKELONG(buildno, MAKEWORD(minor, major)))
#define PROOFMAKEVERSION(major, minor)  PROOFMAKEVERSION1(major, minor, 0)

#define PROOFTHISAPIVERSION             PROOFMAKEVERSION(3, 0)

STRUCTUREBEGIN(PROOFPARAMS) // xpar [in]
    DWORD   versionAPI; // API version requested
STRUCTUREEND1(PROOFPARAMS, versionAPI(PROOFTHISAPIVERSION))



/*************************************************************
     PART 2 - Function Defs
**************************************************************/
#if defined(__cplusplus)
extern "C" {
#endif

/* -------------- Common Section (Speller, Hyphenator, and Thesaurus) --------------

the functions in this section are for documentation only -
separate versions exist for each tool.

  ---------------------------------------------- */
/****************************************************************
*** PROOFVERSION
This is the only routine that can be called outside of a session.
ToolInit begins a session.

The version numbers are in hex format with
the high byte representing the major version number,
the next byte the minor revision number, and the
low order bytes represent an optional build number.
For example, version 1.00 is 0x01000000.  Version 2.13
is 0x020d0000.  Engines that support
this API should return 0x03000000 for iAPIVersion.

The engine ID identifies the core engine creator.  The list
in vendor.h identifies the possible values.  For example,
the Inso derived speller returns VendorIdInso.   iVendorVersion
is up to the vendor to manage and determine.

This routine may return in xcap the functionality
supported by the module.  Since modules are usually
dynamically linked, the application should read the
information and verify that required functionality is
present.
Errors:
    ptecModuleError - bad memory (can't write on pinfo)
**********************************/
// PTEC WINAPI ToolVersion(ToolInfo *pInfo);
typedef PTEC (WINAPI *PROOFVERSION) (PROOFINFO *pinfo);

/***********************************************************
*** ToolInit
This is the entry point for a session.  With the exception
of ToolVersion, this routine must return successfully before
use of any other routines.  ToolInit initializes internal
structures and resources needed for subsequent calls into the
module.  For example, SpellerInit initializes the UserLex,
ChangeOnce, and ChangeAlways built-in UDR's.  In general,
modules allocate and free resources as needed, transparent to
the application.  pToolId is the handle to those variables.
Modules store any data from the PROOFPARAMS structure internally
and do not rely on the data in the structure remaining intact.

Errors:
    ptecModuleError - bad memory (can't write on pxpar)
    ptecNotSupported - incompatible version
    ptecOOM - insufficient memory
*****************************************/
// PTEC WINAPI ToolInit(PROOFID *pToolid, const PROOFPARAMS *pxpar);
typedef PTEC (WINAPI *PROOFINIT) (PROOFID *pid, const PROOFPARAMS *pxpar);


/************************************************************
*** ToolTerminate
This function marks the end of the session.  It attempts to
close all dictionaries and free up any and all other resources
allocated by the module since ToolInit.

Do not call ToolTerminate if  ToolInit was not successful.

If fForce is TRUE, ToolTerminate is guaranteed to succeed.  If
fForce is false, it may fail.  For example, there may be errors
writing the user dictionaries out to disk.  After ToolTerminate
(whether it succeeds or fails), all other module routines with
the exception of ToolTerminate and ToolVersion are unusable
until the module is successfully reinitialized using ToolInit.

If this call fails, successful re-initialization of the module
is not guaranteed on all platforms.  In addition, failure to
successfully terminate each session may lock memory and file
resources in an unrecoverable way until terminate is successful.
If the terminate call fails, the main application should either
fix the problem (e.g., insert floppy in drive) and try to
terminate again, or should terminate using the fForce flag
switch.
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
***********************************************/
// PTEC WINAPI ToolTerminate(PROOFID id, BOOL fForce);
typedef PTEC (WINAPI *PROOFTERMINATE) (PROOFID id, BOOL fForce);


/*****************************************************************
*** ToolSetOptions
Set the value of an option for a tool.  The value to set is in iOptVal.

Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecNotSupported    - iOptionSelect unknown
********************************************/
// PTEC WINAPI ToolSetOptions(PROOFID id, int iOptionSelect, int iOptVal);
typedef PTEC (WINAPI *PROOFSETOPTIONS) (PROOFID id, DWORD iOptionSelect, const DWORD iOptVal);


/*****************************************************************
*** ToolGetOptions
Get the current value of an option from a tool.  Returns in *piOptVal;
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecModuleError - can't write at piOptVal
    ptecNotSupported    - iOptionSelect unknown
********************************************/
// PTEC WINAPI ToolGetOptions(PROOFID id, int iOptionSelect, int *piOptVal);
typedef PTEC (WINAPI *PROOFGETOPTIONS) (PROOFID id, DWORD iOptionSelect, DWORD *piOptVal);


/*****************************************************************
*** ToolOpenLex
The dictionary file (main or user) is opened and verified, but not
necessarily loaded.
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecModuleError - memory error
    ptecIOErrorMainLex - Can't open or read Main Lex
    ptecIOErrorMainLex, ptecInvalidFormat
    ptecIOErrorMainLex, ptecInvalidLanguage - requested LANGID not in this lex
    ptecOOM
    ptecIOErrorUserLex, ptecUserLexCountExceeded - second exclusion dictionary
                                                 - too many Udrs
    ptecIOErrorUserLex, ptecFileOpenError
    ptecIOErrorUserLex, ptecFileCreate - couldn't create a UDR
    ptecIOErrorUserLex, ptecFileRead
    ptecIOErrorUserLex, ptecInvalidFormat
********************************************/
// PTEC WINAPI ToolOpenLex(PROOFID id, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);
typedef PTEC (WINAPI *PROOFOPENLEX) (PROOFID id, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);


/*****************************************************************
*** ToolCloseLex
Closes the specified dictionary and disassociates that dictionary
from any subsequent checks.  In the case of user dictionaries,
updates the disk file (if any).  If the dictionary file cannot
be updated, the call fails unless the fForce parameter is also set.

If fForce is true, ToolCloseLex is guaranteed to successfully
remove the dictionary from the dictionary list and effectively
close the file.  In this case, it the file could not be updated,
the changes are lost, but the function is considered successful,
and therefore returns ptecNOERRORS.
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecModuleError, ptecInvalidMainLex - lex is illegal
    ptecIOErrorUserLex, ptecFileWrite
    ptecIOErrorUserLex, ptecOperNotMatchedUserLex - can't close a built-in UDR
// PTEC WINAPI ToolCloseLex(PROOFID id, PROOFLEX dict, BOOL fforce);
*****************************/
typedef PTEC (WINAPI *PROOFCLOSELEX) (PROOFID id, PROOFLEX lex, BOOL fforce);
// fForce forces closing the specified user dictionary, even if the
// dictionary cannot be updated.  Has no meaning for main
// dictionaries.


/******************************** Special Glue DLL API ******************
For the glue dll's (converts the API for clients to tools that use API v1 for
speller, hyphenator, v2 for thesaurus), we need to set the name of the previous version
DLL to use - and the code page (that it can't figure out from the LANGID)
to use for any data conversion.
The glue dll's use the lid to set the code page for data conversion.

BOOL WINAPI ToolSetDllName(const WCHAR *pwszDllName, const UINT uCodePage);
*************************************************************************/
#define idllProofSetDllName     19
typedef BOOL (WINAPI *PROOFSETDLLNAME)(const WCHAR *pwszDllName, const UINT uCodePage);


#if defined(__cplusplus)
}
#endif
#pragma pack(pop, proofapi_h)   // restore to whatever was before

#endif // PROOFBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by thawbrkr.rc
//
#define IDR_LEXICON1                    105
#define IDR_LEXICON2                    106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\register.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1998 - 1999, Microsoft Corporation.
//
// File:        Register.cxx
//
// Contents:    Self-registration for Word Breaker /Stemmer.
//
// Functions:   DllRegisterServer, DllUnregisterServer
//
// History:     12-Jan-98       Weibz       Created
//              08-Jan-99       AlanW       Modified to use langreg.hxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop
#include "thwbint.h"
#include "langreg.hxx"

//
// Registry constants
//


WCHAR const wszCILang[] = L"System\\CurrentControlSet\\Control\\ContentIndex\\Language";

#if defined (THAIINDEX)
SLangRegistry const LangResource = {
    L"Thai_IndexDefault",
    1054,
    {   L"{B66F590A-62A5-47db-AFBC-EFDD4FFBDBEB}", // L"{cca22cf4-59fe-11d1-aaff-00c04fb97fda}",
        L"Thai_IndexDefault Word Breaker",
        L"thawbrkr.dll",
        L"Both" },

    {   L"{52CC7D83-1378-4537-A40F-DD4372498E18}", // L"{cedc01c7-59fe-11d1-aaff-00c04fb97fda}",
        L"Thai_IndexDefault Stemmer",
        L"thawbrkr.dll",
        L"Both" }
};
#else
SLangRegistry const LangResource = {
    L"Thai_Default",
    1054,
    {   L"{cca22cf4-59fe-11d1-bbff-00c04fb97fda}",
        L"Thai_Default Word Breaker",
        L"thawbrkr.dll",
        L"Both" },

    {   L"{cedc01c7-59fe-11d1-bbff-00c04fb97fda}",
        L"Thai_Default Stemmer",
        L"thawbrkr.dll",
        L"Both" }
};
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Self-registration
//
//  History:    12-Jan-98       Weibz       Created 
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer()
{
    long dwErr = UnRegisterALanguageResource( LangResource );
    if ( ERROR_SUCCESS != dwErr )
        return S_FALSE;

    return S_OK;
} //DllUnregisterServer

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Self-registration
//
//  History:    12-Jan-98       Weibz       Created
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer()
{
    //
    // Register classes
    //

    long dwErr = RegisterALanguageResource( LangResource );

    if ( ERROR_SUCCESS != dwErr )
        return SELFREG_E_CLASS;

    return S_OK;
} //DllRegisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\thwbint.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Thai WordBreak
//
//  Thai WordBreak Interface Header File.
//
//  History:
//      created 6/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _THWBINT_H_
#define _THWBINT_H_

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <assert.h>
#include <memory.h>
#include "ProofBase.h"						// Include for definition of PTEC.
#include "thwbdef.hpp"
#include "thwbplat.h"

#define VERSIONMAJOR 1
#define VERSIONMINOR 0

#if defined(__cplusplus)
extern "C" {
#endif

#if defined (NGRAM_ENABLE)
PTEC WINAPI ThaiWordBreakInit(WCHAR* szFileName, WCHAR* szFileNameSentStruct, WCHAR* szFileNameTrigram);
#else
PTEC WINAPI ThaiWordBreakInit(WCHAR* szFileName, WCHAR* szFileNameTrigram);
#endif
PTEC WINAPI ThaiWordBreakInitResource(LPBYTE pThaiDic, LPBYTE pThaiTrigram, BOOL fSkipHeader);
void WINAPI ThaiWordBreakTerminate();
BOOL WINAPI ThaiWordBreakSearch(WCHAR* szWord, DWORD* pdwPOS);
int WINAPI THWB_FindWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakLen, unsigned int mode);
int WINAPI ThaiSoundEx(WCHAR* word);

int WINAPI THWB_IndexWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,THWB_STRUCT* pThwb_Struct,unsigned int iBreakMax);
int WINAPI THWB_FindAltWord(WCHAR* wzWord,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos);
THWB_STRUCT* WINAPI THWB_CreateThwbStruct(unsigned int iNumStruct);
void WINAPI THWB_DeleteThwbStruct(THWB_STRUCT* pThwb_Struct);


DWORD_PTR WINAPI THWB_CreateWordBreaker();
int WINAPI THWB_FindWB(DWORD_PTR dwBreaker, WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakLen, unsigned int mode);
BOOL WINAPI THWB_DeleteWordBreaker(DWORD_PTR dwBreaker);


#if defined(__cplusplus)
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\thwbdef.hpp ===
//+---------------------------------------------------------------------------
//
//
//  THWBDEF.HPP - contain different definition use in Thai Word Break.
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _THWBDEF_HPP_
#define _THWBDEF_HPP_
#include <windows.h>
#include "thwbplat.h"

#define THAI_Ko_Kai					0x0e01
#define THAI_Kho_Rakhang            0x0e06
#define THAI_Cho_Ching              0x0e09
#define THAI_So_So                  0x0e0b
#define THAI_Tho_NangmonTho         0x0e11
#define THAI_Pho_Phung              0x0e1c
#define THAI_Fo_Fa                  0x0e1d
#define THAI_Fo_Fan                 0x0e1f
#define THAI_Pho_Samphao            0x0e20
#define THAI_Ho_Hip                 0x0e2b
#define THAI_Ho_Nok_Huk				0x0e2e
#define THAI_Sign_PaiYanNoi         0x0e2f
#define THAI_Vowel_Sara_A           0x0e30
#define THAI_Vowel_Sign_Mai_HanAkat 0x0e31
#define THAI_Vowel_Sara_AA          0x0e32
#define THAI_Vowel_Sign_Sara_Am		0x0e33
#define THAI_Vowel_Sara_I           0x0e34
#define THAI_Vowel_Sara_II          0x0e35
#define THAI_Sara_Ue                0x0e36
#define THAI_Sara_Uee               0x0e37
#define THAI_Vowel_Sign_Phinthu		0x0e3a
#define THAI_Vowel_Sara_E           0x0e40
#define THAI_Vowel_Sara_AI_MaiMaLai 0x0e44
#define THAI_Vowel_LakKhangYao      0x0e45
#define THAI_Vowel_MaiYaMok         0x0e46
#define THAI_Tone_MaiTaiKhu         0x0e47
#define THAI_Tone_Mai_Ek			0x0e48
#define THAI_Tone_Mai_Tri           0x0e4a
#define THAI_Thanthakhat            0x0e4c
#define THAI_Nikhahit               0x0e4d

#define POSTYPE		                304
#define POS_UNKNOWN                 (POSTYPE - 1)
#define TAGPOS_UNKNOWN              0x012F301
#define TAGPOS_PURGE                0x0130301

#define MAXBREAK                    256

// Soundex definition.
#define APPROXIMATEWEIGHT           60

#define WB_LINEBREAK	0
#define WB_NORMAL		1
//#define WB_LINEBREAK	2	// Number 2 is also linebreak.
#define WB_SPELLER		3
#define WB_INDEX		4

typedef struct THWB_STRUCT
{
	bool fThai;
	BYTE alt;
} THWB_STRUCT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\stemcf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       stemcf.cxx
//
//  Contents:   Stemmer class factory
//
//  History:     weibz,   10-Sep-1997   created 
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include "stemcf.hxx"
#include "stemmer.hxx"

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::CStemmerCF
//
//  Synopsis:   Stemmer class factory constructor
//
//--------------------------------------------------------------------------

CStemmerCF::CStemmerCF( LCID lcid )
        : _cRefs( 1 ), _lcid( lcid )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::~CStemmerCF
//
//  Synopsis:   Stemmer class factory destructor
//
//--------------------------------------------------------------------------

CStemmerCF::~CStemmerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::QueryInterface( REFIID riid,
                                                    void  ** ppvObject )
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStemmerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStemmerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::CreateInstance
//
//  Synopsis:   Creates new CStemmer object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::CreateInstance( IUnknown * pUnkOuter,
                                                    REFIID riid,
                                                    void  * * ppvObject )
{
    CStemmer *pIUnk = 0;
    SCODE sc = S_OK;

    __try
    {
        pIUnk = new CStemmer( _lcid );
        if (pIUnk)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );

            pIUnk->Release();  // Release extra refcount from QueryInterface
        }
        else
        {
            sc = E_UNEXPECTED;
        }
    }
    __except(1)
    {
        Assert( 0 == pIUnk );

        sc = E_UNEXPECTED;
    }


    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\stemmer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       stemmer.cxx
//
//  Contents:   Thai Stemmer
//
//  History:    weibz,   10-Nov-1997   created 
//
//----------------------------------------------------------------------------

#include <pch.cxx>

#include "stemmer.hxx"

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::CStemmer
//
//  Synopsis:   Constructor for the CStemmer class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CStemmer::CStemmer( LCID lcid )
        : _cRefs(1)
{
   InterlockedIncrement( &gulcInstances );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::~CStemmer
//
//  Synopsis:   Destructor for the CStemmer class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CStemmer::~CStemmer()
{
   InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::QueryInterface( REFIID riid, void  ** ppvObject)
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IStemmer == riid )
        *ppvObject = (IUnknown *)(IStemmer *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Init
//
//  Synopsis:   Initialize stemmer
//
//  Arguments:  [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::Init(
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{

    if ( NULL == pfLicense ) {
       return E_INVALIDARG;
    }

    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *pfLicense = TRUE;
    _ulMaxTokenSize = ulMaxTokenSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CStemmer::GetLicenseToUse( const WCHAR **ppwcsLicense )
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1998";
    
    if ( NULL == ppwcsLicense ) {
       return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return ( E_INVALIDARG );
    }

    *ppwcsLicense = wcsCopyright;

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::GenerateWordForms
//
//  Synopsis:   Stem a word into its inflected forms, eg swim to swims and swimming
//
//  Arguments:  [pwcInBuf] -- input Unicode word
//              [cwc] -- count of characters in word
//              [pWordFormSink] -- sink to collect inflected forms
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::GenerateWordForms(
    WCHAR const *pwcInBuf,
    ULONG cwc,
    IWordFormSink *pWordFormSink )
{
    INT nReturn;
    SCODE sc = S_OK;

#ifdef THAIDBG
    ULONG  i;
    OutputDebugString("\n Stemword\n");
    for (i=0; i<cwc; i++)
    {
          WORD  wtmp;
          char  ctmp[80];

          wtmp = pwcInBuf[i];
          sprintf(ctmp, "%4x ", wtmp);
          OutputDebugString(ctmp);
    }
#endif

    if ( NULL == pWordFormSink  || NULL == pwcInBuf) {
        return E_FAIL;
    }

    // Currently, Thai stemmer doesn't make inflection form for tripolli.

    return pWordFormSink->PutWord (pwcInBuf, cwc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\acctl32.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    acctl32.cxx

Abstract:

    Translations of 32 bit ioctl to 64 bit ioctls and back.

Author:

    Shai Kariv (shaik) 14-May-2000

Environment:

    Kernel mode, Win64 only.

Revision History:

--*/

#include "internal.h"
#include "acctl32.h"

#ifndef MQDUMP
#include "acctl32.tmh"
#endif

#ifdef _WIN64

//
// ISSUE-2000/10/19-erezh Workaround compiler warning 4244
//
// PTR32_TO_PTR
// Sign extend PTR32 to PTR
// This is here just to workaround compiler bug that generates warning
// error C4244: '==' : conversion from 'USHORT *__ptr64 const ' to 'USHORT *', possible loss of data

template <class T>
inline T* PTR32_TO_PTR(T* POINTER_32 pT32)
{
  return pT32;
}


template <class T> 
inline
T**
PtrToPtrFrom32To64(
    T* POINTER_32* POINTER_32 ppT32,
    T** ppHelper
    )
{
    //
    // If ptr to ptr is NULL, return NULL
    //
    if (ppT32 == NULL)
        return NULL;

    //
    // Otherwise, set the helper ptr to point to the value
    //
    __try
    {
        *ppHelper = *ppT32;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // Return a *safe* bougus pointer
        //
        return (T**)1;
    }

    //
    // Return the ptr to the helper ptr (passed as a param)
    //
    return ppHelper;
}


////////////////////////////////////////////////////////////////////////////////
//
// 32 to 64 bit conversions
//
//
//    Values are copied as is.
//
//    32 bit pointers are copied as is (expanded to 64 bits).
//
//    32 bit pointers to 32 bit structures are copied by creating a new 64 bit
//    struct in a helper struct, and pointing to the new 64 bit struct instead
//    of the 32 bit struct.
//
//    32 bit pointers to 32 bit pointers are copied by putting the inner pointer
//    as a 64 bit value in a helper struct as a 64 bit pointer, and changing the
//    outer (64 bit) pointer to point to the new 64 bit pointer in the helper
//    structure instead of to the 32 bit pointer.


VOID
ACpMsgProps32ToMsgProps(
    const CACMessageProperties_32 * pMsgProps32,
    CACMessageProperties64Helper  * pHelper,
    CACMessageProperties          * pMsgProps
    )
/*++

Routine Description:

    Convert CACMessageProperties_32 to CACMessageProperties.

Arguments:

    pMsgProps32 - Pointer to 32 bit message properties structure.

    pHelper     - Pointer to a helper structure.

    pMsgProps   - Pointer to 64 bit message properties structure, on output.

Return Value:

    None.

--*/
{
    //
    // Compile time assert. If you hit this, you changed CACMessageProperties,
    // and you should change CACMessageProperties_32 and CACMessageProperties64Helper
    // accordingly. and change the number in the C_ASSERT to the correct size.
    //
    C_ASSERT(sizeof(CACMessageProperties) == 576);

    pMsgProps->pClass = pMsgProps32->pClass;
    pMsgProps->ppMessageID = PtrToPtrFrom32To64(pMsgProps32->ppMessageID, &pHelper->pMessageID);
    pMsgProps->ppCorrelationID = PtrToPtrFrom32To64(pMsgProps32->ppCorrelationID, &pHelper->pCorrelationID);
    pMsgProps->pSentTime = pMsgProps32->pSentTime;
    pMsgProps->pArrivedTime = pMsgProps32->pArrivedTime;
    pMsgProps->pPriority = pMsgProps32->pPriority;
    pMsgProps->pDelivery = pMsgProps32->pDelivery;
    pMsgProps->pAcknowledge = pMsgProps32->pAcknowledge;
    pMsgProps->pAuditing = pMsgProps32->pAuditing;
    pMsgProps->pApplicationTag = pMsgProps32->pApplicationTag;
    pMsgProps->ppBody = PtrToPtrFrom32To64(pMsgProps32->ppBody, &pHelper->pBody);
    pMsgProps->ulBodyBufferSizeInBytes = pMsgProps32->ulBodyBufferSizeInBytes;
    pMsgProps->ulAllocBodyBufferInBytes = pMsgProps32->ulAllocBodyBufferInBytes;
    pMsgProps->pBodySize = pMsgProps32->pBodySize;
    pMsgProps->ppTitle = PtrToPtrFrom32To64(pMsgProps32->ppTitle, &pHelper->pTitle);
    pMsgProps->ulTitleBufferSizeInWCHARs = pMsgProps32->ulTitleBufferSizeInWCHARs;
    pMsgProps->pulTitleBufferSizeInWCHARs = pMsgProps32->pulTitleBufferSizeInWCHARs;
    pMsgProps->ulAbsoluteTimeToQueue = pMsgProps32->ulAbsoluteTimeToQueue;
    pMsgProps->pulRelativeTimeToQueue = pMsgProps32->pulRelativeTimeToQueue;
    pMsgProps->ulRelativeTimeToLive = pMsgProps32->ulRelativeTimeToLive;
    pMsgProps->pulRelativeTimeToLive = pMsgProps32->pulRelativeTimeToLive;
    pMsgProps->pTrace = pMsgProps32->pTrace; 
    pMsgProps->pulSenderIDType = pMsgProps32->pulSenderIDType;
    pMsgProps->ppSenderID = PtrToPtrFrom32To64(pMsgProps32->ppSenderID, &pHelper->pSenderID);
    pMsgProps->pulSenderIDLenProp = pMsgProps32->pulSenderIDLenProp;
    pMsgProps->pulPrivLevel = pMsgProps32->pulPrivLevel;
    pMsgProps->ulAuthLevel = pMsgProps32->ulAuthLevel;
    pMsgProps->pAuthenticated = pMsgProps32->pAuthenticated;
    pMsgProps->pulHashAlg = pMsgProps32->pulHashAlg;
    pMsgProps->pulEncryptAlg = pMsgProps32->pulEncryptAlg;
    pMsgProps->ppSenderCert = PtrToPtrFrom32To64(pMsgProps32->ppSenderCert, &pHelper->pSenderCert);
    pMsgProps->ulSenderCertLen = pMsgProps32->ulSenderCertLen;
    pMsgProps->pulSenderCertLenProp = pMsgProps32->pulSenderCertLenProp;
    pMsgProps->ppwcsProvName = PtrToPtrFrom32To64(pMsgProps32->ppwcsProvName, &pHelper->pwcsProvName);
    pMsgProps->ulProvNameLen = pMsgProps32->ulProvNameLen;
    pMsgProps->pulAuthProvNameLenProp = pMsgProps32->pulAuthProvNameLenProp;
    pMsgProps->pulProvType = pMsgProps32->pulProvType;
    pMsgProps->fDefaultProvider = pMsgProps32->fDefaultProvider;
    pMsgProps->ppSymmKeys = PtrToPtrFrom32To64(pMsgProps32->ppSymmKeys, &pHelper->pSymmKeys);
    pMsgProps->ulSymmKeysSize = pMsgProps32->ulSymmKeysSize;
    pMsgProps->pulSymmKeysSizeProp = pMsgProps32->pulSymmKeysSizeProp;
    pMsgProps->bEncrypted = pMsgProps32->bEncrypted;
    pMsgProps->bAuthenticated = pMsgProps32->bAuthenticated;
    pMsgProps->uSenderIDLen = pMsgProps32->uSenderIDLen;
    pMsgProps->ppSignature = PtrToPtrFrom32To64(pMsgProps32->ppSignature, &pHelper->pSignature);
    pMsgProps->ulSignatureSize = pMsgProps32->ulSignatureSize;
    pMsgProps->pulSignatureSizeProp = pMsgProps32->pulSignatureSizeProp;
    pMsgProps->ppSrcQMID = PtrToPtrFrom32To64(pMsgProps32->ppSrcQMID, &pHelper->pSrcQMID);
    pMsgProps->pUow = pMsgProps32->pUow;
    pMsgProps->ppMsgExtension = PtrToPtrFrom32To64(pMsgProps32->ppMsgExtension, &pHelper->pMsgExtension);
    pMsgProps->ulMsgExtensionBufferInBytes = pMsgProps32->ulMsgExtensionBufferInBytes;
    pMsgProps->pMsgExtensionSize = pMsgProps32->pMsgExtensionSize;
    pMsgProps->ppConnectorType = PtrToPtrFrom32To64(pMsgProps32->ppConnectorType, &pHelper->pConnectorType);
    pMsgProps->pulBodyType = pMsgProps32->pulBodyType;
    pMsgProps->pulVersion = pMsgProps32->pulVersion;
    pMsgProps->pbFirstInXact = pMsgProps32->pbFirstInXact;
    pMsgProps->pbLastInXact = pMsgProps32->pbLastInXact;
    pMsgProps->ppXactID = PtrToPtrFrom32To64(pMsgProps32->ppXactID, &pHelper->pXactID);
    pMsgProps->pLookupId = pMsgProps32->pLookupId;
    pMsgProps->ppSrmpEnvelope = PtrToPtrFrom32To64(pMsgProps32->ppSrmpEnvelope, &pHelper->pSrmpEnvelope);
    pMsgProps->pSrmpEnvelopeBufferSizeInWCHARs = pMsgProps32->pSrmpEnvelopeBufferSizeInWCHARs;
    pMsgProps->ppCompoundMessage = PtrToPtrFrom32To64(pMsgProps32->ppCompoundMessage, &pHelper->pCompoundMessage);
    pMsgProps->CompoundMessageSizeInBytes = pMsgProps32->CompoundMessageSizeInBytes;
    pMsgProps->pCompoundMessageSizeInBytes = pMsgProps32->pCompoundMessageSizeInBytes;
    pMsgProps->EodStreamIdSizeInBytes = 0;
    pMsgProps->pEodStreamIdSizeInBytes = NULL;
    pMsgProps->ppEodStreamId = NULL;
    pMsgProps->EodOrderQueueSizeInBytes = 0;
    pMsgProps->pEodOrderQueueSizeInBytes = NULL;
    pMsgProps->ppEodOrderQueue = NULL;
    pMsgProps->pEodAckSeqId = NULL;
    pMsgProps->pEodAckSeqNum = NULL;
    pMsgProps->EodAckStreamIdSizeInBytes = 0;
    pMsgProps->pEodAckStreamIdSizeInBytes = NULL;
    pMsgProps->ppEodAckStreamId = NULL;

} // ACpMsgProps32ToMsgProps


static
bool
ACpMqf32ToMqf(
    ULONG                 nMqf32,
    const QUEUE_FORMAT_32 mqf32[],
    ULONG *               pnMqf,
    QUEUE_FORMAT * *      ppMqf 
    )
{
    ASSERT(ppMqf);
    ASSERT(pnMqf);

    *pnMqf = nMqf32;

    if (nMqf32 == 0)
    {
        return true;
    }

    *ppMqf = new (PagedPool) QUEUE_FORMAT[nMqf32];
    if ((*ppMqf) == NULL)
    {
    	TrERROR(AC, "Failed to allocate %d QUEUE_FORMATs from paged pool.", nMqf32);
        return false;
    }
    
    for (ULONG ix = 0; ix < nMqf32; ++ix)
    {
        (*ppMqf)[ix].InitFromQueueFormat32(&mqf32[ix]);
    }

    return true;

} // ACpMqf32ToMqf


NTSTATUS
ACpSendParams32ToSendParams(
    const CACSendParameters_32 * pSendParams32,
    CACSendParameters64Helper  * pHelper,
    CACSendParameters          * pSendParams
    )
/*++

Routine Description:

    Convert CACSendParameters_32 to CACSendParameters.

Arguments:

    pSendParams32 - Pointer to 32 bit send parameters structure.

    pHelper       - Pointer to a send helper structure.

    pSendParams   - Pointer to 64 bit send parameters structure, on output.

Return Value:

    STATUS_SUCCESS - The operation completed successfully.
    STATUS_INSUFFICIENT_RESOURCES - The operation failed, no memory.

--*/
{
    //
    // Compile time assert. If you hit this, you changed CACSendParameters,
    // and you should change CACSendParameters_32 and CACSendParameters64Helper
    // accordingly. and change the number in the C_ASSERT to the correct size.
    //
    C_ASSERT(sizeof(CACSendParameters) == 656);

    //
    // Convert message properties
    //
    ACpMsgProps32ToMsgProps(
        &pSendParams32->MsgProps,
        &pHelper->MsgPropsHelper,
        &pSendParams->MsgProps
        );

    //
    // Convert Admin MQF
    //
    AP<QUEUE_FORMAT> pAdminMqf;
    if (!ACpMqf32ToMqf(
             pSendParams32->nAdminMqf, 
             pSendParams32->AdminMqf, 
             &pSendParams->nAdminMqf, 
             &pAdminMqf
             ))
    {
    	TrERROR(AC, "Failed to convert admin MQF because of insufficient resources.");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Convert Response MQF
    //
    AP<QUEUE_FORMAT> pResponseMqf;
    if (!ACpMqf32ToMqf(
             pSendParams32->nResponseMqf, 
             pSendParams32->ResponseMqf, 
             &pSendParams->nResponseMqf, 
             &pResponseMqf
             ))
    {
    	TrERROR(AC, "Failed to convert response MQF because of insufficient resources.");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Convert Signature MQF
    //
    pSendParams->ppSignatureMqf = PtrToPtrFrom32To64(pSendParams32->ppSignatureMqf, &pHelper->pSignatureMqf);
    pSendParams->SignatureMqfSize = pSendParams32->SignatureMqfSize;

    //
    // Convert XMLDSIG
    //
    pSendParams->ppXmldsig = PtrToPtrFrom32To64(pSendParams32->ppXmldsig, &pHelper->pXmldsig);
    pSendParams->ulXmldsigSize = pSendParams32->ulXmldsigSize;

    //
    // Convert SOAP header and body
    //
    pSendParams->ppSoapHeader = PtrToPtrFrom32To64(pSendParams32->ppSoapHeader, &pHelper->pSoapHeader);
    pSendParams->ppSoapBody   = PtrToPtrFrom32To64(pSendParams32->ppSoapBody, &pHelper->pSoapBody);

    //
    // Assign autopointers and detach
    //
    pSendParams->AdminMqf = pAdminMqf.detach();
    pSendParams->ResponseMqf = pResponseMqf.detach();

    return STATUS_SUCCESS;

} // ACpSendParams32ToSendParams


VOID
ACpReceiveParams32ToReceiveParams(
    const CACReceiveParameters_32 * pReceiveParams32,
    CACReceiveParameters64Helper  * pHelper,
    CACReceiveParameters          * pReceiveParams
    )
/*++

Routine Description:

    Convert CACReceiveParameters_32 to CACReceiveParameters.

Arguments:

    pReceiveParams32 - Pointer to 32 bit receive parameters structure.

    pHelper          - Pointer to a receive helper structure.

    pReceiveParams   - Pointer to 64 bit receive parameters structure, on output.

Return Value:

    None.

--*/
{
    //
    // Compile time assert. If you hit this, you changed CACReceiveParameters,
    // and you should change CACReceiveParameters_32 and CACReceiveParameters64Helper
    // accordingly. and change the number in the C_ASSERT to the correct size.
    //
    C_ASSERT(sizeof(CACReceiveParameters) == 736);

    //
    // Convert message properties
    //
    ACpMsgProps32ToMsgProps(
        &pReceiveParams32->MsgProps,
        &pHelper->MsgPropsHelper,
        &pReceiveParams->MsgProps
        );

    //
    // Request timeout, Action, Asynchronous, Cursor
    //
    pReceiveParams->RequestTimeout = pReceiveParams32->RequestTimeout;
    pReceiveParams->Action         = pReceiveParams32->Action;
    pReceiveParams->Asynchronous   = pReceiveParams32->Asynchronous;
    pReceiveParams->Cursor         = pReceiveParams32->Cursor;

    //
    // Lookup ID
    //
    pReceiveParams->LookupId        = pReceiveParams32->LookupId;

    //
    // Response queue
    //
    pReceiveParams->ppResponseFormatName =
        PtrToPtrFrom32To64(pReceiveParams32->ppResponseFormatName, &pHelper->pResponseFormatName);
    pReceiveParams->pulResponseFormatNameLenProp = pReceiveParams32->pulResponseFormatNameLenProp;
    
    //
    // Admin queue
    //
    pReceiveParams->ppAdminFormatName =
        PtrToPtrFrom32To64(pReceiveParams32->ppAdminFormatName, &pHelper->pAdminFormatName);
    pReceiveParams->pulAdminFormatNameLenProp = pReceiveParams32->pulAdminFormatNameLenProp;

    //
    // Destination queue
    //
    pReceiveParams->ppDestFormatName =
        PtrToPtrFrom32To64(pReceiveParams32->ppDestFormatName, &pHelper->pDestFormatName);
    pReceiveParams->pulDestFormatNameLenProp = pReceiveParams32->pulDestFormatNameLenProp;
    

    //
    // Ordering queue
    //
    pReceiveParams->ppOrderingFormatName =
        PtrToPtrFrom32To64(pReceiveParams32->ppOrderingFormatName, &pHelper->pOrderingFormatName);
    pReceiveParams->pulOrderingFormatNameLenProp = pReceiveParams32->pulOrderingFormatNameLenProp;

    //
    // Destination Multi Queue Format
    //
    pReceiveParams->ppDestMqf =
        PtrToPtrFrom32To64(pReceiveParams32->ppDestMqf, &pHelper->pDestMqf);
    pReceiveParams->pulDestMqfLenProp = pReceiveParams32->pulDestMqfLenProp;

    //
    // Admin Multi Queue Format
    //
    pReceiveParams->ppAdminMqf =
        PtrToPtrFrom32To64(pReceiveParams32->ppAdminMqf, &pHelper->pAdminMqf);
    pReceiveParams->pulAdminMqfLenProp = pReceiveParams32->pulAdminMqfLenProp;

    //
    // Response Multi Queue Format
    //
    pReceiveParams->ppResponseMqf =
        PtrToPtrFrom32To64(pReceiveParams32->ppResponseMqf, &pHelper->pResponseMqf);
    pReceiveParams->pulResponseMqfLenProp = pReceiveParams32->pulResponseMqfLenProp;

	//
	// Signature Multi Queue Format
	//
    pReceiveParams->ppSignatureMqf = PtrToPtrFrom32To64(pReceiveParams32->ppSignatureMqf, &pHelper->pSignatureMqf);
    pReceiveParams->SignatureMqfSize = pReceiveParams32->SignatureMqfSize;
    pReceiveParams->pSignatureMqfSize = pReceiveParams32->pSignatureMqfSize;

} // ACpReceiveParams32ToReceiveParams


////////////////////////////////////////////////////////////////////////////////
//
// 64 to 32 bit conversions
//
//
//    Values are copied as is.
//
//    Pointers to values are NOT copied since it is assumed that is something
//    changed, it was the pointed value and not the pointer itself.
//
//    Pointers to pointers are NOT copied because of the same reason as regular
//    pointers.
//
//    Pointers to 32 bit structures are copied by converting the 64 bit struct to
//    the 32 bit struct that was specified in the original 32 bit pointer. The
//    pointer itself is not copied, since it points to a 64 bit struct in a helper
//    struct.


VOID
ACpMsgPropsToMsgProps32(
    const CACMessageProperties         * pMsgProps,
    const CACMessageProperties64Helper * pHelper,
    CACMessageProperties_32            * pMsgProps32
    )
/*++

Routine Description:

    Convert CACMessageProperties back to CACMessageProperties_32.

Arguments:

    pMsgProps   - Pointer to 64 bit message properties structure.

    pHelper     - Pointer to a helper structure.

    pMsgProps32 - Pointer to 32 bit message properties structure.

Return Value:

    None.

--*/
{
    //
    // Check that ptrs to ptrs haven't changed when converting back from 64 bit
    //  to 32 bit struct. Only in debug.
    //
    DBG_USED(pHelper);

#ifdef _DEBUG
#define CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(ppOrig32, pp64, pHelper64)   \
   if (pp64 == NULL)                                                        \
   {                                                                        \
      ASSERT(ppOrig32 == NULL);                                             \
   }                                                                        \
   else                                                                     \
   {                                                                        \
      ASSERT(pp64 == &pHelper64);                                           \
      ASSERT(ppOrig32 != NULL);                                             \
      /*ASSERT(pHelper64 == PTR32_TO_PTR(*ppOrig32)); don't access user memory here*/ \
   }
#else //!DEBUG
#define CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(ppOrig32, pp64, pHelper64)
#endif //DEBUG


    ASSERT(PTR32_TO_PTR(pMsgProps32->pClass) == pMsgProps->pClass);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppMessageID,
                                           pMsgProps->ppMessageID,
                                           pHelper->pMessageID);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppCorrelationID,
                                           pMsgProps->ppCorrelationID,
                                           pHelper->pCorrelationID);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pSentTime) == pMsgProps->pSentTime);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pArrivedTime) == pMsgProps->pArrivedTime);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pPriority) == pMsgProps->pPriority);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pDelivery) == pMsgProps->pDelivery);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pAcknowledge) == pMsgProps->pAcknowledge);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pAuditing) == pMsgProps->pAuditing);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pApplicationTag) == pMsgProps->pApplicationTag);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppBody,
                                           pMsgProps->ppBody,
                                           pHelper->pBody);
    pMsgProps32->ulBodyBufferSizeInBytes = pMsgProps->ulBodyBufferSizeInBytes;
    pMsgProps32->ulAllocBodyBufferInBytes = pMsgProps->ulAllocBodyBufferInBytes;
    ASSERT(PTR32_TO_PTR(pMsgProps32->pBodySize) == pMsgProps->pBodySize);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppTitle,
                                           pMsgProps->ppTitle,
                                           pHelper->pTitle);
    pMsgProps32->ulTitleBufferSizeInWCHARs = pMsgProps->ulTitleBufferSizeInWCHARs;
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulTitleBufferSizeInWCHARs) == pMsgProps->pulTitleBufferSizeInWCHARs);
    pMsgProps32->ulAbsoluteTimeToQueue = pMsgProps->ulAbsoluteTimeToQueue;
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulRelativeTimeToQueue) == pMsgProps->pulRelativeTimeToQueue);
    pMsgProps32->ulRelativeTimeToLive = pMsgProps->ulRelativeTimeToLive;
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulRelativeTimeToLive) == pMsgProps->pulRelativeTimeToLive);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulSenderIDType) == pMsgProps->pulSenderIDType);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppSenderID,
                                           pMsgProps->ppSenderID,
                                           pHelper->pSenderID);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulSenderIDLenProp) == pMsgProps->pulSenderIDLenProp);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulPrivLevel) == pMsgProps->pulPrivLevel);
    pMsgProps32->ulAuthLevel = pMsgProps->ulAuthLevel;
    ASSERT(PTR32_TO_PTR(pMsgProps32->pAuthenticated) == pMsgProps->pAuthenticated);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulHashAlg) == pMsgProps->pulHashAlg);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulEncryptAlg) == pMsgProps->pulEncryptAlg);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppSenderCert,
                                           pMsgProps->ppSenderCert,
                                           pHelper->pSenderCert);
    pMsgProps32->ulSenderCertLen = pMsgProps->ulSenderCertLen;
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulSenderCertLenProp) == pMsgProps->pulSenderCertLenProp);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppwcsProvName,
                                           pMsgProps->ppwcsProvName,
                                           pHelper->pwcsProvName);
    pMsgProps32->ulProvNameLen = pMsgProps->ulProvNameLen;
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulAuthProvNameLenProp) == pMsgProps->pulAuthProvNameLenProp);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulProvType) == pMsgProps->pulProvType);
    pMsgProps32->fDefaultProvider = pMsgProps->fDefaultProvider;
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppSymmKeys,
                                           pMsgProps->ppSymmKeys,
                                           pHelper->pSymmKeys);
    pMsgProps32->ulSymmKeysSize = pMsgProps->ulSymmKeysSize;
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulSymmKeysSizeProp) == pMsgProps->pulSymmKeysSizeProp);
    pMsgProps32->bEncrypted = pMsgProps->bEncrypted;
    pMsgProps32->bAuthenticated = pMsgProps->bAuthenticated;
    pMsgProps32->uSenderIDLen = pMsgProps->uSenderIDLen;
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppSignature,
                                           pMsgProps->ppSignature,
                                           pHelper->pSignature);
    pMsgProps32->ulSignatureSize = pMsgProps->ulSignatureSize;
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulSignatureSizeProp) == pMsgProps->pulSignatureSizeProp);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppSrcQMID,
                                           pMsgProps->ppSrcQMID,
                                           pHelper->pSrcQMID);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pUow) == pMsgProps->pUow);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppMsgExtension,
                                           pMsgProps->ppMsgExtension,
                                           pHelper->pMsgExtension);
    pMsgProps32->ulMsgExtensionBufferInBytes = pMsgProps->ulMsgExtensionBufferInBytes;
    ASSERT(PTR32_TO_PTR(pMsgProps32->pMsgExtensionSize) == pMsgProps->pMsgExtensionSize);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppConnectorType,
                                           pMsgProps->ppConnectorType,
                                           pHelper->pConnectorType);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulBodyType) == pMsgProps->pulBodyType);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pulVersion) == pMsgProps->pulVersion);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pbFirstInXact) == pMsgProps->pbFirstInXact);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pbLastInXact) == pMsgProps->pbLastInXact);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppXactID,
                                           pMsgProps->ppXactID,
                                           pHelper->pXactID);

    ASSERT(PTR32_TO_PTR(pMsgProps32->pLookupId) == pMsgProps->pLookupId);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppSrmpEnvelope,
                                           pMsgProps->ppSrmpEnvelope,
                                           pHelper->pSrmpEnvelope);
    ASSERT(PTR32_TO_PTR(pMsgProps32->pSrmpEnvelopeBufferSizeInWCHARs) == pMsgProps->pSrmpEnvelopeBufferSizeInWCHARs);
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pMsgProps32->ppCompoundMessage,
                                           pMsgProps->ppCompoundMessage,
                                           pHelper->pCompoundMessage);
    pMsgProps32->CompoundMessageSizeInBytes = pMsgProps->CompoundMessageSizeInBytes;
    ASSERT(PTR32_TO_PTR(pMsgProps32->pCompoundMessageSizeInBytes) == pMsgProps->pCompoundMessageSizeInBytes);

} // ACpMsgPropsToMsgProps32


VOID
ACpSendParamsToSendParams32(
    CACSendParameters               * pSendParams,
    const CACSendParameters64Helper * pHelper,
    CACSendParameters_32            * pSendParams32
    )
/*++

Routine Description:

    Convert CACSendParameters back to CACSendParameters_32.

Arguments:

    pSendParams   - Pointer to 64 bit send parameters structure.

    pHelper       - Pointer to a send helper structure.

    pSendParams32 - Pointer to 32 bit send parameters structure.

Return Value:

    None.

--*/
{
    //
    // Convert message properties
    //
    ACpMsgPropsToMsgProps32(
        &pSendParams->MsgProps,
        &pHelper->MsgPropsHelper,
        &pSendParams32->MsgProps
        );

    //
    // Deallocate memory
    //
    if (pSendParams->nAdminMqf != 0)
    {
        delete [] pSendParams->AdminMqf;
        pSendParams->AdminMqf = NULL;
    }

    if (pSendParams->nResponseMqf != 0)
    {
        delete [] pSendParams->ResponseMqf;
        pSendParams->ResponseMqf = NULL;
    }

    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pSendParams32->ppSignatureMqf,
                                           pSendParams->ppSignatureMqf,
                                           pHelper->pSignatureMqf);
    pSendParams32->SignatureMqfSize = pSendParams->SignatureMqfSize;

} // ACpSendParamsToSendParams32


VOID
ACpReceiveParamsToReceiveParams32(
    const CACReceiveParameters         * pReceiveParams,
    const CACReceiveParameters64Helper * pHelper,
    CACReceiveParameters_32            * pReceiveParams32
    )
/*++

Routine Description:

    Convert CACReceiveParameters back to CACReceiveParameters_32.

Arguments:

    pReceiveParams   - Pointer to 64 bit receive parameters structure.

    pHelper          - Pointer to a receive helper structure.

    pReceiveParams32 - Pointer to 32 bit receive parameters structure.

Return Value:

    None.

--*/
{
    //
    // Convert message properties
    //
    ACpMsgPropsToMsgProps32(
        &pReceiveParams->MsgProps,
        &pHelper->MsgPropsHelper,
        &pReceiveParams32->MsgProps
        );

    //
    // Request timeout, Action, Asynchronous, Cursor
    //
    pReceiveParams32->RequestTimeout = pReceiveParams->RequestTimeout;
    pReceiveParams32->Action         = pReceiveParams->Action;
    pReceiveParams32->Asynchronous   = pReceiveParams->Asynchronous;
    pReceiveParams32->Cursor         = pReceiveParams->Cursor;

    //
    // Lookup ID
    //
    pReceiveParams32->LookupId       = pReceiveParams->LookupId;

    //
    // Destination queue
    //
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(
        pReceiveParams32->ppDestFormatName,
        pReceiveParams->ppDestFormatName,
        pHelper->pDestFormatName
        );
    ASSERT(PTR32_TO_PTR(pReceiveParams32->pulDestFormatNameLenProp) == pReceiveParams->pulDestFormatNameLenProp);

    //
    // Admin queue
    //
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(
        pReceiveParams32->ppAdminFormatName,
        pReceiveParams->ppAdminFormatName,
        pHelper->pAdminFormatName
        );
    ASSERT(PTR32_TO_PTR(pReceiveParams32->pulAdminFormatNameLenProp) == pReceiveParams->pulAdminFormatNameLenProp);

    //
    // Response queue
    //
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(
        pReceiveParams32->ppResponseFormatName,
        pReceiveParams->ppResponseFormatName,
        pHelper->pResponseFormatName
        );
    ASSERT(PTR32_TO_PTR(pReceiveParams32->pulResponseFormatNameLenProp) == pReceiveParams->pulResponseFormatNameLenProp);
    
    //
    // Ordering queue
    //
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(
        pReceiveParams32->ppOrderingFormatName,
        pReceiveParams->ppOrderingFormatName,
        pHelper->pOrderingFormatName
        );
    ASSERT(PTR32_TO_PTR(pReceiveParams32->pulOrderingFormatNameLenProp) == pReceiveParams->pulOrderingFormatNameLenProp);

    //
    // Destination Multi Queue Format
    //
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(
        pReceiveParams32->ppDestMqf,
        pReceiveParams->ppDestMqf,
        pHelper->pDestMqf
        ); 
    ASSERT(PTR32_TO_PTR(pReceiveParams32->pulDestMqfLenProp) == pReceiveParams->pulDestMqfLenProp);
    
    //
    // Admin Multi Queue Format
    //
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(
        pReceiveParams32->ppAdminMqf,
        pReceiveParams->ppAdminMqf,
        pHelper->pAdminMqf
        ); 
    ASSERT(PTR32_TO_PTR(pReceiveParams32->pulAdminMqfLenProp) == pReceiveParams->pulAdminMqfLenProp);
    
    //
    // Response Multi Queue Format
    //
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(
        pReceiveParams32->ppResponseMqf,
        pReceiveParams->ppResponseMqf,
        pHelper->pResponseMqf
        ); 
    ASSERT(PTR32_TO_PTR(pReceiveParams32->pulResponseMqfLenProp) == pReceiveParams->pulResponseMqfLenProp);

	//
	// Signature Multi Queue Format
	//
    CHECK_PTR_TO_PTR_CONVERSION_BACK_TO_32(pReceiveParams32->ppSignatureMqf,
                                           pReceiveParams->ppSignatureMqf,
                                           pHelper->pSignatureMqf);
    pReceiveParams32->SignatureMqfSize = pReceiveParams->SignatureMqfSize;
    ASSERT(PTR32_TO_PTR(pReceiveParams32->pSignatureMqfSize) == pReceiveParams->pSignatureMqfSize);
    
} // ACpReceiveParamsToSendParams32


#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\acheap.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    acheap.h

Abstract:

    AC heaps

Author:

    Erez Haba (erezh) 12-Apr-96

Revision History:

    Shai Kariv  (shaik)  11-Apr-2000     Modify for MMF dynamic mapping.

--*/

#ifndef __ACHEAP_H
#define __ACHEAP_H

#include "heap.h"
#include "packet.h"
#include "data.h"

//---------------------------------------------------------
//
//  Heap functions
//
//---------------------------------------------------------

inline CAllocatorBlockOffset ac_malloc(CMMFAllocator** ppAllocator, ACPoolType pool, ULONG size, BOOL fCheckQuota)
{
    ASSERT(g_pAllocator != 0);
    return g_pAllocator->malloc(pool, size, ppAllocator, fCheckQuota);
}

inline void ac_free(CMMFAllocator* pAllocator, CAllocatorBlockOffset abo)
{
    pAllocator->free(abo);
}

inline void ac_release_unused_resources()
{
    ASSERT(g_pAllocator != 0);
    g_pAllocator->ReleaseFreeHeaps();
}

inline void ac_set_quota(ULONGLONG ullQuota)
{
    CPoolAllocator::Quota(ullQuota);
}

inline void ac_bitmap_update(CMMFAllocator* pAllocator, CAllocatorBlockOffset abo, ULONG size, BOOL fExists)
{
    pAllocator->BitmapUpdate(abo, size, fExists);
}

inline NTSTATUS ac_restore_packets(PCWSTR pLogPath, PCWSTR pFilePath, ULONG id, ACPoolType pt)
{
    ASSERT(g_pAllocator != 0);
    return g_pAllocator->RestorePackets(pLogPath, pFilePath, id, pt);
}

inline void ac_set_mapped_limit(ULONG ulMaxMappedFiles)
{
    ASSERT(g_pAllocator != 0);
    g_pAllocator->MappedLimit(ulMaxMappedFiles);
}

inline ULONGLONG ac_get_used_quota()
{
	return CPoolAllocator::GetUsedQuota();
}

inline CBaseHeader* AC2QM(CPacket* pPacket)
{
    return static_cast<CBaseHeader*>(
            pPacket->QmAccessibleBuffer());
}


void
ACpDestroyHeap(
    void
    );


PVOID
ACpCreateHeap(
    PCWSTR pRPath,
    PCWSTR pPPath,
    PCWSTR pJPath,
    PCWSTR pLPath
    );

#endif // __ACHEAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\intlwb\thai2\wb\wbclassf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       wbclassf.cxx
//
//  Contents:   Word Breaker class factory
//
//  History:     weibz,   10-Nov-1997   created 
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include "wbclassf.hxx"
#include "iwbreak.hxx"

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::CWordBreakerCF
//
//  Synopsis:   Word Breaker class factory constructor
//
//--------------------------------------------------------------------------

CWordBreakerCF::CWordBreakerCF( LCID lcid )
        : _cRefs( 1 ), _lcid( lcid )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::~CWordBreakerCF
//
//  Synopsis:   Word Breaker class factory destructor
//
//--------------------------------------------------------------------------

CWordBreakerCF::~CWordBreakerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CWordBreakerCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CWordBreakerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CWordBreakerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::CreateInstance
//
//  Synopsis:   Creates new CWordBreaker object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreakerCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID riid,
    void  * * ppvObject )
{
    CWordBreaker *pIUnk = 0;
    SCODE sc = S_OK;

    if (NULL != pUnkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return E_NOINTERFACE;
    }

    __try 
    {
        pIUnk = new CWordBreaker( _lcid );
        if (pIUnk)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );

            pIUnk->Release();  // Release extra refcount from QueryInterface
        }
        else
        {
            sc = E_UNEXPECTED;
        }
    }
    __except(1)
    {
        Assert( 0 == pIUnk );

        sc = E_UNEXPECTED;
    }


    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreakerCF::LockServer(
    BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\actempl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    actempl.h

Abstract:
    usefull templates

Author:
    Erez Haba (erezh) 5-Mar-96

Revision History:
--*/

#ifndef _ACTEMPL_H
#define _ACTEMPL_H

//---------------------------------------------------------
//
//  Comperision operators
//
//---------------------------------------------------------
//
//  You need only to define operator== and operator<
//
template <class T>
inline BOOL operator !=(const T& a, const T& b)
{
    return !(a == b);
}

template <class T>
inline BOOL operator>(const T& a, const T& b)
{
    return b < a;
}

template <class T>
inline BOOL operator<=(const T& a, const T& b)
{
    return !(b < a);
}

template <class T>
inline BOOL operator>=(const T& a, const T& b)
{
    return !(a < b);
}

//---------------------------------------------------------
//
//  Auto Pointers Templates
//
//---------------------------------------------------------

template<class T>
inline void ACpAddRef(T* p)
{
    if(p)
    {
        p->AddRef();
    }
}

template<class T>
inline void ACpRelease(T* p)
{
    if(p)
    {
        p->Release();
    }
}

//---------------------------------------------------------
//
//  Auto Pointers Templates
//
//---------------------------------------------------------

//
//  return type for 'identifier::operator ->' is not a UDT or reference to a UDT.
//  Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)

//---------------------------------------------------------
//
//  Auto delete pointer
//
//---------------------------------------------------------

template<class T>
class P {
private:
    T* m_p;

public:
    P() : m_p(0)            {}
    P(T* p) : m_p(p)        {}
   ~P()                     { delete m_p; }

    operator T*() const     { return m_p; }
    T** operator &()        { return &m_p;}
    T* operator ->() const  { return m_p; }
    P<T>& operator =(T* p)  { m_p = p; return *this; }
};

//---------------------------------------------------------
//
//  Auto delete[] pointer, used for arrays
//
//---------------------------------------------------------

template<class T>
class AP {
private:
    T* m_p;

public:
    AP() : m_p(0)           {}
    AP(T* p) : m_p(p)       {}
   ~AP()                    { delete[] m_p; }

    operator T*() const     { return m_p; }
    T** operator &()        { return &m_p;}
    T* operator ->() const  { return m_p; }
    AP<T>& operator =(T* p) { m_p = p; return *this; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
};

//---------------------------------------------------------
//
//  Auto Relese() pointer
//
//---------------------------------------------------------

template<class T>
class R {
private:
    T* m_p;

public:
    R() : m_p(0)            {}
    R(T* p) : m_p(p)        {}
   ~R()                     { if(m_p) m_p->Release(); }

    operator T*() const     { return m_p; }
    T** operator &()        { return &m_p;}
    T* operator ->() const  { return m_p; }
    R<T>& operator =(T* p)  { m_p = p; return *this; }
};

#endif // _ACTEMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\acctl32.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    acctl32.h

Abstract:
    Definitions for translations of 32 bit ioctl to 64 bit ioctls and back

Author:
    Raanan Harari (raananh) 13-Mar-2000
    Shai Kariv    (shaik)   14-May-2000

Revision History:

--*/

#ifndef __ACCTL32_H
#define __ACCTL32_H

//
// The file is useful only on Win64
//
#ifdef _WIN64

#include <acdef.h>
#include <qformat.h>

//---------------------------------------------------------
//
//  struct CACSendParameters64Helper
//  struct CACReceiveParameters64Helper
//
//  These structures are used as a scratch pad, temporary structures that hold
//  64 bit pointers to data, and structures that are different between win64
//  and win32. It is used when converting CACSendParameters_32 and 
//  CACReceiveParameters_32 to 64 bit (e.g. when a 32 bit process performs an 
//  AC request).
//
//  CACSendParameters_32 and CACReceiveParameters_32 contain the following values 
//  that need to be converted:
//  - Pointers to pointers - when converting to 64 bit, we need a place to put the
//    inner pointers as 64 bit values, so we put it here.
//  - Structures that are different between win64 and win32 (like QUEUE_FORMAT) - 
//    we create a 64 bit structure here and fill it based on the 32 bit QUEUE_FORMAT
//    (QUEUE_FORMAT_32).
//
//---------------------------------------------------------


struct CACMessageProperties64Helper
{
    OBJECTID* pMessageID;
    UCHAR* pCorrelationID;
    UCHAR* pBody;
    WCHAR* pTitle;
    UCHAR* pSenderID;
    UCHAR* pSenderCert;
    WCHAR* pwcsProvName;
    UCHAR* pSymmKeys;
    UCHAR* pSignature;
    GUID* pSrcQMID;
    UCHAR* pMsgExtension;
    GUID* pConnectorType;
    OBJECTID* pXactID;
    WCHAR* pSrmpEnvelope;
    UCHAR* pCompoundMessage;
};


struct CACSendParameters64Helper
{
    CACMessageProperties64Helper MsgPropsHelper;

    UCHAR* pSignatureMqf;
    UCHAR* pXmldsig;

    WCHAR* pSoapHeader;
    WCHAR* pSoapBody;
};


struct CACReceiveParameters64Helper
{
    CACMessageProperties64Helper MsgPropsHelper;

    WCHAR* pDestFormatName;
    WCHAR* pAdminFormatName;
    WCHAR* pResponseFormatName;
    WCHAR* pOrderingFormatName;

    WCHAR* pDestMqf;
    WCHAR* pAdminMqf;
    WCHAR* pResponseMqf;
	UCHAR* pSignatureMqf;
};


VOID
ACpMsgProps32ToMsgProps(
    const CACMessageProperties_32 * pMsgProps32,
    CACMessageProperties64Helper  * pHelper,
    CACMessageProperties          * pMsgProps
    );

NTSTATUS
ACpSendParams32ToSendParams(
    const CACSendParameters_32 * pSendParams32,
    CACSendParameters64Helper  * pHelper,
    CACSendParameters          * pSendParams
    );

VOID
ACpReceiveParams32ToReceiveParams(
    const CACReceiveParameters_32 * pReceiveParams32,
    CACReceiveParameters64Helper  * pHelper,
    CACReceiveParameters          * pReceiveParams
    );

VOID
ACpMsgPropsToMsgProps32(
    const CACMessageProperties         * pMsgProps,
    const CACMessageProperties64Helper * pHelper,
    CACMessageProperties_32            * pMsgProps32
    );

VOID
ACpSendParamsToSendParams32(
    CACSendParameters               * pSendParams,
    const CACSendParameters64Helper * pHelper,
    CACSendParameters_32            * pSendParams32
    );

VOID
ACpReceiveParamsToReceiveParams32(
    const CACReceiveParameters         * pReceiveParams,
    const CACReceiveParameters64Helper * pHelper,
    CACReceiveParameters_32            * pReceiveParams32
    );


#endif //_WIN64

#endif // __ACCTL32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\avl.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    avl.h

Abstract:

    Definitions for a generic AVL tree.

Author:

    Boaz Feldbaum (BoazF) Apr 5, 1996

Revision History:

--*/

#ifndef __AVL_H
#define __AVL_H

struct AVLNODE;
typedef AVLNODE* PAVLNODE;

// A cursor structure used for scanning the tree.
class CAVLTreeCursor {
private:
    PAVLNODE pPrev;
    PAVLNODE pCurr;
friend class CAVLTree;
};

// Constats used as parameters for the SetCursor() method.
#define POINT_TO_SMALLEST ((PVOID)1)
#define POINT_TO_LARGEST ((PVOID)2)

// Tree handling routines passed to the tree contructor.
typedef BOOL (__cdecl *NODEDOUBLEINSTANCEPROC)(PVOID, PVOID, BOOL);
typedef int (__cdecl *NODECOMPAREPROC)(PVOID, PVOID);
typedef void (__cdecl *NODEDELETEPROC)(PVOID);

// The definition of the tree enumeration callback function.
typedef BOOL (__cdecl *NODEENUMPROC)(PVOID, PVOID, int);

// The AVL tree class definition.
class CAVLTree {
public:
    CAVLTree(NODEDOUBLEINSTANCEPROC, NODECOMPAREPROC, NODEDELETEPROC);
   ~CAVLTree();

    BOOL AddNode(PVOID, CAVLTreeCursor*); // Add a node to the tree.
    void DelNode(PVOID); // Delete a node from the tree.
    PVOID FindNode(PVOID); // Find data in the tree.
    BOOL IsEmpty() { return m_Root == NULL; }; // TRUE if tree is empty.
    BOOL EnumNodes(BOOL, NODEENUMPROC, PVOID); // Enumerate tree nodes.
    BOOL SetCursor(PVOID, CAVLTreeCursor *, PVOID*); // Set a cursor in the tree.
    BOOL GetNext(CAVLTreeCursor *, PVOID*); // Get next node relative to the cursor position.
    BOOL GetPrev(CAVLTreeCursor *, PVOID*); // Get prevoius node relative to the cursor position.

private:
    PAVLNODE m_Root; // Points to the root node.
    NODEDOUBLEINSTANCEPROC m_pfnDblInstNode; // Double instance handler.
    NODECOMPAREPROC m_pfnCompNode; // Node comparison function.
    NODEDELETEPROC m_pfnDelNode; // Delete node's data.

private:
    int Search(PVOID, PAVLNODE &); // Search data in the tree.
    void Balance(PAVLNODE*); // Balance a sub tree, if necessary.
};

#endif // __AVL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\avl.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    avl.cxx

Abstract:

    This module contains the code for generic balanced binary trees (AVL).

Author:

    Boaz Feldbaum (BoazF) Apr 5, 1996

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "avl.h"

#ifndef MQDUMP
#include "avl.tmh"
#endif

// An enumeration type that indicates side of node.
typedef enum {
    Left = 1,
    Right
} TREE_SIDE;

#define VISIT_SIDE_FLAG 1
#define IS_VISITED_FLAG 2

#define NODE_FLAGS(n) ((n)->uFlags)
#define GET_VISIT_SIDE(n) ((NODE_FLAGS(n) & VISIT_SIDE_FLAG) ? Left : Right)
#define SET_VISIT_SIDE(n, s) ((s == Left) ? (NODE_FLAGS(n) |= VISIT_SIDE_FLAG) : \
    (NODE_FLAGS(n) &= ~VISIT_SIDE_FLAG))
#define IS_VISITED(n) ((NODE_FLAGS(n) & IS_VISITED_FLAG) != 0)
#define SET_VISITED(n, v) ((v) ? (NODE_FLAGS(n) |= IS_VISITED_FLAG) : \
    (NODE_FLAGS(n) &= ~IS_VISITED_FLAG))

#define NODE_HEIGHT(pNode) max(((pNode)->ulLeftHeight),((pNode)->ulRightHeight))


// An AVL tree node definition.
struct AVLNODE {
    AVLNODE(); // Constructor.
    AVLNODE *pParent; // Points to the parent of the node. NULL for root node.
    AVLNODE *pLeftChild; // Points to the left hand child node.
    AVLNODE *pRightChild; // Points to the right hand child node.
    PVOID pData; // Points to the data that the node holds.
    UCHAR ulLeftHeight; // Height of left hand sub tree.
    UCHAR ulRightHeight; // Height of the right hand sub tree.
    USHORT uFlags;
    BOOL IsLeaf(void); // TRUE if node is a leaf.
    void Attach(TREE_SIDE, AVLNODE *); // Attach a child node.
};

//
// The constructor for a node in the AVL tree.
//
inline AVLNODE::AVLNODE()
{
    pParent = pLeftChild = pRightChild = NULL;
    pData=  NULL;
    ulLeftHeight = ulRightHeight = 0;
    uFlags = 0;
}

inline BOOL AVLNODE::IsLeaf(void)
{
    return !pLeftChild && !pRightChild;
}

//
// Attach a child node.
//
void AVLNODE::Attach(TREE_SIDE Side, PAVLNODE pNode)
{
    UCHAR h;

    if (pNode) {
        h = (UCHAR)(NODE_HEIGHT(pNode) + 1); // Calculate the new height.
        pNode->pParent = this;  // Make the child point to the parent.
    } else {
        h = 0;
    }

    // Point to the child and set the height on that side.
    if (Side == Right) {
        pRightChild = pNode;
        ulRightHeight = h;
    } else {
        pLeftChild = pNode;
        ulLeftHeight = h;
    }
}


//
// The default node compare procedure. It compares the pointer values. This
// creates a tree of ULONGs.
//
static int __cdecl DefaultNodeCompProc(PVOID v1, PVOID v2)
{
    return ComparePointersAVL(v1, v2);
}


//
// The default object deletion procedure - does nothing.
//
static void __cdecl DefaultNodeDelProc(PVOID /*p*/)
{
    return;
}

//
// The default double object instance handler - does nothing.
//
static BOOL __cdecl DefaultNodeDblInstProc(PVOID /*pNew*/, PVOID /*pOld*/, BOOL /*bInsert*/)
{
    return TRUE;
}

//
// Initialize the AVL tree object.
//
// Parameters:
//      pfnDblInst - A function that deals double instances in the tree. This
//                   function gets called whenever an item is inserted to the tree
//                   and it already exist in the tree, and whenever an item is being
//                   deleted from the tree.
//                   BOOL DblInstProc(PVOID pNew, PVOID pOld, BOOL bInsert)
//                      pNew - Points to the data passed to AddNode() or DelNode()..
//                      pOld - Points to the data in the tree.
//                      bInsert - Indicates whether the function is called upon item
//                                insertion or item deletion.
//                      Return value: Upon item insertion, the return value of
//                                    DblInstProc is the return value of AddNode().
//                                    Upon item deletion, the return value detrmines
//                                    whether the node should be deleted from the tree.
//                                    If DblInstProc returns TRUE, the node is
//                                    deleted.
//      pfnCompNode - A function that is called in order to compare a node in the
//                    tree with a searched data.
//                    int CompNodeProc(PVOID v1, PVOID v2)
//                      v1 - Points to the searched data.
//                      v2 - Points to the data that the node points to.
//                      Returned value: 0 - If the items are equal.
//                                      <0 - If the searched item is smaller than
//                                           the data in the node.
//                                      >0 - Else.
//      pfnDelNode - A function that is called for each of the nodes upon the tree
//                   distruction. When the tree is being destroyed, the application
//                   is given a chance to also destroy the data that is being held
//                   by the nodes in the tree. The function is called once per each
//                   node.
//                   void DelNodeProc(PVOID pData)
//                      pData - Points to the data that is pointed by the node.
//      pMutex - An optional pointer to a fast mutex object that is to be used for
//               mutexing the tree operations. This is an optional parameter.
//
CAVLTree::CAVLTree(
    NODEDOUBLEINSTANCEPROC pfnDblInst,
    NODECOMPAREPROC pfnCompNode,
    NODEDELETEPROC pfnDelNode
    ) :
    m_Root(NULL)
{
    m_pfnCompNode = pfnCompNode ? pfnCompNode : DefaultNodeCompProc;
    m_pfnDelNode = pfnDelNode ? pfnDelNode : DefaultNodeDelProc;
    m_pfnDblInstNode = pfnDblInst ? pfnDblInst : DefaultNodeDblInstProc;
}

//
// CAVLTree distructors.
//
CAVLTree::~CAVLTree()
{
    PAVLNODE pCurr = m_Root;

    if (!pCurr)
    {
        // Empty tree.
        return;
    }

    // Delete left sub-tree, delete right sub-tree, goto parent and delete
    // the child you just left.
    for(;;)
    {
        while (pCurr->pLeftChild) {
            SET_VISITED(pCurr, FALSE);
            SET_VISIT_SIDE(pCurr, Left);
            pCurr = pCurr->pLeftChild;
        }

        SET_VISITED(pCurr, TRUE);
        m_pfnDelNode(pCurr->pData);
        while (!pCurr->pRightChild) {
            do {
                pCurr = pCurr->pParent;
                if (!pCurr)
                    break;
                if (GET_VISIT_SIDE(pCurr) == Left)
                    delete pCurr->pLeftChild;
                else
                    delete pCurr->pRightChild;
            } while (IS_VISITED(pCurr));

            if (pCurr) {
                SET_VISITED(pCurr, TRUE);
                m_pfnDelNode(pCurr->pData);
            } else {
                break;
            }
        }

        if (pCurr) {
            SET_VISIT_SIDE(pCurr, Right);
            pCurr = pCurr->pRightChild;
            SET_VISITED(pCurr, FALSE);
        } else {
            break;
        }
    }

    // Delete the root node.
    delete m_Root;
    m_Root = NULL;
}

//
// Add a node to the tree.
//
BOOL CAVLTree::AddNode(PVOID pData2Add, CAVLTreeCursor *pCurs)
{
    if (!m_Root)
    {
        //
        // Insert the first node in the tree, becomes the root node.
        //
        m_Root = new (PagedPool, NormalPoolPriority) AVLNODE;
        if(m_Root == 0)
        {
        	TrERROR(AC, "Failed to allocate the root AVLNODE from paged pool."); 
            return FALSE;
        }

        m_Root->pData = pData2Add;

        pCurs->pCurr = m_Root;
        pCurs->pPrev = NULL;
        return TRUE;
    }

    PAVLNODE pNode;
    int c = Search(pData2Add, pNode);

    if (c == 0)
    {
        //
        // Handle double instance and leave.
        //
        return m_pfnDblInstNode(pData2Add, pNode->pData, TRUE);
    }

    //
    // Insert a new node.
    //
    PAVLNODE pNewNode = new (PagedPool, NormalPoolPriority) AVLNODE;
    if(pNewNode == 0)
    {
    	TrERROR(AC, "Failed to allocate an AVLNODE from paged pool."); 
        return FALSE;
    }

    pNewNode->pData = pData2Add;
    pNewNode->pParent = pNode;

    pCurs->pCurr = pNewNode;
    pCurs->pPrev = NULL;

    if (c < 0)
    {
        SET_VISIT_SIDE(pNode, Left);
        pNode->pLeftChild = pNewNode;
    }
    else
    {
        SET_VISIT_SIDE(pNode, Right);
        pNode->pRightChild = pNewNode;
    }

    // Go up the tree, update heights and balance the tree.
    do {
        if (GET_VISIT_SIDE(pNode) == Left)
        {
            pNode->ulLeftHeight = (UCHAR)(NODE_HEIGHT(pNode->pLeftChild) + 1);
        }
        else
        {
            pNode->ulRightHeight = (UCHAR)(NODE_HEIGHT(pNode->pRightChild) + 1);
        }
        Balance(&pNode);
        pNode = pNode->pParent;
    } while (pNode);

    return TRUE;
}

//
// Delete a node from the tree.
//
void CAVLTree::DelNode(PVOID pData2Del)
{

    // Empty tree, nothing to do.
    if(!m_Root)
        return;

    // Data was not found, nothing to do.
    PAVLNODE pNode;
    if(Search(pData2Del, pNode) != 0)
        return;

    // See if the node should actually be removed from the tree.
    if(!m_pfnDblInstNode(pData2Del, pNode->pData, FALSE))
        return;


    if((pNode == m_Root) && (m_Root->IsLeaf()))
    {
        // Special handling for a leaf root node.
        delete m_Root;
        m_Root = NULL;
        return;
    }

    // Remove the node from the tree.
    PAVLNODE pOtherNode;
    pOtherNode = pNode->pRightChild;
    if (pOtherNode)
    {
        // Go one child to the right and then try to go all the way to the left.
        SET_VISIT_SIDE(pNode, Right);
        if (pOtherNode->pLeftChild)
        {
            // Go all the way to the left.
            while (pOtherNode->pLeftChild) {
                SET_VISIT_SIDE(pOtherNode, Left);
                pOtherNode = pOtherNode->pLeftChild;
            }
            // Switch the data.
            pNode->pData = pOtherNode->pData;
            // Since the tree in balanced and there is no left child, just drage
            // the right sub tree up.
            pNode = pOtherNode->pParent;
            pOtherNode = pNode->pLeftChild->pRightChild;
            delete pNode->pLeftChild;
            if((pNode->pLeftChild = pOtherNode) != 0)
            {
                pOtherNode->pParent = pNode;
            }
        }
        else
        {
            // No left child, just drag the right sub tree up.
            pNode->pData = pOtherNode->pData;
            if((pNode->pRightChild = pOtherNode->pRightChild) != 0)
            {
                pNode->pRightChild->pParent = pNode;
            }
            delete pOtherNode;
        }
    }
    else
    {
        // No right child.
        pNode = pNode->pParent;
        if (!pNode)
        {
            // Special handling for a root node that doesn't have a right child.
            pNode = m_Root;
            m_Root = pNode->pLeftChild;
            m_Root->pParent = NULL;
            delete pNode;
            return;
        }
        else
        {
            // Delete the node and drag the sub tree up.
            if (GET_VISIT_SIDE(pNode) == Left)
            {
                pOtherNode = pNode->pLeftChild;
                if((pNode->pLeftChild = pOtherNode->pLeftChild) != 0)
                {
                    pNode->pLeftChild->pParent = pNode;
                }
            }
            else
            {
                pOtherNode = pNode->pRightChild;
                if((pNode->pRightChild = pOtherNode->pLeftChild) != 0)
                {
                    pNode->pRightChild->pParent = pNode;
                }
            }
        }
        delete pOtherNode;
    }

    do
    {
        // Go up the tree, update heights and balance the tree.
        if (GET_VISIT_SIDE(pNode) == Left)
        {
            if (pNode->pLeftChild)
                pNode->ulLeftHeight = (UCHAR)(NODE_HEIGHT(pNode->pLeftChild) + 1);
            else
                pNode->ulLeftHeight = 0;
        }
        else
        {
            if (pNode->pRightChild)
            {
                pNode->ulRightHeight = (UCHAR)(NODE_HEIGHT(pNode->pRightChild) + 1);
            }
            else
            {
                pNode->ulRightHeight = 0;
            }
        }
        Balance(&pNode);
        pNode = pNode->pParent;
    } while (pNode);
}

//
// Search the tree for some specific data.
//
int CAVLTree::Search(PVOID pData2Search, PAVLNODE &pNode)
{
    int c;

    ASSERT(m_Root);

    pNode = m_Root;
    if (pNode == 0) {
        // Empty tree.
        return 0;
    }

    for(;;)
    {
        // Compare the searched data with the data in the node.
        c = m_pfnCompNode(pData2Search, pNode->pData);
        if (c) {
            if (c < 0) {
                // Continue the search in the left sub tree.
                SET_VISIT_SIDE(pNode, Left);
                if (pNode->pLeftChild)
                    pNode = pNode->pLeftChild;
                else
                    return c;
            } else {
                // Continue the search in the right sub tree.
                SET_VISIT_SIDE(pNode, Right);
                if (pNode->pRightChild)
                    pNode = pNode->pRightChild;
                else
                    return c;
            }
        } else {
            // The node is found.
            return c;
        }
    }
}

//
// See if the sub tree is unbalanced and balance it, if necessary.
//
void CAVLTree::Balance(PAVLNODE *pNode)
{
    PAVLNODE A, B, C, y, z;
    PAVLNODE pParent;
    int d;

    A = *pNode;
    if (!A) {
        // Empty tree.
        return;
    }

    pParent = A->pParent;
    d = (int)A->ulLeftHeight - (int)A->ulRightHeight;

    if (abs(d) < 2) {
        // The sub tree is balanced.
        return;
    }

    if (d < 0) {
        B = A->pRightChild;
        if (B->ulLeftHeight < B->ulRightHeight) {
          /*
           *                 RR
           *        A                    B
           *       / \                  / \
           *      x   B                A   C
           *         / \    ----->    / \ / \
           *        y   C             x y z w
           *           / \
           *          z   w
           */
            y = B->pLeftChild;
            *pNode = B;
            A->Attach(Right, y);
            B->Attach(Left, A);
        } else {
          /*
           *                 RL
           *        A                    C
           *       / \                  / \
           *      x   B                A   B
           *         / \    ----->    / \ / \
           *        C   w             x y z w
           *       / \
           *      y   z
           */
            C = B->pLeftChild;
            y = C->pLeftChild;
            z = C->pRightChild;
            *pNode = C;
            A->Attach(Right, y);
            B->Attach(Left, z);
            C->Attach(Left, A);
            C->Attach(Right, B);
        }
    } else {
        B = A->pLeftChild;
        if (B->ulLeftHeight < B->ulRightHeight) {
          /*
           *                    LR
           *          A                   C
           *         / \                 / \
           *        B   w               B   A
           *       / \        ----->   / \ / \
           *      x   C                x y z w
           *         / \
           *        y   z
           */
            C = B->pRightChild;
            y = C->pLeftChild;
            z = C->pRightChild;
            *pNode = C;
            A->Attach(Left, z);
            B->Attach(Right, y);
            C->Attach(Right, A);
            C->Attach(Left, B);
         } else {
           /*
            *                    LL
            *           A                       B
            *          / \                     / \
            *         B   w                   C   A
            *        / \           ----->    / \ / \
            *       C   z                    x y z w
            *      / \
            *     x   y
            */
            z = B->pRightChild;
            *pNode = B;
            A->Attach(Left, z);
            B->Attach(Right, A);
        }
    }

    (*pNode)->pParent = pParent;
    if (!pParent) {
        // Update the pointer to the root node.
        m_Root = *pNode;
    } else {
        // Update the child pointer of the parent node.
        if (GET_VISIT_SIDE(pParent) == Left) {
            pParent->pLeftChild = (*pNode);
        } else {
            pParent->pRightChild = (*pNode);
        }
    }
}

#define NEXT_CHILD(bAcc) ((bAcc) ? pCurr->pLeftChild : pCurr->pRightChild)

#ifdef UNUSED
//
// Enumerate all the nodes in the tree in accending or decending order.
//
// Parameters:
//      bAccending - TRUE accending order, FALSE decending order.
//      pfnEnumProc - The enumeration callback procedure:
//                      EnumNodesProc(PVOID pData, PVOID pContext, int iHeight)
//                      pData - A pointer to the node's data.
//                      pContext - A pointer to a context buffer.
//                      iHeight - The height of the node in the tree.
//                      Returned value: TRUE to continue the enumeration, else FALSE.
//      pvContext - A pointer to a context buffer that is passed to the enumeration
//                  procedure.
//
BOOL CAVLTree::EnumNodes(BOOL bAccending, NODEENUMPROC pfnEnumProc,
                         PVOID pvContext)
{
    PAVLNODE pCurr;
    int h = 0;
    BOOL bRet = TRUE;

    if (!m_Root) {
        // Empty tree.
        bRet = FALSE;
        goto ret;
    }

    pCurr = m_Root;

    // Enumerate left sub tree, call the enumeration procedure and enumerate the
    // right sub tree. Do in oposite order in case of decending enumeration.
    do {        
        while (NEXT_CHILD(bAccending)) {
            SET_VISITED(pCurr, FALSE);
            pCurr = NEXT_CHILD(bAccending);
            h++;
        }
        SET_VISITED(pCurr, TRUE);
        if (!pfnEnumProc(pCurr->pData, pvContext, h))
            goto ret;
        while (!NEXT_CHILD(!bAccending)) {
            do {
                pCurr = pCurr->pParent;
                h--;
            } while (pCurr && IS_VISITED(pCurr));
            if (pCurr) {
                SET_VISITED(pCurr, TRUE);
                if (!pfnEnumProc(pCurr->pData, pvContext, h))
                    goto ret;
            } else
                break;
        }
        if (pCurr) {
            pCurr = NEXT_CHILD(!bAccending);
            h++;
            SET_VISITED(pCurr, FALSE);
        }
    } while (pCurr);
    
ret:;
    return bRet;
}
#endif // UNUSED

//
// Find a node in the tree.
//
// Parameter:
//      pData2Find - A pointer that is passed to the node compare function.
//
// Returned value:
//      A pointer to the data in the tree. NULL, if the data was not found.
//
PVOID CAVLTree::FindNode(PVOID pData2Find)
{
    PVOID pRet = NULL;
    PAVLNODE pNode;

    if (m_Root && (Search(pData2Find, pNode) == 0))
        pRet = pNode->pData;

    return pRet;
}

//
// Set a cursor to point to some node in the tree.
//
// Parameters:
//      pData2Point - A pointer to the data that should be pointed by the cursor.
//                    There are two special case values:
//                    POINT_TO_SMALLEST - Point to the smallest value in the tree.
//                    POINT_TO_LARGEST - Point to the largest value in the tree.
//      pCursor - A pointer to a cursor structure. The cursor structure is filled
//                by this function.
//      pData - After calling SetCursor(), this pointer will point to the data that
//              the cursor points to.
//
// Comments:
//      After changing the contents of the tree (adding and/or deleting nodes),
//      it is not possible to use the cursor anymore.
//
BOOL CAVLTree::SetCursor(PVOID pData2Point, CAVLTreeCursor *pCursor, PVOID *pData)
{
    BOOL bRet = FALSE;
    PAVLNODE pNode = NULL;

    // Search the item.
    if (m_Root) {
        switch ((ULONG_PTR)pData2Point) {
        case (ULONG_PTR)POINT_TO_SMALLEST:
            pNode = m_Root;
            while (pNode->pLeftChild)
                pNode = pNode->pLeftChild;
            bRet = TRUE;
            break;
        case (ULONG_PTR)POINT_TO_LARGEST:
            pNode = m_Root;
            while (pNode->pRightChild)
                pNode = pNode->pRightChild;
            bRet = TRUE;
            break;
        default:
            if (Search(pData2Point, pNode) == 0)
                bRet = TRUE;
            break;
        }
    }

    // Point to the item.
    if (bRet) {
        *pData = pNode->pData;
    } else {
        *pData = NULL;
    }

    // Fill the cursor structure.
    pCursor->pCurr = pNode;
    pCursor->pPrev = NULL;

    return bRet;
}

//
// Get the next data in the tree that has the next higher value in the tree.
//
// Parameters:
//      pCursor - A pointer to a cursor structure. The cursor structure must be
//                first filled by the SetCursor().
//      pData - After calling GetNext(), this pointer will point to the data that
//              the cursor points to.
//
// Comments:
//      After changing the contents of the tree (adding and/or deleting nodes),
//      it is not possible to use the cursor anymore.
//
//      GetNext() fails if called when the cursor points to the node with the
//      highest value in the tree.
//
//      After changing the contents of the tree (adding and/or deleting nodes),
//      it is not possible to use the cursor anymore.
//
BOOL CAVLTree::GetNext(CAVLTreeCursor *pCursor, PVOID *pData)
{
    BOOL bRet;
    PAVLNODE pNode;

    pNode = pCursor->pCurr;
    if (!pNode->pRightChild || pNode->pRightChild == pCursor->pPrev) {
        do {
            pNode = pNode->pParent;
            pCursor->pPrev = pCursor->pCurr;
            pCursor->pCurr = pNode;
        } while(pNode && (pNode->pRightChild == pCursor->pPrev));
    } else {
        pNode = pNode->pRightChild;
        while(pNode->pLeftChild)
            pNode = pNode->pLeftChild;
        pCursor->pPrev = NULL;
        pCursor->pCurr = pNode;
    }

    // Point to the item.
    if (pNode) {
        *pData = pNode->pData;
        bRet = TRUE;
    } else {
        *pData = NULL;
        bRet = FALSE;
    }

    return bRet;
}

//
// Get the next data in the tree that has the next lower value in the tree.
//
// Parameters:
//      pCursor - A pointer to a cursor structure. The cursor structure must be
//                first filled by the SetCursor().
//      pData - After calling GetPrev(), this pointer will point to the data that
//              the cursor points to.
//
// Comments:
//      After changing the contents of the tree (adding and/or deleting nodes),
//      it is not possible to use the cursor anymore.
//
//      GetPrev() fails if called when the cursor points to the node with the
//      lowest value in the tree.
//
//      After changing the contents of the tree (adding and/or deleting nodes),
//      it is not possible to use the cursor anymore.
//
BOOL CAVLTree::GetPrev(CAVLTreeCursor *pCursor, PVOID *pData)
{
    BOOL bRet;
    PAVLNODE pNode;

    pNode = pCursor->pCurr;
    if (!pNode->pLeftChild || (pNode->pLeftChild == pCursor->pPrev)) {
        do {
            pNode = pNode->pParent;
            pCursor->pPrev = pCursor->pCurr;
            pCursor->pCurr = pNode;
        } while(pNode && (pNode->pLeftChild == pCursor->pPrev));
    } else {
        pNode = pNode->pLeftChild;
        while(pNode->pRightChild != NULL)
            pNode = pNode->pRightChild;
        pCursor->pPrev = NULL;
        pCursor->pCurr = pNode;
    }

    // Point to the item.
    if (pNode) {
        *pData = pNode->pData;
        bRet = TRUE;
    } else {
        *pData = NULL;
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\acp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    acp.h

Abstract:
    AC private functions

Author:
    Erez Haba (erezh) 5-Feb-96

Revision History:
--*/

#ifndef _ACP_H
#define _ACP_H

#include <qformat.h>
#include "data.h"
#include "treenode.h"

//
//  Bytes to quota charge (1k Granularity)
//
#define ULONGLONG_INFINITE 0xFFFFFFFFFFFFFFFF
#define QUOTA_UNIT  1024
#define QUOTA2BYTE(x) (static_cast<ULONGLONG>(x) * QUOTA_UNIT)
#define BYTE2QUOTA(x) ((((x) / QUOTA_UNIT) < INFINITE) ? static_cast<ULONG>(x/ QUOTA_UNIT) : INFINITE)  
#define ULONGLONG2ULONG(x) ((x < INFINITE)? static_cast<ULONG>(x) : INFINITE) 
//
//  Heap managment constants
//
#define X64K (64 * 1024)

//++
//
// VOID
// ACProbeForRead(
//     IN PVOID Address,
//     IN ULONG Length
//     )
//
//--
inline
void
ACProbeForRead(
    IN PVOID StartAddress,
    IN size_t Length
    )
{
    //
    // To support 32bit process running on 64bit system we allocate helper 
    // structures in kernel memory, so do not probe.
    //
    if (g_fWow64)
    {
        return;
    }

    PVOID EndAddress = static_cast<PCHAR>(StartAddress) + Length;
    if(
        (EndAddress < StartAddress) ||
        (EndAddress > (PVOID)MM_USER_PROBE_ADDRESS))
    {
        ExRaiseAccessViolation();
    }
}

//++
//
// VOID
// ACProbeForWrite(
//     IN PVOID Address,
//     IN size_t Length
//     )
//
//  NOTE: we just check address space validity
//
//--
#define ACProbeForWrite(a, b) ACProbeForRead(a, b)

//-----------------------------------------------------------------------------
//

inline PEPROCESS ACAttachProcess(PEPROCESS pProcess)
{
    PEPROCESS pCurrentProcess = IoGetCurrentProcess();

    if(pCurrentProcess == pProcess)
    {
        return 0;
    }

    KeDetachProcess();
    KeAttachProcess((PRKPROCESS)pProcess);
    return pCurrentProcess;
}

inline void ACDetachProcess(PEPROCESS pProcess)
{
    if(pProcess != 0)
    {
        KeDetachProcess();
        KeAttachProcess((PRKPROCESS)pProcess);
    }
}

//-----------------------------------------------------------------------------
//
//  Time conversion routines
//
//const LONGLONG DIFF1970TO1601 = (1970 - 1601) * 365.25 * 24 * 60 * 60 - (diff);
#define DIFF1970TO1601 ((LONGLONG)(1970 - 1601) * 8766 * 60 * 60 - (78 * 60 * 60))

inline LONGLONG Convert1970to1601(ULONG ulTime)
{
    return ((ulTime + DIFF1970TO1601) * (1000 * 1000 * 10));
}

inline ULONG Convert1601to1970(LONGLONG llTime)
{
    return static_cast<ULONG>((llTime / (1000 * 1000 * 10)) - DIFF1970TO1601);
}

inline ULONG system_time()
{
    LARGE_INTEGER liTime;
    KeQuerySystemTime(&liTime);
    return Convert1601to1970(liTime.QuadPart);
}

//-----------------------------------------------------------------------------
//
//  Safe list manipulation routines
//

inline bool ACpEntryInTree(const CTreeNode& TreeNode)
{
    return (TreeNode.inserted());
}

inline void ACpRemoveEntryList(LIST_ENTRY * pEntry)
{
    ASSERT(pEntry != NULL);
    RemoveEntryList(pEntry);

    //
    // Zero Flink and Blink to aid in debugging
    //
    pEntry->Flink = NULL;
    pEntry->Blink = NULL;    
}

//---------------------------------------------------------
//
//  Helper function for holding/releasing RT irps
//
//  We store state on the IRP.Tail.Overlay.DriverContext structure.
//  Use this class as encapsulation.
//
class CProxy;
class CCursor;
class CPacket;
class CPacketIterator;
class CDriverContext {

public:
    enum IrpContextType {
        ctSend = 1,
        ctReceive,
        ctRemoteReadClient,
        ctXactControl,
    };

    union {

        //
        // Send context
        //
        struct {
            NTSTATUS              m_LastStatus;
        } Send;

        //
        // Receive context: both local receive and remote read server
        //
        struct {
            LIST_ENTRY            m_XactReaderLink;
            CCursor *             m_pCursor;
        } Receive;

        //
        // Remote read client context
        //
        struct {
            CProxy *              m_pProxy;
        } RemoteReadClient;

    } Context;

    union {
        ULONG m_flags;
        struct {
            ULONG m_bfContextType      : 3;
            ULONG m_bfTimeoutArmed     : 1;
            ULONG m_bfTimeoutCompleted : 1;
            ULONG m_bfDiscard          : 1;
            ULONG m_bfManualCancel     : 1;
            ULONG m_bfMultiPackets     : 1;
            ULONG m_bfTag              : 16;
        };
    };

public:

    explicit CDriverContext(NTSTATUS InitialSendStatus);
    explicit CDriverContext(CCursor * pCursor, bool fDiscard, bool fTimeoutArmed);
    explicit CDriverContext(bool fDiscard, bool fTimeoutArmed, CProxy * pProxy);
    explicit CDriverContext(bool fXactControl);

    bool TimeoutArmed(void) const;
    void TimeoutArmed(bool fTimeoutArmed);

    bool TimeoutCompleted(void) const;
    void TimeoutCompleted(bool fTimeoutCompleted);

    bool IrpWillFreePacket(void) const;
    void IrpWillFreePacket(bool fDiscard);

    bool ManualCancel(void) const;
    void ManualCancel(bool fManualCancel);

    bool MultiPackets(void) const;
    void MultiPackets(bool fMultiPackets);

    ULONG Tag(void) const;
    void Tag(USHORT tag);

    //
    // Get/set Send context
    //

    NTSTATUS LastStatus(NTSTATUS NewStatus);

    //
    // Get/set Receive context
    //

    void RemoveXactReaderLink(void);
    void SafeRemoveXactReaderLink(void);
    
    CCursor * Cursor(void) const;
    void Cursor(CCursor * pCursor);

    //
    // Get/set Remote Read Client context
    //

    CProxy * Proxy(void) const;
    void Proxy(CProxy * pProxy);

    IrpContextType ContextType(void) const;

}; // class CDriverContext


//
// Size must not exceed size of IRP.Tail.Overlay.DriverContext
//
C_ASSERT(sizeof(CDriverContext) <= 4 * sizeof(PVOID));


inline CDriverContext* irp_driver_context(PIRP irp)
{
    return reinterpret_cast<CDriverContext*>(&irp->Tail.Overlay.DriverContext);
}

inline CDriverContext::CDriverContext(NTSTATUS InitialSendStatus)
{
    memset(this, 0, sizeof(*this));
    m_bfContextType = ctSend;
    Context.Send.m_LastStatus = InitialSendStatus;
}

inline CDriverContext::CDriverContext(CCursor * pCursor, bool fDiscard, bool fTimeoutArmed)
{
    memset(this, 0, sizeof(*this));
    m_bfContextType = ctReceive;

    InitializeListHead(&Context.Receive.m_XactReaderLink);

    Cursor(pCursor);
    IrpWillFreePacket(fDiscard);
    TimeoutArmed(fTimeoutArmed);
}

inline CDriverContext::CDriverContext(bool fDiscard, bool fTimeoutArmed, CProxy * pProxy)
{
    memset(this, 0, sizeof(*this));
    m_bfContextType = ctRemoteReadClient;

    Proxy(pProxy);
    Tag(++g_IrpTag);
    IrpWillFreePacket(fDiscard);
    TimeoutArmed(fTimeoutArmed);
}

inline CDriverContext::CDriverContext(bool)
{
    memset(this, 0, sizeof(*this));
    m_bfContextType = ctXactControl;
}

inline bool CDriverContext::TimeoutArmed(void) const
{
    return m_bfTimeoutArmed;
}

inline void CDriverContext::TimeoutArmed(bool fTimeoutArmed)
{
    m_bfTimeoutArmed = fTimeoutArmed;
}

inline bool CDriverContext::TimeoutCompleted(void) const
{
    return m_bfTimeoutCompleted;
}

inline void CDriverContext::TimeoutCompleted(bool fTimeoutCompleted)
{
    m_bfTimeoutCompleted = fTimeoutCompleted;
}

inline bool CDriverContext::IrpWillFreePacket(void) const
{
    return m_bfDiscard;
}

inline void CDriverContext::IrpWillFreePacket(bool fDiscard)
{
    m_bfDiscard = fDiscard;
}

inline bool CDriverContext::ManualCancel(void) const
{
    return m_bfManualCancel;
}

inline void CDriverContext::ManualCancel(bool fManualCancel)
{
    m_bfManualCancel = fManualCancel;
}

inline bool CDriverContext::MultiPackets(void) const
{
    return m_bfMultiPackets;
}

inline void CDriverContext::MultiPackets(bool fMultiPackets)
{
    m_bfMultiPackets = fMultiPackets;
}

inline ULONG CDriverContext::Tag(void) const
{
    return m_bfTag;
}

inline void CDriverContext::Tag(USHORT tag)
{
    m_bfTag = tag;
}

inline NTSTATUS CDriverContext::LastStatus(NTSTATUS NewStatus)
{
    ASSERT(ContextType() == ctSend);
    
    ASSERT(MultiPackets());

    if (NT_ERROR(Context.Send.m_LastStatus))
    {
        return Context.Send.m_LastStatus;
    }

    if (NT_WARNING(Context.Send.m_LastStatus) && !NT_ERROR(NewStatus))
    {
        return Context.Send.m_LastStatus;
    }

    if (NT_INFORMATION(Context.Send.m_LastStatus) && !NT_ERROR(NewStatus) && !NT_WARNING(NewStatus))
    {
        return Context.Send.m_LastStatus;
    }

    Context.Send.m_LastStatus = NewStatus;
    if (NT_SUCCESS(Context.Send.m_LastStatus))
    {
        //
        // Overwrite other success codes (e.g. STATUS_PENDING)
        //
        Context.Send.m_LastStatus = STATUS_SUCCESS;
    }

    return Context.Send.m_LastStatus;
}

inline void irp_safe_set_final_status(PIRP irp, NTSTATUS NewStatus)
{
    if (!irp_driver_context(irp)->MultiPackets())
    {
        irp->IoStatus.Status = NewStatus;
        return;
    }

    irp->IoStatus.Status = irp_driver_context(irp)->LastStatus(NewStatus);
}

inline void CDriverContext::RemoveXactReaderLink(void)
{
    ASSERT(ContextType() == ctReceive);

    ACpRemoveEntryList(&Context.Receive.m_XactReaderLink);
}

inline void CDriverContext::SafeRemoveXactReaderLink(void)
{
    if (ContextType() == ctReceive)
    {
        RemoveXactReaderLink();
    }
}
 
inline CCursor* CDriverContext::Cursor(void) const
{
    if (ContextType() == ctRemoteReadClient)
    {
        return NULL;
    }

    ASSERT(ContextType() == ctReceive);

    return Context.Receive.m_pCursor;
}

inline void CDriverContext::Cursor(CCursor * pCursor)
{
    ASSERT(ContextType() == ctReceive);

    Context.Receive.m_pCursor = pCursor;
}

inline CProxy* CDriverContext::Proxy(void) const
{
    ASSERT(ContextType() == ctRemoteReadClient);

    return Context.RemoteReadClient.m_pProxy;
}

inline void CDriverContext::Proxy(CProxy * pProxy)
{
    ASSERT(ContextType() == ctRemoteReadClient);

    Context.RemoteReadClient.m_pProxy = pProxy;
}

inline CDriverContext::IrpContextType CDriverContext::ContextType(void) const
{
    //return (const IrpContextType)m_bfContextType;
    return static_cast<IrpContextType>(m_bfContextType);
}


//---------------------------------------------------------
//
//  FILE_OBJECT to queue conversion
//
class CQueueBase;
inline CQueueBase*& file_object_queue(FILE_OBJECT* pFileObject)
{
    return *reinterpret_cast<CQueueBase**>(&pFileObject->FsContext);
}

inline CQueueBase* file_object_queue(const FILE_OBJECT* pFileObject)
{
    return static_cast<CQueueBase*>(pFileObject->FsContext);
}

inline void file_object_set_queue_owner(FILE_OBJECT* pFileObject)
{
    ULONG_PTR & flags = reinterpret_cast<ULONG_PTR&>(pFileObject->FsContext2);
    
    flags |= 1;
}

inline BOOL file_object_is_queue_owner(const FILE_OBJECT* pFileObject)
{
    const ULONG_PTR & flags = reinterpret_cast<const ULONG_PTR&>(pFileObject->FsContext2);

    BOOL rc = ((flags & 1) != 0);
    return rc;
}

inline void file_object_set_protocol_srmp(FILE_OBJECT* pFileObject, bool fProtocolSrmp)
{
    ULONG_PTR & flags = reinterpret_cast<ULONG_PTR&>(pFileObject->FsContext2);
    if (fProtocolSrmp)
    {
        //
        // This is an http queue (direct=http or multicast), or: this is a distribution
        // with at least one http queue member.
        //
        flags |= 2;
        return;
    }

    //
    // This is not an http queue, or: this is a distribution with at least one member
    // that is not http queue.
    //
    flags &= ~2;
}

inline bool file_object_is_protocol_srmp(const FILE_OBJECT* pFileObject)
{
    //
    // Return true iff: this is an http queue (direct=http or multicast), or: this is 
    // a distribution with at least one http queue member.
    //

    const ULONG_PTR & flags = reinterpret_cast<const ULONG_PTR&>(pFileObject->FsContext2);

    bool rc = ((flags & 2) != 0);
    return rc;
}

inline void file_object_set_protocol_msmq(FILE_OBJECT* pFileObject, bool fProtocolMsmq)
{
    ULONG_PTR & flags = reinterpret_cast<ULONG_PTR&>(pFileObject->FsContext2);
    if (fProtocolMsmq)
    {
        //
        // This is not an http queue, or: this is a distribution with at least one member
        // that is not http queue.
        //
        flags |= 4;
        return;
    }

    //
    // This is an http queue (direct=http or multicast), or: this is a distribution
    // with at least one http queue member.
    //
    flags &= ~4;
}

inline bool file_object_is_protocol_msmq(const FILE_OBJECT* pFileObject)
{
    //
    // Return true iff: this is not an http queue, or: this is a distribution with at least
    // one member that is not http queue.
    //

    const ULONG_PTR & flags = reinterpret_cast<const ULONG_PTR&>(pFileObject->FsContext2);

    bool rc = ((flags & 4) != 0);
    return rc;
}

//---------------------------------------------------------
//
//  MessageID helpers
//
ULONGLONG ACpGetSequentialID();

inline void ACpSetSequentialID(ULONGLONG SequentialId)
{
    if(g_MessageSequentialID < SequentialId)
    {
        g_MessageSequentialID = SequentialId;
    }
}

//---------------------------------------------------------
//
//  Queue Format helpers
//
WCHAR * ACpDupString(LPCWSTR pSource);

inline
bool
ACpDupQueueFormat(
    const QUEUE_FORMAT& source,
    QUEUE_FORMAT& target
    )
{
    target = source;

    if (source.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        WCHAR * pDup = ACpDupString(source.DirectID());
        if(pDup == NULL)
        {
            return false;
        }

        target.DirectID(pDup);
        target.Suffix(source.Suffix());
        return true;
    }

    if (source.GetType() == QUEUE_FORMAT_TYPE_DL &&
        source.DlID().m_pwzDomain != NULL)
    {
        DL_ID id;
        id.m_DlGuid    = source.DlID().m_DlGuid;
        id.m_pwzDomain = ACpDupString(source.DlID().m_pwzDomain);
        if(id.m_pwzDomain == NULL)
        {
            return false;
        }

        target.DlID(id);
        return true;
    }

    return true;

} // ACpDupQueueFormat


#endif // _ACP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\bitmap.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    bitmap.cxx

Abstract:

Author:

    Erez Haba (erezh) 13-Apr-1996

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "bitmap.h"

#ifndef MQDUMP
#include "bitmap.tmh"
#endif

#define RightShiftUlong(E1, E2) ((E2) < 32 ? (E1) >> (E2) : 0)
#define LeftShiftUlong(E1, E2)  ((E2) < 32 ? (E1) << (E2) : 0)
#define AndOrUlong(s, E1, E2) ((s) ? ((E1) |= (E2)) : ((E1) &= ~(E2)))

//---------------------------------------------------------
//
//  class CBitmap
//
//---------------------------------------------------------

void CBitmap::FillBits(ULONG ulStartIndex, ULONG ulBitCount, BOOL fSetBits)
{
    //KdPrint("ClearBits %08lx, ", ulBitCount);
    //KdPrint("%08lx", ulStartIndex);
    ASSERT(ulStartIndex + ulBitCount <= m_ulBitCount);

    //
    //  Special case the situation where the number of bits to fill is zero.
    //  Turn this into a noop.
    //
    if(ulBitCount == 0)
    {
        return;
    }

    ULONG BitOffset = ulStartIndex % 32;

    //
    //  Get a pointer to the first longword that needs to be filled
    //
    PULONG CurrentLong = &m_ulBuffer[ulStartIndex / 32];

    //
    //  Check if we can only need to fill one longword.
    //
    ULONG ulMask;
    ULONG ulBitState = (fSetBits) ? 0xFFFFFFFF : 0;
    if((BitOffset + ulBitCount) <= 32)
    {
        //
        //  To build a mask of bits to fill we shift left to get the number
        //  of bits we're changing and then shift right to put it in position.
        //  We'll typecast the right shift to ULONG to make sure it doesn't
        //  do a sign extend.
        //
        ulMask = LeftShiftUlong(
                    RightShiftUlong((ULONG)0xFFFFFFFF, 32 - ulBitCount),
                    BitOffset
                    );

        AndOrUlong(ulBitState, *CurrentLong, ulMask);

        //
        //  And return to our caller
        //
        return;
    }

    //
    //  We can fill out to the end of the first longword so we'll
    //  do that right now.
    //
    ulMask = LeftShiftUlong(0xFFFFFFFF, BitOffset);
    AndOrUlong(ulBitState, *CurrentLong, ulMask);


    //
    //  And indicate what the next longword to fill is and how many
    //  bits are left to fill
    //
    CurrentLong += 1;
    ulBitCount -= 32 - BitOffset;

    //
    //  The bit position is now long aligned, so we can continue
    //  filling longwords until the number to fill is less than 32
    //
    while(ulBitCount >= 32)
    {
        *CurrentLong = ulBitState;
        CurrentLong += 1;
        ulBitCount -= 32;
    }

    //
    //  And now we can clear the remaining bits, if there are any, in the
    //  last longword
    //
    if(ulBitCount > 0)
    {
        ulMask = ~LeftShiftUlong(0xFFFFFFFF, ulBitCount);
        AndOrUlong(ulBitState, *CurrentLong, ulMask);
    }

    //
    //  And return to our caller
    //
    return;
}

const LONG FillMask[] = 
{
    0xffffffff, 0xfffffffe, 0xfffffffc, 0xfffffff8,
    0xfffffff0, 0xffffffe0, 0xffffffc0, 0xffffff80,
    0xffffff00, 0xfffffe00, 0xfffffc00, 0xfffff800,
    0xfffff000, 0xffffe000, 0xffffc000, 0xffff8000,
    0xffff0000, 0xfffe0000, 0xfffc0000, 0xfff80000,
    0xfff00000, 0xffe00000, 0xffc00000, 0xff800000,
    0xff000000, 0xfe000000, 0xfc000000, 0xf8000000,
    0xf0000000, 0xe0000000, 0xc0000000, 0x80000000,
};

inline ULONG ACpFindBitOffset(ULONG ulBits, ULONG ulFirst)
{
    //
    //  Get first set bit in the mask
    //
    ULONG ulMask = FillMask[ulFirst] & -FillMask[ulFirst];

    //
    //  find the first bit set
    //
    while((ulBits & ulMask) == 0)
    {
        ulMask <<= 1;
        ++ulFirst;
    }

    ASSERT(ulFirst < 32);
    return ulFirst;
}

ULONG CBitmap::FindBit(ULONG ulStartIndex) const
{
    while(ulStartIndex < m_ulBitCount)
    {
        ULONG BitOffset = ulStartIndex % 32;

        //
        //  Get a pointer to the longword that needs to be check
        //
        ULONG ulCurrent = m_ulBuffer[ulStartIndex / 32];

        //
        //  check if bits are set from the bit offset, if so return index
        //  to first bit set
        //
        if((ulCurrent & FillMask[BitOffset]) != 0)
        {
            //
            //  found a bit run, return the offset to this bit
            //
            return (ulStartIndex - BitOffset + ACpFindBitOffset(ulCurrent, BitOffset));
        }

        ulStartIndex += 32 - BitOffset;
    }

    return m_ulBitCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\avltree.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    avltree.cxx

Abstract:

    This module contains the code for generic balanced binary trees (AVL).

Author:

    Erez Haba (ErezH) Oct 20, 2001

Revision History:

--*/




#include "internal.h"
#include "avltree.h"

#ifndef MQDUMP
#include "avl.tmh"
#endif


//---------------------------------------------------------
//
// CAVLNode implementation
//
//---------------------------------------------------------
bool CAVLNode::is_parent_of(CAVLNode* p) const
{
    //
    // Find if p is in the tree of this (including this)
    //

    for(; p != 0; p = p->parent())
    {
        if(p == this)
            return true;
    }

    return false;
}


inline int CAVLNode::node_height(CAVLNode* p)
{
    if(p == 0)
        return 0;

    return p->m_height;
}


void CAVLNode::right(CAVLNode* p)
{
    m_pRight = p;
    if(p != 0)
    {
        p->parent(this);
    }
}


void CAVLNode::left(CAVLNode* p)
{
    m_pLeft = p;
    if(p != 0)
    {
        p->parent(this);
    }
}


CAVLNode* CAVLNode::Lmost(CAVLNode* p)
{
    if(p == 0)
        return 0;

    while(p->left() != 0)
    {
        p = p->left();
    }

    return p;
}


CAVLNode* CAVLNode::Rmost(CAVLNode* p)
{
    if(p == 0)
        return 0;

    while(p->right() != 0)
    {
        p = p->right();
    }

    return p;
}


CAVLNode* CAVLNode::next() const
{
    CAVLNode* p = Lmost(right());
    if(p != 0)
        return p;

    //
    // Find first parent that 'this' is left to.
    //
    const CAVLNode* q = this;
    while((p = q->parent()) != 0)
    {
        if(p->left() == q)
            return p;

        q = p;
    }

    return 0;
}


CAVLNode* CAVLNode::prev() const
{
    CAVLNode* p = Rmost(left());
    if(p != 0)
        return p;

    //
    // Find first parent that 'this' is right to.
    //
    const CAVLNode* q = this;
    while((p = q->parent()) != 0)
    {
        if(p->right() == q)
            return p;

        q = p;
    }

    return 0;
}





//---------------------------------------------------------
//
// INSERT
//
//---------------------------------------------------------
inline CAVLNode* CAVLNode::insert_node(CAVLNode* p, Pred less)
{
    if(less(p, this))
    {
        left(p->insert_into(left(), less));
    }
    else
    {
        right(p->insert_into(right(), less));
    }

    return balance();
}


CAVLNode* CAVLNode::insert_into(CAVLNode* p, Pred less)
{
    if(p == 0)
        return this;

    return p->insert_node(this, less);
}





//---------------------------------------------------------
//
// REMOVE
//
//---------------------------------------------------------
inline CAVLNode* CAVLNode::remove_right()
{
    //
    // If this node does not have a left node, it is the one we are looking for.
    //
    CAVLNode* l = Lmost(left());
    if(l == 0)
        return this;

    //
    // Take the left-most node and put it at the top, as a right parent.
    //
    l->right(remove_node(l));
    return l;
}


inline CAVLNode* CAVLNode::remove_top()
{
    //
    // If only left sub-tree exist, we're done (this is arbitrary, right could
    // be used as well, but the rest of the logic need to be updated too)
    //
    CAVLNode* p = right();
    if(p == 0)
        return left();

    //
    // Get the right sub-tree with no left offspring as the top node.
    //
    p = p->remove_right();

    p->left(left());
    return p->balance();
}


CAVLNode* CAVLNode::remove_node(CAVLNode* p)
{
    //
    // Verify that the node belong to this sub-tree (or is its root)
    // This also implicitly verifies that the node is inserted to the tree.
    //
    ASSERT(p != 0);
    ASSERT(is_parent_of(p));

    //
    // Capture p's parent
    //

    CAVLNode* pParent = p->parent();

    //
    // Detach the node from its two offsprings and get a one unbalanced sub-tree
    // combining both. (p is not detached from its parent)
    //
    CAVLNode* t = p->remove_top();

    //
    // Balance all the way up from 'p' until you hit this.
    //
    while(p != this)
    {
        ASSERT(pParent != 0);

        //
        // Assign the new sub-tree to p's original parent at the correct side
        //
        if(p == pParent->right())
        {
            pParent->right(t);
        }
        else
        {
            ASSERT(p == pParent->left());
            pParent->left(t);
        }

        //
        // Move up one level, and balance the parent sub-tree. Capture p's
        // parent before balancing since p might get rotated while balancing.
        //
        p = pParent;
        pParent = p->parent();
        t = p->balance();
    }
    return t;
}


//---------------------------------------------------------
//
// BALANCE
//
//---------------------------------------------------------
inline CAVLNode* CAVLNode::LLRotation()
{
    //
    //                   LL
    //        this                   l
    //         / \                  / \
    //        l   *                *  this
    //       / \        ----->    / \ / \
    //      *   x                *  * x  *
    //     / \
    //    *   *
    //
    CAVLNode* l = left();
    left(l->right());
    l->right(this);
    return l;
}


inline CAVLNode* CAVLNode::LRRotation()
{
    //
    //                   LR
    //       this                  lr
    //        / \                 / \
    //       l   *               l  this
    //      / \        ----->   / \ / \
    //     *   lr              *  x y  *
    //        / \
    //       x   y
    //
    CAVLNode* l = left();
    CAVLNode* lr = l->right();

    l->right(lr->left());
    left(lr->right());

    lr->right(this);
    lr->left(l);
    return lr;
}


inline CAVLNode* CAVLNode::RLRotation()
{
    //
    //                RL
    //     this                   rl
    //      / \                  / \
    //     *   r              this  r
    //        / \    ----->    / \ / \
    //       rl  *            *  x y  *
    //      / \
    //     x   y
    //
    CAVLNode* r = right();
    CAVLNode* rl = r->left();

    r->left(rl->right());
    right(rl->left());

    rl->left(this);
    rl->right(r);
    return rl;
}


inline CAVLNode* CAVLNode::RRRotation()
{
    //
    //                RR
    //     this                   r
    //      / \                  / \
    //     *   r              this  *
    //        / \    ----->    / \ / \
    //       x   *            *  x *  *
    //          / \
    //         *   *
    //
    CAVLNode* r = right();
    right(r->left());
    r->left(this);
    return r;
}


inline int CAVLNode::hdiff() const
{
    int l = node_height(left());
    int r = node_height(right());
    return (l - r);
}


void CAVLNode::calc_height()
{
    int l = node_height(left());
    int r = node_height(right());
    m_height = ((l < r) ? r : l) + 1; // max + 1
}

CAVLNode* CAVLNode::balance()
{
    //
    // Balance this sub-tree
    //
    // NOTE: balance does not sets the new top elements parent.
    //

    switch(hdiff())
    {
        case  2:  // left subtree needs balancing
            switch(left()->hdiff())
            {
                case  1: // LL rotaion
                case  0: // case 0 is for DELETE ONLY
                    return LLRotation();
                
                case -1: // LR rotaion
                    return LRRotation();
                
                default: // Some error in algorithm
                    ASSERT(0);
            };
        
        case -2: // right subtree needs balancing
            switch(right()->hdiff())
            {
                case  1: // RL rotaion
                    return RLRotation();
                
                case  0: // case 0 is for DELETE ONLY
                case -1: // RR rotaion
                    return RRRotation();
                
                default: // Some error in algorithm
                    ASSERT(0);
            };
            
        case  1:
        case  0: // Balanced levels
        case -1:
            return this;
            
        default: // Some error in algorithm
            ASSERT(0);
                
    };
    return this;  // This line, so we'll not get a compiler warrning
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\cancel.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    cancel.cxx

Abstract:

    This module contains the code to for Falcon Cancel routine.

Author:

    Erez Haba (erezh) 3-Aug-95

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"

#ifndef MQDUMP
#include "cancel.tmh"
#endif

BOOL
NTAPI
ACCancelIrp(
    PIRP irp,
    KIRQL irql,
    NTSTATUS status
    )
{
    //
    //  This routine MUST be called with the cancel spin lock held
    //

    irp->Cancel = TRUE;

    //
    // Obtain the address of the cancel routine, and if one was specified,
    // invoke it.
    //
    PDRIVER_CANCEL cr;
    cr = (PDRIVER_CANCEL)InterlockedExchangePointer((PVOID*)&irp->CancelRoutine, 0);
    if(cr != 0)
    {
        irp->CancelIrql = irql;
        irp->IoStatus.Status = status;
        cr(irp->Tail.Overlay.CurrentStackLocation->DeviceObject, irp);

        //
        // The cancel spinlock should have been released by the cancel routine.
        //
        return TRUE;
    }
    else
    {
        //
        // There is no cancel routine, so release the cancel spinlock and
        // return indicating the Irp was not currently cancelable.
        //
        IoReleaseCancelSpinLock(irql);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\avltree.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    avltree.h

Abstract:

    Definitions for a generic AVL tree.

Author:

    Erez Haba (ErezH) Oct 20, 2001

Revision History:

    Milena Salman (msalman) Nov 5, 2001

--*/

#ifndef __AVLTREE_H
#define __AVLTREE_H


#pragma once



#include "treenode.h"

//---------------------------------------------------------
//
// class CAVLNode
//
//---------------------------------------------------------
class CAVLNode : public CTreeNode {
public:
    typedef bool (*Pred)(CAVLNode* e1, CAVLNode* e2);

public:
    CAVLNode* parent() const;
    void parent(CAVLNode*);

    CAVLNode* next() const;
    CAVLNode* prev() const;

    CAVLNode* insert_into(CAVLNode* pTop, Pred less);
    CAVLNode* remove_node(CAVLNode* p);

public:
    CAVLNode* right() const;
    CAVLNode* left() const;

    static CAVLNode* Lmost(CAVLNode* p);
    static CAVLNode* Rmost(CAVLNode* p);

private:
    CAVLNode* insert_node(CAVLNode* p, Pred less);

    CAVLNode* remove_right();
    CAVLNode* remove_top();

    bool is_parent_of(CAVLNode* p) const;

    CAVLNode* balance();
    CAVLNode* LLRotation();
    CAVLNode* LRRotation();
    CAVLNode* RLRotation();
    CAVLNode* RRRotation();
    
  
    void right(CAVLNode*);
    void left(CAVLNode*);

    int hdiff() const;
    void calc_height();
    static int node_height(CAVLNode*);
};


inline CAVLNode* CAVLNode::parent() const
{
    return static_cast<CAVLNode*>(m_pParent);
}


inline CAVLNode* CAVLNode::right() const
{
    return static_cast<CAVLNode*>(m_pRight);
}


inline CAVLNode* CAVLNode::left() const
{
    return static_cast<CAVLNode*>(m_pLeft);
}


inline void CAVLNode::parent(CAVLNode* p)
{
    m_pParent = p;
    calc_height();
}

//---------------------------------------------------------
//
// class AVLHelper 
//
//---------------------------------------------------------

template<class T>
class AVLHelper {
public:

	enum { Offset = FIELD_OFFSET(T, m_treenode) };
   
};

template<class Key>
class Less
{
public:
    bool operator()(const Key& k1, const Key& k2)
    {
        return k1 < k2;
    }
};


//---------------------------------------------------------
//
// class CAVLTree1
//
//---------------------------------------------------------
template<class T, class Key, class Kfn, class Pred = Less<Key>, int Offset = AVLHelper<T>::Offset>
class CAVLTree1 {
public:

    class Iterator;

public:
    CAVLTree1();

    Iterator insert(T& item);
    void remove(T& item);

    Iterator begin() const;
    Iterator end() const;

    Iterator rbegin() const;
    Iterator rend() const;

    bool isempty() const;

    Iterator  find(const Key& key) const;
    Iterator  lower_bound(const Key& key) const;   
    Iterator  upper_bound(const Key& key) const;    

    static CAVLNode* item2node(T&);
    static T& node2item(CAVLNode*);

private:
    static bool less(CAVLNode* e1, CAVLNode* e2);
    
private:
    CAVLNode* m_top;

public:


    //---------------------------------------------------------
    //
    // class CAVLTree1::Iterator
    //
    //---------------------------------------------------------
    class Iterator {
    private:
        CAVLNode* m_node;

    public:
        
        Iterator(CAVLNode* p) :
            m_node(p)
        {
        }
        
        explicit Iterator(T* t) 
        {
            m_node = item2node(*t);
        }

        T& operator*() const
        {
            if(m_node == 0)
            {
        		return *(T*)0;
            }
            return node2item(m_node);
        }

        T* operator->() const
        {
            return (&**this);
        }
        
        operator T*() const
        { 
            return (&**this);
        }

        Iterator& operator =(T* t)
        {
            m_node = item2node(*t);
            return *this;
        } 

        
        Iterator& operator++()
        {
            m_node = m_node->next();
            return *this;
        }

        Iterator operator++(int)
        {
            Iterator tmp = *this;
            ++*this;
            return tmp;
        }

        Iterator& operator--()
        {
            m_node = m_node->prev();
            return *this;
        }

        Iterator operator--(int)
        {
            Iterator tmp = *this;
            --*this;
            return tmp;
        }

        bool operator==(const Iterator& it) const
        {
            return (m_node == it.m_node);
        }

        bool operator!=(const Iterator& it) const
        {
            return !(*this == it);
        }
    };
  
};


template<class T, class Key, class Kfn, class Pred, int Offset >
inline CAVLNode* CAVLTree1<T, Key, Kfn, Pred, Offset>::item2node(T& item)
{
    return ((CAVLNode*)(void*)((char*)&item + Offset));
}


template<class T, class Key, class Kfn, class Pred, int Offset >
inline T& CAVLTree1<T, Key, Kfn, Pred, Offset>::node2item( CAVLNode* node)
{
    return *((T*)(void*)((char*)node - Offset));
}


template<class T, class Key, class Kfn, class Pred, int Offset >
inline bool CAVLTree1<T, Key, Kfn, Pred, Offset>::less( CAVLNode* e1, CAVLNode*e2)
{
    return Pred()(Kfn()(node2item(e1)), Kfn()(node2item(e2)));
}


template<class T, class Key, class Kfn, class Pred, int Offset >
inline CAVLTree1<T, Key, Kfn, Pred, Offset>::CAVLTree1() :
    m_top(0)
{
}


template<class T, class Key, class Kfn, class Pred, int Offset >
typename CAVLTree1<T, Key, Kfn, Pred, Offset>::Iterator CAVLTree1<T, Key, Kfn, Pred, Offset>::insert(T& item)
{
     CAVLNode* p = item2node(item);

    //
    // Verify that item is not in any tree
    //
    ASSERT(!p->inserted());
    m_top = p->insert_into(m_top, less);
    m_top->parent(0);

    return p;
}


template<class T, class Key, class Kfn, class Pred, int Offset >
typename CAVLTree1<T, Key, Kfn, Pred, Offset>::Iterator 
CAVLTree1<T, Key, Kfn, Pred, Offset>::lower_bound(const Key& k) const
{
	CAVLNode* x = m_top;
	CAVLNode* y = 0;
	while (x != 0)
	{
		if (Pred()(Kfn()(node2item(x)), k))
		{
			x = x->right();
		}
		else
		{
			y = x;
			x = x->left();
		}
	}
	return (y);
}

template<class T, class Key, class Kfn, class Pred, int Offset >
typename CAVLTree1<T, Key, Kfn, Pred, Offset>::Iterator 
CAVLTree1<T, Key, Kfn, Pred, Offset>::upper_bound(const Key& k) const
{
	CAVLNode* x = m_top;
	CAVLNode* y = 0;
	while (x != 0)
	{
		if (Pred()( k, Kfn()(node2item(x))))
		{
		    y = x;
			x = x->left();
		}
		else
		{
			x = x->right();
		}
	}
	return (y);
}


template<class T, class Key, class Kfn, class Pred, int Offset >
typename CAVLTree1<T, Key, Kfn, Pred, Offset>::Iterator 
CAVLTree1<T, Key, Kfn, Pred, Offset>::find(const Key& k) const
{
    CAVLTree1<T, Key, Kfn, Pred, Offset>::Iterator it = lower_bound(k);
    if (it == end() || Pred()(k, Kfn()(*it)))
    {
        return end();
    }

    return it;                               
}


template<class T, class Key, class Kfn, class Pred, int Offset >
void CAVLTree1<T, Key, Kfn, Pred, Offset>::remove(T& item)
{
    CAVLNode* p = item2node(item);

    //
    // Verify this is not an empty tree.
    //
    ASSERT(m_top != 0);

    m_top = m_top->remove_node(p);
    if(m_top != 0)
    {
        m_top->parent(0);
    }

    //
    // Reset removed node
    //

    p->init();
}


template<class T, class Key, class Kfn, class Pred, int Offset >
inline typename CAVLTree1<T, Key, Kfn, Pred, Offset>::Iterator CAVLTree1<T, Key, Kfn, Pred, Offset>::begin() const
{
    return  CAVLNode::Lmost(m_top);
}


template<class T, class Key, class Kfn, class Pred, int Offset >
inline typename CAVLTree1<T, Key, Kfn, Pred, Offset>::Iterator CAVLTree1<T, Key, Kfn, Pred, Offset>::end() const
{
    return 0;
}

template<class T, class Key, class Kfn, class Pred, int Offset >
inline typename CAVLTree1<T, Key, Kfn, Pred, Offset>::Iterator CAVLTree1<T, Key, Kfn, Pred, Offset>::rbegin() const
{
    return  CAVLNode::Rmost(m_top);
}

template<class T, class Key, class Kfn, class Pred, int Offset >
inline typename CAVLTree1<T, Key, Kfn, Pred, Offset>::Iterator CAVLTree1<T, Key, Kfn, Pred, Offset>::rend() const
{
    return 0;
}


template<class T, class Key, class Kfn, class Pred, int Offset >
inline bool CAVLTree1<T, Key, Kfn, Pred, Offset>::isempty() const
{
    return (m_top == 0);
}


#endif // __AVLTREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\bitmap.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    bitmap.h

Abstract:

    Bitmap aritmetic

Author:

    Erez Haba (erezh) 27-May-96

Revision History:

--*/

#ifndef __BITMAP_H
#define __BITMAP_H

#pragma warning(disable: 4200)

//---------------------------------------------------------
//
//  class CBitmap
//
//---------------------------------------------------------
class CBitmap {
public:
    CBitmap(ULONG ulBitCount);

    void FillBits(ULONG ulStartIndex, ULONG ulBitCount, BOOL fSetBits);
    ULONG FindBit(ULONG ulStartIndex) const;

private:
    ULONG m_ulBitCount;
    ULONG m_ulBuffer[];
};

#pragma warning(default: 4200)

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

inline CBitmap::CBitmap(ULONG ulBitCount) :
    m_ulBitCount(ulBitCount)
{
    RtlZeroMemory(
        m_ulBuffer,
        ((ulBitCount + 31) / 32) * 4
        );
}

//---------------------------------------------------------
//
//  class CPingPong
//
//---------------------------------------------------------

class CPingPong {

    enum 
	{
		SignatureCoherent = 'zerE',
		SignatureNotCoherent = 'roM',
		SignatureInvalid = 0
	};

public:
    CPingPong();
   ~CPingPong();

    void FillBits(ULONG ulStartIndex, ULONG ulBitCount, BOOL fSetBits);
    ULONG FindBit(ULONG ulStartIndex) const;

    NTSTATUS Validate() const;
    void Invalidate();
    ULONG Ping();
    ULONG CurrentPing() const;
	BOOL IsCoherent() const;
	void SetCoherent();
	BOOL IsNotCoherent() const;
	void SetNotCoherent();

private:
    ULONG m_ulSignature;
    ULONG m_ulPingPong;
    ULONG m_ulReserved1;
    CBitmap m_bm;
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

inline CPingPong::CPingPong() :
    m_ulPingPong(0),
    m_ulReserved1(0),
    m_bm((PAGE_SIZE - sizeof(CPingPong)) * 8)
{
}

inline void CPingPong::Invalidate()
{
    m_ulSignature = SignatureInvalid;
}

inline CPingPong::~CPingPong()
{
    Invalidate();
}

inline void CPingPong::FillBits(ULONG ulStartIndex, ULONG ulBitCount, BOOL fSetBits)
{
    m_bm.FillBits(ulStartIndex, ulBitCount, fSetBits);
}

inline ULONG CPingPong::FindBit(ULONG ulStartIndex) const
{
    return m_bm.FindBit(ulStartIndex);
}

inline NTSTATUS CPingPong::Validate() const
{
	if(IsCoherent() || IsNotCoherent())
	{
		return STATUS_SUCCESS;
	}

	return STATUS_INTERNAL_DB_CORRUPTION;
}

inline BOOL CPingPong::IsCoherent() const
{
	return m_ulSignature == SignatureCoherent;
}

inline void CPingPong::SetCoherent()
{
	m_ulSignature = SignatureCoherent;
}

inline BOOL CPingPong::IsNotCoherent() const
{
	return m_ulSignature == SignatureNotCoherent;
}

inline void CPingPong::SetNotCoherent()
{
	m_ulSignature = SignatureNotCoherent;
}

inline ULONG CPingPong::Ping()
{
    return ++m_ulPingPong;
}

inline ULONG CPingPong::CurrentPing() const
{
    return m_ulPingPong;
}

#endif // __BITMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\cleanup.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    cleanup.cxx

Abstract:

    This module contains the code to for Falcon handle closing.

Author:

    Erez Haba (erezh) 5-Mar-95

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "data.h"
#include "lock.h"
#include "qm.h"
#include "queue.h"
#include "acheap.h"

#ifndef MQDUMP
#include "cleanup.tmh"
#endif

NTSTATUS
ACCleanup(
    IN PDEVICE_OBJECT /*pDevice*/,
    IN PIRP irp
    )
/*++

Routine Description:

    Called when a handle count go to zero.

Arguments:

    pDevice
        Pointer to the device object for this device

    irp
        Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/
{
    //
    //  Serialize access to the driver
    //
    CS lock(g_pLock);
    TrTRACE(AC, "ACCleanup");


    PFILE_OBJECT pFileObject = IoGetCurrentIrpStackLocation(irp)->FileObject;

    CQueueBase* pQueue = file_object_queue(pFileObject);
    if(pQueue != 0)
    {
        //
        //  This is a queue or a group closing
        //
        pQueue->Close(pFileObject, file_object_is_queue_owner(pFileObject));
        TrTRACE(AC, " (pQueueBase=0x%p)", pQueue);
    }

    if(g_pQM->Connection() == pFileObject)
    {
        //
        //  This is the QM service shutdown, disconnect the QM service
        //  and close the machine journal queue
        //
        ACpDestroyHeap();
        TrTRACE(AC, " HEAP DESTROYED");

        g_pQM->Disconnect();
        g_pMachineJournal = 0;
        g_pMachineDeadletter = 0;
        g_pMachineDeadxact = 0;
        TrTRACE(AC, " connection");
    }

    TrTRACE(AC, " (irp=0x%p)", irp);
    irp->IoStatus.Information = 0;
    irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\close.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    close.cxx

Abstract:

    This module contains the code to for Falcon Close routine.

Author:

    Erez Haba (erezh) 1-Aug-95

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "data.h"
#include "lock.h"
#include "queue.h"

#ifndef MQDUMP
#include "close.tmh"
#endif

NTSTATUS
ACClose(
    IN PDEVICE_OBJECT /*pDevice*/,
    IN PIRP irp
    )
/*++

Routine Description:

    Close the last refrence to the queue.

Arguments:

    pDevice
        Pointer to the device object for this device

    irp
        Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/
{
    //
    //  Serialize access to the driver
    //
    CS lock(g_pLock);
    TrTRACE(AC, "ACClose");

    CQueueBase* pQueue = 
        file_object_queue(IoGetCurrentIrpStackLocation(irp)->FileObject);

    if(pQueue != 0)
    {
        pQueue->Release();
        TrTRACE(AC, " (pQueueBase=0x%p)", pQueue);
    }

    if(InterlockedDecrement(&g_DriverHandleCount) == 0)
    {
        //
        // Unmap the performance buffer. We do not need it anymore.
        //
        ACpSetPerformanceBuffer(NULL);
    }

    TrTRACE(AC, " (irp=0x%p)", irp);
    irp->IoStatus.Information = 0;
    irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\control.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    control.cxx

Abstract:

    This module contains the code to for Falcon DeviceControl routine.

Author:

    Erez Haba (erezh) 1-Aug-95
    Shai Kariv (shaik) 11-Apr-2000

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "acioctl.h"
#include "data.h"
#include "qgroup.h"
#include "queue.h"
#include "qproxy.h"
#include "qxact.h"
#include "cursor.h"
#include <mqformat.h>
#include "acheap.h"
#include "qm.h"
#include "lock.h"
#include "store.h"
#include "localsend.h"
#include "acctl32.h"
#include "dl.h"
#include "data.h"

#ifndef MQDUMP
#include "control.tmh"
#endif

#ifdef MQWIN95
#define  VALIDATE_QUEUE(pQueue)                        \
    NTSTATUS rc = CQueueBase::Validate95(pQueue) ;     \
    if (!(NT_SUCCESS(rc)))                             \
    {                                                  \
        return rc ;                                    \
    }
#else
#define  VALIDATE_QUEUE(pQueue) \
    ASSERT(NT_SUCCESS(CQueueBase::Validate(pQueue)));
#endif

#ifdef MQWIN95
#define  VALIDATE_PROXY(pProxy)                        \
    NTSTATUS rc = CProxy::Validate95(pProxy) ;         \
    if (!(NT_SUCCESS(rc)))                             \
    {                                                  \
        return rc ;                                    \
    }
#else
#define  VALIDATE_PROXY(pProxy) \
    ASSERT(NT_SUCCESS(CProxy::Validate(pProxy)));
#endif

#ifdef _DEBUG
#define VALIDATE_PACKET(p) IsValidPacket2(p)
#else
#define VALIDATE_PACKET(p)
#endif

#ifdef _DEBUG
//++
//
// VOID
// SysProbeForWriteUlong(
//     IN PVOID Address
//     );
//
//  Probe for address in system space only
//--
static
void
SysProbeForWriteUlong(
    IN PVOID Address
    )
{
    if(Address <= (PVOID)MM_USER_PROBE_ADDRESS)
    {
        ExRaiseAccessViolation();
    }

    *(volatile ULONG *)(Address) = *(volatile ULONG *)(Address);
}


static
BOOL
IsValidPacket(
    CPacket* pPacket
    )
{
    __try
    {
        //
        // Probe the CPacket address as kernel memory
        //
        SysProbeForWriteUlong(pPacket);

        //
        // Probe packet buffer is in User mode address space, in QM process
        //
        CAccessibleBlock* pab = pPacket->QmAccessibleBufferNoMapping();
        ACProbeForRead(pab, pab->m_size);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }

    return TRUE;
}

static
void
IsValidPacket2(
    CPacket* pPacket
    )
{
    BOOL fPacketIsValid = IsValidPacket(pPacket);
    ASSERT(fPacketIsValid);
}

#endif // _DEBUG


WCHAR * ACpDupString(LPCWSTR pSource)
{
    ASSERT(pSource != NULL);

    size_t len = wcslen(pSource) + 1;

    WCHAR * pDup = new (PagedPool, NormalPoolPriority) WCHAR[len];
    if(pDup == NULL)
    {
    	TrERROR(AC, "Failed to allocate %Id bytes, to duplicate string %ls", len*2, pSource);
        return NULL;
    }

    memcpy(pDup, pSource, len * sizeof(WCHAR));
    return pDup;
}


//
//  Helper funciton, deref object if not 0
//
inline
void
ACpObDereferenceObject(
    IN PVOID pObject
    )
{
    if(pObject != 0)
    {
        ObDereferenceObject(pObject);
    }
}


inline
CQueue*
ACpCreateMachineQueues(
    const GUID* pQMID,
    PFILE_OBJECT pFileObject
    )
{
    ASSERT(g_pMachineDeadletter == 0);
    ASSERT(g_pMachineJournal == 0);
    ASSERT(g_pMachineDeadxact == 0);

    //
    //  Set Machine deadletter queue properties, the queue format is the
    //  machine GUID and machine queue format type.
    //
    QUEUE_FORMAT qf(0, *pQMID);

    //
    //  Create the machine deadletter queue
    //
    CQueue* pQueue =
        new (NonPagedPool) CQueue(
                                pFileObject,
                                FILE_WRITE_ACCESS,
                                FILE_SHARE_READ | FILE_SHARE_DELETE,
                                FALSE,
                                pQMID,
                                &qf,
                                0,       // No performance counters yet
                                0,
                                0,
								0
                                );

    file_object_queue(pFileObject) = pQueue;
    file_object_set_queue_owner(pFileObject);
    file_object_set_protocol_msmq(pFileObject, true);
    file_object_set_protocol_srmp(pFileObject, false);
    if(pQueue == 0)
    {
    	TrERROR(AC, "Failed to allocate a machine deadletter queue from non paged pool."); 
        return 0;
    }

	ASSERT (pQueue->IsValidQueueFormat());

    pQueue->ConfigureAsMachineQueue(FALSE);
    g_pMachineDeadletter = pQueue;

    //
    //  Create the machine journal queue
    //
    pQueue->CreateJournalQueue();
    pQueue = pQueue->JournalQueue();
    if(pQueue == 0)
    {
    	TrERROR(AC, "Failed to create a machine journal queue because of insufficient resources."); 
        return 0;
    }

    pQueue->ConfigureAsMachineQueue(FALSE);
    g_pMachineJournal = pQueue;

    //
    //  Create the machine deadxact queue
    //
    pQueue->CreateJournalQueue();
    pQueue = pQueue->JournalQueue();
    if(pQueue == 0)
    {
        return 0;
    }

    pQueue->ConfigureAsMachineQueue(TRUE);
    QUEUE_FORMAT* pqf = const_cast<QUEUE_FORMAT*>(pQueue->UniqueID());
    pqf->Suffix(QUEUE_SUFFIX_TYPE_DEADXACT);
    g_pMachineDeadxact = pQueue;


    TrTRACE(AC, "MachineDeadletter=0x%p MachineJournal=0x%p\n MachineDeadxact=0x%p", g_pMachineDeadletter, g_pMachineJournal, g_pMachineDeadxact);

    return pQueue;
}


NTSTATUS CheckForQMProcess()
/*++

Routine Description:
	Check that calling process is %SystemPath%\system32\mqsvc.exe

Arguments:
    None

Return Value:
	STATUS_SUCCESS - calling process is %SystemPath%\system32\mqsvc.exe

Note:
	steps:
	1. open our service file "\SystemRoot\SYSTEM32\mqsvc.exe"
	2. get the object name of the file
	3. get the full path of the calling process
	   result is: "\Device\HarddiskVolumeZ\WINDOWS\system32\mqsvc.exe"
	4. check both strings are the same

--*/
{
#ifndef MQDUMP
	//
	// Check that we are in override mode
	//
	if (g_fCheckForQMProcessOverride)
	{
		return STATUS_SUCCESS;
	}
	
	OBJECT_ATTRIBUTES oa;
	UNICODE_STRING usPredefinedFileName;
	RtlInitUnicodeString(&usPredefinedFileName, L"\\SystemRoot\\system32\\mqsvc.exe");

	InitializeObjectAttributes(
							&oa,
	                       	&usPredefinedFileName,
	                       	OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
	                       	NULL,
	                       	NULL
	                       	);

	IO_STATUS_BLOCK ios;
	HANDLE h;
	NTSTATUS rc = ZwOpenFile(&h, FILE_READ_DATA, &oa, &ios, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL);
	if (!NT_SUCCESS(rc))
	{
		return rc;
	}

	PVOID pFileObject;
	OBJECT_HANDLE_INFORMATION hi;
	rc = ObReferenceObjectByHandle (h, STANDARD_RIGHTS_ALL, NULL, KernelMode, &pFileObject, &hi);
	if (!NT_SUCCESS(rc))
	{
		ZwClose(h);
		return rc;
	}

	ULONG size;
	WCHAR ServicePathBuf[256+sizeof(UNICODE_STRING)];
	rc = ObQueryNameString(pFileObject, (POBJECT_NAME_INFORMATION)&ServicePathBuf, sizeof(ServicePathBuf), &size);

	ObDereferenceObject (pFileObject);
	ZwClose(h);

	if (!NT_SUCCESS(rc))
	{
		return rc;
	}

	ServicePathBuf[STRLEN(ServicePathBuf)] = '\0';
	PUNICODE_STRING uszServiceFileName = (PUNICODE_STRING)ServicePathBuf;


	//
	// this is handle to current process
	//
	h = (HANDLE)(LONG_PTR) -1;
	WCHAR ProcessPathBuf[256+sizeof(UNICODE_STRING)];
	rc = ZwQueryInformationProcess (h ,ProcessImageFileName,  &ProcessPathBuf, sizeof(ProcessPathBuf), &size);
	if (!NT_SUCCESS(rc))
	{
		return rc;
	}

	ProcessPathBuf[STRLEN(ProcessPathBuf)] = '\0';
	PUNICODE_STRING usProcessFileName = (PUNICODE_STRING)ProcessPathBuf;

	BOOLEAN b = RtlEqualUnicodeString(usProcessFileName, uszServiceFileName, TRUE);
	if (!b)
	{
	    TrERROR(AC, "Only %ls image can connect to QM interface, not: %ls", uszServiceFileName->Buffer, usProcessFileName->Buffer);
		return STATUS_INVALID_DEVICE_REQUEST;
	}

#endif //MQDUMP
	return STATUS_SUCCESS;
}


static
NTSTATUS
ACConnect(
    const CACConnectParameters *pcp,
    PFILE_OBJECT pFileObject,
    PEPROCESS pProcess
    )
{
    TrTRACE(AC, "ACConnect MessageID=0x%I64x, MaxMessageSize=0x%x, RestoreSeqID=0x%I64x", pcp->MessageID, pcp->ulPoolSize, pcp->liSeqIDAtRestore);

	//
    //  Check that calling process is %SystemPath%\system32\mqsvc.exe
    //
	NTSTATUS rc = CheckForQMProcess();
	if (!NT_SUCCESS(rc))
	{
		return rc;
	}
	
	//
    //  Destroy the old heap if still exists, and create shared memory heap
    //
    ACpDestroyHeap();

    //
    //  Set the heap pool size
    //
    g_ulHeapPoolSize = ALIGNUP_ULONG(pcp->ulPoolSize, X64K);

    //
    //  Set first message ID,
    //  this one is really used after driver restart
    //
    ACpSetSequentialID(pcp->MessageID);

    //
    // Set the value of SeqID at the last restore time
    //
    g_liSeqIDAtRestore = pcp->liSeqIDAtRestore;

    //
    // Set the Xact Compatibility mode flag
    //
    g_fXactCompatibilityMode = pcp->fXactCompatibilityMode;

    //
    //  Make a new heap allocator
    //
    PVOID pAllocator;
    pAllocator = ACpCreateHeap(
                    pcp->pStoragePath[0],  // express
                    pcp->pStoragePath[1],  // persistent
                    pcp->pStoragePath[2],  // journal
                    pcp->pStoragePath[3]   // log
                    );

    if(pAllocator == 0)
    {
        //
        //  Heap allocator can not be created, not enougth resources
        //
        TrERROR(AC, "Failed to create a heap allocator."); 
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    CQueue* pQueue;
    pQueue = ACpCreateMachineQueues(pcp->pgSourceQM, pFileObject);
    if(pQueue == 0)
    {
    	TrERROR(AC, "Failed to create machine queues because of insufficient resources."); 
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  - Set connection to QM process ID.
    //  - Register file object used for connection, this file object will be
    //    used in close time to disconnect from the QM.
    //  - Store the QM unique identifier (a GUID)
    //
    g_pQM->Connect(pProcess, pFileObject, pcp->pgSourceQM);

    return STATUS_SUCCESS;
}

static
NTSTATUS
ACSetMachineProperties(
    ULONG ulQuota
    )
{
    TrTRACE(AC, "ACSetMachineProperties (Quota=%u)", ulQuota);
    ac_set_quota(QUOTA2BYTE(ulQuota));

    return STATUS_SUCCESS;
}

static
NTSTATUS
ACCanCloseQueue(
    CQueueBase* pQueue
    )
{
    TrTRACE(AC, "ACCanCloseQueue (pQueue=0x%p)", pQueue);
    ASSERT(NT_SUCCESS(CQueueBase::Validate(pQueue)));

    return pQueue->CanClose();
}

static
NTSTATUS
ACAllocatePacket(
    BOOL fCheckMachineQuota,
    ACPoolType pt,
    ULONG ulPacketSize,
    CACPacketPtrs* pPacketPtrs,
    PIO_STATUS_BLOCK pIoStatus
    )
{
    TrTRACE(AC, "ACAllocatePacket size=%ul", ulPacketSize);

    __try
    {
        pPacketPtrs->pPacket = 0;
        pPacketPtrs->pDriverPacket = 0;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        //  in some unclear situation when the QM goes down we might cause
        //  an Access Violation here. protect against it and return debug
        //  error code
        //
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Allocate memeory from the packet pool with the requested size
    //
    CPacket* pPacket;
    NTSTATUS rc;
    rc = CPacket::Create(
            &pPacket,
            ulPacketSize,
            pt,
            fCheckMachineQuota
            );

    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    CBaseHeader * pBase = AC2QM(pPacket);
    if (pBase == NULL)
    {
        pPacket->Release();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    TrTRACE(AC, ", pPacket=0x%p", pPacket);

    __try
    {
        //
        // Give the QM a pointer in its address space
        // to the packet buffer and pin-down the buffer.
        //
        pPacketPtrs->pPacket = pBase;
        pPacketPtrs->pDriverPacket = pPacket;
        pPacket->AddRefBuffer();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        //  in some unclear situation when the QM goes down we might cause
        //  an Access Violation here. protect against it and return debug
        //  error code
        //
        return STATUS_INVALID_PARAMETER;
    }

    pIoStatus->Information = sizeof(CBaseHeader*);

    return STATUS_SUCCESS;
}


static
NTSTATUS
ACFreePacket(
    CPacket* pPacket,
    USHORT usClass
    )
{
    TrTRACE(AC, "ACFreePacket pPacket=0x%0p, Class=%hx", pPacket, usClass);
    VALIDATE_PACKET(pPacket);
    ASSERTMSG("ACFreePacket is used twice by the QM\n",
            ((pPacket->Queue() == 0) || pPacket->IsReceived()));

    CPacketBuffer * ppb = pPacket->Buffer();
    if (ppb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The QM is not referencing the packet anymore,
    // unpin the buffer (MMF).
    //
    pPacket->ReleaseBuffer();

    //
    //  Setting packet to unreceived so the packet will be freed,
    //  and all attributes released. i.e., the QM does not hold a
    //  refrence to this packet anymore.
    //
    pPacket->IsReceived(FALSE);
    pPacket->Done(usClass, ppb);

    return STATUS_SUCCESS;
}


static
NTSTATUS
ACFreePacket2(
    CPacket* pPacket,
    USHORT   usClass
    )
{
    TrTRACE(AC, "ACFreePacket2 pPacket=0x%0p, class=%ud", pPacket, usClass);

    if (!pPacket->BufferAttached())
    {
        pPacket->ReleaseBuffer();
        return STATUS_SUCCESS;
    }

    CPacketBuffer * ppb = pPacket->Buffer();
    if (ppb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The QM is not referencing the packet anymore,
    // unpin the buffer (MMF).
    //
    pPacket->ReleaseBuffer();

    //
    //  Don't set this packet to unreceived, it is conditionaly freed.
    //  also remove refrence count
    //
    pPacket->Done(usClass, ppb);

    return STATUS_SUCCESS;
}


NTSTATUS
ACFreePacket1(
    CPacket* pPacket,
    USHORT usClass
    )
{
    TrTRACE(AC, "ACFreePacket1 pPacket=0x%0p, class=%ud", pPacket, usClass);

    NTSTATUS rc;
    rc = ACFreePacket2(pPacket, usClass);
    if (!NT_SUCCESS(rc))
    {
        return rc;
    }

    pPacket->Release();
    return STATUS_SUCCESS;
}


static
NTSTATUS
ACArmPacketTimer(
    CPacket* pPacket,
    BOOL fTarget,
    ULONG ulDelay
    )
{
    TrTRACE(AC, "ACArmPacketTimer pPacket=0x%0p, fTarget=%d", pPacket, fTarget);

    CPacketBuffer * ppb = pPacket->Buffer();
    if (ppb == NULL && pPacket->BufferAttached())
    {
        //
        // Mapping fail due to low resources
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The QM is not referencing the packet anymore,
    // unpin the buffer (MMF).
    //
    pPacket->ReleaseBuffer();

    pPacket->StartTimer(ppb, fTarget, ulDelay);
    pPacket->Release();

    return STATUS_SUCCESS;
}


static
NTSTATUS
ACPutPacket(
    PIRP irp,
    CQueue* pQueue,
    CPacket* pPacket
    )
{
    TrTRACE(AC, "ACPutPacket (pQueue=0x%p, pPacket=0x%p)", pQueue, pPacket);
    ASSERT(NT_SUCCESS(CQueue::Validate(pQueue)));
    VALIDATE_PACKET(pPacket);
    ASSERTMSG("ACPutPacket is used to insert a packet twice to the queue by the QM\n",
            ((pPacket->Queue() == 0) || pPacket->IsReceived()));

    CPacketBuffer * ppb = pPacket->Buffer();
    if (ppb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  The packet Received flag is reset to allow receivers to get this packet
    //
    pPacket->IsReceived(FALSE);

    //
    // We AddRef the packet so it will not be lost while in PuPacket (this will
    // happen when a reciever is receiving from this queue already.
    //
    pPacket->AddRef();

    NTSTATUS rc = pQueue->PutPacket(irp, pPacket, ppb);
    if (NT_SUCCESS(rc))
    {
	    //
	    // The QM is not referencing the packet anymore,
	    // unpin the buffer (MMF).
	    //
	    pPacket->ReleaseBuffer();
    }
    else
    {
    	//
    	// Set the Received flag back on, becuase it is the QM responsebility to
    	// retry to Put it or to free it on error
    	//
	    pPacket->IsReceived(TRUE);
    }

    pPacket->Release();

    return rc;
}

static
NTSTATUS
ACPutPacket1(
    PIRP irp,
    CQueue* pQueue,
    CPacket* pPacket
    )
/*++

Routine Description:

    The QM calls this routine to put the packet in the queue
    but it still references the packet buffer.

    NOTE: The QM calls ACPutPacket or ACFreePacket after calling
    this routine, thus this routine should not release the buffer.

Arguments:

    irp - A pointer to the IRP for this request.

    pQueue - A pointer to the queue.

    pPacket - A pointer to the queue.

Return Value:

    NTSTATUS code.

--*/
{
    TrTRACE(AC, "ACPutPacket1 (pQueue=0x%p, pPacket=0x%p)", pQueue, pPacket);
    ASSERT(NT_SUCCESS(CQueue::Validate(pQueue)));
    VALIDATE_PACKET(pPacket);
    ASSERTMSG("ACPutPacket1 is used incorrectly by the QM\n",
            ((pPacket->Queue() == 0) && !pPacket->IsReceived()));

    CPacketBuffer * ppb = pPacket->Buffer();
    if (ppb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  The packet Received flag is set to indicate that no receiver can get
    //  this packet yet.
    //
    pPacket->IsReceived(TRUE);
    return pQueue->PutPacket(irp, pPacket, ppb);
}

static
NTSTATUS
ACPutRemotePacket(
    CProxy* pProxy,
    ULONG ulTag,
    CPacket* pPacket
    )
{
    TrTRACE(AC, "ACPutRemotePacket (pProxy=0x%p, pPacket=0x%p, tag=%d)", pProxy, pPacket, ulTag);
    VALIDATE_PROXY(pProxy);
    VALIDATE_PACKET(pPacket);


    //
    // Addref the packet, so that it will not disappear afte PutRemotePacket
    //
    pPacket->AddRef();


    NTSTATUS rcProxy = pProxy->PutRemotePacket(pPacket, ulTag);
    if( NT_SUCCESS(rcProxy) )
    {
        //
        // The QM is not referencing the packet anymore,
        // unpin the buffer (MMF).
        //
        pPacket->ReleaseBuffer();
    }

    pPacket->Release();
    return rcProxy;
}

static
NTSTATUS
ACCancelRequest(
    CQueueBase* pQueue,
    NTSTATUS status,
    ULONG ulTag
    )
{
    TrTRACE(AC, "ACCancelRequest (pQueue=0x%p, status=0x%x, tag=%d)", pQueue, status, ulTag);
    VALIDATE_QUEUE(pQueue) ;

    return pQueue->CancelTaggedRequest(status, ulTag);
}

static
NTSTATUS
ACGetPacket(
    PIRP irp,
    CQueueBase* pQueue
    )
{
    TrTRACE(AC, "ACGetPacket (pQueue=0x%p)", pQueue);
    ASSERT(NT_SUCCESS(CQueueBase::Validate(pQueue)));

    return pQueue->ProcessRequest( irp,
                                   INFINITE,
                                   0,
                                   MQ_ACTION_PEEK_CURRENT,
                                   false,
                                   0,
                                   NULL ) ;
}

static
NTSTATUS
ACSendMessage(
    PIRP irp,
    BOOL fCheckMachineQuota,
    CQueue* pQueue,
    CACSendParameters * pSendParams
    )
{
    TrTRACE(AC, "ACSendMessage (pQueue=0x%p)", pQueue);

    NTSTATUS rc;
    rc = CQueue::Validate(pQueue);
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    CTransaction* pXact = 0;
    __try
    {
        ACProbeForRead(pSendParams, sizeof(CACSendParameters));

        XACTUOW * pUow = pSendParams->MsgProps.pUow;
        if (pUow != NULL)
        {
            ACProbeForRead(pUow, sizeof(XACTUOW));
            pXact = CTransaction::Find(pUow);
            if(pXact == 0)
            {
                //
                //  The transaction is not enlisted, or passed prepare phase.
                //
                return MQ_ERROR_TRANSACTION_SEQUENCE;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return GetExceptionCode();
    }

    new (irp_driver_context(irp)) CDriverContext(STATUS_SUCCESS);
    return pQueue->PutNewPacket(irp, pXact, fCheckMachineQuota, pSendParams);

} // ACSendMessage


#ifdef _WIN64
static
NTSTATUS
ACSendMessage_32(
    PIRP irp,
    BOOL fCheckMachineQuota,
    CQueue* pQueue,
    CACSendParameters_32* pSendParams32
    )
{
    TrTRACE(AC, "ACSendMessage_32 (pQueue=0x%p)", pQueue);
    //
    // Convert CACSendParameters_32 to CACSendParameters
    //
    CACSendParameters         SendParams;
    CACSendParameters64Helper Helper;

    NTSTATUS rc;
    rc = ACpSendParams32ToSendParams(pSendParams32, &Helper, &SendParams);
    if (!NT_SUCCESS(rc))
    {
        return rc;
    }

    //
    // Call the regular 64 bit handling routine
    //
    g_fWow64 = TRUE;
    rc = ACSendMessage(
             irp,
             fCheckMachineQuota,
             pQueue,
             &SendParams
             );
    g_fWow64 = FALSE;

    //
    // Convert CACSendParameters_32 back to CACSendParameters.
    //
    ACpSendParamsToSendParams32(&SendParams, &Helper, pSendParams32);

    //
    // return result
    //
    return rc;
}
#endif //_WIN64

static
NTSTATUS
ACpReceiveMessage(
    PIRP irp,
    PFILE_OBJECT pFileObject,
    CUserQueue* pQueue,
    ULONG ulAction,
    ULONG ulTimeout,
    HACCursor32 hCursor,
    const XACTUOW* pUow,
    bool  fReceiveByLookupId,
    ULONGLONG LookupId,
    OUT ULONG *pulTag
    )
{
    NTSTATUS rc;
    rc = CUserQueue::Validate(pQueue);
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    if (!pFileObject->DeleteAccess  &&
        (ulAction == MQ_ACTION_RECEIVE || (ulAction & MQ_LOOKUP_RECEIVE_MASK) == MQ_LOOKUP_RECEIVE_MASK))
    {
        //
        //  Caller want to Receive (which also mean to delete the message)
        //  but he opened the queue only for Peek.
        //
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Check that the transacted status of the operation and queue match.
    //  Also holds for remote reader, you can not remote read within
    //  a transaction.
    //
    if(
        //
        //  Transaction with non transactional queue
        //
        ((pUow != 0) && !pQueue->Transactional()) ||

        //
        //  Peek within a transaction
        //
        (pUow != 0 &&
         ( (ulAction & MQ_ACTION_PEEK_MASK) == MQ_ACTION_PEEK_MASK ||
           (ulAction & MQ_LOOKUP_PEEK_MASK) == MQ_LOOKUP_PEEK_MASK) )
        )
    {
        return MQ_ERROR_TRANSACTION_USAGE;
    }


    CCursor* pCursor = 0;
    if(hCursor != 0)
    {
        pCursor = CCursor::Validate(hCursor);
        if(pCursor == 0 || !pCursor->IsOwner(pFileObject))
        {
            return STATUS_INVALID_HANDLE;
        }
    }
    else
    {
        //
        //  No cursor was supplied, so no movement is allowed for non-lookup.
        //
        if(ulAction & ~MQ_ACTION_PEEK_MASK && !fReceiveByLookupId)
        {
            return STATUS_INVALID_PARAMETER;
        }
    }

    return pQueue->ProcessRequest(
                        irp,
                        ulTimeout,
                        pCursor,
                        ulAction,
                        fReceiveByLookupId,
                        LookupId,
                        pulTag
                        );
} // ACpReceiveMessage

static
NTSTATUS
ACReceiveMessage(
    PIRP irp,
    PFILE_OBJECT pFileObject,
    CUserQueue* pQueue,
    CACReceiveParameters * pReceiveParams
    )
{
    ULONG_PTR cursor = (ULONG_PTR)pReceiveParams->Cursor;
    TrTRACE(AC, "ACReceiveMessage (pQueue=0x%p, pCursor=0x%Ix, Action=0x%x)", pQueue, cursor, pReceiveParams->Action);

    return ACpReceiveMessage(
            irp,
            pFileObject,
            pQueue,
            pReceiveParams->Action,
            pReceiveParams->RequestTimeout,
            pReceiveParams->Cursor,
            pReceiveParams->MsgProps.pUow,
            false,
            0,
            NULL );
}


static
NTSTATUS
ACReceiveMessageByLookupId(
    PIRP                   irp,
    PFILE_OBJECT           pFileObject,
    CUserQueue *           pQueue,
    CACReceiveParameters * pReceiveParams
    )
{
    ASSERT(pReceiveParams->RequestTimeout == 0);
    ASSERT(pReceiveParams->Cursor == 0);

    TrTRACE(AC, "ACReceiveMessageByLookupId (pQueue=0x%p, LookupId=0x%I64x, Action=0x%x)", pQueue, pReceiveParams->LookupId,pReceiveParams->Action);

    return ACpReceiveMessage(
               irp,
               pFileObject,
               pQueue,
               pReceiveParams->Action,
               0,
               0,
               pReceiveParams->MsgProps.pUow,
               true,
               pReceiveParams->LookupId,
               NULL );
} // ACReceiveMessageByLookupId


#ifdef _WIN64
static
NTSTATUS
ACReceiveMessage_32(
    PIRP irp,
    PFILE_OBJECT pFileObject,
    CUserQueue* pQueue,
    CACReceiveParameters_32* pReceiveParams32
    )
{
    TrTRACE(AC, "ACReceiveMessage (pQueue=0x%p, pCursor=0x%x, Action=0x%x)", pQueue, pReceiveParams32->Cursor, pReceiveParams32->Action);

    return ACpReceiveMessage(
            irp,
            pFileObject,
            pQueue,
            pReceiveParams32->Action,
            pReceiveParams32->RequestTimeout,
            pReceiveParams32->Cursor,
            pReceiveParams32->MsgProps.pUow,
            false,
            0,
            NULL );
}


static
NTSTATUS
ACReceiveMessageByLookupId_32(
    PIRP                      irp,
    PFILE_OBJECT              pFileObject,
    CUserQueue *              pQueue,
    CACReceiveParameters_32 * pReceiveParams32
    )
{
    ASSERT(pReceiveParams32->RequestTimeout == 0);
    ASSERT(pReceiveParams32->Cursor == 0);

    TrTRACE(AC, "ACReceiveMessageByLookupId (pQueue=0x%p, LookupId=0x%I64x, Action=0x%x)", pQueue, pReceiveParams32->LookupId, pReceiveParams32->Action);

    return ACpReceiveMessage(
               irp,
               pFileObject,
               pQueue,
               pReceiveParams32->Action,
               0,
               0,
               pReceiveParams32->MsgProps.pUow,
               true,
               pReceiveParams32->LookupId,
               NULL );
} // ACReceiveMessageByLookupId_32
#endif //_WIN64

static
NTSTATUS
ACBeginGetPacket2Remote(
    PIRP irp,
    PFILE_OBJECT pFileObject,
    CQueue* pQueue,
    CACGet2Remote* pg2r
    )
{
    TrTRACE(AC, "ACBeginGetPacket2Remote: pQueue=0x%p, irp=0x%p, Cursor = %d, Action =0x%x, LookupId = (%d, %I64d)", pQueue, irp, (DWORD)pg2r->Cursor, pg2r->Action, pg2r->fReceiveByLookupId, pg2r->LookupId);

    ASSERT(pg2r->pTag != 0);

    if (pg2r->fReceiveByLookupId)
    {
        ASSERT(pg2r->RequestTimeout == 0);
        ASSERT(pg2r->Cursor == 0);
    }

    NTSTATUS rc;
    rc = ACpReceiveMessage(
            irp,
            pFileObject,
            pQueue,
            pg2r->Action,
            pg2r->RequestTimeout,
            pg2r->Cursor,
            0,
            pg2r->fReceiveByLookupId,
            pg2r->LookupId,
            pg2r->pTag );

    //
    //  return the tag of this request even if not pending
    //

    return rc;
}

static
NTSTATUS
ACEndGetPacket2Remote(
    PFILE_OBJECT pFileObject,
    CACGet2Remote* pg2r
    )
{
    CPacket* pPacket = pg2r->lpDriverPacket;
    TrTRACE(AC, "ACEndGetPacket2Remote (pPacket=0x%p)", pPacket);
    VALIDATE_PACKET(pPacket);

    CPacketBuffer * ppb = pPacket->Buffer();
    if (ppb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The QM is not referencing the packet anymore,
    // unpin the buffer (MMF).
    //
    pPacket->ReleaseBuffer();

    CCursor* pCursor = 0;
    HACCursor32 hCursor = pg2r->Cursor;
    if(hCursor != 0)
    {
        pCursor = CCursor::Validate(hCursor);
        ASSERT((pCursor != 0) && pCursor->IsOwner(pFileObject));
        UNREFERENCED_PARAMETER(pFileObject);
    }

    BOOL fDiscard = (pg2r->Action & MQ_ACTION_PEEK_MASK) != MQ_ACTION_PEEK_MASK &&
                    (pg2r->Action & MQ_LOOKUP_PEEK_MASK) != MQ_LOOKUP_PEEK_MASK;
    return pPacket->RemoteRequestTail(pCursor, fDiscard, ppb);
}

static
NTSTATUS
ACCreateCursor(
    PIRP                   irp,	
    PFILE_OBJECT           pFileObject,
    PDEVICE_OBJECT         pDevice,
    CUserQueue           * pQueue
    )
{
    TrTRACE(AC, "ACCreateCursor (pQueue=0x%p)", pQueue);

    NTSTATUS rc;
    rc = CUserQueue::Validate(pQueue);
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    return pQueue->CreateCursor(irp, pFileObject, pDevice);
}


static
NTSTATUS
ACCreateRemoteCursor(
    PDEVICE_OBJECT pDevice,
    CProxy* pProxyQueue,
	const CACCreateRemoteCursorParameters* pcrcp
	)
{
    TrTRACE(AC, "ACCreateRemoteCursor (hRemoteCursor = 0x%x, ulTag = 0x%x)", pcrcp->hRemoteCursor, pcrcp->ulTag);

    ASSERT(pcrcp != NULL);
    ASSERT(pcrcp->hRemoteCursor != 0);

    ASSERT(NT_SUCCESS(CProxy::Validate(pProxyQueue)));

    return pProxyQueue->CreateRemoteCursor(pDevice, pcrcp->hRemoteCursor, pcrcp->ulTag);
}


static
NTSTATUS
ACCloseCursor(
    PFILE_OBJECT pFileObject,
    HACCursor32 hCursor
    )
{
    ULONG_PTR cursor = (ULONG_PTR)hCursor;
    TrTRACE(AC, "ACCloseCursor (hCursor=0x%Ix)", cursor);

    CCursor* pCursor = CCursor::Validate(hCursor);
    if(pCursor == 0 || !pCursor->IsOwner(pFileObject))
    {
        return STATUS_INVALID_HANDLE;
    }

    pCursor->CloseRemote();
    pCursor->Close();
    return STATUS_SUCCESS;
}


static
NTSTATUS
ACMoveQueueToGroup(
    CQueueBase* pQueue,
    HANDLE hGroup
    )
{
    TrTRACE(AC, "ACMoveQueueToGroup pQueue=0x%p", pQueue);

    ASSERT(NT_SUCCESS(CQueueBase::Validate(pQueue)));

    CGroup* pGroup = 0;
    FILE_OBJECT* pFileObject = 0;

    if(hGroup != 0)
    {
        NTSTATUS rc;
        rc = ObReferenceObjectByHandle(
                hGroup,
                GENERIC_ALL,
                0,
                KernelMode,
                reinterpret_cast<PVOID*>(&pFileObject),
                0
                );

        if(!NT_SUCCESS(rc))
        {
            return rc;
        }

        pGroup = static_cast<CGroup*>(file_object_queue(pFileObject));
        ASSERT(NT_SUCCESS(CGroup::Validate(pGroup)));
    }

    TrTRACE(AC, ", pGroup=0x%p)", pGroup);
    pQueue->MoveToGroup(pGroup);

    ACpObDereferenceObject(pFileObject);

    return STATUS_SUCCESS;
}

inline ACCESS_MASK MQ2ACAccess(ULONG MQDesiredAccess)
{
    ACCESS_MASK DesiredAccess = 0;
    if(MQDesiredAccess & (MQ_RECEIVE_ACCESS | MQ_PEEK_ACCESS))
    {
        DesiredAccess |= FILE_READ_ACCESS;
    }
    if(MQDesiredAccess & MQ_RECEIVE_ACCESS)
    {
        DesiredAccess |= DELETE;
    }

    if(MQDesiredAccess & MQ_SEND_ACCESS)
    {
        DesiredAccess |= FILE_WRITE_ACCESS;
    }
    return DesiredAccess;
}

inline ULONG MQ2ACShare(ULONG MQShareAccess)
{
    ULONG ShareAccess = FILE_SHARE_WRITE | FILE_SHARE_DELETE | FILE_SHARE_READ;
    if(MQShareAccess & MQ_DENY_RECEIVE_SHARE)
    {
        ShareAccess &= ~FILE_SHARE_DELETE;
    }
    return ShareAccess;
}

static
NTSTATUS
ACAssociateQueue(
    CUserQueue* pQueue,
    HANDLE  hACHandle,
    ULONG   MQDesiredAccess,
    ULONG   MQShareAccess,
    bool    fProtocolSrmp
    )
{
    TrTRACE(AC, "ACAssociateQueue (pQueue=0x%p, hACHandle=0x%p, fProtocolSrmp=%d)", pQueue, hACHandle, fProtocolSrmp);

    if (pQueue == NULL)
    {
        //
        // Bug 8765. The "real" fix is in qm, cqmgr.cpp.
        // I added this "if" here for better robustness of driver.
        // The real fix identify the case where format name
        // direct=os:remote\system$;journal is opened with MQ_ADMIN_ACCESS
        // and fail the MQOpenQueue call. Without failing in QM, we reach
        // here with NULL pQueue.
        //
        return STATUS_INVALID_HANDLE;
    }

    ASSERT(NT_SUCCESS(CUserQueue::Validate(pQueue)));
    ASSERT(hACHandle != 0);

    PFILE_OBJECT pFileObject;

    NTSTATUS rc;
    rc = ObReferenceObjectByHandle(
            hACHandle,
            GENERIC_ALL,
            0,
            KernelMode,
            reinterpret_cast<PVOID*>(&pFileObject),
            0
            );

    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    ASSERTMSG(
        "The handle is already associated with a queue",
        file_object_queue(pFileObject) == 0
        );

    //
    //  Handle sharing access to the queue
    //
    rc = pQueue->CheckShareAccess(
                    pFileObject,
                    MQ2ACAccess(MQDesiredAccess),
                    MQ2ACShare(MQShareAccess)
                    );

    if(NT_SUCCESS(rc))
    {
        file_object_queue(pFileObject) = pQueue;
        file_object_set_protocol_srmp(pFileObject, fProtocolSrmp);
        file_object_set_protocol_msmq(pFileObject, !fProtocolSrmp);
        pQueue->AddRef();
    }

    ObDereferenceObject(pFileObject);

    return rc;
}

//
// Map a pointer to queue performence counters in the QM's address space into
// the system address space.
//
inline QueueCounters *MapQM2ACQueueCounters(QueueCounters *pQMQueueCounters)
{
    if (pQMQueueCounters)
    {
        return reinterpret_cast<QueueCounters*>(
                reinterpret_cast<PCHAR>(pQMQueueCounters) +
                    g_ulACQM_PerfBuffOffset);
    }

    return(NULL);
}

//
// Map a pointer to QM performence counters in the QM's address space into
// the system address space.
//
inline QmCounters *MapQM2ACQmCounters(QmCounters *pQMQmCounters)
{
    if (pQMQmCounters)
    {
        return reinterpret_cast<QmCounters*>(
                reinterpret_cast<PCHAR>(pQMQmCounters) +
                    g_ulACQM_PerfBuffOffset);
    }

    return(NULL);
}


static
NTSTATUS
ACSetQueueProperties(
    CUserQueue* pQueue,
    const CACSetQueueProperties* pqp
    )
{
    TrTRACE(AC, "ACSetQueueProperties (pQueue=0x%p)", pQueue);
    ASSERT(NT_SUCCESS(CUserQueue::Validate(pQueue)));

    return pQueue->SetProperties(pqp, sizeof(*pqp));
}


static
NTSTATUS
ACGetQueueProperties(
    CUserQueue* pQueue,
    CACGetQueueProperties* pqp
    )
{
    TrTRACE(AC, "ACGetQueueProperties (pQueue=0x%p)", pQueue);
    ASSERT(NT_SUCCESS(CUserQueue::Validate(pQueue)));

    return pQueue->GetProperties(pqp, sizeof(*pqp));
}


static
NTSTATUS
ACGetQueueHandleProperties(
    const PFILE_OBJECT            pFileObject,
    CUserQueue *                  pQueue,
    CACGetQueueHandleProperties * pqhp
    )
{
    TrTRACE(AC, "ACGetQueueHandleProperties (pQueue=0x%p)", pQueue);

	NTSTATUS rc;
    rc = CUserQueue::Validate(pQueue);
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    __try
    {
        ACProbeForWrite(pqhp, sizeof(CACGetQueueHandleProperties));
        pqhp->fProtocolSrmp = file_object_is_protocol_srmp(pFileObject);
        pqhp->fProtocolMsmq = file_object_is_protocol_msmq(pFileObject);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return GetExceptionCode();
    }

    return STATUS_SUCCESS;
}


static
NTSTATUS
ACHandleToFormatName(
    CUserQueue* pQueue,
    LPWSTR lpwcsFormatName,
    ULONG ulBufferLength,
    PULONG pulFormatNameLength
    )
{
    TrTRACE(AC, "ACHandleToFormatName (pQueue=0x%p)", pQueue);

    NTSTATUS rc;
    rc = CUserQueue::Validate(pQueue);
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    __try
    {
        ACProbeForWrite(pulFormatNameLength, sizeof(ULONG));
        ACProbeForWrite(lpwcsFormatName, ulBufferLength);

        rc = pQueue->HandleToFormatName(
                 lpwcsFormatName,
                 ulBufferLength,
                 pulFormatNameLength
                 );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return GetExceptionCode();
    }

    return rc;
}


//
// Use by the QM to purge a deleted queue or undelivered messages. This API doesn't check
// for delete permision.
//
static
NTSTATUS
ACPurgeQueue(
    CUserQueue* pQueue,
    BOOL fDelete,
    USHORT usClass
    )
{
    TrTRACE(AC, "ACPurgeQueue (pQueue=0x%p, Delete=%d, Class=%d)", pQueue, fDelete, usClass);

    NTSTATUS rc;
    rc = CUserQueue::Validate(pQueue);
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    return pQueue->Purge(fDelete, usClass);
}


//
// Use by the RT and the QM (remote queue or dependent client) to purge a user queue.
//
static
NTSTATUS
ACPurgeQueue(
    PFILE_OBJECT pFileObject,
    CUserQueue* pQueue
    )
{
    TrTRACE(AC, "ACPurgeQueue (pQueue=0x%p)", pQueue);

    NTSTATUS rc;
    rc = CUserQueue::Validate(pQueue);
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    if (!pFileObject->DeleteAccess)
    {
        //
        // Caller opened the queue for peek only.
        //
        return STATUS_ACCESS_DENIED;
    }

    return pQueue->Purge(FALSE, MQMSG_CLASS_NORMAL);
}


static
NTSTATUS
ACGetServiceRequest(
    PIRP irp
    )
{
    TrTRACE(AC, "ACGetServiceRequest");

    return g_pQM->ProcessService(irp);
}


static
NTSTATUS
ACCreatePacketCompleted(
    PIRP      irp
    )
{
    TrTRACE(AC, "ACCreatePacketCompleted");

    g_pCreatePacketComplete->HandleNotification(irp);
    return STATUS_PENDING;
}


static
NTSTATUS
ACStorageCompleted(
    PIRP irp
    )
{
    TrTRACE(AC, "ACStorageCompleted");

    g_pStorageComplete->HoldNotification(irp);
    return STATUS_PENDING;
}


NTSTATUS
ACAckingCompleted(
    CPacket* pPacket
    )
{
    TrTRACE(AC, "ACAckingCompleted (pPacket=0x%p)", pPacket);

    //
    // The QM is not referencing the packet anymore,
    // unpin the buffer (MMF).
    //
    pPacket->ReleaseBuffer();

    pPacket->Release();
    return STATUS_SUCCESS;
}

VOID
ACPacketTimeout(
    PVOID pv
    )
{
    //
    //  Serialize access to the driver
    //
    CS lock(g_pLock);
    CPacket* pPacket = static_cast<CPacket*>(pv);
    CQueue* pQueue = pPacket->Queue();
    TrTRACE(AC, "ACPacketTimeout (pQueue=0x%p, pPacket=0x%p)\n", pQueue, pPacket);

    pPacket->HandleTimeout();
}

VOID
ACReceiveTimeout(
    PVOID pv
    )
/*++

Routine Description:

    This function is called by the receive scheduler upon timeout of message
    receive.

Arguments:

    pv
        A pointer to the IRP of the request for which the timeout occured.

Return Value:

    None.

--*/
{
    PIRP irp = (PIRP)pv;

    //
    //  if we got to here this irp is still alive since it is not at the scheduler
    //  and if canceled by NT it will not be completed.
    //
    KIRQL irql;
    IoAcquireCancelSpinLock(&irql);
    irp_driver_context(irp)->TimeoutArmed(false);

    if(!ACCancelIrp(irp, irql, MQ_ERROR_IO_TIMEOUT))
    {
        //
        //  The receiver IRP has already been canceled, but the cancel routine
		//  is blocked waiting for this scheduler routine to complete.
		//  Signal this irp, to unblock the receiver cancel routine
		//
		//  N.B. The irp should not be accessed from this point on. it may have
		//       been freed in another thread/another processor
        //
        irp_driver_context(irp)->TimeoutCompleted(true);
    }

    //
    // The cancel spinlock should have been released by the cancel routine.
    //
}


const XACTUOW NULL_UOW = { 0 };

inline BOOL operator ==(const XACTUOW& a, const XACTUOW& b)
{
    return (RtlCompareMemory(&a, &b, sizeof(XACTUOW)) == sizeof(XACTUOW));
}


static
NTSTATUS
ACPutRestoredPacket(
    CQueue* pQueue,
    CPacket* pPacket
    )
{
    TrTRACE(AC, "ACPutRestoredPacket (pQueue=0x%p, pPacket=0x%p)", pQueue, pPacket);
    ASSERT(NT_SUCCESS(CQueue::Validate(pQueue)));
    VALIDATE_PACKET(pPacket);

    CPacketInfo* ppi = pPacket->Buffer();
    if (ppi == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The QM is not referencing the packet anymore,
    // unpin the buffer (MMF).
    //
    pPacket->ReleaseBuffer();

    if(ppi->InJournalQueue())
    {
        //
        //  This works fine for deadletter and machine journal queues, since
        //  machine journal is deadletter queue journaling queue
        //
        CQueue* pJournal = pQueue->JournalQueue();

        if(pJournal == 0)
        {
            //
            //  We found a packet residing in a journal queue, but the QM does
            //  not know it. It may happen that this queue have already been
            //  deleted, or that QM is offline and queue was not cached.
            //  Assume this is a delete case and put the packet in the queue
            //  itself.
            //
            //  BUGBUG: needs update when queue can changes from temp to local
            //
        }
        else
        {
            pQueue = pJournal;
        }
    }

    if(ppi->InMachineDeadxact())
    {
        pQueue = g_pMachineDeadxact;
    }

    //
    //  check for a packet in a transaction
    //
	if(*ppi->Uow() != NULL_UOW)
	{
		CTransaction* pXact = CTransaction::Find(ppi->Uow());
		if(pXact != 0)
		{
			//
			// Non of the journal queues are transactional. Nor the machine
			// journal neither the queue journal.
			//
			ASSERT(!ppi->InJournalQueue());
			return pXact->RestorePacket(pQueue, pPacket);
		}
	}

    return pQueue->RestorePacket(pPacket);
}

static
NTSTATUS
ACGetRestoredPacket(
    CACRestorePacketCookie * pPacketCookie
    )
{
    TrTRACE(AC, "ACGetRestoredPacket");

    pPacketCookie->pDriverPacket = 0;

    CPacket* pPacket = g_pRestoredPackets->peekhead();
    if(pPacket != 0)
    {
        //
        // Give the QM a cookie to this packet.
        // The cookie contains the sequence ID of the packet and
        // a pointer in kernel address space to the packet object.
        //

        CPacketInfo * ppi = pPacket->Buffer();
        if (ppi == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        g_pRestoredPackets->gethead();
        pPacketCookie->SeqId = ppi->SequentialId();
        pPacketCookie->pDriverPacket = pPacket;
    }

    TrTRACE(AC, ", pPacket=0x%p", pPacket);
    return STATUS_SUCCESS;
}


static
NTSTATUS
ACGetPacketByCookie(
    CACPacketPtrs * pPacketPtrs
    )
/*++

Routine Description:

    Return a packet in QM process address space.

Arguments:

    pPacketPtrs - Pointers to a structure with packet pointers.

Return Value:

    STATUS_SUCCESS - The operation was successful.
    other status   - the operation failed.

--*/
{
    TrTRACE(AC, "ACGetPacketByCookie");

    CPacket * pPacket = pPacketPtrs->pDriverPacket;

#ifdef _DEBUG
    __try
    {
        //
        // Probe the CPacket address as kernel memory
        //
        SysProbeForWriteUlong(pPacket);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        ASSERT(("Invalid packet pointer passed as cookie", 0));
        return STATUS_INVALID_PARAMETER;
    }
#endif // DEBUG

    TrTRACE(AC, ", Packet=0x%p", pPacket);

    //
    // Give the QM a pointer in its address space
    // to the packet buffer and pin-down the buffer.
    //

    CBaseHeader * pBase = AC2QM(pPacket);
    if (pBase == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pPacketPtrs->pPacket = pBase;
    pPacket->AddRefBuffer();

    return STATUS_SUCCESS;

} // ACGetPacketByCookie


static
NTSTATUS
ACRestorePackets(
    PCWSTR pLogPath,
    PCWSTR pFilePath,
    ULONG ulFileID,
    ACPoolType pt
    )
{
    TrTRACE(AC, "ACRestorePackets FileID=%x\n    %S\n    %S", ulFileID, pLogPath, pFilePath);

    return ac_restore_packets(pLogPath, pFilePath, ulFileID, pt);
}


static
NTSTATUS
ACSetMappedLimit(
  ULONG ulMaxMappedFiles
    )
{
    TrTRACE(AC, "ACSetMappedLimit=%lu\n", ulMaxMappedFiles);

    ASSERT(("Max mapped files should never be 0", ulMaxMappedFiles > 0));

    ac_set_mapped_limit(ulMaxMappedFiles);
    return STATUS_SUCCESS;
}


NTSTATUS
ACpSetPerformanceBuffer(
    HANDLE hPerformanceSection,
    PVOID pvQMPerformanceBuffer,
    QueueCounters *pQMDeadLetterCounters,
    QmCounters *pQmCounters
    )
{
    static PVOID pViewBase = 0;

    // If we have a mapped view, unmap it first.
    if (pViewBase)
    {
        MmUnmapViewInSystemSpace(pViewBase);
        pViewBase = 0;

        //
        // The order of the next two lines is important to avoid race condition
        // when updating the performance counters. DO NOT CHANGE THE ORDER OF
        // THE FOLLOWING TWO CODE LINES.
        //
        g_pQmCounters = NULL;
        g_ulACQM_PerfBuffOffset = NO_BUFFER_OFFSET;
    }

    if (hPerformanceSection)
    {
        PVOID pSection;
        ULONG_PTR ulViewSize = 0;

        ASSERT(!pViewBase);

        NTSTATUS rc = ObReferenceObjectByHandle(
                        hPerformanceSection,
                        GENERIC_ALL,
                        0,
                        KernelMode,
                        &pSection,
                        0
                        );

        if(!NT_SUCCESS(rc))
        {
            return rc;
        }

        //
        //  Map the performance buffer in system space.
        //  Init pViewBase with QM address to work on Win95.
        //
        pViewBase = pvQMPerformanceBuffer;
        rc = MmMapViewInSystemSpace(
                pSection,
                &pViewBase,
                &ulViewSize
                );

        //
        //  No need for the section pointer any more
        //
        ObDereferenceObject(pSection);

        if(!NT_SUCCESS(rc))
        {
            return rc;
        }

        g_ulACQM_PerfBuffOffset = (PCHAR)pViewBase - (PCHAR)pvQMPerformanceBuffer;

        QueueCounters* pDeadLetterCounters = MapQM2ACQueueCounters(pQMDeadLetterCounters);
        g_pMachineDeadletter->PerformanceCounters(pDeadLetterCounters);
        g_pMachineDeadxact->PerformanceCounters(pDeadLetterCounters);
        if (pDeadLetterCounters)
        {
            g_pMachineJournal->PerformanceCounters(pDeadLetterCounters + 1);
        }

        g_pQmCounters = MapQM2ACQmCounters(pQmCounters);
    }

    return STATUS_SUCCESS;
}

static
NTSTATUS
ACConvertPacket(
	PIRP      irp,
    CPacket * pPacket,
    BOOL      fStore
	)
/*++

Routine Description:

    The QM calls this routine to convert the packet from an old version (MSMQ 1.0)
    or to change the QM ID on the packets when joining to new domain.

    NOTE: The QM does not have a valid reference to the packet
    when calling this routine. The pointer that is passed to this
    routine is considered opaque by the QM.

Arguments:

    irp                  - Pointer to the IRP for this request.

    pPacket              - Pointer to the packet in kernel address space.

    fStore               - Store the packet (implies computing checksum).
                           In MSMQ 2.0 and higher we use checksum.

Return Value:

    NTSTATUS code.

--*/
{

    TrTRACE(AC, "ACConvertPacket, pPacket=0x%p", pPacket);

    return pPacket->Convert(irp, fStore);
}

static
NTSTATUS
ACIsSequenceOnHold(
    CQueue* pQueue,
    CPacket* pPacket
    )
/*++

Routine Description:

    The QM calls this routine to check if the packet EOD sequence
    is on hold.

    NOTE: The QM calls ACPutPacket or ACFreePacket after calling
    this routine, thus this routine should not release the buffer.

Arguments:

    pQueue - A pointer to the queue for this request.

    pPacket - A pointer to the packet..

Return Value:

    NTSTATUS code.

--*/
{
    TrTRACE(AC, "ACIsSequenceOnHold (pQueue=0x%p, pPacket=0x%p)", pQueue, pPacket);
    ASSERT(NT_SUCCESS(CQueue::Validate(pQueue)));
    VALIDATE_PACKET(pPacket);

    return pQueue->IsSequenceOnHold(pPacket);
}

static
NTSTATUS
ACSetSequenceAck(
    CQueue* pQueue,
    CACSetSequenceAck *ptb
    )
{
    TrTRACE(AC, "ACSetSequenceAck (pQueue=0x%p)", pQueue);
    ASSERT(NT_SUCCESS(CQueue::Validate(pQueue)));

    pQueue->UpdateSeqAckData(ptb->liAckSeqID, ptb->ulAckSeqN);

    return STATUS_SUCCESS;
}

//
//   Transaction-related AC routines
//

static
NTSTATUS
ACXactCommit1(
    PIRP irp,
    CTransaction* pXact
    )
{
    TrTRACE(AC, "ACXactCommit1 (pXact=0x%p)", pXact);
    ASSERT(NT_SUCCESS(CTransaction::Validate(pXact)));

    return pXact->Commit1(irp);
}

static
NTSTATUS
ACXactCommit2(
	PIRP irp,
    CTransaction* pXact
    )
{
    TrTRACE(AC, "ACXactCommit2 (pXact=0x%p)", pXact);
    ASSERT(NT_SUCCESS(CTransaction::Validate(pXact)));

    return pXact->Commit2(irp);
}

static
NTSTATUS
ACXactCommit3(
    CTransaction* pXact
    )
{
    TrTRACE(AC, "ACXactCommit3 (pXact=0x%p)", pXact);
    ASSERT(NT_SUCCESS(CTransaction::Validate(pXact)));

	return pXact->Commit3();
}


static
NTSTATUS
ACXactAbort1(
	PIRP irp,
    CTransaction* pXact
    )
{
    TrTRACE(AC, "ACXactAbort1 (pXact=0x%p)", pXact);
    ASSERT(NT_SUCCESS(CTransaction::Validate(pXact)));

    return pXact->Abort1(irp);
}

static
NTSTATUS
ACXactAbort2(
	CTransaction *pXact
	)
{
    TrTRACE(AC, "ACXactAbort2 (pXact=0x%p)", pXact);
    ASSERT(NT_SUCCESS(CTransaction::Validate(pXact)));

    return pXact->Abort2();
}

static
NTSTATUS
ACXactPrepare(
    PIRP irp,
    CTransaction* pXact
    )
{
    TrTRACE(AC, "ACXactPrepare (pXact=0x%p)", pXact);
    ASSERT(NT_SUCCESS(CTransaction::Validate(pXact)));

    return pXact->Prepare(irp);
}

static
NTSTATUS
ACXactPrepareDefaultCommit(
    PIRP irp,
    CTransaction* pXact
    )
{
    TrTRACE(AC, "ACXactPrepareDefaultCommit (pXact=0x%p)", pXact);
    ASSERT(NT_SUCCESS(CTransaction::Validate(pXact)));

    return pXact->PrepareDefaultCommit(irp);
}

static
NTSTATUS
ACXactGetInformation(
    CTransaction* pXact,
    CACXactInformation* pInfo
    )
{
    TrTRACE(AC, "ACXactGetInformation(pXact=0x%p)", pXact);

    pXact->GetInformation(pInfo);
    return STATUS_SUCCESS;
}

static
NTSTATUS
ACCreateQueue(
    PFILE_OBJECT pFileObject,
    const CACCreateQueueParameters* pqp
    )
{
    CQueue* pQueue =
        new (NonPagedPool) CQueue(
                            pFileObject,
                            0,
                            0,
                            pqp->fTargetQueue,
                            pqp->pDestGUID,
                            pqp->pQueueID,
                            MapQM2ACQueueCounters(pqp->pQueueCounters),
                            pqp->liSeqID,
                            pqp->ulSeqN,
							pqp->SenderStream
                            );

    TrTRACE(AC, "ACCreateQueue (pQueue=0x%p, pJournal=0x%p)", pQueue, pQueue ? pQueue->JournalQueue() : 0);

	if(pQueue == 0)
	{
		TrERROR(AC, "Failed to allocate a Queue from non paged pool."); 
	}

    file_object_queue(pFileObject) = pQueue;
    file_object_set_queue_owner(pFileObject);
    file_object_set_protocol_msmq(pFileObject, true);
    file_object_set_protocol_srmp(pFileObject, false);

    if( (pQueue == 0) ||
        (pqp->fTargetQueue && (pQueue->JournalQueue() == 0)) ||
		(!pQueue->IsValidQueueFormat())
		)
    {
        //
        // N.B. No need to release the queue in second case. when the
        //      file handle will be closed is will release it.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}


static
NTSTATUS
ACCreateDistribution(
    PFILE_OBJECT pFileObject,
    CACCreateDistributionParameters * pParams
    )
{
    ULONG nTopLevelQueueFormats = pParams->nTopLevelQueueFormats;
    const QUEUE_FORMAT * TopLevelQueueFormats = pParams->TopLevelQueueFormats;
    ULONG nQueues = pParams->nQueues;
    const HANDLE * hQueues = pParams->hQueues;
    const bool * HttpSend = pParams->HttpSend;

    //
    // Create distribution object
    //
    CDistribution * pDistribution = new (NonPagedPool) CDistribution(pFileObject);
    TrTRACE(AC, "ACCreateDistribution (pDistribution=0x%p, nQueues=0x%x)", pDistribution, nQueues);
    if (pDistribution == 0)
    {
    	TrERROR(AC, "Failed to allocate a Distribution list from non paged pool."); 
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NTSTATUS rc = pDistribution->SetTopLevelQueueFormats(nTopLevelQueueFormats, TopLevelQueueFormats);
    if (!NT_SUCCESS(rc))
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Attach file object
    //
    file_object_queue(pFileObject) = pDistribution;
    file_object_set_queue_owner(pFileObject);

    //
    // Add queues as members to the distribution object. 0 members is legal.
    //
    file_object_set_protocol_msmq(pFileObject, false);
    file_object_set_protocol_srmp(pFileObject, false);
    for (ULONG ix = 0; ix < nQueues; ++ix)
    {
        rc = pDistribution->AddMember(hQueues[ix], HttpSend[ix]);
        if (!NT_SUCCESS(rc))
        {
            return rc;
        }

        if (HttpSend[ix])
        {
            file_object_set_protocol_srmp(pFileObject, true);
        }
        else
        {
            file_object_set_protocol_msmq(pFileObject, true);
        }
    }

    return STATUS_SUCCESS;

} // ACCreateDistribution


static
NTSTATUS
ACCreateGroup(
    PFILE_OBJECT pFileObject,
    BOOL         fPeekByPriority
    )
{
    CGroup* pGroup = new (NonPagedPool) CGroup(fPeekByPriority);

    TrTRACE(AC, "ACCreateGroup (pGroup=0x%p)", pGroup);

    if(pGroup == 0)
    {
    	TrERROR(AC, "Failed to allocate a Group from non paged pool. PeekByPriority = %d", fPeekByPriority); 
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    file_object_queue(pFileObject) = pGroup;
    file_object_set_queue_owner(pFileObject);
    return STATUS_SUCCESS;
}

static
NTSTATUS
ACCreateTransaction(
    PFILE_OBJECT pFileObject,
    const XACTUOW* pUow
    )
{
    XACTUOW Uow;
    __try
    {
         Uow = *pUow;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return STATUS_INVALID_PARAMETER;
    }

    CTransaction* pXact = new (NonPagedPool) CTransaction(&Uow);

    TrTRACE(AC, "ACCreateTransaction (pXact=0x%p)", pXact);

    if(pXact == 0)
    {
       	TrERROR(AC, "Failed to allocate a CTransaction from non paged pool."); 
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    file_object_queue(pFileObject) = pXact;
    file_object_set_queue_owner(pFileObject);
    return STATUS_SUCCESS;
}

static
NTSTATUS
ACCreateRemoteProxy(
    PFILE_OBJECT pFileObject,
    const CACCreateRemoteProxyParameters* ppp
    )
{
    CProxy* pProxy =
        new (NonPagedPool) CProxy(
                            pFileObject,
                            FILE_WRITE_ACCESS,
                            FILE_SHARE_READ | FILE_SHARE_DELETE,
                            ppp->pQueueID,
                            ppp->cli_pQMQueue
                            );

    TrTRACE(AC, "ACCreateRemoteProxy (pProxy=0x%p)", pProxy);

    if(pProxy == 0)
    {
       	TrERROR(AC, "Failed to allocate a CProxy from non paged pool."); 
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    file_object_queue(pFileObject) = pProxy;
    file_object_set_queue_owner(pFileObject);
    return STATUS_SUCCESS;
}


static
NTSTATUS
ACReleaseResources(
    void
    )
{
    ac_release_unused_resources();
    return STATUS_SUCCESS;
}

static
NTSTATUS
ACGetUsedQuota(
	ULONGLONG* pUsedQuota
	)
{
	*pUsedQuota = ac_get_used_quota();
	return STATUS_SUCCESS;
}

NTSTATUS
ACDeviceControl(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP irp
    )
/*++

Routine Description:

    Device control.

Arguments:

    pDevice
        Pointer to the device object for this device

    irp
        Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/
{
#define MQAC_IOCTL_CONNECT IoGetFunctionCodeFromCtlCode(IOCTL_AC_CONNECT)

    NTSTATUS rc = STATUS_SUCCESS;
    PEPROCESS pProcess = IoGetRequestorProcess(irp);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);

    PFILE_OBJECT pFileObject = irpSp->FileObject;
    CQueueBase* pQueue = file_object_queue(pFileObject);

    ULONG IoControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
    ULONG ulFunctionCode = IoGetFunctionCodeFromCtlCode(IoControlCode);
    ULONG InputBufferLength  = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    ULONG OutputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    PVOID SystemBuffer = irp->AssociatedIrp.SystemBuffer;
    PVOID UserBuffer = irp->UserBuffer;
    PVOID Type3InputBuffer = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    //
    //  Used by storage mechanism
    //
    irp->IoStatus.Status = STATUS_PENDING;

    //
    //  Serialize access to the driver
    //
    CS lock(g_pLock);

    //
    // Check if it is the QM process for QM IOCTLs
    //
    if(
        //
        //  Check if it is the QM calling
        //
        ((ulFunctionCode > MQAC_IOCTL_CONNECT) && (g_pQM->Process() != pProcess)) ||

        //
        //  Check if QM exists for application API
        //
        ((ulFunctionCode < MQAC_IOCTL_CONNECT) && (g_pQM->Process() == 0)) ||

        //
        //  Check for connect request
        //
        ((ulFunctionCode == MQAC_IOCTL_CONNECT) && (g_pQM->Process() != 0)))
    {
        //
        //  This is not the QM service. If it is an application don't let
        //  it know about these IOCTL.
        //
        rc = STATUS_INVALID_DEVICE_REQUEST;
    }
    else switch(IoControlCode)
    {
        //-------------------------------------------------
        //
        //  RT Message APIs
        //
        //-------------------------------------------------

#ifdef _WIN64
        case IOCTL_AC_SEND_MESSAGE_32:
            //
            //  Check if incomming structure is the size of CACSendParameters_32
            //
            ASSERT(OutputBufferLength == sizeof(CACSendParameters_32));
            if (OutputBufferLength != sizeof(CACSendParameters_32))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACSendMessage_32(
                    irp,
                    InputBufferLength,
                    static_cast<CQueue*>(pQueue),
                    static_cast<CACSendParameters_32*>(UserBuffer)
                    );
            break;
#endif //_WIN64

        case IOCTL_AC_SEND_MESSAGE:
            //
            //  Check if incomming structure is the size of CACSendParameters
            //
            ASSERT(OutputBufferLength == sizeof(CACSendParameters));
            if (OutputBufferLength != sizeof(CACSendParameters))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACSendMessage(
                    irp,
                    InputBufferLength,
                    static_cast<CQueue*>(pQueue),
                    static_cast<CACSendParameters*>(UserBuffer)
                    );
            break;

#ifdef _WIN64
        case IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_32:
            //
            //  Check if incomming structure is the size of CACReceiveParameters_32
            //
            ASSERT(InputBufferLength == sizeof(CACReceiveParameters_32));
            if (InputBufferLength != sizeof(CACReceiveParameters_32))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACReceiveMessageByLookupId_32(
                    irp,
                    pFileObject,
                    static_cast<CUserQueue*>(pQueue),
                    static_cast<CACReceiveParameters_32*>(SystemBuffer)
                    );
            break;

        case IOCTL_AC_RECEIVE_MESSAGE_32:
            //
            //  Check if incomming structure is the size of CACReceiveParameters_32
            //
            ASSERT(InputBufferLength == sizeof(CACReceiveParameters_32));
            if (InputBufferLength != sizeof(CACReceiveParameters_32))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACReceiveMessage_32(
                    irp,
                    pFileObject,
                    static_cast<CUserQueue*>(pQueue),
                    static_cast<CACReceiveParameters_32*>(SystemBuffer)
                    );
            break;
#endif //_WIN64

        case IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID:
            //
            //  Check if incomming structure is the size of CACReceiveParameters
            //
            ASSERT(InputBufferLength == sizeof(CACReceiveParameters));
            if (InputBufferLength != sizeof(CACReceiveParameters))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACReceiveMessageByLookupId(
                    irp,
                    pFileObject,
                    static_cast<CUserQueue*>(pQueue),
                    static_cast<CACReceiveParameters*>(SystemBuffer)
                    );
            break;

        case IOCTL_AC_RECEIVE_MESSAGE:
            //
            //  Check if incomming structure is the size of CACReceiveParameters
            //
            ASSERT(InputBufferLength == sizeof(CACReceiveParameters));
            if (InputBufferLength != sizeof(CACReceiveParameters))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACReceiveMessage(
                    irp,
                    pFileObject,
                    static_cast<CUserQueue*>(pQueue),
                    static_cast<CACReceiveParameters*>(SystemBuffer)
                    );
            break;

#ifdef _WIN64
        case IOCTL_AC_CREATE_CURSOR_32:
#endif //_WIN64
        case IOCTL_AC_CREATE_CURSOR:
            //
            //  Check if incomming structure is the size of HACCursor32
            //
            ASSERT(OutputBufferLength == sizeof(HACCursor32));
            if (OutputBufferLength != sizeof(HACCursor32))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACCreateCursor(
                    irp,
                    pFileObject,
                    pDevice,
                    static_cast<CUserQueue*>(pQueue)
                    );
            break;

#ifdef _WIN64
        case IOCTL_AC_CLOSE_CURSOR_32:
#endif //_WIN64
        case IOCTL_AC_CLOSE_CURSOR:
            rc = ACCloseCursor(
                    pFileObject,
                    (HACCursor32)INT_PTR_TO_INT(UserBuffer) /*hCursor*/
                    );
            break;

#ifdef _WIN64
        case IOCTL_AC_HANDLE_TO_FORMAT_NAME_32:
#endif //_WIN64
        case IOCTL_AC_HANDLE_TO_FORMAT_NAME:
            rc = ACHandleToFormatName(
                    static_cast<CUserQueue*>(pQueue),
                    static_cast<PWSTR>(UserBuffer),
                    OutputBufferLength,
                    static_cast<PULONG>(Type3InputBuffer)
                    );
            break;

#ifdef _WIN64
        case IOCTL_AC_PURGE_QUEUE_32:
#endif  //_WIN64
        case IOCTL_AC_PURGE_QUEUE:
            rc = ACPurgeQueue(
                    pFileObject,
                    static_cast<CUserQueue*>(pQueue)
                    );
            break;

#ifdef _WIN64
        case IOCTL_AC_GET_QUEUE_HANDLE_PROPS_32:
#endif // _WIN64
        case IOCTL_AC_GET_QUEUE_HANDLE_PROPS:
            ASSERT(OutputBufferLength == sizeof(CACGetQueueHandleProperties));
            if (OutputBufferLength != sizeof(CACGetQueueHandleProperties))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACGetQueueHandleProperties(
                    pFileObject,
                    static_cast<CUserQueue*>(pQueue),
                    static_cast<CACGetQueueHandleProperties*>(UserBuffer)
                    );
            break;

        //-------------------------------------------------
        //
        //  QM Control APIs
        //
        //-------------------------------------------------

        case IOCTL_AC_CONNECT:
            ASSERT(OutputBufferLength == sizeof(CACConnectParameters));
            if (OutputBufferLength != sizeof(CACConnectParameters))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACConnect(
                    static_cast<const CACConnectParameters*>(UserBuffer),
                    irpSp->FileObject,
                    pProcess
                    );
            break;

        case IOCTL_AC_SET_MACHINE_PROPS:
            rc = ACSetMachineProperties(
                    OutputBufferLength
                    );
            break;

        case IOCTL_AC_CREATE_QUEUE:
            ASSERT(OutputBufferLength == sizeof(CACCreateQueueParameters));
            if (OutputBufferLength != sizeof(CACCreateQueueParameters))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACCreateQueue(
                    pFileObject,
                    static_cast<const CACCreateQueueParameters*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_CREATE_GROUP:
            rc = ACCreateGroup(
                    pFileObject,
                    InputBufferLength
                    );
            break;

        case IOCTL_AC_CREATE_DISTRIBUTION:
            ASSERT(OutputBufferLength == sizeof(CACCreateDistributionParameters));
            if (OutputBufferLength != sizeof(CACCreateDistributionParameters))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACCreateDistribution(
                     pFileObject,
                     static_cast<CACCreateDistributionParameters*>(UserBuffer)
                     );
            break;

        case IOCTL_AC_ASSOCIATE_QUEUE:
            rc = ACAssociateQueue(
                    static_cast<CUserQueue*>(pQueue),
                    UserBuffer,
                    InputBufferLength,
                    OutputBufferLength,
                    reinterpret_cast<bool>(Type3InputBuffer)
                    );
            break;

        case IOCTL_AC_ASSOCIATE_JOURNAL:
            ASSERT(NT_SUCCESS(CQueue::Validate(static_cast<CQueue*>(pQueue))));
            rc = ACAssociateQueue(
                    static_cast<CQueue*>(pQueue)->JournalQueue(),
                    UserBuffer,
                    InputBufferLength,
                    OutputBufferLength,
                    false
                    );
            break;

        case IOCTL_AC_ASSOCIATE_DEADXACT:
            ASSERT(NT_SUCCESS(CQueue::Validate(g_pMachineDeadxact)));
            if (!NT_SUCCESS(CQueue::Validate(g_pMachineDeadxact)))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACAssociateQueue(
                    g_pMachineDeadxact,
                    UserBuffer,
                    InputBufferLength,
                    OutputBufferLength,
                    false
                    );
            break;

        case IOCTL_AC_CAN_CLOSE_QUEUE:
            rc = ACCanCloseQueue(
                    pQueue
                    );
            break;

        case IOCTL_AC_SET_QUEUE_PROPS:
            ASSERT(OutputBufferLength == sizeof(CACSetQueueProperties));
            if (OutputBufferLength != sizeof(CACSetQueueProperties))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACSetQueueProperties(
                    static_cast<CUserQueue*>(pQueue),
                    static_cast<const CACSetQueueProperties*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_GET_QUEUE_PROPS:
            ASSERT(OutputBufferLength == sizeof(CACGetQueueProperties));
            if (OutputBufferLength != sizeof(CACGetQueueProperties))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACGetQueueProperties(
                    static_cast<CUserQueue*>(pQueue),
                    static_cast<CACGetQueueProperties*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_GET_SERVICE_REQUEST:
            rc = ACGetServiceRequest(irp);
            break;

        case IOCTL_AC_STORE_COMPLETED:
            rc = ACStorageCompleted(
                    irp
                    );
            break;

        case IOCTL_AC_CREATE_PACKET_COMPLETED:
            rc = ACCreatePacketCompleted(
                    irp
                    );
            break;

        case IOCTL_AC_ACKING_COMPLETED:
            rc = ACAckingCompleted(
                    static_cast<CPacket*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_PUT_RESTORED_PACKET:
            rc = ACPutRestoredPacket(
                    static_cast<CQueue*>(pQueue),
                    static_cast<CPacket*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_GET_RESTORED_PACKET:
            ASSERT(OutputBufferLength == sizeof(CACRestorePacketCookie));
            if (OutputBufferLength != sizeof(CACRestorePacketCookie))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACGetRestoredPacket(
                    static_cast<CACRestorePacketCookie*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_GET_PACKET_BY_COOKIE:
            ASSERT(OutputBufferLength == sizeof(CACPacketPtrs));
            if (OutputBufferLength != sizeof(CACPacketPtrs))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACGetPacketByCookie(
                    static_cast<CACPacketPtrs*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_RESTORE_PACKETS:
            rc = ACRestorePackets(
                    static_cast<PCWSTR>(Type3InputBuffer),
                    static_cast<PCWSTR>(UserBuffer),
                    OutputBufferLength,
                    static_cast<ACPoolType>(InputBufferLength)
                    );
            break;
		
        case IOCTL_AC_SET_MAPPED_LIMIT:
            rc = ACSetMappedLimit(
                    OutputBufferLength
                    );
            break;

        case IOCTL_AC_SET_PERFORMANCE_BUFF:
#ifdef _WIN64
        {
            CACSetPerformanceBuffer * pPerf =
               static_cast<CACSetPerformanceBuffer *>(UserBuffer);
            rc = ACpSetPerformanceBuffer(
                    pPerf->hPerformanceSection,
                    pPerf->pvPerformanceBuffer,
                    pPerf->pMachineQueueCounters,
                    pPerf->pQmCounters
                    );
        }
#else //!_WIN64
            rc = ACpSetPerformanceBuffer(
                    static_cast<HANDLE>(Type3InputBuffer),
                    UserBuffer,
                    reinterpret_cast<QueueCounters*>(OutputBufferLength),
                    reinterpret_cast<QmCounters*>(InputBufferLength)
                    );
#endif //_WIN64
            break;

        case IOCTL_AC_ARM_PACKET_TIMER:
            rc = ACArmPacketTimer(
                    static_cast<CPacket*>(UserBuffer),
                    static_cast<BOOL>(OutputBufferLength),
                    static_cast<ULONG>(InputBufferLength)
                    );
            break;

        case IOCTL_AC_RELEASE_RESOURCES:
            rc = ACReleaseResources();
            break;

		case IOCTL_AC_CONVERT_PACKET:
			rc = ACConvertPacket(
                     irp,
                     static_cast<CPacket*>(UserBuffer),
                     static_cast<BOOL>(InputBufferLength)
                     );
			break;
	
        case IOCTL_AC_SET_SEQUENCE_ACK:
            //
            //  Check if incomming structure is the size of CACSetSequenceAck
            //
            ASSERT(OutputBufferLength == sizeof(CACSetSequenceAck));
            if (OutputBufferLength != sizeof(CACSetSequenceAck))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACSetSequenceAck(
                    static_cast<CQueue*>(pQueue),
                    static_cast<CACSetSequenceAck*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_IS_SEQUENCE_ON_HOLD:
            rc = ACIsSequenceOnHold(
                    static_cast<CQueue*>(pQueue),
                    static_cast<CPacket*>(UserBuffer)
                    );
            break;

		case IOCTL_AC_INTERNAL_PURGE_QUEUE:
            rc = ACPurgeQueue(
                    static_cast<CUserQueue*>(pQueue),
                    InputBufferLength,
                    static_cast<USHORT>(OutputBufferLength)
                    );
            break;

        case IOCTAL_AC_GET_USED_QUOTA:
        	rc = ACGetUsedQuota(
        			static_cast<ULONGLONG*>(UserBuffer)
        			);
        	break;

        //-------------------------------------------------
        //
        // QM Network interface APIs
        //
        //-------------------------------------------------

        case IOCTL_AC_ALLOCATE_PACKET:
            rc = ACAllocatePacket(
                    (BOOL)INT_PTR_TO_INT(Type3InputBuffer),
                    static_cast<ACPoolType>(InputBufferLength),
                    OutputBufferLength,
                    static_cast<CACPacketPtrs*>(UserBuffer),
                    &irp->IoStatus
                    );
            break;

        case IOCTL_AC_FREE_PACKET:
            rc = ACFreePacket(
                    static_cast<CPacket*>(UserBuffer),
                    static_cast<USHORT>(OutputBufferLength)
                    );
            break;

        case IOCTL_AC_FREE_PACKET2:
            rc = ACFreePacket2(
                    static_cast<CPacket*>(UserBuffer),
                    static_cast<USHORT>(OutputBufferLength)
                    );
            break;

        case IOCTL_AC_FREE_PACKET1:
            rc = ACFreePacket1(
                    static_cast<CPacket*>(UserBuffer),
                    static_cast<USHORT>(OutputBufferLength)
                    );
            break;

        case IOCTL_AC_PUT_PACKET:
            rc = ACPutPacket(
                    irp,
                    static_cast<CQueue*>(pQueue),
                    static_cast<CPacket*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_PUT_PACKET1:
            rc = ACPutPacket1(
                    irp,
                    static_cast<CQueue*>(pQueue),
                    static_cast<CPacket*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_GET_PACKET:
            ASSERT(OutputBufferLength == sizeof(CACPacketPtrs));
            if (OutputBufferLength != sizeof(CACPacketPtrs))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACGetPacket(irp, pQueue);
            break;

        case IOCTL_AC_MOVE_QUEUE_TO_GROUP:
            rc = ACMoveQueueToGroup(
                    pQueue,
                    static_cast<HANDLE>(UserBuffer)
                    );
            break;

        //-------------------------------------------------
        //
        // QM remote read facilities
        //
        //-------------------------------------------------

        case IOCTL_AC_CREATE_REMOTE_PROXY:
            ASSERT(OutputBufferLength == sizeof(CACCreateRemoteProxyParameters));
            if (OutputBufferLength != sizeof(CACCreateRemoteProxyParameters))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACCreateRemoteProxy(
                    pFileObject,
                    static_cast<CACCreateRemoteProxyParameters*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_CREATE_REMOTE_CURSOR:
            ASSERT(InputBufferLength == sizeof(CACCreateRemoteCursorParameters));
            if (InputBufferLength != sizeof(CACCreateRemoteCursorParameters))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
			rc = ACCreateRemoteCursor(
                    pDevice,
                    static_cast<CProxy*>(pQueue),
                    static_cast<CACCreateRemoteCursorParameters*>(Type3InputBuffer)
                    );
            break;

        case IOCTL_AC_BEGIN_GET_PACKET_2REMOTE:
            ASSERT(OutputBufferLength == sizeof(CACPacketPtrs));
            if (OutputBufferLength != sizeof(CACPacketPtrs))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACBeginGetPacket2Remote(
                    irp,
                    pFileObject,
                    static_cast<CQueue*>(pQueue),
                    static_cast<CACGet2Remote*>(SystemBuffer)
                    );
            break;

        case IOCTL_AC_END_GET_PACKET_2REMOTE:
            ASSERT(OutputBufferLength == sizeof(CACGet2Remote));
            if (OutputBufferLength != sizeof(CACGet2Remote))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACEndGetPacket2Remote(
                    pFileObject,
                    static_cast<CACGet2Remote*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_PUT_REMOTE_PACKET:
            rc = ACPutRemotePacket(
                    static_cast<CProxy*>(pQueue),
                    OutputBufferLength,
                    static_cast<CPacket*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_CANCEL_REQUEST:
            rc = ACCancelRequest(
                    pQueue,
                    InputBufferLength,
                    OutputBufferLength
                    );
            break;

        //-------------------------------------------------
        //
        // QM transaction facilities
        //
        //-------------------------------------------------

        case IOCTL_AC_CREATE_TRANSACTION:
            ASSERT(OutputBufferLength == sizeof(XACTUOW));
            if (OutputBufferLength != sizeof(XACTUOW))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACCreateTransaction(
                    pFileObject,
                    static_cast<const XACTUOW*>(UserBuffer)
                    );
            break;

        case IOCTL_AC_XACT_COMMIT1:
            rc = ACXactCommit1(
                    irp,
                    static_cast<CTransaction*>(pQueue)
                    );
            break;

        case IOCTL_AC_XACT_COMMIT2:
            rc = ACXactCommit2(
					irp,
                    static_cast<CTransaction*>(pQueue)
                    );
            break;

		case IOCTL_AC_XACT_COMMIT3:
			rc = ACXactCommit3(
					static_cast<CTransaction*>(pQueue)
					);
			break;
		

        case IOCTL_AC_XACT_ABORT1:
            rc = ACXactAbort1(
					irp,
                    static_cast<CTransaction*>(pQueue)
                    );
            break;

		case IOCTL_AC_XACT_ABORT2:
			rc = ACXactAbort2(
					static_cast<CTransaction*>(pQueue)
					);
			break;


        case IOCTL_AC_XACT_PREPARE:
            rc = ACXactPrepare(
                    irp,
                    static_cast<CTransaction*>(pQueue)
                    );
            break;

        case IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT:
            rc = ACXactPrepareDefaultCommit(
                    irp,
                    static_cast<CTransaction*>(pQueue)
                    );
            break;

        case IOCTL_AC_XACT_GET_INFORMATION:
            ASSERT(OutputBufferLength == sizeof(CACXactInformation));
            if (OutputBufferLength != sizeof(CACXactInformation))
            {
                rc = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            rc = ACXactGetInformation(
                    static_cast<CTransaction*>(pQueue),
                    static_cast<CACXactInformation *>(UserBuffer)
                    );
            break;

        default:
            //
            // Illegal AC IOCTL
            //
            TrTRACE(AC, "Illigal IOCTL (IoControlCode=0x%x)", IoGetFunctionCodeFromCtlCode(IoControlCode));
            //ASSERT(irp == 0);
            rc = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    if(rc == STATUS_PENDING)
    {
        TrTRACE(AC, ", irp=0x%p, pending", irp);
        //
        //  Need to mark pending at point of issue
        //
        //  IoMarkIrpPending(irp);
    }
    else
    {
        TrTRACE(AC, ", irp=0x%p, rc=0x%x\n", irp, rc);
        irp->IoStatus.Status = rc;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return rc;

} // ACDeviceControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\crc32.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.h

Abstract:

    CRC-32 alogorithm

Author:

    MikeSw

Revision History:
	07-DEC-98		adopted from original code by Mike Swift

--*/

//
// This code comes from Dr. Dobbs Journal, May 1992
//

#define CRC32_SEED	0xffffffff

const unsigned long CRCTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


inline ULONG Crc32Sum(ULONG ulCrc, ULONG_PTR cbBuffer, const UCHAR* pbBuffer )
{
#ifndef _WIN64 //may be redundant, but just to make sure ULONG_PTR is ULONG in the asm code below
#ifdef _X86_
_asm
{
  mov     ecx, DWORD PTR cbBuffer
  shr     ecx, 2
  mov     eax, ecx
  dec     ecx
  mov     esi, DWORD PTR pbBuffer

  mov     edx, DWORD PTR ulCrc
  test    eax, eax
  je      SHORT $LABEL2
  inc     ecx
$LABEL1:
  mov     ebx, DWORD PTR [esi]
  add     esi, 4

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
;  shr     ebx, 8  -- Not needed on last byte
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  dec     ecx
  jne     SHORT $LABEL1
$LABEL2:
  mov     DWORD PTR ulCrc, edx
  mov     DWORD PTR pbBuffer, esi
}

    cbBuffer &= 0x3;
#endif //_X86_
#endif //!_WIN64

    while (cbBuffer-- != 0)
    {
        ulCrc = (ulCrc >> 8) ^ CRCTable[(unsigned char) ulCrc ^ *pbBuffer++];
    }
    
	return(ulCrc);
}

inline ULONG Crc32Sum(ULONG ulCrc, const UCHAR* pStart, const UCHAR* pEnd)
{
    ASSERT(pEnd >= pStart);

	return Crc32Sum(ulCrc, pEnd - pStart, pStart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\create.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    create.cxx

Abstract:

    This module contains the code to for Falcon Create routine.

Author:

    Erez Haba (erezh) 13-Aug-95

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "data.h"
#include "lock.h"

#ifndef MQDUMP
#include "create.tmh"
#endif

NTSTATUS
ACCreate(
    IN PDEVICE_OBJECT /*pDevice*/,
    IN PIRP irp
    )
/*++

Routine Description:

    Create/Open a new Queue by application request

Arguments:

    pDevice
        Pointer to the device object for this device

    irp
        Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/
{
    //
    //  Count the handles granted
    //
    InterlockedIncrement(&g_DriverHandleCount);

    irp->IoStatus.Information = 0;
    irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\cursor.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    cursor.cxx

Abstract:
    Implement cursor member functions

Author:
    Erez Haba (erezh) 29-Feb-96

Environment:
    Kernel mode

Revision History:

--*/

 

#include "internal.h"
#include "queue.h"
#include "qproxy.h"
#include "cursor.h"
#include "qm.h"
#include "data.h"

#ifndef MQDUMP
#include "cursor.tmh"
#endif

//---------------------------------------------------------
//
//  class CCursor
//
//---------------------------------------------------------

inline 
CCursor::CCursor(
    const CPacketPool& pl, 
    const FILE_OBJECT* pOwner, 
    CUserQueue* pQueue, 
    PIO_WORKITEM pWorkItem
    ) :
    m_pl(&pl),
    m_current(pl.end()),
    m_owner(pOwner),
    m_hRemoteCursor(0),
    m_fValidPosition(FALSE),
    m_handle(0),
    m_pQueue(pQueue),
    m_pWorkItem(pWorkItem),
    m_fWorkItemBusy(FALSE)
{
    ASSERT(("Must point to queue", m_pQueue != NULL));
    ASSERT(("Must point to work item", m_pWorkItem != NULL));

    //
    // Increment ref count as the cursor is "referencing" the queue.
    // Ref count will be decremented in CCursor::~CCursor.
    //
    m_pQueue->AddRef();

}


inline CCursor::~CCursor()
{
	ASSERT (m_handle==0);
    //
    //  The cursor is ALWAYS in some list untill destructrion
    //
    ACpRemoveEntryList(&m_link);

    CPacket* pPacket = m_current;
    
    ACpRelease(pPacket);

    IoFreeWorkItem(m_pWorkItem);

    //
    // Decrement ref count as the cursor is no loner "referencing" the queue.
    // Ref count was incremented in CCursor::CCursor.
    //
    m_pQueue->Release();
}


HACCursor32
CCursor::Create(
    const CPacketPool& pl, 
    const FILE_OBJECT* pOwner, 
    PDEVICE_OBJECT pDevice,
    CUserQueue* pQueue
    )
{
    PIO_WORKITEM pWorkItem = IoAllocateWorkItem(pDevice);
    if (pWorkItem == NULL)
    {
        return 0;
    }

    CCursor* pCursor = new (PagedPool, NormalPoolPriority) CCursor(pl, pOwner, pQueue, pWorkItem);
    if(pCursor == 0)
    {
       	TrERROR(AC, "Failed to allocate a cursor from paged pool. pQueue = 0x%p", pQueue); 
        IoFreeWorkItem(pWorkItem);
        return 0;
    }

    HACCursor32 hCursor = g_pCursorTable->CreateHandle(pCursor);
    if(hCursor == 0)
    {
        InitializeListHead(&pCursor->m_link);
        pCursor->Release();
        return 0;
    }

    pCursor->m_handle = hCursor;
    return hCursor;
}


void CCursor::SetTo(CPacket* pPacket)
{
    ASSERT(pPacket != 0);

    pPacket->AddRef();
    CPacket* pPacket1 = m_current;
    ACpRelease(pPacket1);
    m_current = pPacket;
    m_fValidPosition = TRUE;
}

void CCursor::Advance()
{
    //
    //  find the next matching packet.
    //
    CPacketPool::Iterator current = m_current;
    if(m_current == m_pl->end())
    {
        //
        //The Cursor was just created
        //move the  iterator to the begining of the list
        //

        current = m_pl->begin(); 
    }
    else
    {
        ++current;
    }

    m_fValidPosition = FALSE;
    for(; current != m_pl->end(); ++current)
    {
        CPacket *pEndPacket = current;
        if (IsMatching(pEndPacket))
        {
            SetTo(pEndPacket);
            return;        
        }
    }
}

NTSTATUS CCursor::Move(ULONG ulDirection)
{
    switch(ulDirection)
    {
        case MQ_ACTION_RECEIVE:
        case MQ_ACTION_PEEK_CURRENT:
            if(Current() == 0)
            {
                //
                //  Try to move to the first packet in the list
               
                Advance();
            }
            break;

        case MQ_ACTION_PEEK_NEXT:
            if(Current() == 0)
            {
                //
                //  peek after end of list
                //
                return MQ_ERROR_ILLEGAL_CURSOR_ACTION;
            }
            Advance();
            break;

        default:
            return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

BOOL CCursor::IsMatching(CPacket* pPacket)
{
    ASSERT(pPacket);

    if(pPacket->IsReceived())
    {
        return FALSE;
    }

    return TRUE;
}

NTSTATUS CCursor::CloseRemote() const
{
    ULONG hCursor = RemoteCursor();
    if(hCursor == 0)
    {
        return STATUS_SUCCESS;
    }

    CProxy* pProxy = static_cast<CProxy*>(file_object_queue(m_owner));
    ASSERT(NT_SUCCESS(CProxy::Validate(pProxy)));

    return pProxy->IssueRemoteCloseCursor(hCursor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\cursor.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    cursor.h

Abstract:
    Cursor definition.

Author:
    Erez Haba (erezh) 25-Feb-96

Revision History:

--*/

#ifndef __CURSOR_H
#define __CURSOR_H

#include "packet.h"
#include "actempl.h"
#include "htable.h"

#include "avltree.h"

typedef CAVLTree1<CPacket, ULONGLONG, CPacket::CGetLookupId> CPacketPool;

class CUserQueue;

//---------------------------------------------------------
//
//  class CCursor
//
//---------------------------------------------------------

class CCursor : public CObject {
public:
    NTSTATUS Move(ULONG ulDirection);
    void SetTo(CPacket* pPacket);
    void InvalidatePosition();
    BOOL IsMatching(CPacket* pPacket);
    BOOL IsOwner(const FILE_OBJECT* pOwner);

    CPacket* Current();
    void Close();
    NTSTATUS CloseRemote() const;

    ULONG RemoteCursor() const;
    void RemoteCursor(ULONG hRemoteCursor);

    void SetWorkItemDone();
    PIO_WORKITEM WorkItem() const;

public:
    static 
    HACCursor32
    Create(
        const CPacketPool& pl, 
        const FILE_OBJECT* pOwner, 
        PDEVICE_OBJECT pDevice,
        CUserQueue* pQueue
        );

    static 
    CCursor* 
    Validate(
        HACCursor32 hCursor
        );

private:
   ~CCursor();
    CCursor(const CPacketPool& pl, const FILE_OBJECT* pOwner, CUserQueue* pQueue, PIO_WORKITEM pWorkItem);

    BOOL ValidPosition() const;
    void Advance();

private:

    //
    // the current message (by iterator)
    //
    CPacketPool::Iterator m_current;   
    const CPacketPool* m_pl;

    //
    //  Owner context information
    //
    const FILE_OBJECT* m_owner;

    //
    // On client QM, this is the handle of remote cursor (in case of
    // remote reading).
    //
    ULONG m_hRemoteCursor;

    //
    //  The cursor is positioned on a valid packet
    //
    BOOL m_fValidPosition;

    //
    //  cursor handle in cursor handles table
    //
    HACCursor32 m_handle;

    //
    // The owner queue
    //
    CUserQueue* m_pQueue;

    //
    // An allocated work item used for cleanup
    //
    PIO_WORKITEM m_pWorkItem;

    //
    // A flag to indicate if work item is queued
    //
    mutable LONG m_fWorkItemBusy;
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

inline CCursor* CCursor::Validate(HACCursor32 hCursor)
{
    return static_cast<CCursor*>(g_pCursorTable->ReferenceObject(hCursor));
}


inline void CCursor::InvalidatePosition()
{
    m_fValidPosition = FALSE;
}


inline BOOL CCursor::ValidPosition() const
{
    return m_fValidPosition;
}


inline CPacket* CCursor::Current(void)
{
    return (ValidPosition() ? (CPacket*)m_current : (CPacket*)0);
}


inline BOOL CCursor::IsOwner(const FILE_OBJECT* pOwner)
{
    return (m_owner == pOwner);
}


inline ULONG CCursor::RemoteCursor() const
{
    return m_hRemoteCursor;
}

inline void CCursor::RemoteCursor(ULONG hRemoteCursor)
{
    m_hRemoteCursor = hRemoteCursor;
}

inline void CCursor::Close()
{
    //
    //  Revoke the validity of this cursor
    //
    if(m_handle != 0)
    {
        PVOID p = g_pCursorTable->CloseHandle(m_handle);
        DBG_USED(p);
        ASSERT(p == this);
        m_handle = 0;
        Release();
    }
}

inline void CCursor::SetWorkItemDone()
{
    //
    // Mark the work item as not busy, so it can be requeued
    //
    m_fWorkItemBusy = FALSE;
}

inline PIO_WORKITEM CCursor::WorkItem() const
{
    //
    // Wait until the work item is done (not busy), then mark it as busy
    // and return it.
    //
    while (InterlockedExchange(&m_fWorkItemBusy, TRUE))
    {
        // 
        //  Time is in 100 nsec, and is negative to be treated as
        //  relative time by KeDelayExecutionThread
        //
        LARGE_INTEGER Time;
        Time.QuadPart = -10 * 1000;
        KeDelayExecutionThread(
		        KernelMode,
		        FALSE,
		        &Time
		        );
    }

    return m_pWorkItem;
}

#endif // __CURSOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\data.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    data.cxx

Abstract:

    This module contains global data.

Author:

    Erez Haba (erezh) 14-Dec-95

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "data.h"
#include "version.h"

#ifndef MQDUMP
#include "data.tmh"
#endif

ULONGLONG g_MessageSequentialID;
LONGLONG g_liSeqIDAtRestore;
CQMInterface* g_pQM;
CSMAllocator* g_pAllocator;
CLock* g_pLock;
CScheduler* g_pPacketScheduler;
CScheduler* g_pReceiveScheduler;
CQueue* g_pMachineJournal;
CQueue* g_pMachineDeadletter;
CQueue* g_pMachineDeadxact;
CStorage* g_pStorage;
CStorageComplete* g_pStorageComplete;
CCreatePacket * g_pCreatePacket;
CCreatePacketComplete * g_pCreatePacketComplete;
PWSTR g_pLogPath;
List<CPacket>* g_pRestoredPackets;
List<CTransaction>* g_pTransactions;
ULONG_PTR g_ulACQM_PerfBuffOffset = NO_BUFFER_OFFSET;
_QmCounters* g_pQmCounters;
CHTable* g_pCursorTable;
LONG g_DriverHandleCount;
ULONG g_HeapFileNameCount;
ULONG g_ulHeapPoolSize;
BOOL g_fXactCompatibilityMode;
BOOL g_fWow64;
FAST_IO_DISPATCH g_ACpFastIoDispatch;
DWORD g_dwMsmqBuildNo = rup;  // Holds MSMQ version for debugging purposes
USHORT g_IrpTag;
BOOL g_fCheckForQMProcessOverride = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\devext.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    devext.h

Abstract:

    CDeviceExt definition

Author:

    Erez Haba (erezh) 13-Aug-95

Revision History:
--*/

#ifndef _DEVEXT_H
#define _DEVEXT_H

#include "qm.h"
#include "lock.h"
#include "timer.h"
#include "store.h"
#include "LocalSend.h"
#include "packet.h"
#include "queue.h"
#include "qxact.h"
#include "htable.h"

//---------------------------------------------------------
//
//  class CDeviceExt
//
//---------------------------------------------------------

class CDeviceExt {

    //
    //  One CDeviceExt object resides in NON pageable memory in
    //  the device extionsion memory.
    //

public:

    CDeviceExt();

public:

    //
    //  The QM object
    //
    CQMInterface m_qm;

    //
    //  BUGBUG: The driver global lock
    //
    CLock m_lock;

    //
    //  packet writers list
    //
    CStorage m_storage;

    //
    //  packet storage complete notificaion handler
    //
    CStorageComplete m_storage_complete;

    //
    // Async Create Packet manager
    //
    CCreatePacket m_CreatePacket;

    //
    // Async Create Packet completion manager
    //
    CCreatePacketComplete m_CreatePacketComplete;

    //
    //  Packet scheduler data
    //
    FAST_MUTEX m_PacketMutex;
    CTimer m_PacketTimer;

    //
    //  Receive scheduler data
    //
    FAST_MUTEX m_ReceiveMutex;
    CTimer m_ReceiveTimer;

    //
    //  Recovered packets list
    //
    List<CPacket> m_RestoredPackets;

    //
    //  Cursor handle table
    //
    CHTable m_CursorTable;

    //
    //  List of transactional queues
    //
    List<CTransaction> m_Transactions;
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

inline CDeviceExt::CDeviceExt()
{
    ExInitializeFastMutex(&m_PacketMutex);
    ExInitializeFastMutex(&m_ReceiveMutex);
}

#endif // _DEVEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\data.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    data.h

Abstract:

    Global Data of Falcon Driver

Author:

    Erez Haba (erezh) 1-Aug-95

Revision History:
--*/
#ifndef _DATA_H
#define _DATA_H

//
//  Falcon MessageID counter
//
extern ULONGLONG g_MessageSequentialID;

//
// Last SeqID value at the last restore time
//
extern LONGLONG g_liSeqIDAtRestore;   

//
//  The QM interface object (resides in the device extention)
//
extern class CQMInterface* g_pQM;

//
//  The shared memory heap manager, resides in pagable memory
//
extern class CSMAllocator* g_pAllocator;

//
//  BUGBUG: Temporary
//  AC Driver serializing lock
//
extern class CLock* g_pLock;

//
//  Global variables for the scheduler.
//
extern class CScheduler* g_pPacketScheduler;
extern class CScheduler* g_pReceiveScheduler;

//
//  The machine journal queue, aka 'Outgoing Journal'
//
extern class CQueue* g_pMachineJournal;

//
//  The machine deadletter queue
//
extern class CQueue* g_pMachineDeadletter;

//
//  The machine deadxact queue
//
extern class CQueue* g_pMachineDeadxact;

//
//  Storage manager
//
extern class CStorage* g_pStorage;

//
//  Storage complete manager
//
extern class CStorageComplete* g_pStorageComplete;

//
//  Async Create Packet manager
//
extern class CCreatePacket * g_pCreatePacket;

//
// Async Create Packer Completion manager
//
extern class CCreatePacketComplete * g_pCreatePacketComplete;

//
//  The heap logger path
//
extern PWSTR g_pLogPath;

//
// The offest in bytes between the performance buffer in the address space
// of the device driver and the address space of the QM. When given an address
// of a performance counter in the address space of the QM, add
// g_ulACQM_PerfBuffOffset to this address to get the address of the
// performance counter in the address space of the device driver.
//
extern ULONG_PTR g_ulACQM_PerfBuffOffset;

//
// The NO_BUFFER_OFFSET is associated with the g_ulACQM_PerfBuffOffset. When
// this global variable equals NO_BUFFER_OFFSET, it means that the performance
// buffer is not valid.
//
#define NO_BUFFER_OFFSET    ((ULONG_PTR)0)

//
// A pointer to the QM performance counters.
//
extern struct _QmCounters* g_pQmCounters;

//
//  The recoverd packets list
//
class CPacket;
template<class T> class List;
extern List<CPacket>* g_pRestoredPackets;

//
// List of Transaction Queues
//
class CTransaction;
extern List<CTransaction>* g_pTransactions;

//
//  Cursors handle table
//
extern class CHTable* g_pCursorTable;

//
//  The driver refrence count on opend handles
//
extern LONG g_DriverHandleCount;

//
//  The count to generate file names
//
extern ULONG g_HeapFileNameCount;

//
//  The size of a heap pool, also maximum message size
//
extern ULONG g_ulHeapPoolSize;

//
// Flag of the Xact Compatibility mode
//
extern BOOL g_fXactCompatibilityMode;

//
// Flag of running 32bit process on 64bit system to override probing
//
extern BOOL g_fWow64;

//
//  The Fast IO dispatch table, for APIs that are not blocked
//
//extern FAST_IO_DISPATCH g_ACpFastIoDispatch;

//
//  IRP tags counter
//
extern USHORT g_IrpTag;

//
//  Flag of overriding the CheckForQMProcess function
//
extern BOOL g_fCheckForQMProcessOverride;

#endif // _DATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\dl.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dl.cxx

Abstract:

    Implementation of distribution list class.
    Distribution list represents an outgoing message sent to multiple 
    destinations queues.

Author:

    Shai Kariv  (shaik)  30-Apr-2000

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include <fntoken.h>
#include "dl.h"
#include "qxact.h"
#include "irp2pkt.h"
#include "localsend.h"

#ifndef MQDUMP
#include "dl.tmh"
#endif

//---------------------------------------------------------
//
//  class CDistribution
//
//---------------------------------------------------------

DEFINE_G_TYPE(CDistribution);


static
NTSTATUS 
ACpHandle2Queue(
    HANDLE     hQueue, 
    CQueue * * ppQueue
    )
/*++

Routine Description:

    Translate a queue handle to a queue object.
    Increment reference count on the queue object.

Arguments:

    hQueue     - Queue handle.

    ppQueue    - Pointer to pointer to queue object.

Return Value:

    STATUS_SUCCESS - The operation completed successfully.
    other status   - The operation failed.

--*/
{
    //
    // Get the file object
    //
    PFILE_OBJECT pFileObject;
    NTSTATUS     rc;
    rc = ObReferenceObjectByHandle(
            hQueue,
            GENERIC_ALL,
            0,
            KernelMode,
            reinterpret_cast<PVOID*>(&pFileObject),
            0
            );

    if(!NT_SUCCESS(rc))
    {
        TrERROR(AC, " Queue handle to queue object failed (handle=0x%p)", hQueue);
        return rc;
    }

    //
    // Get the queue object
    //
    *ppQueue = static_cast<CQueue*>(file_object_queue(pFileObject));

    //
    // Validate the queue object
    //
    ASSERT(NT_SUCCESS(CQueue::Validate(*ppQueue)));

    //
    // Incremenet reference count on the queue object
    //
    (*ppQueue)->AddRef();

    //
    // Dereference the handle
    //
    ObDereferenceObject(pFileObject);

    return STATUS_SUCCESS;

} // ACpHandle2Queue


NTSTATUS
CDistribution::SetTopLevelQueueFormats(
    ULONG              nTopLevelQueueFormats, 
    const QUEUE_FORMAT TopLevelQueueFormats[]
    )
/*++

Routine Description:

    Set the top level queue format names for the queue member of this
    distribution.
    This is part of the distribution object construction and should be called
    exactly once.

Arguments:

    nTopLevelQueueFormats - Number of top level queue format names.

    TopLevelQueueFormats  - Array of top level queue format names.

Return Value:

    STATUS_SUCCESS - The operation completed successfully.
    STATUS_INSUFFICIENT_RESOURCES - The operation failed, no memory.

--*/
{
    ASSERT(("Must have at least one top level queue format", nTopLevelQueueFormats != 0));
    ASSERT(("Must set top level queue formats once only",  m_nTopLevelQueueFormats == 0));

    //
    // Allocate space for the queue formats
    //
    m_TopLevelQueueFormats = new (PagedPool) QUEUE_FORMAT[nTopLevelQueueFormats];
    if (m_TopLevelQueueFormats == NULL)
    {
    	TrERROR(AC, "Failed to allocate %d QUEUE_FORMATs from paged pool.", nTopLevelQueueFormats); 
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the queue formats and update member counter one by one.
    // This is necessary for correct destruction if no memory.
    //
    for (ULONG ix = 0; ix < nTopLevelQueueFormats; ++ix)
    {
        if (!ACpDupQueueFormat(TopLevelQueueFormats[ix], m_TopLevelQueueFormats[ix]))
        {
           	TrERROR(AC, "Failed to duplicate qf because of insufficient resources."); 
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        ++m_nTopLevelQueueFormats;
    }
    ASSERT(m_nTopLevelQueueFormats == nTopLevelQueueFormats);

    return STATUS_SUCCESS;

} // CDistribution::SetTopLevelQueueFormats


NTSTATUS 
CDistribution::AddMember(
    HANDLE hQueue,
    bool   fProtocolSrmp
    )
/*++

Routine Description:

    Add an outgoing queue to the distribution object.

Arguments:

    hQueue        - Handle to an outgoing queue.

    fProtocolSrmp - Indicates whether the queue is http (direct=http or multicast).

Return Value:

    STATUS_SUCCESS - The operation completed successfully.
    STATUS_INSUFFICIENT_RESOURCES - The operation failed, no memory.
    other status   - The operation failed.

--*/
{
    //
    // Get queue object from queue handle and increment reference count on the queue object.
    //
    CQueue * pQueue;
    NTSTATUS rc = ACpHandle2Queue(hQueue, &pQueue);
    if (!NT_SUCCESS(rc))
    {
        return rc;
    }

    //
    // Allocate linked list entry from queue object
    //
    CEntry * pEntry = new (PagedPool) CEntry(pQueue, fProtocolSrmp);
    if (pEntry == NULL)
    {
        pQueue->Release();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Add the linked list entry to the linked list
    //
    m_members.insert(pEntry);

    TrTRACE(AC, " Add queue to distribution succeeded (pQueue=%p)", pQueue);
    return STATUS_SUCCESS;

} // CDistribution::AddMember


CDistribution::~CDistribution()
/*++

Routine Description:

    Destructor. Release all pointed objects and resources.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CEntry * pEntry;
    while((pEntry = m_members.gethead()) != 0)
    {
        //
        // Decrement reference count on the queue object
        //
        pEntry->m_pQueue->Release();

        //
        // Deallocate the list entry
        //
        delete pEntry;
    }

    for (ULONG ix = 0; ix < m_nTopLevelQueueFormats; ++ix)
    {
        m_TopLevelQueueFormats[ix].DisposeString();
    }
} // CDistribution::~CDistribution


static
VOID
ACpCleanupAttachedPackets(
    PIRP irp
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    //
    // Detach packets from irp. De-ref packets creation and packets attach to irp.
    //

    CPacket * pPacket;

    #ifdef _DEBUG
        pPacket = CIrp2Pkt::SafePeekFirstPacket(irp);
        ASSERT(pPacket != NULL);
        CQueue * pDistribution = pPacket->Queue();
        CTransaction * pXact = pPacket->Transaction();
    #endif

    while ((pPacket = CIrp2Pkt::GetAttachedPacketsHead(irp)) != NULL)
    {
        ASSERT(pPacket->Queue() == pDistribution);
        pPacket->Queue(NULL);
        ASSERT(pPacket->Transaction() == pXact);
        pPacket->Transaction(NULL);

        pPacket->Release();
        pPacket->Release();
    }
} // ACpCleanupAttachedPackets


inline
static
VOID
ACpSetIdenticalMsgId(
    CPacketBuffer * ppb,
    bool *          pfMessageIdIsInitialized,
    OBJECTID *      pMessageId
    )
{
    CUserHeader * pUserHeader = CPacketBuffer::UserHeader(ppb);
    if (*pfMessageIdIsInitialized)
    {
        pUserHeader->SetMessageID(pMessageId);
        return;
    }

    pUserHeader->GetMessageID(pMessageId);
    *pfMessageIdIsInitialized = true;

} // ACpSetIdenticalMsgId 


inline
static
NTSTATUS
ACpSetMsgIdProperty(
    CACSendParameters * pSendParams,
    const OBJECTID      MessageId
    )
{
    //
    // Set the message ID property. User buffer was already probed.
    //
    if (pSendParams->MsgProps.ppMessageID != NULL)
    {
        __try
        {
            OBJECTID* pMessageID = *pSendParams->MsgProps.ppMessageID;
            ACProbeForWrite(pMessageID, sizeof(OBJECTID));
            (**pSendParams->MsgProps.ppMessageID) = MessageId;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return GetExceptionCode();
        }
    }

    return STATUS_SUCCESS;

} // ACpSetMsgIdProperty


NTSTATUS 
CDistribution::CreatePacket(
    PIRP                      irp, 
    CTransaction *            pXact, 
    BOOL                      fCheckMachineQuota, 
    const CACSendParameters * pSendParams
    )
/*++

Routine Description:

    Create new packets, possibly asynchronously.

    Algorithm:

    * Mark irp as multiple packet handler.
    * Synchronously create the packets:
      * By calling CPacket::SyncCreate
      * This will point the packet to this queue and transaction
      * This will attach the packet to the irp
      * Force same message ID on all packets
    * If async creation needed, issue request to QM.
      * By calling CPacket::AsyncCreate
    * Failure handling: every routine cleans up after itself in case of failure.
    * Note: m_members.m_pPacket used as scratch pad in this routine.

Arguments:

    irp                - The interrupt request packet of the send request.
    
    pXact              - Pointer to transaction object, may be NULL.

    fCheckMachineQuota - Indicates whether to check machine quota or not.

    pSendParams        - Pointer to send parameters.

Return Value:

    STATUS_SUCCESS - All Packets completed successfully and synchronously.

    STATUS_PENDING - At least one packet creation is pending QM processing.

    failure status - At least one packet creation failed. The packets that
        were created attached to irp and completion handler will clean them.

--*/
{
    //
    // Mark irp as mutiple packet handler
    //
    irp_driver_context(irp)->MultiPackets(true);

    //
    // Empty distribution. De-ref queue/xact (undo PutNewPacket) and return success.
    //
    if (m_members.isempty())
    {
        Release();
        ACpRelease(pXact);
        return STATUS_SUCCESS;

    }

    //
    // Synchronously create the packets. On failure, de-ref packets creation and packets attach to irp.
    //
    bool fMessageIdIsInitialized = false;
    OBJECTID MessageId;
    memset(&MessageId, 0, sizeof(MessageId));
    bool fNeedAsync = false;
    NTSTATUS rc;
    for(List<CEntry>::Iterator pEntry(m_members); pEntry != NULL; ++pEntry)
    {
        rc = CPacket::SyncCreate(
                 irp, 
                 pXact, 
                 pEntry->m_pQueue,        // Destination queue
                 m_nTopLevelQueueFormats, // nDestinationMqf 
                 m_TopLevelQueueFormats,  // DestinationMqf
                 fCheckMachineQuota,     
                 pSendParams, 
                 this,                    // Async completion handler
                 pEntry->m_fProtocolSrmp,
                 &pEntry->m_pPacket
                 );

        if (!NT_SUCCESS(rc))
        {
            ASSERT(pEntry->m_pPacket == NULL);
            if (CIrp2Pkt::SafePeekFirstPacket(irp) != NULL)
            {
                ACpCleanupAttachedPackets(irp);
            }
            return rc;
        }

        //
        // Success. Packet points to this distribution and transaction. Packet attached to irp.
        //
        ASSERT(pEntry->m_pPacket != NULL);
        ASSERT(pEntry->m_pPacket->Queue() == this);
        ASSERT(pEntry->m_pPacket->Transaction() == pXact);
        ASSERT(CIrp2Pkt::SafePeekFirstPacket(irp) != NULL);
        CPacketBuffer * ppb = pEntry->m_pPacket->Buffer();
        ASSERT(ppb != NULL);
        ACpSetIdenticalMsgId(ppb, &fMessageIdIsInitialized, &MessageId);
        if (pEntry->m_pQueue->NeedAsyncCreatePacket(ppb, pEntry->m_fProtocolSrmp))
        {
            fNeedAsync = true;
        }
    }

    rc = ACpSetMsgIdProperty(const_cast<CACSendParameters*>(pSendParams), MessageId);
    if (!NT_SUCCESS(rc))
    {
        ACpCleanupAttachedPackets(irp);
        return rc;
    }

    //
    // Do async creation, if needed. On failure, de-ref packets creation and packets attach to irp.
    //
    if (!fNeedAsync)
    {
        return STATUS_SUCCESS;
    }

    for(List<CEntry>::Iterator pEntry(m_members); pEntry != NULL; ++pEntry)
    {
        CPacketBuffer * ppb = pEntry->m_pPacket->Buffer();
        if (ppb == NULL)
        {
            ACpCleanupAttachedPackets(irp);
            return rc;
        }

        if (pEntry->m_pQueue->NeedAsyncCreatePacket(ppb, pEntry->m_fProtocolSrmp))
        {
            rc = pEntry->m_pPacket->IssueCreatePacketRequest(pEntry->m_fProtocolSrmp);
            if (!NT_SUCCESS(rc))
            {
                ACpCleanupAttachedPackets(irp);
                return rc;
            }
            CIrp2Pkt::IncreasePacketsPendingCreateCounter(irp);
        }
    }

    return STATUS_PENDING;

} // CDistribution::CreatePacket


VOID
CDistribution::HandleCreatePacketCompletedFailureAsync(
    PIRP irp
    )
{
    //
    // Extract queue/xact context from packet, and auto-decrement their ref count (undo PutNewPacket).
    //
    ASSERT(!CIrp2Pkt::IsHeld(irp));
    CPacket * pPacket = CIrp2Pkt::SafePeekFirstPacket(irp);
    ASSERT(pPacket != NULL);
    ASSERT(pPacket->Queue() == this);
    R<CDistribution> pDistribution = this;
    R<CTransaction> pXact = pPacket->Transaction();

    //
    // Detach packets from irp, de-ref packet creation and packet attach.
    //
    ACpCleanupAttachedPackets(irp);

} // CDistribution::HandleCreatePacketCompletedFailureAsync


NTSTATUS
CDistribution::HandleCreatePacketCompletedSuccessSync(
    PIRP irp
    )
{
    if (m_members.isempty())
    {
        ASSERT(("Empty distribution: there is no packet!", CIrp2Pkt::NumOfAttachedPackets(irp) == 0));
        ASSERT(!CIrp2Pkt::IsHeld(irp));
        return STATUS_SUCCESS;
    }

    return HandleCreatePacketCompletedSuccessAsync(irp);

} // CDistribution::HandleCreatePacketCompletedSuccessSync


NTSTATUS
CDistribution::HandleCreatePacketCompletedSuccessAsync(
    PIRP irp
    )
{
    //
    // Extract queue/xact context from packet, and auto-decrement their ref count (undo PutNewPacket).
    //
    ASSERT(!CIrp2Pkt::IsHeld(irp));
    CPacket * pPacket = CIrp2Pkt::SafePeekFirstPacket(irp);
    ASSERT(pPacket != NULL);
    ASSERT(pPacket->Queue() == this);
    R<CDistribution> pDistribution = this;
    R<CTransaction> pXact = pPacket->Transaction();

    //
    // Detach packets from irp and de-ref the packet attach. Clean the irp.
    //
    for(List<CEntry>::Iterator pEntry(m_members); pEntry != NULL; ++pEntry)
    {
        pEntry->m_pPacket = CIrp2Pkt::GetAttachedPacketsHead(irp);
        pEntry->m_pPacket->Release();

        ASSERT(pEntry->m_pPacket->Queue() == this);
        pEntry->m_pPacket->Queue(NULL);
        ASSERT(pEntry->m_pPacket->Transaction() == pXact);
        pEntry->m_pPacket->Transaction(NULL);
    }
    ASSERT(CIrp2Pkt::NumOfAttachedPackets(irp) == 0);

    //
    // Put each packet in the transaction
    //
    if (pXact != NULL)
    {
        BOOL fPassedPrepare = pXact->PassedPreparePhase();
        for(List<CEntry>::Iterator pEntry(m_members); pEntry != NULL; ++pEntry)
        {
            if (fPassedPrepare)
            {
                pEntry->m_pPacket->Release();
            }
            else
            {
                pEntry->m_pQueue->HandleValidTransactionUsage(TRUE, pEntry->m_pPacket);
                pXact->SendPacket(pEntry->m_pQueue, pEntry->m_pPacket);
            }
        }
        return fPassedPrepare ? MQ_ERROR_TRANSACTION_SEQUENCE : STATUS_SUCCESS;
    }

    //
    // Put each packet in its queue.
    //
    CIrp2Pkt::InitPacketIterator(irp);
    bool fPending = false;
    NTSTATUS MostSevereStatus = STATUS_SUCCESS;
    for(List<CEntry>::Iterator pEntry(m_members); pEntry != NULL; ++pEntry)
    {
        CPacketBuffer * ppb = pEntry->m_pPacket->Buffer();
        if (ppb == NULL)
        {
            pEntry->m_pPacket->Release();
            MostSevereStatus = irp_driver_context(irp)->LastStatus(STATUS_INSUFFICIENT_RESOURCES);
            continue;
        }

        pEntry->m_pQueue->HandleValidTransactionUsage(FALSE, pEntry->m_pPacket);
        NTSTATUS rc = pEntry->m_pQueue->PutPacket(irp, pEntry->m_pPacket, ppb);
        if (rc == STATUS_PENDING)
        {
            fPending = true;
            continue;
        }

        if (!NT_SUCCESS(rc))
        {
            pEntry->m_pPacket->PacketRundown(rc);
            MostSevereStatus = irp_driver_context(irp)->LastStatus(rc);
        }
    }

    return fPending ? STATUS_PENDING : MostSevereStatus;

} // CDistribution::HandleCreatePacketCompletedSuccessAsync


NTSTATUS 
CDistribution::CreateCursor(
	PIRP,
    PFILE_OBJECT, 
    PDEVICE_OBJECT
    )
{
    return MQ_ERROR_ILLEGAL_OPERATION;

} // CDistribution::CreateCursor


NTSTATUS 
CDistribution::SetProperties(
    const VOID*, 
    ULONG
    )
{
    return MQ_ERROR_ILLEGAL_OPERATION;

} // CDistribution::SetProperties


NTSTATUS 
CDistribution::GetProperties(
    VOID*, 
    ULONG
    )
{
    return MQ_ERROR_ILLEGAL_OPERATION;

} // CDistribution::GetProperties


NTSTATUS 
CDistribution::Purge(
    BOOL,
    USHORT
    )
{
    return MQ_ERROR_ILLEGAL_OPERATION;

} // CDistribution::Purge


NTSTATUS
CDistribution::HandleToFormatName(
    LPWSTR pBuffer,
    ULONG  BufferLength,
    PULONG pRequiredLength
    ) const
/*++

Routine Description:

    Translate a distribution object handle to a multi queue format name string
    of all the top level queue formats.

    The pointers and buffer passed to this routine are supplied by the user,
    so parsing them may raise an exception.

Arguments:

    pBuffer         - Pointer to the string output buffer as supplied by user.

    BufferLength    - Length of the string output buffer in characters.

    pRequiredLength - Points to actual length of the mqf string in characters.

Return Value:

    STATUS_SUCCESS - The operation succeeded.
    MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL - The operation failed, buffer too small.
    other status - The operation failed.

    Exceptions: This routine may throw exception.

--*/
{
    NTSTATUS rc1 = STATUS_SUCCESS;
    NTSTATUS rc  = STATUS_SUCCESS;

    *pRequiredLength = 0;
    for (ULONG ix = 0; ix < m_nTopLevelQueueFormats; ++ix)
    {
        bool fLastElement = (ix == m_nTopLevelQueueFormats - 1);

        //
        // Convert queue format element to string
        //
        ULONG Length = BufferLength;
        rc = ACpGetQueueFormatString(rc, m_TopLevelQueueFormats[ix], &pBuffer, &Length, !fLastElement);
        if (!NT_SUCCESS(rc))
        {
            rc1 = rc;
        }

        //
        // Dont count the MQF separator AND the null terminator right after it
        //
        if (!fLastElement)
        {
            --Length;
        }

        //
        // Update required length, remaining length, and pointer in buffer
        //
        *pRequiredLength += Length;
        if (BufferLength < Length)
        {
            BufferLength = 0;
        }
        else
        {
            BufferLength -= Length;
        }
        if (pBuffer != NULL)
        {
            pBuffer += Length;
        }
    }

    return rc1;

} // CDistribution::HandleToFormatName


BOOL 
CDistribution::Closed() const
/*++

Routine Description:

    Check is the destination is closed. We do that by checking if:
    1. The destination object itself is closed => Closed.
    2. The destination object is opened and does not contain any queues => Opened.
    3. The destination object is opened but at least one of the queues inside is closed => Closed.

Arguments:

    None.

Return Value:

    TRUE - closed.
    FALSE - opened.

--*/
{
	if (Inherited::Closed())
	{
		//
		// DL object is closed.
		//
		return TRUE;
	}

	if (m_members.isempty())
	{
		//
		// No queues in DL and DL object is not closed - DL is opened.
		//
		return FALSE;
	}

	for(List<CEntry>::Iterator pEntry(m_members); pEntry != NULL; ++pEntry)
    {
    	ASSERT(pEntry->m_pQueue != NULL);
    	
		if (pEntry->m_pQueue->Closed())
		{
			//
			// Found one queue closed. There are two cases in which this can happen:
			// 1. The QM stopped and restarted while the user held a handle to the destination object.
			// In this case all the queues inside the destination object should be closed.
			// 2. The QM is in the process of stopping - some queues may be opened and some closed.
			// If at least one queue is closed - treat it like all the queues are closed.
			//
			TrTRACE(AC, "Queue inside DL is closed. Continuing like DL object is closed");			
			return TRUE;
		}
	}
	
	//
	// DL object and all DL queues are opened.
	//
	return FALSE;

} // CDistribution::Closed
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\dump.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dump.h

Abstract:

    Header for dump.cpp .

Author:

    Shai Kariv   (shaik)   08-Aug-1999

Environment:

    User mode.

Revision History:

--*/

#pragma once


extern bool g_fDumpUsingLogFile;


//
// Mqdump should not open files for write,
// unless it is dealing with its own dummy log file.
//

#ifdef MQDUMP

const ACCESS_MASK AC_GENERIC_ACCESS  = GENERIC_READ;
const ULONG       AC_PAGE_ACCESS     = PAGE_READONLY;
const DWORD       AC_FILE_MAP_ACCESS = FILE_MAP_READ | FILE_MAP_COPY;

#else // MQDUMP

const ACCESS_MASK AC_GENERIC_ACCESS        = GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE;
const ULONG       AC_PAGE_ACCESS           = PAGE_READWRITE;

#ifdef MQWIN95
const DWORD       AC_FILE_MAP_ACCESS       = FILE_MAP_ALL_ACCESS;
#endif // MQWIN95

#endif // MQDUMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\dl.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dl.h

Abstract:

    Distribution list definitions.
    The distribution list class represents an outgoing message sent to multiple
    destination queues.

Author:

    Shai Kariv  (shaik)  30-Apr-2000

Revision History:

--*/

#ifndef __DL_H
#define __DL_H

#include "queue.h"

//--------------------------------------------------------------
//
// class CDistribution
//
// Header is declared here to allow inclusion of nested classes.
//
//--------------------------------------------------------------

class CDistribution : public CQueue {
public:

//--------------------------------------------------------------
//
// class CDistribution::CEntry
//
// Linked list entry. Points to an outgoing queue object.
//
//--------------------------------------------------------------

    class CEntry {
    public:

        CEntry(
            CQueue * pQueue, 
            bool fProtocolSrmp
            ) : 
            m_pQueue(pQueue),
            m_fProtocolSrmp(fProtocolSrmp),
            m_pPacket(NULL)
        {
        }

        //
        // The linked list entry
        //
        LIST_ENTRY   m_link;

        //
        // The member queue object
        //
        CQueue     * m_pQueue;

        //
        // The protocol used (for direct=http and multicast the protocol is SRMP)
        //
        bool         m_fProtocolSrmp;

        //
        // Scratch pad for the packet to be put in the member queue
        //
        CPacket *    m_pPacket;
    };

//--------------------------------------------------------------
//
// class CDistribution
//
// The class definition actually starts at the top of this file.
//
//--------------------------------------------------------------
//class CDistribution : public CQueue {
public:

    typedef CQueue Inherited;

public:
    //
    // Constructor
    //
    CDistribution(
        PFILE_OBJECT pFile
        );

    //
    // Attach top level queue format names
    //
    NTSTATUS 
    SetTopLevelQueueFormats(
        ULONG              nTopLevelQueueFormats, 
        const QUEUE_FORMAT TopLevelQueueFormats[]
        );

    //
    // Add outgoing queue member
    //
    NTSTATUS AddMember(HANDLE hQueue, bool fProtocolSrmp);

    //
    // Translate distribution object handle to multi queue format name
    //
    virtual
    NTSTATUS 
    HandleToFormatName(
        LPWSTR pBuffer, 
        ULONG  BufferLength, 
        PULONG pRequiredLength
        ) const;

    //
    // Completion handlers for async packet creation.
    //
    virtual NTSTATUS HandleCreatePacketCompletedSuccessAsync(PIRP);
    virtual void     HandleCreatePacketCompletedFailureAsync(PIRP);

    //
    //  Create a cursor
    //
    virtual NTSTATUS CreateCursor(PIRP, PFILE_OBJECT, PDEVICE_OBJECT);

    //
    //  Set properties of the distribution
    //
    virtual NTSTATUS SetProperties(const VOID*, ULONG);

    //
    //  Get the properties of the distribution
    //
    virtual NTSTATUS GetProperties(VOID*, ULONG);

    //
    //  Purge the content of the distribution
    //
    virtual NTSTATUS Purge(BOOL, USHORT);

	//
	// Check if the destination is closed
	//
    virtual BOOL Closed() const;

protected:
    //
    // Destructor
    //
    virtual ~CDistribution();

private:
    //
    // Create new packets, possibly asynchronously.
    //
    virtual NTSTATUS CreatePacket(PIRP, CTransaction*, BOOL, const CACSendParameters*);

    //
    // Completion handler for sync packet creation
    //
    virtual NTSTATUS HandleCreatePacketCompletedSuccessSync(PIRP);

private:
    //
    //  The linked list of outgoing queue objects
    //
    List<CEntry> m_members;

    //
    // The top level queue format names
    //
    ULONG            m_nTopLevelQueueFormats;
    AP<QUEUE_FORMAT> m_TopLevelQueueFormats;

public:
    //
    // Check if this is a valid distribution object
    //
    static NTSTATUS Validate(const CDistribution* pDistribution);

private:
    //
    //  Class type debugging section
    //
    CLASS_DEBUG_TYPE();

}; // CDistribution


//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

#pragma warning(disable: 4238)  //  nonstandard extension used : class rvalue used as lvalue

inline 
CDistribution::CDistribution(
    PFILE_OBJECT pFile
    ) :
    m_nTopLevelQueueFormats(0),
    Inherited(
        pFile, 
        0, 
        0, 
        FALSE,
        0,
        &QUEUE_FORMAT(),
        0,
        0,
        0,
		0
        )
{
} // CDistribution::CDistribution

#pragma warning(default: 4238)  //  nonstandard extension used : class rvalue used as lvalue
    
inline NTSTATUS CDistribution::Validate(const CDistribution* pDistribution)
{
    ASSERT(pDistribution && pDistribution->isKindOf(Type()));
    return Inherited::Validate(pDistribution);

} // CDistribution::Validate


#endif // __DL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\dump.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dump.cpp

Abstract:

    Entry routine for mqdump utility.

Author:

    Shai Kariv   (shaik)   08-Aug-1999

Environment:

    User mode.

Revision History:

--*/

#include "internal.h"
#include "dump.h"
#include "data.h"
#include "qm.h"
#include "heap.h"
#include "packet.h"
#include <uniansi.h>
#include <mqtypes.h>
#include <_mqdef.h>
#include <fntoken.h>
#include <stdio.h>
#include <time.h>

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)
#include <winsvc.h>
#include <_registr.h>
#include <autorel2.h>


void TrERROR(...)
{
};

void TrWARNING(...)
{
};

void TrTRACE(...)
{
};


//
// Control flags
//
bool  g_fDumpUsingLogFile    = true;
static bool  s_fDumpMsgPropsOnly    = false;
static bool  s_fExplicitFilename    = false;
static WCHAR s_wzDumpFile[MAX_PATH] = L"";
bool  g_fDumpRestoreMaximum  = false;
FILE *g_fFixFile = NULL;


static
VOID
DupUsage(
    VOID
    )
{
    printf("\n");
    printf("Syntax: mqdump -p [-l] [-t] | -r [-t] | -a [-l] [-t] | <Pathname> [-l] [-t] [-s]\n");
    printf("\t-p:         dump Persistent storage files\n");
    printf("\t-r:         dump Reliable storage files\n");
    printf("\t-a:         dump All storage files (Persistent + Reliable)\n");
    printf("\t<Pathname>: dump <Pathname> only\n");
    printf("\t-l:         no Log file\n");
    printf("\t-t:         dump message properTies only\n");
    printf("\t-s:         reStore maximum possible\n");

    exit(1);

} //DupUsage


static
VOID
DupErrorExit(
    LPCWSTR message
    )
{
    wprintf(L"%s\n", message);
    printf("Exiting...");

    exit(1);

} //DupErrorExit


static
VOID
DupInit(
    VOID
    )
/*++

Routine Description:

    Initialize mqac as a library.

Arguments:

    None.

Return Value:

    None.

--*/
{
    g_ulHeapPoolSize = 4 * 1024 * 1024;

    BOOL APIENTRY DllMain(HANDLE, DWORD, PVOID);
    DllMain(NULL, DLL_PROCESS_ATTACH, NULL);

    GUID qmid = GUID_NULL;

    PCWSTR pPath = L"\\DummyPath";

    g_pAllocator = new (PagedPool) CSMAllocator(pPath, pPath, pPath, pPath);


    g_pQM->Connect(reinterpret_cast<PEPROCESS>(1), 0, &qmid);

} //DupInit


static
VOID
DupGetFullPathName(
    LPCWSTR     pwzFileName,
    LPWSTR      pwzPath,
    LPWSTR      pwzFile
    )
/*++

Routine Description:

    Wrapper for Win32 API GetFullPathName().

    Break a full pathname into a path part and 
    a file part.

Arguments:

    pwzFileName - Pointer to const buffer with path name.

    pwzPath     - Pointer to out buffer to contain path part.

    pwzFile     - Pointer to out buffer to contain file part.

Return Value:

    None.

--*/
{
    //
    // BUGBUG: assuming length of buffers is MAX_PATH
    //

    LPWSTR pwFile = 0;
    if (0 == GetFullPathName(pwzFileName, MAX_PATH, pwzPath, &pwFile))
    {
        WCHAR err[256] = L"";
        swprintf(
            err, 
            L"Unable to get full path name for '%s', error 0x%x", 
            pwzFileName, 
            GetLastError()
            );

        DupErrorExit(err);
    }

    wcscpy(pwzFile, pwFile);
    *pwFile = NULL;

} //DupGetFullPathName


static
VOID
DupGetStoragePath(
    LPCWSTR pwzRegName,
    LPWSTR  pwzPath
    )
/*++

Routine Description:

    Read from registry the pathname of an
    MSMQ storage type, and write it on a
    buffer.

Arguments:

    pwzRegName - Pointer to buffer containing registry value to read.

    pwzPath    - Pointer to out buffer to contain storage pathname.

Return Value:

    None.

--*/
{
    //
    // BUGBUG: assuming buffer length is MAX_PATH
    //
    DWORD dwType = REG_SZ;
    DWORD cbSize = MAX_PATH * sizeof(WCHAR);   

    LONG rc = GetFalconKeyValue(pwzRegName, &dwType, pwzPath, &cbSize);

    if (rc != ERROR_SUCCESS)
    {
        DupErrorExit(L"Failed to read MSMQ storage path from registry.");
    }

    size_t len = wcslen(pwzPath);
    if (pwzPath[len-1] != L'\\')
    {
        wcscat(pwzPath, L"\\");
    }
} //DupGetStoragePath


static
VOID
DupComputeSearchPattern(
    LPCWSTR pwzPath,
    WCHAR   cPatternLetter,
    LPWSTR  pwzPattern
    )
/*++

Routine Description:

    Generate a file template string to be used
    by FindFirstFile / FindNextFile.

Arguments:

    pwzPath - Pathname of an MSMQ storage folder.

    cPatternLetter - Initial letter of storage file (e.g. 'p', 'j', 'r').

    pwzPattern - Pointer to out buffer to contain the generated string.

Return Value:

    None.

--*/
{
    swprintf(pwzPattern, L"%s%c*.mq", pwzPath, cPatternLetter);

} //DupComputeSearchPattern


static
VOID
DupGetPathAndPattern(
    LPCWSTR pwzRegName,
    WCHAR   cPatternLetter,
    LPWSTR  pwzPath,
    LPWSTR  pwzPattern
    )
{
    DupGetStoragePath(pwzRegName, pwzPath);

    DupComputeSearchPattern(pwzPath, cPatternLetter, pwzPattern);
    
} //DupGetPathAndPattern


static
bool
DupIsFileFound(
    LPCWSTR pFileName
    )
/*++

Routine Description:

    Check if a given file is on disk.

Arguments:

    pFileName - Full pathname to check.

Return Value:

    true - File was found.

    false - File not found.

--*/
{
    DWORD attr = GetFileAttributes(pFileName);

    if ( 0xffffffff == attr )
    {
        return false;
    }

    return true;

} // DupIsFileFound


static
VOID
DupGenerateLogFileName(
    LPCWSTR pwzPersistentFile,
    LPWSTR  pwzLogFile
    )
/*++

Routine Description:

    Generate the file name of a storage log file
    corresponded to a given persistent storage file.

Arguments:

    pwzPersistentFile - Name of an MSMQ persistent storage file.

    pwzLogFile - Pointer to out buffer to contain storage log file.

Return Value:

    None.

--*/
{
    //
    // Generate the file name part of the log pathname
    //

    WCHAR wzPath[MAX_PATH] = L"";
    WCHAR wzFile[MAX_PATH] = L"";

    DupGetFullPathName(pwzPersistentFile, wzPath, wzFile);
    wzFile[0] = L'l';

    WCHAR wzLogFile[MAX_PATH] = L"";
    if (s_fExplicitFilename)
    {
        //
        // Explicit pathname to dump was given as an argument.
        // Log file should be in same folder as the file-to-dump.
        //
        swprintf(wzLogFile, L"%s%s", wzPath, wzFile);
    }
    else
    {
        //
        // Dump all files, or all persistent files.
        // Search log file in the log folder as written in registry.
        //
        WCHAR wzLogPath[MAX_PATH] = L"";
        DupGetStoragePath(MSMQ_STORE_LOG_PATH_REGNAME, wzLogPath);
        swprintf(wzLogFile, L"%s%s", wzLogPath, wzFile);
    }

    //
    // Copy on the out buffer.
    // BUGBUG: assuming out buffer is big enough (MAX_PATH).
    //
    wcscpy(pwzLogFile, wzLogFile);

} // DupGenerateLogFileName

    
static
VOID
DupCreateDummyLogFile(
    LPCWSTR pwzFileName,
    LPWSTR  pwzDummy
    )
/*++

Routine Description:

    Create a dummy log file in the folder of the given file.

Arguments:

    pwzFileName - Name of a storage file to dump.

    pwzDummy - Points to out buffer to receive the pathname of the dummy.

Return Value:

    None.

--*/
{
    //
    // BUGBUG: Assuming length of out buffer is long enough (MAX_PATH).
    //

    //
    // Generate a full path name
    //
    WCHAR wzFile[MAX_PATH] = L"";
    DupGetFullPathName(pwzFileName, pwzDummy, wzFile);

    LPCWSTR xDUMMY_FILE_NAME = L"mqdump.mq";
    wcscat(pwzDummy, xDUMMY_FILE_NAME);

    //
    // Create the dummy log file
    //
    PWCHAR pBitmapFile;
    HANDLE hBitmapFile;
    CPingPong * pPingPong = ACpCreateBitmap(pwzDummy, &pBitmapFile, &hBitmapFile);

    if (pPingPong == NULL)
    {
        DupErrorExit(L"Failed to create a dummy log file.");
    }

    //
    // Set it not coherent
    //
    pPingPong->SetNotCoherent();
    NTSTATUS rc = ACpWritePingPong(pPingPong, hBitmapFile);

    if (!NT_SUCCESS(rc))
    {
        DupErrorExit(L"Failed to create a dummy log file.");
    }
} // DupCreateDummyLogFile


static
VOID
DupDumpPersistentUsingLog(
    LPCWSTR pwzFileName
    )
/*++

Routine Description:

    Dump content of a persistent MSMQ storage file using its log file.

Arguments:

    pwzFileName - Name of a persistent storage file to dump.

Return Value:

    None.

--*/
{
    WCHAR wzLogFile[MAX_PATH] = L"";
    DupGenerateLogFileName(pwzFileName, wzLogFile);

    //
    // Make sure log file exists on disk
    //
    if (!DupIsFileFound(wzLogFile))
    {
        wprintf(L"Log file '%s' not found.\n", wzLogFile);
        printf("Aborting dump of this file...\n");
        printf("-----------------------------------\n");
        return;
    }

    wprintf(L"Log file is: '%s'\n", wzLogFile);
    printf("-----------------------------------\n");

    //
    // Do dump
    //
    CPoolAllocator pa(L".", x_persist_granularity, ptPersistent);
    pa.RestorePackets(wzLogFile, pwzFileName);

} // DupDumpPersistentUsingLog


static
VOID
DupDumpPersistentNoLog(
    LPCWSTR pwzFileName
    )
/*++

Routine Description:

    Dump content of a persistent MSMQ storage file without using log file.

Arguments:

    pwzFileName - Name of a persistent storage file to dump.

Return Value:

    None.

--*/
{
    printf("( *** No use of Log file *** )\n");
    printf("-----------------------------------\n");

    //
    // Create a dumy log file in the folder of the file-to-dump
    //
    WCHAR wzDummy[MAX_PATH] = L"";
    DupCreateDummyLogFile(pwzFileName, wzDummy);

    //
    // Do dump. 
    //
    {
        CPoolAllocator pa(L".", x_persist_granularity, ptPersistent);
        pa.RestorePackets(wzDummy, pwzFileName);
    }

    //
    // Delete the dummy log file. Ignore errors.
    //
    DeleteFile(wzDummy);

} // DupDumpPersistentNoLog


static
VOID
DupDumpPersistent(
    LPCWSTR pwzFileName
    )
/*++

Routine Description:

    Dump content of a persistent MSMQ storage file.

Arguments:

    pwzFileName - Name of a persistent storage file to dump.

Return Value:

    None.

--*/
{
    printf("\n\n");
    printf("-----------------------------------\n");
    wprintf(L"Dump of file '%s':\n", pwzFileName);

    if (s_fDumpMsgPropsOnly)
    {
        printf("( *** Dump of message properties only *** )\n");
    }

	if (g_fDumpRestoreMaximum)
    {
        WCHAR wcsFullFixPathname[MAX_PATH];

        // generate full path name for fix file 
	    wcscpy(wcsFullFixPathname,pwzFileName);
	    wcscat(wcsFullFixPathname,L".fix");

	    // Create & open fix file. Let it be empty is everything OK.
	    g_fFixFile = _wfopen( wcsFullFixPathname, L"w" );
    }
    
	if (g_fDumpUsingLogFile)
    {
        DupDumpPersistentUsingLog(pwzFileName);
        return;
    }

    DupDumpPersistentNoLog(pwzFileName);

    // Close fix file
	if (g_fDumpRestoreMaximum)
    {
        fclose(g_fFixFile);
    }

} //DupDumpPersistent


static
VOID
DupDumpPersistentAllInternal(
    LPCWSTR pwzPath,
    LPCWSTR pwzPattern
    )
/*++

Routine Description:

    Enumerate persistent storage files of a specific type
    (either 'p' or 'j') and dump their content.

Arguments:

    pwzPath - Path name of an MSMQ storage folder to enumerate files in.

    pwzPattern - File template to search for ("p*.mq" or "j*.mq").

Return Value:

    None.

--*/
{
    WIN32_FIND_DATA FindData;
    CFindHandle hEnum(FindFirstFile(pwzPattern, &FindData));

    if(hEnum == INVALID_HANDLE_VALUE)
    {
        return;
    }

    do
    {
        WCHAR wzFile[MAX_PATH] = L"";
        swprintf(wzFile, L"%s%s", pwzPath, FindData.cFileName);

        DupDumpPersistent(wzFile);

    } while(FindNextFile(hEnum, &FindData));

} //DupDumpPersistentAllInternal


static
VOID
DupDumpPersistentAll(
    VOID
    )
/*++

Routine Description:

    Enumerate all persistent storage files and dump their content.

Arguments:

    None.

Return Value:

    None.

--*/
{
    printf("\n\n");
    printf("---------------------------------\n");
    printf("Dump of Persistent storage files:\n");
    printf("---------------------------------\n");

    WCHAR wzPath[MAX_PATH]    = L"";
    WCHAR wzPattern[MAX_PATH] = L"";

    //
    // Dump "j*.mq" files
    //
    DupGetPathAndPattern(MSMQ_STORE_JOURNAL_PATH_REGNAME, L'j', wzPath, wzPattern);
    DupDumpPersistentAllInternal(wzPath, wzPattern);

    //
    // Dump "p*.mq" files
    //
    DupGetPathAndPattern(MSMQ_STORE_PERSISTENT_PATH_REGNAME, L'p', wzPath, wzPattern);
    DupDumpPersistentAllInternal(wzPath, wzPattern);

} //DupDumpPersistentAll


static
VOID
DupDumpReliable(
    LPCWSTR pwzFileName
    )
/*++

Routine Description:

    Dump content of a reliable (express) MSMQ storage file.

Arguments:

    pwzFileName - Name of a reliable (express) storage file to dump.

Return Value:

    None.

--*/
{
    printf("\n\n");
    printf("-----------------------------------\n");
    wprintf(L"Dump of file '%s':\n", pwzFileName);
    
    if (s_fDumpMsgPropsOnly)
    {
        printf("( *** Dump of message properties only *** )\n");
    }

    printf("-----------------------------------\n");

    CPoolAllocator pa(L".", x_express_granularity, ptReliable);
    pa.RestoreExpressPackets(pwzFileName);

} //DupDumpReliable


static
VOID 
DupDumpReliableAll(
    VOID
    )
/*++

Routine Description:

    Enumerate all reliable (express) storage files and dump their content.

Arguments:

    None.

Return Value:

    None.

--*/
{
    printf("\n\n");
    printf("-------------------------------\n");
    printf("Dump of Reliable storage files:\n");
    printf("-------------------------------\n");

    WCHAR wzPath[MAX_PATH]    = L"";
    WCHAR wzPattern[MAX_PATH] = L"";

    DupGetPathAndPattern(MSMQ_STORE_RELIABLE_PATH_REGNAME, L'r', wzPath, wzPattern);

    WIN32_FIND_DATA FindData;
    CFindHandle hEnum(FindFirstFile(wzPattern, &FindData));

    if(hEnum == INVALID_HANDLE_VALUE)
    {
        return;
    }

    do
    {
        WCHAR wzFile[MAX_PATH] = L"";
        swprintf(wzFile, L"%s%s", wzPath, FindData.cFileName);

        DupDumpReliable(wzFile);

    } while(FindNextFile(hEnum, &FindData));
    
} //DupDumpReliableAll


static
bool
DupIsFilePersistent(
    LPCWSTR pwzFileName
    )
/*++

Routine Description:

    Check if a filename represents a persistent storage file ("p*.mq" or "j*.mq").

Arguments:

    pwzFileName - Name of file to check.

Return Value:

    true - File is persistent.

    false - File is not persistent.

--*/
{
    WCHAR wzPath[MAX_PATH] = L"";
    WCHAR wzFile[MAX_PATH] = L"";

    DupGetFullPathName(pwzFileName, wzPath, wzFile);

    return (wzFile[0] == L'p'   ||   wzFile[0] == L'j');

} //DupIsFilePersistent


static
VOID
DupDumpExplicitFile(
    VOID
    )
/*++

Routine Description:

    Dump content of file whose name was given explicitly by user.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Invalid file name, or file not found.
    //
    if (wcslen(s_wzDumpFile) < 1)
    {
        DupUsage();
    }

    //
    // Raise the explicit flag - used later during dump.
    //
    s_fExplicitFilename = true;
    
    //
    // Decide if file is persistent or express
    //
    if (DupIsFilePersistent(s_wzDumpFile))
    {
        DupDumpPersistent(s_wzDumpFile);
        return;
    }
    
    DupDumpReliable(s_wzDumpFile);

} // DupDumpExplicitFile


static
WCHAR
DupGetUserAction(
    int      argc, 
    wchar_t* * argv 
    )
/*++

Routine Description:

    Parse command line arguments.

Arguments:

    argc - Number of command line arguments. 

    argv - Array of command line arguments.

Return Value:

    Lowercase char representing user action.

--*/
{
    WCHAR cAction = 0;

    for (int i = 1; i < argc; ++i)
    {
        WCHAR c = argv[i][0];
        if (c != L'-' && c != L'/')
        {
            if (wcslen(s_wzDumpFile) > 0 || cAction != 0)
            {
                DupUsage();
            }

            WCHAR wzPath[MAX_PATH]     = L"";
            WCHAR wzFile[MAX_PATH]     = L"";

            LPCWSTR pArg = argv[i];
            DupGetFullPathName(pArg, wzPath, wzFile);

            swprintf(s_wzDumpFile, L"%s%s", wzPath, wzFile);

            continue;
        }

        if (wcslen(argv[i]) != 2)
        {
            DupUsage();
        }
        
        c = static_cast<WCHAR>(tolower(argv[i][1]));
        if (c == L'l')
        {
            g_fDumpUsingLogFile = false;
        }
        else if (c == L't')
        {
            s_fDumpMsgPropsOnly = true;
        }
        else if (c == 's')
        {
            g_fDumpRestoreMaximum = true;
        }
        else
        {
            cAction = c;
            if (wcslen(s_wzDumpFile) > 0)
            {
                DupUsage();
            }
        }
    }

    if (cAction == 0 && wcslen(s_wzDumpFile) < 1)
    {
        DupUsage();
    }

    return cAction;

} //DupGetUserAction


extern "C"
int
__cdecl
wmain(
    int      argc,
    wchar_t* * argv
    )
{
    DupInit();

    switch(DupGetUserAction(argc, argv))
    {
        case L'p':
        {
            DupDumpPersistentAll();
            return 0;
        }

        case L'r':
        {
            DupDumpReliableAll();
            return 0;
        }

        case L'a':
        {
            DupDumpPersistentAll();
            DupDumpReliableAll();
            return 0;
        }

        default:
        {
            DupDumpExplicitFile();
            return 0;
        }
    }
} //main



////////////////////////////////////////////////////////////////////////////
//
// Dump routines for packet headers
//

static
VOID
DupGuidToString(
    GUID   guid,
    LPWSTR pwzGuid
    )
{
    const int xGuidStrBufferSize = (8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1);

    const GUID * pguid = &guid;
    _snwprintf(
        pwzGuid,
        xGuidStrBufferSize,
        GUID_FORMAT,             // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        GUID_ELEMENTS(pguid)
        );
} // DupGuidToString


static
VOID 
DupDumpInfoHeader(
    const CPacketInfo * ppi
    )
{
	printf("\nPacket Info Header:\n");

	printf("\tSequential ID       = 0x%I64x\n", ppi->SequentialId());    
	printf("\tIn Source Machine   = %s\n", ppi->InSourceMachine()   ? "True" : "False");
	printf("\tIn Target Queue     = %s\n", ppi->InTargetQueue()     ? "True" : "False");
	printf("\tIn Journal Queue    = %s\n", ppi->InJournalQueue()    ? "True" : "False");
	printf("\tIn Machine Journal  = %s\n", ppi->InMachineJournal()  ? "True" : "False");
	printf("\tIn Deadletter Queue = %s\n", ppi->InDeadletterQueue() ? "True" : "False");
	printf("\tIn Machine Deadxact = %s\n", ppi->InMachineDeadxact() ? "True" : "False");
	printf("\tIn Connector Queue  = %s\n", ppi->InConnectorQueue()  ? "True" : "False");
	printf("\tIn Transaction      = %s\n", ppi->InTransaction()     ? "True" : "False");
	printf("\tTransact Send       = %s\n", ppi->TransactSend()      ? "True" : "False");

	const XACTUOW *uow = ppi->Uow(); 

	printf("\tUow                 = ");
	for (DWORD i=0; i<16; ++i)
    {
		printf("%x ",uow->rgb[i]);
    }
	
    printf("\n");

} // DupDumpInfoHeader


static
VOID 
DupDumpBaseHeader(
    const CBaseHeader * pBase
    )
{
	printf("\nPacket Base Header:\n");

	if (pBase->VersionIsValid())
	{
		printf("\tVersion             = 0x%x\n",pBase->GetVersion());
	}
	else
	{
		printf("\tVersion             = Not Valid\n");
	}

	printf("\tSignature is Valid  = %s\n", pBase->SignatureIsValid() ? "True" : "False");

	printf("\tPacket Size = %d (0x%x)\n", pBase->GetPacketSize() , pBase->GetPacketSize());

	ULONG ulAbsTime = pBase->GetAbsoluteTimeToQueue();
	printf("\tAbsolute Time To Q  = (0x%x) %s", ulAbsTime,
		    (ulAbsTime == INFINITE) ? "Infinite\n" : ctime((time_t*)(&ulAbsTime)));

	printf("\tBase Header Flags:\n");

	printf("\t\tPriority    = %u\n", pBase->GetPriority());
	printf("\t\tInternal    = %u\n", pBase->GetType());
	printf("\t\tSession     = %u\n", pBase->SessionIsIncluded() ? 1 : 0);
	printf("\t\tDebug       = %u\n", pBase->DebugIsIncluded()   ? 1 : 0);
	printf("\t\tAck         = %u\n", pBase->AckIsImmediate()    ? 1 : 0);
	printf("\t\tTrace       = %u\n", pBase->GetTraced());
	printf("\t\tFragment    = %u\n", pBase->IsFragmented()      ? 1 : 0);

} // DupDumpBaseHeader


static
VOID 
DupDumpUserHeader(
    const CUserHeader * pUser
    )
{
	printf("\nPacket User Section:\n");

    WCHAR wzBuffer[1000] = L"";
	DupGuidToString(*pUser->GetSourceQM(), wzBuffer);
	wprintf(L"\tSource QM           = %s\n", wzBuffer);

	DupGuidToString(*pUser->GetDestQM(), wzBuffer);
	wprintf(L"\tDestination QM      = %s\n", wzBuffer);

	wprintf(L"\tHop Count           = %u\n", pUser->GetHopCount());


    LPCWSTR Delivery[] = {L"Guaranteed", L"Recoverable", L"On-Line", L"Reserved"};
    wcscpy(wzBuffer, L"Unknown");

    UCHAR uDelivery = pUser->GetDelivery();
    if (uDelivery >= 0 && uDelivery < sizeof(Delivery)/sizeof(Delivery[0]))
    {
        wcscpy(wzBuffer, Delivery[uDelivery]);
    }
	wprintf(L"\tDelivery Mode       = (0x%x) %s\n", uDelivery, wzBuffer);


    LPCWSTR Audit[] = {L"Dead letter file", L"Journal file", L"Journal + Dead letter file"};
    wcscpy(wzBuffer, L"Not Journal, not Dead letter file");

    UCHAR uAudit = pUser->GetAuditing();
    if (uAudit >= 0 && uAudit < sizeof(Audit)/sizeof(Audit[0]))
    {
        wcscpy(wzBuffer, Audit[uAudit]);
    }
	wprintf(L"\tAuditing Mode       = (0x%x) %s\n", uAudit ,wzBuffer);


	printf("\tSecurity Section    = %s\n", pUser->SecurityIsIncluded() ? "Included" : "Not included");
	printf("\tOrdered             = %s\n", pUser->IsOrdered()          ? "True" : "False");
	printf("\tProp Section        = %s\n", pUser->PropertyIsIncluded() ? "Included" : "Not included");
	printf("\tMQF Sections        = %s\n", pUser->MqfIsIncluded() ? "Included" : "Not included");
	printf("\tSRMP Sections       = %s\n", pUser->SrmpIsIncluded() ? "Included" : "Not included");

	if (pUser->ConnectorTypeIsIncluded())
	{
		DupGuidToString(*pUser->GetConnectorType(), wzBuffer);
		wprintf(L"\tConnector Type      = %s\n",  wzBuffer);
	}
	else
	{
		wprintf(L"\tConnector Type      = Not Included.\n");
	}
} // DupDumpUserHeader


static
VOID 
DupDumpXactHeader(
    const CXactHeader * pXact
    )
{
	printf("\nPacket Xact Section:\n");

	printf("\tSequence ID         = %I64d\n", pXact->GetSeqID());
	printf("\tSequence Number     = %u\n", pXact->GetSeqN());
	printf("\tPrevious Seq Number = %u\n", pXact->GetPrevSeqN());

	if (pXact->ConnectorQMIncluded())
	{
        WCHAR wzBuffer[1000] = L"";
		DupGuidToString(*pXact->GetConnectorQM(), wzBuffer);

		wprintf(L"\tConnector QM        = %s\n", wzBuffer);
	}
	else
	{
		printf("\tConnector QM        = Not included.\n");
	}
} // DupDumpXactHeader


static
VOID 
DupDumpSecurityHeader(
    const CSecurityHeader * pSec
    )
{
	printf("\nPacket Security Section:\n");

	printf("\tAuthenticated       = %s\n", pSec->IsAuthenticated() ? "True" : "False");
	printf("\tEncrypted           = %s\n", pSec->IsEncrypted()     ? "True" : "False"); 

} // DupDumpSecurityHeader


static
VOID
DupDumpPacketHeaders(
    const CAccessibleBlock * pab
    )
/*++

Routine Description:

    Dump content of all packet headers except Property, MQF, SRMP

Arguments:

    pab - Pointer to accessible packet buffer.

Return Value:

    None.

--*/
{
    const CPacketBuffer * ppb = static_cast<const CPacketBuffer*>(pab);

	printf("\nBlock size= %u (0x%x)\n", pab->m_size, pab->m_size);

    if (!s_fDumpMsgPropsOnly)
    {
        DupDumpInfoHeader(ppb);
    }

    const CBaseHeader * pBase = ppb;
    if (!s_fDumpMsgPropsOnly)
    {
        DupDumpBaseHeader(pBase);
    }

    PVOID pSection      = pBase->GetNextSection();
    CUserHeader * pUser = static_cast<CUserHeader*>(pSection);
    if (!s_fDumpMsgPropsOnly)
    {
        DupDumpUserHeader(pUser);
    }

    pSection = pUser->GetNextSection();
    if(pUser->IsOrdered())
    {
        CXactHeader * pXact = static_cast<CXactHeader*>(pSection);
        pSection = pXact->GetNextSection();
        
        if (!s_fDumpMsgPropsOnly)
        {
            DupDumpXactHeader(pXact);
        }
    }

    if(pUser->SecurityIsIncluded())
    {
        CSecurityHeader * pSec = static_cast<CSecurityHeader*>(pSection);
        pSection = pSec->GetNextSection();
        
        if (!s_fDumpMsgPropsOnly)
        {
            DupDumpSecurityHeader(pSec);
        }
    }

    if (pUser->MqfIsIncluded())
    {
        //
        // MQF properties are dumped elsewhere.
        //
        NULL;
    }

    if (pUser->SrmpIsIncluded())
    {
        //
        // SRMP properties are dumped elsewhere
        //
        NULL;
    }
    
} // DupDumpPacketHeaders


////////////////////////////////////////////////////////////////////////////
//
// Dump routines for packet properties
//

static
VOID 
DupDumpPropertyClass(
    USHORT usClass
    )
{
    struct Entry
    {
        USHORT  usClass;
        LPCWSTR pDescription;
    };

    Entry Class[] = {
        { MQMSG_CLASS_NORMAL,                     L"Normal"                      },
        { MQMSG_CLASS_REPORT,                     L"Report"                      },
        { MQMSG_CLASS_ACK_REACH_QUEUE,            L"Ack Reach Queue"             },
        { MQMSG_CLASS_ORDER_ACK,                  L"Order Ack"                   },
        { MQMSG_CLASS_ACK_RECEIVE,                L"Ack Receive"                 },
        { MQMSG_CLASS_NACK_BAD_DST_Q,             L"Nack Bad Destination Queue"  },
        { MQMSG_CLASS_NACK_PURGED,                L"Nack Purged"                 },
        { MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT,   L"Nack Reach Queue Timeout"    },
        { MQMSG_CLASS_NACK_Q_EXCEED_QUOTA,        L"Nack Queue Exceed Quota"     },
        { MQMSG_CLASS_NACK_ACCESS_DENIED,         L"Nack Access Denied"          },
        { MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED,    L"Nack Hop Count Exceeded"     },
        { MQMSG_CLASS_NACK_BAD_SIGNATURE,         L"Nack Bad Signature"          },
        { MQMSG_CLASS_NACK_BAD_ENCRYPTION,        L"Nack Bad Encryption"         },
        { MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT,     L"Nack Could Not Encrypt"      },
        { MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q,   L"Nack Not Transactional Queue"},
        { MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG, L"Nack Not Transactional Msg"  },
        { MQMSG_CLASS_NACK_Q_DELETED,             L"Nack Queue Deleted"          },
        { MQMSG_CLASS_NACK_Q_PURGED,              L"Nack Queue Purged"           },
        { MQMSG_CLASS_NACK_RECEIVE_TIMEOUT,       L"Nack Receive Timeout"        },
        { MQMSG_CLASS_NACK_SOURCE_COMPUTER_GUID_CHANGED,		  L"Nack Source machine GUID changed"		 }
    };

    printf("\tPROPID_M_CLASS               = (0x%x) ", usClass);

    for (int i = 0; i < sizeof(Class)/sizeof(Class[0]); ++i)
    {
        if (usClass == Class[i].usClass)
        {
            wprintf(L"%s\n", Class[i].pDescription);
            return;
        }
    }

    printf("Unknown\n");

} // DupDumpPropertyClass


static
VOID 
DupDumpPropertyAcknowledge(
    UCHAR  uAcknowledge
    )
{
    LPCWSTR Acknowledge[] = 
    {
        L"No acknowledgment", 
        L"Negative acknowledgment", 
        L"Full acknowledgment"
    };

    printf("\tPROPID_M_ACKNOWLEDGE         = (0x%x) ", uAcknowledge);

    if (uAcknowledge >= 0 && uAcknowledge < sizeof(Acknowledge)/sizeof(Acknowledge[0]))
    {
        wprintf(L"%s\n", Acknowledge[uAcknowledge]);
        return;
    }

    printf("Unknown\n");
		
} // DupDumpPropertyAcknowledge


static
VOID 
DupDumpPropertyMsgId(
    const  OBJECTID *pID
    )
{
    WCHAR wzBuffer[2000] = L"";
    DupGuidToString(pID->Lineage, wzBuffer);

    WCHAR szI4[12] = L"";

    _ltow(pID->Uniquifier, szI4, 10);

    wcscat(wzBuffer, L"\\") ;
    wcscat(wzBuffer, szI4) ;

    wprintf(L"\tPROPID_M_MSGID               = %s\n", wzBuffer);

} // DupDumpPropertyMsgId


static
VOID 
DupDumpPropertyCorrelationId(
    const UCHAR * puCorrelationId
    )
{
    printf("\tPROPID_M_CORRELATIONID       = ");

    for (DWORD i = 0; i < PROPID_M_CORRELATIONID_SIZE; ++i)
    {
        printf("%x", puCorrelationId[i]);
    }

    printf("\n");
    
} // DupDumpPropertyCorrelationId


static
VOID 
DupDumpPropertySenderId(
    const UCHAR * puSenderId
    )
{
    PVOID pSid = static_cast<PVOID>(const_cast<UCHAR*>(puSenderId));
    if (!IsValidSid(pSid)) 
    {
        return;
    }

    PSID_IDENTIFIER_AUTHORITY psia = GetSidIdentifierAuthority(pSid);

    DWORD dwSubAuthorities = *(GetSidSubAuthorityCount(pSid));

    //
    // compute buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    //DWORD dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // prepare S-SID_REVISION-
    //
    WCHAR wzBuffer[2000] = L"";
    DWORD dwSidRev = SID_REVISION;
    swprintf(wzBuffer, L"S-%lu-", dwSidRev);

    //
    // prepare SidIdentifierAuthority
    //
    WCHAR wzTmp[1000] = L"";
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
		swprintf(
            wzTmp,
            L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
            (USHORT)psia->Value[0],
            (USHORT)psia->Value[1],
            (USHORT)psia->Value[2],
            (USHORT)psia->Value[3],
            (USHORT)psia->Value[4],
            (USHORT)psia->Value[5]
            );
        wcscat(wzBuffer, wzTmp);
    }
    else
    {
		swprintf(
            wzTmp,
            L"%lu"  ,
            (ULONG)(psia->Value[5]      )   +
            (ULONG)(psia->Value[4] <<  8)   +
            (ULONG)(psia->Value[3] << 16)   +
            (ULONG)(psia->Value[2] << 24)   
            );
        wcscat(wzBuffer, wzTmp);
    }

    //
    // loop through SidSubAuthorities
    //
    for (DWORD dwCounter = 0 ; dwCounter < dwSubAuthorities ; ++dwCounter)
    {
		swprintf(wzTmp, L"-%lu",*(GetSidSubAuthority(pSid, dwCounter)));
        wcscat(wzBuffer, wzTmp);
    }

    wprintf(L"\tPROPID_M_SENDERID            = %s\n", wzBuffer);

} // DupDumpPropertySenderId


static
VOID 
DupDumpPropertyBody(
    const UCHAR * puBody, 
    ULONG ulBodySize
    )
{
    printf("\tPROPID_M_BODY =\n"); 

    const DWORD x_CharsPerRow = 19;
    DWORD i = 0;
    while (i < ulBodySize)
    {
        for (DWORD j = i; j < i + x_CharsPerRow; ++j)
        {
            if (j < ulBodySize)
            {
                printf("%.2x ", puBody[j]);
            }
        }
        
        for (j = i; j < i + x_CharsPerRow; ++j)
        {
            if (j < ulBodySize)
            {
                if (puBody[j] < 32)
                {
                    printf(".");
                }
                else
                {
                    wprintf(L"%c", puBody[j]);
                }
            }
        }
        
        printf("\n");
        i += x_CharsPerRow;
    }

    printf("\n\n");

} // DupDumpPropertyBody


static
VOID 
DupDumpPropertySenderCert(
    const UCHAR * puSenderCert, 
    ULONG ulSenderCertLen
    )
{
    wprintf(L"\tPROPID_M_SENDER_CERT         = < NOT IMPLEMENTED IN MQDUMP.EXE >\n");
    //
    // BUGBUG: not implemented yet (the following seems digsig related)
    //
    /*
    R<IPersistMemBlob> pMem;
    if (CreateX509(NULL, IID_IPersistMemBlob, (LPVOID*)&pMem))
    {
        BLOB b;
        b.cbSize = ulSenderCertLen;
        b.pBlobData = puSenderCert;
        
        HRESULT hr = pMem->Load(&b);
        if (hr != S_OK)
        {
            return;
        }

        R<IX509> p509;
        pMem->QueryInterface(IID_IX509, (LPVOID*)&p509);
        
        printf("\tPROPID_M_SENDER_CERT:\n");
        
        AP<char> szSubject;
        ShowSubject(&szSubject, p509);
        printf("\t\tSubject: %s\n", szSubject);
        
        AP<char> szIssuer;
        ShowIssuer(&szIssuer, p509);
        printf("\t\tIssuer:  %s\n", szIssuer);
        
        AP<char> szStartDate;
        ShowStartDate(&szStartDate, p509);
        printf("\t\tStart Date: %s\n", szStartDate);
        
        AP<char> szEndDate;
        ShowEndDate(&szEndDate, p509);
        printf("\t\tExpiration Date: %s\n", szEndDate);
    } */
} // DupDumpPropertySenderCert


static
VOID 
DupDumpPropertyMsgExtension(
    const UCHAR * puMsgExtension, 
    ULONG ulMsgExtensionBufferInBytes
    )
{
    printf("\tPROPID_M_EXTENSION         = ");

    for (DWORD i = 0; i < ulMsgExtensionBufferInBytes; ++i)
    {
        printf("%x", puMsgExtension[i]);
    }

    printf("\n");

} // DupDumpPropertyMsgExtension


////////////////////////////////////////////////////////////////////////////
//
// Routines for express messages
//

static 
CAllocatorBlockOffset
ACpIndex2BlockOffsetExpress(
    ULONG ix
    )
/*++

Routine Description:

    Based on ACpIndex2BlockOffset.

Arguments:

    ix    - Index of packet.

Return Value:

    Offset of block.

--*/
{
    return ix * x_express_granularity;

} // ACpIndex2BlockOffsetExpress


static
bool 
ACpValidAllocatorHeaderExpress(
    CAccessibleBlock *pab, 
    ULONG ixStart, 
    ULONG ixEnd
    )
/*++

Routine Description:

    Based on ACpValidAllocatorHeader.

Arguments:

    pab - Pointer to block.

    ixStart - 

    ixEnd   -

Return Value:

    true - Block is valid.

    false - Block is not valid.

--*/
{
	if(pab->m_size == 0)
	{
		//
		// Size is too small
		//
		return false;
	}

	if((pab->m_size & (x_express_granularity - 1)) != 0)
	{
		//
		// Size is not of the right granularity
		//
		return false;
	}

	if(pab->m_size > (ixEnd - ixStart) * x_express_granularity)
	{
		//
		// Size is larger then what's left of the file
		//
		return false;
	}

	return true;

} // ACpValidAllocatorHeaderExpress


////////////////////////////////////////////////////////////////////////////
//
// CPacket dump routines
//

NTSTATUS CPacket::Dump() const
/*++

Routine Description:

    Dump packet content.

Arguments:

    None.

Return Value:

    Status.

--*/
{
    //
    // Prepare buffers for packet properties
    //

    CACReceiveParameters ReceiveParams;
    CACMessageProperties * pMsgProps = &ReceiveParams.MsgProps;

    ULONG ulResponseFormatNameLen                 = MQ_MAX_Q_NAME_LEN;
	AP<WCHAR> pResponseFormatName                 = new WCHAR[ulResponseFormatNameLen];
	ReceiveParams.ppResponseFormatName            = &pResponseFormatName;
    ReceiveParams.pulResponseFormatNameLenProp    = &ulResponseFormatNameLen;

    ULONG ulAdminFormatNameLen                    = MQ_MAX_Q_NAME_LEN;
    AP<WCHAR> pAdminFormatName                    = new WCHAR[ulAdminFormatNameLen];
	ReceiveParams.ppAdminFormatName               = &pAdminFormatName;
    ReceiveParams.pulAdminFormatNameLenProp       = &ulAdminFormatNameLen;

    ULONG ulDestFormatNameLen                     = MQ_MAX_Q_NAME_LEN;
    AP<WCHAR> pDestFormatName                     = new WCHAR[ulDestFormatNameLen];
    ReceiveParams.ppDestFormatName                = &pDestFormatName;
    ReceiveParams.pulDestFormatNameLenProp        = &ulDestFormatNameLen;

    ULONG ulOrderingFormatNameLen                 = MQ_MAX_Q_NAME_LEN;
    AP<WCHAR> pOrderingFormatName                 = new WCHAR[ulOrderingFormatNameLen];
    ReceiveParams.ppOrderingFormatName            = &pOrderingFormatName;
    ReceiveParams.pulOrderingFormatNameLenProp    = &ulOrderingFormatNameLen;

    ULONG ulDestMqfLen                            = 2000;
    AP<WCHAR> pDestMqf                            = new WCHAR[ulDestMqfLen];
    ReceiveParams.ppDestMqf                       = &pDestMqf;
    ReceiveParams.pulDestMqfLenProp               = &ulDestMqfLen;
    
    ULONG ulAdminMqfLen                           = 2000;
    AP<WCHAR> pAdminMqf                           = new WCHAR[ulAdminMqfLen];
    ReceiveParams.ppAdminMqf                      = &pAdminMqf;
    ReceiveParams.pulAdminMqfLenProp              = &ulAdminMqfLen;
    
    ULONG ulResponseMqfLen                        = 2000;
    AP<WCHAR> pResponseMqf                        = new WCHAR[ulResponseMqfLen];
    ReceiveParams.ppResponseMqf                   = &pResponseMqf;
    ReceiveParams.pulResponseMqfLenProp           = &ulResponseMqfLen;
    
    ULONG ulBodySize                              = 4*1024*1024;
    AP<UCHAR> puBody                              = new UCHAR[ulBodySize];
    pMsgProps->ppBody                          = &puBody;
    pMsgProps->pBodySize                       = &ulBodySize;
    pMsgProps->ulBodyBufferSizeInBytes         = ulBodySize * sizeof(ULONG);
    pMsgProps->ulAllocBodyBufferInBytes        = ulBodySize * sizeof(ULONG);

    ULONG ulBodyType                              = 0;
    pMsgProps->pulBodyType                     = &ulBodyType;

    ULONG ulTitleSize                             = MQ_MAX_MSG_LABEL_LEN;
	AP<WCHAR> pTitle                              = new WCHAR[ulTitleSize];
	pMsgProps->ppTitle                         = &pTitle;
	pMsgProps->pulTitleBufferSizeInWCHARs      = &ulTitleSize;
	pMsgProps->ulTitleBufferSizeInWCHARs       = ulTitleSize;

    ULONG ulSenderIdLen                           = 2000;
	AP<UCHAR> puSenderId                          = new UCHAR[ulSenderIdLen];
    pMsgProps->ppSenderID                      = &puSenderId;
    pMsgProps->pulSenderIDLenProp              = &ulSenderIdLen;
    pMsgProps->uSenderIDLen                    = static_cast<USHORT>(ulSenderIdLen);

    ULONG ulSenderIdType                          = 0;
    pMsgProps->pulSenderIDType                 = &ulSenderIdType;

    ULONG ulSenderCertLen                         = 2000;
	AP<UCHAR> puSenderCert                        = new UCHAR[ulSenderCertLen];
    pMsgProps->ppSenderCert                    = &puSenderCert;
    pMsgProps->ulSenderCertLen                 = ulSenderCertLen;
    pMsgProps->pulSenderCertLenProp            = &ulSenderCertLen;

    ULONG ulProvNameLen                           = 2000;
    AP<WCHAR> pProvName                           = new WCHAR[ulProvNameLen]; 
	pMsgProps->ppwcsProvName                   = &pProvName;
	pMsgProps->ulProvNameLen                   = ulProvNameLen;
	pMsgProps->pulAuthProvNameLenProp          = &ulProvNameLen;

    ULONG ulProvType                              = 0;
    pMsgProps->pulProvType                     = &ulProvType;

    ULONG ulSymmKeysSize                          = 2000;
	pMsgProps->pulSymmKeysSizeProp             = &ulSymmKeysSize;
	pMsgProps->ulSymmKeysSize                  = ulSymmKeysSize;

	ULONG ulSignatureSize                         = 2000;
	pMsgProps->pulSignatureSizeProp            = &ulSignatureSize;
	pMsgProps->ulSignatureSize                 = ulSignatureSize;

	ULONG ulMsgExtensionSize                      = 4*1024*1024;
    AP<UCHAR> puMsgExtension                      = new UCHAR[ulMsgExtensionSize];
	pMsgProps->ppMsgExtension                  = &puMsgExtension;
	pMsgProps->pMsgExtensionSize               = &ulMsgExtensionSize;
	pMsgProps->ulMsgExtensionBufferInBytes     = ulMsgExtensionSize;

    AP<UCHAR> puCorrelationId                     = new UCHAR[2000];
    pMsgProps->ppCorrelationID                 = &puCorrelationId;

	ULONG ulSentTime                              = 0;
    pMsgProps->pSentTime                       = &ulSentTime;

    ULONG ulArrivedTime                           = 0;
    pMsgProps->pArrivedTime                    = &ulArrivedTime;

    ULONG ulRelativeTimeToQueue                   = 0;
    ULONG ulRelativeTimeToLive                    = 0;
	pMsgProps->pulRelativeTimeToQueue          = &ulRelativeTimeToQueue;
	pMsgProps->pulRelativeTimeToLive           = &ulRelativeTimeToLive;

    ULONG ulApplicationTag                        = 0;
    pMsgProps->pApplicationTag                 = &ulApplicationTag;

    ULONG ulPrivLevel                             = 0;
    pMsgProps->pulPrivLevel                    = &ulPrivLevel;

    ULONG ulHashAlg                               = 0;
    pMsgProps->pulHashAlg                      = &ulHashAlg;

    ULONG ulEncryptAlg                            = 0;
    pMsgProps->pulEncryptAlg                   = &ulEncryptAlg;

    UCHAR uTrace                                  = 0;
	pMsgProps->pTrace                          = &uTrace;

	UCHAR uAcknowledge                            = 0;
    pMsgProps->pAcknowledge                    = &uAcknowledge;

	USHORT usClass                                = 0;
    pMsgProps->pClass                          = &usClass;

	OBJECTID MessageId;
	OBJECTID * pMessageId                         = &MessageId;
	pMsgProps->ppMessageID                     = &pMessageId;

    const ULONG x_SrmpEnvelopeBufferSizeInWCHARs = 4 * 1024;
    ULONG SrmpEnvelopeSizeInWCHARs = x_SrmpEnvelopeBufferSizeInWCHARs;
    AP<WCHAR> pSrmpEnvelope = new WCHAR[x_SrmpEnvelopeBufferSizeInWCHARs];
    pMsgProps->pSrmpEnvelopeBufferSizeInWCHARs = &SrmpEnvelopeSizeInWCHARs;
    pMsgProps->ppSrmpEnvelope = &pSrmpEnvelope;

    const ULONG x_CompoundMessageBufferSizeInBytes = 4 * 1024 * 1024;
    ULONG CompoundMessageSizeInBytes;
    AP<UCHAR> pCompoundMessage = new UCHAR[x_CompoundMessageBufferSizeInBytes];
    pMsgProps->CompoundMessageSizeInBytes = x_CompoundMessageBufferSizeInBytes;
    pMsgProps->pCompoundMessageSizeInBytes = &CompoundMessageSizeInBytes;
    pMsgProps->ppCompoundMessage = &pCompoundMessage;

    const CAccessibleBlock * pab = QmAccessibleBuffer();
                                      
    //
    // Fill up properties
    //
    NTSTATUS rc = GetProperties(&ReceiveParams);
    if(!NT_SUCCESS(rc))
    {
        printf("\n\nGetProperties() parse error, packet offset = %p (0x%p)\n", pab, pab);
        return rc;
    }

    //
    // Dump all packet headers except Property, MQF, SRMP
    //
    DupDumpPacketHeaders(pab);


    //
    // Dump packet Property header
    //

    printf("\nPacket Property Section:\n");
    
    printf("\tPROPID_M_RESP_QUEUE_LEN      = %u\n", ulResponseFormatNameLen);
    if (ulResponseFormatNameLen > 0)
    {
        wprintf(L"\tPROPID_M_RESP_QUEUE          = %s\n", pResponseFormatName);
    }

    printf("\tPROPID_M_ADMIN_QUEUE_LEN     = %u\n", ulAdminFormatNameLen);
    if (ulAdminFormatNameLen > 0)
    {
        wprintf(L"\tPROPID_M_ADMIN_QUEUE         = %s\n", pAdminFormatName);
    }
    
    printf("\tPROPID_M_DEST_QUEUE_LEN      = %u\n", ulDestFormatNameLen);
    if (ulDestFormatNameLen > 0)
    {
        wprintf(L"\tPROPID_M_DEST_QUEUE          = %s\n", pDestFormatName);
    }
    
    printf("\tORDERING FORMAT NAME LEN     = %u\n", ulOrderingFormatNameLen);
    if (ulOrderingFormatNameLen > 0)
    {
        wprintf(L"\tORDERING FORMAT NAME         = %s\n", pOrderingFormatName);
    }
    
    DupDumpPropertyClass(usClass);

    DupDumpPropertyAcknowledge(uAcknowledge);

    if (ulSentTime == INFINITE)
    {
        wprintf(L"\tPROPID_M_SENTTIME            = (0x%x) %s", ulSentTime, L"Infinite\n");
    }
    else
    {
        printf("\tPROPID_M_SENTTIME            = (0x%x) %s", ulSentTime, 
                                                         ctime((time_t*)(&ulSentTime)));
    }

    if (ulArrivedTime == INFINITE)
    {
        wprintf(L"\tPROPID_M_ARRIVEDTIME         = (0x%x) %s", ulArrivedTime, L"Infinite\n");
    }
    else
    {
        printf("\tPROPID_M_ARRIVEDTIME         = (0x%x) %s", ulArrivedTime, 
                                                         ctime((time_t*)(&ulArrivedTime)));
    }

    printf("\tPROPID_M_APPSPECIFIC         = 0x%x\n", ulApplicationTag);
    
    if (ulRelativeTimeToQueue == INFINITE)
    {
        printf("\tPROPID_M_TIME_TO_REACH_QUEUE = Infinite\n");
    }
    else
    {
        printf("\tPROPID_M_TIME_TO_REACH_QUEUE = %u\n", ulRelativeTimeToQueue);
    }
    
    if (ulRelativeTimeToLive == INFINITE)
    {
        printf("\tPROPID_M_TIME_TO_BE_RECEIVED = Infinite\n");
    }
    else
    {
        printf("\tPROPID_M_TIME_TO_BE_RECEIVED = %u\n", ulRelativeTimeToLive);
    }
    
    printf("\tPROPID_M_TRACE               = 0x%x\n", uTrace);
    printf("\tPROPID_M_PRIV_LEVEL          = 0x%x\n", ulPrivLevel);
    printf("\tPROPID_M_HASH_ALG            = 0x%x\n", ulHashAlg);
    printf("\tPROPID_M_ENCRYPTION_ALG      = 0x%x\n", ulEncryptAlg);
    
    DupDumpPropertyMsgId(pMessageId);
    
    DupDumpPropertyCorrelationId(puCorrelationId);

    printf("\tPROPID_M_SENDERID_TYPE       = 0x%x\n", ulSenderIdType);
    printf("\tPROPID_M_SENDERID_LEN        = %u\n",   ulSenderIdLen);
    if (ulSenderIdLen > 0)
    {
        DupDumpPropertySenderId(puSenderId);
    }

    printf("\tPROPID_M_SENDER_CERT_LEN     = %u\n", ulSenderCertLen);

    DupDumpPropertySenderCert(puSenderCert, ulSenderCertLen);

    printf("\tPROPID_M_PROV_TYPE           = 0x%x\n", ulProvType);

    printf("\tPROPID_M_PROV_NAME_LEN       = %u\n",   ulProvNameLen);
    if (ulProvNameLen > 0)
    {
        wprintf(L"\tPROPID_M_PROV_NAME       = %s\n",   pProvName);
    }
    
    printf("\tPROPID_M_DEST_SYMM_KEY_LEN   = %u\n", ulSymmKeysSize);
    
    printf("\tPROPID_M_SIGNATURE_LEN       = %u\n", ulSignatureSize);
    
    printf("\tPROPID_M_EXTENSION_LEN       = %u\n", ulMsgExtensionSize);
    if (ulMsgExtensionSize > 0)
    {
        DupDumpPropertyMsgExtension(puMsgExtension, ulMsgExtensionSize);
    }

    printf("\tPROPID_M_LABEL_LEN           = %u\n", ulTitleSize);
    if (ulTitleSize > 0)
    {
        wprintf(L"\tPROPID_M_LABEL               = %s\n", pTitle);
    }
    
    printf("\tPROPID_M_BODY_TYPE           = 0x%x\n", ulBodyType);

    printf("\tPROPID_M_BODY_SIZE           = %u\n",   ulBodySize);
    if (ulBodySize > 0)
    {
        DupDumpPropertyBody(puBody, ulBodySize);
    }

    //
    // Dump packet MQF header
    //

    printf("\nPacket MQF Section:\n");
    
    printf("\tPROPID_M_DEST_FORMAT_NAME_LEN = %u\n", ulDestMqfLen);
    if (ulDestMqfLen > 0)
    {
        wprintf(L"\tPROPID_M_DEST_FORMAT_NAME    = %s\n", pDestMqf);
    }
    
    printf("\tPROPID_M_ADMIN_FORMAT_NAME_LEN = %u\n", ulAdminMqfLen);
    if (ulAdminMqfLen > 0)
    {
        wprintf(L"\tPROPID_M_ADMIN_FORMAT_NAME   = %s\n", pAdminMqf);
    }
    
    printf("\tPROPID_M_RESP_FORMAT_NAME_LEN = %u\n", ulResponseMqfLen);
    if (ulResponseMqfLen > 0)
    {
        wprintf(L"\tPROPID_M_RESP_FORMAT_NAME    = %s\n", pResponseMqf);
    }

    //
    // Dump packet SRMP header
    //

    printf("\nPacket SRMP Section:\n");

    printf("\tPROPID_M_SOAP_ENVELOPE_LEN = %u\n", SrmpEnvelopeSizeInWCHARs);
    if (SrmpEnvelopeSizeInWCHARs > 0)
    {
        //
        // TODO: dump SRMP envelope
        //
        NULL;
    }
    
    printf("\tPROPID_M_COMPOUND_MESSAGE_SIZE = %u\n", CompoundMessageSizeInBytes);
    if (CompoundMessageSizeInBytes > 0)
    {
        //
        // TODO: dump compund message
        //
        NULL;
    }
    
	return STATUS_SUCCESS;

} // CPacket::Dump


////////////////////////////////////////////////////////////////////////////
//
// CPoolAllocator dump routines
//

VOID
CPoolAllocator::RestoreExpressPackets(
    LPCWSTR pwzFileName
    )
/*++

Routine Description:

    Based on CPoolAllocaotr::RestorePackets.

Arguments:

    pwzFileName - The storage file to dump.

Return Value:

    None.

--*/
{
    AP<WCHAR> pPath = CreatePath(pwzFileName);
    if(pPath == 0)
    {
        return;
    }

    CMMFAllocator* pAllocator = CMMFAllocator::Create(this, pPath);
    if(pAllocator == 0)
    {
        return;
    }

    pAllocator->RestoreExpressPackets();

} // CPoolAllocator::RestoreExpressPackets


////////////////////////////////////////////////////////////////////////////
//
// CMMFAllocator dump routines
//

VOID
CMMFAllocator::RestoreExpressPackets(
    VOID
    )
/*++

Routine Description:

    Based on CMMFAllocator::RestorePackets.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG ixStart = 0;
    const ULONG ixEnd = m_ulTotalSize / x_express_granularity;
    for(;;)
    {
		ULONG ixPacket;

        NTSTATUS rc = FindValidExpressPacket(ixStart, ixEnd, ixPacket);
        if(!NT_SUCCESS(rc))
        {
            return;
        }

        if(ixPacket > ixEnd)
        {
            ixPacket = ixEnd;
        }

        if(ixPacket == ixEnd)
        {
            return;
        }

        CAllocatorBlockOffset abo = ACpIndex2BlockOffsetExpress(ixPacket);

        CAccessibleBlock* pab = GetQmAccessibleBuffer(abo);

		if(!ACpValidAllocatorHeaderExpress(pab, ixStart, ixEnd))
			return;

        ixStart = ixPacket + (pab->m_size / x_express_granularity);

        CPacket::Restore(this, abo);
    }
} // CMMFAllocator::RestoreExpressPackets


NTSTATUS 
CMMFAllocator::FindValidExpressPacket(
    ULONG ixStart, 
    ULONG ixEnd, 
    ULONG &ixPacket
    )
/*++

Routine Description:

    Based on CMMFAllocator::FindValidPacket.

Arguments:

    ixStart - Start index.

    ixEnd   - End index.

    ixPacket - On output, index of valid express packet.

Return Value:

    NTSTATUS code.

--*/
{
	ixPacket = ixStart;

	for(;ixStart < ixEnd; ixStart++)
	{
        CAllocatorBlockOffset abo = ACpIndex2BlockOffsetExpress(ixStart);

		CAccessibleBlock* pab = GetQmAccessibleBuffer(abo);

		if(ACpValidAllocatorHeaderExpress(pab, ixStart, ixEnd))
        {
            CPacketBuffer* ppb = reinterpret_cast<CPacketBuffer*>(pab);
            
            if(ppb->SignatureIsValid())
            {
                break;
            }
        }
	}

	ixPacket = ixStart;
	return STATUS_SUCCESS;

} // CMMFAllocator::FindValidExpressPacket


//
// Reporting routine
//
void ReportBadPacket(ULONG ulPacket, ULONG ulByte, ULONG ulBit, ULONG ulOffset)
{
	if (g_fDumpRestoreMaximum)
    {
    	fprintf(g_fFixFile, "%x %x %x %x\n", ulPacket, ulByte, ulBit, ulOffset);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\heap.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    heap.cxx

Abstract:

    AC heaps

Author:

    Erez Haba (erezh) 13-Apr-1996

Environment:

    Kernel mode

Revision History:

    Shai Kariv  (shaik)  11-Apr-2000     Modify for MMF dynamic mapping.
    Milena Salman (msalman) 16-Aug-2001  Modify for improving performance of allocation

--*/

#include "internal.h"
#include "data.h"
#include "qm.h"
#include <wchar.h>
#include "acp.h"
#include "heap.h"
#include "actempl.h"
#include "packet.h"
#include "dump.h"
#include <strsafe.h>

#ifndef MQDUMP
#include "heap.tmh"
#endif

#ifdef MQDUMP
extern bool  g_fDumpRestoreMaximum;
extern FILE *g_fFixFile;
extern void ReportBadPacket(ULONG ulPacket, ULONG ulByte, ULONG ulBit, ULONG ulOffset);
#endif
//---------------------------------------------------------
//
//  class CFreeBlockEntry
//
//  Naming convention: 'pfe' - pointer to free entry
//
//  A tree entry represening heap free block.
//
//---------------------------------------------------------
class CFreeBlockEntry {
public:
    CFreeBlockEntry(CAllocatorBlockOffset abo, ULONG size);

    static int  __cdecl Compare(PVOID, PVOID);
    static void __cdecl Delete(PVOID);

public:
    CAllocatorBlockOffset m_abo;
    ULONG m_size;
};


inline CFreeBlockEntry::CFreeBlockEntry(CAllocatorBlockOffset abo, ULONG size) :
    m_abo(abo),
    m_size(size)
{
}


int __cdecl CFreeBlockEntry::Compare(PVOID p1, PVOID p2)
/*++

Routine Description:

    Compare two CFreeBlockEntry entries by evaluating their block offsets.

Arguments:

    p1 - Pointer to a CFreeBlockEntry object.

    p2 - Pointer to a CFreeBlockEntry object.

Return Value:

    Positive integer - p1 > p2.
    Negative integet - p1 < p2.
    Zero             - p1 = p2.

--*/
{
    CFreeBlockEntry* pfe1 = static_cast<CFreeBlockEntry*>(p1);
    CFreeBlockEntry* pfe2 = static_cast<CFreeBlockEntry*>(p2);

    return (pfe1->m_abo.m_offset - pfe2->m_abo.m_offset);

} // CFreeBlockEntry::Compare


void __cdecl CFreeBlockEntry::Delete(PVOID p)
{
    delete static_cast<CFreeBlockEntry*>(p);
}


//---------------------------------------------------------
//
//  class CMMFAllocator
//
//---------------------------------------------------------
CMMFAllocator* CMMFAllocator::sm_pMappedAllocator = 0;

inline CMMFAllocator::CMMFAllocator(
    CPoolAllocator* pOwner,
    PVOID pSection,
    PWCHAR pFileName,
    ULONG size
    ) :
    m_ulTotalSize(size),
    m_ulFreeSize(0),
    m_FreeBlocks(0, CFreeBlockEntry::Compare, CFreeBlockEntry::Delete),
    m_pOwner(pOwner),
    m_pFileName(pFileName),
    m_pSection(pSection),
    m_pQMBase(0),
    m_pACBase(0),
    m_pPingPong(0),
    m_hBitmapFile(0),
    m_pBitmapFileName(0),
	m_nOutstandingStorages(0),
    m_nBufferReference(0),
    m_ulMinNonAvailSize(size+1),
    m_pCurrentFreeBlock(0)
{
    PutFreeBlock(0, size);
}


inline BOOL CMMFAllocator::IsUsed() const
{
    return (m_ulFreeSize < m_ulTotalSize);
}


inline BOOL CMMFAllocator::IsDestroyed() const
{
    return (m_pSection == 0);
}


CFreeBlockEntry* CMMFAllocator::GetFreeBlock(ULONG size)
{
    
    if (size >= m_ulMinNonAvailSize) 
    {
        //
        //  One of previous allocations failed for smaller size.
        //  There are no such size in this allocator. Don't look here.
        //
        return 0;
    }


    CAVLTreeCursor c;
    CFreeBlockEntry* pStart=0;
    
    if (m_pCurrentFreeBlock != 0)
    {
        //
        //NOTE: if m_pCurrentFreeBlock is invalid pointer (this happens during recovery) pStart will get 0
        // DO NOT change this line to pStart=m_pCurrentFreeBlock !! 
        //
        m_FreeBlocks.SetCursor(m_pCurrentFreeBlock, &c, (PVOID*)&pStart);
    }
    else
    {
        m_FreeBlocks.SetCursor(POINT_TO_SMALLEST, &c, (PVOID*)&pStart);
    }

    //
    // Perform "next fit": search from current pointer till the end of MMF
    //
    
    CFreeBlockEntry* pfe = FindFreeBlock(size, pStart, 0);
    if (pfe != 0)
    {
        return pfe;
    }
    
    //
    // search from the beginning of MMF till current pointer
    //

    pfe = FindFreeBlock(size, POINT_TO_SMALLEST, pStart);
    if (pfe != 0)
    {
        return pfe;
    }
    //
    // Allocation failed. Search from the begining of the MMF file next time.
    // Remember the size that was not available to speed-up futher allocations.  
    //

    m_pCurrentFreeBlock = 0;
    m_ulMinNonAvailSize = size;
    
    return 0;
}


CFreeBlockEntry* CMMFAllocator::FindFreeBlock(ULONG size, PVOID pStart, PVOID pEnd)
{ 
   CAVLTreeCursor c;   
    
   CFreeBlockEntry* pfe=0;

    
    for(  m_FreeBlocks.SetCursor(pStart, &c, (PVOID*)&pfe);
          pfe != pEnd; 
          m_FreeBlocks.GetNext(&c, (PVOID*)&pfe))
    {
        ASSERT(pfe);
        if(size == pfe->m_size)
        {
            m_FreeBlocks.GetNext(&c, (PVOID*)&m_pCurrentFreeBlock);
            return pfe;
        }
        if(size < pfe->m_size)
        {
            m_pCurrentFreeBlock = pfe;
            return pfe;
        }
    }
    return 0;
}




void CMMFAllocator::PutFreeBlock(CAllocatorBlockOffset abo, ULONG size)
{
    ULONG NewFreeSize = size;
    m_ulFreeSize += size;

    CFreeBlockEntry* pfe = new (PagedPool, NormalPoolPriority) CFreeBlockEntry(abo, size);

    if(pfe == 0)
    {
        //
        //  Failed to allocate free block entry, just return and add nothing to
        //  the free list tree. The free size of the block will grow but it'll never
        //  succeed to allocate this block again. eventualy this pool will be freed
        //  thus regaining the lost memory.
        //
    	TrWARNING(AC, "Failed to allocate a CFreeBlockEntry from paged pool."); 
        return;
    }

    CAVLTreeCursor c;
    if(!m_FreeBlocks.AddNode(pfe, &c))
    {
        delete pfe;
        return;
    }

    CFreeBlockEntry* pNeighbor;

    //
    //  See if we can combine the free block with the free block before it
    //
    CAVLTreeCursor c_tmp = c;
    if(m_FreeBlocks.GetPrev(&c_tmp, (PVOID*)&pNeighbor) &&
        ((pNeighbor->m_abo.m_offset + pNeighbor->m_size) == abo.m_offset))
    {
        //
        //  Yes, enlarge the free block before the block and delete the current
        //  free block from the free blocks tree.
        //
        pNeighbor->m_size += size;

        NewFreeSize = pNeighbor->m_size;
        m_FreeBlocks.DelNode(pfe);
        delete pfe;

        //
        // Re-new the tree cursor
        //
        m_FreeBlocks.SetCursor(pNeighbor, &c, (PVOID*)&pfe);
    }

    //
    // See if we can combine the free block with the free block after it
    //
    if (m_FreeBlocks.GetNext(&c, (PVOID*)&pNeighbor) &&
        ((pfe->m_abo.m_offset + pfe->m_size)  == pNeighbor->m_abo.m_offset))
    {
        //
        // Yes, enlarge the current free block and free the free block that is
        // after this block.
        //
        pfe->m_size += pNeighbor->m_size;
        NewFreeSize = pfe->m_size;

        //
        // If needed update pointer for "next fit"
        //
        if(pNeighbor == m_pCurrentFreeBlock)
        {
            m_pCurrentFreeBlock = pfe;
        }

        m_FreeBlocks.DelNode(pNeighbor);
        delete pNeighbor;
    }

    if (NewFreeSize >= m_ulMinNonAvailSize)
    {
        //
        // All the blocks in the tree were smaller than  m_ulMinNonAvailSize, 
        // therefore NewFreeSize is the biggest size in the tree. 
        // That is the size NewFreeSize+1 is not available. Remeber this to speed-up futher allocations.
        //
        m_ulMinNonAvailSize = NewFreeSize + 1;
    }
}


inline void CMMFAllocator::MarkUsed()
{
    CFreeBlockEntry* pfe;
    while((pfe = GetFreeBlock(0)) != 0)
    {
        m_FreeBlocks.DelNode(pfe);
        delete pfe;
    }

    m_ulFreeSize = 0;
}


CAllocatorBlockOffset CMMFAllocator::malloc(ULONG size, CMMFAllocator** ppAllocator)
{
    ASSERT(size != 0);

    if(size > m_ulFreeSize)
    {
        //
        //  Not enogh memory in this heap
        //
        return CAllocatorBlockOffset::InvalidValue();
    }

    CFreeBlockEntry* pfe = GetFreeBlock(size);
    if(pfe == 0)
    {
        //
        //  No large enogh block in this heap
        //
        
        return CAllocatorBlockOffset::InvalidValue();
    }

    CAllocatorBlockOffset abo = pfe->m_abo;

    CAccessibleBlock* pab = GetAccessibleBuffer(abo);
    if (pab == 0)
    {
        //
        //  Failed to map to QM process address space
        //
        return CAllocatorBlockOffset::InvalidValue();
    }

    pab->m_size = size;

    if(pfe->m_size == size)
    {
        m_FreeBlocks.DelNode(pfe);
        delete pfe;
    }
    else
    {
        pfe->m_abo.m_offset += size;
        pfe->m_size  -= size;
    }

    m_ulFreeSize -= size;

    *ppAllocator = this;
    return abo;
}


void CMMFAllocator::free(CAllocatorBlockOffset abo)
{
    ASSERT(abo.IsValidOffset());

    if(IsDestroyed())
        return;

    CAccessibleBlock* pab = GetAccessibleBuffer(abo);
    if (pab == 0)
    {
        //
        //  BUGBUG: Resource leak in free, can't map to system address space,
        //          and don't know size of packet
        //
        return;
    }

    ULONG size = pab->m_size;
    m_pOwner->RestoreQuota(size);

    #ifdef _DEBUG
        if(m_pPingPong != 0)
        {
            ULONG BlockLastBit = ((abo.m_offset + size) / x_persist_granularity) - 1;
            ULONG BitmapFirstBit = m_pPingPong->FindBit(abo.m_offset / x_persist_granularity);
            ASSERT(BlockLastBit < BitmapFirstBit);
        }
       	memset(pab, 0xff, sizeof(CPacketBuffer));
    #endif

    PutFreeBlock(abo, size);

    if(!IsUsed())
    {
        m_pOwner->FreeHeap(this);
    }
}


static void ACpDeleteFile(PWCHAR pFileName)
{
    UNICODE_STRING uszFileName;
    RtlInitUnicodeString(
        &uszFileName,
        pFileName
        );

    OBJECT_ATTRIBUTES oa;
    InitializeObjectAttributes(
        &oa,
        &uszFileName,
        OBJ_CASE_INSENSITIVE,
        0,
        0
        );

    ZwDeleteFile(&oa);
}


void CMMFAllocator::Destroy()
{
    if((g_pQM->Process() != 0) && (m_pQMBase != 0))
    {
        MmUnmapViewOfSection(g_pQM->Process(), m_pQMBase);
    }
    m_pQMBase = 0;

    if(m_pACBase != 0)
    {
        UnmapACView();
    }

    if(m_pSection != 0)
    {
        ACpCloseSection(m_pSection);
        m_pSection = 0;
    }

    if(m_hBitmapFile != 0)
    {
    	ZwClose(m_hBitmapFile);
    }
    m_hBitmapFile = 0;

    if(!IsUsed())
    {
        if(m_pFileName != 0)
        {
            ACpDeleteFile(m_pFileName);
        }

        if(m_pBitmapFileName != 0)
        {
            ACpDeleteFile(m_pBitmapFileName);
        }
    }

    delete[] m_pBitmapFileName;
    m_pBitmapFileName = 0;

    delete m_pPingPong;
    m_pPingPong = 0;

    delete[] m_pFileName;
    m_pFileName = 0;

    m_pOwner = 0;
}


inline CMMFAllocator::~CMMFAllocator()
{
    Destroy();
}


void CMMFAllocator::UnmapACView()
{
    ASSERT(m_pACBase != 0);
    ASSERT(sm_pMappedAllocator == this);

    NTSTATUS rc;
    rc = MmUnmapViewInSystemSpace(m_pACBase);
    ASSERT(NT_SUCCESS(rc));

    m_pACBase = 0;
    sm_pMappedAllocator = 0;

	if(m_nOutstandingStorages == 0)
	{
		MarkCoherent();
	}
}


inline NTSTATUS CMMFAllocator::MapACView()
{
    ASSERT(m_pACBase == 0);
    ASSERT(sm_pMappedAllocator == 0);

    //
    //  Map the section to system space.
    //
    PVOID ACViewBase = m_pQMBase;
    ULONG_PTR ACViewSize = 0;
    NTSTATUS rc;
    rc = MmMapViewInSystemSpace(
            m_pSection,
            &ACViewBase,
            &ACViewSize
            );

    if(!NT_SUCCESS(rc))
    {
        TrERROR(AC, "Failed to map MMF to system space, status 0x%x", rc);
        return rc;
    }

    ASSERT(m_ulTotalSize == ACViewSize);
    m_pACBase = ACViewBase;
    sm_pMappedAllocator = this;

    return STATUS_SUCCESS;
}


CAccessibleBlock* 
CMMFAllocator::GetQmAccessibleBufferNoMapping(
    CAllocatorBlockOffset abo
    ) const
/*++

Routine Description:

    Return an accessible address of the buffer in QM process address space.
    This routine assumes that this MMF is mapped to QM process.
    Note that the current process is not necessarily the QM (e.g. issue ack).

Arguments:

    abo - Offset of the buffer.

Return Value:

    An accessible address of the buffer in QM process address space.

--*/
{
    //
    // Offset must be valid here
    //
    ASSERT(abo.IsValidOffset());

    if(IsDestroyed())
        return NULL;

    //
    // This MMF must be mapped to QM process at this point
    //
    ASSERT(m_pQMBase != 0);

    //
    // Add the offset to the base address of the mapping.
    //
    return reinterpret_cast<CAccessibleBlock*>(
            reinterpret_cast<PCHAR>(m_pQMBase) + abo.m_offset);

} // GetQmAccessibleBufferNoMapping


CAccessibleBlock* 
CMMFAllocator::GetAcAccessibleBufferNoMapping(
    CAllocatorBlockOffset abo
    ) const
/*++

Routine Description:

    Return an accessible address of the buffer in AC process address space.
    This routine assumes that this MMF is mapped to AC process.

Arguments:

    abo - Offset of the buffer.

Return Value:

    An accessible address of the buffer in AC process address space.

--*/
{
    //
    // Offset must be valid here
    //
    ASSERT(abo.IsValidOffset());

    if(IsDestroyed())
        return NULL;

    //
    // This MMF must be mapped to AC process at this point
    //
    ASSERT(m_pACBase != 0);

    //
    // Add the offset to the base address of the mapping.
    //
    return reinterpret_cast<CAccessibleBlock*>(
            reinterpret_cast<PCHAR>(m_pACBase) + abo.m_offset);

} // GetAcAccessibleBufferNoMapping


CAccessibleBlock* CMMFAllocator::GetQmAccessibleBuffer(CAllocatorBlockOffset abo)
/*++

Routine Description:

    Return an accessible address of the buffer in QM process address space or
    NULL if no accessible address.
    First map this MMF to QM process.
    Note that the current process is not necessarily the QM (e.g. issue ack).

Arguments:

    abo - Offset of the buffer.

Return Value:

    An accessible address of the buffer in QM process address space or NULL if no
    accessible address.

--*/
{
    //
    // Offset must be valid here
    //
    ASSERT(abo.IsValidOffset());

    if(IsDestroyed())
        return NULL;

    //
    // Map this MMF to QM address space
    //
    NTSTATUS rc = MapQmViewWithRetry();
    if (!NT_SUCCESS(rc))
    {
        return NULL;
    }

    //
    // This MMF is mapped to QM process. Get the address.
    //
    return GetQmAccessibleBufferNoMapping(abo);

} // CMMFAllocator::GetQmAccessibleBuffer


CAccessibleBlock* CMMFAllocator::GetMappedBuffer(CAllocatorBlockOffset abo) const
/*++

Routine Description:

    Return an accessible address of the current mapped buffer in QM process address space or
    kernel address space. IT DOES NOT mapped the buffer if it is unmapped

Arguments:

    abo - Offset of the buffer.

Return Value:

    An accessible address of the buffer in QM or AC address space, or NULL if the
    buffer is not mapped.

--*/

{
	if(IoGetCurrentProcess() == g_pQM->Process())
	{
		return GetQmAccessibleBufferNoMapping(abo);
	}
	else
	{
		return GetAcAccessibleBufferNoMapping(abo);
	}
} // CMMFAllocator::GetMappedBuffer

    
CAccessibleBlock* CMMFAllocator::GetAccessibleBuffer(CAllocatorBlockOffset abo)
/*++

Routine Description:

    Return an accessible address of the buffer in QM process address space or
    kernel address space.

Arguments:

    abo - Offset of the buffer.

Return Value:

    An accessible address of the buffer in QM or AC address space, or NULL if no
    accessible address.

--*/
{
    //
    // Offset must be valid here
    //
    ASSERT(abo.IsValidOffset());

    if(IsDestroyed())
        return NULL;

    //
    // Current process is QM, get an address in QM process.
    // Note that this doesn't imply that this MMF is mapped to QM.
    //
    if(IoGetCurrentProcess() == g_pQM->Process())
    {
        return GetQmAccessibleBuffer(abo);
    }

    //
    // Current process is not QM. Map this MMF to kernel space.
    //
    if(m_pACBase == 0)
    {
        if(sm_pMappedAllocator != 0)
        {
            sm_pMappedAllocator->UnmapACView();
        }
        if (!NT_SUCCESS(MapACView()))
        {
            return 0;
        }
    }

    //
    // This MMF is mapped to kernel space, get an address in kernel space.
    //
    return GetAcAccessibleBufferNoMapping(abo);
} // CMMFAllocator::GetAccessibleBuffer


static PWCHAR ACpGenerateFileName(PCWSTR pPrefix, ULONG ulIndex)
{
    //
    //  The prefix is in the form \DosDevices\c:\directory\r%07x.mq
    //  Allocating 8 more wchars to be on the safe side of the format.
    //

    ULONG len = static_cast<ULONG>(wcslen(pPrefix));
    PWCHAR pFileName = new (PagedPool) WCHAR[len + 1 + 8];
    if(pFileName == 0)
    {
       	TrERROR(AC, "Failed to allocate %d bytes from paged pool for a file name. File Name Prefix = %ls, Index = %d", 2*(len + 1 + 8), pPrefix, ulIndex); 
        return 0;
    }

    StringCchPrintf(pFileName, len+1+8, pPrefix, (ulIndex & 0x0fffffff));
   
    return pFileName;
}


static CAllocatorBlockOffset ACpIndex2BlockOffset(ULONG ix)
/*++

Routine Description:

    Convert index of persistent block to offset from base address.

Arguments:

    ix - Index of persistent block.

Return Value:

    Offset of the block.

--*/
{
    return ix * x_persist_granularity;

} // ACpIndex2BlockOffset


inline BOOL ACpValidAllocatorHeader(CAccessibleBlock *pab, ULONG ixStart, ULONG ixEnd)
{
	if(pab->m_size == 0)
	{
		//
		// Size is too small
		//
		return FALSE;
	}

	if((pab->m_size & (x_persist_granularity - 1)) != 0)
	{
		//
		// Size is not of the right granularity
		//
		return FALSE;
	}

	if(pab->m_size > (ixEnd - ixStart) * x_persist_granularity)
	{
		//
		// Size is larger then what's left of the file
		//
		return FALSE;
	}

	return TRUE;
}


NTSTATUS CMMFAllocator::RestorePackets(ULONG* pulSize)
{
    //
    // Restore allocator that is marked as used, i.e., no free blocks at all.
    //
    ASSERT(m_ulFreeSize == 0);

    ULONG ixStart = 0;
    const ULONG ixEnd = m_ulTotalSize / x_persist_granularity;
    for(;;)
    {
		ULONG ixPacket;

		if(m_pPingPong->IsCoherent())
		{
			//
			// Use bitmap
			//
			ixPacket = m_pPingPong->FindBit(ixStart);
		}
		else
		{
			//
			// Use checksum and signature information
			//
			NTSTATUS rc = FindValidPacket(ixStart, ixEnd, ixPacket);
			if(!NT_SUCCESS(rc))
			{
#ifdef MQDUMP
                printf("FindValidPacket failed with rc=%x, ixStart=%d,  ixPacket=%d, ixEnd=%d\n", rc, ixStart, ixPacket, ixEnd);
#endif
				return rc;
			}
		}

        if(ixPacket > ixEnd)
        {
            ixPacket = ixEnd;
        }

        if(ixPacket > ixStart)
        {
            //
            //  put a free block in free tree
            //
            PutFreeBlock(
                ACpIndex2BlockOffset(ixStart),
                (ixPacket - ixStart) * x_persist_granularity
                );

			//
			// We need to mark the bitmap in case it was not coherent.
			//
			m_pPingPong->FillBits(ixStart, ixPacket - ixStart, FALSE);
        }

        if(ixPacket == ixEnd)
        {
            *pulSize = m_ulTotalSize - m_ulFreeSize;
            return STATUS_SUCCESS;
        }

#ifdef MQDUMP
        printf("--------------------\n");
        printf("Packet Index %d (byte %d, bit %d, mmf 0x%x)\n", ixPacket, ixPacket /8, ixPacket % 8, ixPacket * x_persist_granularity);
#endif

        CAllocatorBlockOffset abo = ACpIndex2BlockOffset(ixPacket);

        CAccessibleBlock* pab = GetQmAccessibleBuffer(abo);
        if (pab == NULL)
            return STATUS_INSUFFICIENT_RESOURCES;

		if(!ACpValidAllocatorHeader(pab, ixStart, ixEnd))
			return STATUS_INTERNAL_DB_CORRUPTION;

        ixStart = ixPacket + (pab->m_size / x_persist_granularity);

        NTSTATUS rc = CPacket::Restore(this, abo);
        if(!NT_SUCCESS(rc))
        {
#ifndef MQDUMP
			//
			// The bitmap might not reflect the right state, but who cares.
			//
            return rc;
#else
        printf("--------------------\n");
        printf("********************Failure rc=%x\n", rc);

		ReportBadPacket(ixPacket, ixPacket /8, ixPacket % 8, ixPacket * x_persist_granularity);
#endif
        }

		//
		// We need to mark the bitmap in case it was not coherent.
		//
		m_pPingPong->FillBits(ixPacket, ixStart - ixPacket, TRUE);
    }
}

NTSTATUS CMMFAllocator::FindValidPacket(ULONG ixStart, ULONG ixEnd, ULONG &ixPacket)
{
	ixPacket = ixStart;

	for(;ixStart < ixEnd; ixStart++)
	{
        CAccessibleBlock* pab = GetQmAccessibleBuffer(ACpIndex2BlockOffset(ixStart));
        if (pab == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

		if(!ACpValidAllocatorHeader(pab, ixStart, ixEnd))
			continue;
	
		NTSTATUS rc = CPacket::CheckPacket(pab);
		if(NT_SUCCESS(rc))
		{
			//
			// Signature and checksum match
			//
			break;
		}

		if(rc == STATUS_INTERNAL_DB_CORRUPTION)
		{
			return rc;
		}
	}

	ixPacket = ixStart;
	return STATUS_SUCCESS;
}


void CMMFAllocator::AddOutstandingStorage()
{
	m_nOutstandingStorages++;
}


void CMMFAllocator::ReleaseOutstandingStorage()
{
	if(--m_nOutstandingStorages != 0)
        return;

    if(IsDestroyed())
        return;

	//
	// Write a coherent bitmap if allocator is not mapped.
	//
	if(m_pACBase == 0)
	{
		MarkCoherent();
	}
}


inline NTSTATUS CMMFAllocator::WriteCoherentBitmap() const
{
	m_pPingPong->SetCoherent();
	return WritePingPong();
}
 

void CMMFAllocator::MarkCoherent()
{
	if(!IsPersistent()) 
        return;

	if(m_pPingPong->IsCoherent())
        return;

	NTSTATUS rc = WriteCoherentBitmap();
	if(!NT_SUCCESS(rc))
	{
		m_pPingPong->SetNotCoherent();
	}
}


NTSTATUS CMMFAllocator::MarkNotCoherent()
{
	ASSERT(IsPersistent());

    if(IsDestroyed())
        return MQ_ERROR_MESSAGE_STORAGE_FAILED;

	if(m_pPingPong->IsNotCoherent())
        return STATUS_SUCCESS;

	m_pPingPong->SetNotCoherent();
	NTSTATUS rc = WritePingPong();
	if(!NT_SUCCESS(rc))
	{
		m_pPingPong->SetCoherent();
		return(rc);
	}

	return STATUS_SUCCESS;
}


CPingPong* ACpCreateBitmap(PCWSTR pLogPath, PWCHAR* ppFileName, HANDLE* phFile)
{
    //
    //  Allocate the ping pong buffer
    //
    PVOID p = new (PagedPool) CHAR[PAGE_SIZE];
    if(p == 0)
    {
    	TrERROR(AC, "Failed to allocate %d bytes for the ping pong buffer.", PAGE_SIZE); 
        return 0;
    }

    CPingPong* pPingPong = new (p) CPingPong;

    PWCHAR pFileName = ACpGenerateFileName(pLogPath, g_HeapFileNameCount);
    if(pFileName == 0)
    {
        delete pPingPong;
        return 0;
    }

    //
    //  Generate file name
    //
    UNICODE_STRING uszFileName;
    RtlInitUnicodeString(
        &uszFileName,
        pFileName
        );

    OBJECT_ATTRIBUTES oa;
    InitializeObjectAttributes(
        &oa,
        &uszFileName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        0,
        0
        );

    ACCESS_MASK access = GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE;
    ULONG       share  = FILE_SHARE_READ;
#ifdef MQDUMP
    if (g_fDumpUsingLogFile)
    {
        //
        // Mqdump should open log file for read only.
        // Unless it is its own dummy log file.
        //
        access = GENERIC_READ;
    }
    else
    {
        //
        // Mqdump uses a dummy log file. Share it.
        //
        share  = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    }
#endif // MQDUMP

    NTSTATUS rc;
    HANDLE hFile;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER liAllocationSize;
    liAllocationSize.QuadPart = PAGE_SIZE * 2;
    rc = ZwCreateFile(
            &hFile,
            access,
            &oa,
            &IoStatus,
            &liAllocationSize,
            FILE_ATTRIBUTE_NORMAL,
            share,
            FILE_OPEN_IF,
            FILE_WRITE_THROUGH |
            FILE_NO_INTERMEDIATE_BUFFERING |
            FILE_SYNCHRONOUS_IO_NONALERT,
            0,
            0
            );

    pPingPong->SetCoherent();

    if(!NT_SUCCESS(rc))
    {
        delete pPingPong;
        delete[] pFileName;
        return 0;
    }

    *ppFileName = pFileName;
    *phFile = hFile;
    return pPingPong;
}


static void ACpCleanupBitmap(CPingPong* pPingPong, PWCHAR pBitmapFileName, HANDLE hBitmapFile)
{
    ZwClose(hBitmapFile);

    //
    // ISSUE-2001/1/4-mickys if file is created in the QM process context, it must also be deleted
    // in this context
    //
    ACpDeleteFile(pBitmapFileName);

    delete[] pBitmapFileName;
    delete pPingPong;
}


inline void CMMFAllocator::SetBitmap(CPingPong* pPingPong, PWCHAR pBitmapFileName, HANDLE hBitmapFile)
{
    ASSERT(m_pPingPong == 0);
    ASSERT(m_pBitmapFileName == 0);
    ASSERT(m_hBitmapFile == 0);
    m_pPingPong = pPingPong;
    m_pBitmapFileName = pBitmapFileName;
    m_hBitmapFile = hBitmapFile;
}


inline CPingPong* CMMFAllocator::CreateBitmap(PCWSTR pLogPath)
{
    ASSERT(m_pBitmapFileName == 0);
    ASSERT(m_hBitmapFile == 0);
    ASSERT(m_pPingPong == 0);
    m_pPingPong = ACpCreateBitmap(pLogPath, &m_pBitmapFileName, &m_hBitmapFile);
    return m_pPingPong;
}


NTSTATUS CMMFAllocator::ReadPingPage(ULONG ulOffset) const
{
    ASSERT(m_pPingPong != 0);
    ASSERT(m_hBitmapFile !=0);

    NTSTATUS rc;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER liStartingOffset;
    liStartingOffset.QuadPart = ulOffset;

    //
    //  Invalidate pingpong buffer before read
    //
    m_pPingPong->Invalidate();
    rc = ZwReadFile(
            m_hBitmapFile,
            0,
            0,
            0,
            &IoStatus,
            m_pPingPong,
            PAGE_SIZE,
            &liStartingOffset,
            0
            );

	if(NT_SUCCESS(rc))
	{
		if(IoStatus.Information != PAGE_SIZE)
		{
			return STATUS_INTERNAL_DB_CORRUPTION;
		}
	}
	
    return rc;
}


NTSTATUS CMMFAllocator::ReadPingPong() const
{
    ULONG ping0 = 0;
    ULONG ping1 = 0;

    //
    //  We need to read the enire page to validte it's checksum on disk
    //
    NTSTATUS rc0;
    rc0 = ReadPingPage(0);
    if(NT_SUCCESS(rc0))
    {
        rc0 = m_pPingPong->Validate();
        ping0 = m_pPingPong->CurrentPing();
    }

    NTSTATUS rc1;
    rc1 = ReadPingPage(PAGE_SIZE);
    if(NT_SUCCESS(rc1))
    {
        rc1 = m_pPingPong->Validate();
        ping1 = m_pPingPong->CurrentPing();
    }

    if(!NT_SUCCESS(rc0))
    {
        //
        //  page 0 was bad return the status of page 1, if it was succesful or not
        //
        return rc1;
    }

    //
    //  Test if ping1 is older than ping0, number wrap 0 safe.
    //
    if(!NT_SUCCESS(rc1) || ((ping1 - ping0) == 0xffffffff))
    {
        //
        //  page 1 was bad, or page 0 is NEWER, reread page 0 and return its status
        //
        rc0 = ReadPingPage(0);
        return rc0;
    }

    //
    //  page 1 was good and newer
    //
    return rc1;
}


NTSTATUS ACpWritePingPong(CPingPong* pPingPong, HANDLE hBitmapFile)
{
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER liStartingOffset;
    liStartingOffset.QuadPart = ((pPingPong->Ping() & 1) == 0) ? PAGE_SIZE : 0;

	NTSTATUS rc;
    rc = ZwWriteFile(
            hBitmapFile,
            0,
            0,
            0,
            &IoStatus,
            pPingPong,
            PAGE_SIZE,
            &liStartingOffset,
            0
            );

	return rc;
}


inline NTSTATUS CMMFAllocator::WritePingPong() const
{
    ASSERT(m_pPingPong != 0);
    ASSERT(m_hBitmapFile != 0);

    return ACpWritePingPong(m_pPingPong, m_hBitmapFile);
}


void CMMFAllocator::BitmapUpdate(CAllocatorBlockOffset abo, ULONG size, BOOL fExists)
{
    if(IsDestroyed())
        return;
    
    m_pPingPong->FillBits(
                    abo.m_offset / x_persist_granularity,
                    size / x_persist_granularity,
                    fExists
                    );
}


CMMFAllocator* CMMFAllocator::Create(CPoolAllocator* pOwner, PCWSTR pPoolPath)
{
    //
    //  The required size must be 64k aligned
    //
    ULONG_PTR ViewSize = g_ulHeapPoolSize;
    ASSERT(ViewSize == ALIGNUP_PTR(ViewSize, X64K));

    PWCHAR pFileName = ACpGenerateFileName(pPoolPath, g_HeapFileNameCount);
    if(pFileName == 0)
    {
        return 0;
    }

    //
    //  Generate file name
    //
    UNICODE_STRING uszFileName;
    RtlInitUnicodeString(
        &uszFileName,
        pFileName
        );

    OBJECT_ATTRIBUTES oa;
    InitializeObjectAttributes(
        &oa,
        &uszFileName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        0,
        0
        );

    NTSTATUS rc;
    HANDLE hFile;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER liMaxSize;
    liMaxSize.QuadPart = ViewSize;
    rc = ZwCreateFile(
            &hFile,
            AC_GENERIC_ACCESS,
            &oa,
            &IoStatus,
            &liMaxSize,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN_IF,
            FILE_WRITE_THROUGH |
            FILE_SYNCHRONOUS_IO_NONALERT |
            FILE_NO_COMPRESSION,
            0,
            0
            );

    if(!NT_SUCCESS(rc))
    {
    	TrERROR(AC, "Failed to create MMF %ls. %!status!.", pFileName ,rc);
        goto E0;
    }

    //
    //  Create section
    //
    PVOID pSection = NULL;
    liMaxSize.QuadPart = ViewSize;

    OBJECT_ATTRIBUTES oaSection;
    InitializeObjectAttributes(
        &oaSection,
        NULL,
        OBJ_KERNEL_HANDLE,
        0,
        0
        );


	HANDLE hSection;
	rc = ZwCreateSection(
			&hSection,
			STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
			&oaSection,
			&liMaxSize,
			AC_PAGE_ACCESS,
			SEC_COMMIT,
			hFile
			);
	if(!NT_SUCCESS(rc))
	{
		TrERROR(AC, "Failed to create section for MMF %ls. %!status!.", pFileName, rc); 
	}

 	if(NT_SUCCESS(rc))
 	{
 		rc = ObReferenceObjectByHandle(
	 			hSection, 
	 			STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
	 			NULL,
				KernelMode,
				&pSection,
				NULL
				);

 		if(!NT_SUCCESS(rc))
		{
			TrERROR(AC, "Get object from handle in MMF %ls failed. %!status!.", pFileName, rc); 
		}

		#ifndef MQDUMP
 			ZwClose(hSection);
		#endif 		

 	}
    ZwClose(hFile);

    if(!NT_SUCCESS(rc))
    {
        goto E1;
    }

    //
    //  Allocate the MMF Allocator from syste paged pool.
    //
    CMMFAllocator* pAllocator;
    pAllocator = new (PagedPool) CMMFAllocator(
                                    pOwner,
                                    pSection,
                                    pFileName,
                                    UINT_PTR_TO_UINT(ViewSize)
                                    );

    if(pAllocator != 0)
    {
        return pAllocator;
    }

    TrERROR(AC, "Failed to allocate MMF Allocator for %ls from paged pool.", pFileName); 


    //
    //  Error, Do cleanup
    //
    ACpCloseSection(pSection);
E1: ZwDeleteFile(&oa);
E0: delete[] pFileName;
    return 0;
}


void CMMFAllocator::AddRefBuffer(void) const
/*++

Routine Description:

    Increment reference count to the MMF. This prevents the MMF from being
    unmapped from the QM address space,

Arguments:

    None.

Return Value:

    None.

--*/
{
    ++m_nBufferReference;  

    TrTRACE(AC, " Buffer refrence was incremented to 0x%x\n", m_nBufferReference);

} // CMMFAllocator::AddRefBuffer


void CMMFAllocator::ReleaseBuffer(void) const
/*++

Routine Description:

    Decrement reference count of the buffer. This *allows* the MMF 
    to be unmapped from the QM address space when the reference count
    reaches zero.
    When ref count is zero, unmap does not have to take place.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    --m_nBufferReference;  

    TrTRACE(AC, " Buffer refrence was decremented to 0x%x", m_nBufferReference);

    ASSERT(m_nBufferReference >= 0);

} // CMMFAllocator::ReleaseBuffer


NTSTATUS CMMFAllocator::MapQmViewNoRetry(void)
/*++

Routine Description:

    Map the MMF to the address space of the QM process.
    Managing the reference count of the QM to the MMF is the
    responsibility of the caller.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - The operation completed successfully.
    other status   - The operation failed.

--*/
{
    ASSERT(("Must not be already mapped to QM process", m_pQMBase == 0));
    ASSERT(("QM must not already have a reference to buffer", m_nBufferReference == 0));

    LARGE_INTEGER liSectionOffset;
    liSectionOffset.QuadPart = 0;

    ULONG_PTR ulSize = m_ulTotalSize;
    NTSTATUS rc;
    rc = MmMapViewOfSection(
            m_pSection,
            g_pQM->Process(),
            &m_pQMBase,
            0,
            0,
            &liSectionOffset,
            &ulSize,
            ViewUnmap,
            0,
            AC_PAGE_ACCESS
            );

    if(!NT_SUCCESS(rc))
    {
        return rc;
    } 

    ASSERT(("Start address of the mapping should be valid here", m_pQMBase != 0));
    ASSERT(("Size of mapped section should match", m_ulTotalSize == ulSize));

    TrTRACE(AC, " Succeeded to map MMF to QM view.");

   
    g_pAllocator->IncMappedNum();
    
    return STATUS_SUCCESS;

} // CMMFAllocator::MapQmViewNoRetry


void CMMFAllocator::UnmapQmView(void)
/*++

Routine Description:

    Unmap the MMF from the address space of the QM process.
    Managing the reference count of the QM to the MMF is the
    responsibility of the caller.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(("Must be currently mapped to QM process", m_pQMBase != 0));
    ASSERT(("QM must not currently have a reference to buffer", m_nBufferReference == 0));

    TrTRACE(AC, " Unmap MMF from QM view.");

    //
    // Ignore return code.
    // Failure can occur when QM process is terminating.
    // Other failures we can't really handle.
    //
    MmUnmapViewOfSection(g_pQM->Process(), m_pQMBase);

    m_pQMBase = 0;

   
    g_pAllocator->DecMappedNum();
    

} // CMMFAllocator::UnmapQmView


NTSTATUS CMMFAllocator::MapQmViewWithRetry(void)
/*++

Routine Description:

    Verify this MMF is mapped to the address space of the QM process.
    If it isn't, try to map it.
    If mapping fails due to virtual memory exhaustion in QM address space
    or low resources try to unmap unreferenced heaps and thus free memory
    resources in QM address space, then try mapping again.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - The operation completed successfully.
    other status   - The operation failed.

--*/
{
    //
    // If already mapped than this is a no-op
    //
    if (m_pQMBase != 0)
    {
        return STATUS_SUCCESS;
    }

    //
    // Try to map to QM process address space.
    //
   
    if (g_pAllocator->MappedLimitExceeded())
    {
        TrTRACE(AC, "Mapped limit exceeded (%d MMFs are currently mapped). Trying to unmap unreferenced MMFs", g_pAllocator->MappedFiles());
        g_pAllocator->UnmapUnreferencedHeaps();
    }
    
    NTSTATUS rc;
    
    rc = MapQmViewNoRetry();

    if (NT_SUCCESS(rc))
    {
        return STATUS_SUCCESS;
    }
    
    //
    // QM process address space is exhausted or low resources. Try to free memory.
    //
    TrWARNING(AC, "Map to QM failed first chance, status=0x%x", rc);
    g_pAllocator->UnmapUnreferencedHeaps();
        
    //
    // Try to map again.
    //
    rc = MapQmViewNoRetry();

    if (NT_SUCCESS(rc))
    {
        return STATUS_SUCCESS;
    }

    TrERROR(AC, "Map to QM failed second chance, status=0x%x", rc);
    return rc;

} // CMMFAllocator::MapQmViewWithRetry


inline void CMMFAllocator::UnmapUnreferencedQmView(void)
/*++

Routine Description:

    Unmap this MMF from QM process address space if it is
    not referenced by the QM, to free virtual memory in the
    QM address space.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (
        //
        // This MMF is already unmapped from QM process.
        //
        m_pQMBase == 0 ||

        //
        // QM process references this MMF, can not unmap it.
        //
        m_nBufferReference != 0)
    {
        return;
    }

    UnmapQmView();

} // CMMFAllocator::UnmapUnreferencedQmView


//---------------------------------------------------------
//
//  class CPoolAllocator
//
//---------------------------------------------------------

ULONGLONG CPoolAllocator::s_ullQuota = static_cast<ULONGLONG>(DEFAULT_QM_QUOTA) * static_cast<ULONGLONG>(QUOTA_UNIT);
ULONGLONG CPoolAllocator::s_ullQuotaUsed = 0;
BOOL CPoolAllocator::s_fFailedLogAllocation = FALSE;


CPoolAllocator::CPoolAllocator(PCWSTR pPoolPath, ULONG ulGranularity, ACPoolType pt) :
    m_ulGranularity(ulGranularity),
    m_fFailedAllocation(FALSE),
    m_pt(pt),
    m_pPoolPath(CreatePath(pPoolPath))
{
    //
    // Reset shared variables to the class. There is no harm in initializing
    // these shared varialbes in the constructor as all the CPoolAllocator
    // objects are created together.
    //

    s_ullQuota = static_cast<ULONGLONG>(DEFAULT_QM_QUOTA) * static_cast<ULONGLONG>(QUOTA_UNIT);
    s_ullQuotaUsed = 0;
    s_fFailedLogAllocation = FALSE;	
    if(m_pPoolPath == 0)
    {
        TrERROR(AC, "Failed to allocate pool path");
    }
}


PWSTR CPoolAllocator::CreatePath(PCWSTR pPoolPath)
{
    //
    //  The pool path is an absolute path, one of the folowing two forms:
    //  1.  <drive>:\dir1\dir2\dir3\dir4\r%07x.mq
    //  2.  \\machine\share\dir1\dir2\dir3\r%07x.mq
    //
    //  NO TERMINATING back-slash
    //  The correct path should be set at the QM no further checking is done
    //  here.
    //
    ASSERT(pPoolPath != 0);

    size_t len = wcslen(pPoolPath);

    ASSERT(len > 2);
    ASSERT((pPoolPath[1] == L'\\') || (pPoolPath[1] == L':'));
    ASSERT(pPoolPath[len - 1] != L'\\');

    PCWSTR pUNC = L"";
    if(pPoolPath[1] == L'\\')
    {
        //
        //  UNC path, skip the leading '\\', and point to a UNC adendum string
        //
        pPoolPath += UNC_PATH_SKIP;
        len += sizeof(UNC_PATH) / sizeof(WCHAR) - 1 - UNC_PATH_SKIP;
        pUNC = UNC_PATH;
    }

    //
    //  Allocation will fail only in tragic events, where the QM could not
    //  run anyway
    //
    len += sizeof(DOSDEVICES_PATH) / sizeof(WCHAR) - 1;
    
    PWSTR pOutPath = new (PagedPool) WCHAR[len + 1];

	if(pOutPath == 0)
	{
	    TrERROR(AC, "Failed to allocate %Id bytes from paged pool to for path %ls.", (len + 1)*2, pPoolPath); 
	}	
    
    if(pOutPath != 0)
    {
        StringCchPrintf(pOutPath, len+1, DOSDEVICES_PATH L"%s%s", pUNC, pPoolPath);
    }
    
    return pOutPath;
}


void CPoolAllocator::PurgeHeaps(List<CMMFAllocator>& heaps)
{
    CMMFAllocator* pAllocator;
    while((pAllocator = heaps.gethead()) != 0)
    {
        pAllocator->Destroy();

        //
        // Release allocator creation
        //
        pAllocator->Release();
    }
}


CPoolAllocator::~CPoolAllocator()
{
    PurgeHeaps(m_FreeHeaps);
    PurgeHeaps(m_Heaps);

    if (m_pPoolPath)
    {
        delete[] m_pPoolPath;
    }
}


void CPoolAllocator::ReleaseFreeHeaps()
{
    PurgeHeaps(m_FreeHeaps);
}


inline ULONG CPoolAllocator::AlignedSize(ULONG size)
{
    return ALIGNUP_ULONG(size + sizeof(CAccessibleBlock), m_ulGranularity);
}


inline BOOL CPoolAllocator::QuotaAvailable(ULONG ulSize)
{
    return (s_ullQuotaUsed + ulSize <= s_ullQuota);
}


inline void CPoolAllocator::ChargeQuota(ULONG ulSize)
{
    s_ullQuotaUsed += ulSize;
}


inline void CPoolAllocator::RestoreQuota(ULONG ulSize)
{
    s_ullQuotaUsed -= ulSize;
}

inline CAllocatorBlockOffset CPoolAllocator::HeapAllocate(ULONG size, CMMFAllocator** ppAllocator)
{
    CAllocatorBlockOffset abo = CAllocatorBlockOffset::InvalidValue();
    CMMFAllocator* pFirst = m_Heaps.peekhead();
    CMMFAllocator* pCurrent = pFirst;

    //
    // Perform "next fit" in used heaps list. List head always points to the MMF that was most recently used for allocation.
    // In cycle try to allocate from the MMF in the head of the list, 
    // if not succeeded move this MMF to the tail of the list.
    //

    if(pCurrent)
    {
        do 
        {
            abo = pCurrent->malloc(size, ppAllocator);
            if(abo.IsValidOffset())
            {
                return abo;
            }
            m_Heaps.gethead();
            m_Heaps.insert(pCurrent);          
            pCurrent = m_Heaps.peekhead();

        } while(pCurrent != pFirst);
    } 
      
    //
    //  Look in the free heaps list; LRU first.
    //
    
    pCurrent = m_FreeHeaps.gettail();
    if(pCurrent != 0)
    {
        //
        // The new heap is inserted to the head of the list. Next allocation will start from it.
        //
        m_Heaps.InsertHead(pCurrent);
        abo = pCurrent->malloc(size, ppAllocator);
        return abo;
    }

    return CAllocatorBlockOffset::InvalidValue();
}


static NTSTATUS ACpReportAllocation(ACPoolType pt, BOOL fSuccess, ULONG ulFileCount)
{
    CACRequest request(CACRequest::rfEventLog);
    request.EventLog.pt = pt;
    request.EventLog.fSuccess = fSuccess;
    request.EventLog.ulFileCount = ulFileCount;
    
    return  g_pQM->ProcessRequest(request);
}



CMMFAllocator* CPoolAllocator::CreateAllocator()
{
    ++g_HeapFileNameCount;
    
    //
    // Check that g_pLogPath and m_pPoolPath are initialized
    // there may be 0 in case of insufficient resources
    //
    
    if(g_pLogPath == 0)
    {
    	TrERROR(AC, "Pool allocator can't create allocator. g_pLogPath was not initialized."); 

        if(!s_fFailedLogAllocation)
        {
            s_fFailedLogAllocation = TRUE;
            ACpReportAllocation(ptLastPool, FALSE, g_HeapFileNameCount);
        }
        return 0;
    }

    if(m_pPoolPath == 0)
    {
    	TrERROR(AC, "Pool allocator can't create allocator. m_pPoolPath was not initialized."); 

        if(!m_fFailedAllocation)
        {
            m_fFailedAllocation = TRUE;
            ACpReportAllocation(m_pt, FALSE, g_HeapFileNameCount);
        }

        return 0;
    }

    //
    //  Create PingPong buffer for persistent storage
    //
    //  BUGBUG: we use a hack to know we need persistent storage, using
    //          the granularity size
    //

    CPingPong* pPingPong = 0;
    PWCHAR pBitmapFileName = 0;
    HANDLE hBitmapFile = 0;
    if(m_ulGranularity == x_persist_granularity)
    {
        pPingPong = ACpCreateBitmap(g_pLogPath, &pBitmapFileName, &hBitmapFile);
        if(pPingPong == 0)
        {
            //
            //  can not create file
            //
            if(!s_fFailedLogAllocation)
            {
                s_fFailedLogAllocation = TRUE;
                ACpReportAllocation(ptLastPool, FALSE, g_HeapFileNameCount);
            }

            return 0;
        }

        //
        //  successfully created a file
        //
        if(s_fFailedLogAllocation)
        {
            s_fFailedLogAllocation = FALSE;
            ACpReportAllocation(ptLastPool, TRUE, g_HeapFileNameCount);
        }

        NTSTATUS rc;
        rc = ACpWritePingPong(pPingPong, hBitmapFile);
        if(!NT_SUCCESS(rc))
        {
            ACpCleanupBitmap(pPingPong, pBitmapFileName, hBitmapFile);
            return 0;
        }
    }

    CMMFAllocator* pAllocator = CMMFAllocator::Create(this, m_pPoolPath);
    if(pAllocator == 0)
    {
        //
        //  Could not allocate pool (disk space probably) give it another
        //  try after releasing resoruces.
        //
        g_pAllocator->ReleaseFreeHeaps();
        pAllocator = CMMFAllocator::Create(this, m_pPoolPath);
        if(pAllocator == 0)
        {
            if(m_ulGranularity == x_persist_granularity)
            {
                ACpCleanupBitmap(pPingPong, pBitmapFileName, hBitmapFile);
            }

            //
            //  can not create file
            //
            if(!m_fFailedAllocation)
            {
                m_fFailedAllocation = TRUE;
                ACpReportAllocation(m_pt, FALSE, g_HeapFileNameCount);
            }

            return 0;
        }
    }

    //
    //  successfully created a file
    //
    if(m_fFailedAllocation)
    {
        m_fFailedAllocation = FALSE;
        ACpReportAllocation(m_pt, TRUE, g_HeapFileNameCount);
    }

    pAllocator->SetBitmap(pPingPong, pBitmapFileName, hBitmapFile);
    return pAllocator;
}


CAllocatorBlockOffset CPoolAllocator::malloc(ULONG size, CMMFAllocator** ppAllocator, BOOL fCheckQuota)
{
    ASSERT(size != 0);
    size = AlignedSize(size);

    if(size > g_ulHeapPoolSize)
    {
    	TrERROR(AC, "Pool allocator can't allocate %d bytes for packet. The required size is larger then the maximum which is %d bytes.", size ,g_ulHeapPoolSize); 
        return CAllocatorBlockOffset::InvalidValue();
    }

    //
    //  Check quota exceeded
    //
    if(fCheckQuota && !QuotaAvailable(size))
    {
       	TrERROR(AC, "Pool allocator failed to allocate %d bytes for packet because the quota is exceeded. There are %I64d bytes left.", size, s_ullQuota-s_ullQuotaUsed); 
        return CAllocatorBlockOffset::InvalidValue();
    }

    CAllocatorBlockOffset abo = HeapAllocate(size, ppAllocator);
    if(!abo.IsValidOffset())
    {
        //
        //  could not find large enough block, need to allocate pool
        //
        CMMFAllocator* pAllocator = CreateAllocator();
        if(pAllocator == 0)
        {
	       	TrERROR(AC, "Pool allocator failed to allocate %d bytes for packet, because it failed to create a new mmf.", size); 
            return CAllocatorBlockOffset::InvalidValue();
        }

        m_Heaps.InsertHead(pAllocator);
        abo = pAllocator->malloc(size, ppAllocator);
        if(!abo.IsValidOffset())
            return CAllocatorBlockOffset::InvalidValue();
    }

    ASSERT(abo.IsValidOffset());

    ChargeQuota(size);
    return abo;
}


void CPoolAllocator::FreeHeap(CMMFAllocator* pAllocator)
{
    m_Heaps.remove(pAllocator);
    m_FreeHeaps.insert(pAllocator);
}


NTSTATUS CPoolAllocator::RestorePackets(PCWSTR pLogPath, PCWSTR pFilePath)
{
    AP<WCHAR> pLPath = CreatePath(pLogPath);
    AP<WCHAR> pFPath = CreatePath(pFilePath);
    if((pLPath == 0) || (pFPath == 0))
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    R<CMMFAllocator> pAllocator = CMMFAllocator::Create(this, pFPath);
    if(pAllocator == 0)
    {
        //
        //  NOTE:   It could be that this file cannot be opend, nevertheless we return
        //          this status to the QM
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Mark this allocator as used, so the underling file will not be deleted
    // in-case of an error.  erezh 11-Aug-98
    //
    pAllocator->MarkUsed();

    if(pAllocator->CreateBitmap(pLPath) == 0)
    {
        //
        //  NOTE:   It could be that this file canot be opend, nevertheless we return
        //          this status to the QM
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NTSTATUS rc;
    rc = pAllocator->ReadPingPong();
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    ULONG ulSize;
    rc = pAllocator->RestorePackets(&ulSize);
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    //
    //  Quota for restored pools is not monitored
    //
    if(ulSize != 0)
    {
        ChargeQuota(ulSize);
        m_Heaps.insert(pAllocator);
    }
    else
    {
        m_FreeHeaps.insert(pAllocator);
    }

    //
    // detach allocator from auto pointer
    //
    pAllocator = 0;

    return STATUS_SUCCESS;
}


void CPoolAllocator::UnmapUnreferencedHeaps(void) const
/*++

Routine Description:

    Unmap from QM address space MMFs that are not referenced by the QM.
    Called when virtual memory of the QM is exhausted, and free memory
    in the QM is needed.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Iterate free heaps. Ask each heap to unmap its view from QM address space.
    //
    for(List<CMMFAllocator>::Iterator pAllocator(m_FreeHeaps); pAllocator; ++pAllocator)
    {
        pAllocator->UnmapUnreferencedQmView();
    }

    //
    // Iterate non free heaps. Ask each heap to unmap its view from QM address space.
    //
    for(List<CMMFAllocator>::Iterator pAllocator(m_Heaps); pAllocator; ++pAllocator)
    {
        pAllocator->UnmapUnreferencedQmView();
    }
} // CPoolAllocator::UnmapUnreferencedHeaps


//---------------------------------------------------------
//
//  class CSMAllocator
//
//---------------------------------------------------------

CAllocatorBlockOffset CSMAllocator::malloc(ACPoolType pt, ULONG size, CMMFAllocator** ppAllocator, BOOL fCheckQuota)
{
    switch(pt)
    {
        case ptReliable:
            return m_Reliable.malloc(size, ppAllocator, fCheckQuota);

        case ptPersistent:
            return m_Persistant.malloc(size, ppAllocator, fCheckQuota);

        case ptJournal:
            return m_Journal.malloc(size, ppAllocator, fCheckQuota);

        default:
            ASSERT(pt == ptReliable);
            return CAllocatorBlockOffset::InvalidValue();
    }
}


NTSTATUS CSMAllocator::RestorePackets(PCWSTR pLogPath, PCWSTR pFilePath, ULONG id, ACPoolType pt)
{
    if(id > g_HeapFileNameCount)
    {
        g_HeapFileNameCount = id;
    }

    switch(pt)
    {
        case ptPersistent:
            return m_Persistant.RestorePackets(pLogPath, pFilePath);

        case ptJournal:
            return m_Journal.RestorePackets(pLogPath, pFilePath);

        default:
            ASSERT(pt == ptPersistent);
            return STATUS_NOT_IMPLEMENTED;
    }
}


void CSMAllocator::ReleaseFreeHeaps()
{
    m_Reliable.ReleaseFreeHeaps();
    m_Persistant.ReleaseFreeHeaps();
    m_Journal.ReleaseFreeHeaps();
}


void CSMAllocator::UnmapUnreferencedHeaps(void) const
{
    m_Reliable.UnmapUnreferencedHeaps();
    m_Persistant.UnmapUnreferencedHeaps();
    m_Journal.UnmapUnreferencedHeaps();
}


void ACpDestroyHeap()
{
    //
    // Free unrecoverd packets
    //
    CPacket* pPacket;
    while((pPacket = g_pRestoredPackets->gethead()) != 0)
    {
        pPacket->QueueRundown();
    }

    //
    // Cleanup all QM requests. Do it after all packets are rundown
    // (here or queues are closed) to avoid posibility of packet being freed.
    //
    g_pQM->CleanupRequests();

    //
    //  destroy the heap itself
    //
    delete g_pAllocator;
    g_pAllocator = 0;
}


PVOID
ACpCreateHeap(
    PCWSTR pRPath,
    PCWSTR pPPath,
    PCWSTR pJPath,
    PCWSTR pLPath
    )
{
    ASSERT(g_pAllocator == 0);
    g_pAllocator = new (PagedPool) CSMAllocator(pRPath, pPPath, pJPath, pLPath);
    if(g_pAllocator == NULL)
    {
    	TrERROR(AC, "Failed to allocate a shared memory allocator.");
    }
    return g_pAllocator;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\htable.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    htable.cxx

Abstract:
    handle table

Author:
    Erez Haba (erezh) 10-Mar-97

Environment:
    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "htable.h"

#ifndef MQDUMP
#include "htable.tmh"
#endif

//---------------------------------------------------------
//
//  class CHTable
//
//---------------------------------------------------------

void CHTable::Reallocate(ULONG nObjects)
{
    ASSERT(m_ixTop <= nObjects);
    ASSERT(nObjects != m_nObjects);

    PVOID* pObjects = new (PagedPool, NormalPoolPriority) PVOID[nObjects];
    if(pObjects == 0)
    {
    	TrERROR(AC, "Failed to allocate an array of %d handels from paged pool.", nObjects); 
        return;
    }

    memcpy(pObjects, m_pObjects, min(nObjects, m_nObjects) * sizeof(PVOID));
    m_nObjects = nObjects;

    delete[] m_pObjects;
    m_pObjects = pObjects;
}


inline void CHTable::Grow()
{
    ASSERT(m_ixTop == m_nObjects);
    Reallocate(m_nObjects + GrowSize);
}


inline void CHTable::Shrink()
{
    while(m_ixTop && (m_pObjects[m_ixTop - 1] == 0))
    {
        m_ixTop--;
    }

    if((m_nObjects - m_ixTop) >= ShrinkSize)
    {
        Reallocate(ALIGNUP_ULONG(m_ixTop + 1, GrowSize));
    }
}


inline ULONG HandleToIndex(HACCursor32 Handle)
{
    return ((((ULONG)Handle) >> 2) - 1);
}


inline HACCursor32 IndexToHandle(ULONG Index)
{
    return (HACCursor32)((Index + 1) << 2);
}


HACCursor32 CHTable::CreateHandle(PVOID Object)
{
    ASSERT(Object != 0);

    //
    //  First look at top index
    //
    if(m_ixTop < m_nObjects)
    {
        m_pObjects[m_ixTop] = Object;
        return IndexToHandle(m_ixTop++);
    }

    //
    //  Look for a hole in the already allocated table
    //
    for(ULONG ix = 0; ix < m_nObjects; ix++)
    {
        if(m_pObjects[ix] == 0)
        {
            m_pObjects[ix] = Object;
            return IndexToHandle(ix);
        }
    }

    //
    //  No free entry, grow the table
    //
    Grow();

    if(m_ixTop < m_nObjects)
    {
        m_pObjects[m_ixTop] = Object;
        return IndexToHandle(m_ixTop++);
    }

    return 0;
}


PVOID CHTable::ReferenceObject(HACCursor32 Handle)
{
    ULONG ix = HandleToIndex(Handle);
    if(ix < m_ixTop)
    {
        return m_pObjects[ix];
    }

    return 0;
}


PVOID CHTable::CloseHandle(HACCursor32 Handle)
{
    ULONG ix = HandleToIndex(Handle);
    if(ix < m_ixTop)
    {
        PVOID tmp = m_pObjects[ix];
        m_pObjects[ix] = 0;
        Shrink();
        return tmp;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\htable.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    htable.h

Abstract:
    Handle table

Author:
    Erez Haba (erezh) 10-Mar-97

Revision History:

--*/

#ifndef __HTABLE_H
#define __HTABLE_H

//---------------------------------------------------------
//
//  class CHTable
//
//---------------------------------------------------------

class CHTable {

    enum {
        GrowSize = 16,      // N.B. must be a power of 2
        ShrinkSize = 24     // N.B. must be greater than GrowSize
    };

public:
    CHTable();
   ~CHTable();

    HACCursor32 CreateHandle(PVOID Object);
    PVOID ReferenceObject(HACCursor32 Handle);
    PVOID CloseHandle(HACCursor32 Handle);

private:
    void Grow();
    void Shrink();
    void Reallocate(ULONG nObjects);

private:
    ULONG m_nObjects;
    ULONG m_ixTop;
    PVOID* m_pObjects;
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

inline CHTable::CHTable() :
    m_nObjects(0),
    m_ixTop(0),
    m_pObjects(0)
{
}

inline CHTable::~CHTable()
{
    ASSERT(m_ixTop == 0);
    delete[] m_pObjects;
}

#endif // __HTABLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\heap.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    heap.h

Abstract:

    AC heaps

Author:

    Erez Haba (erezh) 13-Apr-1996

Revision History:

    Shai Kariv  (shaik)  11-Apr-2000     Modify for MMF dynamic mapping.

--*/

#ifndef _HEAP_H
#define _HEAP_H

#include <qformat.h>
#include <acdef.h>
#include "object.h"
#include "avl.h"
#include "list.h"
#include "bitmap.h"
#include "data.h"

const ULONG x_express_granularity = 64;
const ULONG x_persist_granularity = 512;

//
//  Forward class declaration
//
class CPoolAllocator;
class CFreeBlockEntry;

//
// Routines declarations
//
CPingPong* ACpCreateBitmap(PCWSTR pLogPath, PWCHAR* ppFileName, HANDLE* phFile);
NTSTATUS ACpWritePingPong(CPingPong* pPingPong, HANDLE hBitmapFile);

//---------------------------------------------------------
//
//  class CAllocatorBlockOffset
//
//  Represents a heap block in allocator coordinates.
//
//---------------------------------------------------------
class CAllocatorBlockOffset
{
    typedef ULONG32 Offset;

public:
    CAllocatorBlockOffset(Offset offset) : m_offset(offset)
    {
    }

    void Invalidate(void)
    {
        m_offset = xInvalidOffset;
    }


    bool IsValidOffset(void) const 
    { 
        return m_offset != xInvalidOffset; 
    }

public:
    static CAllocatorBlockOffset InvalidValue(void)
    {
        return xInvalidOffset;
    }

public:
    Offset m_offset;
    
private:
    static const Offset xInvalidOffset = 0xffffffffUL;

}; // CAllocatorBlockOffset


//---------------------------------------------------------
//
//  class CAccessibleBlock
//
//  Naming convention: 'pab' - pointer to accessible block
//
//  Represents an accessible heap block. A pointer to this
//  class object may point in the QM or System address space.
//
//---------------------------------------------------------
class CAccessibleBlock {
public:
    ULONG m_size;
};

//---------------------------------------------------------
//
//  class CMMFAllocator
//
//---------------------------------------------------------

class CMMFAllocator : public CObject {

    friend class CPoolAllocator;

public:
    void free(CAllocatorBlockOffset abo);

    BOOL IsPersistent() const;
    void BitmapUpdate(CAllocatorBlockOffset abo, ULONG size, BOOL fExists);

	CAccessibleBlock* GetMappedBuffer(CAllocatorBlockOffset abo) const;
    CAccessibleBlock* GetAccessibleBuffer(CAllocatorBlockOffset abo);
    CAccessibleBlock* GetQmAccessibleBuffer(CAllocatorBlockOffset abo);
    CAccessibleBlock* GetQmAccessibleBufferNoMapping(CAllocatorBlockOffset abo) const;

	NTSTATUS MarkNotCoherent();

	void AddOutstandingStorage();
	void ReleaseOutstandingStorage();

    void AddRefBuffer(void) const;     
    void ReleaseBuffer(void) const;

#ifdef MQDUMP
    VOID RestoreExpressPackets(VOID);
    NTSTATUS FindValidExpressPacket(ULONG ixStart, ULONG ixEnd, ULONG &ixPacket);
#endif // MQDUMP

public:
    static CMMFAllocator* Create(CPoolAllocator* pOwner, PCWSTR pPoolPath);

private:
    ~CMMFAllocator();
    void Destroy();
    BOOL IsDestroyed() const;

    CAllocatorBlockOffset malloc(ULONG size, CMMFAllocator** ppAllocator);

    BOOL IsUsed() const;
    void MarkUsed();

    CPingPong* CreateBitmap(PCWSTR pLogPath);
    void SetBitmap(CPingPong* pPingPong, PWCHAR pBitmapFileName, HANDLE hBitmapFile);

    NTSTATUS RestorePackets(ULONG* pulSize);
	NTSTATUS FindValidPacket(ULONG ixStart, ULONG ixEnd, ULONG &ixPacket);

	NTSTATUS ReadPingPong() const;
    NTSTATUS WritePingPong() const;
    NTSTATUS WriteCoherentBitmap() const;
	void MarkCoherent();
    NTSTATUS ReadPingPage(ULONG ulOffset) const;

    NTSTATUS MapACView();
    void UnmapACView();

    NTSTATUS MapQmViewNoRetry(void);
    NTSTATUS MapQmViewWithRetry(void);

    CAccessibleBlock* GetAcAccessibleBufferNoMapping(CAllocatorBlockOffset abo) const;

    void UnmapQmView(void);
    void UnmapUnreferencedQmView(void);

    CMMFAllocator(
        CPoolAllocator* pOwner,
        PVOID pSection,
        PWCHAR pFileName,
        ULONG size
        );

private:
    CFreeBlockEntry* FindFreeBlock(ULONG size, PVOID pStart, PVOID pEnd);
    CFreeBlockEntry* GetFreeBlock(ULONG size);
    void PutFreeBlock(CAllocatorBlockOffset abo, ULONG size);
    

private:
    ULONG m_ulTotalSize;
    ULONG m_ulFreeSize;
    CAVLTree m_FreeBlocks;

private:
    PWCHAR m_pFileName;
    PWCHAR m_pBitmapFileName;
    PVOID m_pSection;
    PVOID m_pQMBase;
    PVOID m_pACBase;
    CPoolAllocator* m_pOwner;
    CPingPong* m_pPingPong;
    HANDLE m_hBitmapFile;
	ULONG m_nOutstandingStorages;
    mutable LONG  m_nBufferReference;
    ULONG m_ulMinNonAvailSize;
    CFreeBlockEntry* m_pCurrentFreeBlock;

private:
    static CMMFAllocator* sm_pMappedAllocator;
};

inline BOOL CMMFAllocator::IsPersistent() const
{
    return (m_pPingPong != 0);
}


//---------------------------------------------------------
//
//  class CPoolAllocator
//
//---------------------------------------------------------

class CPoolAllocator {
public:
    CPoolAllocator(PCWSTR pPoolPath, ULONG ulGranularity, ACPoolType pt);
   ~CPoolAllocator();

    CAllocatorBlockOffset malloc(ULONG size, CMMFAllocator** ppAllocator, BOOL fCheckQuota);
    NTSTATUS RestorePackets(PCWSTR pLogPath, PCWSTR pFilePath);
    void ReleaseFreeHeaps();
    void UnmapUnreferencedHeaps(void) const;

    void FreeHeap(CMMFAllocator* pAllocator);

#ifdef MQDUMP
    VOID RestoreExpressPackets(LPCWSTR pwzFileName);
#endif // MQDUMP

public:
    static PWSTR CreatePath(PCWSTR pPoolPath);

    static void Quota(ULONGLONG ullQuota);
    static BOOL QuotaAvailable(ULONG ulSize);
    static void ChargeQuota(ULONG ulSize);
    static void RestoreQuota(ULONG ulSize);
    static void PurgeHeaps(List<CMMFAllocator>& heaps);
    static ULONGLONG GetUsedQuota();

private:
    CAllocatorBlockOffset HeapAllocate(ULONG size, CMMFAllocator** ppAllocator);
    CMMFAllocator* CreateAllocator();
    ULONG AlignedSize(ULONG size);

private:
    List<CMMFAllocator> m_FreeHeaps;
    List<CMMFAllocator> m_Heaps;
    PWCHAR m_pPoolPath;
    ULONG m_ulGranularity;
    BOOL m_fFailedAllocation;
    ACPoolType m_pt;

private:
    static ULONGLONG s_ullQuota;
    static ULONGLONG s_ullQuotaUsed;
    static BOOL s_fFailedLogAllocation;
};

inline void CPoolAllocator::Quota(ULONGLONG ullQuota)
{
    s_ullQuota = ullQuota;
}

inline ULONGLONG CPoolAllocator::GetUsedQuota()
{
	return s_ullQuotaUsed;
}



//---------------------------------------------------------
//
//  class CSMAllocator
//
//---------------------------------------------------------

class CSMAllocator {
public:
    CSMAllocator(PCWSTR, PCWSTR, PCWSTR, PCWSTR);
   ~CSMAllocator();

    CAllocatorBlockOffset malloc(ACPoolType pool, ULONG size, CMMFAllocator** ppAllocator, BOOL fCheckQuota);
    NTSTATUS RestorePackets(PCWSTR pLogPath, PCWSTR pFilePath, ULONG id, ACPoolType pt);
    void ReleaseFreeHeaps();
    void UnmapUnreferencedHeaps(void) const;
    void MappedLimit(ULONG ulMappedLimit);
    BOOL MappedLimitExceeded();
    void IncMappedNum();
    void DecMappedNum();
    ULONG MappedFiles() const;

private:
    CPoolAllocator m_Reliable;
    CPoolAllocator m_Persistant;
    CPoolAllocator m_Journal;

    ULONG m_ulMappedLimit;
    ULONG m_ulMapped;
};

inline
CSMAllocator::CSMAllocator(
    PCWSTR pRPath,
    PCWSTR pPPath,
    PCWSTR pJPath,
    PCWSTR pLPath
    ) :
    m_Reliable(pRPath, x_express_granularity, ptReliable),
    m_Persistant(pPPath, x_persist_granularity, ptPersistent),
    m_Journal(pJPath, x_persist_granularity, ptJournal),
    m_ulMappedLimit(0xffffffff),
    m_ulMapped(0)
{
    ASSERT(g_pLogPath == 0);
    g_pLogPath = CPoolAllocator::CreatePath(pLPath);
}

inline CSMAllocator::~CSMAllocator()
{
    if(g_pLogPath)
    {
        delete[] g_pLogPath;
    }
    g_pLogPath = 0;
}

inline void CSMAllocator::MappedLimit(ULONG ulMappedLimit)
{
    m_ulMappedLimit = ulMappedLimit;
}

inline BOOL CSMAllocator::MappedLimitExceeded()
{
    return (m_ulMapped >= m_ulMappedLimit);
}

inline void CSMAllocator::IncMappedNum()
{
    m_ulMapped++;
}

inline void CSMAllocator::DecMappedNum()
{
    ASSERT(m_ulMapped > 0);
    m_ulMapped--;
}

inline ULONG CSMAllocator::MappedFiles() const
{
    return m_ulMapped;
}

#endif // _HEAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\internal.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    internal.h

Abstract:

    Type definitions and data for Falcon AC driver

Author:

    Erez Haba (erezh) 1-Aug-95

Revision History:
--*/

#ifndef _INTERNAL_H
#define _INTERNAL_H

#pragma warning(disable: 4097) // typedef-name 'id1' used as synonym for class-name 'id2'
#pragma warning(disable: 4201) // nameless struct/union
#pragma warning(disable: 4514) // unreferenced inline function has been removed
#pragma warning(disable: 4711) // function '*' selected for automatic inline expansion


// --- function prototypes --------------------------------
//
#include "platform.h"
#include <mqwin64a.h>
#include <mqsymbls.h>
#include <mqmacro.h>
#include "actempl.h"


#ifndef abs
#define abs(x) (((x) < 0) ? -(x) : (x))
#endif

#define ALIGNUP_ULONG(x, g) (((ULONG)((x) + ((g)-1))) & ~((ULONG)((g)-1)))
#define ALIGNUP_PTR(x, g) (((ULONG_PTR)((x) + ((g)-1))) & ~((ULONG_PTR)((g)-1)))

extern "C"
{
//
//  Priority increment for completing message queue I/O.  This is used by the
//  Message Queue Access Control driver when completing an IRP (IoCompleteRequest).
//

#define IO_MQAC_INCREMENT           2
//
// NT Device Driver Interface routines
//

NTSTATUS
NTAPI
DriverEntry(
    IN PDRIVER_OBJECT pDriver,
    IN PUNICODE_STRING pRegistryPath
    );

VOID
NTAPI
ACUnload(
    IN PDRIVER_OBJECT pDriver
    );

NTSTATUS
NTAPI
ACCreate(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP irp
    );

NTSTATUS
NTAPI
ACClose(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP irp
    );

NTSTATUS
NTAPI
ACRead(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP irp
    );

NTSTATUS
NTAPI
ACWrite(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP irp
    );

NTSTATUS
NTAPI
ACCleanup(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP irp
    );

NTSTATUS
NTAPI
ACShutdown(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP irp
    );

NTSTATUS
NTAPI
ACFlush(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP irp
    );

class CPacket;

NTSTATUS
NTAPI
ACAckingCompleted(
    CPacket* pPacket
    );

NTSTATUS
NTAPI
ACFreePacket1(
    CPacket* pPacket,
    USHORT usClass
    );

NTSTATUS
NTAPI
ACDeviceControl(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP irp
    );

} // extern "C"

extern "C"  // addendum
{

BOOL
NTAPI
ACCancelIrp(
    PIRP irp,
    KIRQL irql,
    NTSTATUS status
    );

VOID
NTAPI
ACPacketTimeout(
    IN PVOID pPacket
    );

VOID
NTAPI
ACReceiveTimeout(
    IN PVOID irp
    );

BOOLEAN
NTAPI
ACfDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

} // extern "C"

#endif // _INTERNAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\irplist.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    irplist.h

Abstract:

    CIRPList definition, a forward class to CList

Author:

    Erez Haba (erezh) 24-Dec-95

Revision History:
--*/

#ifndef _IRPLIST_H
#define _IRPLIST_H

#include "list.h"
#include "acp.h"

typedef XList<IRP, FIELD_OFFSET(IRP, Tail.Overlay.ListEntry)> CIRPList;

typedef XList<IRP, FIELD_OFFSET(IRP, Tail.Overlay.DriverContext) + FIELD_OFFSET(CDriverContext, Context.Receive.m_XactReaderLink)> CIRPList1;


#endif // _IRPLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\irp2pkt.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    irp2pkt.cxx

Abstract:

    IRP to packet[s] mapping definition.

    1-1 messages, IRP handles a single packet request to QM.
    1-N messages, IRP may handle multiple packet requests to QM.

Author:

    Shai Kariv  (shaik)  29-May-2000

Revision History:

--*/

#include "internal.h"
#include "irp2pkt.h"
#include "acp.h"

#ifndef MQDUMP
#include "irp2pkt.tmh"
#endif

///////////////////////////////////////////////////////////////////////////////
//
// class CPacketIterator
//


inline
bool
CPacketIterator::insert(
    CPacket * pPacket
    )
{
    CEntry * pEntry = new (NonPagedPool) CEntry(pPacket);
    if (pEntry == NULL)
    {
    	TrERROR(AC, "Failed to allocate a CEntry from non paged pool."); 
        return false;
    }

    m_entries.insert(pEntry);
    ++m_nEntries;

    return true;

} // CPacketIterator::insert


inline
VOID
CPacketIterator::remove(
    CPacket * pPacket
    )
{
    CEntry * pEntry = Packet2Entry(pPacket);
    ASSERT(pEntry != NULL);

    remove(pEntry);

} // CPacketIterator::remove


inline
VOID
CPacketIterator::remove(
    CEntry * pEntry
    )
{
    m_entries.remove(pEntry);
    delete pEntry;
    
    ASSERT(m_nEntries != 0);
    --m_nEntries;

} // CPacketIterator::remove


inline
CPacket *
CPacketIterator::gethead(
    VOID
    )
{
    CEntry * pEntry = m_entries.gethead();
    if (pEntry == NULL)
    {
        return NULL;
    }

    ASSERT(m_nEntries != 0);
    --m_nEntries;

    CPacket * pPacket = pEntry->m_pPacket;
    ASSERT(pPacket != NULL);

    delete pEntry;

    return pPacket;

} // CPacketIterator::gethead


inline
CPacket *
CPacketIterator::peekhead(
    VOID
    )
{
    CEntry * pEntry = m_entries.peekhead();
    if (pEntry == NULL)
    {
        return NULL;
    }

    CPacket * pPacket = pEntry->m_pPacket;
    ASSERT(pPacket != NULL);

    return pPacket;

} // CPacketIterator::peekhead


inline
CPacketIterator::CEntry *
CPacketIterator::Packet2Entry(
    CPacket * pPacket
    )
{
    for(List<CEntry>::Iterator pEntry(m_entries);
        pEntry != NULL;
        ++pEntry)
    {
        if (pEntry->m_pPacket == pPacket)
        {
            return pEntry;
        }
    }

    return NULL;

} // CPacketIterator::Packet2Entry



///////////////////////////////////////////////////////////////////////////////
//
// class CIrp2Pkt
//


VOID
CIrp2Pkt::AttachSinglePacket(
    PIRP      irp,
    CPacket * pPacket
    )
{
    ASSERT(!irp_driver_context(irp)->MultiPackets());

    ASSERT(pPacket != NULL);
    irp->IoStatus.Information = reinterpret_cast<ULONG_PTR>(pPacket);

} // CIrp2Pkt::AttachSinglePacket


CPacket *
CIrp2Pkt::PeekSinglePacket(
    PIRP irp
    )
{
    ASSERT(!irp_driver_context(irp)->MultiPackets());

    //
    // It is OK to have NULL pointer on the IRP.
    //
    CPacket * pPacket = reinterpret_cast<CPacket*>(irp->IoStatus.Information);
    return pPacket;

} // CIrp2Pkt::PeekSinglePacket


CPacket *
CIrp2Pkt::SafePeekFirstPacket(
    PIRP irp
    )
{
    if (!irp_driver_context(irp)->MultiPackets())
    {
        return PeekSinglePacket(irp);
    }

    CPacketIterator * pPacketIterator = GetPacketIterator(irp);
    if (pPacketIterator == NULL)
    {
        return NULL;
    }

    return pPacketIterator->peekhead();

} // CIrp2Pkt::SafePeekFirstPacket


CPacket *
CIrp2Pkt::DetachSinglePacket(
    PIRP irp
    )
{
    ASSERT(!irp_driver_context(irp)->MultiPackets());

    //
    // It is expected that there is a valid pointer to a packet on the IRP.
    //
    CPacket * pPacket = PeekSinglePacket(irp);
    ASSERT(pPacket != NULL);

    //
    // "Detach" the packet from IRP by zeroing the pointer on the IRP.
    //
    irp->IoStatus.Information = 0;

    return pPacket;

} // CIrp2Pkt::DetachSinglePacket


ULONG
CIrp2Pkt::NumOfAttachedPackets(
    PIRP irp
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    CPacketIterator * pPacketIterator = GetPacketIterator(irp);
    if (pPacketIterator == NULL)
    {
        return 0;
    }
    
    return pPacketIterator->NumOfEntries();

} // CIrp2Pkt::NumOfAttachedPackets


ULONG 
CIrp2Pkt::NumOfPacketsPendingCreate(
    PIRP irp
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    CPacketIterator * pPacketIterator = GetPacketIterator(irp);
    if (pPacketIterator == NULL)
    {
        return 0;
    }
    
    return pPacketIterator->NumOfPacketsPendingCreate();

} // CIrp2Pkt::NumOfPacketsPendingCreate


VOID
CIrp2Pkt::IncreasePacketsPendingCreateCounter(
    PIRP irp
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    CPacketIterator * pPacketIterator = GetPacketIterator(irp);
    ASSERT(pPacketIterator != NULL);
    
    pPacketIterator->IncreasePacketsPendingCreateCounter();

} // CIrp2Pkt::IncreasePacketsPendingCreateCounter


VOID
CIrp2Pkt::DecreasePacketsPendingCreateCounter(
    PIRP irp
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    CPacketIterator * pPacketIterator = GetPacketIterator(irp);
    ASSERT(pPacketIterator != NULL);
    
    pPacketIterator->DecreasePacketsPendingCreateCounter();

} // CIrp2Pkt::DecreasePacketsPendingCreateCounter


bool
CIrp2Pkt::AttachPacket(
    PIRP      irp,
    CPacket * pPacket
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    CPacketIterator * pPacketIterator = GetPacketIterator(irp);
    if (pPacketIterator == NULL)
    {
        if ((pPacketIterator = AllocatePacketIterator(irp)) == NULL)
        {
            return false;
        }
    }

    ASSERT(pPacketIterator != NULL);

    bool success = pPacketIterator->insert(pPacket);
    if (success)
    {
        return true;
    }

    if(NumOfAttachedPackets(irp) == 0)
    {
        DeallocatePacketIterator(irp);
    }
    
    return false;

} // CIrp2Pkt::AttachPacket


bool
CIrp2Pkt::SafeAttachPacket(
    PIRP      irp,
    CPacket * pPacket
    )
{
    if (irp_driver_context(irp)->MultiPackets())
    {
        return AttachPacket(irp, pPacket);
    }

    AttachSinglePacket(irp, pPacket);
    return true;

} // CIrp2Pkt::SafeAttachPacket


CPacket *
CIrp2Pkt::DetachPacket(
    PIRP      irp,
    CPacket * pPacket
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    CPacketIterator * pPacketIterator = GetPacketIterator(irp);
    ASSERT(pPacketIterator != NULL);

    pPacketIterator->remove(pPacket);

    if (NumOfAttachedPackets(irp) == 0)
    {
        DeallocatePacketIterator(irp);
    }

    return pPacket;

} // CIrp2Pkt::DetachPacket


CPacket *
CIrp2Pkt::SafeDetachPacket(
    PIRP      irp,
    CPacket * pPacket
    )
{
    if (irp_driver_context(irp)->MultiPackets())
    {
        return DetachPacket(irp, pPacket);
    }

    CPacket * pPacket1 = DetachSinglePacket(irp);
    ASSERT(pPacket == pPacket1);
    return pPacket1;

} // CIrp2Pkt::SafeDetachPacket


CPacket *
CIrp2Pkt::GetAttachedPacketsHead(
    PIRP irp
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    CPacketIterator * pPacketIterator = GetPacketIterator(irp);
    if (pPacketIterator == NULL)
    {
        return NULL;
    }

    CPacket * pPacket = pPacketIterator->gethead();
    ASSERT(pPacket != NULL);

    if (NumOfAttachedPackets(irp) == 0)
    {
        DeallocatePacketIterator(irp);
    }

    return pPacket;

} // CIrp2Pkt::GetAttachedPacketsHead


CPacket *
CIrp2Pkt::SafeGetAttachedPacketsHead(
    PIRP irp
    )
{
    //
    // This routine is used when caller doesn't care if irp represents multiple packets or not
    //

    if (irp_driver_context(irp)->MultiPackets())
    {
        return GetAttachedPacketsHead(irp);
    }

    if (PeekSinglePacket(irp) == NULL)
    {
        return NULL;
    }

    return DetachSinglePacket(irp);

} // CIrp2Pkt::SafeGetAttachedPacketsHead


VOID
CIrp2Pkt::InitPacketIterator(
    PIRP irp
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    SetPacketIterator(irp, NULL);

} // CIrp2Pkt::InitPacketIterator


VOID
CIrp2Pkt::DeallocatePacketIterator(
    PIRP irp
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    CPacketIterator * pPacketIterator = GetPacketIterator(irp);
    ASSERT(pPacketIterator != NULL);

    delete pPacketIterator;

    SetPacketIterator(irp, NULL);

} // CIrp2Pkt::DeallocatePacketIterator


CPacketIterator *
CIrp2Pkt::GetPacketIterator(
    PIRP irp
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    return reinterpret_cast<CPacketIterator*>(irp->IoStatus.Information);

} // CIrp2Pkt::GetPacketIterator


List<CPacketIterator::CEntry>& 
CIrp2Pkt::GetPacketIteratorEntries(
    PIRP irp
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    CPacketIterator * pPacketIterator = GetPacketIterator(irp);
    ASSERT(pPacketIterator != NULL);

    return pPacketIterator->entries();

} // CIrp2Pkt::GetPacketIteratorEntries


CPacketIterator *
CIrp2Pkt::AllocatePacketIterator(
    PIRP irp
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    ASSERT(GetPacketIterator(irp) == NULL);

    CPacketIterator * pPacketIterator = new (NonPagedPool) CPacketIterator;
    if (pPacketIterator == NULL)
    { 
    	TrERROR(AC, "Failed to allocate a Packet iterator for irp from non paged pool. PIRP = %p", irp); 

        return NULL;
    }

    return SetPacketIterator(irp, pPacketIterator);

} // CIrp2Pkt::AllocatePacketIterator


CPacketIterator *
CIrp2Pkt::SetPacketIterator(
    PIRP              irp,
    CPacketIterator * pPacketIterator
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    irp->IoStatus.Information = reinterpret_cast<ULONG_PTR>(pPacketIterator);

    return pPacketIterator;

} // CIrp2Pkt::SetPacketIterator


bool
CIrp2Pkt::IsHeld(
    PIRP irp
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    CPacketIterator * pPacketIterator = GetPacketIterator(irp);
    if (pPacketIterator == NULL)
    {
        return false;
    }

    return pPacketIterator->IsHeld();

} // CIrp2Pkt::IsHeld


VOID
CIrp2Pkt::IsHeld(
    PIRP irp,
    bool fHeld
    )
{
    ASSERT(irp_driver_context(irp)->MultiPackets());

    CPacketIterator * pPacketIterator = GetPacketIterator(irp);
    ASSERT(pPacketIterator != NULL);

    pPacketIterator->IsHeld(fHeld);

} // CIrp2Pkt::IsHeld
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\irp2pkt.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    irp2pkt.h

Abstract:

    IRP to packet[s] mapping declaration.

    1-1 messages, IRP handles a single packet request to QM.
    1-N messages, IRP may handle multiple packet requests to QM.

Author:

    Shai Kariv  (shaik)  29-May-2000

Revision History:

--*/

#ifndef __IRP2PKT_H
#define __IRP2PKT_H

#include "packet.h"


//--------------------------------------------------------------
//
// class CPacketIterator
//
// Header is declared here to allow inclusion of nested classes.
//
//--------------------------------------------------------------

class CPacketIterator {
public:

//--------------------------------------------------------------
//
// class CPacketIterator::CEntry
//
// Linked list entry. Points to a packet.
//
//--------------------------------------------------------------

    class CEntry {
    public:

        CEntry(CPacket * pPacket) : m_pPacket(pPacket) {}

        LIST_ENTRY   m_link;
        CPacket    * m_pPacket;
    };

//--------------------------------------------------------------
//
// class CPacketIterator
//
// The class definition actually starts at the top of this file.
//
//--------------------------------------------------------------
//class CPacketIterator {
public:
    //
    // Constructor.
    //
    CPacketIterator() : 
        m_nEntries(0), 
        m_nPacketsPendingCreate(0),
        m_fHeld(false)
    {
    }

    //
    // List manipulation encapsulation.
    //
    bool insert(CPacket * pPacket);
    VOID remove(CPacket * pPacket);
    VOID remove(CEntry  * pEntry);
    CPacket * gethead(VOID);
    CPacket * peekhead(VOID);

    //
    // Get number of entries in list.
    //
    ULONG 
    NumOfEntries(
        VOID
        ) 
    { 
        return m_nEntries; 
    }

    //
    // Get a reference to the list
    //
    List<CEntry>& 
    entries(
        VOID
        ) 
    { 
        return m_entries; 
    }

    //
    // Get number of packets that are pending for create by QM.
    //
    ULONG 
    NumOfPacketsPendingCreate(
        VOID
        ) 
    { 
        return m_nPacketsPendingCreate; 
    }

    //
    // Increase counter of packets that are pending for create by QM.
    //
    VOID 
    IncreasePacketsPendingCreateCounter(
        VOID
        ) 
    { 
        ++m_nPacketsPendingCreate; 
    }

    //
    // Decrease counter of packets that are pending for create by QM.
    //
    VOID 
    DecreasePacketsPendingCreateCounter(
        VOID
        ) 
    { 
        ASSERT(m_nPacketsPendingCreate > 0); 
        --m_nPacketsPendingCreate; 
    }

    //
    // Handle is held in list
    //
    bool 
    IsHeld(
        VOID
        ) const 
    { 
        return m_fHeld;
    }

    VOID
    IsHeld(
        bool fHeld
        )
    {
        m_fHeld = fHeld;
    }

private:
    //
    // Find an entry in the list
    //
    CEntry * Packet2Entry(CPacket * pPacket);

private:
    //
    //  The linked list of packets.
    //
    List<CEntry> m_entries;
    ULONG        m_nEntries;

    //
    // Number of packets that are pending for create by QM.
    //
    ULONG        m_nPacketsPendingCreate;

    //
    // Is held in list
    //
    bool m_fHeld;

}; // class CPacketIterator


//--------------------------------------------------------------
//
// class CIrp2Pkt
//
// Interface encapulation for IRP to packet mapping.
//
//--------------------------------------------------------------

class CIrp2Pkt
{
public:

    //
    // Handle irp to single packet mapping.
    //
    static VOID      AttachSinglePacket(PIRP irp, CPacket * pPacket);
    static CPacket * DetachSinglePacket(PIRP irp);
    static CPacket * PeekSinglePacket(PIRP irp);

    //
    // Handle irp to multiple packets mapping.
    //
    static ULONG      NumOfAttachedPackets(PIRP irp);
    static bool       AttachPacket(PIRP irp, CPacket * pPacket);
    static CPacket *  DetachPacket(PIRP irp, CPacket * pPacket);
    static CPacket *  GetAttachedPacketsHead(PIRP irp);
    static bool       IsHeld(PIRP irp);
    static VOID       IsHeld(PIRP irp, bool fHeld);

    //
    // Handle packets that are pending for creation by QM.
    //
    static ULONG NumOfPacketsPendingCreate(PIRP irp);
    static VOID  IncreasePacketsPendingCreateCounter(PIRP irp);
    static VOID  DecreasePacketsPendingCreateCounter(PIRP irp);

    //
    // "safe" routines: used when caller doesn't care if irp represents multiple packets or not.
    //
    static CPacket * SafePeekFirstPacket(PIRP irp);
    static CPacket * SafeGetAttachedPacketsHead(PIRP irp);
    static CPacket * SafeDetachPacket(PIRP irp, CPacket * pPacket);
    static bool      SafeAttachPacket(PIRP irp, CPacket * pPacket);

    //
    // Handle packet iterator for the irp.
    //
    static VOID InitPacketIterator(PIRP irp);
    static List<CPacketIterator::CEntry>& GetPacketIteratorEntries(PIRP);

private:

    //
    // Handle packet iterator for the irp.
    //
    static CPacketIterator * AllocatePacketIterator(PIRP irp);
    static VOID              DeallocatePacketIterator(PIRP irp);
    static CPacketIterator * SetPacketIterator(PIRP irp, CPacketIterator * p);
    static CPacketIterator * GetPacketIterator(PIRP irp);

}; // class CIrp2Pkt


#endif // __IRP2PKT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\list.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    list.h

Abstract:

    List and XList::Iterator.
    An intrusive double linked list and iterator template

Author:

    Erez Haba (erezh) 13-Aug-95

Revision History:

--*/

/*++

  DESCRIPTION:
     List is defined as a circular doubble linked list. With actions
     to insert and remove entries.


      List
     +-----+   +-----+ +-----+ +-----+ +-----+ +-----+
     |     |<--|     | |     | |     | |     | |     |
     | head|   | data| | data| | data| | data| | data|
     |     |-->|     | |     | |     | |     | |     |
     +-----+   +-----+ +-----+ +-----+ +-----+ +-----+

                      Linked list diagram


     An iteration is defined for the list using the member type
     named Iterator. (to declater an interator use resolved scope
     name. e.g., List::Iterator). An iterator variable acts as a
     LIST_ENTRY pointer, operators are overloaded for this type so
     you can (allmost) freely use is as a pointer.

     Example:
       for(List::Iterator p(list); p; ++p) {
         p->doSomeThing();
       }
--*/

#ifndef _LIST_H
#define _LIST_H

// --- helper class ---------------------------------------
//
// ListHelper
//
// This template class is used to woraround C12 (VC6.0) bug where the XList
// template parameter 'Offset' can not be directly assigned the value of
// 'FIELD_OFFSET(T, m_link)'. The compiler does hot handle correctly using
// this class without specifing the type, i.e., using this template class
// in another template, as inheritance or as an agrigate.    erezh 29-Mar-99
//
template<class T>
class ListHelper {
public:

	enum { Offset = FIELD_OFFSET(T, m_link) };
};


// --- declerations ---------------------------------------
//
// class XList
//
template<class T, int Offset = ListHelper<T>::Offset>
class XList {
private:

    //
    // The list head is the *only* data member
    //
    LIST_ENTRY m_head;

    static LIST_ENTRY* Item2Entry(T*);
    static T* Entry2Item(LIST_ENTRY*);

public:

    XList(void);
   ~XList(void);

    void insert(T* pItem);
    void InsertHead(T* pItem);
    void InsertAfter(T* pItem, T* pPrevItem);
    void remove(T* pItem);

    int isempty(void) const;

    T* peekhead(void) const;
    T* peektail(void) const;

    T* gethead(void);
    T* gettail(void);

public:

    //
    // class Iterator decleration
    //
    class Iterator {

    private:
        const LIST_ENTRY* m_head;
        LIST_ENTRY* m_current;

    public:

        //
        //  Iterator implementation is here due to bug
        //  in VC++ 4.0 compiler. If implementation is not
        //  here, liker looks for some constructor not needed
        //
        Iterator(const XList& cl) :
            m_head(&cl.m_head),
            m_current(cl.m_head.Flink)
        {
        }

        Iterator& operator =(T* t)
        {
            m_current = XList<T, Offset>::Item2Entry(t);
            return *this;
        }

        Iterator& operator ++()
        {
            m_current = m_current->Flink;
            return *this;
        }

        Iterator& operator --()
        {
            m_current = m_current->Blink;
            return *this;
        }

        operator T*() const
        {
            return (m_head == m_current) ?
                    0 : XList<T, Offset>::Entry2Item(m_current);
        }

        T* operator ->() const
        {
            return operator T*();
        }
    };
    //
    // end class Iterator decleration
    //

    //
    //  The iterator is a friend of List
    //
    friend Iterator;
};

// --- declerations ---------------------------------------
//
// class List, a shorthand for m_link
//


template<class T>
class List : public XList<T> {};



// --- implementation -------------------------------------
//
// class XList
//
//
template<class T, int Offset>
inline XList<T, Offset>::XList(void)
{
    InitializeListHead(&m_head);
}

template<class T, int Offset>
inline XList<T, Offset>::~XList(void)
{
    ASSERT(isempty());
}

template<class T, int Offset>
inline LIST_ENTRY* XList<T, Offset>::Item2Entry(T* t)
{
    return (LIST_ENTRY*)((PCHAR)t + Offset);
}

template<class T, int Offset>
inline T* XList<T, Offset>::Entry2Item(LIST_ENTRY* l)
{
    return (T*)((PCHAR)l - Offset);
}

template<class T, int Offset>
inline void XList<T, Offset>::insert(T* pItem)
{
    LIST_ENTRY* pEntry = Item2Entry(pItem);
    InsertTailList(&m_head, pEntry);
}

template<class T, int Offset>
inline void XList<T, Offset>::InsertHead(T* pItem)
{
    LIST_ENTRY* pEntry = Item2Entry(pItem);
    InsertHeadList(&m_head, pEntry);
}

template<class T, int Offset>
inline void XList<T, Offset>::InsertAfter(T* pItem, T* pPrevItem)
{
    LIST_ENTRY* pEntry = Item2Entry(pItem);
    LIST_ENTRY* pPrevEntry = Item2Entry(pPrevItem);

    InsertHeadList(pPrevEntry, pEntry);
}

template<class T, int Offset>
inline void XList<T, Offset>::remove(T* item)
{
    LIST_ENTRY* pEntry = Item2Entry(item);
    RemoveEntryList(pEntry);

    pEntry->Flink = NULL;
    pEntry->Blink = NULL;
}

template<class T, int Offset>
inline int XList<T, Offset>::isempty(void) const
{
    return IsListEmpty(&m_head);
}

template<class T, int Offset>
inline T* XList<T, Offset>::peekhead() const
{
    return isempty() ? 0 : Entry2Item(m_head.Flink);
}

template<class T, int Offset>
inline T* XList<T, Offset>::peektail() const
{
    return isempty() ? 0 : Entry2Item(m_head.Blink);
}

template<class T, int Offset>
inline T* XList<T, Offset>::gethead()
{
    if(isempty())
    {
        return 0;
    }

    //
    // return RemoveHeadList(...) will NOT work here!!! (macro)
    //
    LIST_ENTRY* p = RemoveHeadList(&m_head);
    
    p->Flink = NULL;
    p->Blink = NULL;
    
    return Entry2Item(p);
}

template<class T, int Offset>
inline T* XList<T, Offset>::gettail()
{
    if(isempty())
    {
        return 0;
    }

    //
    // return RemoveTailList(...) will NOT work here!!! (macro)
    //
    LIST_ENTRY* p = RemoveTailList(&m_head);
    
    p->Flink = NULL;
    p->Blink = NULL;

    return Entry2Item(p);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\init.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ac.cxx

Abstract:

    This module contains the code to initialize Falcon Access Control.

Author:

    Erez Haba (erezh) 1-Aug-95

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "data.h"
#include "acioctl.h"
#include "devext.h"
#include "sched.h"

#ifndef MQDUMP
#include "init.tmh"
#endif

// --- local constants ------------------------------------
//

//
// Falcon AC Name as known to Nt system.
// Allocate enough space for long service name.  (ShaiK, 14-Jun-1999)
//
WCHAR wzFalconACDeviceName[300] = L"\\Device\\";

//
// Falcon AC Name as known to WIN32 sybsystem
// Allocate enough space for long service name.  (ShaiK, 14-Jun-1999)
//
WCHAR wzFalconACLinkName[300]   = L"\\DosDevices\\";

//
// Value name of the CheckForQM override mode
//
#define REG_OVERRIDE_CHECK_QM_PROCESS   L"CheckQMProcess"


#ifdef _DEBUG
ANSI_STRING g_szDebugDevName ;
#endif

// --- implementation -------------------------------------
//

void GetCheckForQMOverrideMode(PUNICODE_STRING RegistryPath)
/*++

Routine Description:
	Read from registry if we will override the CheckForQMProcess function

Arguments:
    RegistryPath - pointer to the registry path of the driver:
    				HKLM\SYSTEM\CurrentControlSet\Services\MQAC

Return Value:
	None.

--*/
{
#ifndef MQDUMP

	OBJECT_ATTRIBUTES oa;
	InitializeObjectAttributes(
							&oa,
	                       	RegistryPath,
	                       	OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
	                       	NULL,
	                       	NULL
	                       	);
	HANDLE h;
	NTSTATUS rc = ZwOpenKey(&h, KEY_QUERY_VALUE, &oa);
	if (!NT_SUCCESS(rc))
	{
		return;
	}

	UNICODE_STRING usOverrideValueName;
	RtlInitUnicodeString(&usOverrideValueName, REG_OVERRIDE_CHECK_QM_PROCESS);
	UCHAR ValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
	ULONG size;
	rc = ZwQueryValueKey(h, &usOverrideValueName, KeyValuePartialInformation, ValueBuffer, sizeof(ValueBuffer), &size);
	ZwClose (h);
	if (NT_SUCCESS(rc))
	{
		PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
		if ((value->Type == REG_DWORD) &&
			(value->DataLength == sizeof(DWORD)) &&
			(*(DWORD*)&(value->Data) == TRUE))
		{
			//
			// we are in override mode
			//
			g_fCheckForQMProcessOverride = TRUE;
		}
	}

#endif //MQDUMP
}



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   pDriver,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    The entry point to initialize Falcon AC driver.

Arguments:

    pDriver
        Just what it says, really of little use to the driver itself,
        it is something that the IO system cares more about.

    PathToRegistry
        Points to the entry for this driver in the current control set
        of the registry.

Return Value:

    STATUS_SUCCESS if we could initialize a single device, otherwise
    STATUS_NO_SUCH_DEVICE.

--*/
{
   WPP_INIT_TRACING(pDriver, RegistryPath);

	//
	// Read from registry if we will override the CheckForQMProcess function
	//
	GetCheckForQMOverrideMode(RegistryPath);
	
   //
   // Find device name
   //
   int index = 0 ;
   WCHAR *pDevName = &RegistryPath->Buffer[0];
   for ( ; RegistryPath->Buffer[ index ] ; index++ ) {
      if (RegistryPath->Buffer[ index ] == L'\\') {
         pDevName = &RegistryPath->Buffer[ index+1 ] ;
      }
   }

   //
   // Form a full symbolic device name
   //
   WCHAR *pTmp = &wzFalconACDeviceName[0];
   for ( index = 0 ; wzFalconACDeviceName[ index ] ; index++ ) {
      if (wzFalconACDeviceName[ index ] == L'\\') {
         pTmp = &wzFalconACDeviceName[ index+1 ] ;
      }
   }

   WCHAR *pDevTmp = pDevName;
   while (*pDevTmp) {
      *pTmp = *pDevTmp ;
      pTmp++ ;
      pDevTmp++ ;
   }
   *pTmp = 0 ;

   UNICODE_STRING uszDeviceName;
   RtlInitUnicodeString(
        &uszDeviceName,
        wzFalconACDeviceName
        );

   //
   // Form a full symbolic link name
   //
   for ( index = 0 ; wzFalconACLinkName[ index ] ; index++ ) {
      if (wzFalconACLinkName[ index ] == L'\\') {
         pTmp = &wzFalconACLinkName[ index+1 ] ;
      }
   }

   pDevTmp = pDevName ;
   while (*pDevTmp) {
      *pTmp = *pDevTmp ;
      pTmp++ ;
      pDevTmp++ ;
   }
   *pTmp = 0 ;

   UNICODE_STRING uszLinkName;
   RtlInitUnicodeString(
        &uszLinkName,
        wzFalconACLinkName
        );

#ifdef _DEBUG
    ANSI_STRING szDebug ;

    RtlUnicodeStringToAnsiString(  &szDebug,
                                   RegistryPath,
                                   TRUE  ) ;

    KdPrint(("Falcon DriverEntry (Reg- %s )\n", szDebug.Buffer));
    RtlFreeAnsiString( &szDebug ) ;

    RtlUnicodeStringToAnsiString( &g_szDebugDevName,
                                  &uszDeviceName,
                                  TRUE  ) ;
    KdPrint(("Falcon DriverEntry (DevName- %s )\n", g_szDebugDevName.Buffer));

    RtlUnicodeStringToAnsiString(  &szDebug,
                                   &uszLinkName,
                                   TRUE  ) ;
    KdPrint(("Falcon DriverEntry (LinkName- %s )\n", szDebug.Buffer));
    RtlFreeAnsiString( &szDebug ) ;
#endif

    //
    // Set driver to be completely paged out.
    //

    //
    //  BUGBUG: temporary don't page out, until we stable with synchronization
    //
    //MmPageEntireDriver(DriverEntry);

    //
    // Create the device object for this device.
    //
    PDEVICE_OBJECT pDevice;
    NTSTATUS rc = IoCreateDevice(
                    pDriver,
                    sizeof(CDeviceExt),
                    &uszDeviceName,
                    FILE_DEVICE_MQAC,
                    0,
                    FALSE,
                    &pDevice
                    );

    if(!NT_SUCCESS(rc))
    {
        //
        // very bad, we could not create the device
        //
        KdPrint(("Falcon DriverEntry (IoCreateDevice failed %lx )\n", rc));
        return rc;
    }
	
    //
    // call CDeviceExt::CDeviceExt (default contstructor) allocated in the
    // device extention memory
    //
    CDeviceExt* pDE = new (pDevice->DeviceExtension) CDeviceExt;

    //
    // initialize the global QM interface and Shared memory heap manager
    //
    g_pQM   = &pDE->m_qm;
    g_pLock = &pDE->m_lock;
    g_pStorage = &pDE->m_storage;
    g_pStorageComplete = &pDE->m_storage_complete;
    g_pCreatePacket = &pDE->m_CreatePacket;
    g_pCreatePacketComplete = &pDE->m_CreatePacketComplete;
    g_pRestoredPackets = &pDE->m_RestoredPackets;
    g_pTransactions = &pDE->m_Transactions;
    g_pCursorTable = &pDE->m_CursorTable;

    if (!g_pStorageComplete->AllocateWorkItem(pDevice))
    {
    	TrERROR(AC, "Failed to allocate a storage completion work item."); 
        IoDeleteDevice(pDevice);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!g_pCreatePacketComplete->AllocateWorkItem(pDevice))
    {
    	TrERROR(AC, "Failed to allocate a local create packet completion work item."); 
        IoDeleteDevice(pDevice);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!g_pQM->InitTimer(pDevice))
    {
       	TrERROR(AC, "Failed to allocate a timer work item."); 
        IoDeleteDevice(pDevice);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Create the schedulers.
    //
    g_pPacketScheduler = new (PagedPool) CScheduler(
                                            ACPacketTimeout,
                                            &pDE->m_PacketTimer,
                                            &pDE->m_PacketMutex
                                            );

    g_pReceiveScheduler = new (PagedPool) CScheduler(
                                             ACReceiveTimeout,
                                             &pDE->m_ReceiveTimer,
                                             &pDE->m_ReceiveMutex
                                             );

    if(g_pPacketScheduler == 0                 || 
       g_pReceiveScheduler == 0                ||
       !g_pPacketScheduler->InitTimer(pDevice) ||
       !g_pReceiveScheduler->InitTimer(pDevice))
    {
    	TrERROR(AC, "Failed to allocate a CScheduler from paged pool."); 
        delete g_pPacketScheduler;
        delete g_pReceiveScheduler;
        IoDeleteDevice(pDevice);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    rc = IoCreateSymbolicLink(
            &uszLinkName,
            &uszDeviceName
            );

    if(!NT_SUCCESS(rc))
    {
        //
        // no symbolic link, return error
        //
        KdPrint(("Falcon DriverEntry (IoCreateSymbolicLink failed %lx )\n", rc));
        delete g_pPacketScheduler;
        IoDeleteDevice(pDevice);
        return rc;
    }

    //
    // Initialize the Driver Object with driver's entry points
    //
    pDriver->MajorFunction[IRP_MJ_CREATE  ] = ACCreate;
    pDriver->MajorFunction[IRP_MJ_CLOSE   ] = ACClose;
    pDriver->MajorFunction[IRP_MJ_CLEANUP ] = ACCleanup;
//    pDriver->MajorFunction[IRP_MJ_READ    ] = ACRead;
//    pDriver->MajorFunction[IRP_MJ_WRITE   ] = ACWrite;
//    pDriver->MajorFunction[IRP_MJ_SHUTDOWN] = ACShutdown;
//    pDriver->MajorFunction[IRP_MJ_FLUSH_BUFFERS ] = ACFlush;
    pDriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ACDeviceControl;
    pDriver->DriverUnload = ACUnload;

    KdPrint(("Falcon DriverEntry (returning STATUS_SUCCESS)\n"));
    return STATUS_SUCCESS;
}

VOID
ACUnload(
    IN PDRIVER_OBJECT pDriver
    )
/*++

Routine Description:

    This routine cleans up all of the memory associated with
    any of the devices belonging to the driver.

Arguments:

    pDriver
        Pointer to the driver object controling all of the devices.

Return Value:

    None.

--*/
{
    KdPrint(("Falcon ACUnload\n"));

    UNICODE_STRING uszLinkName;
    RtlInitUnicodeString(
        &uszLinkName,
        wzFalconACLinkName
        );

    //
    // clean up symbolic links
    //
    IoDeleteSymbolicLink(&uszLinkName);

    //
    //  Destruct the CDeviceExt object allocated in the device extension
    //  The appropriate delete operator is called. delete (void*, void*)
    //
    PDEVICE_OBJECT pDevice = pDriver->DeviceObject;
    static_cast<CDeviceExt*>(pDevice->DeviceExtension)->~CDeviceExt();
    delete g_pPacketScheduler;
    delete g_pReceiveScheduler;

    //
    //  Delete the device from kernel tables.
    //
    IoDeleteDevice(pDevice);

    WPP_CLEANUP(pDriver);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\kernel95.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    kernel95.cxx

Abstract:

    This module simulates some NT kernel api on Win95.

Author:

    Erez Haba (erezh) 8-Sep-96

Environment:

    User Mode

Revision History:

--*/

#include "internal.h"
#include "lock.h"
#include "dump.h"


//----------------------------------------------------------------------------
//
//  Io API
//
//----------------------------------------------------------------------------
CLock g_CancelSpinLock;

EXTERN_C
NTKERNELAPI
VOID
IoAcquireCancelSpinLock(
    OUT PKIRQL /*Irql*/
    )
{
    g_CancelSpinLock.Lock();
}

EXTERN_C
NTKERNELAPI
VOID
IoReleaseCancelSpinLock(
    IN KIRQL /*Irql*/
    )
{
    g_CancelSpinLock.Unlock();
}

EXTERN_C
NTKERNELAPI
VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    )
{
    PAGED_CODE();

    //
    // Set the access type in the file object for the current accessor.
    //

    FileObject->ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE
        | FILE_READ_DATA)) != 0);
    FileObject->WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA
        | FILE_APPEND_DATA)) != 0);
    FileObject->DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);

    //
    // Check to see whether the current file opener would like to read,
    // write, or delete the file.  If so, account for it in the share access
    // structure; otherwise, skip it.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        //
        // Only update the share modes if the user wants to read, write or
        // delete the file.
        //

        FileObject->SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);
        FileObject->SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);
        FileObject->SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);

        //
        // Set the Share Access structure open count.
        //

        ShareAccess->OpenCount = 1;

        //
        // Set the number of readers, writers, and deleters in the Share Access
        // structure.
        //

        ShareAccess->Readers = FileObject->ReadAccess;
        ShareAccess->Writers = FileObject->WriteAccess;
        ShareAccess->Deleters = FileObject->DeleteAccess;

        //
        // Set the number of shared readers, writers, and deleters in the Share
        // Access structure.
        //

        ShareAccess->SharedRead = FileObject->SharedRead;
        ShareAccess->SharedWrite = FileObject->SharedWrite;
        ShareAccess->SharedDelete = FileObject->SharedDelete;

    } else {

        //
        // No read, write, or delete access has been requested.  Simply zero
        // the appropriate fields in the structure so that the next accessor
        // sees a consistent state.
        //

        ShareAccess->OpenCount = 0;
        ShareAccess->Readers = 0;
        ShareAccess->Writers = 0;
        ShareAccess->Deleters = 0;
        ShareAccess->SharedRead = 0;
        ShareAccess->SharedWrite = 0;
        ShareAccess->SharedDelete = 0;
    }
}

EXTERN_C
NTKERNELAPI
NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    )
{
    ULONG ocount;

    PAGED_CODE();

    //
    // Set the access type in the file object for the current accessor.
    // Note that reading and writing attributes are not included in the
    // access check.
    //

    FileObject->ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE
        | FILE_READ_DATA)) != 0);
    FileObject->WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA
        | FILE_APPEND_DATA)) != 0);
    FileObject->DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);

    //
    // There is no more work to do unless the user specified one of the
    // sharing modes above.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        FileObject->SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);
        FileObject->SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);
        FileObject->SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);

        //
        // Now check to see whether or not the desired accesses are compatible
        // with the way that the file is currently open.
        //

        ocount = ShareAccess->OpenCount;

        if ( (FileObject->ReadAccess && (ShareAccess->SharedRead < ocount))
             ||
             (FileObject->WriteAccess && (ShareAccess->SharedWrite < ocount))
             ||
             (FileObject->DeleteAccess && (ShareAccess->SharedDelete < ocount))
             ||
             ((ShareAccess->Readers != 0) && !FileObject->SharedRead)
             ||
             ((ShareAccess->Writers != 0) && !FileObject->SharedWrite)
             ||
             ((ShareAccess->Deleters != 0) && !FileObject->SharedDelete)
           ) {

            //
            // The check failed.  Simply return to the caller indicating that the
            // current open cannot access the file.
            //

            return STATUS_SHARING_VIOLATION;

        //
        // The check was successful.  Update the counter information in the
        // shared access structure for this open request if the caller
        // specified that it should be updated.
        //

        } else if (Update) {

            ShareAccess->OpenCount++;

            ShareAccess->Readers += FileObject->ReadAccess;
            ShareAccess->Writers += FileObject->WriteAccess;
            ShareAccess->Deleters += FileObject->DeleteAccess;

            ShareAccess->SharedRead += FileObject->SharedRead;
            ShareAccess->SharedWrite += FileObject->SharedWrite;
            ShareAccess->SharedDelete += FileObject->SharedDelete;
        }
    }
    return STATUS_SUCCESS;
}

EXTERN_C
NTKERNELAPI
VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    )
{
    PAGED_CODE();

    //
    // If this accessor wanted some type of access other than READ_ or
    // WRITE_ATTRIBUTES, then account for the fact that he has closed the
    // file.  Otherwise, he hasn't been accounted for in the first place
    // so don't do anything.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        //
        // Decrement the number of opens in the Share Access structure.
        //

        ShareAccess->OpenCount--;

        //
        // For each access type, decrement the appropriate count in the Share
        // Access structure.
        //

        if (FileObject->ReadAccess) {
            ShareAccess->Readers--;
        }

        if (FileObject->WriteAccess) {
            ShareAccess->Writers--;
        }

        if (FileObject->DeleteAccess) {
            ShareAccess->Deleters--;
        }

        //
        // For each shared access type, decrement the appropriate count in the
        // Share Access structure.
        //

        if (FileObject->SharedRead) {
            ShareAccess->SharedRead--;
        }

        if (FileObject->SharedWrite) {
            ShareAccess->SharedWrite--;
        }

        if (FileObject->SharedDelete) {
            ShareAccess->SharedDelete--;
        }
    }
}

EXTERN_C
NTKERNELAPI
NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN PUNICODE_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    )
{
    const int DEVICE_SIZE = sizeof(DEVICE_OBJECT) + DeviceExtensionSize;
    PDEVICE_OBJECT pDevice = (PDEVICE_OBJECT)(new (PagedPool) CHAR[DEVICE_SIZE]);
    RtlZeroMemory(pDevice, DEVICE_SIZE);
    pDevice->DeviceExtension = ((UCHAR*)(pDevice)) + sizeof(DEVICE_OBJECT);

    *DeviceObject = pDevice;
    DriverObject->DeviceObject = pDevice;
    return STATUS_SUCCESS;
}

EXTERN_C
NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
    IN PIRP irp,
    IN CCHAR /*PriorityBoost*/
    )
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    irp->PendingReturned = (BOOLEAN)(irpSp->Control & SL_PENDING_RETURNED);

    //
    // Check to see whether there is any data in a system buffer which needs
    // to be copied to the caller's buffer.  If so, copy the data and then
    // free the system buffer if necessary.
    //
    if (irp->Flags & IRP_BUFFERED_IO)
    {
        //
        // Copy the data if this was an input operation.  Note that no copy
        // is performed if the status indicates that a verify operation is
        // required, or if the final status was an error-level severity.
        //
        if (irp->Flags & IRP_INPUT_OPERATION  &&
            irp->IoStatus.Status != STATUS_VERIFY_REQUIRED &&
            !NT_ERROR( irp->IoStatus.Status ))
        {
            //
            // Copy the information from the system buffer to the caller's
            // buffer.  This is done with an exception handler in case
            // the operation fails because the caller's address space
            // has gone away, or it's protection has been changed while
            // the service was executing.
            //
            __try
            {
                RtlCopyMemory( irp->UserBuffer,
                               irp->AssociatedIrp.SystemBuffer,
                               irp->IoStatus.Information );
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                //
                // An exception occurred while attempting to copy the
                // system buffer contents to the caller's buffer.  Set
                // a new I/O completion status.
                //
                irp->IoStatus.Status = GetExceptionCode();
            }
        }

        //
        // Free the buffer if needed.
        //

        if (irp->Flags & IRP_DEALLOCATE_BUFFER)
        {
            delete irp->AssociatedIrp.SystemBuffer;
        }
    }

    //
    // Check to see whether or not the I/O operation actually completed.  If
    // it did, then proceed normally.  Otherwise, cleanup everything and get
    // out of here.
    //
    if( !NT_ERROR( irp->IoStatus.Status ) ||
        (NT_ERROR( irp->IoStatus.Status ) && irp->PendingReturned))
    {
        if(irp->UserIosb)
        {
            *irp->UserIosb = irp->IoStatus;
        }

        if(irp->UserEvent)
        {
            SetEvent(irp->UserEvent);
        }

    }

    delete irp;
}

//----------------------------------------------------------------------------
//
//  Ke API
//
//----------------------------------------------------------------------------

#if 0  // BUGBUG


typedef void (WINAPIV *PSCHED_ROUTINE)(void *, DWORD);

EXTERN_C
void
APIENTRY
QMSetTimer(
    IN DWORD msec,
    IN PSCHED_ROUTINE pRoutine,
    IN void* pThis,
    IN DWORD ObjDefined
    );

EXTERN_C
VOID
APIENTRY
QMKillTimer(
    PVOID pThis
    );


#endif



EXTERN_C
NTKERNELAPI
BOOLEAN
KeCancelTimer (
    IN PKTIMER Timer
    )
{
#if 0  // BUGBUG
    QMKillTimer(Timer->Dpc);
#endif

    return TRUE;
}


VOID
WINAPIV
KepDefferedRoutine(
    void* pContext,
    ULONG /*dwContext*/
    )
{
    PKDPC Dpc = (PKDPC)pContext;
    Dpc->DeferredRoutine(Dpc, Dpc->DeferredContext, 0, 0);
}


EXTERN_C
NTKERNELAPI
BOOLEAN
KeSetTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc OPTIONAL
    )
{
    Timer->Dpc = Dpc;

    KeCancelTimer(Timer);

    LARGE_INTEGER liTime;
    KeQuerySystemTime(&liTime);
    DueTime.QuadPart -= liTime.QuadPart;
    DueTime.QuadPart /= 10000;
    ULONG msec = 0x7fffffff;
    if(DueTime.QuadPart < msec)
    {
        msec = DueTime.LowPart;
    }

#if 0  // BUGBUG
    QMSetTimer(msec, KepDefferedRoutine, Dpc, 0);
#endif

    return TRUE;
}


EXTERN_C
NTKERNELAPI                                         
NTSTATUS                                            
KeDelayExecutionThread (                            
    IN KPROCESSOR_MODE WaitMode,                    
    IN BOOLEAN Alertable,                           
    IN PLARGE_INTEGER Interval                      
    )
{
    Sleep(100);
    return STATUS_SUCCESS;
}


//----------------------------------------------------------------------------
//
//  Mm API
//
//----------------------------------------------------------------------------

EXTERN_C
NTKERNELAPI
NTSTATUS
NTAPI
MmCreateSection (
    OUT PVOID *SectionObject,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL
    )
{
    ASSERT(ObjectAttributes == 0);

    HANDLE hSection;
    hSection = CreateFileMapping(
                    FileHandle,
                    0,
                    AllocationAttributes | SectionPageProtection,
                    MaximumSize->HighPart,
                    MaximumSize->LowPart,
                    0
                    );

    *SectionObject = hSection;
    return ((hSection != 0) ? STATUS_SUCCESS : STATUS_OPEN_FAILED);
}

EXTERN_C
NTKERNELAPI
NTSTATUS
NTAPI
MmMapViewOfSection(
    IN PVOID SectionToMap,
    IN PEPROCESS Process,
    IN OUT PVOID *CapturedBase,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset,
    IN OUT PULONG CapturedViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    )
{
    PVOID pBase;
    pBase = MapViewOfFile(
                SectionToMap,
                AC_FILE_MAP_ACCESS,
                SectionOffset->HighPart,
                SectionOffset->LowPart,
                *CapturedViewSize
                );
    *CapturedBase = pBase;
    return ((pBase != 0) ? STATUS_SUCCESS : STATUS_OPEN_FAILED);
}

EXTERN_C
NTKERNELAPI
NTSTATUS
NTAPI
MmUnmapViewOfSection(
    IN PEPROCESS /*Process*/,
    IN PVOID BaseAddress
    )
{
    BOOL f = UnmapViewOfFile(BaseAddress);
    return ((f) ? STATUS_SUCCESS : STATUS_OPEN_FAILED);
}

//----------------------------------------------------------------------------
//
//  Zw API
//
//----------------------------------------------------------------------------

EXTERN_C
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL
    )
{
    ASSERT(ObjectAttributes == 0);

    *SectionHandle = CreateFileMapping(
                    FileHandle,
                    0,
                    AllocationAttributes | SectionPageProtection,
                    MaximumSize->HighPart,
                    MaximumSize->LowPart,
                    0
                    );

    return ((*SectionHandle != 0) ? STATUS_SUCCESS : STATUS_OPEN_FAILED);
}

EXTERN_C
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID /*EaBuffer*/,
    IN ULONG /*EaLength*/
    )
{
    ASSERT(FileAttributes == FILE_ATTRIBUTE_NORMAL);
    ASSERT(CreateDisposition == FILE_OPEN_IF);
    ASSERT(CreateOptions ==
            (FILE_WRITE_THROUGH |
            FILE_NO_INTERMEDIATE_BUFFERING |
            FILE_SYNCHRONOUS_IO_NONALERT));

    *FileHandle = CreateFile(
                    ObjectAttributes->ObjectName->Buffer,
                    DesiredAccess,
                    ShareAccess,
                    0,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL |
                        FILE_FLAG_WRITE_THROUGH |
                        FILE_FLAG_NO_BUFFERING,
                    0
                    );

    return ((*FileHandle != INVALID_HANDLE_VALUE) ? STATUS_SUCCESS : STATUS_OPEN_FAILED);
}

EXTERN_C
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )
{
    ASSERT(FileInformationClass == FileEndOfFileInformation);
    ASSERT(Length == sizeof(LARGE_INTEGER));
    PLARGE_INTEGER pli = (PLARGE_INTEGER)FileInformation;

    SetFilePointer(
        FileHandle,
        pli->LowPart,
        &pli->HighPart,
        FILE_BEGIN
        );

    SetEndOfFile(FileHandle);

    //
    //  write meta file information to disk (i.e., FAT)
    //
    FlushFileBuffers(FileHandle);

    return STATUS_SUCCESS;
}

EXTERN_C
NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN HANDLE Handle
    )
{
    BOOL f = CloseHandle(Handle);
    return ((f) ? STATUS_SUCCESS : STATUS_OPEN_FAILED);
}


EXTERN_C
NTKERNELAPI
NTSTATUS
NTAPI
ZwDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{

#ifdef MQDUMP
    //
    // Mqdump should do read only operations.
    //
    return STATUS_SUCCESS;

#else

    BOOL f = DeleteFile(ObjectAttributes->ObjectName->Buffer);
    return ((f) ? STATUS_SUCCESS : STATUS_OPEN_FAILED);
    
#endif // MQDUMP
}

EXTERN_C
NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )
{
    ASSERT(Event == 0);
    ASSERT(ApcRoutine == 0);
    ASSERT(ApcContext == 0);

    SetFilePointer(
        FileHandle,
        ByteOffset->LowPart,
        &ByteOffset->HighPart,
        FILE_BEGIN
        );

    BOOL f = ReadFile(
                FileHandle,
                Buffer,
                Length,
                &IoStatusBlock->Information,
                0
                );

    IoStatusBlock->Status = (f) ? STATUS_SUCCESS : STATUS_OPEN_FAILED;
    return IoStatusBlock->Status;
}

EXTERN_C
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )
{
    ASSERT(Event == 0);
    ASSERT(ApcRoutine == 0);
    ASSERT(ApcContext == 0);

    SetFilePointer(
        FileHandle,
        ByteOffset->LowPart,
        &ByteOffset->HighPart,
        FILE_BEGIN
        );

    BOOL f = WriteFile(
                FileHandle,
                Buffer,
                Length,
                &IoStatusBlock->Information,
                0
                );

    IoStatusBlock->Status = (f) ? STATUS_SUCCESS : STATUS_OPEN_FAILED;
    return IoStatusBlock->Status;
}

//----------------------------------------------------------------------------
//
//  Rtl API
//
//----------------------------------------------------------------------------

EXTERN_C
NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    )
{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString ))
    {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
    }
    else
    {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\localsend.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    LocalSend.cxx

Abstract:

    AC Local Send Processing Requests Manager

Author:

    Shai Kariv (shaik) 31-Oct-2000

Revision History:

--*/

#include "internal.h"
#include "lock.h"
#include "LocalSend.h"
#include "packet.h"
#include "queue.h"
#include "qxact.h"
#include "data.h"
#include "acheap.h"
#include "acp.h"
#include "qm.h"
#include "irp2pkt.h"

#ifndef MQDUMP
#include "LocalSend.tmh"
#endif

//---------------------------------------------------------
//
//  ACCancelSender
//
//---------------------------------------------------------

static
VOID
ACCancelSender(
    IN PDEVICE_OBJECT /*pDevice*/,
    IN PIRP irp
    )
{
    //
    // Remove irp from list
    //
    ACpRemoveEntryList(&irp->Tail.Overlay.ListEntry);

    //
    // Release cancel spinlock
    //
    IoReleaseCancelSpinLock(irp->CancelIrql);

    //
    // Grab AC global lock
    //
    TrTRACE(AC, "ACCancelSender (irp=0x%p)", irp);
    CS lock(g_pLock);

    //
    // Mark irp as not held and call handler on the queue/distribution to cleanup irp.
    //
    if (irp_driver_context(irp)->MultiPackets())
    {
        CIrp2Pkt::IsHeld(irp, false);
    }
    CPacket * pPacket = CIrp2Pkt::SafePeekFirstPacket(irp);
    ASSERT(pPacket->Queue() != NULL);
    pPacket->Queue()->HandleCreatePacketCompletedFailureAsync(irp);

    //
    // Complete the irp
    //
    irp->IoStatus.Information = 0;
    irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}


//---------------------------------------------------------
//
//  class CCreatePacket
//
//---------------------------------------------------------

void CCreatePacket::HoldCreatePacketRequest(PIRP irp)
{
    //
    // Grab cancel spinlock
    //
    ASL asl;

    //
    // Packet[s] must be attached on the irp
    //
    ASSERT(CIrp2Pkt::SafePeekFirstPacket(irp) != NULL);

    //
    // irp must not already be held (this field is relevant for multi packets irp only)
    //
    ASSERT(!irp_driver_context(irp)->MultiPackets() || !CIrp2Pkt::IsHeld(irp));

    //
    // Insert irp to list. The IsHeld flag is used only for multi packets irp.
    //
    m_senders.insert(irp);
    if (irp_driver_context(irp)->MultiPackets())
    {
        CIrp2Pkt::IsHeld(irp, true);
    }

    //
    // Set the irp as pending and cancellable
    //
    ASSERT(irp->CancelRoutine == 0);
    IoSetCancelRoutine(irp, ACCancelSender);
    IoMarkIrpPending(irp);
}


bool CCreatePacket::ReplaceCreatePacketRequestContext(CPacket * pOld, CPacket * pNew)
{
    ASSERT(pOld != NULL);
    ASSERT(pNew != NULL);

    //
    // Grab cancel spinlock
    //
    ASL asl;

    for(CIRPList::Iterator p(m_senders); p; ++p)
    {
        PIRP irp = p;
        if (!irp_driver_context(irp)->MultiPackets())
        {
            if (CIrp2Pkt::PeekSinglePacket(irp) == pOld)
            {
                CIrp2Pkt::AttachSinglePacket(irp, pNew);
                return true;
            }

            continue;
        }

        ASSERT(CIrp2Pkt::IsHeld(irp));
        List<CPacketIterator::CEntry>& entries = CIrp2Pkt::GetPacketIteratorEntries(irp);
        for(List<CPacketIterator::CEntry>::Iterator pEntry(entries); 
            pEntry != NULL; 
            ++pEntry)
        {
            ASSERT(pEntry->m_pPacket != NULL);
            if (pEntry->m_pPacket == pOld)
            {
                pEntry->m_pPacket = pNew;
                return true;
            }
        }
    }

    return false;

} // CCreatePacket::ReplaceCreatePacketRequestContext


PIRP CCreatePacket::GetCreatePacketRequest(CPacket * pContext)
{
    ASL asl;

    TrTRACE(AC, "* CCreatePacket::GetCreatePacketRequest, context=%p *", pContext);
    for(CIRPList::Iterator p(m_senders); p; ++p)
    {
        PIRP irp = p;
        if (!irp_driver_context(irp)->MultiPackets())
        {
            if (CIrp2Pkt::PeekSinglePacket(irp) == pContext)
            {
                IoSetCancelRoutine(irp, 0);
                m_senders.remove(irp);
                return irp;
            }

            continue;
        }

        ASSERT(CIrp2Pkt::IsHeld(irp));
        TrTRACE(AC, "* CCreatePacket::GetCreatePacketRequest, irp is multi packet *");
        List<CPacketIterator::CEntry>& entries = CIrp2Pkt::GetPacketIteratorEntries(irp);
        for(List<CPacketIterator::CEntry>::Iterator pEntry(entries); 
            pEntry != NULL; 
            ++pEntry)
        {
            ASSERT(pEntry->m_pPacket != NULL);
            TrTRACE(AC, "* CCreatePacket::GetCreatePacketRequest, packet=%p *", pEntry->m_pPacket);

            if (pEntry->m_pPacket == pContext)
            {
                IoSetCancelRoutine(irp, 0);
                CIrp2Pkt::DecreasePacketsPendingCreateCounter(irp);
                m_senders.remove(irp);
                CIrp2Pkt::IsHeld(irp, false);
                return irp;
            }
        }
    }

    return 0;

} // CCreatePacket::GetCreatePacketRequest

                     
//---------------------------------------------------------
//
//  ACpCompleteCreatePacket
//
//---------------------------------------------------------

static
void
ACpCompleteCreatePacket(
    CPacket* pPacket,
    NTSTATUS status,
    USHORT   ack
   )
{
    ASSERT(pPacket != NULL);

    CS lock(g_pLock);

	pPacket->HandleCreatePacketCompleted(status, ack);

    //
    // Decrement ref count of the processing.
    //
	
    pPacket->Release();
}

//---------------------------------------------------------
//
//  ACCancelCreatePacketNotification
//
//---------------------------------------------------------
VOID
ACCancelCreatePacketNotification(
    IN PDEVICE_OBJECT /*pDevice*/,
    IN PIRP irp
    )
{
    ACpRemoveEntryList(&irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(irp->CancelIrql);

    TrTRACE(AC, "ACCancelCreatePacketNotification (irp=0x%p)", irp);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    CPacket * pPacket = static_cast<CPacket*>(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

    ACpCompleteCreatePacket(
        pPacket,
        STATUS_CANCELLED,
        0
        );

    irp->IoStatus.Information = 0;
    irp->IoStatus.Status = STATUS_CANCELLED;

    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

//---------------------------------------------------------
//
//  class CCreatePacketComplete
//
//---------------------------------------------------------

void CCreatePacketComplete::HoldNotification(PIRP irp)
{
    {
        ASL asl;

        m_notifications.insert(irp);
        ASSERT(irp->CancelRoutine == 0);
        IoSetCancelRoutine(irp, ACCancelCreatePacketNotification);
        IoMarkIrpPending(irp);
    }

    if(!m_fWorkItemInQueue)
    {
        m_fWorkItemInQueue = true;
        IoQueueWorkItem(m_pWorkItem, WorkerRoutine, DelayedWorkQueue, 0);
    }
}


void CCreatePacketComplete::HandleNotification(PIRP irp)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    CPacket * pOld = static_cast<CPacket*>(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);
    CPacket * pNew = static_cast<CPacket*>(irp->UserBuffer);

    #ifdef _DEBUG
    {
        NTSTATUS status = static_cast<NTSTATUS>(irpSp->Parameters.DeviceIoControl.InputBufferLength);
        USHORT ack = static_cast<USHORT>(irpSp->Parameters.DeviceIoControl.OutputBufferLength);
        ASSERT(pOld != NULL);

        if (ack != 0)
        {
            ASSERT(("NACK is viewed by sender as success!", NT_SUCCESS(status)));
        }

        if (pNew != NULL)
        {
            ASSERT(("new packet must be different than old one!", pNew != pOld));
            ASSERT(("new packet implies status success!", NT_SUCCESS(status)));
        }
    }
    #endif // _DEBUG

	//
	// Release the buffer since QM has finished the processing.
	//
	pOld->ReleaseBuffer();
    
	if (pNew != NULL)
    {
		//
		// If we have a new packet - release its buffer too.
		//
		pNew->ReleaseBuffer();

        //
        // Replace old packet with new one on the irp.
        //
		bool fReplaced = g_pCreatePacket->ReplaceCreatePacketRequestContext(pOld, pNew);
		if (fReplaced)
        {
			//
			// At this point the irp may be taken out by ACCancelSender (although we replaced
			// the packets). This means that ACCancelSender will work on the new packet 
			// instead of the old one on the irp. 
			//
			pNew->Queue(pOld->Queue());
			pOld->Queue(NULL);
			pNew->Transaction(pOld->Transaction());
			pOld->Transaction(NULL);
		
			//
			// Addref new packet for processing and attach.
			//
			pNew->AddRef();
			pNew->AddRef();
			
			//
			// Release old packet attach and creation.
			//
			pOld->Release();
			pOld->Release();
			
        }
	
		// 
		// Else - if irp was not found we should release new packet creation and addref
		// for processing -> do nothing.
		// (ACCancelSender will release old packet creation and attach)
		//

		//
		// Release old packet request.
		//
		pOld->Release();

		//
		// Keep pointing at the new packet only
		//
		irp->UserBuffer = NULL;
		irpSp->Parameters.DeviceIoControl.Type3InputBuffer = pNew;
        
    }

	//
	// Else - if pNew = NULL we should release old packet request and addref for processing
	// -> do nothing.
	//

	HoldNotification(irp);

    

} // CCreatePacketComplete::HandleNotification


inline PIRP CCreatePacketComplete::GetNotification()
{
    ASL asl;
    PIRP irp = m_notifications.gethead();
    if(irp != 0)
    {
        IoSetCancelRoutine(irp, 0);
    }

    return irp;
}


inline void CCreatePacketComplete::CompleteCreatePacket()
{
    m_fWorkItemInQueue = false;

    PIRP irp;
    while((irp = GetNotification()) != 0)
    {
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
        CPacket * pPacket = static_cast<CPacket*>(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);
        NTSTATUS status = static_cast<NTSTATUS>(irpSp->Parameters.DeviceIoControl.InputBufferLength);
        USHORT ack = static_cast<USHORT>(irpSp->Parameters.DeviceIoControl.OutputBufferLength);

        ACpCompleteCreatePacket(
            pPacket,
            status,
            ack
            );

        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = STATUS_SUCCESS;

        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}

void NTAPI CCreatePacketComplete::WorkerRoutine(PDEVICE_OBJECT, PVOID)
{
    g_pCreatePacketComplete->CompleteCreatePacket();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\object.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    object.h

Abstract:

    Abstruct object for refrence count and list entry: declaration

Author:

    Erez Haba (erezh) 17-Apr-96

Revision History:

    Milena Salman (msalman) 10-Nov-2001
--*/

#ifndef __OBJECT_H
#define __OBJECT_H


//---------------------------------------------------------
//
//  Class debugging macros
//
//---------------------------------------------------------

#ifdef _DEBUG

#define DEFINE_G_TYPE(c)        int c::g_type = 0

#define STATIC_G_TYPE           static int g_type
#define STATIC_PVOID_TYPE()     static PVOID Type() { return &g_type; }

#define VIRTUAL_BOOL_ISKINDOF()\
    virtual BOOL isKindOf(PVOID pType) const\
    { return ((Type() == pType) || Inherited::isKindOf(pType)); }

#define CLASS_DEBUG_TYPE()\
    public:  STATIC_PVOID_TYPE(); VIRTUAL_BOOL_ISKINDOF();\
    private: STATIC_G_TYPE;

#define BASE_VIRTUAL_BOOL_ISKINDOF()\
    virtual BOOL isKindOf(PVOID) const { return FALSE; }

#define BASE_CLASS_DEBUG_TYPE()\
    public:  BASE_VIRTUAL_BOOL_ISKINDOF();

#else // _DEBUG

#define DEFINE_G_TYPE(c)
#define CLASS_DEBUG_TYPE()
#define BASE_CLASS_DEBUG_TYPE()

#endif // _DEBUG

//---------------------------------------------------------
//
//  class CBaseObject 
//
//---------------------------------------------------------

class CBaseObject {
public:
    CBaseObject();
    virtual ~CBaseObject() = 0;

    ULONG Ref() const;
    ULONG AddRef();
    ULONG Release();
    ULONG m_ref;

    BASE_CLASS_DEBUG_TYPE();
};

//---------------------------------------------------------
//
//  class CObject
//
//---------------------------------------------------------

class CObject : public CBaseObject {
public:
    CObject();
    LIST_ENTRY m_link;
};

#endif // __OBJECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\nt95.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nt95.cxx

Abstract:

    This module simulates some NT api on Win95.

Author:

    Erez Haba (erezh) 8-Sep-96

Environment:

    User Mode

Revision History:

--*/

#include "internal.h"

DRIVER_OBJECT g_ACDriverObject;
UNICODE_STRING g_ACDriverName = {0, 0, L"\\mqac"};

//
//  Helpsers
//
static
PIRP
ACpAllocateIrp(
    VOID
    )
{
    //
    //  Allocate an IRP and 1 (one) stack location
    //
    const int IRP_SIZE = sizeof(IRP) + sizeof(IO_STACK_LOCATION);
    PIRP irp = reinterpret_cast<PIRP>(new (NonPagedPool) CHAR[IRP_SIZE]);
    RtlZeroMemory(irp, IRP_SIZE);

    //
    // Initialize the remainder of the packet by setting the appropriate fields
    // and setting up the I/O stack locations in the packet.
    //
    irp->Type = (CSHORT) IO_TYPE_IRP;
    irp->Size = (USHORT) IRP_SIZE;
    irp->StackCount = (CCHAR) 1;
    irp->CurrentLocation = (CCHAR) (1);
    irp->ApcEnvironment = 0;

    irp->Tail.Overlay.CurrentStackLocation =
        (PIO_STACK_LOCATION) (((UCHAR*)(irp)) + sizeof(IRP));

    return irp;
}

inline
VOID
ACpSetFileObject(
    PIRP irp,
    PFILE_OBJECT pFileObject
    )
{
    IoGetCurrentIrpStackLocation(irp)->FileObject = pFileObject;
}

inline
VOID
ACpInitialize(
    VOID
    )
{
    NTSTATUS rc;
    rc = DriverEntry(&g_ACDriverObject, &g_ACDriverName);
    if(!NT_SUCCESS(rc))
    {
        exit(rc);
    }
}

//---------------------------------------------------------
//
//  Nt API
//
//---------------------------------------------------------

EXTERN_C
__declspec(dllexport)
HANDLE
NTAPI
ACpCreateFileW(
    LPCWSTR lpFileName,
    ULONG dwDesiredAccess,
    ULONG dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    ULONG dwCreationDisposition,
    ULONG dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    //
    //  we need to allocate a file object (with refrence) and call ACCreate.
    //
    PFILE_OBJECT pFileObject = new FILE_OBJECT;
    RtlZeroMemory(pFileObject, sizeof(FILE_OBJECT));

    //
    // Save the desired access on file object. 
    //
    pFileObject->Busy = 0; 
    if (dwDesiredAccess & (FILE_READ_DATA | GENERIC_READ))
    {
        pFileObject->Busy |= FILE_READ_DATA;
    }
    if (dwDesiredAccess & (FILE_WRITE_DATA | GENERIC_WRITE))
    {
        pFileObject->Busy |= FILE_WRITE_DATA;
    }

    PIRP irp = ACpAllocateIrp();
    ACpSetFileObject(irp, pFileObject);
    ACCreate(g_ACDriverObject.DeviceObject, irp);

    return pFileObject;
}

EXTERN_C
__declspec(dllexport)
BOOL
NTAPI
ACpDuplicateHandle(
    HANDLE hSourceProcessHandle,    // handle to process with handle to duplicate 
    HANDLE hSourceHandle,           // handle to duplicate 
    HANDLE hTargetProcessHandle,    // handle to process to duplicate to 
    LPHANDLE lpTargetHandle,        // pointer to duplicate handle 
    ULONG ulDesiredAccess,          // access for duplicate handle 
    BOOL bInheritHandle,            // handle inheritance flag
    ULONG ulOptions                 // optional actions 
   )
{
    ASSERT(ulOptions == DUPLICATE_CLOSE_SOURCE);
    ASSERT(bInheritHandle == TRUE);
    ASSERT(hSourceHandle != NULL);

    PFILE_OBJECT pFileObject = (PFILE_OBJECT) hSourceHandle;

    //
    // Save the desired access on file object. 
    //
    pFileObject->Busy = ulDesiredAccess; 
    *lpTargetHandle = hSourceHandle;

    return (TRUE);
}

EXTERN_C
__declspec(dllexport)
NTSTATUS
NTAPI
NtClose(
    IN HANDLE Handle
    )
{
    //
    //  call AC
    //
    PIRP irp = ACpAllocateIrp();
    ACpSetFileObject(irp, (PFILE_OBJECT)Handle);
    NTSTATUS rc;
    rc = ACCleanup(g_ACDriverObject.DeviceObject, irp);
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    irp = ACpAllocateIrp();
    ACpSetFileObject(irp, (PFILE_OBJECT)Handle);
    rc = ACClose(g_ACDriverObject.DeviceObject, irp);
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }
    delete Handle;

    return rc;
}

EXTERN_C
__declspec(dllexport)
NTSTATUS
NTAPI
NtDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )
{
    PAGED_CODE();

    //
    // Get the method that the buffers are being passed.
    //
    ULONG method = IoControlCode & 3;

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    NTSTATUS rc;
    PFILE_OBJECT fileObject;
    rc = ObReferenceObjectByHandle(
            FileHandle,
            0L,
            IoFileObjectType,
            requestorMode,
            (PVOID *) &fileObject,
            &handleInformation
            );
    if (!NT_SUCCESS( rc ))
    {
        return rc;
    }

    //---------------------------------------------------------
    //
    // Now check the access type for this control code to ensure that the
    // caller has the appropriate access to this file object to perform the
    // operation.
    //

    ULONG accessMode = (IoControlCode >> 14) & 3;

    if (accessMode != FILE_ANY_ACCESS)
    {

        //
        // This I/O control requires that the caller have read, write,
        // or read/write access to the object.  If this is not the case,
        // then cleanup and return an appropriate error status code.
        //
        if (!(fileObject->Busy & accessMode))
        {
            ObDereferenceObject( fileObject );
            return STATUS_ACCESS_DENIED;
        }
    }
    //---------------------------------------------------------

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here, too, that if
    // the handle does not refer to an event, or if the event cannot be
    // written, then the reference will fail.
    //
    PKEVENT eventObject = (PKEVENT) NULL;
    if (ARGUMENT_PRESENT( Event ))
    {
        rc = ObReferenceObjectByHandle(
                Event,
                EVENT_MODIFY_STATE,
                ExEventObjectType,
                requestorMode,
                (PVOID *) &eventObject,
                NULL
                );
        if (!NT_SUCCESS( rc ))
        {
            ObDereferenceObject( fileObject );
            return rc;
        }

        ResetEvent(Event);
    }

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.

    PIRP irp;
    irp = ACpAllocateIrp();

    irp->Tail.Overlay.OriginalFileObject = fileObject;

    //
    // Fill in the service independent parameters in the IRP.
    //
    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    //  To identify a proc different from 0
    //
    irp->Tail.Overlay.Thread = (PETHREAD)1;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    PIO_STACK_LOCATION irpSp;
    irpSp = IoGetCurrentIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;

    //
    // Based on the method that the buffer are being passed, either allocate
    // buffers or build MDLs.  Note that in some cases no probing has taken
    // place so the exception handler must catch access violations.
    //

    switch ( method )
    {

    case 0:

        //
        // For this case, allocate a buffer that is large enough to contain
        // both the input and the output buffers.  Copy the input buffer to
        // the allocated buffer and set the appropriate IRP fields.
        //
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = (PVOID) NULL;

        if (InputBufferLength || OutputBufferLength)
        {
            irp->AssociatedIrp.SystemBuffer =
                new (NonPagedPool) char[max(InputBufferLength, OutputBufferLength)];

            if (ARGUMENT_PRESENT( InputBuffer ))
            {
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                               InputBuffer,
                               InputBufferLength );
            }
            irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            irp->UserBuffer = OutputBuffer;
            if (ARGUMENT_PRESENT( OutputBuffer ))
            {
                irp->Flags |= IRP_INPUT_OPERATION;
            }
        }
        break;

    case 1:
    case 2:
        //
        //  Falcon AC driver dosen't use this two methods
        //
        ASSERT(0);
        break;

    case 3:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        irp->Flags = 0;
        irp->UserBuffer = OutputBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;
    }

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //
    return ACDeviceControl(g_ACDriverObject.DeviceObject, irp);
}

BOOL APIENTRY DllMain(HANDLE hMod, DWORD dwReason, PVOID /*lpvReserved*/)
{
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            ACpInitialize();
            break;

        case DLL_PROCESS_DETACH:
            NOTHING;
            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\ntp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    ntp.h

Abstract:
    NT APIs not exposed in DDK

Author:
    Erez Haba (erezh) 10-Oct-96

Revision History:
--*/

#ifndef _NTP_H
#define _NTP_H

//
// for winnt we take the definitions below from NT headers in ac\winnt\platform.h
//
#ifdef MQWIN95
//-----------------------------------------------------------------------------
//
//  BUGBUG: These kernel funcitons are NOT exposed to a DDK environment
//          and are used here asuming internal knowldge of PEPROCESS struct
//          and the function parameters.
//

#define SEC_COMMIT        0x8000000

NTKERNELAPI
VOID
NTAPI
KeAttachProcess(
    PEPROCESS
    );

NTKERNELAPI
VOID
NTAPI
KeDetachProcess(
    VOID
    );

NTKERNELAPI
PEPROCESS
NTAPI
IoGetRequestorProcess(
    IN PIRP Irp
    );

NTKERNELAPI
NTSTATUS
NTAPI
MmMapViewOfSection(
    IN PVOID SectionToMap,
    IN PEPROCESS Process,
    IN OUT PVOID *CapturedBase,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset,
    IN OUT PULONG CapturedViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTKERNELAPI
NTSTATUS
NTAPI
MmUnmapViewOfSection(
    IN PEPROCESS Process,
    IN PVOID BaseAddress
    );

NTKERNELAPI
NTSTATUS
NTAPI
MmCreateSection (
    OUT PVOID *SectionObject,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL
    );

NTKERNELAPI
NTSTATUS
NTAPI
ZwDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

#endif //MQWIN95
#endif // _NTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\localsend.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    LocalSend.h

Abstract:

    AC Local Send Processing Requests Manager

Author:

    Shai Kariv (shaik) 31-Oct-2000

Revision History:

--*/

#ifndef __LOCAL_SEND_H
#define __LOCAL_SEND_H

#include "irplist.h"
#include "packet.h"



//---------------------------------------------------------
//
//  class CCreatePacket
//
//---------------------------------------------------------
class CCreatePacket {
public:

    void HoldCreatePacketRequest(PIRP irp);
    bool ReplaceCreatePacketRequestContext(CPacket * pOld, CPacket * pNew);
    PIRP GetCreatePacketRequest(CPacket * pContext);

private:
    CIRPList m_senders;
};

//---------------------------------------------------------
//
//  class CCreatePacketComplete
//
//---------------------------------------------------------
class CCreatePacketComplete {
public:

    CCreatePacketComplete();
    ~CCreatePacketComplete();

    bool AllocateWorkItem(PDEVICE_OBJECT pDevice);
    void HandleNotification(PIRP);

private:
    void HoldNotification(PIRP irp);
    void CompleteCreatePacket();
    PIRP GetNotification();

private:
    static void NTAPI WorkerRoutine(PDEVICE_OBJECT, PVOID);

private:
    CIRPList m_notifications;
    PIO_WORKITEM m_pWorkItem;
    bool m_fWorkItemInQueue;
};


inline CCreatePacketComplete::CCreatePacketComplete() : m_pWorkItem(NULL), m_fWorkItemInQueue(false)
{
}


inline CCreatePacketComplete::~CCreatePacketComplete()
{
    if (m_pWorkItem != NULL)
    {
        IoFreeWorkItem(m_pWorkItem);
    }
}


inline bool CCreatePacketComplete::AllocateWorkItem(PDEVICE_OBJECT pDevice)
{
    ASSERT(m_pWorkItem == NULL);
    m_pWorkItem = IoAllocateWorkItem(pDevice);

    return (m_pWorkItem != NULL);
}


#endif // __LOCAL_SEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\lock.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    lock.h

Abstract:

    provide internal locking mechanism

Author:

    Erez Haba (erezh) 20-Feb-96

Revision History:
--*/

#ifndef _LOCK_H
#define _LOCK_H

//---------------------------------------------------------
//
//  class CLock
//
//---------------------------------------------------------

class CLock {
private:
    FAST_MUTEX m_mutex;

public:
    CLock();
   ~CLock();

    void Lock();
    void Unlock();
};

//---------------------------------------------------------
//
//  class CS
//
//---------------------------------------------------------

class CS {
private:
    CLock* m_lock;

public:
    CS(CLock* lock);
   ~CS();
};

//---------------------------------------------------------
//
//  class ASL
//
//---------------------------------------------------------

class ASL {
private:
    KIRQL m_irql;

public:
    ASL();
   ~ASL();
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

//---------------------------------------------------------
//
//  class CLock
//
//---------------------------------------------------------

inline CLock::CLock()
{
    ExInitializeFastMutex(&m_mutex);
}

inline CLock::~CLock()
{
    //
    //  NT kernel: does nothing, Win95: DeleteCriticalSection
    //
    ExDeleteFastMutex(&m_mutex);
}

inline void CLock::Lock()
{
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&m_mutex);
}

inline void CLock::Unlock()
{
    ExReleaseFastMutexUnsafe(&m_mutex);
    KeLeaveCriticalRegion();
}

//---------------------------------------------------------
//
//  class CS
//
//---------------------------------------------------------

inline CS::CS(CLock* lock) :
    m_lock(lock)
{
    m_lock->Lock();
}

inline CS::~CS()
{
    m_lock->Unlock();
}

//---------------------------------------------------------
//
//  class ASL
//
//---------------------------------------------------------

inline ASL::ASL()
{
    IoAcquireCancelSpinLock(&m_irql);
}

inline ASL::~ASL()
{
    IoReleaseCancelSpinLock(m_irql);
}

#endif // _LOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\object.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    object.cxx

Abstract:

    Abstruct object for refrence count and list entry: implementation

Author:

    Shai Kariv  (shaik)  05-Apr-2001

Environment:

    Kernel mode

Revision History:

    Milena Salman (msalman) 10-Nov-2001

--*/

#include "internal.h"
#include "object.h"

#ifndef MQDUMP
#include "object.tmh"
#endif


//---------------------------------------------------------
//
// class CBaseObject
//
//---------------------------------------------------------


CBaseObject::CBaseObject() :
    m_ref(1)
{
}

CBaseObject::~CBaseObject()
{
    ASSERT(m_ref == 0);
}

ULONG CBaseObject::Ref() const
{
    return m_ref;
}

ULONG CBaseObject::AddRef()
{
    TrTRACE(AC, " *AddRef(0x%0p) = %d*", this, m_ref + 1);
    return ++m_ref;
}

ULONG CBaseObject::Release()
{
    ASSERT(m_ref > 0);
    TrTRACE(AC, " *Release(0x%0p) = %d*", this, m_ref - 1);
    if(--m_ref > 0)
    {
        return m_ref;
    }

    delete this;
    return 0;
}

//---------------------------------------------------------
//
// class CObject
//
//---------------------------------------------------------

CObject::CObject() 
{
    InitializeListHead(&m_link);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\packet.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

      packet.cxx

Abstract:

    Implement packet member functions

Author:

    Erez Haba (erezh) 4-Feb-96
    Shai Kariv (shaik) 11-Apr-2000

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "data.h"
#include "qm.h"
#include "packet.h"
#include "cursor.h"
#include "acp.h"
#include "actempl.h"
#include <wchar.h>
#include <mqformat.h>
#include <mqfutils.h>
#include "queue.h"
#include "qxact.h"
#include "acheap.h"
#include "sched.h"
#include "store.h"
#include "LocalSend.h"
#include "lock.h"
#include "crc32.h"
#include "acctl32.h"
#include "dl.h"
#include "irp2pkt.h"

#ifndef MQDUMP
#include "packet.tmh"
#endif

//
// Dummy function to link ph files
//
void ReportAndThrow(LPCSTR)
{
	ASSERT(0);
}


#pragma warning(disable: 4238)  //  nonstandard extension used : class rvalue used as lvalue

#define MESSAGE_ID_UPDATE    0x400

ULONGLONG ACpGetSequentialID()
{
    if((g_MessageSequentialID % MESSAGE_ID_UPDATE) == 0)
    {
        //
        //  Save the message id every 1024 messges starting with the first
        //  message sent.
        //
        CACRequest request(CACRequest::rfMessageID);
        request.MessageID.Value = g_MessageSequentialID + (MESSAGE_ID_UPDATE * 2);

        g_pQM->ProcessRequest(request);
    }

    return (++g_MessageSequentialID);
}


   
//---------------------------------------------------------
//
// class CQEntry
//
//---------------------------------------------------------

CQEntry::~CQEntry()
{
    ASSERT(!ACpEntryInTree(m_treenode));
    if(BufferAttached())
    {
        ac_free(Allocator(), m_abo);
    }
    if (m_bfOtherPacket && m_pOtherPacket)
    {
        m_pOtherPacket->Release() ;
    }
}


void CQEntry::TargetQueue(CQueue* pQueue)
{
    m_bfOtherPacket = FALSE;

    ACpAddRef(pQueue);
    ACpRelease(m_pTargetQueue);
    m_pTargetQueue = pQueue;
}


void CQEntry::OtherPacket(CPacket* pPacket)
{
    m_bfOtherPacket = TRUE;

    ACpAddRef(pPacket);
    ACpRelease(m_pOtherPacket);
    m_pOtherPacket = pPacket;
}


//---------------------------------------------------------
//
// class CPacket
//
//---------------------------------------------------------

inline
CPacket::CPacket(
    CMMFAllocator* pAllocator,
    CAllocatorBlockOffset abo
    ) :
    CQEntry(pAllocator, abo)
{
    //
    //  NOTE:   The constructor is inlined in the cxx file in order do desallow
    //          any instantiation of class CPacket by means of linker, that is the
    //          linker will not find the constructor since it is inlined.
    //
}


CPacket::~CPacket()
{
    CQueue *pQueue = Queue();
    if(pQueue)
    {
        pQueue->RemovePacket(this);
    }
}


NTSTATUS
CPacket::Create(
    CPacket** ppPacket,
    ULONG ulPacketSize,
    ACPoolType pt,
    BOOL fCheckMachineQuota
    )
{
    //
    //  Allocate the apporpriate buffer in the shared pool for the
    //  serialized packet.
    //
    CAllocatorBlockOffset abo = CAllocatorBlockOffset::InvalidValue();
    CMMFAllocator* pAllocator;
    abo = ac_malloc(
            &pAllocator,
            pt,
            ulPacketSize + sizeof(CPacketInfo),
            fCheckMachineQuota
            );

    if(!abo.IsValidOffset())
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Get an accessible buffer so we could write it.
    //
    CAccessibleBlock* pab = pAllocator->GetAccessibleBuffer(abo);
    if (pab == 0)
    {
        ac_free(pAllocator, abo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Allocate the Queue entry in pagable memory, and make it point to
    //  serialized packet
    //
    CPacket* pPacket = new (PagedPool) CPacket(pAllocator, abo);

    if(pPacket == 0)
    { 
    	TrERROR(AC, "Failed to allocate a Packet from paged pool while creating it."); 
        ac_free(pAllocator, abo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Construct the serialized packet, make it point to the queue entry,
    //  and set the default properties
    //
    pab = new (pab) CPacketBuffer(ulPacketSize, ACpGetSequentialID());

    *ppPacket = pPacket;
    return STATUS_SUCCESS;
}


static
bool
ACpNeedEodAckHeader(
    const CACMessageProperties * pMsgProps
    )
/*++

Routine Description:

    Check if this packet needs to include an EOD-Ack header.

Arguments:

    pMsgProps - Points to the message properties structure.

Return Value:

    true - EodAck header needs to be included on this packet.
    false - EodAck header does not need to be included on this packet.

--*/
{
    return (pMsgProps->pEodAckSeqId != NULL    ||
            pMsgProps->pEodAckSeqNum != NULL   ||
            pMsgProps->EodAckStreamIdSizeInBytes != 0);

} // ACpNeedEodAckHeader


static
bool
ACpNeedSoapSection(
    const CACSendParameters * pSendParams
    )
/*++

Routine Description:

    Check if this packet needs to include SOAP sections.
    SOAP sections are included if user provides at least one of the SOAP
    write-only properties (soap header, soap body).

Arguments:

    pSendParams - Points to the send parameters structure.

Return Value:

    true - SOAP sections need to be included on this packet.
    false - SOAP sections do not need to be included on this packet.

--*/
{
    return (pSendParams->ppSoapHeader != NULL || pSendParams->ppSoapBody != NULL);

} // ACpNeedSoapSection


static
ULONG
ACpComputeAuthProvNameSizeSrmp(
	const CACSendParameters * pSendParams
	)
/*++

Routine Description:

	Helper code to compute size (in bytes) of provider name in packet.
	for Srmp protocol.

Arguments:

    pSendParams - Points to the send parameters structure.

Return Value:
	size in bytes of provider name in packet.

--*/
{
    ULONG ulSize = 0;

	//
	// For Srmp protocol, need to check that ulXmldsigSize != 0
	//
    if ( (pSendParams->ulXmldsigSize != 0) && (!(pSendParams->MsgProps.fDefaultProvider)) )
    {
        ulSize = AuthProvNameSize(&pSendParams->MsgProps);
    }

    return ulSize;

} // ACpComputeAuthProvNameSizeSrmp

	
static
ULONG
ACpComputeAuthProvNameSize(
	const CACSendParameters * pSendParams,
	bool fProtocolSrmp
	)
/*++

Routine Description:

	compute size (in bytes) of provider name in packet.

Arguments:

    pSendParams - Points to the send parameters structure.
	fProtocolSrmp - flag that indicate if Srmp message.

Return Value:
	size in bytes of provider name in packet.

--*/
{
	if(fProtocolSrmp)
	{
		return ACpComputeAuthProvNameSizeSrmp(pSendParams);
	}

	return ComputeAuthProvNameSize(&pSendParams->MsgProps);
} // ACpComputeAuthProvNameSize


static
VOID
ACpGetSignatureAndProviderSizes(
    const CACSendParameters * pSendParams,
    ULONG * pSignatureSize,
    ULONG * pAuthProvSize,
    ULONG * pAuthSignExSize,
	bool    fProtocolSrmp
    )
{
    (*pAuthProvSize)  = 0;
    (*pAuthSignExSize) = 0;
	(*pSignatureSize) = pSendParams->MsgProps.ulSignatureSize;
    if (pSendParams->MsgProps.ulSignatureSize != 0 && !pSendParams->MsgProps.fDefaultProvider)
    {
        size_t ProvNameSize = (wcslen(*pSendParams->MsgProps.ppwcsProvName) + 1) * sizeof(WCHAR);
        ACProbeForRead(*pSendParams->MsgProps.ppwcsProvName, ProvNameSize);
    }
    ULONG  ulProvNameSize = ACpComputeAuthProvNameSize(pSendParams, fProtocolSrmp);

	if(fProtocolSrmp)
	{
		//
		// for Srmp SignatureSize is taken from ulXmldsigSize
		//
		(*pSignatureSize) = pSendParams->ulXmldsigSize;

		//
        // ignore "Extra" signature for Srmp.
        //
        (*pAuthProvSize) = ulProvNameSize;

        return;
	}

    if (pSendParams->MsgProps.pulAuthProvNameLenProp)
    {
        //
        // pAuthProvSize points to the actual size of the "ProvInfo" in packet.
        // It inlcudes the provider name (if available) and the "Extra"
        // signature. this size is computed by the run time.
        //
        ULONG * pAuthProvNameLenProp = pSendParams->MsgProps.pulAuthProvNameLenProp;
        ACProbeForRead(pAuthProvNameLenProp, sizeof(ULONG));
        (*pAuthProvSize) = *pAuthProvNameLenProp;

        //
        // computer size of the "Extra" signature. Remove the name.
        //
        (*pAuthSignExSize) = (*pAuthProvSize) - ALIGNUP4_ULONG(ulProvNameSize);

        //
        // from signature, reduce the size of the "extra" signature. This
        // leave only the size of msmq1.0 signature. the "Extra" arrive
        // to the driver in the "ppSignature" buffer, so the SignatureSize
        // field, when arriving the driver, is the size of both.
        //
        (*pSignatureSize) = pSendParams->MsgProps.ulSignatureSize - (*pAuthSignExSize);

        return;
    }

    if (pSendParams->MsgProps.ulSignatureSize)
    {
        //
        // "Extra" signature not provided.
        //
        (*pAuthProvSize) = ulProvNameSize;
    }
} // ACpGetSignatureAndProviderSizes


static
ULONG
ACpCalcPacketSize(
    const CACSendParameters * pSendParams,
    const GUID *              pSourceQM,
    const GUID *              pDestinationQM,
    const GUID *              pConnectorQM,
    const QUEUE_FORMAT *      pDestinationQueue,
    ULONG                     nDestinationMqf,
    const QUEUE_FORMAT        DestinationMqf[],
	bool					  fProtocolSrmp,
	const CSenderStream&      SenderStream
	
    )
{
    ULONG ulPacketSize;
    ulPacketSize  = CBaseHeader::CalcSectionSize();

    QUEUE_FORMAT * AdminMqf = pSendParams->AdminMqf;
    ULONG nAdminMqf = pSendParams->nAdminMqf;
    ACProbeForRead(AdminMqf, nAdminMqf * sizeof(QUEUE_FORMAT));
    QUEUE_FORMAT   AdminQueueFormat;
    QUEUE_FORMAT * pAdminQueueFormat = &AdminQueueFormat;
    MQpMqf2SingleQ(nAdminMqf, AdminMqf, &pAdminQueueFormat);

    QUEUE_FORMAT * ResponseMqf = pSendParams->ResponseMqf;
    ULONG nResponseMqf = pSendParams->nResponseMqf;
    ACProbeForRead(ResponseMqf, nResponseMqf * sizeof(QUEUE_FORMAT));
    QUEUE_FORMAT   ResponseQueueFormat;
    QUEUE_FORMAT * pResponseQueueFormat = &ResponseQueueFormat;
    MQpMqf2SingleQ(nResponseMqf, ResponseMqf, &pResponseQueueFormat);

    const CACMessageProperties * pMsgProps = &pSendParams->MsgProps;
    GUID * pConnectorType = NULL;
    if (pMsgProps->ppConnectorType != NULL)
    {
        pConnectorType = *pMsgProps->ppConnectorType;
        ACProbeForRead(pConnectorType, sizeof(GUID));
    }
    ulPacketSize += CUserHeader::CalcSectionSize(
                        pSourceQM,
                        pDestinationQM,
                        pConnectorType,
                        pDestinationQueue,
                        pAdminQueueFormat,
                        pResponseQueueFormat
                        );

    XACTUOW * pUow = pMsgProps->pUow;
    if (pUow != NULL)
    {
        ACProbeForRead(pUow, sizeof(XACTUOW));
    }
    ulPacketSize += CXactHeader::CalcSectionSize(pUow, pConnectorQM);

    ULONG SignatureSize;
    ULONG AuthProvSize;
    ULONG AuthSignExSize;
    ACpGetSignatureAndProviderSizes(pSendParams, &SignatureSize, &AuthProvSize, &AuthSignExSize, fProtocolSrmp);

    ulPacketSize += CSecurityHeader::CalcSectionSize(
                        pMsgProps->uSenderIDLen,
                        (USHORT)pMsgProps->ulSymmKeysSize,
                        (USHORT)SignatureSize,
                        pMsgProps->ulSenderCertLen,
                        AuthProvSize
                        );

    ulPacketSize += CPropertyHeader::CalcSectionSize(
                        pMsgProps->ulTitleBufferSizeInWCHARs,
                        pMsgProps->ulMsgExtensionBufferInBytes,
                        pMsgProps->ulAllocBodyBufferInBytes
                        );

    //
    // If packet should include MQF header, it should also include
    // Debug header with an unknown report queue, so that MSMQ 1.0/2.0
    // reporting QMs will not append Debug header to the packet.
    //
    if (MQpNeedMqfHeaders(DestinationMqf, nDestinationMqf, pSendParams))
    {
        //
        // Debug header size
        //
        ulPacketSize += CDebugSection::CalcSectionSize(&QUEUE_FORMAT());

        //
        // Destination MQF header size
        //
        ulPacketSize += CBaseMqfHeader::CalcSectionSize(DestinationMqf, nDestinationMqf);

        //
        // Admin MQF header size
        //
        ulPacketSize += CBaseMqfHeader::CalcSectionSize(AdminMqf, nAdminMqf);

        //
        // Response MQF header size
        //
        ulPacketSize += CBaseMqfHeader::CalcSectionSize(ResponseMqf, nResponseMqf);

		//
		// MQF Signature header
		//
		ULONG SignatureMqfSize = 0;
		if (!fProtocolSrmp)
		{
			SignatureMqfSize = pSendParams->SignatureMqfSize;
		}
		ulPacketSize += CMqfSignatureHeader::CalcSectionSize(SignatureMqfSize);
    }

    if (ACpNeedEodAckHeader(pMsgProps))
    {
        ulPacketSize += CEodAckHeader::CalcSectionSize(pMsgProps->EodAckStreamIdSizeInBytes);
    }

    if (ACpNeedSoapSection(pSendParams))
    {
        ULONG SoapHeaderLen = 0;
        if (pSendParams->ppSoapHeader != NULL)
        {
            SoapHeaderLen = static_cast<ULONG>(wcslen(*pSendParams->ppSoapHeader));
        }
        ulPacketSize += CSoapSection::CalcSectionSize(SoapHeaderLen);

        ULONG SoapBodyLen = 0;
        if (pSendParams->ppSoapBody != NULL)
        {
            SoapBodyLen = static_cast<ULONG>(wcslen(*pSendParams->ppSoapBody));
        }
        ulPacketSize += CSoapSection::CalcSectionSize(SoapBodyLen);
    }

    if (pUow != NULL && fProtocolSrmp && SenderStream.IsValid())
    {
		ulPacketSize += CSenderStreamHeader::CalcSectionSize();
    }
    

    return ulPacketSize;

} // ACpCalcPacketSize


#ifdef _DEBUG
ULONG ACpDiffPtr(const void* end, const void* start)
{
	ptrdiff_t diff = (UCHAR*)end - (UCHAR*)start;
	return (ULONG)diff;	
}
#endif


static
void
ACpBuildPacket(
    CPacketBuffer *      ppb,
    const CACSendParameters * pSendParams,
    const GUID *         pSourceQM,
    const GUID *         pDestinationQM,
    const GUID *         pConnectorQM,
    const QUEUE_FORMAT * pDestinationQueue,
    ULONG                nDestinationMqf,
    const QUEUE_FORMAT   DestinationMqf[],
    bool                 fProtocolSrmp,
	const CSenderStream& SenderStream
    )
{
    //
    //  Build the packet info
    //
    CPacketInfo* ppi = ppb;
    ppi->InSourceMachine(TRUE);

    //
    //  Build the basic header
    //
    CBaseHeader* pBase = ppb;
    PVOID pSection = pBase->GetNextSection();
    ASSERT(ACpDiffPtr(pSection, pBase) == CBaseHeader::CalcSectionSize());

    const CACMessageProperties * pMsgProps = &pSendParams->MsgProps;

    if(pMsgProps->pPriority)
    {
        UCHAR * pPriority = pMsgProps->pPriority;
        ACProbeForRead(pPriority, sizeof(UCHAR));
        pBase->SetPriority(*pPriority);
    }

    if(pMsgProps->pTrace)
    {
        UCHAR * pTrace = pMsgProps->pTrace;
        ACProbeForRead(pTrace, sizeof(UCHAR));
        pBase->SetTrace(*pTrace);
    }

    if (pMsgProps->ulAbsoluteTimeToQueue)
    {
        pBase->SetAbsoluteTimeToQueue(pMsgProps->ulAbsoluteTimeToQueue);
    }

    //
    // Build user header
    //

    QUEUE_FORMAT * AdminMqf = pSendParams->AdminMqf;
    ULONG nAdminMqf = pSendParams->nAdminMqf;
    ACProbeForRead(AdminMqf, nAdminMqf * sizeof(QUEUE_FORMAT));
    QUEUE_FORMAT   AdminQueueFormat;
    QUEUE_FORMAT * pAdminQueueFormat = &AdminQueueFormat;
    MQpMqf2SingleQ(nAdminMqf, AdminMqf, &pAdminQueueFormat);

    QUEUE_FORMAT * ResponseMqf = pSendParams->ResponseMqf;
    ULONG nResponseMqf = pSendParams->nResponseMqf;
    ACProbeForRead(ResponseMqf, nResponseMqf * sizeof(QUEUE_FORMAT));
    QUEUE_FORMAT   ResponseQueueFormat;
    QUEUE_FORMAT * pResponseQueueFormat = &ResponseQueueFormat;
    MQpMqf2SingleQ(nResponseMqf, ResponseMqf, &pResponseQueueFormat);

    CUserHeader* pUser = new (pSection) CUserHeader(
                            pSourceQM,
                            pDestinationQM,
                            pDestinationQueue,
                            pAdminQueueFormat,
                            pResponseQueueFormat,
                            ppb->SequentialIdLow32()
                            );

    GUID* pConnectorType = NULL;
    if (pMsgProps->ppConnectorType)
    {
        pConnectorType = *pMsgProps->ppConnectorType;
        ACProbeForRead(pConnectorType, sizeof(GUID));
        pUser->SetConnectorType(pConnectorType);
    }

    //
    //  Setting the Connector type changes the user section size, therfore
    //  calculate the next section only after the connector type is set.
    //
    pSection = pUser->GetNextSection();
    ASSERT(ACpDiffPtr(pSection, pUser) == CUserHeader::CalcSectionSize(
                                              pSourceQM,
                                              pDestinationQM,
                                              pConnectorType,
                                              pDestinationQueue,
                                              pAdminQueueFormat,
                                              pResponseQueueFormat
                                              ));

    pUser->SetTimeToLiveDelta(pMsgProps->ulRelativeTimeToLive);

    //
    // Set absolute sent time (time when packet was sent by user).
    //
    LARGE_INTEGER liCurrTime;
    KeQuerySystemTime(&liCurrTime);
    pUser->SetSentTime(Convert1601to1970(liCurrTime.QuadPart));

    if(pMsgProps->ppMessageID)
    {
        //
        //  This is a Read Only property.
        //
        OBJECTID* pMessageID = *pMsgProps->ppMessageID;
        ACProbeForWrite(pMessageID, sizeof(OBJECTID));
        pUser->GetMessageID(pMessageID);
    }

    if (pMsgProps->pDelivery)
    {
        UCHAR * pDelivery = pMsgProps->pDelivery;
        ACProbeForRead(pDelivery, sizeof(UCHAR));
        pUser->SetDelivery(*pDelivery);
    }

    if (pMsgProps->pUow)
    {
        pUser->SetDelivery(MQMSG_DELIVERY_RECOVERABLE);
    }

    if(pMsgProps->pAuditing)
    {
        UCHAR * pAuditing = pMsgProps->pAuditing;
        ACProbeForRead(pAuditing, sizeof(UCHAR));
        pUser->SetAuditing(*pAuditing);
    }

    //
    // Build the xact header.
    //

    XACTUOW * pUow = pMsgProps->pUow;
    if (pUow != NULL)
    {
        ACProbeForRead(pUow, sizeof(XACTUOW));

        pUser->IncludeXact(TRUE);

        CXactHeader* pXact = new (pSection) CXactHeader(pConnectorQM);

        //
        //  Should we cancel the receive follow-up for this message?
        //
        if(
            //
            // Not deadletter and not compatability mode
            //
            (!(pUser->GetAuditing() & MQMSG_DEADLETTER) && !g_fXactCompatibilityMode))
        {
            pXact->SetCancelFollowUp(TRUE);
        }

        pSection = pXact->GetNextSection();
        ASSERT(ACpDiffPtr(pSection, pXact) == CXactHeader::CalcSectionSize(pUow, pConnectorQM));
    }

    //
    // Build the security header.
    //
    ULONG SignatureSize;
    ULONG AuthProvSize;
    ULONG AuthSignExSize;
    ACpGetSignatureAndProviderSizes(pSendParams, &SignatureSize, &AuthProvSize, &AuthSignExSize, fProtocolSrmp);

    if (pMsgProps->uSenderIDLen ||
        pMsgProps->ulSenderCertLen ||
        SignatureSize            ||
        pMsgProps->ulSymmKeysSize
        )
    {
        pUser->IncludeSecurity(TRUE);

        CSecurityHeader* pSec = new (pSection) CSecurityHeader;

        USHORT uSenderIDLen = pMsgProps->uSenderIDLen;
        if (uSenderIDLen != 0)
        {
            ULONG * pSenderIdType = pMsgProps->pulSenderIDType;
            ACProbeForRead(pSenderIdType, sizeof(ULONG));
            if ((*pSenderIdType) != MQMSG_SENDERID_TYPE_NONE)
            {
                //
                // Write the sender ID info in the security section.
                //
                ASSERT(*pMsgProps->ppSenderID);
                PUCHAR pSenderID = *pMsgProps->ppSenderID;
                ACProbeForRead(pSenderID, uSenderIDLen);
                pSec->SetSenderID(pSenderID, uSenderIDLen);

                pSec->SetSenderIDType((USHORT)*pSenderIdType);
            }
        }

        USHORT SymmKeysSize = (USHORT)pMsgProps->ulSymmKeysSize;
        if (SymmKeysSize != 0)
        {
            //
            // Write the encrypted symmetric keys in the security header.
            //
            UCHAR * pSymmKeys = NULL;
            if (pMsgProps->ppSymmKeys != NULL)
            {
                pSymmKeys = *pMsgProps->ppSymmKeys;
                ACProbeForRead(pSymmKeys, SymmKeysSize);
            }
            pSec->SetEncryptedSymmetricKey(pSymmKeys, SymmKeysSize);
        }

        if (SignatureSize != 0)
        {
            //
            // Mark the packet as not authenticated. QM may authenticate it later on.
            //
            pSec->SetAuthenticated(FALSE);
            pSec->SetLevelOfAuthentication(MQMSG_AUTHENTICATION_NOT_REQUESTED);

            if (fProtocolSrmp)
            {
                //
                // Write the XML signature in the security section
                //
                ASSERT(pSendParams->ulXmldsigSize == SignatureSize);
                ASSERT((pSendParams->ppXmldsig != NULL) && (*pSendParams->ppXmldsig != NULL));
                PUCHAR pXmldsig = *pSendParams->ppXmldsig;
                ACProbeForRead(pXmldsig, SignatureSize);
                pSec->SetSignature(pXmldsig, (USHORT)SignatureSize);
            }
			else
			{
				//
				// Write the signature in the security section.
				//
				ASSERT(pMsgProps->ppSignature && *pMsgProps->ppSignature);
				PUCHAR pSignature = *pMsgProps->ppSignature;
				ACProbeForRead(pSignature, SignatureSize);
				pSec->SetSignature(pSignature, (USHORT)SignatureSize);
			}
        }

        ULONG ulSenderCertLen = pMsgProps->ulSenderCertLen;
        if (ulSenderCertLen)
        {
            //
            // Write the sender's certificate in the security section.
            //
            ASSERT(*pMsgProps->ppSenderCert);
            PUCHAR pSenderCert = *pMsgProps->ppSenderCert;
            ACProbeForRead(pSenderCert, ulSenderCertLen);
            pSec->SetSenderCert(pSenderCert, ulSenderCertLen);
        }

        if (SignatureSize != 0)
        {
            //
            // Write the CSP info in the security section.
            //
            WCHAR * pProvName = NULL;
            if (pMsgProps->ppwcsProvName != NULL)
            {
                pProvName = *pMsgProps->ppwcsProvName;
                size_t ProvNameSize = (wcslen(pProvName) + 1) * sizeof(WCHAR);
                ACProbeForRead(pProvName, ProvNameSize);
            }

            ULONG * pProvType = pMsgProps->pulProvType;
            if (pProvType != NULL)
            {
                ACProbeForRead(pProvType, sizeof(ULONG));
            }

            pSec->SetProvInfoEx(
                    AuthProvSize,
                    pMsgProps->fDefaultProvider,
                    pProvName,
                    (pProvType != NULL) ? (*pProvType) : 0
                    );

			if(!fProtocolSrmp)
			{
				//
				// Set the "extra" signature in packet.
				// only if Not Srmp
				//
				if (pMsgProps->pulAuthProvNameLenProp)
				{
					PUCHAR pSignatureEx = (*pMsgProps->ppSignature) + SignatureSize;
					ACProbeForRead(pSignatureEx, AuthSignExSize);
					pSec->SetSectionEx(pSignatureEx, AuthSignExSize);
				}
			}
        }

        pSec->SetEncrypted(pMsgProps->bEncrypted);

        pSection = pSec->GetNextSection();
        ASSERT(ACpDiffPtr(pSection, pSec) == CSecurityHeader::CalcSectionSize(
                                             uSenderIDLen,
                                             SymmKeysSize,
                                             (USHORT)SignatureSize,
                                             ulSenderCertLen,
                                             AuthProvSize
                                             ));
    }

    //
    // Build Message Property
    //
    CPropertyHeader* pProp = new (pSection) CPropertyHeader;

    if(pMsgProps->pClass)
    {
        USHORT * pClass = pMsgProps->pClass;
        ACProbeForRead(pClass, sizeof(USHORT));
        pProp->SetClass(*pClass);
    }

    //
    //  MessageID in user header
    //

    if(pMsgProps->ppCorrelationID)
    {
        PUCHAR pCorrelationID = *pMsgProps->ppCorrelationID;
        ACProbeForRead(pCorrelationID, PROPID_M_CORRELATIONID_SIZE);
        pProp->SetCorrelationID(pCorrelationID);
    }

    //
    //  Priority in base header
    //  Delivery in user header
    //

    if(pMsgProps->pAcknowledge)
    {
        UCHAR * pAcknowledge = pMsgProps->pAcknowledge;
        ACProbeForRead(pAcknowledge, sizeof(UCHAR));
        pProp->SetAckType(*pAcknowledge);
    }

    //
    //  Routing in user header
    //  Auditing in user header
    //

    if(pMsgProps->pApplicationTag)
    {
        ULONG * pApplicationTag = pMsgProps->pApplicationTag;
        ACProbeForRead(pApplicationTag, sizeof(ULONG));
        pProp->SetApplicationTag(*pApplicationTag);
    }

    if(pMsgProps->ppTitle)
    {
        //
        //  NOTE: Setting the title to the message MUST occure before setting the body
        //
        PWCHAR pTitle = *pMsgProps->ppTitle;
        ACProbeForRead(pTitle, pMsgProps->ulTitleBufferSizeInWCHARs * sizeof(WCHAR));
        pProp->SetTitle(pTitle, pMsgProps->ulTitleBufferSizeInWCHARs);
    }

    if (pMsgProps->ppMsgExtension)
    {
        //
        //  NOTE: Setting the Message Extension to property section MUST occure
        //        before setting the body and after setting the title
        //
        PUCHAR pMsgExtension = *pMsgProps->ppMsgExtension;
        ACProbeForRead(pMsgExtension, pMsgProps->ulMsgExtensionBufferInBytes);
        pProp->SetMsgExtension(pMsgExtension, pMsgProps->ulMsgExtensionBufferInBytes);
    }

    if(pMsgProps->ppBody)
    {
        PUCHAR pBody = *pMsgProps->ppBody;
        ACProbeForRead(pBody, pMsgProps->ulBodyBufferSizeInBytes);
        pProp->SetBody(pBody, pMsgProps->ulBodyBufferSizeInBytes, pMsgProps->ulAllocBodyBufferInBytes);
    }

    if(pMsgProps->pBodySize)
    {
        NOTHING;
    }

    //
    // Privacy level
    //
    if (pMsgProps->pulPrivLevel)
    {
        ULONG * pPrivLevel = pMsgProps->pulPrivLevel;
        ACProbeForRead(pPrivLevel, sizeof(ULONG));
        pProp->SetPrivLevel(*pPrivLevel);
    }

    //
    // Hash algorithm
    //
    if (pMsgProps->pulHashAlg)
    {
        ULONG * pHashAlg = pMsgProps->pulHashAlg;
        ACProbeForRead(pHashAlg, sizeof(ULONG));
        pProp->SetHashAlg(*pHashAlg);
    }

    //
    // Encryption algorithm
    //
    if (pMsgProps->pulEncryptAlg)
    {
        ULONG * pEncryptAlg = pMsgProps->pulEncryptAlg;
        ACProbeForRead(pEncryptAlg, sizeof(ULONG));
        pProp->SetEncryptAlg(*pEncryptAlg);
    }

    //
    // Body Type
    //
    if (pMsgProps->pulBodyType)
    {
        ULONG * pBodyType = pMsgProps->pulBodyType;
        ACProbeForRead(pBodyType, sizeof(ULONG));
        pProp->SetBodyType(*pBodyType);
    }

    //
    //  Timeout in user header
    //  Trace in base header
    //

    pSection = pProp->GetNextSection();
    ASSERT(ACpDiffPtr(pSection, pProp) == CPropertyHeader::CalcSectionSize(
                                          pMsgProps->ulTitleBufferSizeInWCHARs,
                                          pMsgProps->ulMsgExtensionBufferInBytes,
                                          pMsgProps->ulAllocBodyBufferInBytes
                                          ));

    //
    // If packet should include MQF header, it should also include
    // Debug header with an unknown report queue, so that MSMQ 1.0/2.0
    // reporting QMs will not append Debug header to the packet.
    //
    if (MQpNeedMqfHeaders(DestinationMqf, nDestinationMqf, pSendParams))
    {
        //
        // Build Debug header
        //
        pBase->IncludeDebug(TRUE);
        CDebugSection * pDebug = new (pSection) CDebugSection(&QUEUE_FORMAT());
        pSection = pDebug->GetNextSection();
        ASSERT(ACpDiffPtr(pSection, pDebug) == CDebugSection::CalcSectionSize(&QUEUE_FORMAT()));

        //
        // Build Destination MQF header
        //
        pUser->IncludeMqf(true);

        const USHORT x_DESTINATION_MQF_HEADER_ID = 100;
        CBaseMqfHeader * pDestinationMqf = new (pSection) CBaseMqfHeader(
                                                              DestinationMqf,
                                                              nDestinationMqf,
                                                              x_DESTINATION_MQF_HEADER_ID
                                                              );
        pSection = pDestinationMqf->GetNextSection();
        ASSERT(ACpDiffPtr(pSection, pDestinationMqf) == CBaseMqfHeader::CalcSectionSize(
                                                            DestinationMqf,
                                                            nDestinationMqf
                                                            ));

        //
        // Build Admin MQF header
        //
        const USHORT x_ADMIN_MQF_HEADER_ID = 200;
        CBaseMqfHeader * pAdminMqf = new (pSection) CBaseMqfHeader(
                                                        AdminMqf,
                                                        nAdminMqf,
                                                        x_ADMIN_MQF_HEADER_ID
                                                        );
        pSection = pAdminMqf->GetNextSection();
        ASSERT(ACpDiffPtr(pSection, pAdminMqf) == CBaseMqfHeader::CalcSectionSize(
                                                            AdminMqf,
                                                            nAdminMqf
                                                            ));

        //
        // Build Response MQF header
        //
        const USHORT x_RESPONSE_MQF_HEADER_ID = 300;
        CBaseMqfHeader * pResponseMqf = new (pSection) CBaseMqfHeader(
                                                           ResponseMqf,
                                                           nResponseMqf,
                                                           x_RESPONSE_MQF_HEADER_ID
                                                           );
        pSection = pResponseMqf->GetNextSection();
        ASSERT(ACpDiffPtr(pSection, pResponseMqf) == CBaseMqfHeader::CalcSectionSize(
                                                            ResponseMqf,
                                                            nResponseMqf
                                                            ));

		//
		// Build MQF Signature header
		//
		// Capture user buffer and size and probe the buffer
		//
        PUCHAR pUserBuffer = NULL;
		ULONG UserBufferSize = 0;
		if (!fProtocolSrmp)
		{
			UserBufferSize = pSendParams->SignatureMqfSize;
		}
        if (UserBufferSize != 0)
        {
		    pUserBuffer = *pSendParams->ppSignatureMqf;
		    ACProbeForRead(pUserBuffer, UserBufferSize);
        }

		const USHORT x_MQF_SIGNATURE_HEADER_ID = 350;
		CMqfSignatureHeader * pMqfSignature = new (pSection) CMqfSignatureHeader(
			                                                     x_MQF_SIGNATURE_HEADER_ID,
			                                                     UserBufferSize,
																 pUserBuffer
																 );
		pSection = pMqfSignature->GetNextSection();
        ASSERT(ACpDiffPtr(pSection, pMqfSignature) == CMqfSignatureHeader::CalcSectionSize(UserBufferSize));
    }

    //
    // Build EOD-Ack header
    //
    if (ACpNeedEodAckHeader(pMsgProps))
    {
        pUser->IncludeEodAck(true);

        //
        // Capture stream ID buffer and size and probe the buffer
        //
        PUCHAR pEodAckStreamId = *pMsgProps->ppEodAckStreamId;
        ULONG  EodAckStreamIdSizeInBytes = pMsgProps->EodAckStreamIdSizeInBytes;
        ACProbeForRead(pEodAckStreamId, EodAckStreamIdSizeInBytes);

        const USHORT x_EOD_ACK_HEADER_ID = 700;
        CEodAckHeader * pEodAck = new (pSection) CEodAckHeader(
                                                  x_EOD_ACK_HEADER_ID,
                                                  pMsgProps->pEodAckSeqId,
                                                  pMsgProps->pEodAckSeqNum,
                                                  EodAckStreamIdSizeInBytes,
                                                  pEodAckStreamId
                                                  );
        pSection = pEodAck->GetNextSection();
        ASSERT(ACpDiffPtr(pSection, pEodAck) == CEodAckHeader::CalcSectionSize(EodAckStreamIdSizeInBytes));
    }

    //
    // Build SOAP sections
    //
    if (ACpNeedSoapSection(pSendParams))
    {
        pUser->IncludeSoap(true);

        LPWSTR pSoapHeader = NULL;
        ULONG SoapHeaderLen = 0;
        if (pSendParams->ppSoapHeader != NULL)
        {
            //
            // Capture SOAP header buffer and size and probe the buffer
            //
            pSoapHeader = *pSendParams->ppSoapHeader;
            SoapHeaderLen = static_cast<ULONG>(wcslen(pSoapHeader));
            ACProbeForRead(pSoapHeader, (SoapHeaderLen + 1) * sizeof(WCHAR));
        }

        const USHORT x_SOAP_HEADER_SECTION_ID = 800;
        CSoapSection * pSoapHeaderSection = new (pSection) CSoapSection(
                                                               pSoapHeader,
                                                               SoapHeaderLen,
                                                               x_SOAP_HEADER_SECTION_ID
                                                               );
        pSection = pSoapHeaderSection->GetNextSection();
        ASSERT(ACpDiffPtr(pSection, pSoapHeaderSection) == CSoapSection::CalcSectionSize(SoapHeaderLen));

        LPWSTR pSoapBody = NULL;
        ULONG SoapBodyLen = 0;
        if (pSendParams->ppSoapBody != NULL)
        {
            //
            // Capture SOAP body buffer and size and probe the buffer
            //
            pSoapBody = *pSendParams->ppSoapBody;
            SoapBodyLen = static_cast<ULONG>(wcslen(pSoapBody));
            ACProbeForRead(pSoapBody, (SoapBodyLen + 1) * sizeof(WCHAR));
        }

        const USHORT x_SOAP_BODY_SECTION_ID = 900;
        CSoapSection * pSoapBodySection = new (pSection) CSoapSection(
                                                             pSoapBody,
                                                             SoapBodyLen,
                                                             x_SOAP_BODY_SECTION_ID
                                                             );
        pSection = pSoapBodySection->GetNextSection();
        ASSERT(ACpDiffPtr(pSection, pSoapBodySection) == CSoapSection::CalcSectionSize(SoapBodyLen));
    }

	
	if (pUow != NULL && fProtocolSrmp && SenderStream.IsValid())
	{
		pUser->IncludeSenderStream(TRUE);
		const USHORT x_SENDER_STREAM_SECDTION_ID = 1000;
		CSenderStreamHeader* pSenderStreamHeader = new (pSection) CSenderStreamHeader(
														 SenderStream,
                                                         x_SENDER_STREAM_SECDTION_ID
                                                         );

		pSection = pSenderStreamHeader->GetNextSection();
        ASSERT(ACpDiffPtr(pSection, pSenderStreamHeader) == CSenderStreamHeader::CalcSectionSize());
	}


} // ACpBuildPacket


void CPacket::CacheCurrentState(CPacketBuffer* ppb)
{
    ASSERT(ppb != NULL && MappedBuffer() == ppb);

    //
    //  cached flags: ordered, sent localy, source journal, lookup id
    //
    CPacketInfo* ppi = ppb;
    CBaseHeader* pBase = ppb;
    CUserHeader* pUser = CPacketBuffer::UserHeader(pBase);

    IsOrdered(pUser->IsOrdered());
    InSourceMachine(ppi->InSourceMachine());
    SourceJournal(ppi->InSourceMachine() && (pUser->GetAuditing() & MQMSG_JOURNAL));

    //
    // LookupID is 64 bit value (8 bytes) where high order byte is inverted priority,
    // and rest of bytes are the low order 56 bits of SequentialId.
    //
    //   Byte0     Byte1     Byte2     Byte3     Byte4     Byte5     Byte6     Byte7
    // +-------------------------------------------------------------------------------+
    // | Inv.Pri |                    low 56 bits of SequentialId                      |
    // +-------------------------------------------------------------------------------+
    //
    ULONGLONG lookupid = MQ_MAX_PRIORITY - pBase->GetPriority();
    lookupid = (lookupid << 56) + (ppi->SequentialId() & 0x00FFFFFFFFFFFFFF);

    //
    // Special case: Sequential ID == zero means this packet was remote read from a downlevel
    // QM that does not support lookupid. In this case return invalid lookupid (zero).
    //
    if (ppi->SequentialId() == 0)
    {
        lookupid = 0;
    }

    LookupId(lookupid);

    CachedFlagsSet(TRUE);
}


static
NTSTATUS
ValidateProperties(
    const CACMessageProperties * pMsgProps,
    const CQueue *               pDestinationQueue,
    bool                         fProtocolSrmp,
    bool                         fDlOrMqf
    )
{
    ACProbeForRead(pMsgProps->pulPrivLevel, sizeof(ULONG));

    bool fDirect = fProtocolSrmp || pDestinationQueue->GetQueueFormatType() == QUEUE_FORMAT_TYPE_DIRECT;
    if( (fDirect) &&
        (*pMsgProps->pulPrivLevel != MQMSG_PRIV_LEVEL_NONE) &&
        !pMsgProps->bEncrypted)
    {
        //
        // Encryption is not supported for direct queues.
        //
        return MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION;
    }

	if(fProtocolSrmp  && 
    	(pMsgProps->pulEncryptAlg != NULL && pMsgProps->ppSymmKeys != NULL))
	{
		//
        // Message should not be encrypted for direct http formatname and multicast.
        //
        return MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION;		
	}

    if( fDlOrMqf && 
    	(pMsgProps->pulEncryptAlg != NULL && pMsgProps->ppSymmKeys != NULL))
    {
        //
        // Message should not be encrypted for DL.
        //
        return MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION;
    }
    return STATUS_SUCCESS;
}


inline
ACPoolType
GetPacketPoolType(
    const CACMessageProperties * pMsgProps
    )
{
    if(pMsgProps->pAuditing && (*pMsgProps->pAuditing & MQMSG_JOURNAL))
    {
        return ptJournal;
    }

    if(pMsgProps->pDelivery && (*pMsgProps->pDelivery == MQMSG_DELIVERY_RECOVERABLE))
    {
        return ptPersistent;
    }

    if(pMsgProps->pUow)              //All transactional messages are persistent
    {
        return ptPersistent;
    }

    return ptReliable;
}


NTSTATUS
CPacket::Create(
    CPacket * *        ppPacket,
    BOOL               fCheckMachineQuota,
    const CACSendParameters * pSendParams,
    const CQueue *     pDestinationQueue,
    ULONG              nDestinationMqf,
    const QUEUE_FORMAT DestinationMqf[],
    bool               fProtocolSrmp
    )
{
    *ppPacket = 0;
    __try
    {
        NTSTATUS rc;
        const CACMessageProperties * pMsgProps = &pSendParams->MsgProps;
		bool fDlOrMqf = (nDestinationMqf > 1 || DestinationMqf[0].GetType() == QUEUE_FORMAT_TYPE_DL);
		rc = ValidateProperties(pMsgProps, pDestinationQueue, fProtocolSrmp, fDlOrMqf);
        if(!NT_SUCCESS(rc))
        {
            return rc;
        }

        const GUID * pSourceQM = g_pQM->UniqueID();
        const GUID * pDestinationQM = pDestinationQueue->QMUniqueID();
        ULONG ulPacketSize;
        ulPacketSize = ACpCalcPacketSize(
                        pSendParams,
                        pSourceQM,
                        pDestinationQM,
                        pDestinationQueue->ConnectorQM(),
                        pDestinationQueue->UniqueID(),
                        nDestinationMqf,
                        DestinationMqf,
						fProtocolSrmp,
						pDestinationQueue->SenderStream()
						);


        ACPoolType pt = GetPacketPoolType(pMsgProps);
        rc = Create(
                ppPacket,
                ulPacketSize,
                pt,
                fCheckMachineQuota
                );

        if(!NT_SUCCESS(rc))
        {
            return rc;
        }

        CPacketBuffer * ppb = (*ppPacket)->Buffer();
        ASSERT(ppb != NULL);

        ACpBuildPacket(
            ppb,
            pSendParams,
            pSourceQM,
            pDestinationQM,
            pDestinationQueue->ConnectorQM(),
            pDestinationQueue->UniqueID(),
            nDestinationMqf,
            DestinationMqf,
            fProtocolSrmp,
			pDestinationQueue->SenderStream()
            );

        return STATUS_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        ACpRelease(*ppPacket);
        *ppPacket = 0;
        return GetExceptionCode();
    }
} // CPacket::Create


NTSTATUS
CPacket::SyncCreate(
    PIRP                      irp,
    CTransaction *            pXact,
    CQueue *                  pDestinationQueue,
    ULONG                     nDestinationMqf,
    const QUEUE_FORMAT        DestinationMqf[],
    BOOL                      fCheckMachineQuota,
    const CACSendParameters * pSendParams,
    CQueue *                  pAsyncCompletionHandler,
    bool                      fProtocolSrmp,
    CPacket * *               ppPacket
    )
/*++

Routine Description:

    Do the synchronous part of packet creation. Store async completion context
    on the packet. Attach the packet to irp.

Arguments:

    irp                     - Pointer to the send request IRP.

    pXact                   - Pointer to transaction, may be null.

    pDestinationQueue       - Pointer to destination queue object.

    nDestinationMqf         - Number of entries in DestinationMqf array.

    DestinationMqf          - Array of destination queue formats, may be empty.

    fCheckMachineQuota      - Indicates whether to check machine quota in creation.

    pSendParams             - Pointer to send parameters.

    pAsyncCompletionHandler - Queue/Distribution to handle async completion.

    fProtocolSrmp           - Indicates whether the destination queue is http (direct=http or multicast).

    ppPacket                - Pointer to pointer to created packet, on output.

Return Value:

    STATUS_SUCCESS - The packet created successfully and attached to irp.

    failure status - Failed to create the packet, there is no packet.

--*/
{
    ASSERT(ppPacket != NULL);

    //
    // Create packet object
    //
    NTSTATUS rc;
    rc = Create(ppPacket, fCheckMachineQuota, pSendParams, pDestinationQueue, nDestinationMqf, DestinationMqf, fProtocolSrmp);
    if (!NT_SUCCESS(rc))
    {
        ASSERT((*ppPacket) == NULL);
        return rc;
    }

    //
    // Packet should have no async completion context on it
    //
    CPacket * pPacket = *ppPacket;
    ASSERT(pPacket->Queue() == NULL);
    ASSERT(pPacket->Transaction() == NULL);

    //
    // Attach packet to irp and AddRef the packet. On failure de-ref packet creation.
    //
    if (!CIrp2Pkt::SafeAttachPacket(irp, pPacket))
    {
        pPacket->Release();
        (*ppPacket) = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    pPacket->AddRef();

    //
    // Store async completion context on packet
    //
    pPacket->Queue(pAsyncCompletionHandler);
    pPacket->Transaction(pXact);

    return STATUS_SUCCESS;

} // CPacket::SyncCreate


NTSTATUS CPacket::IssueCreatePacketRequest(bool fProtocolSrmp)
/*++

Routine Description:

    Issue QM request to complete packet creation. AddRef the packet.

Arguments:

    fProtocolSrmp - Indicates whether the destination queue is http (direct=http or multicast).

Return Value:

    STATUS_SUCCESS - The operation completed successfully.

    failure status - The operation failed.

--*/
{
    CACRequest request(CACRequest::rfCreatePacket);
    request.CreatePacket.pPacket = NULL;
    request.CreatePacket.pDriverPacket = this;
    request.CreatePacket.fProtocolSrmp = fProtocolSrmp;

    AddRef();
    NTSTATUS rc = g_pQM->ProcessRequest(request);
    if(!NT_SUCCESS(rc))
    {
        Release();
        return rc;
    }

    return STATUS_SUCCESS;

} // CPacket::IssueCreatePacketRequest


NTSTATUS
CPacket::Restore(
    CMMFAllocator* pAllocator,
    CAllocatorBlockOffset abo
    )
{
    ASSERT(pAllocator != NULL);
    CPacketBuffer* ppb = static_cast<CPacketBuffer*>(
                            pAllocator->GetQmAccessibleBufferNoMapping(abo)
                            );

    //
    //  Allocate the Queue entry in pagable memory, and make it point to
    //  serialized packet
    //
    CPacket* pPacket = new (PagedPool) CPacket(pAllocator, abo);
    if(pPacket == 0)
    {
        //
        //  we don't have enough resources for restoration
        //  EVENT LOG: not enough resurces to restore
        //
        TrERROR(AC, "Failed to allocate a CPacket from paged pool while restoring it."); 
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Construct the serialized packet, make it point to the queue entry
    //  Note that mqdump should do read-only operations on the files.
    //
    UNREFERENCED_PARAMETER(ppb);
#ifndef MQDUMP
    CPacketInfo* ppi = ppb;
    ACpSetSequentialID(ppi->SequentialId());
#endif // MQDUMP


    pPacket->ArrivalAckIssued(TRUE);
    pPacket->StorageIssued(TRUE);
	pPacket->StorageCompleted(TRUE);

    g_pRestoredPackets->insert(pPacket);

    NTSTATUS rc = pPacket->Dump();

    return rc;
}


NTSTATUS
ACpGetQueueFormatString(
    NTSTATUS rc,
    const QUEUE_FORMAT& qf,
    LPWSTR* ppfn,
    PULONG pBufferLen,
    bool   fSerializeMqfSeperator
    )
{
    LPWSTR pfn;
    if(ppfn != 0)
    {
        //
        //  Format Name property was specified. prob it
        //
        pfn = *ppfn;

        ACProbeForWrite(pfn, *pBufferLen * sizeof(WCHAR));
    }
    else
    {
        //
        //  Format Name property was not specified, set it's length to zero
        //  so no memory will be written
        //
        pfn = 0;
        *pBufferLen = 0;
    }

    if(qf.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN)
    {
        NTSTATUS rc1;
        rc1 = MQpQueueFormatToFormatName(
                &qf,
                pfn,
                *pBufferLen,
                pBufferLen,
                fSerializeMqfSeperator
                );

        if(!NT_SUCCESS(rc1) && ppfn)
        {
            //
            //  This is an error, overwrite any previous status.
            //  An error is returned to the application only if the Format Name
            //  property exists.
            //
            return rc1;
        }
    }
    else
    {
        *pBufferLen = 0;
    }

    return rc;

} // ACpGetQueueFormatString


NTSTATUS
ACpGetMqfProperty(
    NTSTATUS rc,
    CBaseMqfHeader * pMqf,
    ULONG *          pLength,
    WCHAR * *        ppUserBuffer
    )
{
    ASSERT(pLength != NULL);
    ULONG BufferLength = *pLength;
    *pLength = 0;

    WCHAR * pUserBuffer = NULL;
    if (ppUserBuffer != NULL)
    {
        pUserBuffer = *ppUserBuffer;
        ppUserBuffer = &pUserBuffer;
    }

    //
    // MQF header not included on packet, or contains 0 elements
    //
    ULONG nMqf;
    if (pMqf == NULL ||
        (nMqf = pMqf->GetNumOfElements()) == 0)
    {
        return rc;
    }

    UCHAR * pMqfBuffer = pMqf->GetSerializationBuffer();
    QUEUE_FORMAT qf;
    for ( ; nMqf-- != 0; )
    {
        bool fLastElement = (nMqf == 0);

        //
        // Get next element from MQF header and convert to string
        //
        pMqfBuffer = pMqf->GetQueueFormat(pMqfBuffer, &qf);
        ULONG Length = BufferLength;
        rc = ACpGetQueueFormatString(rc, qf, ppUserBuffer, &Length, !fLastElement);

        //
        // Dont count the MQF separator AND the null terminator right after it
        //
        if (!fLastElement)
        {
            --Length;
        }

        //
        // Update required length, remaining length, and pointer in buffer
        //
        *pLength += Length;
        if (BufferLength < Length)
        {
            BufferLength = 0;
        }
        else
        {
            BufferLength -= Length;
        }
        if (ppUserBuffer != NULL)
        {
            *ppUserBuffer += Length;
        }
    }

    return rc;

} // ACpGetMqfProperty


static
ULONG
AbsoluteToRelativeTime(
    ULONG ulAbsolute
    )
{
    ULONG ulCurrentTime = system_time();
    if(ulAbsolute > ulCurrentTime)
    {
        return (ulAbsolute - ulCurrentTime);
    }

    //
    //  Underflow, timeout has expired already.
    //
    return 0;
}


static 
bool
InOutgoingQueue(
	CPacketInfo * ppi 
	)
{
	return ( !ppi->InJournalQueue() && 
			 !ppi->InDeadletterQueue() && 
    	 	 !ppi->InTargetQueue() && 
    	 	 !ppi->InConnectorQueue() );
}


NTSTATUS
CPacket::Convert(
    PIRP irp,
    BOOL fStore
    )
/*++

Routine Description:

    Convert packet to latest format.

Arguments:

    irp                  - Points to the IRP.

    fStore               - Store the packet (implies computing checksum).
                           In MSMQ 2.0 and higher we use checksum.

Return Value:

    STATUS_SUCCESS - The operation completed successfully.
    STATUS_PENDING - The operation is pending storage.
    other          - The operation failed.

--*/
{
    CPacketBuffer * ppb = Buffer();
    if (ppb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If needed, convert to MSMQ 3.0 format (64 bit sequential ID)
    //
    CPacketInfo *   ppi = ppb;
    if (!ppi->SequentialIdMsmq3Format())
    {
        ULONG SequentialIdHigh32 = ppi->SequentialIdHigh32();
        ppi->SequentialID(SequentialIdHigh32);
        ppi->SequentialIdMsmq3Format(TRUE);
        fStore = true;
    }

    //
    // If needed, change QM GUID on packet. This is to support join domain.
    //
    CUserHeader *   pUser = CPacketBuffer::UserHeader(ppb);
    ASSERT(pUser != NULL);

	//
	// We don't change the GUID on tx messages in outgoing queues that were sent from this
	// computer. These messages will be thrown away during recovery.
	//
    if (ppi->InSourceMachine() && (!pUser->IsOrdered() || !InOutgoingQueue(ppi)))
    {
        if ((*pUser->GetSourceQM()) != (*g_pQM->UniqueID()))
        {
            pUser->SetSourceQM(g_pQM->UniqueID());
            fStore = true;
        }
    }

    if (ppi->InTargetQueue() || ppi->InJournalQueue()) 
    {
        if ((*pUser->GetDestQM()) != (*g_pQM->UniqueID()))
        {
            pUser->SetDestQM(g_pQM->UniqueID());
            fStore = true;
        }
    }

    if (!fStore)
    {
        return STATUS_SUCCESS;
    }

	StorageIssued(FALSE);
	StorageCompleted(FALSE);
    return StoreInPlace(irp);

} // CPacket::Convert


NTSTATUS CPacket::GetProperties(CACReceiveParameters * pReceiveParams) const
{
    CPacketBuffer* ppb = Buffer();
    if (ppb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    CPacketInfo* ppi = ppb;
    CBaseHeader* pBase = ppb;
    CUserHeader* pUser = 0;
    CXactHeader* pXact = 0;
    CSecurityHeader* pSec = 0;
    CPropertyHeader* pProp = 0;
    CDebugSection  * pDebug = 0;
    CBaseMqfHeader * pDestinationMqf = 0;
    CBaseMqfHeader * pAdminMqf = 0;
    CBaseMqfHeader * pResponseMqf = 0;
	CMqfSignatureHeader  * pMqfSignature = 0;
    CSrmpEnvelopeHeader    * pSrmpEnvelope = 0;
    CCompoundMessageHeader * pCompoundMessage = 0;
    CEodHeader     * pEod = 0;
    CEodAckHeader  * pEodAck = 0;

    NTSTATUS rc = STATUS_SUCCESS;
    CACMessageProperties * pMsgProps = &pReceiveParams->MsgProps;

    __try
    {
        PVOID pSection = pBase->GetNextSection();

        //
        // Get the user section
        //
        pUser = static_cast<CUserHeader*>(pSection);
        pSection = pUser->GetNextSection();
        //
        // Get the XACT section
        //
        if(pUser->IsOrdered())
        {
            pXact = static_cast<CXactHeader*>(pSection);
            pSection = pXact->GetNextSection();
        }
        //
        // Get the security section
        //
        if(pUser->SecurityIsIncluded())
        {
            pSec = static_cast<CSecurityHeader*>(pSection);
            pSection = pSec->GetNextSection();
        }
        //
        // Get the property Section
        //
        if (pUser->PropertyIsIncluded())
        {
            pProp = static_cast<CPropertyHeader*>(pSection);
            pSection = pProp->GetNextSection();
        }

        //
        // Get the debug section.
        // Debug section always included when MQF section is included.
        //
        if (pBase->DebugIsIncluded())
        {
            pDebug = static_cast<CDebugSection*>(pSection);
            pSection = pDebug->GetNextSection();
        }

        //
        // Get the MQF sections: Destination, Admin, Response, Signature
        //
        if (pUser->MqfIsIncluded())
        {
            ASSERT(pBase->DebugIsIncluded());

            pDestinationMqf = static_cast<CBaseMqfHeader*>(pSection);
            pSection = pDestinationMqf->GetNextSection();

            pAdminMqf = static_cast<CBaseMqfHeader*>(pSection);
            pSection = pAdminMqf->GetNextSection();

            pResponseMqf = static_cast<CBaseMqfHeader*>(pSection);
            pSection = pResponseMqf->GetNextSection();

			pMqfSignature = static_cast<CMqfSignatureHeader*>(pSection);
			pSection = pMqfSignature->GetNextSection();
        }

        //
        // Get the SRMP sections: Envelope, CompoundMessage
        //
        if (pUser->SrmpIsIncluded())
        {
            pSrmpEnvelope = static_cast<CSrmpEnvelopeHeader*>(pSection);
            pSection = pSrmpEnvelope->GetNextSection();

            pCompoundMessage = static_cast<CCompoundMessageHeader*>(pSection);
            pSection = pCompoundMessage->GetNextSection();
        }

        //
        // Get the EOD section
        //
        if (pUser->EodIsIncluded())
        {
            pEod = static_cast<CEodHeader*>(pSection);
            pSection = pEod->GetNextSection();
        }

        //
        // Get the EOD-Ack section
        //
        if (pUser->EodAckIsIncluded())
        {
            pEodAck = static_cast<CEodAckHeader*>(pSection);
            pSection = pEodAck->GetNextSection();
        }

        if(pUser->SecurityIsIncluded())
        {
            //
            // Get the security properties
            //
            ASSERT(pSec != NULL);

            if (pMsgProps->ppSenderID)
            {
                const unsigned char *pSenderID;
                USHORT uSenderIDReqLen;

                pSenderID = pSec->GetSenderID(&uSenderIDReqLen);

                if (pMsgProps->uSenderIDLen < uSenderIDReqLen)
                {
                    rc = MQ_ERROR_SENDERID_BUFFER_TOO_SMALL;
                }

                PUCHAR pSenderIDBuffer = *pMsgProps->ppSenderID;
                ACProbeForWrite(pSenderIDBuffer, pMsgProps->uSenderIDLen);
                memcpy(
                    pSenderIDBuffer,
                    pSenderID,
                    min(pMsgProps->uSenderIDLen, uSenderIDReqLen)
                    );
            }

            if (pMsgProps->pulSenderIDLenProp)
            {
                USHORT uSenderIDReqLen;
                pSec->GetSenderID(&uSenderIDReqLen);
                *pMsgProps->pulSenderIDLenProp = uSenderIDReqLen;
            }

            if (pMsgProps->pulSenderIDType)
            {
                *pMsgProps->pulSenderIDType = pSec->GetSenderIDType();
            }

            if (pMsgProps->ppSymmKeys)
            {
                const unsigned char *pSymmKey;
                USHORT uSymmKeySize;

                pSymmKey = pSec->GetEncryptedSymmetricKey(&uSymmKeySize);

                if (pMsgProps->ulSymmKeysSize < uSymmKeySize)
                {
                    rc = MQ_ERROR_SYMM_KEY_BUFFER_TOO_SMALL;
                }

                PUCHAR pSymmKeyBuffer = *pMsgProps->ppSymmKeys;
                ACProbeForWrite(pSymmKeyBuffer, pMsgProps->ulSymmKeysSize);
                memcpy(
                    pSymmKeyBuffer,
                    pSymmKey,
                    min(pMsgProps->ulSymmKeysSize, uSymmKeySize)
                    );
            }

            if (pMsgProps->pulSymmKeysSizeProp)
            {
                USHORT uSymmKeysSize;
                pSec->GetEncryptedSymmetricKey(&uSymmKeysSize);
                *pMsgProps->pulSymmKeysSizeProp = uSymmKeysSize;
            }

            if (pMsgProps->ppSenderCert)
            {
                const unsigned char *pSenderCert;
                ULONG ulSenderCertReqLen;

                pSenderCert = pSec->GetSenderCert(&ulSenderCertReqLen);

                if (pMsgProps->ulSenderCertLen < ulSenderCertReqLen)
                {
                    rc = MQ_ERROR_SENDER_CERT_BUFFER_TOO_SMALL;
                }

                PUCHAR pSenderCertBuffer = *pMsgProps->ppSenderCert;
                ACProbeForWrite(pSenderCertBuffer, pMsgProps->ulSenderCertLen);
                memcpy(
                    pSenderCertBuffer,
                    pSenderCert,
                    min(pMsgProps->ulSenderCertLen, ulSenderCertReqLen)
                    );
            }

            if (pMsgProps->pulSenderCertLenProp)
            {
                pSec->GetSenderCert(pMsgProps->pulSenderCertLenProp);
            }

            if (pMsgProps->ppSignature)
            {
                const unsigned char *pSignature;
                USHORT uSignatureSize;

                pSignature = pSec->GetSignature(&uSignatureSize);

                if (pMsgProps->ulSignatureSize < uSignatureSize)
                {
                    rc = MQ_ERROR_SIGNATURE_BUFFER_TOO_SMALL;
                }

                PUCHAR pSignatureBuffer = *pMsgProps->ppSignature;
                ACProbeForWrite(pSignatureBuffer, pMsgProps->ulSignatureSize);
                memcpy(
                    pSignatureBuffer,
                    pSignature,
                    min(pMsgProps->ulSignatureSize, uSignatureSize)
                    );
            }

            if (pMsgProps->pulSignatureSizeProp)
            {
                USHORT uSignatureSize;
                pSec->GetSignature(&uSignatureSize);
                *pMsgProps->pulSignatureSizeProp = uSignatureSize;
            }

            if (pMsgProps->pAuthenticated)
            {
                //
                // See if caller of MQReceiveMessge() asked for the
                // PROPID_M_AUTHENTICATED_EX property.
                //
                BOOL bGetEx = (((*pMsgProps->pAuthenticated) &
                                  MQMSG_AUTHENTICATION_REQUESTED_EX) ==
                                        MQMSG_AUTHENTICATION_REQUESTED_EX);
                *pMsgProps->pAuthenticated = 0;

                if (bGetEx)
                {
                    *pMsgProps->pAuthenticated = pSec->GetLevelOfAuthentication();
                }
                else if (pSec->IsAuthenticated())
                {
                    *pMsgProps->pAuthenticated = MQMSG_AUTHENTICATION_REQUESTED;
                }
            }

            USHORT uSignatureSize;
            pSec->GetSignature(&uSignatureSize);

            if (uSignatureSize)
            {
                //
                // Get the CSP information from the packet.
                //
                BOOL bDefProv;
                LPCWSTR pwstrProvName;
                ULONG ulProvType;

                pSec->GetProvInfo(&bDefProv, &pwstrProvName, &ulProvType);

                if (pMsgProps->pulProvType)
                {
                    *pMsgProps->pulProvType = bDefProv ? DEFAULT_E_PROV_TYPE : ulProvType;
                }

                if (pMsgProps->pulAuthProvNameLenProp)
                {
                    //
                    // Return to caller only the length of provider name,
                    // without the "Extra" that is added after the name.
					//

					ULONG ulProvNameSize = (ULONG)((bDefProv ?
					DEFAULT_E_DEFAULTCSP_LEN : wcslen(pwstrProvName)) + 1);
             		

                    if (pMsgProps->ppwcsProvName)
                    {
                        PWCHAR pProvName = *pMsgProps->ppwcsProvName;
                        ACProbeForWrite(pProvName,
                              *pMsgProps->pulAuthProvNameLenProp * sizeof(WCHAR)) ;

                        if (ulProvNameSize > *pMsgProps->pulAuthProvNameLenProp)
                        {
                            rc = MQ_ERROR_PROV_NAME_BUFFER_TOO_SMALL;
                        }

                        ULONG ulSize = min(ulProvNameSize,
                                          *pMsgProps->pulAuthProvNameLenProp);
                        memcpy(
                            pProvName,
                            (bDefProv ? DEFAULT_E_DEFAULTCSP : pwstrProvName),
                            ulSize * sizeof(WCHAR)
                            );
                        if (ulSize > 0)
                        {
                            pProvName[ulSize-1] = L'\0';
                        }
                    }

                    *pMsgProps->pulAuthProvNameLenProp = ulProvNameSize;
                }
            }
            else
            {
                if (pMsgProps->pulAuthProvNameLenProp)
                {
                    *pMsgProps->pulAuthProvNameLenProp = 0;
                }
            }


        }
        else
        {
            ASSERT(pSec == NULL);

            if (pMsgProps->pulSenderIDLenProp)
            {
                *pMsgProps->pulSenderIDLenProp = 0;
            }

            if(pMsgProps->pulSenderIDType)
            {
                *pMsgProps->pulSenderIDType = MQMSG_SENDERID_TYPE_NONE;
            }

            if (pMsgProps->pulSymmKeysSizeProp)
            {
                *pMsgProps->pulSymmKeysSizeProp = 0;
            }

            if (pMsgProps->pulSenderCertLenProp)
            {
                *pMsgProps->pulSenderCertLenProp = 0;
            }

            pMsgProps->uSenderIDLen = 0;

            if (pMsgProps->pAuthenticated)
            {
                *pMsgProps->pAuthenticated = 0;
            }

            if (pMsgProps->pulSignatureSizeProp)
            {
                *pMsgProps->pulSignatureSizeProp = 0;
            }

            if (pMsgProps->pulAuthProvNameLenProp)
            {
                *pMsgProps->pulAuthProvNameLenProp = 0;
            }
        }

        ASSERT(pProp != NULL);

        if(pMsgProps->pClass)
        {
            *pMsgProps->pClass = pProp->GetClass();
        }

        if(pMsgProps->ppSrcQMID)
        {
            GUID* pSrcID = *pMsgProps->ppSrcQMID;
            ACProbeForWrite(pSrcID, sizeof(GUID));
            *pSrcID = *pUser->GetSourceQM();
        }

        if (pMsgProps->ppConnectorType)
        {
            GUID* pConnectorType = *pMsgProps->ppConnectorType;
            ACProbeForWrite(pConnectorType, sizeof(GUID));
            const GUID* pPacketConnectorType = pUser->GetConnectorType();
            if(pPacketConnectorType != 0)
            {
                *pConnectorType = *pPacketConnectorType;
            }
            else
            {
                memset(pConnectorType, 0, sizeof(GUID));
            }
        }

        QUEUE_FORMAT qf;
        BOOL success;
        DBG_USED(success);
        if(pReceiveParams->pulResponseFormatNameLenProp)
        {
            success = pUser->GetResponseQueue(&qf);
            ASSERT(success || (qf.GetType() == QUEUE_FORMAT_TYPE_UNKNOWN));

            rc = ACpGetQueueFormatString(
                    rc,
                    qf,
                    pReceiveParams->ppResponseFormatName,
                    pReceiveParams->pulResponseFormatNameLenProp,
                    false
                    );
        }

        if(pReceiveParams->pulAdminFormatNameLenProp)
        {
            success = pUser->GetAdminQueue(&qf) ;
            ASSERT(success || (qf.GetType() == QUEUE_FORMAT_TYPE_UNKNOWN));

            rc = ACpGetQueueFormatString(
                    rc,
                    qf,
                    pReceiveParams->ppAdminFormatName,
                    pReceiveParams->pulAdminFormatNameLenProp,
                    false
                    );
        }

        if(pReceiveParams->pulDestFormatNameLenProp)
        {
           success = pUser->GetDestinationQueue(&qf);
           ASSERT(success);

            rc = ACpGetQueueFormatString(
                    rc,
                    qf,
                    pReceiveParams->ppDestFormatName,
                    pReceiveParams->pulDestFormatNameLenProp,
                    false
                    );
        }

        if(pReceiveParams->pulOrderingFormatNameLenProp)
        {
            //
            // Returns the xact status queue only if the packet is transacted
            //
            if(pUser->IsOrdered())
            {
               qf.PrivateID(*pUser->GetSourceQM(), ORDER_QUEUE_PRIVATE_INDEX);
            }

            rc = ACpGetQueueFormatString(
                    rc,
                    qf,
                    pReceiveParams->ppOrderingFormatName,
                    pReceiveParams->pulOrderingFormatNameLenProp,
                    false
                    );
        }

        if(pMsgProps->ppMessageID)
        {
            OBJECTID* pMessageID = *pMsgProps->ppMessageID;
            ACProbeForWrite(pMessageID, sizeof(OBJECTID));
            pUser->GetMessageID(*pMsgProps->ppMessageID);
        }

        if(pMsgProps->ppCorrelationID)
        {
            PUCHAR pCorrelationID = *pMsgProps->ppCorrelationID;
            ACProbeForWrite(pCorrelationID, PROPID_M_CORRELATIONID_SIZE);
            pProp->GetCorrelationID(pCorrelationID);
        }

        if (pMsgProps->pulVersion)
        {
            *pMsgProps->pulVersion = pBase->GetVersion();
        }

        if(pMsgProps->pPriority)
        {
            *pMsgProps->pPriority = pBase->GetPriority();
        }

        if(pMsgProps->pDelivery)
        {
            *pMsgProps->pDelivery = pUser->GetDelivery();
        }

        if(pMsgProps->pAcknowledge)
        {
            *pMsgProps->pAcknowledge = pProp->GetAckType();
        }

        if(pMsgProps->pAuditing)
        {
            *pMsgProps->pAuditing = pUser->GetAuditing();
        }

        if (pMsgProps->pSentTime)
        {
            *pMsgProps->pSentTime = pUser->GetSentTime();
        }

        if (pMsgProps->pArrivedTime)
        {
            *pMsgProps->pArrivedTime = ppi->ArrivalTime() ;
        }

        if(pMsgProps->pApplicationTag)
        {
            *pMsgProps->pApplicationTag = pProp->GetApplicationTag();

            //
            //  The following trace is to help trouble shoot the Redmond stress issue
            //  The client heartbeat has Application tag value of 21 (0x15) value
            //
            TrTRACE(
                PROFILING, 
                "Message Application Tag Value = 0x%x",
                *pMsgProps->pApplicationTag
                );
        }

        if(pMsgProps->pMsgExtensionSize)
        {
            *pMsgProps->pMsgExtensionSize = pProp->GetMsgExtensionSize();
        }

        if(pMsgProps->ppMsgExtension)
        {
            //
            //  Even in an overflow copy the message extension to user buffer
            //
            PUCHAR pMsgExtension = *pMsgProps->ppMsgExtension;
            ACProbeForWrite(pMsgExtension, pMsgProps->ulMsgExtensionBufferInBytes);
            pProp->GetMsgExtension(pMsgExtension, pMsgProps->ulMsgExtensionBufferInBytes);

            if(pMsgProps->ulMsgExtensionBufferInBytes < pProp->GetMsgExtensionSize())
            {
                rc = MQ_ERROR_BUFFER_OVERFLOW;
            }

            if (WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
            {
		//
                // The following is to display the first 3 DWORD in the extension property
                // The Redmond stress client heartbeats has extension field and the first three
                // DWORD are as follow:
                //  
                //    DWORD dwVersion
                //    DWORD dwSenderID
                //    DWORD dwStressID
                //
                int nExtensionLength = pProp->GetMsgExtensionSize();
                
                if(nExtensionLength >= 3*sizeof(DWORD))
                {
                DWORD *pdwMsgExtension=reinterpret_cast<DWORD *>(pMsgExtension);

                    TrTRACE(
                        PROFILING, 
                        "Message Extension size = %d, first three DWORD = 0x%x, 0x%x, 0x%x",
                        nExtensionLength,
                        *pdwMsgExtension,
                        *(pdwMsgExtension+1),
                        *(pdwMsgExtension+2)
                        );
                }
            }
            
        }

        if(pMsgProps->pBodySize)
        {
            if (pCompoundMessage != NULL)
            {
                *pMsgProps->pBodySize = pCompoundMessage->GetBodySizeInBytes();
            }
            else
            {
                *pMsgProps->pBodySize = pProp->GetBodySize();
            }
        }

        if(pMsgProps->ppBody)
        {
            //
            //  Even in an overflow copy the body to user buffer
            //
            PUCHAR pBody = *pMsgProps->ppBody;
            ACProbeForWrite(pBody, pMsgProps->ulBodyBufferSizeInBytes);

            if (pCompoundMessage != NULL)
            {
                pCompoundMessage->GetBody(pBody, pMsgProps->ulBodyBufferSizeInBytes);
                if(pMsgProps->ulBodyBufferSizeInBytes < pCompoundMessage->GetBodySizeInBytes())
                {
                    rc = MQ_ERROR_BUFFER_OVERFLOW;
                }
            }
            else
            {
                pProp->GetBody(pBody, pMsgProps->ulBodyBufferSizeInBytes);
                if(pMsgProps->ulBodyBufferSizeInBytes < pProp->GetBodySize())
                {
                    rc = MQ_ERROR_BUFFER_OVERFLOW;
                }
            }
        }

        if (pMsgProps->pulPrivLevel)
        {
            *pMsgProps->pulPrivLevel = pProp->GetPrivLevel();
        }

        if (pMsgProps->pulHashAlg && pSec)
        {
            if (pSec->IsAuthenticated() || ppi->InConnectorQueue())
            {
                //
                // packets in connector queue are not authenticated (the
                // qm does not authenticate them). But connector server
                // code (like bridge) need to read the hash algorithm
                // to know if it need to authenticate the packet.
                //
                *pMsgProps->pulHashAlg = pProp->GetHashAlg();
            }
        }

        if (pMsgProps->pulEncryptAlg && (pProp->GetPrivLevel() != MQMSG_PRIV_LEVEL_NONE))
        {
            *pMsgProps->pulEncryptAlg = pProp->GetEncryptAlg();
        }

        if(pMsgProps->pulTitleBufferSizeInWCHARs)
        {
            if (pMsgProps->ppTitle)
            {
                PWCHAR pTitle = *pMsgProps->ppTitle;
                //
                //  Even in an overflow copy the message extension to user buffer
                //

                ACProbeForWrite(pTitle, *pMsgProps->pulTitleBufferSizeInWCHARs * sizeof(WCHAR));
                pProp->GetTitle(pTitle, *pMsgProps->pulTitleBufferSizeInWCHARs);

                if(*pMsgProps->pulTitleBufferSizeInWCHARs < pProp->GetTitleLength())
                {
                    rc = MQ_ERROR_LABEL_BUFFER_TOO_SMALL;
                }

                if (WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
                {
                    long lLabelLength=pProp->GetTitleLength();

                    if( lLabelLength )
                    {
                        TrTRACE(
                            PROFILING, 
                            "Message Label size = %d, Label:%S",
                            lLabelLength,
                            pTitle
                            );
                    }
                   
                }

            }
            *pMsgProps->pulTitleBufferSizeInWCHARs = pProp->GetTitleLength();




        }

        //
        //  Timeout will never be seen by the RT
        //

        if(pMsgProps->pTrace)
        {
            *pMsgProps->pTrace = (UCHAR) pBase->GetTraced();
        }

        if (pMsgProps->pulBodyType)
        {
            *pMsgProps->pulBodyType = pProp->GetBodyType();
        }

        if (pMsgProps->pulRelativeTimeToQueue)
        {
            ULONG ulTimeout = pBase->GetAbsoluteTimeToQueue();
            if(ulTimeout != INFINITE)
            {
                ulTimeout = AbsoluteToRelativeTime(ulTimeout);
            }
            *pMsgProps->pulRelativeTimeToQueue = ulTimeout;
        }

        if (pMsgProps->pulRelativeTimeToLive)
        {
            ULONG ulTimeout = pUser->GetTimeToLiveDelta();
            if(ulTimeout != INFINITE)
            {
                ulTimeout += pBase->GetAbsoluteTimeToQueue();
                ulTimeout = AbsoluteToRelativeTime(ulTimeout);
            }
            *pMsgProps->pulRelativeTimeToLive = ulTimeout;
        }

        if (pMsgProps->pbFirstInXact)
        {
            *pMsgProps->pbFirstInXact = (pXact ? pXact->GetFirstInXact() : (UCHAR)FALSE);
        }

        if (pMsgProps->pbLastInXact)
        {
            *pMsgProps->pbLastInXact = (pXact ? pXact->GetLastInXact() : (UCHAR)FALSE);
        }

        if(pMsgProps->ppXactID)
        {
            OBJECTID* pXactID = *pMsgProps->ppXactID;
            ACProbeForWrite(pXactID, sizeof(OBJECTID));
			if(pXact)
			{
				pXactID->Lineage = *pUser->GetSourceQM();
				pXactID->Uniquifier = pXact->GetXactIndex();
			}
			else
			{
				memset(pXactID, 0, sizeof(OBJECTID));
			}
        }

        if(pReceiveParams->pulDestMqfLenProp != NULL)
        {
            ULONG ulDestMqfLenProp = *pReceiveParams->pulDestMqfLenProp;
            rc = ACpGetMqfProperty(rc, pDestinationMqf, pReceiveParams->pulDestMqfLenProp, pReceiveParams->ppDestMqf);

            if(*pReceiveParams->pulDestMqfLenProp == 0)
            {
                *pReceiveParams->pulDestMqfLenProp = ulDestMqfLenProp;
                success = pUser->GetDestinationQueue(&qf);
                ASSERT(success);

                rc = ACpGetQueueFormatString(
                         rc,
                         qf,
                         pReceiveParams->ppDestMqf,
                         pReceiveParams->pulDestMqfLenProp,
                         false
                         );
            }
        }

        if(pReceiveParams->pulAdminMqfLenProp != NULL)
        {
            ULONG ulAdminMqfLenProp = *pReceiveParams->pulAdminMqfLenProp;
            rc = ACpGetMqfProperty(rc, pAdminMqf, pReceiveParams->pulAdminMqfLenProp, pReceiveParams->ppAdminMqf);

            if(*pReceiveParams->pulAdminMqfLenProp == 0)
            {
                *pReceiveParams->pulAdminMqfLenProp = ulAdminMqfLenProp;
                success = pUser->GetAdminQueue(&qf) ;
                ASSERT(success || (qf.GetType() == QUEUE_FORMAT_TYPE_UNKNOWN));

                rc = ACpGetQueueFormatString(
                         rc,
                         qf,
                         pReceiveParams->ppAdminMqf,
                         pReceiveParams->pulAdminMqfLenProp,
                         false
                         );
            }
        }

        if(pReceiveParams->pulResponseMqfLenProp != NULL)
        {
            ULONG ulResponseMqfLenProp = *pReceiveParams->pulResponseMqfLenProp;
            rc = ACpGetMqfProperty(rc, pResponseMqf, pReceiveParams->pulResponseMqfLenProp, pReceiveParams->ppResponseMqf);

            if(*pReceiveParams->pulResponseMqfLenProp == 0)
            {
                *pReceiveParams->pulResponseMqfLenProp = ulResponseMqfLenProp;
                success = pUser->GetResponseQueue(&qf);
                ASSERT(success || (qf.GetType() == QUEUE_FORMAT_TYPE_UNKNOWN));

                rc = ACpGetQueueFormatString(
                        rc,
                        qf,
                        pReceiveParams->ppResponseMqf,
                        pReceiveParams->pulResponseMqfLenProp,
                        false
                        );
            }
        }

        if (pMsgProps->pLookupId != NULL)
        {
            *pMsgProps->pLookupId = LookupId();
        }

        if (pMsgProps->pSrmpEnvelopeBufferSizeInWCHARs != NULL)
        {
            if (pSrmpEnvelope == NULL)
            {
                *pMsgProps->pSrmpEnvelopeBufferSizeInWCHARs = 0;
            }
            else
            {
                if (pMsgProps->ppSrmpEnvelope != NULL)
                {
                    //
                    // Even in an overflow copy the buffer to user buffer
                    //
                    WCHAR * pEnvelope = *pMsgProps->ppSrmpEnvelope;
                    ULONG EnvelopeBufferLengthInWCHARs = *pMsgProps->pSrmpEnvelopeBufferSizeInWCHARs;
                    ACProbeForWrite(pEnvelope, EnvelopeBufferLengthInWCHARs * sizeof(WCHAR));
                    pSrmpEnvelope->GetData(pEnvelope, EnvelopeBufferLengthInWCHARs);

                    if (EnvelopeBufferLengthInWCHARs < pSrmpEnvelope->GetDataLengthInWCHARs())
                    {
                        rc = MQ_ERROR_BUFFER_OVERFLOW;
                    }
                }

                *pMsgProps->pSrmpEnvelopeBufferSizeInWCHARs = pSrmpEnvelope->GetDataLengthInWCHARs();
            }
        }

        if (pMsgProps->pCompoundMessageSizeInBytes != NULL)
        {
            if (pCompoundMessage == NULL)
            {
                *pMsgProps->pCompoundMessageSizeInBytes = 0;
            }
            else
            {
                *pMsgProps->pCompoundMessageSizeInBytes = pCompoundMessage->GetDataSizeInBytes();
            }
        }

        if (pMsgProps->ppCompoundMessage != NULL)
        {
            if (pCompoundMessage != NULL)
            {
                //
                // Even in an overflow copy the buffer to user buffer
                //
                UCHAR * pCompoundMsg = *pMsgProps->ppCompoundMessage;
                ACProbeForWrite(pCompoundMsg, pMsgProps->CompoundMessageSizeInBytes);
                pCompoundMessage->GetData(pCompoundMsg, pMsgProps->CompoundMessageSizeInBytes);

                if (pMsgProps->CompoundMessageSizeInBytes < pCompoundMessage->GetDataSizeInBytes())
                {
                    rc = MQ_ERROR_BUFFER_OVERFLOW;
                }
            }
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return GetExceptionCode();
    }

    return rc;

} // CPacket::GetProperties


inline NTSTATUS CPacket::DoneXact(const XACTUOW* pUow)
{
    CTransaction* pXact = CTransaction::Find(pUow);
    if(pXact == 0)
    {
        return MQ_ERROR_TRANSACTION_SEQUENCE;
    }

    return pXact->ProcessReceivedPacket(this);

}


CPacket* CPacket::CreateXactDummy(CTransaction* pXact)
{
    ASSERT(StorageIssued());
    ASSERT(StorageCompleted());
    ASSERT(!DeleteStorageIssued());

    PVOID p = ExAllocatePoolWithTag(PagedPool, sizeof(CPacket), 'AXQM');
    if (p == NULL)
    {
        return NULL;
    }

    CPacket* pDummy = new (p) CPacket(Allocator(), AllocatorBlockOffset());

    //
    //  Mark this packet as received, link it to the dummy entry,
    //
    IsReceived(TRUE);
    OtherPacket(pDummy);

    //
    //  Link the dummy enty to the real packet, insert it into the transaction
    //
    pDummy->OtherPacket(this);
    pDummy->Transaction(pXact);

    //
    // Copy storage state to dummy
    //
    pDummy->StorageIssued(StorageIssued());
    pDummy->StorageCompleted(StorageCompleted());
    pDummy->DeleteStorageIssued(DeleteStorageIssued());
    pDummy->IsReceived(IsReceived());

    return pDummy;
}


NTSTATUS CPacket::ProcessRequest(PIRP irp)
{
    if(IsReceived())
    {
        //
        //  This is an already received packet, it can not be processed by this
        //  request. return appropriate error.
        //  This may happen if a cursor points to an already received message.
        //  Decrement cursor ref count (AddRef done in CQueueBase::ProcessRequest).
        //
	    TrWARNING(AC, "Message already received: irp=0x%p, pPacket=0x%p", irp, this);
        ACpRelease(irp_driver_context(irp)->Cursor());
        return MQ_ERROR_MESSAGE_ALREADY_RECEIVED;
    }

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    ULONG ioctl = irpSp->Parameters.DeviceIoControl.IoControlCode;

    switch(ioctl)
    {
        case IOCTL_AC_GET_PACKET:
            return ProcessQMRequest(irp);

#ifdef _WIN64
        case IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_32:
        case IOCTL_AC_RECEIVE_MESSAGE_32:
            return ProcessRTRequest_32(irp);
#endif //_WIN64

        case IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID:
        case IOCTL_AC_RECEIVE_MESSAGE:
            return ProcessRTRequest(irp);

        case IOCTL_AC_BEGIN_GET_PACKET_2REMOTE:
            return ProcessRRRequest(irp);
    }

    //
    //  we should never get here
    //
    ASSERT(ioctl == IOCTL_AC_RECEIVE_MESSAGE);
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS CPacket::ProcessRRRequest(PIRP irp)
{
    ASSERT(Transaction() == 0);

    if(irp_driver_context(irp)->IrpWillFreePacket())
    {
	    TrTRACE(AC, "Irp Will Free Packet, irp=0x%p, pPacket=0x%p", irp, this);
        return ProcessQMRequest(irp);
    }

    //
    //  Get the cursor associated with this irp,
    //  AutoDecrement cursor ref count (AddRef done in CQueueBase::ProcessRequest).
    //
    R<CCursor> pCursor = irp_driver_context(irp)->Cursor();

    CPacketBuffer * ppb = Buffer();
    if (ppb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if(pCursor)
    {
	    TrTRACE(AC, "Set cursor to packet, irp=0x%p, pPacket=0x%p, pCursor = 0x%p", irp, this, pCursor);
        pCursor->SetTo(this);
    }

    //
    // Clone a copy of this packet. Keep same SequentialID.
    //

    CPacketInfo * ppi = ppb;
    ULONGLONG SequentialID = ppi->SequentialId();
    CPacket* pPacket = CloneCopy(ptReliable, FALSE);
    if(pPacket == 0)
    {
        TrERROR(AC, "Failed to Clone a packet while procesing a remote read request.");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ppi = pPacket->Buffer();
    ASSERT(ppi != NULL);
    ppi->SequentialID(SequentialID);

    return pPacket->ProcessQMRequest(irp);
}


NTSTATUS CPacket::ProcessQMRequest(PIRP irp)
{
    ASSERT(Transaction() == 0);

    //
    //  The QM output is the packet pointer. This is a METHOD_BUFFERED call
    //
    CACPacketPtrs * pPacketPtrs = static_cast<CACPacketPtrs*>(irp->AssociatedIrp.SystemBuffer);

    //
    //  Relink packet in the sequence
    //
    if(Queue() != 0)
    {
        NTSTATUS rc = (Queue()->RelinkPacket(this));
        if (!NT_SUCCESS(rc))
        {
            return rc;
        }
    }

    //
    // Give the QM a pointer in its address space
    // to the packet buffer and pin-down the buffer.
    //
    CBaseHeader * pBase = AC2QM(this);
    if (pBase == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pPacketPtrs->pPacket= pBase;
    pPacketPtrs->pDriverPacket = this;
    AddRefBuffer();
    irp->IoStatus.Information = sizeof(CACPacketPtrs);

    //
    //  Mark the packet as received
    //
    IsReceived(TRUE);

    TrTRACE(AC, " *QMRequest(irp=0x%p, pPacket=0x%p)*", irp, this);
    return STATUS_SUCCESS;
}


NTSTATUS CPacket::ProcessRTRequestTB(PIRP irp, CACReceiveParameters * pReceiveParams)
{
    ASSERT(Transaction() == 0);

    //
    //  Get the cursor associated with this irp,
    //  AutoDecrement cursor ref count (AddRef done in CQueueBase::ProcessRequest).
    //
    R<CCursor> pCursor = irp_driver_context(irp)->Cursor();

    PEPROCESS pProcess = IoGetRequestorProcess(irp);
    PEPROCESS pDetach = ACAttachProcess(pProcess);

    NTSTATUS rc;
    rc = GetProperties(pReceiveParams);

    XACTUOW uow;
    if(pReceiveParams->MsgProps.pUow != 0)
    {
        memcpy(&uow, pReceiveParams->MsgProps.pUow, sizeof(XACTUOW));
    }

    ACDetachProcess(pDetach);

    if(pCursor)
    {
        //
        //  This packet is released to a cursor request, thus
        //  let the cursor point to this packet, (SetTo will AddRef this)
        //
        //  NOTE: The cursor should be set to this packet BEFORE retruning
        //      in-case of an error, thus letting the receiver point to this
        //      packet. (e.g., the receiver buffer was too small, so it can
        //      receive this packet again using peek_current)
        //
        pCursor->SetTo(this);
    }

    //
    //  Check if there was a GetProperties parsing error
    //
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    //
    //  That was a receive request rather than a peek operation
    //
    if(irp_driver_context(irp)->IrpWillFreePacket())
    {
        if(pReceiveParams->MsgProps.pUow != 0)
        {
            rc = DoneXact(&uow);

            //
            //  If an error, return without moving the cursor
            //
            if(!NT_SUCCESS(rc))
            {
                return rc;
            }
        }
        else
        {
            ASSERT(!DeleteStorageIssued());

            //
            // AddRef so Done will not free the packet
            //
            AddRef();
            Done(0, Buffer());
            if(DeleteStorageIssued())
            {
                //
                // Attach packet to irp, AddRef the packet, hold irp in list.
                //
                irp_driver_context(irp)->MultiPackets(false);
                CIrp2Pkt::AttachSinglePacket(irp, this);
                AddRef();

                HoldWriteRequest(irp);
                irp = 0;
                rc = STATUS_PENDING;
            }
            else if(StorageIssued())
            {
	            rc = STATUS_INSUFFICIENT_RESOURCES;
            }
            Release();
        }

        if(pCursor)
        {
            //
            //  This packet is received, don't allow peek next using this cursor
            //
            pCursor->InvalidatePosition();
        }

    }

    TrTRACE(AC, " *RTRequestTB(irp=0x%p, pPacket=0x%p, pCursor=0x%p, rc=0x%x)*", irp, this, pCursor, rc);
    return rc;
}


NTSTATUS CPacket::ProcessRTRequest(PIRP irp)
{
    //
    //  The RT receive buffer is in SystemBuffer. This is a METHOD_BUFFERED call
    //
    CACReceiveParameters * pReceiveParams =
        static_cast<CACReceiveParameters*>(irp->AssociatedIrp.SystemBuffer);
    //
    // Call ProcessRTRequestTB to fill the buffer
    //
    NTSTATUS rc = ProcessRTRequestTB(irp, pReceiveParams);
    //
    // return result
    //
    TrTRACE(AC, " *RTRequest(irp=0x%p, pPacket=0x%p, rc=0x%x)*", irp, this, rc);
    return rc;
}


#ifdef _WIN64
NTSTATUS CPacket::ProcessRTRequest_32(PIRP irp)
{
    //
    //  The RT buffer is in SystemBuffer. This is a METHOD_BUFFERED call
    //
    CACReceiveParameters_32 * pReceiveParams32 =
        static_cast<CACReceiveParameters_32*>(irp->AssociatedIrp.SystemBuffer);
    //
    // Convert CACReceiveParameters_32 to CACReceiveParameters
    //
    CACReceiveParameters         ReceiveParams;
    CACReceiveParameters64Helper Helper;

    PEPROCESS pProcess = IoGetRequestorProcess(irp);
    PEPROCESS pDetach = ACAttachProcess(pProcess);
    ACpReceiveParams32ToReceiveParams(pReceiveParams32, &Helper, &ReceiveParams);
    ACDetachProcess(pDetach);

    //
    // Call the regular 64 bit ProcessRTRequestTB to fill the 64 bit buffer
    //
    NTSTATUS rc = ProcessRTRequestTB(irp, &ReceiveParams);
    //
    // Convert CACReceiveParameters back to CACReceiveParameters_32, no matter
    // what the result of ProcessRTRequestTB was, since on win32
    // it really works on the pReceiveParams itself
    //
    ACpReceiveParamsToReceiveParams32(&ReceiveParams, &Helper, pReceiveParams32);

    //
    // return result
    //
    TrTRACE(AC, " *RTRequest_32(irp=0x%p, pPacket=0x%p, rc=0x%x)*", irp, this, rc);
    return rc;
}
#endif //_WIN64


NTSTATUS CPacket::RemoteRequestTail(CCursor* pCursor, BOOL fFreePacket, CPacketBuffer * ppb)
{
    ASSERT(ppb != NULL && MappedBuffer() == ppb);

    IsReceived(FALSE);
    if(pCursor)
    {
        pCursor->SetTo(this);
    }

    if(fFreePacket)
    {
        Done(0, ppb);
        if(pCursor)
        {
            //
            //  This packet is received, don't allow peek next using this cursor
            //
            pCursor->InvalidatePosition();
        }
    }
    else
    {
        //
        //  return the packet to the queue, incase an irp is pending
        //
        CQueue* pQueue = Queue();
        ASSERT(pQueue != 0);

        NTSTATUS rc;
        PIRP tempIrp = NULL;
        rc = pQueue->PutPacket(tempIrp, this, ppb);
        ASSERT(NT_SUCCESS(rc));
    }

    ACpRelease(pCursor);
    return STATUS_SUCCESS;
}


//---------------------------------------------------------
//
//  Packet logic functions
//
//---------------------------------------------------------

CPacket* CPacket::CloneSame()
{
    CPacketInfo* ppi = Buffer();
    if (ppi == NULL)
    {
        return NULL;
    }

    CPacket* pPacket = new (PagedPool) CPacket(Allocator(), AllocatorBlockOffset());
    if(pPacket == NULL)
    {
        return NULL;
    }

    ppi->SequentialID(ACpGetSequentialID());
    DetachBuffer();

	//
    // QM may reference the original packet when sending ack
    //
    AssertNoOtherPacket();
    OtherPacket(pPacket) ;

    return pPacket;
}


CPacket* CPacket::CloneCopy(ACPoolType pt, BOOL fCheckMachineQuota) const
{
    if(g_pQM->Process() == 0)
    {
        return 0;
    }

    PEPROCESS pDetach = ACAttachProcess(g_pQM->Process());

    CPacketBuffer* ppb = Buffer();
    if (ppb == NULL)
    {
        ACDetachProcess(pDetach);
        return 0;
    }

    AddRefBuffer();

    CPacket* _pPacket = 0;
    ULONG ulSize = ppb->GetPacketSize();
    NTSTATUS rc;
    rc = Create(
            &_pPacket,
            ulSize,
            pt,
            fCheckMachineQuota
            );

    if(NT_SUCCESS(rc))
    {
        CPacketInfo* ppi = ppb;

        CPacketInfo* _ppi =  _pPacket->Buffer();
        ASSERT(_ppi != NULL);
        memcpy(_ppi, ppi, ulSize + sizeof(CPacketInfo));

        //
        //  after coping the packet info, the serial id was distroyed,
        //  also the CPacket pointer was overwritten. restore them
        //
        _ppi->SequentialID(g_MessageSequentialID);
    }

    ACDetachProcess(pDetach);
    ReleaseBuffer();
    return _pPacket;
}


inline CPacket* CPacket::Clone(ACPoolType pt)
{
    //
    //  Make a persistent clone,
    //  a) using the same packet if posible.
    //  b) in the prefered pool and copy message buffer
    //
    return (Allocator()->IsPersistent() ? CloneSame() : CloneCopy(pt, TRUE));
}


inline ULONG CPacket::GetAbsoluteTimeToLive(CPacketBuffer * ppb, BOOL fAtTargetQueue) const
{
    ULONG ulTimeout;
    if(!BufferAttached())
    {
        return INFINITE;
    }

    ASSERT(ppb != NULL && MappedBuffer() == ppb);
    CBaseHeader* pBase = ppb;

    if(fAtTargetQueue)
    {
        CUserHeader* pUser = CPacketBuffer::UserHeader(pBase);
        ulTimeout = pUser->GetTimeToLiveDelta();
        if(ulTimeout != INFINITE)
        {
           ulTimeout += pBase->GetAbsoluteTimeToQueue();
        }
    }
    else
    {
        //
        //  We get the packet timeout here, since if received by the QM it might
        //  change to relative time.
        //
        ulTimeout = pBase->GetAbsoluteTimeToQueue();
    }

    return ulTimeout;
}


inline NTSTATUS CPacket::IssueTimeout(ULONG ulTimeout)
{
    ASSERT(ulTimeout != INFINITE);

    LARGE_INTEGER liTimeout;
    liTimeout.QuadPart = Convert1970to1601(ulTimeout);
    if(!g_pPacketScheduler->SchedAt(liTimeout, this))
        return STATUS_INSUFFICIENT_RESOURCES;

    AddRef();
    TimeoutIssued(TRUE);
    return STATUS_SUCCESS;
}


void CPacket::StartTimer(CPacketBuffer * ppb, BOOL fTarget, ULONG ulDelay)
{
    CQueue* pQueue = Queue();

    ASSERT(pQueue != 0);
    ASSERT(!TimeoutIssued());

    if(pQueue->Silent())
    {
        //
        //  Don't start timer for queues that are silent
        //
        return;
    }

    ULONG ulTimeout = GetAbsoluteTimeToLive(ppb, fTarget);
    if(ulTimeout != INFINITE)
    {
        TimeoutTarget(fTarget);

        if (ulDelay < INFINITE - ulTimeout)
        {
            ulTimeout += ulDelay;
        }
        else
        {
            ulTimeout = 0xFFFFFFFE;
        }

        Timeout(ulTimeout);
        IssueTimeout(ulTimeout);
    }

}

inline void CPacket::CancelTimeout()
{
    if(TimeoutIssued())
    {
        TimeoutIssued(FALSE);

        ULONG ulTimeout = Timeout();
        ASSERT(ulTimeout != INFINITE);

        LARGE_INTEGER liTimeout;
        liTimeout.QuadPart = Convert1970to1601(ulTimeout);

        if(g_pPacketScheduler->SchedCancel(liTimeout, this))
        {
            //
            //  Release the packet if and only if the timeout was canceled
            //
            Release();
        }
    }
}

void CPacket::Touch(CBaseHeader * pbh, ULONG ulSize)
{
    ASSERT(pbh != NULL);
	ASSERT(IoGetCurrentProcess() == g_pQM->Process());

    PCHAR pStart = (PCHAR)pbh;
    PCHAR pEnd = (PCHAR)pbh + ulSize - 1;
	
    for(PCHAR pPage = pStart; pPage < pEnd; pPage += PAGE_SIZE)
    {
        *(volatile CHAR*)pPage = *pPage;
    }

    //
    //  pStart is not page aligned so need to touch last page.
    //
    *(volatile CHAR*)pEnd = *pEnd;
}


ULONG CPacket::ComputeCRC(CPacketBuffer *ppb)
{
	CPacketInfo *ppi = ppb;
	CBaseHeader *pbh = ppb;

	PUCHAR pStart = ((PUCHAR) ppi) + sizeof(CPacket *);
	PUCHAR pEnd = ppb->GetCRCBuffer();
	ULONG ulCRC = Crc32Sum(CRC32_SEED, pStart, pEnd);
	pStart = pEnd + ppb->GetCRCBufferSize();
	CXactHeader *pxh = CPacketBuffer::XactHeader(pbh);
	if(pxh != 0)
	{
        pEnd = pxh->GetPrevSeqNBuffer();
        ulCRC = Crc32Sum(ulCRC, pStart, pEnd);
        pStart = pEnd + pxh->GetPrevSeqNBufferSize();

		if(pxh->ConnectorQMIncluded())
		{
			pEnd = pxh->GetConnectorQMBuffer();
			ulCRC = Crc32Sum(ulCRC, pStart, pEnd);
			pStart = pEnd + pxh->GetConnectorQMBufferSize();
		}
	}
	pEnd = ((PUCHAR) ppi) + sizeof(CPacketInfo) +  ppb->GetPacketSize();
	ulCRC = Crc32Sum(ulCRC, pStart, pEnd);

	return(ulCRC);
}


NTSTATUS CPacket::CheckPacket(CAccessibleBlock* pab)
{
    ASSERT(IoGetCurrentProcess() == g_pQM->Process());

    CPacketBuffer *ppb = static_cast<CPacketBuffer*>(pab);

	if(!ppb->CPacketInfo::ValidOnDiskSignature())
	{
		return(STATUS_UNSUCCESSFUL);
	}

	if(!ppb->CBaseHeader::ValidOnDiskSignature())
	{
		return(STATUS_UNSUCCESSFUL);
	}

	ULONG ulCRC = ComputeCRC(ppb);
	if(!ppb->CBaseHeader::ValidCRC(ulCRC))
	{
		CBaseHeader *pbh = ppb;
        DBG_USED(pbh);
		TrTRACE(AC, " *CRC mismatch has 0x%x need 0x%x (buffer=0x%p)*", ulCRC, pbh->GetCRC(), pab);
		return STATUS_UNSUCCESSFUL;
	}

	return STATUS_SUCCESS;
}


inline NTSTATUS CPacket::IssueStorage()
{
	//
	// We have to attach the QM before calling Buffer
	// because we want Buffer to return QM pointer
	// so the touching will be made on QM PTE.
	//
	
	PEPROCESS pDetach = ACAttachProcess(g_pQM->Process());

	CPacketBuffer *ppb = Buffer();
    if (ppb == NULL)
    {
		ACDetachProcess(pDetach);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

	ULONG ulSize = ppb->GetPacketSize();
	Touch(ppb, ulSize);

	//
	// Compute and set header pattern and packet checksum
	// N.B.
	//    Do this as late as possible in the game to prevent
	//    accidental flushes from writing valid signatures. erezh
	//
	ppb->CPacketInfo::SetOnDiskSignature();
	ppb->CBaseHeader::SetOnDiskSignature();
	ppb->SetCRC(ComputeCRC(ppb));


	//
	// Build request.
    //
    CACRequest request(CACRequest::rfStorage);
    request.Storage.pPacket = NULL;
    request.Storage.pDriverPacket = this;
    request.Storage.pAllocator = Allocator();
	request.Storage.ulSize = ulSize;

    AddRef();
    NTSTATUS rc;
    rc = g_pQM->ProcessRequest(request);
    if(!NT_SUCCESS(rc))
    {
        Release();
		ACDetachProcess(pDetach);
        return rc;
    }

	Allocator()->AddOutstandingStorage();
    StorageIssued(TRUE);
	ACDetachProcess(pDetach);
    return rc;

} // CPacket::IssueStorage


inline NTSTATUS CPacket::IssueDeleteStorage()
{
	//
	// We have to attach the QM before calling Buffer
	// because we want Buffer to return QM pointer
	// so the touching will be made on QM PTE.
	//

	PEPROCESS pDetach = ACAttachProcess(g_pQM->Process());

	CPacketBuffer *ppb = Buffer();
    if (ppb == NULL)
    {
		ACDetachProcess(pDetach);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

	//
	// Build delete storage request.
    // For small packets, flush the entire packet to optimize batch writer.
    // For big packets, write 1 page (size is set to 0).
    //

    //
	// Clear header signature
	//
	ppb->CPacketInfo::ClearOnDiskSignature();
	ppb->CBaseHeader::ClearOnDiskSignature();

    CACRequest request(CACRequest::rfStorage);
    request.Storage.pPacket = NULL;
    request.Storage.pDriverPacket = this;
    request.Storage.pAllocator = Allocator();
    request.Storage.ulSize = 0;				
    if(ppb->GetPacketSize() <= (4 *  PAGE_SIZE))
    {
        request.Storage.ulSize = ppb->GetPacketSize();
    }
    Touch(ppb, request.Storage.ulSize);

    AddRef();
    NTSTATUS rc;
    rc = g_pQM->ProcessRequest(request);
    if(!NT_SUCCESS(rc))
    {
	    ppb->CPacketInfo::SetOnDiskSignature();
	    ppb->CBaseHeader::SetOnDiskSignature();
        Release();
		ACDetachProcess(pDetach);
        return rc;
    }

    CAccessibleBlock* pab = ppb;
    ULONG size = pab->m_size;

	Allocator()->AddOutstandingStorage();
    DeleteStorageIssued(TRUE);
    UpdateBitmap(size);
	ACDetachProcess(pDetach);
    return rc;

} // CPacket::IssueDeleteStorage


void CPacket::HoldWriteRequest(PIRP irp)
{
    if(irp == 0)
    {
        return;
    }

    //
    // At this point packet[s] must be attached to irp
    //
    ASSERT(CIrp2Pkt::SafePeekFirstPacket(irp) != NULL);

    if (!irp_driver_context(irp)->MultiPackets() || !CIrp2Pkt::IsHeld(irp))
    {
        g_pStorage->HoldWriteRequest(irp);
    }

    WriterPending(TRUE);
}


NTSTATUS CPacket::DeleteStorage()
{
    if(StorageIssued() && !DeleteStorageIssued())
    {
		//
		// Mark allocator as non coherent
		//
		NTSTATUS rc;
		rc = Allocator()->MarkNotCoherent();
		if(!NT_SUCCESS(rc))
		{
			//
			// Can not mark the allocator's bitmap as non coherent, fail the operation
			//
			return rc;
		}

 		//
		// Issue delete storage request
		//
		rc = IssueDeleteStorage();
	    if(!NT_SUCCESS(rc))
		{
			//
			//  Can not issue the request, fail the operation
			//
            return rc;
		}
    }
	
	return(STATUS_SUCCESS);
}


inline CQueue* CPacket::DeadLetterQueue(CPacketBuffer * ppb) const
{
    ASSERT(ppb != NULL && MappedBuffer() == ppb);

    if(IsOrdered() && InSourceMachine() && (IsDeadLetter(ppb) || g_fXactCompatibilityMode))
    {
        return g_pMachineDeadxact;
    }

    if(!IsOrdered() && IsDeadLetter(ppb))
    {
        return g_pMachineDeadletter;
    }

    return 0;
}


inline void CPacket::Kill(USHORT usClass)
{
    ASSERT(BufferAttached());

    CQueue* pQueue = Queue();
    if(pQueue && pQueue->Silent())
    {
        return;
    }

    CPacketBuffer * ppb = Buffer();
    if (ppb == NULL)
    {
        return;
    }

    pQueue = DeadLetterQueue(ppb);
    if(pQueue == 0)
    {
        return;
    }

    //
    //  Clone this packet and put it in the dead-letter queue
    //
    CPacket* pPacket = Clone(ptJournal);
    if(pPacket == 0)
    {
        //
        //  if packet could not be allocated, it will not be journalized
        //
        return;
    }

    //
    //  Please note that this->Buffer() may have detached already
    //  or this is another copy.
    //
    ppb = pPacket->Buffer();
    ASSERT(ppb != NULL);

    CPacketInfo* ppi = ppb;
    ppi->InDeadletterQueue(TRUE);
    ppi->InMachineDeadxact(pQueue == g_pMachineDeadxact);
    CPacketBuffer::PropertyHeader(ppb)->SetClass(usClass);
    PIRP tempIrp = NULL;
    NTSTATUS rc = pQueue->PutPacket(tempIrp, pPacket, ppb);
    if (!NT_SUCCESS(rc))
    {
        pPacket->PacketRundown(rc);
    }
}


inline CQueue* CPacket::JournalQueue() const
{
    CQueue* pQueue = Queue();
    if(pQueue->TargetJournaling())
    {
        return pQueue->JournalQueue();
    }

    if(SourceJournal())
    {
        return g_pMachineJournal;
    }

    return 0;
}


inline void CPacket::Journalize()
{
    ASSERT(Queue() != 0);
    ASSERT(BufferAttached());

    CQueue* pQueue = Queue();
    if(pQueue->Silent())
    {
        return;
    }

    pQueue = JournalQueue();
    if(pQueue == 0)
    {
        return;
    }

    //
    //  Clone this packet an put it in the journal queue
    //
    CPacket* pPacket = Clone(ptJournal);
    if(pPacket == 0)
    {
        //
        //  if packet could not be allocated, it will not be journalized
        //
        return;
    }


    //
    //  Please note that this->Buffer() may have detached already
    //  or this is another copy.
    //
    CPacketBuffer * ppb = pPacket->Buffer();
    ASSERT(ppb != NULL);
    CPacketInfo * ppi = ppb;

    ppi->InJournalQueue(TRUE);
    ppi->InMachineJournal(pQueue == g_pMachineJournal);
    PIRP tempIrp = NULL;
    NTSTATUS rc = pQueue->PutPacket(tempIrp, pPacket, ppb);
    if (!NT_SUCCESS(rc))
    {
        pPacket->PacketRundown(rc);
    }
}



inline NTSTATUS CPacket::IssueAcknowledgment(USHORT usClass, BOOL fUser, BOOL fOrder)
{
    CACRequest request(CACRequest::rfAck);
    request.Ack.pPacket = NULL;
    request.Ack.pDriverPacket = this;
    request.Ack.ulClass = usClass;
    request.Ack.fUser = fUser;
    request.Ack.fOrder = fOrder;
    ASSERT(AllocatorBlockOffset().IsValidOffset());
    request.Ack.ulAllocatorBlockOffset = AllocatorBlockOffset().m_offset;

    AddRef();
    NTSTATUS rc;
    rc = g_pQM->ProcessRequest(request);
    if(!NT_SUCCESS(rc))
    {
        Release();
        return rc;
    }

    return rc;

} // CPacket::IssueAcknowledgment


void CPacket::SendAcknowledgment(USHORT usClass)
{
    CQueue* pQueue = Queue();
    if(pQueue && pQueue->Silent())
    {
        return;
    }

    CPacketBuffer* ppb = Buffer();
    if (ppb == NULL)
    {
        //
        // Either buffer is not attached, or mapping to kernel/user space failed
        //
        return;
    }

    CBaseHeader* pBase = ppb;
    CPacketInfo* ppi = ppb;

    UCHAR bAcknowledgment = CPacketBuffer::PropertyHeader(pBase)->GetAckType();

    //
    //  This is a target queue if the queue is marked as target or, the packet
    //  is not inserted in any queue. The QM *NACK* a packet immidiatly upon
    //  receiving it before putting it in a queue.
    //
    BOOL fTarget = !pQueue || pQueue->IsTargetQueue();
    ASSERT(pQueue || MQCLASS_NACK(usClass));

    BOOL fUser =
        //
        //  Validate we can send user acknowledgment
        //
        (
            //
            //  Send user ACK/NACK to ordered/non-ordered packets in target queue
            //
            fTarget ||

			//
			//  OR, if http nack and we are in the source machine.
			//
			(MQCLASS_NACK_HTTP(usClass) && InSourceMachine()) ||

            //
            // bug 7588
            // If message expired in connector queue (for example, bridge
            // is down), then nack was not returned. Fix it to return nack.
            //
            // Connector server return the first order ack when it inserts
            // xact message in connector queue. So by default, win2k source
            // computer remove the xact message from its outgoing queue.
            // without this nack, there is no feedback that something
            // wrong happen.
            // Note #1: possitive ack are returned only from the MQSeries
            // computers, not from connector server.
            // Note #2: for non connector case, routing server do not return
            // nack for xact messages, as source computer keep the xact
            // message in outgoing queue until it get order ack from target.
            // So source computer itself expire the message and generate the
            // nack. Connector queue is a special "mixed" case of being both
            // target and routing at the same time.
            //
            (ppi->InConnectorQueue() && MQCLASS_NACK(usClass) ) ||

            //
            //  OR, only NACK to non-ordered packets, from non target queue
            //
            (!IsOrdered() && MQCLASS_NACK(usClass))
        ) &&

        //
        //  AND, class matches required acknowledgment
        //
        MQCLASS_MATCH_ACKNOWLEDGMENT(usClass, bAcknowledgment);


    BOOL fOrder =

        //
        //  Send order ACK/NACK only to ordered packets
        //
        IsOrdered() &&

        //
        //  AND, at target machine
        //
        fTarget &&

        //
        //  AND, not originated locally
        //
        !InSourceMachine() &&

        //
        //  AND, that is not arrival acknowledgment class
        //
        !MQCLASS_POS_ARRIVAL(usClass);


    //
    // Not sending internal receive receipt if it was canceled
    //
    if (fOrder && MQCLASS_RECEIVE(usClass))
    {
        CXactHeader* pXactHeader = CPacketBuffer::XactHeader(pBase);
        ASSERT(pXactHeader != 0);

        if (pXactHeader->GetCancelFollowUp())
        {
            fOrder = FALSE;
        }
    }

    if(fUser || fOrder)
    {
        IssueAcknowledgment(usClass, fUser, fOrder);
    }
}


inline void CPacket::SendReceiveAcknowledgment()
{
    ASSERT(Queue() != 0);
    SendAcknowledgment(MQMSG_CLASS_ACK_RECEIVE);
}


void CPacket::Done(USHORT usClass, CPacketBuffer * ppb)
{
    ASSERT(ppb != NULL && MappedBuffer() == ppb);

    if(!IsRevoked())
    {
        //
        //  This is the first time this packet is revoked, save the final class
        //
        FinalClass(usClass);
    }

    //
    //  A packet that is done is revoked and can't be received anymore
    //
    SetRevoked();

    //
    //  cancel the storage for this packet if it was done successfully
    //
    if (!NT_SUCCESS(DeleteStorage()))
    {
        //
        //  return in order to avoid corruption
        //
        return;
    }

    //
    //  if a timer was set for the packet, cancel it
    //
    CancelTimeout();

    //
    //  Complete the writer if any, it is always successfull for the writer
    //
    CompleteWriter(STATUS_SUCCESS);

    if(IsReceived())
    {
        //
        //  The packet currently in process, e.g. Transaction, Remote Reader,
        //  held by the QM for send, or was already done.
        //
        //  Postpone this packet completion till final status is know.
        //  Current Class is saved to be used later in-case packet is requeued.
        //
        return;
    }

    IsReceived(TRUE);

    //
    //  Restore charged quota
    //
    CQueue* pQueue = Queue();
    if(pQueue != 0)
    {
        pQueue->RestoreQuota(ppb->GetPacketSize());
    }
    else
    {
        CacheCurrentState(ppb);
    }

    //
    //  Audit the packet
    //
    if(MQCLASS_NACK(usClass))
    {
        SendAcknowledgment(usClass);
        Kill(usClass);
    }
    else if(pQueue != 0)
    {
        SendArrivalAcknowledgment();
        SendReceiveAcknowledgment();
        Journalize();
    }

    SetDone();
    Release();
}


void CPacket::PacketRundown(NTSTATUS rc)
{
    SetRundown();
    SetRevoked();
    CancelTimeout();
    CompleteWriter(rc);

    if(!IsDone() && !IsReceived()) 
    {
        //
        // We want to release a packet here if it was not released by Done 
        // and 
        // the packet is not currently in process ( e.g. Transaction, Remote Reader,
        // held by the QM for send) 
        // or if QueueRundown happened
        //
    
        Release();
    
    }
}


void CPacket::QueueRundown()
{
    //
    //  The packet has already removed from the list
    //
    Queue(0);

    AddRef();
    //
    // We want to release this packet in PacketRundown if it is not Done
    // therefore we turn off IsReceived flag 
    //
    IsReceived(FALSE);
    PacketRundown(MQ_ERROR_STALE_HANDLE);
    DetachBuffer();
    Release();
}


int CPacket::Priority() const
{
    //
    // The caller should either cache the priority on the QEntry object (CacheCurrentState)
    // or map the packet buffer into memory. We cannot fail here.
    //

    if (CachedFlagsSet())
    {
        //
        // LookupID is 64 bit value (8 bytes) where high order byte is inverted priority,
        // and rest of bytes are the low order 56 bits of SequentialId.
        //
        //   Byte0     Byte1     Byte2     Byte3     Byte4     Byte5     Byte6     Byte7
        // +-------------------------------------------------------------------------------+
        // | Inv.Pri |                    low 56 bits of SequentialId                      |
        // +-------------------------------------------------------------------------------+
        //
        return (MQ_MAX_PRIORITY - static_cast<int>(LookupId() >> 56));
    }

    CBaseHeader* pBase = Buffer();
    ASSERT(pBase != NULL);

    return pBase->GetPriority();
}


void CPacket::HandleRevoked(CPacketBuffer * ppb)
{
    ASSERT(IsRevoked());

    //
    //  This packet has been inserted to the queue as revoked.
    //  Revoked packet final class was saved, since the packet could not
    //  complete immidiatly.
    //

    if(IsRundown())
    {
        //
        //  This packet has rundown.
        //  This is a failed storage message returned to the queue.
        //  Storage failed while QM holding this packet.
        //
        //  NOTE: *NO* auditing is be generated
        //
        PacketRundown(MQ_ERROR_MESSAGE_STORAGE_FAILED);
    }
    else
    {
        //
        //  This is a revoked message returned to the queue.
        //  The writer has already completed successfully.
        //
        ASSERT(!WriterPending());

        //
        //  Negative ack is generated, if nessesary
        //
	    ASSERT(ppb != NULL && MappedBuffer() == ppb);
        Done(FinalClass(), ppb);
    }
}


void CPacket::CompleteWriter(NTSTATUS rc)
{
    TrTRACE(AC, " *CPacket::CompleteWriter, pPacket=%p, rc=%d*", this, rc);

    if(!WriterPending())
    {
        return;
    }

    //
    // Remove the writer irp from the writers list. It will not be found if Cancel has occured previously.
    //
    WriterPending(FALSE);
    PIRP irp = g_pStorage->GetWriteRequest(this);
    if(irp == 0)
    {
        TrTRACE(AC, " *CPacket::CompleteWriter, GetWriteRequest returned 0");
        return;
    }

    //
    // Detach this packet from irp and auto de-ref the attach packet.
    // This packet is no longer pending for storage.
    //
    ASSERT(!irp_driver_context(irp)->MultiPackets() || !CIrp2Pkt::IsHeld(irp));
    R<CPacket> pPacket = CIrp2Pkt::SafeDetachPacket(irp, this);

	CDriverContext::IrpContextType ContextType = irp_driver_context(irp)->ContextType();
    //
    // If more packets pending, re-insert the writer irp to the list
    //
    if (CIrp2Pkt::SafePeekFirstPacket(irp) != NULL)
    {
        ASSERT(CIrp2Pkt::NumOfAttachedPackets(irp) != 0);
        ASSERT(ContextType != CDriverContext::ctReceive);
        HoldWriteRequest(irp);
        return;
    }

    //
    // Complete the irp
    //
    ASSERT(!irp_driver_context(irp)->MultiPackets() || CIrp2Pkt::NumOfAttachedPackets(irp) == 0);

	//
	// if the irp is pending because it is receive operation and we wait on the delete storage
	// request, we will complete the request with success because NT will flush the message
	// files when the QM process is shuting down. if the flush will fail we will have duplicate message
	//
    BOOL fFreePacket = irp_driver_context(irp)->IrpWillFreePacket();
    if ((MQ_ERROR_STALE_HANDLE == rc) && (TRUE == fFreePacket) && (ContextType == CDriverContext::ctReceive))
    {
	    irp_safe_set_final_status(irp, STATUS_SUCCESS);
    }
	else
	{
	    irp_safe_set_final_status(irp, rc);
	}
	
    irp->IoStatus.Information = 0;
    IoCompleteRequest(irp, IO_MQAC_INCREMENT);
}

NTSTATUS CPacket::StoreInPlace(PIRP irp)
{
    ASSERT(!StorageIssued());

    //
    // Attach packet to irp and AddRef the packet
    //
    irp_driver_context(irp)->MultiPackets(false);
    CIrp2Pkt::AttachSinglePacket(irp, this);
    AddRef();

    //
    // Issue request for storage. On failure, detach packet from irp and de-ref the attach packet,
    // fail the operation and release the packet.
    //
	NTSTATUS rc;
    rc = IssueStorage();
    if(!NT_SUCCESS(rc))
    {
        CIrp2Pkt::DetachSinglePacket(irp);
        Release();
        PacketRundown(rc);
        return rc;
    }

    //
    //  Hold the writer in the queues writers list
    //
    HoldWriteRequest(irp);
    return STATUS_PENDING;
}


NTSTATUS CPacket::Store(PIRP irp)
/*++

Routine Description:

    Note: it is the responsibility of the caller to call PacketRundown
    if this routine returns failure status.

Arguments:

    irp - The interrupt request packet. May be NULL.

Return Value:

    STATUS_PENDING - Storage request was issued successfully to QM.
    failure status - Failed to issue storage request. Caller should call PacketRundown.

--*/
{
    ASSERT(!StorageIssued());

	//
	// Mark allocator as non coherent
	//
	NTSTATUS rc;
	rc = Allocator()->MarkNotCoherent();
	if(!NT_SUCCESS(rc))
	{
		return rc;
	}

    //
    // Attach packet to irp and AddRef the packet.
    //
    if (irp != NULL)
    {
        if (!CIrp2Pkt::SafeAttachPacket(irp, this))
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        AddRef();
    }

    //
    // Issue storage request. On failure, detach packet from irp and de-ref the packet attach
    //
    rc = IssueStorage();
    if(!NT_SUCCESS(rc))
    {
        if (irp != NULL)
        {
            CIrp2Pkt::SafeDetachPacket(irp, this)->Release();
        }
        return rc;
    }

    //
    // Hold the write irp in the list
    //
    HoldWriteRequest(irp);

    return STATUS_PENDING;
}


void CPacket::UpdateBitmap(ULONG size)
{
    ASSERT(StorageIssued());

    if(!BufferAttached())
    {
        //
        //  QueueRundown occured while storing
        //
        return;
    }

	if(DeleteStorageIssued())
	{
		//
		// If a delete storage was issued, then we do not need to turn on
		// the bits in the bitmap, we need to turn them off.
		//
		ac_bitmap_update(Allocator(), AllocatorBlockOffset(), size, FALSE);
	}
	else
	{
		ac_bitmap_update(Allocator(), AllocatorBlockOffset(), size, TRUE);
	}
}


void CPacket::HandleCreatePacketCompleted(NTSTATUS rc, USHORT ack)
{
    TrTRACE(AC, " *CPacket::HandleCreatePacketCompleted, pPacket=%p, rc=%d, ack=%d*", this, rc, ack);
    ASSERT(rc != STATUS_PENDING);

    //
    // Revoke the packet: this is a success in the sender's view.
    //
    if (ack != 0)
    {
        ASSERT(("Sender view this as success", NT_SUCCESS(rc)));
        FinalClass(ack);
        SetRevoked();
    }

    //
    // Remove the send irp from list. It will not be found if cancel has previously occured.
    //
    PIRP irp = g_pCreatePacket->GetCreatePacketRequest(this);
    if (irp == NULL)
    {
        return;
    }

    //
    // Failure. Notify failure handler on queue/distribution and complete the irp.
    //
    CPacket * pPacket = CIrp2Pkt::SafePeekFirstPacket(irp);
    ASSERT(pPacket->Queue() != NULL);
    if (!NT_SUCCESS(rc))
    {
        pPacket->Queue()->HandleCreatePacketCompletedFailureAsync(irp);
        irp_safe_set_final_status(irp, rc);
        irp->IoStatus.Information = 0;
        IoCompleteRequest(irp, IO_MQAC_INCREMENT);
        return;
    }

    //
    // More packets pending: re-insert irp to list and return
    //
    if (irp_driver_context(irp)->MultiPackets() && CIrp2Pkt::NumOfPacketsPendingCreate(irp) != 0)
    {
        g_pCreatePacket->HoldCreatePacketRequest(irp);
        return;
    }

    //
    // Call async completion handler on queue/distribution. Complete irp if needed.
    //
    rc = pPacket->Queue()->HandleCreatePacketCompletedSuccessAsync(irp);
    if (rc == STATUS_PENDING)
    {
        return;
    }

    irp_safe_set_final_status(irp, rc);
    irp->IoStatus.Information = 0;
    IoCompleteRequest(irp, IO_MQAC_INCREMENT);

} // CPacket::HandleCreatePacketCompleted


void CPacket::HandleStorageCompleted(NTSTATUS rc)
{
    TrTRACE(AC, " *CPacket::HandleStorageCompleted, pPacket=%p, rc=%d*", this, rc);

    ASSERT(StorageIssued());

    CTransaction* pXact = Transaction();

    if(!NT_SUCCESS(rc))
    {
        if(pXact == 0)
        {
			PacketRundown(rc);
        }
        else
        {
            ASSERT(BufferAttached());
            if(StorageCompleted())
            {
                //
                // This was DeleteStorage, we want to be able to retry it 
                // (e.g. Abort1() can be called several times)
                //
                ASSERT(DeleteStorageIssued());
                DeleteStorageIssued(FALSE);
            }
            pXact->PacketStoreCompleted(rc);
        }

        return;
    }

	if(pXact != 0)
	{
        ASSERT(BufferAttached());
		StorageCompleted(TRUE);
		pXact->PacketStoreCompleted(rc);
		return;
	}
	
	if(!StorageCompleted())
	{
        //
		//  That was a successful Storage, not DeleteStorage.
		//  Complete writer and send arrival ack if needed (check Queue to
        //  support Convert).
        //
        //  The following assert was removed when fixing #6330.
        //  scenario: send persistent message to remote computer, with
        //  deadletter flag and 0 time-to-reach-queue. The packet expire
        //  on sender machine and enter local deadletter queue before its
        //  storage is completed. So when storage complete, the CPacket
        //  object is ok, but pointer to buffer is NULL, as buffer moved
        //  to cloned CPacket object that is put in deadletter queue.
        //
        //  ASSERT((BufferAttached()) || (ArrivalAckIssued()));
        //
		StorageCompleted(TRUE);
        if (Queue() != NULL)
        {
            SendArrivalAcknowledgment();
        }
	}

	CompleteWriter(rc);
}


inline NTSTATUS CPacket::IssueTimeoutRequest()
{
    CACRequest request(CACRequest::rfTimeout);
    request.Timeout.pPacket = NULL;
    request.Timeout.pDriverPacket = this;
    request.Timeout.fTimeToBeReceived = TimeoutTarget();

    AddRef();
    NTSTATUS rc;
    rc = g_pQM->ProcessRequest(request);
    if(!NT_SUCCESS(rc))
    {
        Release();
        return rc;
    }

    return rc;

} // CPacket::IssueTimeoutRequest


void CPacket::HandleTimeout()
{
    if(!TimeoutIssued())
    {
        //
        //  The timeout for this packet has been canceled while this timeout already
        //  dispatched, thus we need to release this packet (it was not release by
        //  the cancel)
        //
        Release();
        return;
    }

    TimeoutIssued(FALSE);


    CQueue* pQueue = Queue();
	ASSERT(pQueue != 0);
    BOOL fTarget = pQueue->IsTargetQueue();

    if(!fTarget && IsOrdered() && InSourceMachine())
    {
        //
        //  we don't handle timeout for localy sent ordered packet in a non local queue
        //  the QM expire these messages.
        //
        IssueTimeoutRequest();
    }
    else
    {

        USHORT usClass = fTarget ?
                MQMSG_CLASS_NACK_RECEIVE_TIMEOUT :
                MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT;

        CPacketBuffer * ppb = Buffer();
        if (ppb == NULL)
        {
            //
            // ISSUE-2001/01/01-shaik Reschedule packet timeout on low resource
            // when we switch to intrusive scheduler tree
            //
            return;
        }
        Done(usClass, ppb);
    }
    Release();
}


#pragma warning(default: 4238)  //  nonstandard extension used : class rvalue used as lvalue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\qgroup.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qgroup.h

Abstract:

    CQueue definitiona. It is the Falcon Queue represination in the
    Access Control layer.

Author:

    Erez Haba (erezh) 13-Aug-95

Revision History:
--*/

#ifndef __QGROUP_H
#define __QGROUP_H

#include "qbase.h"

//---------------------------------------------------------
//
//  class CGroup
//
//---------------------------------------------------------

class CGroup : public CQueueBase {

    typedef CQueueBase Inherited;

public:
    //
    // CGroup constructor, store the PeekByPriority flag
    //
    CGroup(BOOL fPeekByPriority);

    //
    //  Remove a queue member
    //
    void RemoveMember(CQueueBase*);

    //
    //  Add a queue memeber
    //
    void AddMember(CQueueBase*);

    //
    //  Close that queue
    //
    virtual void Close(PFILE_OBJECT pOwner, BOOL fCloseAll);

protected:

    virtual ~CGroup() {}

private:
    //
    //  Get the first packet from the group if available
    //
    virtual CPacket* PeekPacket();

    //
    // Get a packet by its lookup ID
    //
    virtual NTSTATUS PeekPacketByLookupId(ULONG Action, ULONGLONG LookupId, CPacket** ppPacket);

    //
    // Get the PeekByPriority flag
    //
    BOOL PeekByPriority(VOID) const;

private:
    //
    //  The Queues list
    //
    List<CQueueBase> m_members;

public:
    static NTSTATUS Validate(const CGroup* pGroup);

private:
    //
    //  Class type debugging section
    //
    CLASS_DEBUG_TYPE();
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

inline CGroup::CGroup(BOOL fPeekByPriority)
{
    Flag1(fPeekByPriority);
}

inline BOOL CGroup::PeekByPriority(VOID) const
{
    return Flag1();
}

inline void CGroup::RemoveMember(CQueueBase* pQueue)
{
    m_members.remove(pQueue);
    pQueue->m_owner = 0;
}

inline NTSTATUS CGroup::Validate(const CGroup* pGroup)
{
    ASSERT(pGroup && pGroup->isKindOf(Type()));
    return Inherited::Validate(pGroup);
}

#endif // __QGROUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\qgroup.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qgroup.cxx

Abstract:

    This module implements CGroup members

Author:

    Erez Haba (erezh) 27-Nov-96

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include <limits.h>
#include "qgroup.h"
#include "queue.h"

#ifndef MQDUMP
#include "qgroup.tmh"
#endif

//---------------------------------------------------------
//
//  class CGroup
//
//---------------------------------------------------------

DEFINE_G_TYPE(CGroup);

void CGroup::AddMember(CQueueBase* pQueue)
{
    pQueue->m_owner = this;
    m_members.insert(pQueue);

    //
    //  Packets in pQueue are released to pending requests in this group
    //  It is assumed that only GetPacket requests are pending in the group,
    //  thus cursor is not checked
    //
    CPacket* pPacket;
    while((pPacket = pQueue->PeekPacket()) != 0)
    {
        //
        //  All requests of a group are receiveing requests
        //
        PIRP irp = GetRequest(pPacket);
        if(irp == 0)
        {
            //
            //  No pending request in this group
            //
            return;
        }

        pPacket->CompleteRequest(irp);
    }
}


NTSTATUS CGroup::PeekPacketByLookupId(ULONG, ULONGLONG, CPacket**)
{
    ASSERT(("Should not get here.", 0));
    return STATUS_NOT_IMPLEMENTED;
}

CPacket* CGroup::PeekPacket(void)
{
    //
    //  TODO:   performence, check if the queues should not be a linked list
    //          but rather a more facinating data structure for better performance
    //

    LONG lMaxPrio = LONG_MIN;
    CQueueBase *pChosenQueue = 0;
    CPacket *pChosenPacket = 0;

    for(List<CQueueBase>::Iterator p(m_members); p; ++p)
    {
        CQueueBase* pQueue = p;
        CPacket *pPacket = pQueue->PeekPacket();
        
        if(pPacket != 0)
        {
            LONG lPrio = pPacket->Priority() + pPacket->Queue()->BasePriority();

            if(lPrio > lMaxPrio)
            {
                lMaxPrio = lPrio;
                pChosenQueue = pQueue;
                pChosenPacket = pPacket;
            }

            ASSERT(pChosenQueue != NULL);
            ASSERT(pChosenPacket != NULL);

            if (!PeekByPriority())
            {
                break;
            }
        }
    }

    if (pChosenQueue)
    {
        // Move the queue to the end of the list, this way we do round robin.
        m_members.remove(pChosenQueue);
        m_members.insert(pChosenQueue);

        ASSERT(pChosenPacket);
        return pChosenPacket;
    }

    return(NULL);
}

void CGroup::Close(PFILE_OBJECT pOwner, BOOL fCloseAll)
{
    ASSERT(fCloseAll == TRUE);

    Inherited::Close(pOwner, fCloseAll);

    //
    //  disconnect all sibling queues
    //
    CQueueBase* pQueue;
    while((pQueue = m_members.peekhead()) != 0)
    {
        RemoveMember(pQueue);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\pktbuf.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    pktbuf.h

Abstract:

    CPacketBuffer definition

Author:

    Erez Haba (erezh) 17-Feb-96
    Shai Kariv (shaik) 11-Apr-2000

Revision History:

--*/

#ifndef __PKTBUF_H
#define __PKTBUF_H

#include "heap.h"
#include <ph.h>
#include <phinfo.h>

//---------------------------------------------------------
//
// class CPacketBuffer
//
//---------------------------------------------------------

class CPacketBuffer :
    public CAccessibleBlock,
    public CPacketInfo,
    public CBaseHeader
{
public:
    CPacketBuffer(ULONG PacketSize, ULONGLONG SequentialID);

    static CUserHeader *            UserHeader(CBaseHeader* pBase);
    static CXactHeader *            XactHeader(CBaseHeader* pBase);
    static CSecurityHeader *        SecurityHeader(CBaseHeader* pBase);
    static CPropertyHeader *        PropertyHeader(CBaseHeader* pBase);
    static CBaseMqfHeader *         DestinationMqfHeader(CBaseHeader* pBase);
    static CBaseMqfHeader *         AdminMqfHeader(CBaseHeader* pBase);
    static CBaseMqfHeader *         ResponseMqfHeader(CBaseHeader* pBase);
    static CSrmpEnvelopeHeader *    SrmpEnvelopeHeader(CBaseHeader* pBase);
    static CCompoundMessageHeader * CompoundMessageHeader(CBaseHeader* pBase);
};

inline CPacketBuffer::CPacketBuffer(ULONG PacketSize, ULONGLONG SequentialID) :
    CPacketInfo(SequentialID),
    CBaseHeader(PacketSize)
{
}


inline CUserHeader* CPacketBuffer::UserHeader(CBaseHeader* pBase)
{
    return reinterpret_cast<CUserHeader*>(pBase->GetNextSection());
}


inline CXactHeader* CPacketBuffer::XactHeader(CBaseHeader* pBase)
{
    CUserHeader* pUser = UserHeader(pBase);

    if(!pUser->IsOrdered())
    {
        return 0;
    }

    PVOID pSection = pUser->GetNextSection();
    return static_cast<CXactHeader*>(pSection);
}


inline CSecurityHeader* CPacketBuffer::SecurityHeader(CBaseHeader* pBase)
{
    CUserHeader* pUser = UserHeader(pBase);

    if(!pUser->SecurityIsIncluded())
    {
        return 0;
    }

    PVOID pSection = pUser->GetNextSection();
    if(pUser->IsOrdered())
    {
        pSection = static_cast<CXactHeader*>(pSection)->GetNextSection();
    }

    return static_cast<CSecurityHeader*>(pSection);
}


inline CPropertyHeader* CPacketBuffer::PropertyHeader(CBaseHeader* pBase)
{
    CUserHeader* pUser = UserHeader(pBase);

    PVOID pSection = pUser->GetNextSection();
    if(pUser->IsOrdered())
    {
        pSection = static_cast<CXactHeader*>(pSection)->GetNextSection();
    }

    if(pUser->SecurityIsIncluded())
    {
        pSection = static_cast<CSecurityHeader*>(pSection)->GetNextSection();
    }

    return static_cast<CPropertyHeader*>(pSection);
}


#endif // __PKTBUF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\qentry.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qentry.h

Abstract:

    CQEntry definition

Author:

    Erez Haba (erezh) 24-Dec-95

Revision History:

    Shai Kariv  (shaik)  11-Apr-2000     Modify for MMF dynamic mapping.

--*/

#ifndef __QENTRY_H
#define __QENTRY_H

#include "object.h"
#include "pktbuf.h"
#include "irplist.h"
#include "treenode.h"

class CQueue;
class CPacket;
class CTransaction;


//---------------------------------------------------------
//
// class CQEntry
//
//---------------------------------------------------------

class CQEntry : public CBaseObject {
public:
    CQEntry(CMMFAllocator* pAllocator, CAllocatorBlockOffset abo);
    ~CQEntry();

    CMMFAllocator* Allocator() const;
    CPacketBuffer* Buffer() const;
    CPacketBuffer* MappedBuffer() const;
    CPacketBuffer* QmAccessibleBuffer() const;
    CPacketBuffer* QmAccessibleBufferNoMapping() const;
    CAllocatorBlockOffset AllocatorBlockOffset() const;

    void DetachBuffer();
    bool BufferAttached() const;

    CQueue* Queue() const;
    void Queue(CQueue* pQueue);

    USHORT FinalClass() const;
    void FinalClass(USHORT);

    BOOL IsReceived() const;
    void IsReceived(BOOL);

    BOOL IsRevoked() const;
    void SetRevoked();

    BOOL IsRundown() const;
    void SetRundown();

    BOOL WriterPending() const;
    void WriterPending(BOOL);

    BOOL TimeoutIssued() const;
    void TimeoutIssued(BOOL);

    BOOL TimeoutTarget() const;
    void TimeoutTarget(BOOL);

    ULONG Timeout() const;
    void  Timeout(ULONG);

    BOOL ArrivalAckIssued() const;
    void ArrivalAckIssued(BOOL);

    BOOL StorageIssued() const;
    void StorageIssued(BOOL);

	BOOL StorageCompleted() const;
	void StorageCompleted(BOOL);

	BOOL DeleteStorageIssued() const;
    void DeleteStorageIssued(BOOL);

    CTransaction* Transaction() const;
    void Transaction(CTransaction* pXact);

    CQueue* TargetQueue() const;
    void TargetQueue(CQueue* pQueue);

    CPacket* OtherPacket() const;
    void OtherPacket(CPacket* pPacket);
    void AssertNoOtherPacket() const;

    BOOL IsXactSend() const;

    BOOL CachedFlagsSet() const;
    void CachedFlagsSet(BOOL);

    BOOL IsOrdered() const;
    void IsOrdered(BOOL);

    BOOL InSourceMachine() const;
    void InSourceMachine(BOOL);

    BOOL SourceJournal() const;
    void SourceJournal(BOOL);

    BOOL IsDone() const;
    void SetDone();

    ULONGLONG LookupId() const;
    void LookupId(ULONGLONG LookupId);

    void AddRefBuffer(void) const;
    void ReleaseBuffer(void) const;

private:

    //
    // Memory layout of this object - 32 bit system:
    //
    // VTable Pointer         (32 bit)
    // CBaseObject::m_ref     (32 bit)
    // m_abo                  (32 bit)
    // m_pAllocator           (32 bit)
    // m_pQueue               (32 bit)
    // m_pXact                (32 bit)
    // m_ulTimeout            (32 bit)
    // m_ulFlags              (32 bit)
    // m_LookupId             (64 bit)
    // m_pTargetQueue/m_pOtherPacket (32 bit)
    // m_treenode::m_pParent  (32 bit)  //also  m_link::Flink (32 bit)
    // m_treenode::m_pRight   (32 bit)  //also  m_link::Blink (32 bit)
    // m_treenode::m_pLeft    (32 bit)
    // m_treenode::m_height   (32 bit)
    //
    //
    // Memory layout of this object - 64 bit system:
    //
    // VTable Pointer         (64 bit)
    // CBaseObject::m_ref     (32 bit)
    // m_abo                  (32 bit)
    // m_pAllocator           (64 bit)
    // m_pQueue               (64 bit)
    // m_pXact                (64 bit)
    // m_ulTimeout            (32 bit)
    // m_ulFlags              (32 bit)
    // m_LookupId             (64 bit)
    // m_pTargetQueue/m_pOtherPacket (64 bit)
    // m_treenode::m_pParent  (64 bit)    //also  m_link::Flink (64 bit)
    // m_treenode::m_pRight   (64 bit)    //also  m_link::Blink (64 bit)
    // m_treenode::m_pLeft    (64 bit)
    // m_treenode::m_height   (32 bit)

    CAllocatorBlockOffset m_abo;
    R<CMMFAllocator> m_pAllocator;
    CQueue* m_pQueue;
    CTransaction* m_pXact;

    //
    //  StartTimer keeps the timeout here, so that Cancel will know what to look for
    //
    ULONG m_ulTimeout;
    union {
        ULONG m_ulFlags;
        struct {
            ULONG m_bfFinalClass        : 16;   // the packet final revoked class
            ULONG m_bfRundown           : 1;    // The packet was run down
            ULONG m_bfRevoked           : 1;    // the packet has been done storage
            ULONG m_bfReceived          : 1;    // the packet has been received
            ULONG m_bfWriterPending     : 1;    // writer is waiting for this packet storage
            ULONG m_bfTimeoutIssued     : 1;    // a timeout has been issued
            ULONG m_bfTimeoutTarget     : 1;    // a timeout evaluated at target
            ULONG m_bfArrivalAckIssued  : 1;    // Arrive Ack has been issued
            ULONG m_bfStorageIssued     : 1;    // Storage request has been issued
			ULONG m_bfStorageCompleted	: 1;	// Storage for this packet has been completed
			ULONG m_bfDeleteStorageIssued: 1;	// Delete Storage request has been issued
            ULONG m_bfOtherPacket       : 1;    // m_pOtherPacket is in used in union

            //
            //  Cached information, to allow faster access to info
            //  in packet buffer
            //
            ULONG m_bfCachedFlagsSet    : 1;    // The next flags where cached
            ULONG m_bfInSoruceMachine   : 1;    // was originaly send from this machine
            ULONG m_bfOrdered           : 1;    // ordered packet
            ULONG m_bfSourceJournal     : 1;    // need to be journalized in this machine journal
            ULONG m_bfDone              : 1;    // packet handling is done
        };
    };

    ULONGLONG m_LookupId;

    union {
        //
        //  Used in a Send packet in a CTransaction queue.
        //  Pointer to the target queue object to send at commit
        //
        CQueue* m_pTargetQueue;

        //
        //  Used in a Receive packet in a CTransaction and in CQueue.
        //  Pointer to the other CPacket entry; For entries that are in a
        //  CTrnsaction, the other entry is the real received packet in the
        //  queue. For entreis that are in a CQueue, the other entry is the
        //  dummy enty resides at the transaction.
        //
        CPacket* m_pOtherPacket;
    };

public:
    union
    {
        LIST_ENTRY m_link;    
        CTreeNode m_treenode;
    };
    
};

//---------------------------------------------------------
//
// IMPLEMENTATION
//
//---------------------------------------------------------

inline CQEntry::CQEntry(CMMFAllocator* pAllocator, CAllocatorBlockOffset abo) :
    m_pAllocator(pAllocator),
    m_abo(abo),
    m_pQueue(0),
    m_pXact(0),
    m_pTargetQueue(0),
    m_ulFlags(0),
    m_LookupId(0)
{
    m_pAllocator->AddRef();
    m_treenode.init();
}

inline CMMFAllocator* CQEntry::Allocator() const
{
    return m_pAllocator;
}


inline CPacketBuffer* CQEntry::MappedBuffer() const
/*++

Routine Description:

    Return an accessible address of the current mapped buffer in QM process address space or
    kernel address space. IT DOES NOT mapped the buffer if it is unmapped

Arguments:

    None.

Return Value:

    An accessible address of the buffer in QM or AC address space, or NULL if the
    buffer is not mapped.

--*/
{
    if(BufferAttached())
    {
        ASSERT(m_pAllocator != NULL);

        return static_cast<CPacketBuffer*>(m_pAllocator->GetMappedBuffer(m_abo));
    }

    return 0;
} // CQEntry::MappedBuffer


inline CPacketBuffer* CQEntry::Buffer() const
/*++

Routine Description:

    Return an accessible address of the buffer in QM process address space
    or in kernel address space.

Arguments:

    None.

Return Value:

    An accessible address in user space (QM) or kernel space (AC).
    0 - no accessible address.

--*/
{
    if(BufferAttached())
    {
        ASSERT(m_pAllocator != NULL);

        return static_cast<CPacketBuffer*>(
                m_pAllocator->GetAccessibleBuffer(m_abo));
    }

    return 0;

} // CQEntry::Buffer


inline CPacketBuffer* CQEntry::QmAccessibleBuffer() const
/*++

Routine Description:

    Return an accessible address of the buffer in QM proces address space.

Arguments:

    None.

Return Value:

    An accessible address is user space (QM) or NULL if no accessible address.

--*/
{
    ASSERT(m_pAllocator != NULL);

    return static_cast<CPacketBuffer*>(
            m_pAllocator->GetQmAccessibleBuffer(m_abo));

} // CQEntry::QmAccessibleBuffer


inline CPacketBuffer* CQEntry::QmAccessibleBufferNoMapping() const
/*++

Routine Description:

    Return an accessible address of the buffer in QM proces address space.
    This routine assumes the buffer is currently mapped to QM process.

Arguments:

    None.

Return Value:

    An accessible address is user space (QM).

--*/
{
    ASSERT(m_pAllocator != NULL);

    return static_cast<CPacketBuffer*>(
            m_pAllocator->GetQmAccessibleBufferNoMapping(m_abo));

} // CQEntry::QmAccessibleBufferNoMapping


inline CAllocatorBlockOffset CQEntry::AllocatorBlockOffset() const
/*++

Routine Description:

    Return allocator block offset that represents the buffer in
    allocator coordinates. 

Arguments:

    None.

Return Value:

    Block offset (Note that 0 is a legal offset) or xInvalidAllocatorBlockOffset.

--*/
{
    return m_abo;
}

inline void CQEntry::DetachBuffer()
{
    m_abo.Invalidate();
}

inline bool CQEntry::BufferAttached() const
{
    return m_abo.IsValidOffset();
}

inline CQueue* CQEntry::Queue() const
{
    return m_pQueue;
}

inline void CQEntry::Queue(CQueue* pQueue)
{
    m_pQueue = pQueue;
}

inline USHORT CQEntry::FinalClass() const
{
    return (USHORT)m_bfFinalClass;
}

inline void CQEntry::FinalClass(USHORT usClass)
{
    m_bfFinalClass = usClass;
}

inline BOOL CQEntry::IsReceived() const
{
    return m_bfReceived;
}

inline void CQEntry::IsReceived(BOOL f)
{
    m_bfReceived = f;
}

inline BOOL CQEntry::IsRevoked() const
{
    return m_bfRevoked;
}

inline void CQEntry::SetRevoked()
{
    m_bfRevoked = TRUE;
}

inline BOOL CQEntry::IsRundown() const
{
    return m_bfRundown;
}

inline void CQEntry::SetRundown()
{
    m_bfRundown = TRUE;
}

inline BOOL CQEntry::WriterPending() const
{
    return m_bfWriterPending;
}

inline void CQEntry::WriterPending(BOOL f)
{
    m_bfWriterPending = f;
}

inline BOOL CQEntry::TimeoutIssued() const
{
    return m_bfTimeoutIssued;
}

inline void CQEntry::TimeoutIssued(BOOL f)
{
    m_bfTimeoutIssued = f;
}

inline BOOL CQEntry::TimeoutTarget() const
{
    return m_bfTimeoutTarget;
}

inline void CQEntry::TimeoutTarget(BOOL f)
{
    m_bfTimeoutTarget = f;
}

inline ULONG CQEntry::Timeout() const
{
    return m_ulTimeout;
}

inline void CQEntry::Timeout(ULONG ul)
{
    m_ulTimeout = ul;
}

inline BOOL CQEntry::ArrivalAckIssued() const
{
    return m_bfArrivalAckIssued;
}

inline void CQEntry::ArrivalAckIssued(BOOL f)
{
    m_bfArrivalAckIssued = f;
}

inline BOOL CQEntry::StorageIssued() const
{
    return m_bfStorageIssued;
}

inline void CQEntry::StorageIssued(BOOL f)
{
    m_bfStorageIssued = f;
}

inline BOOL CQEntry::StorageCompleted() const
{
    return m_bfStorageCompleted;
}

inline void CQEntry::StorageCompleted(BOOL f)
{
    m_bfStorageCompleted = f;
}

inline BOOL CQEntry::DeleteStorageIssued() const
{
    return m_bfDeleteStorageIssued;
}

inline void CQEntry::DeleteStorageIssued(BOOL f)
{
    m_bfDeleteStorageIssued = f;
}

inline CTransaction* CQEntry::Transaction() const
{
    return m_pXact;
}

inline void CQEntry::Transaction(CTransaction* pXact)
{
    m_pXact = pXact;
}

inline CQueue* CQEntry::TargetQueue() const
{
    ASSERT(m_bfOtherPacket == FALSE);
    return m_pTargetQueue;
}

inline CPacket* CQEntry::OtherPacket() const
{
    ASSERT(m_bfOtherPacket == TRUE);
    return m_pOtherPacket;
}

inline void CQEntry::AssertNoOtherPacket() const
{
    ASSERT(m_pOtherPacket == NULL);
}

inline BOOL CQEntry::IsXactSend() const
{
    return (m_bfOtherPacket == FALSE);
}

inline BOOL CQEntry::CachedFlagsSet() const
{
    return m_bfCachedFlagsSet;
}

inline void CQEntry::CachedFlagsSet(BOOL f)
{
    m_bfCachedFlagsSet = f;
}

inline BOOL CQEntry::IsOrdered() const
{
    ASSERT(CachedFlagsSet());
    return m_bfOrdered;
}

inline void CQEntry::IsOrdered(BOOL f)
{
    m_bfOrdered = f;
}

inline BOOL CQEntry::InSourceMachine() const
{
    ASSERT(CachedFlagsSet());
    return m_bfInSoruceMachine;
}

inline void CQEntry::InSourceMachine(BOOL f)
{
    m_bfInSoruceMachine = f;
}

inline BOOL CQEntry::SourceJournal() const
{
    ASSERT(CachedFlagsSet());
    return m_bfSourceJournal;
}

inline void CQEntry::SourceJournal(BOOL f)
{
    m_bfSourceJournal = f;
}

inline BOOL CQEntry::IsDone() const
{
    return m_bfDone;
}

inline void CQEntry::SetDone()
{
    m_bfDone = TRUE;
}

inline ULONGLONG CQEntry::LookupId() const
{
    ASSERT(CachedFlagsSet());
    return m_LookupId;
}

inline void CQEntry::LookupId(ULONGLONG LookupId)
{
    m_LookupId = LookupId;
}

inline void CQEntry::AddRefBuffer(void) const
/*++

Routine Description:

    Increment reference count of the buffer.
    Called when QM gets a reference to the buffer from AC.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(m_pAllocator != NULL);
    m_pAllocator->AddRefBuffer();

} // CQEntry::AddRefBuffer


inline void CQEntry::ReleaseBuffer(void) const
/*++

Routine Description:

    Decrement reference count of the buffer.
    Called when QM releases a reference to the buffer, 
    which was previously given to it by AC.
    That means that the QM will not reference the packet buffer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(m_pAllocator != NULL);
    m_pAllocator->ReleaseBuffer();

} // CQEntry::ReleaseBuffer


#endif // __QENTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\qbase.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qbase.h

Abstract:

    CQueueBase definition. It is the Falcon Queue Base represination in the
    Access Control layer.

Author:

    Erez Haba (erezh) 13-Aug-95

Revision History:
--*/

#ifndef __QBASE_H
#define __QBASE_H

#include "object.h"
#include "irplist.h"
#include "packet.h"
#include "cursor.h"

//---------------------------------------------------------
//
//  class CQueueBase
//
//---------------------------------------------------------

class CQueueBase : public CObject {

    typedef CObject Inherited;
    friend class CGroup;

public:
    //
    //  Default constructor
    //
    CQueueBase();

    //
    //  Move this queue to a specific group. (a 0 group is allowed)
    //
    void MoveToGroup(CGroup* pGroup);

    //
    //  Process read request
    //
    virtual
    NTSTATUS
    ProcessRequest(
        PIRP,
        ULONG Timeout,
        CCursor *,
        ULONG Action,
        bool  fReceiveByLookupId,
        ULONGLONG LookupId,
        OUT ULONG *pulTag
        );

    //
    //  Close that queue
    //
    virtual void Close(PFILE_OBJECT pOwner, BOOL fCloseAll);

    //
    //  Can close that queue?
    //
    virtual NTSTATUS CanClose() const;

    //
    //  Cancel a request with final status rc.
    //
    void CancelPendingRequests(NTSTATUS rc, PFILE_OBJECT pOwner, BOOL fAll);

    //
    //  Cancel a request marked by tag.
    //
    NTSTATUS CancelTaggedRequest(NTSTATUS status, ULONG ulTag);

    //
    //  This queue has been permanetly closed
    //
    virtual BOOL Closed() const;

    //
    //  This queue opened offline or the queue is remote private or direct queue,
    //  we don't  know if it is transacted or non transacted queue. Therefor
    //  we allow such a queue to participate in a trnasaction.
    //  Queue that is marked with unknown type can't be a local queue. When
    //  the  DS becomes online, the QM update the queue property.
    //
    BOOL UnknownQueueType() const;

    //
    // Create a cursor on this queue
    //
    virtual NTSTATUS CreateCursor(PIRP irp, PFILE_OBJECT pFileObject, PDEVICE_OBJECT pDevice);

protected:
    //
    //  CQueueBase is an abstract class, and can not be instanciated.
    //  the object is destructed only through Release
    //
    virtual ~CQueueBase() = 0;

    //
    //  Get a request from the pending readers list, matching the packet.
    //  If no request is found on this queue, this member will look for a
    //  machineg request in owner group
    //
    //
    PIRP GetRequest(CPacket*);

    //
    //  Get a request from the pending readers list, matching a tag.
    //  The owner group will NOT be searched.
    //
    PIRP GetTaggedRequest(ULONG ulTag);

    //
    //  Put the request in the pending irp list.
    //
    //  N.B. The cancel routine should NOT set the irp status when completed.
    //      HoldRequest already sets the value to STATUS_CANCELLED, so when the
    //      irp is cancled by the IO sub system it will return the right value.
    //      This enable us to set the status value prior canceling the irp,
    //      e.g., STATUS_IO_TIMEOUT when request timeout expires.
    //
    //
    NTSTATUS HoldRequest(PIRP irp, ULONG ulTimeout, PDRIVER_CANCEL pCancel);

    //
    //  This flag is for general use.
    //
    void Flag1(BOOL f);

    //
    //  This flag is for general use.
    //
    BOOL Flag1() const;

    //
    //  This queue opened offline or the queue is remote private or direct queue,
    //  we don't  know if it is transacted or non transacted queue. Therefor
    //  we allow such a queue to participate in a trnasaction.
    //  Queue that is marked with unknown type can't be a local queue. When
    //  the  DS becomes online, the QM update teh queue property.
    //
    void UnknownQueueType(BOOL f);

private:
    //
    //  Get the first packet from the queue if available
    //
    virtual CPacket* PeekPacket();

    //
    // Get packet by its lookup ID
    //
    virtual NTSTATUS PeekPacketByLookupId(ULONG Action, ULONGLONG LookupId, CPacket** ppPacket);

    //
    // Process lookup request
    //
    NTSTATUS ProcessLookupRequest(PIRP irp, ULONG Action, ULONGLONG LookupId);

    //
    //  Helper functions
    //
    PIRP get_request(CPacket*);

private:
    //
    //  The group this queue belongs to
    //
    CGroup* m_owner;

    //
    //  All pending readers for this queue
    //
    CIRPList m_readers;

    //
    //  Base queue flags
    //
    union {
        ULONG m_ulFlags;
        struct {
            ULONG m_bfClosed        : 1;    // This queue has been closed
            ULONG m_bfFlag1         : 1;    // Flag for general use.
            ULONG m_bfUnknownQueueType : 1; // This queue type is unknown. Th
                                            // Queue was opened offline
        };
    };

public:
    static NTSTATUS Validate(const CQueueBase* pQueue);
#ifdef MQWIN95
    static NTSTATUS Validate95(const CQueueBase* pQueue);
#endif

private:
    //
    //  Class type debugging section
    //
    CLASS_DEBUG_TYPE();
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

inline CQueueBase::CQueueBase() :
    m_ulFlags(0),
    m_owner(0)
{
}

inline CQueueBase::~CQueueBase()
{
    //
    //  Detach from owner
    //
    MoveToGroup(0);
}

inline CPacket* CQueueBase::PeekPacket()
{
    return 0;
}

inline NTSTATUS CQueueBase::PeekPacketByLookupId(ULONG, ULONGLONG, CPacket**)
{
    return 0;
}

inline BOOL CQueueBase::Closed() const
{
    return m_bfClosed;
}


inline BOOL CQueueBase::Flag1() const
{
    return m_bfFlag1;
}

inline void CQueueBase::Flag1(BOOL f)
{
    m_bfFlag1 = f;
}

inline BOOL CQueueBase::UnknownQueueType() const
{
    return m_bfUnknownQueueType;
}

inline void CQueueBase::UnknownQueueType(BOOL f)
{
    m_bfUnknownQueueType = f;
}

inline NTSTATUS CQueueBase::Validate(const CQueueBase* pQueueBase)
{
    ASSERT(pQueueBase && pQueueBase->isKindOf(Type()));

    if(pQueueBase == 0)
    {
        return STATUS_INVALID_HANDLE;
    }

    if(pQueueBase->Closed())
    {
        //
        //  The queue has been previously closed by the QM
        //
        return MQ_ERROR_STALE_HANDLE;
    }

    return STATUS_SUCCESS;
}

inline NTSTATUS CQueueBase::CreateCursor(PIRP, PFILE_OBJECT, PDEVICE_OBJECT)
{
    return MQ_ERROR_ILLEGAL_OPERATION;
}

#ifdef MQWIN95

inline NTSTATUS CQueueBase::Validate95(const CQueueBase* pQueueBase)
{
    //
    // On Win95, our handle are not operating system handles, so no
    // one protect us against bad handles. Validate the handle inside
    // a try/except structure to catch bad ones.
    //

    NTSTATUS rc =  STATUS_INVALID_HANDLE;

    __try
    {
        rc = CQueueBase::Validate(pQueueBase) ;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc =  STATUS_INVALID_HANDLE;
    }

    return rc ;
}

#endif // MQWIN95

#endif // __QBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\qbase.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qbase.cxx

Abstract:

    This module contains define CQueueBase members

Author:

    Erez Haba (erezh) 27-Nov-96

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "qbase.h"
#include "qgroup.h"
#include "lock.h"
#include "sched.h"
#include "acp.h"
#include "qxact.h"

#ifndef MQDUMP
#include "qbase.tmh"
#endif

//---------------------------------------------------------
//
//  Safe sched cancel routine
//
//---------------------------------------------------------
static
VOID
SafeSchedCancel(
      IN  PIRP irp
      )
/*++

Routine Description:

  Remove an IRP scheduled timeout routine. If fail to do so, the timeout
  routine is already dispatched; wait until the timeout routine completes.

  Waiting for a signal from the timeout routine, guaranties that an IRP will
  not be freed or recycled before the timeout routine completes. Failing to do
  so will corrupt the IRP or its memory location by the timeout routine.

  This solves race conditions like,
  Accessing freed IRP,
  1. The receiver IRP is being canceled
  2. The timeout is already dispatched. i.e., it is already in the
     ACReceiveTimeout waiting on the spin lock
  3. In the cancel routine it could not remove the irp from the scheduler and
     goes and complete and deallocate the irp
  4. ACReceiveTimeout calls ACCancelIrp, thus accessing the already freed irp.
  5. blue sceen

  Accessing recycled IRP
  1. The same case as above, but the Io Subsystem reused the IRP for another
     call, thus corrupting that IRP.

  Invoking wrong cancel routine
  1. A timeout is already dispatched. i.e., it is already in the
     ACReceiveTimeout waiting on the spin lock
  2. GetRequest() cannot remove the irp from the scheduler but reassigns the
     irp a new cancel routine
  3. The "new" cancel routine is invoked by the timeout routine


--*/
{
    if(!g_pReceiveScheduler->SchedCancel(irp))
    {
        //
        //  Wait for the timeout routine to complete
        //
        while(!irp_driver_context(irp)->TimeoutCompleted())
        {
            //
            //  Wait for 1msec and recheck for timeout routine signal
            //
            //  Time is in 100 nsec, and is negative to be treated as
			//  relative time by KeDelayExecutionThread
            //
            LARGE_INTEGER Time;
            Time.QuadPart = -10 * 1000;
    		KeDelayExecutionThread(
			        KernelMode,
			        FALSE,
			        &Time
			        );
        }
    }
}

static void NTAPI ReleaseCursorRoutine(PDEVICE_OBJECT, PVOID pContext)
{
    ASSERT(pContext != NULL);

    CCursor* pCursor = static_cast<CCursor*>(pContext);
    pCursor->SetWorkItemDone();

    //
    //  Lock the driver mutext so access the resoruces is thread safe.
    //
    CS lock(g_pLock);

    pCursor->Release();
}

//---------------------------------------------------------
//
//  Reader cancel routine
//
//---------------------------------------------------------

static
VOID
NTAPI
ACCancelReader(
    IN PDEVICE_OBJECT,
    IN PIRP irp
    )
/*++

Routine Description:

    Cancel a LOCAL reader request, it can get canceled by NT when the thread
    terminates. Or internally when a request time-out occurs. In the latter
    case the irp TimeoutArmed flag is reset.

    N.B. We try to handle a race condition with request time-out code.

--*/
{
    bool fTimeoutArmed = irp_driver_context(irp)->TimeoutArmed();

    ACpRemoveEntryList(&irp->Tail.Overlay.ListEntry);
    irp_driver_context(irp)->RemoveXactReaderLink();
    IoReleaseCancelSpinLock(irp->CancelIrql);

    TrTRACE(AC, "ACCancelReader (irp=0x%p, rc=0x%x)", irp, irp->IoStatus.Status);

    if(fTimeoutArmed)
    {
        SafeSchedCancel(irp);
    }

    CCursor* pCursor = irp_driver_context(irp)->Cursor();
    //
    //  Releasing the cursor requires locking g_pLock. This can not be done
    //  here because of a possible dead lock with the scheduler ( when it is releasing
    //  more than one irp at a time)
    //
    if(pCursor != 0)
    {
        IoQueueWorkItem(pCursor->WorkItem(), ReleaseCursorRoutine, DelayedWorkQueue, pCursor);
    }

    //
    //  The status is not set here, it is set by the caller, when the irp is
    //  held in a list it status is set to STATUS_CANCELLED.
    //
    //ASSERT((irp->IoStatus.Status != STATUS_CANCELLED) || !irp_driver_context(irp)->TimeoutArmed());
    irp->IoStatus.Information = 0;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

//---------------------------------------------------------
//
//  class CQueueBase
//
//---------------------------------------------------------

DEFINE_G_TYPE(CQueueBase);

static NTSTATUS ACpIrp2Xact(PIRP irp, CTransaction** ppXact)
{
    *ppXact = NULL;

    ULONG ioctl = (IoGetCurrentIrpStackLocation(irp))->Parameters.DeviceIoControl.IoControlCode;
    XACTUOW * pUow;
    if (ioctl == IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID || ioctl == IOCTL_AC_RECEIVE_MESSAGE)
    {
        CACReceiveParameters * prp = static_cast<CACReceiveParameters*>(irp->AssociatedIrp.SystemBuffer);
        pUow = prp->MsgProps.pUow;
    }
#ifdef _WIN64
    else if (ioctl == IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_32 || ioctl == IOCTL_AC_RECEIVE_MESSAGE_32)
    {
        CACReceiveParameters_32 * prp32 = static_cast<CACReceiveParameters_32*>(irp->AssociatedIrp.SystemBuffer);
        pUow = prp32->MsgProps.pUow;
    }
#endif // _WIN64
    else
    {
        return STATUS_SUCCESS;
    }

    if (pUow == NULL)
    {
        return STATUS_SUCCESS;
    }

    __try
    {
        ACProbeForRead(pUow, sizeof(XACTUOW));
        *ppXact = CTransaction::Find(pUow);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return GetExceptionCode();
    }

    if((*ppXact) == NULL)
    {
        return MQ_ERROR_TRANSACTION_SEQUENCE;
    }

    return STATUS_SUCCESS;
}


NTSTATUS CQueueBase::HoldRequest(PIRP irp, ULONG ulTimeout, PDRIVER_CANCEL pCancel)
{
    if(ulTimeout == 0)
    {
        //
        //  Zero timeout, release cursor and return timout error
        //
        ACpRelease(irp_driver_context(irp)->Cursor());
        return MQ_ERROR_IO_TIMEOUT;

    }

    //
    // Get a transaction context. May be NULL.
    //
    CTransaction * pXact;
    NTSTATUS rc = ACpIrp2Xact(irp, &pXact);
    if (!NT_SUCCESS(rc))
    {
        return rc;
    }

    //
    //  Set the irp status to STATUS_CANCELLED, so if cancled by NT this
    //  will be the status returned
    //
    irp->IoStatus.Status = STATUS_CANCELLED;

    if (ulTimeout != INFINITE)
    {
        //
        // Schedule a timeout event in case no message will be received.
        // Calculate the absolute time for the timeout.
        //
        LARGE_INTEGER liTimeout;
        KeQuerySystemTime(&liTimeout);
        liTimeout.QuadPart += (LONGLONG)ulTimeout * 10000;

        //
        // Schedule the timeout event.
        // if failed, the scheduler is not disabled so no need to re-enable events.
        //
        if(!g_pReceiveScheduler->SchedAt(liTimeout, irp, TRUE))
            return STATUS_INSUFFICIENT_RESOURCES;
    }

    {
        ASL asl;
        IoSetCancelRoutine(irp, pCancel);
        IoMarkIrpPending(irp);
        m_readers.insert(irp);
        if (pXact != NULL)
        {
            pXact->HoldReader(irp);
        }
    }


    if (ulTimeout != INFINITE)
    {
        g_pReceiveScheduler->EnableEvents();
    }

    return STATUS_PENDING;
}


inline PIRP get_matching_irp(CIRPList& list, PFILE_OBJECT pOwner, BOOL fAll)
{
    //
    //  This helper function should be called with the cancel spinlock held
    //
    for(CIRPList::Iterator p(list); p; ++p)
    {
        PIRP irp = p;
        if(
            fAll ||
            (IoGetCurrentIrpStackLocation(irp)->FileObject == pOwner))
        {
            return irp;
        }
    }

    return 0;
}


void CQueueBase::CancelPendingRequests(NTSTATUS rc, PFILE_OBJECT pOwner, BOOL fAll)
{
    PIRP irp;
    KIRQL irql;

    for(;;)
    {
        IoAcquireCancelSpinLock(&irql);
        if((irp = get_matching_irp(m_readers, pOwner, fAll)) == 0)
        {
            break;
        }
        irp_driver_context(irp)->ManualCancel(true);
        ACCancelIrp(irp, irql, rc);

        //
        // The cancel spinlock should have been released by the cancel routine.
        //
    }

    IoReleaseCancelSpinLock(irql);
}

void CQueueBase::Close(PFILE_OBJECT pOwner, BOOL fCloseAll)
{
    if(fCloseAll)
    {
        //
        //  The queue is permanently closed
        //
        m_bfClosed = TRUE;
    }

    CancelPendingRequests(STATUS_CANCELLED, pOwner, fCloseAll);
}


NTSTATUS CQueueBase::CanClose() const
{
    //
    //  Check if the handle count is greater that 1, the QM ref
    //
    if(Ref() > 1)
    {
        return STATUS_HANDLE_NOT_CLOSABLE;
    }

    //
    //  Check if readers are pending
    //
    if(!m_readers.isempty())
    {
        return STATUS_HANDLE_NOT_CLOSABLE;
    }

    return STATUS_SUCCESS;
}


PIRP CQueueBase::get_request(CPacket* pPacket)
{
    //
    //  This member is called with the cancel spin lock held
    //

    PIRP irp = m_readers.gethead();
    if(irp != 0)
    {
        IoSetCancelRoutine(irp, 0);
        irp_driver_context(irp)->SafeRemoveXactReaderLink();
    }
    else if(m_owner != 0)
    {
        CQueueBase* pOwner = m_owner;
        irp = pOwner->get_request(pPacket);
    }
    return irp;
}


PIRP CQueueBase::GetRequest(CPacket* pPacket)
{
    KIRQL Irql;
    IoAcquireCancelSpinLock(&Irql);
    PIRP irp = get_request(pPacket);
    bool fTimeoutArmed = (irp != 0) && irp_driver_context(irp)->TimeoutArmed();
    IoReleaseCancelSpinLock(Irql);

    if(fTimeoutArmed)
    {
        //
        //  N.B. if we can't cancel the scheuler event; the irp is in the
        //      process of being timed-out. Nevertheless no cancel routine
        //      for that irp.
        //
        SafeSchedCancel(irp);
    }

    return irp;
}


inline PIRP get_tagged_irp(CIRPList& list, ULONG tag)
{
    //
    //  This helper function should be called with the cancel spinlock held
    //
    for(CIRPList::Iterator p(list); p; ++p)
    {
        PIRP irp = p;
        if(irp_driver_context(irp)->Tag() == tag)
        {
            return irp;
        }
    }

    return 0;
}


PIRP CQueueBase::GetTaggedRequest(ULONG tag)
{
    KIRQL Irql;
    IoAcquireCancelSpinLock(&Irql);
    PIRP irp = get_tagged_irp(m_readers, tag);
    bool fTimeoutArmed = (irp != 0) && irp_driver_context(irp)->TimeoutArmed();
    if(irp != 0)
    {
        m_readers.remove(irp);
        IoSetCancelRoutine(irp, 0);
        irp_driver_context(irp)->SafeRemoveXactReaderLink();
    }
    IoReleaseCancelSpinLock(Irql);

    if(fTimeoutArmed)
    {
        //
        //  N.B. if we can't cancel the scheuler event; the irp is in the
        //      process of being timed-out. Nevertheless no cancel routine
        //      for that irp.
        //
        SafeSchedCancel(irp);
    }
    return irp;
}


NTSTATUS CQueueBase::CancelTaggedRequest(NTSTATUS status, ULONG tag)
{
    KIRQL irql;
    IoAcquireCancelSpinLock(&irql);
    PIRP irp = get_tagged_irp(m_readers, tag);
    if(irp != 0)
    {
        irp_driver_context(irp)->ManualCancel(true);
        ACCancelIrp(irp, irql, status);
        return STATUS_SUCCESS;

        //
        // The cancel spinlock should have been released by the cancel routine.
        //
    }

    IoReleaseCancelSpinLock(irql);
    return STATUS_NOT_FOUND;
}


NTSTATUS
CQueueBase::ProcessLookupRequest(
    PIRP      irp,
    ULONG     ulAction,
    ULONGLONG LookupId
    )
/*++

Routine Description:

    Handle a request to read a packet based on its lookup ID.

Arguments:

    irp         - Pointer to the I/O request packet.

    ulAction    - Peek or Receive.

    LookupId    - A message property that uniquely identifies the message.

Return Value:

    STATUS_SUCCESS - The operation completed successfully.
    other status   - The operation failed.

--*/
{
    //
    // Lookup the packet based on its lookup ID
    //
    CPacket * pPacket;
    NTSTATUS rc = PeekPacketByLookupId(ulAction, LookupId, &pPacket);

    if (!NT_SUCCESS(rc))
    {
        return rc;
    }

    //
    //  A matching packet was found, process the request with this packet
    //
    new (irp_driver_context(irp)) CDriverContext(NULL, (ulAction & MQ_LOOKUP_RECEIVE_MASK) == MQ_LOOKUP_RECEIVE_MASK, true);
    return pPacket->ProcessRequest(irp);

} // CQueueBase::ProcessLookupRequest


NTSTATUS
CQueueBase::ProcessRequest(
    PIRP irp,
    ULONG ulTimeout,
    CCursor* pCursor,
    ULONG ulAction,
    bool  fReceiveByLookupId,
    ULONGLONG LookupId,
    OUT ULONG *pulTag
    )
{
    if (fReceiveByLookupId)
    {
        ASSERT(pCursor == 0);
        return ProcessLookupRequest(irp, ulAction, LookupId);
    }

    if(pCursor != 0)
    {
        NTSTATUS rc;
        rc = pCursor->Move(ulAction);
        if(!NT_SUCCESS(rc))
        {
            return rc;
        }
        pCursor->AddRef();
    }

    new (irp_driver_context(irp)) CDriverContext(pCursor, ulAction == MQ_ACTION_RECEIVE, ulTimeout != INFINITE);

    CPacket* pPacket = (pCursor) ? pCursor->Current() : PeekPacket();

    if(pPacket == 0)
    {
        //
        // No packet was available, tag request and hold it
        //
        irp_driver_context(irp)->Tag(++g_IrpTag);
        if (pulTag)
        {
            *pulTag = irp_driver_context(irp)->Tag();
        }
        return HoldRequest(irp, ulTimeout, ACCancelReader);
    }

    //
    //  A matching packet was found, process the request with this packet
    //
    return pPacket->ProcessRequest(irp);
}


void CQueueBase::MoveToGroup(CGroup* pNewOwner)
{
    if(pNewOwner == m_owner)
    {
        return;
    }

    if(m_owner)
    {
        m_owner->RemoveMember(this);
    }

    if(pNewOwner)
    {
        pNewOwner->AddMember(this);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\packet.h ===
/*++      

Copyright (c) 1995 Microsoft Corporation

Module Name:

    packet.h

Abstract:

    CPacket definition.

Author:

    Erez Haba (erezh) 3-Jan-96
    Shai Kariv (shaik) 11-Apr-2000

Revision History:

--*/

#ifndef __PACKET_H
#define __PACKET_H

#include <acioctl.h>
#include "qentry.h"

class CCursor;

//---------------------------------------------------------
//
//  class CPacket
//
//---------------------------------------------------------

class CPacket : public CQEntry {
public:
    ~CPacket();
    BOOL IsRecoverable(CPacketBuffer * ppb) const;
    BOOL IsDeadLetter(CPacketBuffer * ppb) const;

    void Done(USHORT usClass, CPacketBuffer * ppb);
    void PacketRundown(NTSTATUS rc);
    void QueueRundown();
    NTSTATUS ProcessRequest(PIRP irp);
    NTSTATUS CompleteRequest(PIRP irp);

	void Touch(CBaseHeader * pbh, ULONG ulSize);
	NTSTATUS StoreInPlace(PIRP irp);
    NTSTATUS Store(PIRP irp);
    void HandleStorageCompleted(NTSTATUS rc);
    void UpdateBitmap(ULONG size);

    NTSTATUS IssueCreatePacketRequest(bool fProtocolSrmp);
    void HandleCreatePacketCompleted(NTSTATUS rc, USHORT ack);

    void SendArrivalAcknowledgment();
    void HandleAcknowledgment();

    void StartTimer(CPacketBuffer * ppb, BOOL fTarget, ULONG ulDelay);
    void HandleTimeout();

    void CompleteWriter(NTSTATUS rc);
    void HandleRevoked(CPacketBuffer * ppb);
    int Priority() const;

    NTSTATUS RemoteRequestTail(CCursor* pCursor, BOOL fFreePacket, CPacketBuffer * ppb);

    CPacket* CreateXactDummy(CTransaction* pXact);
    void CacheCurrentState(CPacketBuffer* ppb);
    NTSTATUS DeleteStorage();
	
    NTSTATUS Convert(PIRP irp, BOOL fStore);

    BOOL IsXactLinkable() const;

#ifdef MQDUMP
    NTSTATUS Dump() const;
#else
    NTSTATUS Dump() const { return STATUS_SUCCESS; };
#endif //MQDUMP

private:
    CPacket(CMMFAllocator* pAllocator, CAllocatorBlockOffset abo);

    NTSTATUS GetProperties(CACReceiveParameters * pReceiveParams) const;

    NTSTATUS IssueStorage();
	NTSTATUS IssueDeleteStorage();
    NTSTATUS IssueAcknowledgment(USHORT usClass, BOOL fUser, BOOL fOrder);
    NTSTATUS IssueTimeout(ULONG ulTimeout);
    NTSTATUS IssueTimeoutRequest();

    void Journalize();
    void Kill(USHORT usClass);

    void SendAcknowledgment(USHORT usClass);
    void SendReceiveAcknowledgment();

    ULONG GetAbsoluteTimeToLive(CPacketBuffer * ppb, BOOL fAtTargetQueue) const;
    void CancelTimeout();
    void HoldWriteRequest(PIRP irp);

    NTSTATUS DoneXact(const XACTUOW* pUow);
    NTSTATUS ProcessQMRequest(PIRP irp);
    NTSTATUS ProcessRTRequestTB(PIRP irp, CACReceiveParameters * pReceiveParams);
    NTSTATUS ProcessRTRequest(PIRP irp);
#ifdef _WIN64    
    NTSTATUS ProcessRTRequest_32(PIRP irp);
#endif //_WIN64    
    NTSTATUS ProcessRRRequest(PIRP irp);

    CQueue* JournalQueue() const;
    CQueue* DeadLetterQueue(CPacketBuffer * ppb) const;

    CPacket* CloneSame();
    CPacket* CloneCopy(ACPoolType pt, BOOL fCheckMachineQuota) const;
    CPacket* Clone(ACPoolType pt);

	static ULONG ComputeCRC(CPacketBuffer *ppb);

    static
    NTSTATUS
    Create(
        CPacket * *        ppPacket,
        BOOL               fCheckMachineQuota,
        const CACSendParameters * pSendParams,
        const CQueue *     pDestinationQueue,
        ULONG              nDestinationMqf,
        const QUEUE_FORMAT DestinationMqf[],
        bool               fProtocolSrmp
        );


   

public:

    //
    //type definition of a class extracting LookupId from a packet
    //

    class CGetLookupId 
    {
    public:
        ULONGLONG operator()(const CPacket& pPacket)
        {
            return (pPacket.LookupId()); 
        }
    };
    
    static
    NTSTATUS
    Create(
        CPacket** ppPacket,
        ULONG ulPacketSize,
        ACPoolType pt,
        BOOL fCheckMachineQuota
        );

    static
    NTSTATUS
    SyncCreate(
        PIRP                      irp,
        CTransaction *            pXact,
        CQueue *                  pDestinationQueue,
        ULONG                     nDestinationMqf,
        const QUEUE_FORMAT        DestinationMqf[],
        BOOL                      fCheckMachineQuota,
        const CACSendParameters * pSendParams,
        CQueue *                  pAsyncCompletionHandler,
        bool                      fProtocolSrmp,
        CPacket * *               ppPacket
        );

    static
    NTSTATUS
    Restore(
        CMMFAllocator* pAllocator,
        CAllocatorBlockOffset abo
    );


	static NTSTATUS CheckPacket(CAccessibleBlock* pab);
    static CPacket* GetWriterPacket(PIRP);
};

//---------------------------------------------------------
//
// IMPLEMENTATION
//
//---------------------------------------------------------

inline BOOL CPacket::IsRecoverable(CPacketBuffer * ppb) const
{
    ASSERT(ppb != NULL && MappedBuffer() == ppb);
    CBaseHeader * pBase = ppb;

    CUserHeader* pUser = CPacketBuffer::UserHeader(pBase);
    return (pUser->GetDelivery() == MQMSG_DELIVERY_RECOVERABLE);
}

inline BOOL CPacket::IsDeadLetter(CPacketBuffer * ppb) const
{
    ASSERT(ppb != NULL && MappedBuffer() == ppb);
    CBaseHeader * pBase = ppb;

    CUserHeader* pUser = CPacketBuffer::UserHeader(pBase);
    return (pUser->GetAuditing() & MQMSG_DEADLETTER);
}


inline void CPacket::SendArrivalAcknowledgment()
{
    ASSERT(Queue() != 0);

    if(!ArrivalAckIssued())
    {
        ArrivalAckIssued(TRUE);
        SendAcknowledgment(MQMSG_CLASS_ACK_REACH_QUEUE);
    }
}


inline NTSTATUS CPacket::CompleteRequest(PIRP irp)
{
    NTSTATUS rc = ProcessRequest(irp);
    if(rc != STATUS_PENDING)
    {
        irp->IoStatus.Status = rc;
        IoCompleteRequest(irp, IO_MQAC_INCREMENT);
    }
    return rc;
}

inline BOOL CPacket::IsXactLinkable() const
{
    return (IsOrdered() &&
            InSourceMachine() &&
            BufferAttached());
}


//
// Global routines
//

NTSTATUS
ACpGetQueueFormatString(
    NTSTATUS rc,
    const QUEUE_FORMAT& qf,
    LPWSTR* ppfn,
    PULONG pBufferLen,
    bool   fSerializeMqfSeperator
    );


#endif // __PACKET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\qproxy.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    queue.cxx

Abstract:

    This module contains the code to for Falcon Read routine.

Author:

    Erez Haba (erezh) 1-Aug-95

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "lock.h"
#include "qm.h"
#include "qproxy.h"
#include "acp.h"

#ifndef MQDUMP
#include "qproxy.tmh"
#endif

//---------------------------------------------------------
//
//  Remote reader cancel routine
//
//---------------------------------------------------------

static
VOID
NTAPI
ACCancelRemoteReader(
    IN PDEVICE_OBJECT /*pDevice*/,
    IN PIRP irp
    )
/*++

Routine Description:

    Cancel a REMOTE reader request, it can get canceled by NT when the thread
    terminates. Or internally when an error reply to that request return. In
    the latter case no need to issue a remote cancel request.

--*/
{
    ACpRemoveEntryList(&irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(irp->CancelIrql);

    TrTRACE(
        AC,
        "AC%sRemoteReader (irp=0x%p, pProxy=0x%p, tag=%d, rc=0x%x)\n",
        (irp_driver_context(irp)->ManualCancel() ? "Done" : "Cancel"),
        irp, irp_driver_context(irp)->Proxy(), irp_driver_context(irp)->Tag(), irp->IoStatus.Status
        );

    ASSERT(irp_driver_context(irp)->Proxy() != NULL);

    //
    //  Issue a cancel request only if not canceled manualy
    //  (i.e., canceled by the system).
    //  Lock the driver mutext so access the resoruces is thread safe.
    //
    if(!irp_driver_context(irp)->ManualCancel())
    {
        CS lock(g_pLock);
        CProxy* pProxy = irp_driver_context(irp)->Proxy();
        pProxy->IssueCancelRemoteRead(irp_driver_context(irp)->Tag());
    }

    //
    //  The status is not set here, it is set by the caller, when the irp is
    //  held in a list it status is set to STATUS_CANCELLED.
    //
    //irp->IoStatus.Status = STATUS_CANCELLED;
    irp->IoStatus.Information = 0;

    IoCompleteRequest(irp, IO_NO_INCREMENT);
}


static
VOID
NTAPI
ACCancelRemoteCreateCursor(
    IN PDEVICE_OBJECT /*pDevice*/,
    IN PIRP irp
    )
/*++

Routine Description:

    Cancel a REMOTE Create Cursor request, it can get canceled by NT when the thread
    terminates. Or internally when an error reply to that request return.

--*/
{
    ACpRemoveEntryList(&irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(irp->CancelIrql);

    TrTRACE(AC, "ACCancelRemoteCreateCursor (irp=0x%p)", irp);

    //
    //  The status is not set here, it is set by the caller, when the irp is
    //  held in a list it status is set to STATUS_CANCELLED.
    //
    //irp->IoStatus.Status = STATUS_CANCELLED;
    irp->IoStatus.Information = 0;

    IoCompleteRequest(irp, IO_NO_INCREMENT);
}


//---------------------------------------------------------
//
//  class CProxy
//
//---------------------------------------------------------

DEFINE_G_TYPE(CProxy);


inline
NTSTATUS
CProxy::IssueRemoteRead(
    ULONG hRemoteCursor,
    ULONG ulAction,
    ULONG ulTimeout,
    ULONG ulTag,
    ULONG MaxBodySize,
    ULONG MaxCompoundMessageSize,
    bool  fReceiveByLookupId,
    ULONGLONG LookupId
    ) const
{
    CACRequest request(CACRequest::rfRemoteRead);
    request.Remote.cli_pQMQueue = m_cli_pQMQueue;
    request.Remote.Read.ulTag = ulTag;
    request.Remote.Read.hRemoteCursor = hRemoteCursor;
    request.Remote.Read.ulAction = ulAction;
    request.Remote.Read.ulTimeout = ulTimeout;
    request.Remote.Read.MaxBodySize = MaxBodySize;
    request.Remote.Read.MaxCompoundMessageSize = MaxCompoundMessageSize;
    request.Remote.Read.fReceiveByLookupId = fReceiveByLookupId;
    request.Remote.Read.LookupId = LookupId;

    return  g_pQM->ProcessRequest(request);
}

NTSTATUS CProxy::IssueCancelRemoteRead(ULONG ulTag) const
{
    CACRequest request(CACRequest::rfRemoteCancelRead);
    request.Remote.cli_pQMQueue = m_cli_pQMQueue;
    request.Remote.CancelRead.ulTag = ulTag;

    return  g_pQM->ProcessRequest(request);
}

NTSTATUS CProxy::IssueRemoteCloseQueue() const
{
    CACRequest request(CACRequest::rfRemoteCloseQueue);
    request.Remote.cli_pQMQueue = m_cli_pQMQueue;

    return g_pQM->ProcessRequest(request);
}

NTSTATUS CProxy::IssueRemoteCloseCursor(ULONG hCursor) const
{
    CACRequest request(CACRequest::rfRemoteCloseCursor);
    request.Remote.cli_pQMQueue = m_cli_pQMQueue;
    request.Remote.CloseCursor.hRemoteCursor = hCursor;

    return g_pQM->ProcessRequest(request);
}

NTSTATUS CProxy::IssueRemotePurgeQueue() const
{
    CACRequest request(CACRequest::rfRemotePurgeQueue);
    request.Remote.cli_pQMQueue = m_cli_pQMQueue;

    return g_pQM->ProcessRequest(request);
}


VOID
CProxy::GetBodyAndCompoundSizesFromIrp(
    PIRP   irp,
	ULONG* pMaxBodySize,
	ULONG* pMaxCompoundMessageSize
	) const
{
	*pMaxBodySize = 0;
	*pMaxCompoundMessageSize = 0;

	//
	// Get ulBodyBufferSizeInBytes, CompoundMessageSizeInBytes from the irp.
	//
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    ULONG InputBufferLength  = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    PVOID SystemBuffer = irp->AssociatedIrp.SystemBuffer;

#ifdef _WIN64
    ULONG IoControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;

	if((IoControlCode == IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_32) ||
	   (IoControlCode == IOCTL_AC_RECEIVE_MESSAGE_32))
	{
	    ASSERT(InputBufferLength == sizeof(CACReceiveParameters_32));
	    CACReceiveParameters_32* pReceiveParams32 = static_cast<CACReceiveParameters_32*>(SystemBuffer);
	    *pMaxBodySize = pReceiveParams32->MsgProps.ulBodyBufferSizeInBytes;
	    *pMaxCompoundMessageSize = pReceiveParams32->MsgProps.CompoundMessageSizeInBytes;
		return;
	}
#endif //_WIN64

    ASSERT(InputBufferLength == sizeof(CACReceiveParameters));
	DBG_USED(InputBufferLength);
    CACReceiveParameters* pReceiveParams = static_cast<CACReceiveParameters*>(SystemBuffer);
    *pMaxBodySize = pReceiveParams->MsgProps.ulBodyBufferSizeInBytes;
    *pMaxCompoundMessageSize = pReceiveParams->MsgProps.CompoundMessageSizeInBytes;
}


NTSTATUS
CProxy::ProcessRequest(
    PIRP      irp,
    ULONG     ulTimeout,
    CCursor * pCursor,
    ULONG     ulAction,
	bool      fReceiveByLookupId,
    ULONGLONG LookupId,
    OUT ULONG *pulTag
    )
{
    UNREFERENCED_PARAMETER(pulTag);
    //
    //  Set irp information.
    //  N.B. we don't hold the cursor since we don't need it any more
    //      irp flags are reset since the packet is release manually in
    //      PutRemotePacket so CPacket::ProcessRTRequest does not free it.
    //
    new (irp_driver_context(irp)) CDriverContext(false, false, this);

	//
	// Get ulBodyBufferSizeInBytes, CompoundMessageSizeInBytes from the irp.
	//
	ULONG MaxBodySize = 0;
	ULONG MaxCompoundMessageSize = 0;
	GetBodyAndCompoundSizesFromIrp(irp, &MaxBodySize, &MaxCompoundMessageSize);

    TrTRACE(AC, "irp = 0x%p, MaxBodySize = %d, MaxCompoundMessageSize = %d", irp, MaxBodySize, MaxCompoundMessageSize);

    NTSTATUS rc;
    ULONG hRemoteCursor = (pCursor) ? pCursor->RemoteCursor() : 0;
    rc = IssueRemoteRead(
             hRemoteCursor,
             ulAction,
             ulTimeout,
             irp_driver_context(irp)->Tag(),
			 MaxBodySize,
			 MaxCompoundMessageSize,			
			 fReceiveByLookupId,
             LookupId
             );
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    return HoldRequest(irp, INFINITE, ACCancelRemoteReader);

}

NTSTATUS CProxy::PutRemotePacket(CPacket* pPacket, ULONG ulTag)
{
    CPacketBuffer * ppb = pPacket->Buffer();
    if (ppb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pPacket->CacheCurrentState(ppb);

    NTSTATUS rc = STATUS_NOT_FOUND;
    PIRP irp = GetTaggedRequest(ulTag);
    if(irp != 0)
    {
        ASSERT(!irp_driver_context(irp)->IrpWillFreePacket());
        rc = pPacket->CompleteRequest(irp);
    }

    if( NT_SUCCESS(rc) )
    {
        pPacket->Release();
    }
    return rc;
}

NTSTATUS CProxy::IssueRemoteCreateCursor(ULONG ulTag) const
{
    CACRequest request(CACRequest::rfRemoteCreateCursor);

    request.Remote.cli_pQMQueue = m_cli_pQMQueue;
    request.Remote.CreateCursor.ulTag = ulTag;

    return g_pQM->ProcessRequest(request);
}

NTSTATUS
CProxy::CreateCursor(
	PIRP irp,
	PFILE_OBJECT /* pFileObject */,
	PDEVICE_OBJECT /* pDevice */
	)
{
    //
    //  Set irp information.
	//
    new (irp_driver_context(irp)) CDriverContext(false, false, this);

    NTSTATUS rc = IssueRemoteCreateCursor(irp_driver_context(irp)->Tag());
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    return HoldRequest(irp, INFINITE, ACCancelRemoteCreateCursor);
}

NTSTATUS
CProxy::CreateRemoteCursor(
	PDEVICE_OBJECT pDevice,
    ULONG hRemoteCursor,
    ULONG ulTag
	)
{

    PIRP irp = GetTaggedRequest(ulTag);

	if(irp == 0)
	{
		//
		// Irp was not found, return status not found to the qm.
		//
	    return STATUS_NOT_FOUND;
	}

	//
	// Get original pFileObject from the irp.
	//
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    PFILE_OBJECT pOriginalFileObject = irpSp->FileObject;

	//
    //  Create the local cursor.
    //
    HACCursor32 hCursor = CCursor::Create(CPacketPool(), pOriginalFileObject, pDevice, this);
    if(hCursor == 0)
    {
    	TrERROR(AC, "Failed to create a local cursor for remote read."); 

		//
		// Complete irp
		//
	    irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
	    IoCompleteRequest(irp, IO_NO_INCREMENT);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    TrTRACE(AC, "completing irp = 0x%p, hCursor = 0x%x, hRemotecursor = 0x%x", irp, (ULONG)hCursor, hRemoteCursor);

    CCursor* pCursor = CCursor::Validate(hCursor);
    HoldCursor(pCursor);

    //
    //  Set remote cursor proprty
    //
    pCursor->RemoteCursor(hRemoteCursor);

	//
	// Set return value to RT - get original HACCursor32* from the irp.
	//
    PVOID SystemBuffer = irp->AssociatedIrp.SystemBuffer;
	HACCursor32* phCursor = static_cast<HACCursor32*>(SystemBuffer);
	*phCursor = hCursor;
    irp->IoStatus.Information = sizeof(HACCursor32);

	//
	// Complete irp
	//
    irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


void CProxy::Close(PFILE_OBJECT pOwner, BOOL fCloseAll)
{
    Inherited::Close(pOwner, fCloseAll);

    if(!fCloseAll && !Closed())
    {
        //
        //  This is the application closing the handle and it
        //  did not happen after the qm go down and up again.
        //
        IssueRemoteCloseQueue();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\qproxy.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qproxy.h

Abstract:

    CProxy definition. It is the Falcon Queue represination in the
    Access Control layer.

Author:

    Erez Haba (erezh) 27-Nov-95

Revision History:
--*/

#ifndef __QPROXY_H
#define __QPROXY_H

#include "quser.h"

//---------------------------------------------------------
//
//  class CProxy
//
//---------------------------------------------------------

class CProxy : public CUserQueue {

    typedef CUserQueue Inherited;
    friend static VOID NTAPI ACCancelRemoteReader(PDEVICE_OBJECT, PIRP);

public:
    CProxy(
        PFILE_OBJECT pFile,
        ACCESS_MASK DesiredAccess,
        ULONG ShareAccess,
        const QUEUE_FORMAT* pQueueID,
        const VOID* cli_pQMQueue
        );

    //
    //  Close that queue
    //
    virtual void Close(PFILE_OBJECT pOwner, BOOL fCloseAll);

    //
    //  Process read request
    //
    virtual
    NTSTATUS
    ProcessRequest(
        PIRP,
        ULONG Timeout,
        CCursor*,
        ULONG Action,
		bool  fReceiveByLookupId,
        ULONGLONG LookupId,
        OUT ULONG *pulTag
        );

    //
    //  Create a cursor
    //
    virtual NTSTATUS CreateCursor(PIRP irp, PFILE_OBJECT pFileObject, PDEVICE_OBJECT pDevice);

    //
    // Create remote cursor on this queue
    //
    virtual NTSTATUS CreateRemoteCursor(PDEVICE_OBJECT pDevice, ULONG hRemoteCursor, ULONG ulTag);

    //
    //  Purge the queue content, and optionally mark it as deleted
    //
    virtual NTSTATUS Purge(BOOL fDelete, USHORT usClass);

    //
    //  Put a packet in the queue
    //
    NTSTATUS PutRemotePacket(CPacket* pPacket, ULONG ulTag);

    //
    //  Close a cursor on a remote machine.
    //
    NTSTATUS IssueRemoteCloseCursor(ULONG Cursor) const;

private:
    //
    // Ask the QM to remote read a message.
    //
    NTSTATUS
    IssueRemoteRead(
        ULONG Cursor,
        ULONG Action,
        ULONG Timeout,
        ULONG Tag,
		ULONG MaxBodySize,
		ULONG MaxCompoundMessageSize,
        bool      fReceiveByLookupId,
        ULONGLONG LookupId
        ) const;

	//
	// Get ulBodyBufferSizeInBytes, CompoundMessageSizeInBytes from the irp.
	//
	VOID
	GetBodyAndCompoundSizesFromIrp(
	    PIRP   irp,
		ULONG* pMaxBodySize,
		ULONG* pMaxCompoundMessageSize
		) const;

    //
    //  Close a queue on a remote machine.
    //
    NTSTATUS IssueRemoteCloseQueue() const;

    //
    // issue a request to cancel a pending read on remote (Server) machine.
    //
    NTSTATUS IssueCancelRemoteRead(ULONG ulTag) const;

    //
    // issue a request to purge the queue on remote (Server) machine.
    //
    NTSTATUS IssueRemotePurgeQueue() const;

    //
    // issue a request to create cursor for the queue on remote (Server) machine.
    //
	NTSTATUS IssueRemoteCreateCursor(ULONG ulTag) const;

protected:
    virtual ~CProxy() {}

private:
    //
    //  Remote reader context held in CProxy
    //
	const VOID* m_cli_pQMQueue;

public:
    static NTSTATUS Validate(const CProxy* pProxy);
#ifdef MQWIN95
    static NTSTATUS Validate95(const CProxy* pProxy);
#endif

private:
    //
    //  Class type debugging section
    //
    CLASS_DEBUG_TYPE();
};


//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

inline
CProxy::CProxy(
    PFILE_OBJECT pFile,
    ACCESS_MASK DesiredAccess,
    ULONG ShareAccess,
    const QUEUE_FORMAT* pQueueID,
    const VOID* cli_pQMQueue
    ) :
    Inherited(pFile, DesiredAccess, ShareAccess, pQueueID),
    m_cli_pQMQueue(cli_pQMQueue)
{
}

inline NTSTATUS CProxy::Validate(const CProxy* pProxy)
{
    ASSERT(pProxy && pProxy->isKindOf(Type()));
    return Inherited::Validate(pProxy);
}

#ifdef MQWIN95

inline NTSTATUS CProxy::Validate95(const CProxy* pProxy)
{
    NTSTATUS rc =  STATUS_INVALID_HANDLE;

    __try
    {
        ASSERT(pProxy && pProxy->isKindOf(Type()));
        rc = Inherited::Validate(pProxy);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc =  STATUS_INVALID_HANDLE;
    }

    return rc ;
}

#endif

inline NTSTATUS CProxy::Purge(BOOL /*fDelete*/, USHORT usClass)
{
    ASSERT(usClass == MQMSG_CLASS_NORMAL);
    DBG_USED(usClass);

    return IssueRemotePurgeQueue();
}

#endif // __QPROXY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\queue.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    queue.cxx

Abstract:

    This module contains the code to for Falcon Read routine.

Author:

    Erez Haba (erezh) 1-Aug-95
    Shai Kariv (shaik) 11-Apr-2000

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "queue.h"
#include "qxact.h"
#include "qm.h"
#include "lock.h"
#include "localsend.h"
#include "irp2pkt.h"

#ifndef MQDUMP
#include "queue.tmh"
#endif

//---------------------------------------------------------
//
//  class CQueue
//
//---------------------------------------------------------

DEFINE_G_TYPE(CQueue);

NTSTATUS 
CQueue::CreateCursor(
	PIRP irp, 
	PFILE_OBJECT pFileObject, 
	PDEVICE_OBJECT pDevice 
	)
{
    HACCursor32 hCursor = CCursor::Create(m_packets, pFileObject, pDevice, this);
    if(hCursor == 0)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    HoldCursor(CCursor::Validate(hCursor));

	//
	// Set return value to RT - get HACCursor32* from the irp.
	//
    PVOID SystemBuffer = irp->AssociatedIrp.SystemBuffer;
	HACCursor32* phCursor = static_cast<HACCursor32*>(SystemBuffer);
    *phCursor = hCursor;
    irp->IoStatus.Information = sizeof(HACCursor32);

    return STATUS_SUCCESS;
}


void CQueue::CreateJournalQueue()
{
    FILE_OBJECT DummyFileObject = {0};
    QueueCounters* pQueueCounters = 0;
    if (m_pQueueCounters)
    {
        pQueueCounters = m_pQueueCounters + 1;
    }

    CQueue* pQueue =
        new (NonPagedPool) CQueue(
                                &DummyFileObject,
                                FILE_WRITE_ACCESS,
                                FILE_SHARE_READ | FILE_SHARE_DELETE,
                                FALSE,
                                &m_gQMID,
                                UniqueID(),
                                pQueueCounters,
                                0,
                                0,
								0
                                );

    if(pQueue == 0)
    {

        //
        //  if no memory, no journal queue is created
        //
        TrERROR(AC, "Failed to allocate a journal queue from non paged pool."); 
        return;
    }
	
	ASSERT (pQueue->IsValidQueueFormat());

    //
    //  Set Journal Queue, correct QUEUE_FORMAT
    //
    const_cast<QUEUE_FORMAT*>(pQueue->UniqueID())
        ->Suffix(QUEUE_SUFFIX_TYPE_JOURNAL);

    //
    //  Set arrival time update and storage in journal queue
    //
    pQueue->Store(TRUE);
    pQueue->Silent(TRUE);
    m_pJournalQueue = pQueue;
}



CPacket* CQueue::PeekPacket(void)
{
    for(CPacketPool::Iterator p = m_packets.lower_bound(m_FirstUnreceivedLookupId); p != m_packets.end(); ++p)
    {
        CPacket* pPacket = p;
        if(!pPacket->IsReceived())
        {
            m_FirstUnreceivedLookupId = pPacket->LookupId();
            return pPacket;
        }
    }
    m_FirstUnreceivedLookupId = 0xFFFFFFFFFFFFFFFF;
    return 0;
}


CPacket* CQueue::PeekNextPacketByLookupId(ULONGLONG LookupId) const
{

     for( CPacketPool::Iterator p = m_packets.upper_bound(LookupId); p != m_packets.end(); ++p)
     {
        CPacket* pPacket = p;
        if(!pPacket->IsReceived())
        {
            return pPacket;
        }
     }
     return 0;

} // CQueue::PeekNextPacketByLookupId



CPacket* CQueue::PeekPrevPacketByLookupId(ULONGLONG LookupId) const
{
     CPacketPool::Iterator p = m_packets.lower_bound(LookupId);
     if(p == m_packets.end())
     {
         p = m_packets.rbegin();
     }
     else
     {
         --p;
     }
     for( ;p != m_packets.rend(); --p)
     {
        CPacket* pPacket = p;
        if(!pPacket->IsReceived())
        {
            return pPacket;
        }
     }
     return 0;

} // CQueue::PeekPrevPacketByLookupId




CPacket * CQueue::PeekCurrentPacketByLookupId(ULONGLONG LookupId) const
{
      CPacketPool::Iterator p = m_packets.find(LookupId);
      CPacket* pPacket = p;
      if((p != m_packets.end()) && (!pPacket->IsReceived()))
      {
          return pPacket;
      }
      return 0;

} // CQueue::PeekCurrentPacketByLookupId




NTSTATUS CQueue::PeekPacketByLookupId(ULONG Action, ULONGLONG LookupId, CPacket** ppPacket)
{
    switch (Action)
    {
        case MQ_LOOKUP_PEEK_NEXT:
        case MQ_LOOKUP_RECEIVE_NEXT:
            *ppPacket = PeekNextPacketByLookupId(LookupId);
            break;

        case MQ_LOOKUP_PEEK_PREV:
        case MQ_LOOKUP_RECEIVE_PREV:
            *ppPacket = PeekPrevPacketByLookupId(LookupId);
            break;

        case MQ_LOOKUP_PEEK_CURRENT:
        case MQ_LOOKUP_RECEIVE_CURRENT:
            *ppPacket = PeekCurrentPacketByLookupId(LookupId);
            break;

        default:
            return STATUS_INVALID_PARAMETER;
            break;
    }

    if (*ppPacket == NULL)
    {
        return MQ_ERROR_MESSAGE_NOT_FOUND;
    }

    return STATUS_SUCCESS;

} // CQueue::PeekPacketByLookupId


inline static void ACpYieldGlobalLock(void)
/*++

Routine Description:

    Unlock and relock the driver global lock so that pending threads can preempt
    the current thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    g_pLock->Unlock();

    g_pLock->Lock();

} // ACpYieldGlobalLock


NTSTATUS CQueue::Purge(BOOL fDelete, USHORT Class)
{
    if(Deleted())
    {
        //
        //  Can't purge an already deleted queue
        //
        return MQ_ERROR_QUEUE_DELETED;
    }

    USHORT usClass;
    BOOL fTarget = IsTargetQueue();
    if(fDelete)
    {
        Deleted(TRUE);
        CancelPendingRequests(MQ_ERROR_QUEUE_DELETED, 0, TRUE);

        usClass = fTarget ? MQMSG_CLASS_NACK_Q_DELETED : MQMSG_CLASS_NACK_BAD_DST_Q;
    }
    else
    {
        usClass = fTarget ? MQMSG_CLASS_NACK_Q_PURGED : MQMSG_CLASS_NACK_PURGED;
    }

    if (Class != MQMSG_CLASS_NORMAL)
    {
        usClass = Class;
    }

    for(CPacketPool::Iterator p = m_packets.begin(); p != m_packets.end() ; )
    {
        CPacket* pPacket = p;

        if (!pPacket->BufferAttached())
        {
			++p;
            continue;
        }

        CPacketBuffer * ppb = pPacket->Buffer();
        if (ppb == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        pPacket->AddRef();
        pPacket->Done(usClass, ppb);

        ACpYieldGlobalLock();

        if (!ACpEntryInTree(pPacket->m_treenode))
        {
            //
            // QM rundown, another thread closed the queue and removed all packets.
            // This packet should be rundown and not belong to any queue here.
            //
            ASSERT(pPacket->IsRundown());
            ASSERT(pPacket->Queue() == NULL);
            pPacket->Release();
            return STATUS_CANCELLED;
        }

        ++p;
        pPacket->Release();
    }

    //
    //  Delete the journal queue, only if this is a delete
    //
    CQueue* pQueue = JournalQueue();
    if(fDelete && (pQueue != 0))
    {
        pQueue->Purge(TRUE, usClass);
    }

    //
    //  Set prev ordering number, so the next message sent to this queue
    //  will be accepted in receiver side.
    //
    m_ulPrevN = 0;

    return STATUS_SUCCESS;
}


void CQueue::Close(PFILE_OBJECT pOwner, BOOL fCloseAll)
{
    Inherited::Close(pOwner, fCloseAll);

    //
    //  Revoke packets (fCloseAll indicate QM close, i.e., delete queue)
    //
    if(fCloseAll)
    {
        //
        //  The queue was permanently closed
        //
        CPacket* pPacket;
        while((pPacket = m_packets.begin()) != 0)
        {
            m_packets.remove(*pPacket);
            pPacket->QueueRundown();

        }

        //
        //  Close the journal queue as if the qm closed it
        //
        CQueue* pQueue = JournalQueue();
        if(pQueue != 0)
        {
            pQueue->Close(pOwner, TRUE);
        }

        //
        //  When the queue is close, do not count packest on him any more.
        //
        m_pQueueCounters = NULL;
    }
}


NTSTATUS CQueue::CanClose() const
{
    NTSTATUS rc;
    rc = Inherited::CanClose();
    if(!NT_SUCCESS(rc))
    {
        return rc;
    }

    //
    //  There are packets in this queue
    //
    if(!m_packets.isempty())
    {
        return STATUS_HANDLE_NOT_CLOSABLE;
    }

    //
    //  There is a journal queue ask it
    //
    if(m_pJournalQueue != 0)
    {
        return m_pJournalQueue->CanClose();
    }

    return STATUS_SUCCESS;
}


inline BOOL CQueue::QuotaExceeded() const
{
    return (m_quota_used > m_quota);
}


void update_performance_counters(QueueCounters* pQueueCounters, LONG lSize, LONG lSign)
{
    ASSERT(lSize != 0);
    ASSERT((lSign == 1) || (lSign == -1));

    if(g_ulACQM_PerfBuffOffset == NO_BUFFER_OFFSET)
    {
        return;
    }

    if(pQueueCounters)
    {
        pQueueCounters->nInBytes += lSize;
        pQueueCounters->nInPackets += lSign;
    }

    if(g_pQmCounters)
    {
        g_pQmCounters->nTotalBytesInQueues += lSize;
        g_pQmCounters->nTotalPacketsInQueues += lSign;
    }
}


inline void CQueue::ChargeQuota(ULONG ulSize)
{
    ++m_count;
    m_quota_used += ulSize;
    update_performance_counters(m_pQueueCounters, ulSize, 1);
}


void CQueue::RestoreQuota(ULONG ulSize)
{
    --m_count;
    m_quota_used -= ulSize;
    update_performance_counters(m_pQueueCounters, -(LONG)ulSize, -1);
}


void CQueue::AssignSequence(CPacketBuffer * ppb)
{
    ASSERT(ppb != NULL);
    CBaseHeader * pBase = ppb;

    CXactHeader* pXactHeader = CPacketBuffer::XactHeader(pBase);
    ASSERT(pXactHeader != 0);
    pXactHeader->SetSeqID(m_liSeqID);

    pXactHeader->SetPrevSeqN(m_ulPrevN);
    pXactHeader->SetSeqN(++m_ulSeqN);
    m_ulPrevN = m_ulSeqN;
}


inline void CQueue::CorrectSequence(const CPacket* pPacket, CPacketBuffer * ppb)
{
    ASSERT(ppb != NULL && pPacket->MappedBuffer() == ppb);

    if(!pPacket->IsOrdered() || !pPacket->InSourceMachine())
    {
        //
        //  Non of these should correct sequence.
        //
        return;
    }

    CXactHeader* pXactHeader = CPacketBuffer::XactHeader(ppb);
    ASSERT(pXactHeader != 0);

    //
    // We want all sent-after-restore messages to get new SeqID
    // So don't correct Queue SeqID using pre-restore messages.
    //
    if(pXactHeader->GetSeqID() < g_liSeqIDAtRestore)
    {
        //
        //  Non of these should correct sequence.
        //
        return;
    }

    //
    // Calculate the sure sequence SeqN by pushing it to
    //      Message.SeqN + (MsgIDFromRegistry -  Message.MsgID)
    // for last message of this sequence.
    //
    // Reason: that many packets may be timed out without any trace
    //   If they had came to the destination, next message will be rejected
    //

    ULONG ulSeqN = pXactHeader->GetSeqN();

    ULONG MessageSequentialIdLow32 = static_cast<ULONG>(g_MessageSequentialID);
    ULONG diff = MessageSequentialIdLow32 - ppb->SequentialIdLow32();

    if(!SequenceCorrected())
    {
        //
        // First seen message
        //
        m_liSeqID = pXactHeader->GetSeqID();
        m_ulPrevN = ulSeqN;
        m_ulSeqN  = ulSeqN + diff;
        SequenceCorrected(TRUE);
    }
    else
    {
        ASSERT(Silent() || (m_liSeqID == pXactHeader->GetSeqID()));

        //
        // Catching the last message in a sequence
        //
        if(m_ulPrevN < ulSeqN)
        {
            m_ulPrevN = ulSeqN;
            m_ulSeqN  = ulSeqN + diff;
        }
    }
}


NTSTATUS CQueue::RestorePacket(CPacket* pPacket)
{
    ASSERT(pPacket->Queue() == 0);
    ASSERT(pPacket->IsRevoked() == FALSE);
    ASSERT(pPacket->IsReceived() == FALSE);

    CPacketBuffer* ppb = pPacket->Buffer();
    if (ppb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ChargeQuota(ppb->GetPacketSize());

    pPacket->CacheCurrentState(ppb);
    InsertPacket(pPacket);

	//
	// this is a must so in the next PeekPacket we will get this message
	//
	m_FirstUnreceivedLookupId = 0;
	
    CorrectSequence(pPacket, ppb);
    pPacket->StartTimer(ppb, IsTargetQueue(), 0);
    return STATUS_SUCCESS;
}


void CQueue::SetPacketInformation(CPacketInfo* ppi)
{
    if(ArrivalTimeUpdate())
    {
        //
        //  Write arrival time on the packet, and mark it as in its target queue.
        //
        ppi->ArrivalTime(system_time());
    }

    ppi->InTargetQueue(IsTargetQueue());
    ppi->InConnectorQueue((GetQueueFormatType() == QUEUE_FORMAT_TYPE_CONNECTOR));
}


inline ULONG QueueToMessaePrivLevel(ULONG ulPrivLevel)
{
    switch(ulPrivLevel)
    {
        case MQ_PRIV_LEVEL_NONE:
            return MQMSG_PRIV_LEVEL_NONE;

        case MQ_PRIV_LEVEL_BODY:
            return MQMSG_PRIV_LEVEL_BODY_BASE;
    }

    //
    //  We should not really get here
    //
    ASSERT(ulPrivLevel != ulPrivLevel);
    return INFINITE;
}


void
CQueue::HandleValidTransactionUsage(
    BOOL      fTransactionalSend,
    CPacket * pPacket
    )
    const
{
    if(!this->IsTargetQueue() && this->UnknownQueueType())
    {
        return;
    }

    if (fTransactionalSend == this->Transactional())
    {
        return;
    }

    pPacket->SetRevoked();

    if (!fTransactionalSend)
    {
        ASSERT(this->Transactional());
        pPacket->FinalClass(MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG);
        return;
    }

    ASSERT(!this->Transactional());
    pPacket->FinalClass(MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q);

} // CQueue::HandleValidTransactionUsage

inline void CQueue::UpdateFirstUnreceivedLookupId(ULONGLONG LookupId)
{
    if (LookupId <  m_FirstUnreceivedLookupId)
    {
        m_FirstUnreceivedLookupId = LookupId;
    }
}

void CQueue::RemovePacket(CPacket * pPacket)
{
    m_packets.remove(*pPacket);
}

inline
void
CQueue::InsertPacket(
    CPacket * pPacket
    )
{
    m_packets.insert(*pPacket);
    pPacket->Queue(this);
    ASSERT(pPacket->BufferAttached());

} // CQueue::InsertPacket


NTSTATUS
CQueue::PutNewPacket(
    PIRP                      irp,
    CTransaction *            pXact,
    BOOL                      fCheckMachineQuota,
    const CACSendParameters * pSendParams
    )
/*++

Routine Description:

    This service handles the request for creating a new packet and putting it in
    the [distribution/]queue or the transaction.

    Algorithm:

    * AddRef queue/xact. Needed for async completion.
    * Create a new packet:
      * Can be completed sync or async.
      * Anyway packet is attached to irp, and points back to queue/xact.
    * If async, hold irp in a list and make it cancellable.
    * If sync completion, call the success completion handler to finish the work.
    * Failure handling: every routine cleans up after itself in case of failure.

Arguments:

    irp                - The interrupt request packet of the send request.

    pXact              - Optional transaction object. If exists, packet to be put in it.

    fCheckMachineQuota - Indicates whether to check machine quota when put packet.

    pSendParams        - Points to send parameters.

Return Value:

    STATUS_SUCCESS - Packet was put in queue/transaction successfully and synchronously.

    STATUS_PENDING - Packet creation is pending for QM processing.

    other status   - The operation failed. There is no packet.

--*/
{
    //
    // AddRef queue/xact. Call queue/distribution to create packet[s].
    //
    AddRef();
    ACpAddRef(pXact);
    NTSTATUS rc = CreatePacket(irp, pXact, fCheckMachineQuota, pSendParams);

    //
    // Failure. No packet is attached to irp. The irp is not held in list.
    //
    if (!NT_SUCCESS(rc))
    {
        ASSERT(CIrp2Pkt::SafePeekFirstPacket(irp) == NULL);
        Release();
        ACpRelease(pXact);
        return rc;
    }

    //
    // Packet points to queue/xact, and attached to irp. Irp not held in list.
    // If pending QM processing, hold irp in list.
    //
    ASSERT(!irp_driver_context(irp)->MultiPackets() || !CIrp2Pkt::IsHeld(irp));
    if (rc == STATUS_PENDING)
    {
        g_pCreatePacket->HoldCreatePacketRequest(irp);
        return STATUS_PENDING;
    }

    //
    // Synchronously call the completion handler.
    //
    return HandleCreatePacketCompletedSuccessSync(irp);

} // CQueue::PutNewPacket


bool
CQueue::NeedAsyncCreatePacket(
    CPacketBuffer * ppb,
    bool            fProtocolSrmp
    ) const
{
    //
    // Only target queue needs local send QM processing
    //
    if (!IsTargetQueue())
    {
        return false;
    }

    //
    // Need local send QM processing to generate SRMP properties
    //
    if (fProtocolSrmp)
    {
        return true;
    }

    //
    // No need to authenticate or decrypt the message
    //
    CBaseHeader * pBase = ppb;
    CSecurityHeader * pSec = CPacketBuffer::SecurityHeader(pBase);
    if (pSec == NULL)
    {
        return false;
    }

    //
    // Need local send QM processing to authenticate the message.
    //
    USHORT SignatureSize;
    pSec->GetSignature(&SignatureSize);
    if ((pSec->GetSenderIDType() != MQMSG_SENDERID_TYPE_QM) && (SignatureSize != 0))
    {
        return true;
    }

    //
    // Need local send QM processing to decrypt the message.
    //
    if (pSec->IsEncrypted())
    {
        return true;
    }

    //
    // No need for local send QM processing.
    //
    return false;

} // CQueue::NeedAsyncCreatePacket


NTSTATUS
CQueue::CreatePacket(
    PIRP                      irp,
    CTransaction *            pXact,
    BOOL                      fCheckMachineQuota,
    const CACSendParameters * pSendParams
    )
/*++

Routine Description:

    Create a new packet, possibly asynchronously.

    Algorithm:

    * Mark irp as single packet handler.
    * Synchronously create the packet:
      * By calling CPacket::SyncCreate
      * This will point the packet to this queue and transaction
      * This will attach the packet to the irp
    * If async creation needed, issue request to QM.
      * By calling CPacket::AsyncCreate
    * Failure handling: every routine cleans up after itself in case of failure.

Arguments:

    irp                - The interrupt request packet of the send request.

    pXact              - Pointer to transaction object, may be NULL.

    fCheckMachineQuota - Indicates whether to check machine quota or not.

    pSendParams        - Pointer to send parameters.

Return Value:

    STATUS_SUCCESS - Packet completed successfully and synchronously.

    STATUS_PENDING - Packet creation is pending QM processing.

    failure status - Packet creation failed. There is no packet or the
        packet is attached to irp and completion handler will clean it.

--*/
{
    //
    // Mark irp as single packet handler
    //
    irp_driver_context(irp)->MultiPackets(false);

    //
    // Synchronously create the packet
    //
    bool fProtocolSrmp = file_object_is_protocol_srmp(IoGetCurrentIrpStackLocation(irp)->FileObject);
    NTSTATUS rc;
    CPacket * pPacket;
    rc = CPacket::SyncCreate(
             irp,
             pXact,
             this,                   // Destination queue
             1,                      // nDestinationMqf
             UniqueID(),             // DestinationMqf
             fCheckMachineQuota,
             pSendParams,
             this,                   // Async completion handler
             fProtocolSrmp,
             &pPacket
             );
    if (!NT_SUCCESS(rc))
    {
        ASSERT(pPacket == NULL);
        return rc;
    }

    //
    // Success. Packet points to this queue and transaction. Packet attached to irp.
    //
    ASSERT(pPacket != NULL);
    ASSERT(pPacket->Queue() == this);
    ASSERT(pPacket->Transaction() == pXact);
    ASSERT(CIrp2Pkt::PeekSinglePacket(irp) == pPacket);
    CPacketBuffer * ppb = pPacket->Buffer();
    ASSERT(("buffer should be already mapped into memory!", ppb != NULL));

    if (!NeedAsyncCreatePacket(ppb, fProtocolSrmp))
    {
        return STATUS_SUCCESS;
    }

    //
    // Do async creation. On failure, de-ref packet creation and packet attach to irp.
    //
    rc = pPacket->IssueCreatePacketRequest(fProtocolSrmp);
    if (!NT_SUCCESS(rc))
    {
        CIrp2Pkt::DetachSinglePacket(irp);
        pPacket->Queue(NULL);
        pPacket->Transaction(NULL);
        pPacket->Release();
        pPacket->Release();
        return rc;
    }

    return STATUS_PENDING;

} // CQueue::CreatePacket


VOID
CQueue::HandleCreatePacketCompletedFailureAsync(
    PIRP irp
    )
{
    //
    // Detach packet from irp. Decrement ref count of the attach packet.
    //
    CPacket * pPacket = CIrp2Pkt::DetachSinglePacket(irp);
    pPacket->Release();

    //
    // Extract queue/xact context from packet, and auto-decrement their ref count (undo PutNewPacket).
    //
    ASSERT(pPacket->Queue() == this);
    R<CQueue> pQueue = this;
    R<CTransaction> pXact = pPacket->Transaction();
    pPacket->Queue(NULL);
    pPacket->Transaction(NULL);

    //
    // De-ref packet creation.
    //
    pPacket->Release();

} // CQueue::HandleCreatePacketCompletedFailureAsync


NTSTATUS
CQueue::HandleCreatePacketCompletedSuccessSync(
    PIRP irp
    )
{
    return HandleCreatePacketCompletedSuccessAsync(irp);

} // CQueue::HandleCreatePacketCompletedSuccessSync


NTSTATUS
CQueue::HandleCreatePacketCompletedSuccessAsync(
    PIRP irp
    )
{
    //
    // Detach packet from irp. Decrement ref count of the attach packet.
    //
    CPacket * pPacket = CIrp2Pkt::DetachSinglePacket(irp);
    pPacket->Release();

    //
    // Extract queue/xact context from packet, and auto-decrement their ref count (undo PutNewPacket).
    //
    ASSERT(pPacket->Queue() == this);
    R<CQueue> pQueue = this;
    R<CTransaction> pXact = pPacket->Transaction();
    pPacket->Queue(NULL);
    pPacket->Transaction(NULL);

    HandleValidTransactionUsage(pXact != NULL, pPacket);

    //
    // Put the packet in the transaction. If transaction passed prepare phase,
    // decrement ref count of the packet creation and fail the operation.
    //
    if (pXact != NULL)
    {
        if (pXact->PassedPreparePhase())
        {
            pPacket->Release();
            return MQ_ERROR_TRANSACTION_SEQUENCE;
        }

        pXact->SendPacket(this, pPacket);
        return STATUS_SUCCESS;
    }

    CPacketBuffer * ppb = pPacket->Buffer();
    if (ppb == NULL)
    {
        pPacket->Release();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Put the packet in the queue. On failure rundown the packet.
    //
    NTSTATUS rc = PutPacket(irp, pPacket, ppb);
    if (!NT_SUCCESS(rc) && rc != STATUS_PENDING)
    {
        pPacket->PacketRundown(rc);
    }

    return rc;

} // CQueue::HandleCreatePacketCompletedSuccessAsync


NTSTATUS CQueue::PutPacket(PIRP in_irp, CPacket* pPacket, CPacketBuffer * ppb)
/*++

Routine Description:

    Note: This routine does not call PacketRundown when the call to Store fails
    so it is the responsibility of our caller to call PacketRundown on failure.

Arguments:

    in_irp  - The interrupt request packet. May be NULL.

    pPacket - The packet to put in the queue.

    ppb     - The packet buffer mapped into memory. May be NULL.

Return Value:

    STATUS_SUCCESS - The operation completed successfully and synchronously.

    STATUS_PENDING - The operation is pending storage and will complete asynchronously.

    failure status - The operation failed, caller should call PacketRundown.

--*/
{
    if(pPacket->IsRevoked())
    {
        //
        //  This packet is revoked.
        //  Packet is revoked if it is 'Done', and at that time it was held in the QM
        //  Anyway in the sender view this is a success
        //
        pPacket->HandleRevoked(ppb);
        return STATUS_SUCCESS;
    }

    BOOL fNewPacket = (pPacket->Queue() == 0);
    if(fNewPacket)
    {
        //
        //  First time this packet is put in a queue. The packet is not in a transaction context
        //  and the packet buffer must be attached and mapped into memory.
        //
        ASSERT(pPacket->Transaction() == NULL);
	    ASSERT(ppb != NULL && pPacket->MappedBuffer() == ppb);

        ChargeQuota(ppb->GetPacketSize());

        pPacket->CacheCurrentState(ppb);
        InsertPacket(pPacket);

		if(!pPacket->StorageIssued())
		{
			SetPacketInformation(ppb);
		}

        if(Authenticate())
        {
            //
            //  This is a target queue needs authentication
            //
            CSecurityHeader* pSec = CPacketBuffer::SecurityHeader(ppb);
            if((pSec == 0) || !pSec->IsAuthenticated())
            {
                pPacket->Done(MQMSG_CLASS_NACK_BAD_SIGNATURE, ppb);
                return STATUS_SUCCESS;
            }
        }

        if(PrivLevel() != MQ_PRIV_LEVEL_OPTIONAL)
        {
            //
            //  This is a traget queue forcing privacy level
            //
            CPropertyHeader* pProp = CPacketBuffer::PropertyHeader(ppb);
            if(QueueToMessaePrivLevel(PrivLevel()) !=
                                             pProp->GetPrivBaseLevel())
            {
                pPacket->Done(MQMSG_CLASS_NACK_BAD_ENCRYPTION, ppb);
                return STATUS_SUCCESS;
            }
        }

        if(Deleted())
        {
            //
            //  This queue is deleted.
            //  Delete any newly incomming messages.
            //  Anyway in the sender view this is a success.
            //
            pPacket->Done(MQMSG_CLASS_NACK_BAD_DST_Q, ppb);
            return STATUS_SUCCESS;
        }

        if(QuotaExceeded())
        {
            //
            //  Quota exceeded,
            //
            pPacket->Done(MQMSG_CLASS_NACK_Q_EXCEED_QUOTA, ppb);
            return STATUS_SUCCESS;
        }
    }

    ASSERT(pPacket->Queue() == this);

    if(!pPacket->IsReceived())
    {
        UpdateFirstUnreceivedLookupId(pPacket->LookupId());
    }
    //
    //  Look for pending requests and free matching peeks, and only one receiver.
    //
    //  N.B. The packet MUST be put first in the queue since we might encounter
    //      a peek request or a faulty receive requests.
    //
    //  N.B. The packet is first check that it is not received (ACPutPacket1)
    //      and is used alow to verify that the packet has beed received by the
    //      QM, but not freed.
    //
    PIRP irp;
    while(!pPacket->IsReceived() && ((irp = GetRequest(pPacket)) != 0))
    {
        BOOL fFreePacket = irp_driver_context(irp)->IrpWillFreePacket();
        NTSTATUS rc = pPacket->CompleteRequest(irp);

        //
        //  This irp will free the packet If completed successfully
        //
        if(fFreePacket && NT_SUCCESS(rc))
        {
            //
            //  The packet has been freed, no more processing is requeired for
            //  that packet. The sender can go home and is not detained till
            //  storage complete.
            //
            return STATUS_SUCCESS;
        }
    }

    if(!fNewPacket)
    {
        return STATUS_SUCCESS;
    }

    //
    // Fix for XP client release.
    // Another MMF might have get mapped while completing a requirest with this
    // packet. The cursor was releasing a previous packet while setting its pointer
    // to the current processed packet. This would cause the original MMF to be pulled
    // under the feet of this pointer, making it point to another MMF file, that is
    // random data.
    //
    // RAID #8552 erezh 2001/07/26
    //
    //
    CPacketBuffer * ppb1 = pPacket->Buffer();
    ASSERT(ppb1 != NULL);
    if(ppb1 == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(ppb1 == ppb);
    ppb = ppb1;


    pPacket->StartTimer(ppb, IsTargetQueue(), 0);

    if(
        //
        //  This is a Journal queue or a deadletter queue,
        //  every packet is stored
        //
        Store() ||

        //
        //  This is a Recoverable packet, store that packet
        //
        pPacket->IsRecoverable(ppb)
        )
    {
        //
        //  Trigger packet storage. On failure caller should call PacketRundown.
        //  N.B. in_irp can be 0.
        //
        if(!pPacket->StorageIssued())
        {
            return pPacket->Store(in_irp);
        }
    }

    //
    //  The packet does not require storage, send positive acking if needed.
    //
    pPacket->SendArrivalAcknowledgment();

    return STATUS_SUCCESS;
}


NTSTATUS
CQueue::ProcessRequest(
    PIRP      irp,
    ULONG     ulTimeout,
    CCursor*  pCursor,
    ULONG     ulAction,
    bool      fReceiveByLookupId,
    ULONGLONG LookupId,
    OUT ULONG *pulTag
    )
{
    if(Deleted())
    {
        //
        //  Can't receive from a deleted queue
        //
        return MQ_ERROR_QUEUE_DELETED;
    }

    return Inherited::ProcessRequest(
               irp,
               ulTimeout,
               pCursor,
               ulAction,
               fReceiveByLookupId,
               LookupId,
               pulTag
               );
}

void CQueue::UpdateSeqAckData(LONGLONG liAckSeqID, ULONG ulAckSeqN)
{
    m_liAckSeqID = liAckSeqID;
    m_ulAckSeqN  = ulAckSeqN;
}


NTSTATUS CQueue::IsSequenceOnHold(CPacket *pPacket)
{
    ASSERT(pPacket->IsOrdered());

    CPacketBuffer * ppb = pPacket->Buffer();
    if (ppb == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    CXactHeader* pXact = CPacketBuffer::XactHeader(ppb);
    LONGLONG liSeqID = pXact->GetSeqID();

    //
    // Look for the previous sequence, if it exists
    //

    for(CPacketPool::Iterator p(pPacket); --p != m_packets.rend(); )
    {
        CPacket *pPrev = p;
        if(!pPrev->IsXactLinkable())
        {
            continue;
        }

        ppb = pPrev->Buffer();
        if (ppb == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        CXactHeader* pXactPrev = CPacketBuffer::XactHeader(ppb);

        //
        // Ignore same sequence - we are looking for the previous one
        //
        if (pXactPrev->GetSeqID() == liSeqID)
        {
            continue;
        }

        //
        // Now pointing to a packet from a previous sequence
        //     If it is acked, we are free;
        //     If it is not, we are On Hold

        BOOL rc = !IsPacketAcked(pXactPrev->GetSeqID(), pXactPrev->GetSeqN());
        return (rc ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
    }

    //
    // No hold if found nothing
    //
    return STATUS_UNSUCCESSFUL;
}


CPacket* CQueue::FindPrevOrderedPkt(CPacket *pPacket)
{
    ASSERT(pPacket->IsOrdered());
    ASSERT(pPacket->Queue() == this);

    //
    // Look for the previous ordered packet
    //

    for(CPacketPool::Iterator p(pPacket); --p != m_packets.rend(); )
    {
        CPacket* pPrev = p;
        if(pPrev->IsXactLinkable())
        {
            return pPrev;
        }
    }

    return NULL;
}


NTSTATUS CQueue::RelinkPacket(CPacket *pPacket)
{
    ASSERT(pPacket->Queue() == this);
    ASSERT(pPacket->BufferAttached());

    if(!pPacket->IsXactLinkable() || Silent())
        return STATUS_SUCCESS;

    CBaseHeader * pBase = pPacket->Buffer();
    if (pBase == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    CXactHeader *pXact = CPacketBuffer::XactHeader(pBase);
    ASSERT(pXact);

    //
    // Capture packet information as it is not accessible later on
    //
    LONGLONG liSeqID = pXact->GetSeqID();
    ULONG ulPrevN = pXact->GetPrevSeqN();

    //
    // The packet is already relinked to Zero, nothing to do
    //
    if(ulPrevN == 0)
        return STATUS_SUCCESS;
    //
    // Looking for the previous ordered packet in the queue
    //
    CPacket *pPrev = FindPrevOrderedPkt(pPacket);
    if (!pPrev)
    {
        //
        // We have no ordered packets before this one, so we relink it to 0
        //
        pXact->SetPrevSeqN(0);
        return STATUS_SUCCESS;
    }

    ASSERT(pPrev->IsOrdered());
    pBase = pPrev->Buffer();
    if (pBase == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    CXactHeader *pXactPrev = CPacketBuffer::XactHeader(pBase);
    ASSERT(pXactPrev);

    //
    // Is previous acked?
    //
    if (IsPacketAcked(pXactPrev->GetSeqID(), pXactPrev->GetSeqN()))
    {
        //
        // We have no unacked packets before this one, so we relink it to 0
        //
        pBase = pPacket->Buffer();
        if (pBase == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        pXact = CPacketBuffer::XactHeader(pBase);
        pXact->SetPrevSeqN(0);
        return STATUS_SUCCESS;
    }

    //
    // Is Previous of another sequence?
    //
    if (pXactPrev->GetSeqID() != liSeqID)
    {
        ASSERT(pXactPrev->GetSeqID() < liSeqID);

        //
        // Relink to 0 - nothing in sequence before this packet
        //
        pBase = pPacket->Buffer();
        if (pBase == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        pXact = CPacketBuffer::XactHeader(pBase);
        pXact->SetPrevSeqN(0);
        return STATUS_SUCCESS;
    }

    //
    // Previous is unacked of the same sequence. Does his N differs from PrevN?
    //
    if (pXactPrev->GetSeqN() != ulPrevN)
    {
        ASSERT(pXactPrev->GetSeqID() == liSeqID);
        ULONG ulNewPrevN = pXactPrev->GetSeqN();

        //
        // Relink to it - nothing in the middle can be important anymore
        //
        pBase = pPacket->Buffer();
        if (pBase == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        pXact = CPacketBuffer::XactHeader(pBase);
        pXact->SetPrevSeqN(ulNewPrevN);
    }

    return STATUS_SUCCESS;
}


const CSenderStream& CQueue::SenderStream() const
{
	return m_SenderStream;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\qm.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qm.cxx

Abstract:

    This module implements CQMInterface member functions.

Author:

    Erez Haba (erezh) 22-Aug-95

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "qm.h"
#include "lock.h"
#include "object.h"
#include "packet.h"
#include "acheap.h"
#include "store.h"

#ifndef MQDUMP
#include "qm.tmh"
#endif

static
VOID
ACCancelServiceRequest(
    IN PDEVICE_OBJECT /*pDevice*/,
    IN PIRP irp
    )
{
    ACpRemoveEntryList(&irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(irp->CancelIrql);

    TrTRACE(AC, "ACCancelServiceRequest (irp=0x%p)", irp);

    irp->IoStatus.Information = 0;
    irp->IoStatus.Status = STATUS_CANCELLED;

    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

//---------------------------------------------------------
//
//  class CQMInterface
//
//---------------------------------------------------------


void CQMInterface::CleanupRequests()
{
	//
	// first Cancel the timer so it will not be called when QM is disconnected
	//
	m_Timer.Cancel();

    //
    //  Discard all pending requests. Don't know what to do with
    //  these requests
    //
    CACRequest* pRequest;
    while((pRequest = m_requests.gethead()) != 0)
    {
        switch(pRequest->rf)
        {
            case CACRequest::rfStorage:
                pRequest->Storage.pDriverPacket->Release();
                break;

            case CACRequest::rfCreatePacket:
                pRequest->CreatePacket.pDriverPacket->Release();
                break;

            case CACRequest::rfAck:
                pRequest->Ack.pDriverPacket->Release();
                break;

            case CACRequest::rfTimeout:
                pRequest->Timeout.pDriverPacket->Release();
                break;
        }

        delete pRequest;
    }
}


inline void CQMInterface::HoldRequest(CACRequest* pRequest)
{
    m_requests.insert(pRequest);
}


inline NTSTATUS MapPacketIfNeeded(CACRequest* pRequest)
/*++

Routine Description:

    preper waiting serive request before they get to the QM.

Arguments:

    pRequest
        pointer to the 1st pending CACRequest object

Return Value:

    STATUS_INVALID_PARAMETER - the buffer of the related packet was detached while
    			the request was pending in the list - in this case we complete the
    			request manually
    STATUS_INSUFFICIENT_RESOURCES - there is no memory to do the packet mapping
    			we will return the request to the queue and charge timer to try again
	STATUS_SUCCESS - request is ready to be fired up.
	
--*/
{
	CBaseHeader * pBase;
    switch(pRequest->rf)
    {
        case CACRequest::rfAck:
        	{
	    		CAllocatorBlockOffset abo(pRequest->Ack.ulAllocatorBlockOffset);
	    		ASSERT(abo.IsValidOffset());
	    		if(!abo.IsValidOffset())
	    		{
	    			//
	    			// This code is never reached.
	    			// It is added just to be on the safe side while fixing bug #739107
	    			//
	    			pRequest->Ack.pDriverPacket->AddRefBuffer();
        			ACAckingCompleted(pRequest->Ack.pDriverPacket);
	    			return STATUS_INVALID_PARAMETER;
	    		}
	    		
	    		CMMFAllocator* pAllocator = pRequest->Ack.pDriverPacket->Allocator();
  				pBase = static_cast<CPacketBuffer*>(pAllocator->GetQmAccessibleBuffer(abo));
			    if (pBase == NULL)
			    {
			        return STATUS_INSUFFICIENT_RESOURCES;
			    }
			    pRequest->Ack.pDriverPacket->AddRefBuffer();
			    pRequest->Ack.pPacket = pBase;
				return STATUS_SUCCESS;
        	}

        case CACRequest::rfStorage:
        	if (!pRequest->Storage.pDriverPacket->BufferAttached())
        	{
			    pRequest->Storage.pDriverPacket->AddRefBuffer();
        		ACpCompleteStorage(1, &pRequest->Storage.pDriverPacket, STATUS_SUCCESS);
        		return STATUS_INVALID_PARAMETER;
        	}
		    pBase = AC2QM(pRequest->Storage.pDriverPacket);
		    if (pBase == NULL)
		    {
		        return STATUS_INSUFFICIENT_RESOURCES;
		    }
		    pRequest->Storage.pDriverPacket->AddRefBuffer();
		    pRequest->Storage.pPacket = pBase;
			return STATUS_SUCCESS;

        case CACRequest::rfCreatePacket:
        	//
        	// i do not handle situation that buffer is not attached in this case
        	// becuase it can not happen.
        	//
        	ASSERT(pRequest->CreatePacket.pDriverPacket->BufferAttached());
		    pBase = AC2QM(pRequest->CreatePacket.pDriverPacket);
		    if (pBase == NULL)
		    {
		        return STATUS_INSUFFICIENT_RESOURCES;
		    }
		    pRequest->CreatePacket.pDriverPacket->AddRefBuffer();
		    pRequest->CreatePacket.pPacket = pBase;
			return STATUS_SUCCESS;

        case CACRequest::rfTimeout:
        	if (!pRequest->Timeout.pDriverPacket->BufferAttached())
        	{
			    pRequest->Timeout.pDriverPacket->AddRefBuffer();
        		ACFreePacket1(pRequest->Timeout.pDriverPacket, MQMSG_CLASS_NACK_PURGED);
        		return STATUS_INVALID_PARAMETER;
        	}
		    pBase = AC2QM(pRequest->Timeout.pDriverPacket);
		    if (pBase == NULL)
		    {
		        return STATUS_INSUFFICIENT_RESOURCES;
		    }
		    pRequest->Timeout.pPacket = pBase;
		    pRequest->Timeout.pDriverPacket->AddRefBuffer();
			return STATUS_SUCCESS;

        case CACRequest::rfMessageID:
        case CACRequest::rfRemoteRead:
        case CACRequest::rfRemoteCancelRead:
        case CACRequest::rfRemoteCloseQueue:
        case CACRequest::rfRemoteCreateCursor:
        case CACRequest::rfRemoteCloseCursor:
        case CACRequest::rfRemotePurgeQueue:
        case CACRequest::rfEventLog:
			return STATUS_SUCCESS;

		default:
			ASSERT(0);
			return STATUS_SUCCESS;
    }
}


inline CACRequest* CQMInterface::GetRequest()
/*++

Routine Description:

    get the next available request. 

Arguments:

	None.
	
Return Value:

    CACRequest* - the next valid request to serve.
    			  NULL if there is none.
	
--*/
{
	CACRequest* pRequest;
	while ((pRequest = m_requests.gethead()) != 0)
	{
		NTSTATUS rc = MapPacketIfNeeded(pRequest);
		if (NT_SUCCESS(rc))
		{
			return pRequest;
		}

		if (rc == STATUS_INSUFFICIENT_RESOURCES)
		{
			//
			// Insert the request in the head of the list, so the order of request
			// will not be changed when out of memory
			//
		    m_requests.InsertHead(pRequest);
	        ArmTimer();
	        return NULL;
		}
		if (rc == STATUS_INVALID_PARAMETER)
		{
			delete pRequest;
			continue;
		}
		//
		// We should never be here
		//
		ASSERT(0);
	}
    return NULL;
}


inline void CQMInterface::HoldService(PIRP irp)
{
    KIRQL irql;
    IoAcquireCancelSpinLock(&irql);
    IoMarkIrpPending(irp);
   	m_services.insert(irp);
    if (!irp->Cancel)
    {
	    IoSetCancelRoutine(irp, ACCancelServiceRequest);
	    IoReleaseCancelSpinLock(irql);
	    return;
    }
    irp->CancelIrql = irql;
	ACCancelServiceRequest(NULL, irp);
}


inline PIRP CQMInterface::GetService()
{
    ASL asl;
    PIRP irp = m_services.gethead();
    if(irp)
    {
        IoSetCancelRoutine(irp, 0);
    }
    return irp;
}


//
//  Non member helper function
//
inline void ACpSetIRP(PIRP irp, CACRequest* pRequest)
{
    irp->AssociatedIrp.SystemBuffer = pRequest;
    irp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_INPUT_OPERATION;
    irp->IoStatus.Information = sizeof(*pRequest);
}


NTSTATUS CQMInterface::ProcessService(PIRP irp)
{
    CACRequest* pRequest = GetRequest();

    if(pRequest == NULL)
    {
        //
        // No packet was available, the request is held
        //
        HoldService(irp);
        return STATUS_PENDING;
    }

	TrTRACE(AC, " *CQMInterface::ProcessService(irp=0x%p)*", irp);
    ACpSetIRP(irp, pRequest);
    return STATUS_SUCCESS;
}


NTSTATUS CQMInterface::ProcessRequest(const CACRequest& request)
{
    if(Process() == 0)
    {
        return MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }

	PVOID p = ExAllocatePoolWithTag(PagedPool, sizeof(CACRequest), 'MQQM');

    if(p == 0)
    {
    	TrERROR(AC, "Failed to allocate a CACRequest from paged pool."); 
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    CACRequest* pRequest = new (p) CACRequest(request);
    HoldRequest(pRequest);
	Dispatch();

	return STATUS_SUCCESS;
}


void CQMInterface::Dispatch()
/*++

Routine Description:

    connect between waiting request to waiting QM threads

Arguments:

	None.

Return Value:

	None.

--*/
{
    PIRP irp;
	while ((irp = GetService()) != 0)
	{
		CACRequest* pRequest = GetRequest();
		if (pRequest == NULL)
		{
			HoldService(irp);
			return;
		}

	    TrTRACE(AC, " *CQMInterface::Dispatch(irp=0x%p)*", irp);
	    ACpSetIRP(irp, pRequest);
		irp->IoStatus.Status = STATUS_SUCCESS;
		IoCompleteRequest(irp, IO_MQAC_INCREMENT);
	}    
}


inline void CQMInterface::InternalTimerCallback()
{
    CS lock(g_pLock);
    m_Timer.Busy(0);
    Dispatch();
}


inline void CQMInterface::TimerCallback(PDEVICE_OBJECT, PVOID p)
{
    static_cast<CQMInterface*>(p)->InternalTimerCallback();
}


inline void CQMInterface::ArmTimer()
{
	//
	// arm the timer for 1 second. if it is already armed it will be
	// rearmed with 1 second
	//
	LARGE_INTEGER li;
	li.QuadPart = -10000;
	m_Timer.SetTo(li);
}


bool CQMInterface::InitTimer(PDEVICE_OBJECT pDevice)
{
    //
    // Initialize the timer: Set the timer callback function. The context buffer
    // is the CQMInterface object itself.
    //
    return m_Timer.SetCallback(pDevice, TimerCallback, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\quser.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    quser.h

Abstract:

    CUserQueue definition.

Author:

    Erez Haba (erezh) 13-Aug-95
    Shai Kariv (shaik) 8-May-2000

Revision History:
--*/

#ifndef __QUSER_H
#define __QUSER_H

#include "qbase.h"

//---------------------------------------------------------
//
//  class CUserQueue
//
//---------------------------------------------------------

class CUserQueue : public CQueueBase {

    typedef CQueueBase Inherited;

public:
    //
    //  CUserQueue constructor, handle access, share and queue ID
    //
    CUserQueue(
        PFILE_OBJECT pFile,
        ACCESS_MASK DesiredAccess,
        ULONG ShareAccess,
        const QUEUE_FORMAT* pQueueID
        );

    //
    //  Close that queue
    //
    virtual void Close(PFILE_OBJECT pOwner, BOOL fCloseAll);

    //
    //  Set the queue properties
    //
    virtual NTSTATUS SetProperties(const VOID* properites, ULONG size);

    //
    //  Get the queue properties
    //
    virtual NTSTATUS GetProperties(VOID* properites, ULONG size);

    //
    //  Purge the queue content, and optionally mark it as deleted
    //
    virtual NTSTATUS Purge(BOOL fDelete, USHORT usClass) = 0;

    //
    //  The Queue identifier
    //
    const QUEUE_FORMAT* UniqueID() const;

	//
	//	Check if the queue format is valid
	//
	bool IsValidQueueFormat() const;

    //
    // Get the queue type (public, direct, ...)
    //
    QUEUE_FORMAT_TYPE GetQueueFormatType() const;

    //
    //  Check and update the sharing information
    //
    NTSTATUS CheckShareAccess(PFILE_OBJECT pFile, ULONG access, ULONG share);

    //
    //  This queue can participate in a trnasaction
    //
    BOOL Transactional() const;

    //
    //  This queue can participate in a trnasaction
    //
    void Transactional(BOOL f);

    //
    // Translate queue handle to queue format name
    //
    virtual 
    NTSTATUS 
    HandleToFormatName(
        LPWSTR pwzFormatName, 
        ULONG  BufferLength, 
        PULONG pFormatNameLength
        ) const;

protected:
    //
    //  CUserQueue destructor, dispose of direct ID string
    //
    virtual ~CUserQueue();

    //
    //  Hold a cursor, in the list.
    //
    //  BUGBUG: The cursor should really be held with the FILE_OBJECT, but
    //          in order to put it there in a list, a context memory should
    //          be allocated, and it seems like a waist to allocate it only
    //          for the use of cusrors list. so instade it is held here.
    //          The performance impact is on queue handle closing
    //          all cursors in the list are scaned and those associated with
    //          the FILE_OBJECT are closed.
    //
    void HoldCursor(CCursor* pCursor);

private:
    void UniqueID(const QUEUE_FORMAT* pQueueID);

private:
    //
    //  The cursors
    //
    List<CCursor> m_cursors;

    //
    //  The queue descriptor, a unique identifier
    //
    QUEUE_FORMAT m_QueueID;

    //
    //  Sharing control
    //
    SHARE_ACCESS m_ShareInfo;

public:
    static NTSTATUS Validate(const CUserQueue* pQueue);

private:
    //
    //  Class type debugging section
    //
    CLASS_DEBUG_TYPE();
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

inline
CUserQueue::CUserQueue(
    PFILE_OBJECT pFile,
    ACCESS_MASK DesiredAccess,
    ULONG ShareAccess,
    const QUEUE_FORMAT* pQueueID
    )
{
    UniqueID(pQueueID);
    IoSetShareAccess(DesiredAccess, ShareAccess, pFile, &m_ShareInfo);
}

inline CUserQueue::~CUserQueue()
{
    m_QueueID.DisposeString();
}


inline QUEUE_FORMAT_TYPE CUserQueue::GetQueueFormatType(void) const
{
    return UniqueID()->GetType();
}

inline void CUserQueue::HoldCursor(CCursor* pCursor)
{
    ASSERT(pCursor);
    m_cursors.insert(pCursor);
}

inline const QUEUE_FORMAT* CUserQueue::UniqueID() const
{
    return &m_QueueID;
}

inline NTSTATUS CUserQueue::SetProperties(const VOID* /*pqp*/, ULONG /*ulSize*/)
{
    return STATUS_NOT_IMPLEMENTED;
}


inline NTSTATUS CUserQueue::GetProperties(VOID* /*pqp*/, ULONG /*ulSize*/)
{
    return STATUS_NOT_IMPLEMENTED;
}


inline NTSTATUS CUserQueue::CheckShareAccess(PFILE_OBJECT pFile, ULONG DesiredAccess, ULONG ShareAccess)
{
    return IoCheckShareAccess(
            DesiredAccess,
            ShareAccess,
            pFile,
            &m_ShareInfo,
            TRUE
            );
}

inline NTSTATUS CUserQueue::Validate(const CUserQueue* pUserQueue)
{
    ASSERT(pUserQueue && pUserQueue->isKindOf(Type()));
    return Inherited::Validate(pUserQueue);
}

inline BOOL CUserQueue::Transactional() const
{
    return Flag1();
}

inline void CUserQueue::Transactional(BOOL f)
{
    Flag1(f);
}

#endif // __QUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\qm.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qm.h

Abstract:

    CQMInterface definition

Author:

    Erez Haba (erezh) 22-Aug-95

Revision History:
--*/

#ifndef _QM_H
#define _QM_H

#include <acdef.h>
#include "irplist.h"
#include "timer.h"

//---------------------------------------------------------
//
//  class CQMInterface
//  Falcon AC interface to the QM process
//
//---------------------------------------------------------

class CQMInterface {

public:
// CQMInterface(); No need for zeroing constructor device ext are zeroed
   ~CQMInterface();

    void Connect(PEPROCESS pProcess, PFILE_OBJECT pConnection, const GUID* pID);
    void Disconnect();
    void CleanupRequests();

    PEPROCESS Process() const;
    PFILE_OBJECT Connection() const;
    const GUID* UniqueID() const;

    NTSTATUS ProcessService(PIRP irp);
    NTSTATUS ProcessRequest(const CACRequest& request);

	bool InitTimer(PDEVICE_OBJECT pDevice);

private:
    void UniqueID(const GUID* pGUID);
    void Process(PEPROCESS pEProcess);
    void Connection(PFILE_OBJECT pFileObject);

    void HoldRequest(CACRequest* pRequest);
    CACRequest* GetRequest();

    void HoldService(PIRP irp);
    PIRP GetService();

    static void NTAPI TimerCallback(PDEVICE_OBJECT, PVOID);
   	void InternalTimerCallback();
    void Dispatch();
    void ArmTimer();

private:
    //
    //  QM Process identifier
    //
    PEPROCESS m_process;

    //
    //  QM FILE_OBJECT on connect identifier
    //
    PFILE_OBJECT m_file_object;

    //
    //  QM GUID identifier
    //
    GUID m_guid;

    //
    //  services list
    //
    CIRPList m_services;

    //
    //  new incomming requests. no service was available at the time this
    //  request was posted. the request is waiting till a service is available.
    //
    List<CACRequest> m_requests;

    CTimer m_Timer;

};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

//---------------------------------------------------------
//
// class CQMInterface
//
//---------------------------------------------------------

inline CQMInterface::~CQMInterface()
{
	m_Timer.Cancel();
}


inline void CQMInterface::Connect(PEPROCESS p, PFILE_OBJECT f, const GUID* g)
{
    Process(p);
    Connection(f);
    UniqueID(g);
}


inline void CQMInterface::Disconnect()
{
    Process(0);
    Connection(0);
}


inline PEPROCESS CQMInterface::Process() const
{
    return m_process;
}

inline void CQMInterface::Process(PEPROCESS pEProcess)
{
    m_process = pEProcess;
}

inline PFILE_OBJECT CQMInterface::Connection() const
{
    return m_file_object;
}

inline void CQMInterface::Connection(PFILE_OBJECT pFileObject)
{
    m_file_object = pFileObject;
}

inline const GUID* CQMInterface::UniqueID() const
{
    return &m_guid;
}

inline void CQMInterface::UniqueID(const GUID* pGUID)
{
    m_guid = *pGUID;
}

#endif // _QM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\quser.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    quser.cxx

Abstract:

    Abstruct class CUserQueue members.

Author:

    Erez Haba (erezh) 1-Aug-95
    Shai Kariv (shaik) 8-May-2000

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include <mqformat.h>
#include "quser.h"
#include "acp.h"

#ifndef MQDUMP
#include "quser.tmh"
#endif

//---------------------------------------------------------
//
//  class CUserQueue
//
//---------------------------------------------------------

DEFINE_G_TYPE(CUserQueue);

void CUserQueue::UniqueID(const QUEUE_FORMAT* pQueueID)
{
    ASSERT(m_QueueID.GetType() == QUEUE_FORMAT_TYPE_UNKNOWN);

    if (!ACpDupQueueFormat(*pQueueID, m_QueueID))
    {
        m_QueueID.UnknownID(0);
        return;
    }
}

bool CUserQueue::IsValidQueueFormat() const
{
	return m_QueueID.IsValid();
}

void CUserQueue::Close(PFILE_OBJECT pOwner, BOOL fCloseAll)
{
    Inherited::Close(pOwner, fCloseAll);

    //
    //  Revoke owner cursors
    //
    for(List<CCursor>::Iterator p(m_cursors); p;)
    {
        CCursor* pCursor = p;

        //
        //  N.B. The iterator 'p' is incremented here since pCursor->Close()
        //      removed itself from the list thus invalidating the iterator.
        //
        ++p;

        if(fCloseAll || pCursor->IsOwner(pOwner))
        {
            pCursor->Close();
        }
    }

    //
    //  Remove sharing from queue
    //
    IoRemoveShareAccess(pOwner, &m_ShareInfo);
}


NTSTATUS
CUserQueue::HandleToFormatName(
    LPWSTR pwzFormatName,
    ULONG  BufferLength,
    PULONG pFormatNameLength
    ) const
{
    return MQpQueueFormatToFormatName(
               UniqueID(),
               pwzFormatName,
               BufferLength,
               pFormatNameLength,
               false
               );
} // CUserQueue::HandleToFormatName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\queue.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    queue.h

Abstract:

    CQueue definition. It is the Falcon Queue represination in the
    Access Control layer.

Author:

    Erez Haba (erezh) 13-Aug-95
    Shai Kariv (shaik) 11-Apr-2000

Revision History:

--*/

#ifndef __QUEUE_H
#define __QUEUE_H

#include "quser.h"
#include "acp.h"



//---------------------------------------------------------
//
//  class CQueue
//
//---------------------------------------------------------


class CQueue : public CUserQueue {

    typedef CUserQueue Inherited;

public:
    CQueue(
        PFILE_OBJECT pFile,
        ACCESS_MASK DesiredAccess,
        ULONG ShareAccess,
        BOOL fTargetQueue,
        const GUID* pDestGUID,
        const QUEUE_FORMAT* pQueueID,
        QueueCounters* pQueueCounters,
        LONGLONG liSeqID,
        ULONG ulSeqN,
		const CSenderStream* SenderStream
        );

    //
    //  Can close that queue, (no pending readers)
    //
    virtual NTSTATUS CanClose() const;

    //
    //  Close that queue
    //
    virtual void Close(PFILE_OBJECT pOwner, BOOL fCloseAll);

    //
    //  Process read request
    //
    virtual
    NTSTATUS
    ProcessRequest(
        PIRP,
        ULONG Timeout,
        CCursor*,
        ULONG Action,
        bool  fReceiveByLookupId,
        ULONGLONG LookupId,
        OUT ULONG *pulTag
        );

    //
    //  Set the queue properties
    //
    virtual NTSTATUS SetProperties(const VOID* properites, ULONG size);

    //
    //  Get the queue properties
    //
    virtual NTSTATUS GetProperties(VOID* properites, ULONG size);

    //
    //  Create a cursor
    //
    virtual NTSTATUS CreateCursor(PIRP irp, PFILE_OBJECT pFileObject, PDEVICE_OBJECT pDevice);

    //
    //  Purge the queue content, and optionally mark it as deleted
    //
    virtual NTSTATUS Purge(BOOL fDelete, USHORT usClass);

    //
    //  A packet storage has completed, process it
    //
    void StorageCompleted(CPacket* pPacket, NTSTATUS status);

    //
    // Revoke the packet if the xact status of the operation and queue do not match
    //
    void HandleValidTransactionUsage(BOOL fTransactionalSend, CPacket * pPacket) const;

    //
    // Put new packet in the queue/transaction.
    //
    NTSTATUS PutNewPacket(PIRP, CTransaction*, BOOL, const CACSendParameters*);

    //
    // Completion handlers for async packet creation.
    //
    virtual NTSTATUS HandleCreatePacketCompletedSuccessAsync(PIRP);
    virtual void     HandleCreatePacketCompletedFailureAsync(PIRP);

    //
    //  Put a packet in the queue
    //
    NTSTATUS PutPacket(PIRP irp, CPacket* pPacket, CPacketBuffer * ppb);

    //
    //  Restore a packet into the queue
    //
    NTSTATUS RestorePacket(CPacket* pPacket);

    //
    //  Get the first packet from the queue if available
    //
    virtual CPacket* PeekPacket();

    //
    // Get a packet by its lookup ID
    //
    virtual NTSTATUS PeekPacketByLookupId(ULONG Action, ULONGLONG LookupId, CPacket** ppPacket);

    //
    //  The target journal queue
    //
    CQueue* JournalQueue() const;

    //
    //  Destination QM GUID
    //
    const GUID* QMUniqueID() const;

    //
    //  Connector QM GUID
    //
    const GUID* ConnectorQM() const;

    //
    //  This is the taget queue, a.k.a. local queue
    //
    BOOL IsTargetQueue() const;

    //
    //  All messages to this queue must be authenticated.
    //
    BOOL Authenticate() const;

    //
    //  The privacy level required by this queue.
    //
    ULONG PrivLevel() const;

    //
    //  This queue stores every packet (journal, deadletter)
    //
    BOOL Store() const;

    //
    //  This is a silent queue, i.e., does not timeout messages, does not
    //  ack or nake, and does not send messages to the deadletter queue.
    //  e.g., a journal or deadletter queue.
    //
    BOOL Silent() const;

    //
    //  This queue move to journal dequeued packets (Trarge journal flag)
    //
    BOOL TargetJournaling() const;

    //
    //  This queue sets arrival time of the packet
    //
    BOOL ArrivalTimeUpdate() const;
    void ArrivalTimeUpdate(BOOL);

    //
    //  Configure this queue to be a machine queue.
    //  I.e., deadletter, deadxact, machine journal
    //
    void ConfigureAsMachineQueue(BOOL fTransactional);

    //
    //  The queue base priority;
    //
    LONG BasePriority() const;

    //
    // Set a pointer to the queue's performance counters buffer.
    //
    void PerformanceCounters(QueueCounters* pQueueCounters);

    //
    //  Restore charged quota
    //
    void RestoreQuota(ULONG ulSize);

    //
    // Asks for sequential numbering for the message in this direction
    //
    void AssignSequence(CPacketBuffer * ppb);

    //
    // Corrects SeqID/SeqN based on the values from restored packet
    //
    void CorrectSequence(const CPacket* pPacket, CPacketBuffer * ppb);

    //
    //  Create a journal queue for this queue
    //
    void CreateJournalQueue();

    //
    //  Set packet information when sending
    //
    void SetPacketInformation(CPacketInfo*);

	//
	// Used during transactin processing to find the first and last
	// message to that queue destination
	//
    CPacket* LastPacket(void) const;
    void LastPacket(CPacket*);

    //
    //  Verifies whether the packet belongs to a sequence that cannot be sent
    //  because there are unacked packets in previous sequences
    //
    NTSTATUS IsSequenceOnHold(CPacket* pPacket);

    //
    // Keeps last order acknowledgment information
    //
    void UpdateSeqAckData(LONGLONG liSeqID, ULONG ulSeqN);

    //
    // Last acknowledgment information
    //
    ULONG    LastAckedN()  const;
    LONGLONG LastAckedID() const;

    //
    // Sets packet's PrevN to point to previous actual packet in the queue
    //
    NTSTATUS RelinkPacket(CPacket *pPacket);

    //
    // The GUID of the destination QM
    //
    void QMUniqueID(const GUID* pQMID);

    //
    // Check if async packet creation is needed
    //
    bool NeedAsyncCreatePacket(CPacketBuffer * ppb, bool fProtocolSrmp) const;

	//
	// Return exacly once delivery stream
	//
	const CSenderStream& SenderStream() const;


protected:

    virtual ~CQueue();

private:
    BOOL Deleted() const;
    void Deleted(BOOL);

    ULONG Quota() const;
    void Quota(ULONG);
    BOOL QuotaExceeded() const;
    void ChargeQuota(ULONG ulSize);

    void BasePriority(LONG);
    void TargetJournaling(BOOL);
    void IsTargetQueue(BOOL);
    void Authenticate(BOOL);
    void PrivLevel(ULONG);
    void Store(BOOL);
    void Silent(BOOL);

    void ConnectorQM(const GUID* pQMID);

    BOOL SequenceCorrected() const;
    void SequenceCorrected(BOOL);

    BOOL IsPacketAcked(LONGLONG liSeqID, ULONG ulSeq);
    //
    // Finds previous ordered packet in the queue
    //
    CPacket *FindPrevOrderedPkt(CPacket *pPacket);

    //
    // Get next packet by its lookup ID
    //
    CPacket * PeekNextPacketByLookupId(ULONGLONG LookupId) const;

    //
    // Get previous packet by its lookup ID
    //
    CPacket * PeekPrevPacketByLookupId(ULONGLONG LookupId) const;

    //
    // Get current packet by its lookup ID
    //
    CPacket * PeekCurrentPacketByLookupId(ULONGLONG LookupId) const;

    //
    // Completion handler for sync packet creation
    //
    virtual NTSTATUS HandleCreatePacketCompletedSuccessSync(PIRP);

    //
    // Create a new packet, possibly asynchronously.
    //
    virtual NTSTATUS CreatePacket(PIRP, CTransaction*, BOOL, const CACSendParameters*);

    //
    // Insert a packet into the queue
    //
    void InsertPacket(CPacket * pPacket);

    //
    // Update LookupId of first unreceived packet (for optimization of PeekPacket)
    //
    void UpdateFirstUnreceivedLookupId(ULONGLONG LookupId);

public:
     //
    // Remove a packet from the queue
    //
    void RemovePacket(CPacket * pPacket);

private:

    //
    //  The target journal queue.
    //
    CQueue* m_pJournalQueue;

    //
    //  The queue entries, i.e., queued packtes
    //
    CPacketPool m_packets;

    union {
        ULONG m_ulFlags;
        struct {
            ULONG m_bfTargetQueue   : 1;    //  The queue it the targe queue
            ULONG m_bfDeleted       : 1;    //  Queue was deleted
            ULONG m_bfStore         : 1;    //  Store ALL arrival packets (journal, deadletter)
            ULONG m_bfArrivalTime   : 1;    //  Set packet arrival time
            ULONG m_bfJournal       : 1;    //  This is a target journaling queue
            ULONG m_bfSilent        : 1;    //  This is a silent queue
            ULONG m_bfSeqCorrected  : 1;    //  Sequence has been corrected at least once
            ULONG m_bfXactForeign   : 1;    //  transactional foreign queue
            ULONG m_bfAuthenticate  : 1;    //  The queue requires authentication
        };
    };

    //
    //  The queue quota, and used quota
    //
    ULONGLONG m_quota;
    ULONGLONG m_quota_used;

    //
    //  Message count int the queue
    //
    ULONG m_count;

    //
    //  The Queue base priority
    //
    LONG m_base_priority;

    //
    //  The destination QM guid
    //
    GUID m_gQMID;

    //
    // The Connector QM GUID
    //
    GUID m_gConnectorQM;

    //
    //  A pointer to a the queue performance counters structure.
    //
    QueueCounters* m_pQueueCounters;

    //
    // The privacy level that the queue requires.
    //
    ULONG m_ulPrivLevel;

    //
    //  Exactly-once-delivery numbering: Sequence ID and Sequence number
    //
    ULONG m_ulPrevN;
    ULONG m_ulSeqN;
    LONGLONG m_liSeqID;
	CSenderStream m_SenderStream;

    //
    //  Exactly-once-delivery numbering: Last Acked  Sequence ID and Sequence number
    //
    ULONG m_ulAckSeqN;
    LONGLONG m_liAckSeqID;

    //
    //  Transaction boundary support: used in CTransaction::PrepareDefaultCommit
    //
    CPacket* m_pLastPacket;

    //
    // LookupId of first unreceived packet (used for optimization of PeekPacket)
    //
    ULONGLONG m_FirstUnreceivedLookupId;

public:
    static NTSTATUS Validate(const CQueue* pQueue);

private:
    //
    //  Class type debugging section
    //
    CLASS_DEBUG_TYPE();
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

inline
CQueue::CQueue(
    PFILE_OBJECT pFile,
    ACCESS_MASK DesiredAccess,
    ULONG ShareAccess,
    BOOL fTargetQueue,
    const GUID* pDestGUID,
    const QUEUE_FORMAT* pQueueID,
    QueueCounters* pQueueCounters,
    LONGLONG liSeqID,
    ULONG ulSeqN,
	const CSenderStream* SenderStream
    ) :
    Inherited(pFile, DesiredAccess, ShareAccess, pQueueID),
    m_ulFlags(0),
    m_pJournalQueue(0),
    m_liSeqID(liSeqID),
    m_ulSeqN(ulSeqN),
    m_liAckSeqID(0),
    m_ulAckSeqN(0),
    m_ulPrevN(0),
    m_quota(ULONGLONG_INFINITE),
    m_quota_used(0),
    m_count(0),
    m_base_priority(DEFAULT_Q_BASEPRIORITY),
    m_pLastPacket(0),
    m_FirstUnreceivedLookupId(0)
{
	if(SenderStream != NULL)
	{
		m_SenderStream = *SenderStream;
	}

    IsTargetQueue(fTargetQueue);
    ArrivalTimeUpdate(fTargetQueue);
    PrivLevel(MQ_PRIV_LEVEL_OPTIONAL);
    QMUniqueID(pDestGUID);
    PerformanceCounters(pQueueCounters);
    if(fTargetQueue)
    {
        CreateJournalQueue();
    }
}

inline CQueue::~CQueue()
{
    ACpRelease(JournalQueue());
}

inline CQueue* CQueue::JournalQueue() const
{
    return m_pJournalQueue;
}

inline BOOL CQueue::IsTargetQueue() const
{
    return m_bfTargetQueue;
}

inline void CQueue::IsTargetQueue(BOOL f)
{
    m_bfTargetQueue = f;
}

inline BOOL CQueue::Authenticate() const
{
    return m_bfAuthenticate;
}

inline void CQueue::Authenticate(BOOL f)
{
    m_bfAuthenticate = f;
}

inline ULONG CQueue::PrivLevel() const
{
    return m_ulPrivLevel;
}

inline void CQueue::PrivLevel(ULONG ulPrivLevel)
{
    m_ulPrivLevel = ulPrivLevel;
}

inline BOOL CQueue::Store() const
{
    return m_bfStore;
}

inline void CQueue::Store(BOOL f)
{
    m_bfStore = f;
}

inline BOOL CQueue::TargetJournaling() const
{
    return m_bfJournal;
}

inline void CQueue::TargetJournaling(BOOL f)
{
    m_bfJournal = f;
}

inline BOOL CQueue::ArrivalTimeUpdate() const
{
    return m_bfArrivalTime;
}

inline void CQueue::ArrivalTimeUpdate(BOOL f)
{
    m_bfArrivalTime = f;
}

inline BOOL CQueue::SequenceCorrected() const
{
    return m_bfSeqCorrected;
}

inline void CQueue::SequenceCorrected(BOOL f)
{
    m_bfSeqCorrected = f;
}

inline BOOL CQueue::Silent() const
{
    return m_bfSilent;
}

inline void CQueue::Silent(BOOL f)
{
    m_bfSilent = f;
}

inline void CQueue::ConfigureAsMachineQueue(BOOL fTransactional)
{
    Store(TRUE);
    Silent(TRUE);
    Transactional(fTransactional);
    ArrivalTimeUpdate(TRUE);
}

inline void CQueue::QMUniqueID(const GUID* pDestQMID)
{
    //
    // Distribution queue object does not have a destination QM guid
    //
    if (pDestQMID != NULL)
    {
        m_gQMID = *pDestQMID;
    }
}

inline const GUID* CQueue::QMUniqueID() const
{
    return &m_gQMID;
}

inline void CQueue::ConnectorQM(const GUID* pConnectorQM)
{
    if(pConnectorQM)
    {
        ASSERT(Transactional() || UnknownQueueType());
        m_bfXactForeign = TRUE;
        m_gConnectorQM = *pConnectorQM;
    }
    else
    {
        m_bfXactForeign = FALSE;
    }
}

inline const GUID* CQueue::ConnectorQM() const
{
    return ((m_bfXactForeign) ? &m_gConnectorQM: 0);
}

inline BOOL CQueue::Deleted() const
{
    return m_bfDeleted;
}

inline void CQueue::Deleted(BOOL f)
{
    m_bfDeleted = f;
}

inline ULONG CQueue::Quota() const
{
    return BYTE2QUOTA(m_quota);
}

inline void CQueue::Quota(ULONG ulQuota)
{
    m_quota = QUOTA2BYTE(ulQuota);
}

inline LONG CQueue::BasePriority() const
{
    return m_base_priority;
}

inline void CQueue::BasePriority(LONG lBasePriority)
{
    m_base_priority = lBasePriority;
}

inline ULONG CQueue::LastAckedN() const
{
    return m_ulAckSeqN;
}

inline LONGLONG CQueue::LastAckedID() const
{
    return m_liAckSeqID;
}

inline NTSTATUS CQueue::SetProperties(const VOID* p, ULONG size)
{
    UNREFERENCED_PARAMETER(size);
    ASSERT(size == sizeof(CACSetQueueProperties));
    const CACSetQueueProperties* pqp = static_cast<const CACSetQueueProperties*>(p);

    Transactional(pqp->fTransactional);
    UnknownQueueType(pqp->fUnknownType);
    BasePriority(pqp->lBasePriority);
    ConnectorQM(pqp->pgConnectorQM);

    //
    //  Setting other properties to non local queue has no effect
    //
    if(JournalQueue() != 0)
    {
        TargetJournaling(pqp->fJournalQueue);
        Quota(pqp->ulQuota);
        Authenticate(pqp->fAuthenticate);
        PrivLevel(pqp->ulPrivLevel);
        JournalQueue()->Quota(pqp->ulJournalQuota);
    }
    return STATUS_SUCCESS;
}


inline NTSTATUS CQueue::GetProperties(VOID* p, ULONG size)
{
    UNREFERENCED_PARAMETER(size);
    ASSERT(size == sizeof(CACGetQueueProperties));
    CACGetQueueProperties* pqp = static_cast<CACGetQueueProperties*>(p);

    pqp->ulCount = m_count;
    pqp->ulQuotaUsed = ULONGLONG2ULONG(m_quota_used);
    pqp->ulPrevNo = m_ulPrevN;
    pqp->ulSeqNo = m_ulSeqN + 1;
    pqp->liSeqID = m_liSeqID;

    CQueue* pJournal = JournalQueue();
    if(pJournal != 0)
    {
        pqp->ulJournalCount = pJournal->m_count;
        pqp->ulJournalQuotaUsed = ULONGLONG2ULONG(pJournal->m_quota_used);
    }
    else
    {
        pqp->ulJournalCount = 0;
        pqp->ulJournalQuotaUsed = 0;
    }

    return STATUS_SUCCESS;
}

inline void CQueue::PerformanceCounters(QueueCounters* pqc)
{
    m_pQueueCounters = pqc;
}

inline NTSTATUS CQueue::Validate(const CQueue* pQueue)
{
    ASSERT(pQueue && pQueue->isKindOf(Type()));
    return Inherited::Validate(pQueue);
}

inline CPacket * CQueue::LastPacket(void) const
{
    return m_pLastPacket;
}

inline void CQueue::LastPacket(CPacket *pLastPacket)
{
    m_pLastPacket = pLastPacket;
}

inline BOOL CQueue::IsPacketAcked(LONGLONG liSeqID, ULONG ulSeq)
{
    return (liSeqID <  m_liAckSeqID ||
            liSeqID == m_liAckSeqID && ulSeq <= m_ulAckSeqN);
}

NTSTATUS
ACpSetPerformanceBuffer(
    HANDLE hPerformanceSection,
    PVOID pvQMPerformanceBuffer =NULL,
    QueueCounters *pDeadLetterCounters =NULL,
    QmCounters *pQmCounters =NULL
    );

#endif // __QUEUE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\qxact.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qxact.h

Abstract:

    Transaction queue definition.
    Transaction queue holds send and received packets during a transaciton.

Author:

    Erez Haba (erezh) 27-Nov-96

Revision History:
--*/

#ifndef __QXACT_H
#define __QXACT_H

#include "qbase.h"

//---------------------------------------------------------
//
//  class CTransaction
//
//---------------------------------------------------------

class CTransaction : public CQueueBase {

    typedef CQueueBase Inherited;

public:
    //
    //  Transaction constructor. Create a transaction and insert it to the list
    //  
    CTransaction(const XACTUOW* pUow);

    //
    //  Close the transaction
    //
    virtual void Close(PFILE_OBJECT pOwner, BOOL fCloseAll);

    //
    //  Sending a packet withing a transaction
    //
    void SendPacket(CQueue* pQueue, CPacket* pPacket);

    //
    //  Handle transactionl packets restoration, Send & Received packets
    //
    NTSTATUS RestorePacket(CQueue* pQueue, CPacket* pPacket);

    //
    //  Process a packet that is being received to be included in this xact
    //
    NTSTATUS ProcessReceivedPacket(CPacket* pPacket);

    //
    //  First commit phase is Prepare phase.
    //
    NTSTATUS Prepare(PIRP irp);
    NTSTATUS PrepareDefaultCommit(PIRP irp);

    //
    //  Commit this transaction
    //
    NTSTATUS Commit1(PIRP irp);
    NTSTATUS Commit2(PIRP irp);
	NTSTATUS Commit3();

    //
    //  Abort this transaction
    //
    NTSTATUS Abort1(PIRP irp);
	NTSTATUS Abort2();

    //
    //  A packet storage has completed, successfully or not
    //
    void PacketStoreCompleted(NTSTATUS rc);

    //
    // Get transaction information
    //
    void GetInformation(CACXactInformation *pInfo);

    //
    // The transaction passed the prepare phase. We use the transactional flag to mark that.
    //
    BOOL PassedPreparePhase() const { return Flag1(); }

    //
    // Add a read request IRP to the pending readers list
    //
    void HoldReader(PIRP irp);

public:
    //
    // Finds a transaction by UOW
    //
    static CTransaction* Find(const XACTUOW *pUow);

protected:
    virtual ~CTransaction();

private:
    NTSTATUS GetPacketTimeouts(ULONG& rTTQ, ULONG& rTTLD);

    void PassedPreparePhase(BOOL fPassed) { Flag1(fPassed); }

    void CompletePendingReaders();

private:
    //
    //  Packets in transaction
    //
    List<CPacket> m_packets;
	ULONG m_nReceives;
	ULONG m_nSends;

    //
    //  All pending readers for this transaction
    //
    CIRPList1 m_readers;

    //
    //  The Unit of Work associated with this transaction
    //
    XACTUOW m_uow;

    //
    // Counter of currect Store operations for this trnsaction
    //
    ULONG m_nStores;

	//
	// Final phase result (Commit, Prepare, Abort)
	//
	NTSTATUS m_StoreRC;

public:
    static NTSTATUS Validate(const CTransaction* pXact);

private:
    //
    //  Class type debugging section
    //
    CLASS_DEBUG_TYPE();
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

inline CTransaction::CTransaction(const XACTUOW* pUow) :
    m_nStores(0),
    m_uow(*pUow)
{
    ASSERT(Find(pUow) == 0);
    g_pTransactions->insert(this);
	m_nReceives = 0;
	m_nSends = 0;
}

inline CTransaction::~CTransaction()
{
    g_pTransactions->remove(this);
}

inline NTSTATUS CTransaction::Validate(const CTransaction* pXact)
{
    ASSERT(pXact && pXact->isKindOf(Type()));
    return Inherited::Validate(pXact);
}

#endif // __QXACT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\qxact.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qxact.cxx

Abstract:

    Transaction queue implementation.

Author:

    Erez Haba (erezh) 27-Nov-96

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "queue.h"
#include "qxact.h"

#ifndef MQDUMP
#include "qxact.tmh"
#endif

//---------------------------------------------------------
//
//  XACTUOW operators
//
//---------------------------------------------------------

inline BOOL operator ==(const XACTUOW& uow1, const XACTUOW& uow2)
{
    return (RtlCompareMemory((void*)&uow1, (void*)&uow2, sizeof(XACTUOW)) == sizeof(XACTUOW));
}


//---------------------------------------------------------
//
//  Transaction cancel routine
//
//---------------------------------------------------------

static
VOID
ACCancelXactControl(
    IN PDEVICE_OBJECT /*pDevice*/,
    IN PIRP irp
    )
{
    ACpRemoveEntryList(&irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(irp->CancelIrql);

    TrTRACE(AC, "ACCancelXactControl (irp=0x%p)", irp);

    //
    //  The status is not set here, it is set by the caller, when the irp is
    //  held in a list it status is set to STATUS_CANCELLED.
    //
    //irp->IoStatus.Status = STATUS_CANCELLED;
    irp->IoStatus.Information = 0;

    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

//---------------------------------------------------------
//
//  class CTransaction
//
//---------------------------------------------------------

DEFINE_G_TYPE(CTransaction);

CTransaction* CTransaction::Find(const XACTUOW *pUow)
{
    //
    //  Look for an active trnasaction in the trnasactions list
    //

    for(List<CTransaction>::Iterator p(*g_pTransactions); p; ++p)
    {
        CTransaction* pXact = p;
        if(
            //
            //  This transaction has not passed the prepare phase yet
            //
            !pXact->PassedPreparePhase() &&

            //
            //  and the unit of work match
            //
            (pXact->m_uow == *pUow))
        {
            return pXact;
        }
    }

    return 0;
}

void CTransaction::Close(PFILE_OBJECT pOwner, BOOL fCloseAll)
{
    ASSERT(fCloseAll == TRUE);
    Inherited::Close(pOwner, fCloseAll);


    CPacket* pPacket;
    while((pPacket = m_packets.gethead()) != 0)
    {
        if(pPacket->IsXactSend())
        {
            pPacket->TargetQueue(0);
        }
        else
        {
            CPacket* pOther = pPacket->OtherPacket();
            pOther->AddRef();

            pOther->OtherPacket(0);
            pPacket->OtherPacket(0);
            
            pOther->Release();
        }
        
        pPacket->Transaction(0);
        pPacket->QueueRundown();
    } 

    CompletePendingReaders();
}

void CTransaction::SendPacket(CQueue* pQueue, CPacket* pPacket)
{
    pPacket->TargetQueue(pQueue);
    pPacket->Transaction(this);
    pPacket->IsReceived(TRUE);
    m_packets.insert(pPacket);
	m_nSends++;
}

NTSTATUS CTransaction::ProcessReceivedPacket(CPacket* pPacket)
{
    //
    // create dummy CPacket pointing to same buffer
    //
    CPacket* pDummy = pPacket->CreateXactDummy(this);
    if(pDummy == 0)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    m_packets.insert(pDummy);
	m_nReceives++;
    return STATUS_SUCCESS;
}

NTSTATUS CTransaction::RestorePacket(CQueue* pQueue, CPacket* pPacket)
{
    CPacketInfo * ppi = pPacket->Buffer();
    if (ppi == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if(ppi->TransactSend())
    {
        SendPacket(pQueue, pPacket);
        return STATUS_SUCCESS;
    }

    //
    //  This is a received packet, we should really put it in its queue first
    //  and the process the receive
    //
    NTSTATUS rc;
    rc = pQueue->RestorePacket(pPacket);
    ASSERT(NT_SUCCESS(rc));
	return ProcessReceivedPacket(pPacket);
}

inline NTSTATUS CTransaction::GetPacketTimeouts(ULONG& rTTQ, ULONG& rTTLD)
{
    //
    //  Get time-out information from first send packet
    //
    for(List<CPacket>::Iterator p(m_packets); p; ++p)
    {
        CPacket* pPacket = p;
        if(pPacket->IsXactSend())
        {
            CBaseHeader* pBase = pPacket->Buffer();
            if (pBase == NULL)
            {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            CUserHeader* pUser = CPacketBuffer::UserHeader(pBase);

            rTTQ = pBase->GetAbsoluteTimeToQueue();
            rTTLD = pUser->GetTimeToLiveDelta();
            return STATUS_SUCCESS;
        }
    }

    rTTQ = INFINITE;
    rTTLD = INFINITE;
    return STATUS_SUCCESS;
}

NTSTATUS CTransaction::Prepare(PIRP irp)
{
    ULONG ulTTQ;
    ULONG ulTTLD;
    NTSTATUS rc = GetPacketTimeouts(ulTTQ, ulTTLD);
    if (!NT_SUCCESS(rc))
    {
        return rc;
    }

    ASSERT(m_nStores == 0);
	m_StoreRC = STATUS_SUCCESS;

    //
    //  Mark xact as passed prepare phase, it will not be found in Find.
    //
    PassedPreparePhase(TRUE);
    CompletePendingReaders();

    for(List<CPacket>::Iterator p(m_packets); p; ++p)
    {
        CPacket* pPacket = p;
        CPacketBuffer* ppb = pPacket->Buffer();
        if (ppb == NULL)
        {
            m_StoreRC = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        //  Set basic xact information
        //
        CPacketInfo* ppi = ppb;
        ppi->Uow(&m_uow);
        ppi->InTransaction(TRUE);
        ppi->TransactSend(pPacket->IsXactSend());

        if(pPacket->IsXactSend())
        {
            CBaseHeader* pBase = ppb;
            CUserHeader* pUser = CPacketBuffer::UserHeader(pBase);

            //
            //  Set timeout values to send packets
            //
            pBase->SetAbsoluteTimeToQueue(ulTTQ);
            pUser->SetTimeToLiveDelta(ulTTLD);
        }

        //
        //  issue storage request
        //
        if(pPacket->Allocator()->IsPersistent())
        {
            //
            //  Issue storage request for this packet.
            //
            //  N.B. Storage for received packet is issued using the dummy
            //      packet. Thus even though storage can be active for the
            //      original packet the new storage request will not conflict
            //      with it, it is issed with different cookie.
            //
            pPacket->StorageIssued(FALSE);
            pPacket->StorageCompleted(FALSE);

            PIRP tempIrp = NULL;
            rc = pPacket->Store(tempIrp);
            if(!NT_SUCCESS(rc))
            {
				m_StoreRC = rc;
				break;
			}
	        m_nStores++;
        }
    }

    if(m_nStores == 0)
    {
        //
        //  no stores in this xact, return immidiatly
        //
        return m_StoreRC;
    }

    //
    //  Hold the prepare request
    //
    new (irp_driver_context(irp)) CDriverContext(true);
    return HoldRequest(irp, INFINITE, ACCancelXactControl);
}

NTSTATUS CTransaction::PrepareDefaultCommit(PIRP irp)
{
    ULONG ulTTQ;
    ULONG ulTTLD;
    NTSTATUS rc = GetPacketTimeouts(ulTTQ, ulTTLD);
    if (!NT_SUCCESS(rc))
    {
        return rc;
    }

    ASSERT(m_nStores == 0);
	m_StoreRC = STATUS_SUCCESS;

    //
    //  Mark xact as passed prepare phase, it will not be found in Find.
    //
    PassedPreparePhase(TRUE);
    CompletePendingReaders();

	//
	// Get next transaction index
	//
    ULONG ulXactIndex = static_cast<ULONG>(g_MessageSequentialID & 0xFFFFFFFF);

    //
    // First pass on messages: set message properties
    //
    for(List<CPacket>::Iterator p(m_packets); p; ++p)
    {
		CPacket* pPacket = p;
		CPacketBuffer* ppb = pPacket->Buffer();
        if (ppb == NULL)
        {
            m_StoreRC = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        //  Set basic xact information
        //
        CPacketInfo* ppi = ppb;
        ppi->Uow(&m_uow);
        ppi->TransactSend(pPacket->IsXactSend());

        if(!pPacket->IsXactSend())
        {
			continue;
		}

		ppi->SequentialID(ACpGetSequentialID());

		//
	    //  Set Sequence numbers into packet, update queue information before storage
		//
		CQueue* pQueue = pPacket->TargetQueue();
		pQueue->AssignSequence(ppb);
		pQueue->SetPacketInformation(ppi);

        CBaseHeader* pBase = ppb;
        CUserHeader* pUser = CPacketBuffer::UserHeader(pBase);
        CXactHeader* pXact = CPacketBuffer::XactHeader(pBase);

        //
        //  Set timeout values to send packets
        //
        pBase->SetAbsoluteTimeToQueue(ulTTQ);
        pUser->SetTimeToLiveDelta(ulTTLD);

        //
        // Set transaction index 
        //
        pXact->SetXactIndex(ulXactIndex);

        if (pQueue->LastPacket() == 0)
        {
            //
            // This is the first message designated to this queue, mark it as so.
            //
            pXact->SetFirstInXact(TRUE);
        }

        //
        // Till now, this is the last message to this queue.
        //
        pQueue->LastPacket(pPacket);
    }


	//
    // Second pass over messages: issue storage requrests
	//
    List<CPacket>::Iterator p1(m_packets);
    if (m_StoreRC == STATUS_SUCCESS)
    {
        for(; p1; ++p1)
        {
		    CPacket* pPacket = p1;

            if(pPacket->IsXactSend()) 
            {
        	    CQueue* pQueue = pPacket->TargetQueue();

                //
                // Mark last packets for each queue
                //
                if(pPacket == pQueue->LastPacket())
                {
                    CBaseHeader* pBase = pPacket->Buffer();
                    if (pBase == NULL)
                    {
                        m_StoreRC = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    CXactHeader* pXact = CPacketBuffer::XactHeader(pBase);
                    pXact->SetLastInXact(TRUE);
                    pQueue->LastPacket(0);
                }
            }

            //
            //  issue storage request
            //
            if(pPacket->Allocator()->IsPersistent())
            {
                //
                //  Issue storage request for this packet.
                //
                //  N.B. Storage for received packet is issued using the dummy
                //      packet. Thus even though storage can be active for the
                //      original packet the new storage request will not conflict
                //      with it, it is issed with different cookie.
                //
                pPacket->StorageIssued(FALSE);
                pPacket->StorageCompleted(FALSE);

                PIRP tempIrp = NULL;
                rc = pPacket->Store(tempIrp);
                if(!NT_SUCCESS(rc))
                {
				    m_StoreRC = rc;
				    break;
                }

                m_nStores++;
            }
        }
    }

	//
	// If we failed during store, continue and unmake last packet for all queues
	//
    for(; p1; ++p1)
    {
		CPacket* pPacket = p1;

        if(pPacket->IsXactSend()) 
        {
        	CQueue* pQueue = pPacket->TargetQueue();
            pQueue->LastPacket(0);
        }
	}


    if(m_nStores == 0)
    {
        //
        //  no stores in this xact, return immidiatly
        //
        return m_StoreRC;
    }

    //
    //  Hold the prepare request
    //
    new (irp_driver_context(irp)) CDriverContext(true);
    return HoldRequest(irp, INFINITE, ACCancelXactControl);
}

NTSTATUS CTransaction::Commit1(PIRP irp)
{
    //
    //  At this commit phase, all send packets are stored again to mark that
    //  the packet is not in the transaction any more.
    //  The sequence number for order & exactly onece are assigned.
    //
	TrTRACE(AC, "CTransaction::Commit1 (irp=0x%p)", irp);

    ASSERT(m_nStores == 0);
	m_StoreRC = STATUS_SUCCESS;

    //
    //  Mark xact as passed prepare phase, it will not be found in Find.
    //
    PassedPreparePhase(TRUE);
    CompletePendingReaders();

    for(List<CPacket>::Iterator p(m_packets); p; ++p)
    {
        CPacket* pPacket = p;
        if(!pPacket->IsXactSend())
        {
            continue;
        }

        //
        //  Set non xact anymore. re-set the sequential ID of the packet
        //  so it will be returned to the right place in the queue.
        //
        CPacketBuffer *ppb = pPacket->Buffer();
        if (ppb == NULL)
        {
            m_StoreRC = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        CPacketInfo* ppi = ppb;
        ppi->InTransaction(FALSE);
        ppi->SequentialID(ACpGetSequentialID());

        //
        //  Set Sequence numbers into packet, update queue information before storage
        //
        CQueue* pQueue = pPacket->TargetQueue();
        pQueue->AssignSequence(ppb);
        pQueue->SetPacketInformation(ppi);

        ASSERT(pPacket->IsRecoverable(ppb));
        ASSERT(pPacket->StorageIssued());

        //
        //  Issue SECOND storage request for this packet.
        //
        pPacket->StorageIssued(FALSE);
		pPacket->StorageCompleted(FALSE);
        NTSTATUS rc;
        PIRP tempIrp = NULL;
        rc = pPacket->Store(tempIrp);
        if(!NT_SUCCESS(rc))
        {
			m_StoreRC = rc;
            break;
        }

        m_nStores++;
    }

    if(m_nStores == 0)
    {
        //
        //  no stores in this xact, return immidiatly
        //
        return m_StoreRC;
    }

    //
    //  Hold the commit request
    //
    new (irp_driver_context(irp)) CDriverContext(true);
    return HoldRequest(irp, INFINITE, ACCancelXactControl);
}

NTSTATUS CTransaction::Commit2(PIRP irp)
{
    //
    //  At this commit phase, all recieved packets are deleted
    //

    ASSERT(m_nStores == 0);
	m_StoreRC = STATUS_SUCCESS;

    //
    //  Mark xact as passed prepare phase, it will not be found in Find.
    //
    PassedPreparePhase(TRUE);
    CompletePendingReaders();

    for(List<CPacket>::Iterator p(m_packets); p; ++p)
    {
        CPacket* pPacket = p;
        if(pPacket->IsXactSend())
        {
            continue;
        }
		 
        CPacketBuffer * ppb = pPacket->Buffer();
        if (ppb == NULL)
        {
            m_StoreRC = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ASSERT(pPacket->StorageIssued());
        ASSERT(pPacket->IsRecoverable(ppb));

        if (!pPacket->DeleteStorageIssued())
        {
            NTSTATUS rc;
    		rc = pPacket->DeleteStorage();
	    	if(!NT_SUCCESS(rc))
		    {
			    m_StoreRC = rc;
    			break;
	    	}
	    	    
	        m_nStores++;
        }
    }

    if(m_nStores == 0)
    {
        //
        //  no stores in this xact, return immidiatly
        //
        return m_StoreRC;
    }

    //
    //  Hold the commit request
    //
    new (irp_driver_context(irp)) CDriverContext(true);
    return HoldRequest(irp, INFINITE, ACCancelXactControl);
}

NTSTATUS CTransaction::Commit3()
{
    //
    // Commit3 should be never called if Commit2 had failed
    //
    ASSERT(NT_SUCCESS(m_StoreRC));
    
    //
    //  At this phase send packets are put in their queue
    //  Recevied packet are discarded.
    //

    CompletePendingReaders();

    //
    //  ISSUE-2000/12/20-shaik Consider breaking the PutPacket's into 2 loops for better consistency on failure.
    //
    CPacket * pPacket;
    while((pPacket = m_packets.peekhead()) != 0)
    {
        CPacketBuffer * ppb = pPacket->Buffer();
        if (ppb == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        m_packets.gethead();

        if(pPacket->IsXactSend())
        {
            ASSERT(pPacket->StorageIssued());

            //
            //  Put the sent packet in the target queue.
            //
            //  N.B. We have a ref count on that queue so it is still alive.
            //
            //  N.B. The queue is forcibly closed only in the QM rundown.
            //      So we should *not* really be here when this happens.
            //
            //  N.B. The queue is not closed by the QM after Delete since the
            //      the queue ref count is not zero. So if this queue is
            //      deleted the queue will handle the packet.
            //
            //  N.B. Put the packet in received state first so application
            //      can not receive and abort this packet, this will not start
            //      the packet timer and correct acknowledgment. The
            //      application is allowed to receive the packet only after
            //      the second PutPacket.
            //
            CQueue* pQueue = pPacket->TargetQueue();
            ASSERT(!pQueue->Closed());
            pPacket->Transaction(0);
            pPacket->TargetQueue(0);

            PIRP tempIrp = NULL;
            NTSTATUS rc = pQueue->PutPacket(tempIrp, pPacket, ppb);
            ASSERT(NT_SUCCESS(rc));
            
            pPacket->IsReceived(FALSE);
            tempIrp = NULL;
            rc = pQueue->PutPacket(tempIrp, pPacket, ppb);
            ASSERT(NT_SUCCESS(rc));
            
        }
        else
        {
            //
            //  discard received packets
            //
            CPacket* pDummy = pPacket;
            pPacket = pDummy->OtherPacket();
            ASSERT(pPacket != 0);
			pPacket->AddRef();

            ASSERT(pDummy->DeleteStorageIssued());
            
            pDummy->DetachBuffer();
            pDummy->OtherPacket(0);
            pDummy->Release();
			  
      		//
            //  detach the packet from the transaction and Done it
            //
            pPacket->IsReceived(FALSE);
			pPacket->Transaction(0);
            pPacket->OtherPacket(0);

            //
            // DeleteStorage has been issued on the Dummy packet. We must
            // mark it on the packet so Done will not issue a delete storage
            // again.
            //
            pPacket->DeleteStorageIssued(TRUE);
            pPacket->Done(0, ppb);
			pPacket->Release();
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS CTransaction::Abort1(PIRP irp)
{
    //
    //  Mark xact as passed prepare phase, it will not be found in Find.
    //
    PassedPreparePhase(TRUE);
    CompletePendingReaders();

    //
    //  At this abort phase, all sent packets are deleted
    //
    ASSERT(m_nStores == 0);
	m_StoreRC = STATUS_SUCCESS;

    for(List<CPacket>::Iterator p(m_packets); p; ++p)
    {
        CPacket* pPacket = p;
        if(!pPacket->IsXactSend())
        {
            continue;
        }
		 
		if(pPacket->StorageIssued() && !pPacket->DeleteStorageIssued())
		{
			NTSTATUS rc;

			rc = pPacket->DeleteStorage();
			if(!NT_SUCCESS(rc))
			{
				m_StoreRC = rc;
				break;
			}
			m_nStores++;
		}
    }

    if(m_nStores == 0)
    {
        //
        //  no stores in this xact, return immidiatly
        //
        return m_StoreRC;
    }

    //
    //  Hold the abort request
    //
    new (irp_driver_context(irp)) CDriverContext(true);
    return HoldRequest(irp, INFINITE, ACCancelXactControl);
}

NTSTATUS CTransaction::Abort2()
{
    ASSERT(NT_SUCCESS(m_StoreRC));
    
    CompletePendingReaders();

    CPacket * pPacket;
    while((pPacket = m_packets.gethead()) != 0)
    {
		pPacket->Transaction(0);
        if(pPacket->IsXactSend())
        {
            //
            //  Abort send packet; simply release the packet
            //
            //  N.B. It is ok to abort after Prepare has been called, but you
            //      should *NOT* abort after calling Commit1. Otherwise, the
            //      state of the message will become unstable. It may or may
            //      not be present on disk depending on the timing of the
            //      storage notification.
            //
            pPacket->TargetQueue(0);
	        pPacket->Release();
        }
        else
        {
            //
            //  Abort received packet; simply discard the dummy and return
            //  the received packet to it's queue
            //
            CPacket* pDummy = pPacket;
            pPacket = pDummy->OtherPacket();
			ASSERT(pPacket != 0);

            CPacketBuffer * ppb = NULL;
            if (pPacket->IsRevoked())
            {
                //
                // Need to access the buffer in order to handle revoke.
                // If mapping failed return before detaching from dummy.
                //
                ppb = pPacket->Buffer();
                if (ppb == NULL)
                {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }

			pPacket->AddRef();

            pDummy->DetachBuffer();
            pDummy->OtherPacket(0);
            pDummy->Release();

            //
            //  detach the packet from the transaction and return it to its
            //  original queue
            //
            //  N.B. We do *not* have a refrence count on that queue *but* the
            //      received packet prevent the QM from closing it.
            //
            //  N.B. The queue is forcibly closed only in the QM rundown.
            //      So we should not really be here when this happens.
            //
            //  N.B. The queue is not closed by the QM after Delete since
            //      there is a packet in the queue. So if the queue is
            //      deleted the queue will handle the packet.
            //
            CQueue* pQueue = pPacket->Queue();
            ASSERT(pQueue != 0);
            pPacket->IsReceived(FALSE);
            pPacket->Transaction(0);
            pPacket->OtherPacket(0);

            PIRP tempIrp = NULL;
            NTSTATUS rc = pQueue->PutPacket(tempIrp, pPacket, ppb);
            ASSERT(NT_SUCCESS(rc));
            DBG_USED(rc);

			pPacket->Release();
        }
    }

    return STATUS_SUCCESS;
}

void CTransaction::PacketStoreCompleted(NTSTATUS rc)
{
    //
    //  The prepare, commit1, commit2 and abort request are completed when all packet storage
    //  has been completed, or one of them failed.
    //
	if(!NT_SUCCESS(rc))
	{
		//
        //  One of the stores failed
        //
		m_StoreRC = rc;
	}

    if(--m_nStores == 0)
    {
        //
        //  All stores has completed
        //  Use the cancel routine to end the control irp
        //
        CancelTaggedRequest(m_StoreRC, 0);
    }
}

void CTransaction::GetInformation(CACXactInformation *pInfo)
{
    pInfo->nSends = m_nSends;
    pInfo->nReceives = m_nReceives;
}


void CTransaction::HoldReader(PIRP irp)
{
    //
    // Caller must grab the cancel spinlock
    //
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    m_readers.insert(irp);
}

void CTransaction::CompletePendingReaders()
{
    //
    // Optimization: do not grab the cancel spinlock if list is empty. Note that the
    // AC global lock is held here. Thus, no irp can be inserted at this time.
    //
    if (m_readers.isempty())
    {
        return;
    }

    PIRP irp;
    KIRQL irql;

    for(;;)
    {
        IoAcquireCancelSpinLock(&irql);
        if((irp = m_readers.peekhead()) == 0)
        {
            break;
        }

        ACCancelIrp(irp, irql, MQ_ERROR_TRANSACTION_SEQUENCE);

        //
        // The cancel spinlock should have been released by the cancel routine.
        //
    }

    IoReleaseCancelSpinLock(irql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\sched.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sortq.h

Abstract:

    Definitions for a generic scheduler.

Author:

    Boaz Feldbaum (BoazF) Apr 5, 1996

Revision History:

--*/

#ifndef _SCHED_H
#define _SCHED_H

#include "timer.h"
#include "sortq.h"

//---------------------------------------------------------
//
//  Scheduler time
//
//---------------------------------------------------------

typedef LARGE_INTEGER SCHEDTIME;

inline BOOL operator == (const SCHEDTIME& t1, const SCHEDTIME& t2)
{
    return (t1.QuadPart == t2.QuadPart);
}

inline BOOL operator < (const SCHEDTIME& t1, const SCHEDTIME& t2)
{
    return (t1.QuadPart < t2.QuadPart);
}

//---------------------------------------------------------
//
//  class CScheduler
//
//---------------------------------------------------------

typedef PVOID SCHEDID; // Event ID
struct SCHED_LIST_HEAD;
typedef void (NTAPI *PSCHEDULER_DISPATCH_ROUTINE)(SCHEDID); // The scheduler dispatch procedure.

class CScheduler {
public:
    CScheduler(PSCHEDULER_DISPATCH_ROUTINE, CTimer*, PFAST_MUTEX pMutex);

    bool InitTimer(PDEVICE_OBJECT pDevice);

    //
    //  Schedule an event at specific time
    //
    BOOL SchedAt(const SCHEDTIME&, SCHEDID, BOOL fDisableNewEvents = FALSE);

    //
    //  Cancel a scheduled event
    //
    BOOL SchedCancel(SCHEDID);

    //
    //  Cancel a scheduled event using a time hint
    //
    BOOL SchedCancel(const SCHEDTIME&, SCHEDID);

    //
    //  Enable new events
    //
    void EnableEvents(void);

private:
    BOOL RemoveEntry(SCHED_LIST_HEAD*, SCHEDID);
    void Dispatch();

private:
    static void NTAPI TimerCallback(PDEVICE_OBJECT, PVOID);

private:
    //
    //  All events are held up in a sorted queue..
    //
    CSortQ m_Q;

    //
    //  The registered dispatch function
    //
    PSCHEDULER_DISPATCH_ROUTINE m_pfnDispatch;

    //
    //  The timer object, represent time related operations
    //
    CTimer* m_pTimer;

    //
    //  Next event due time
    //
    SCHEDTIME m_NextSched;

    //
    //  Mutext to protect for Atomicity of operations
    //
    PFAST_MUTEX m_pMutex;

    //
    //  While sceduler is dispatching, no need to wind the timer
    //
    BOOL m_fDispatching;
};

#endif // _SCHED_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\sched.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sched.cxx

Abstract:

    This module contains the code for a generic scheduler.

Author:

    Boaz Feldbaum (BoazF) Apr 5, 1996

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "actempl.h"
#include "sched.h"

#ifndef MQDUMP
#include "sched.tmh"
#endif

// Serialization macros.

#define ENTER_CS(Loc) if (m_pMutex) { \
    KeEnterCriticalRegion(); \
    ExAcquireFastMutexUnsafe(m_pMutex); \
}
#define LEAVE_CS(Loc) if (m_pMutex) { \
    ExReleaseFastMutexUnsafe(m_pMutex); \
    KeLeaveCriticalRegion(); \
}

/*
#define ENTER_CS(Loc) if (m_pMutex) { \
    KdPrint(("Entering CS %s (Thread=%x)", Loc, PsGetCurrentThread())); \
    ExAcquireFastMutex(m_pMutex); \
    KdPrint((" Done (Thread=%x).\n", PsGetCurrentThread())); \
}
#define LEAVE_CS(Loc) if (m_pMutex) { \
    KdPrint(("Leaving CS %s (Thread=%x)", Loc, PsGetCurrentThread())); \
    ExReleaseFastMutex(m_pMutex); \
    KdPrint((" Done(Thread=%x).\n", PsGetCurrentThread())); \
}
*/

//
// The scheduler uses external functions that implements the timer. It also uses
// an external function to get the current time. These external functions are
// passed tot the scheduler constructor.
//
// The scheduler is implemented by using a sorted queue. When adding an event, the
// SchedAt() function gets the event due time and the event ID. It is possible that
// more than one event will be scheduled for the same time. So the data that the
// sorted queue holds is a list of events, as follows:
//
// Schedule list header                 Schedule list item
// +---------+----------+-------+      +----------+-------+
// |Due Time | Event ID | pNext | ---> | Event ID | pNext | ---> ...
// +---------+----------+-------+      +----------+-------+
//

// Schedule list item.
struct SCHED_LIST {
    SCHEDID ID;
    SCHED_LIST *pNext;
};
typedef SCHED_LIST* PSCHED_LIST;

// Schedule list header.
struct SCHED_LIST_HEAD {
    SCHED_LIST_HEAD();
    SCHEDTIME DueTime;
    SCHEDID ID;
    SCHED_LIST* pNext;
	SCHED_LIST* pLast;
};
typedef SCHED_LIST_HEAD* PSCHED_LIST_HEAD;

// List header constructor.
SCHED_LIST_HEAD::SCHED_LIST_HEAD()
{
    pNext = NULL;
	pLast = NULL;
}

// Insert another event with same due time.
// Upon deletion, always return TRUE.
BOOL __cdecl HandleMultipleInstances(PVOID pNew, PVOID pSchedList, BOOL bInsert)
{
    PSCHED_LIST_HEAD pNewSched = (PSCHED_LIST_HEAD)pNew;
    PSCHED_LIST_HEAD pSchedListHead = (PSCHED_LIST_HEAD)pSchedList;

    if (bInsert) {
        // Add a new schedule list item.
        PSCHED_LIST pSchedList1 = new (PagedPool, NormalPoolPriority) SCHED_LIST;
        if(pSchedList1 == 0)
            return FALSE;

        pSchedList1->ID = pNewSched->ID;
		pSchedList1->pNext = NULL;
		if(pSchedListHead->pLast != NULL)
		{
			pSchedListHead->pLast->pNext = pSchedList1;			
		}
		else
		{
			pSchedListHead->pNext = pSchedList1;
		}
		pSchedListHead->pLast = pSchedList1;
	
        delete pNewSched;
    }

    return TRUE;
}

//
// Compare time values.
//
int __cdecl TimeCompare(PVOID v1, PVOID v2)
{
    SCHEDTIME *t1 = &((PSCHED_LIST_HEAD)v1)->DueTime;
    SCHEDTIME *t2 = &((PSCHED_LIST_HEAD)v2)->DueTime;

    LONGLONG diff = t1->QuadPart - t2->QuadPart;
    if(diff > 0)
    {
        return 1;
    }

    if(diff < 0)
    {
        return -1;
    }

    return 0;
}

//
// Delete a schedule list
//
void __cdecl DeleteSchedList(PVOID pSchedList)
{
    PSCHED_LIST_HEAD pSchedListHead = (PSCHED_LIST_HEAD)pSchedList;
    PSCHED_LIST pNextItem, pNextItem1;

    pNextItem = pSchedListHead->pNext;
    //Delete the list header.
    delete pSchedListHead;
    // Delete the list items.
    while (pNextItem) {
        pNextItem1 = pNextItem->pNext;
        delete pNextItem;
        pNextItem = pNextItem1;
    }
}

//
// The scheduler constructor.
//
// pfnDispatch - A function that is call by the scheduler as the event dispatcher
//               procedure.
//               void DispatchProc(SCHEDID ID)
//                  ID - The dispatched event ID.
// pTimer - A timer object.
// pMutex - A pointer to a fast mutex object that is used by the scheduler to mutex
//          the scheduling operations. This is an optional parameter.
//
CScheduler::CScheduler(
    PSCHEDULER_DISPATCH_ROUTINE pfnDispatch,
    CTimer* pTimer,
    PFAST_MUTEX pMutex
    ) :
    m_Q(TRUE, HandleMultipleInstances, TimeCompare, DeleteSchedList),
    m_pfnDispatch(pfnDispatch),
    m_pTimer(pTimer),
    m_pMutex(pMutex),
    m_fDispatching(FALSE)
{
    //
    // Initialize member items.
    //
    m_NextSched.QuadPart = 0;
}

bool CScheduler::InitTimer(PDEVICE_OBJECT pDevice)
{
    //
    // Initialize the timer: Set the timer callback function. The context buffer
    // is the scheduler object itself.
    //
    return m_pTimer->SetCallback(pDevice, TimerCallback, this);
}

//
// Schedule an event at a given time.
//
// Parameter:
//      DueTime - The time at which the event should occur.
//      ID - the event ID.
//
BOOL CScheduler::SchedAt(const SCHEDTIME& DueTime, SCHEDID ID, BOOL fDisableNewEvents)
{
    PSCHED_LIST_HEAD pSchedListHead = new (PagedPool, NormalPoolPriority) SCHED_LIST_HEAD;
    if(pSchedListHead == 0)
    {
       	TrERROR(AC, "Failed to allocate a SCHED_LIST_HEAD from non paged pool."); 
        return FALSE;
    }

    ENTER_CS("Sched 1");

#if 0 // def _DEBUG

    PSCHED_LIST_HEAD pDebugSchedListHead;
    PSCHED_LIST pDebugNext, pDebugPrev;
    SortQCursor DebugCursor;

    m_Q.PeekHead((PVOID *)&pDebugSchedListHead, &DebugCursor);
    while (pDebugSchedListHead) {
        ASSERTMSG("ID already in scheduler", pDebugSchedListHead->ID != ID);

        pDebugNext = pDebugSchedListHead->pNext;
        pDebugPrev = NULL;
        while (pDebugNext) {
            ASSERTMSG("ID already in scheduler", pDebugNext->ID != ID);

            pDebugPrev = pDebugNext;
            pDebugNext = pDebugNext->pNext;
        }

        m_Q.PeekNext((PVOID *)&pDebugSchedListHead, &DebugCursor);
    }

#endif

    // Insert a schedule item into the queue.
    pSchedListHead->DueTime = DueTime;
    pSchedListHead->ID = ID;
    if(!m_Q.Insert(pSchedListHead))
    {
        delete pSchedListHead;
        LEAVE_CS("Sched 1");
        return FALSE;
    }

    if ((DueTime < m_NextSched) || (m_NextSched.QuadPart == 0))
    {
        // Re-schedule the timer event.
        m_NextSched = DueTime;
        if(!m_fDispatching)
        {
            m_pTimer->SetTo(m_NextSched);
        }
    }

    if(!fDisableNewEvents)
    {
        LEAVE_CS("Sched 1");
    }

    return TRUE;
}


BOOL CScheduler::RemoveEntry(PSCHED_LIST_HEAD pSchedListHead, SCHEDID ID)
{
    ASSERT(pSchedListHead != 0);

    if(pSchedListHead->ID != ID)
    {
        //
        //  It is not the first entry, search for ID in the list and remove it
        //
		PSCHED_LIST pPrev = 0;
        for( PSCHED_LIST* ppNext = &pSchedListHead->pNext;
            *ppNext != 0;
            pPrev = *ppNext, ppNext = &(*ppNext)->pNext)
        {
            PSCHED_LIST pNext = *ppNext;
            if(pNext->ID == ID)
            {              
				if(pSchedListHead->pLast == pNext)
				{
					pSchedListHead->pLast = pPrev;
				}
				*ppNext = pNext->pNext;
                delete pNext;
                return TRUE;
            }

        }
        return FALSE;
    }

    //
    //  The ID to remove is the list head. remove it.
    //
    PSCHED_LIST pNext = pSchedListHead->pNext;
    if(pNext != 0)
    {
        //
        //  There are other events at the same time.
        //  replace the head with the next event.
        //
        pSchedListHead->pNext = pNext->pNext;
        pSchedListHead->ID = pNext->ID;
		if(pSchedListHead->pLast == pNext)
		{			
			pSchedListHead->pLast=NULL;					
		}
        delete pNext;
        return TRUE;
    }

    //
    // The head is the only event, remvoe it.
    //
    SCHEDTIME t = pSchedListHead->DueTime;
    m_Q.Delete(pSchedListHead);
    delete pSchedListHead;

    //
    //  There are no other events at the same time, reschedule if
    //  it is the first event that was removed
    //
    if(t == m_NextSched)
    {
        if (!m_Q.PeekHead((PVOID *)&pSchedListHead))
        {
            //
            // There are no other events, cancel the timer event.
            //
            m_NextSched.QuadPart = 0;
            m_pTimer->Cancel();
        }
        else
        {
            //
            // Re-schedule the timer event.
            //
            m_NextSched = pSchedListHead->DueTime;
            if(!m_fDispatching)
            {
                m_pTimer->SetTo(m_NextSched);
            }
        }
    }
    return TRUE;
}


//
// Cancel an event.
//
// Parameter:
//      ID - The event ID.
//
//
BOOL CScheduler::SchedCancel(SCHEDID ID)
{
    ENTER_CS("Sched 2");

    // Search the schedule item in the queue.
    SortQCursor c;
    PSCHED_LIST_HEAD pSchedListHead;
    m_Q.PeekHead((PVOID *)&pSchedListHead, &c);
    while (pSchedListHead)
    {
        if(RemoveEntry(pSchedListHead, ID))
            break;

        m_Q.PeekNext((PVOID *)&pSchedListHead, &c);
    }

    LEAVE_CS("Sched 2");

    return (pSchedListHead != 0);
}


//
// Cancel an event using a hint.
//
// Parameter:
//      ID - The event ID.
//
//
BOOL CScheduler::SchedCancel(const SCHEDTIME& DueTime, SCHEDID ID)
{
    ENTER_CS("Sched 2");
    SCHED_LIST_HEAD slh;
    slh.DueTime = DueTime;
    slh.ID = ID;
    PSCHED_LIST_HEAD pSchedListHead = (PSCHED_LIST_HEAD)m_Q.Find(&slh);
    if((pSchedListHead != 0) && !RemoveEntry(pSchedListHead, ID))
    {
        //
        //  event was not found in list
        //
        pSchedListHead = 0;
    }

    LEAVE_CS("Sched 2");

    return (pSchedListHead != 0);
}


inline void CScheduler::Dispatch()
{
    PSCHED_LIST_HEAD pSchedListHead;
    PSCHED_LIST pNext, pPrev;
    SCHEDTIME CurrTime;

    ENTER_CS("Sched 3");

    ASSERT(!m_fDispatching);
    m_fDispatching = TRUE;

    m_pTimer->GetCurrentTime(CurrTime);
    while ((m_NextSched <= CurrTime) && (m_NextSched.QuadPart != 0))
    {
        m_Q.GetHead((PVOID *)&pSchedListHead);
        if(!pSchedListHead)
        {
            m_NextSched.QuadPart = 0;
            break;
        }

        //
        //  Release the scheduler lock to avoid deadlock. if in the dispatch
        //  routine the scheduler is called or trying to gain another lock.
        //
        LEAVE_CS("Sched 3");

        //
        // Call the dispatch procedure for the header shedule item.
        //
        m_pfnDispatch(pSchedListHead->ID);

        //
        // Call the dispatch procedure for the rest of the schedule items and
        // delete them.
        //
        pNext = pSchedListHead->pNext;
        delete pSchedListHead;
        while(pNext)
        {
            m_pfnDispatch(pNext->ID);
            pPrev = pNext;
            pNext = pNext->pNext;
            delete pPrev;
        }

        //
        //  Get the scheduler lock again, and process the next event
        //
        ENTER_CS("Sched 3");

        ASSERT(m_fDispatching == TRUE);

        if (!m_Q.PeekHead((PVOID *)&pSchedListHead))
        {
            //
            //  No more events
            //
            m_NextSched.QuadPart = 0;
        }
        else
        {
            m_NextSched = pSchedListHead->DueTime;
            ASSERT(m_NextSched.QuadPart > 0);
        }
        m_pTimer->GetCurrentTime(CurrTime);
    }

    m_pTimer->Busy(0);

    if(m_NextSched.QuadPart != 0)
    {
        //
        // Set the timer for next event;
        //
        m_pTimer->SetTo(m_NextSched);
    }

    m_fDispatching = FALSE;

    LEAVE_CS("Sched 3");
}

//
// The timer callback. The context buffer points to the scheduler object.
//
void CScheduler::TimerCallback(PDEVICE_OBJECT, PVOID p)
{
    static_cast<CScheduler*>(p)->Dispatch();
}

void CScheduler::EnableEvents(void)
{
    LEAVE_CS("Sched 4");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    29-Nov-99 AlexDad


!ENDIF

!include $(FROOT)\src\inc\msmq.inc

MSC_WARNING_LEVEL=/W4

#
# Dont use C++ exception handling (/GX-)
#
!undef USE_NATIVE_EH

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\internal.h

SOURCES=\
     ..\acctl32.cxx    \
     ..\avl.cxx        \
     ..\bitmap.cxx     \
     ..\cancel.cxx     \
     ..\cleanup.cxx    \
     ..\close.cxx      \
     ..\control.cxx    \
     ..\create.cxx     \
     ..\cursor.cxx     \
     ..\data.cxx       \
     ..\dl.cxx         \
     ..\heap.cxx       \
     ..\htable.cxx     \
     ..\init.cxx       \
     ..\irp2pkt.cxx    \
     ..\localsend.cxx  \
     ..\ver.rc         \
     ..\object.cxx     \
     ..\packet.cxx     \
     ..\qbase.cxx      \
     ..\qgroup.cxx     \
     ..\qm.cxx         \
     ..\qproxy.cxx     \
     ..\queue.cxx      \
     ..\quser.cxx      \
     ..\qxact.cxx      \
     ..\sched.cxx      \
     ..\sortq.cxx      \
     ..\store.cxx      \
     ..\timer.cxx      \
     ..\avltree.cxx    \
	 

#remove UNICODE,_UNICODE
C_DEFINES=$(C_DEFINES: -D_UNICODE=)
C_DEFINES=$(C_DEFINES: -DUNICODE=)
C_DEFINES=  $(C_DEFINES) -D_CONSOLE

USER_C_FLAGS = $(USER_C_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\store.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    store.cxx

Abstract:

    AC Storage Manager

Author:

    Erez Haba (erezh) 5-May-96

Revision History:

--*/

#include "internal.h"
#include "lock.h"
#include "store.h"
#include "packet.h"
#include "data.h"
#include "acheap.h"
#include "acp.h"
#include "qm.h"
#include "irp2pkt.h"

#ifndef MQDUMP
#include "store.tmh"
#endif

//---------------------------------------------------------
//
//  ACCancelWriter
//
//---------------------------------------------------------
static
VOID
ACCancelWriter(
    IN PDEVICE_OBJECT /*pDevice*/,
    IN PIRP irp
    )
{
    //
    // Remove irp from list
    //
    ACpRemoveEntryList(&irp->Tail.Overlay.ListEntry);

    //
    // Release cancel spinlock
    //
    IoReleaseCancelSpinLock(irp->CancelIrql);
    TrTRACE(AC, "ACCancelWriter (irp=0x%p)", irp);

    //
    // Grab global AC lock
    //
    CS lock(g_pLock);

    //
    // Detach packets from irp, de-ref the attach packet
    //
    CPacket * pPacket;
    while ((pPacket = CIrp2Pkt::SafeGetAttachedPacketsHead(irp)) != NULL)
    {
        pPacket->WriterPending(FALSE);
        pPacket->Release();
    }
    ASSERT(CIrp2Pkt::SafePeekFirstPacket(irp) == NULL);

    //
    // Complete the irp
    //
    irp->IoStatus.Information = 0;
    irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

//---------------------------------------------------------
//
//  class CStorage
//
//---------------------------------------------------------

void CStorage::HoldWriteRequest(PIRP irp)
{
    //
    // Grab cancel spinlock
    //
    ASL asl;

    //
    // Packet[s] must be attached on the irp
    //
    ASSERT(CIrp2Pkt::SafePeekFirstPacket(irp) != NULL);

    //
    // irp must not already be held (this field is relevant for multi packets irp only)
    //
    ASSERT(!irp_driver_context(irp)->MultiPackets() || !CIrp2Pkt::IsHeld(irp));

    //
    // Insert the irp to list. The IsHeld flag is used only for multi packets irp.
    //
    m_writers.insert(irp);
    if (irp_driver_context(irp)->MultiPackets())
    {
        CIrp2Pkt::IsHeld(irp, true);
    }

    //
    // Set the irp as pending and cancellable
    //
    ASSERT(irp->CancelRoutine == 0);
    IoSetCancelRoutine(irp, ACCancelWriter);
    IoMarkIrpPending(irp);
}

PIRP CStorage::GetWriteRequest(CPacket * pContext)
{
    ASSERT(pContext != NULL);

    //
    // Grab cancel spinlock
    //
    ASL asl;

    TrTRACE(AC, "* CStorage::GetWriteRequest, context=%p *", pContext);
    for(CIRPList::Iterator p(m_writers); p; ++p)
    {
        PIRP irp = p;
        ASSERT(("Packet[s] must be attached on the irp", CIrp2Pkt::SafePeekFirstPacket(irp) != NULL));

        if (!irp_driver_context(irp)->MultiPackets())
        {
            if (CIrp2Pkt::PeekSinglePacket(irp) == pContext)
            {
                IoSetCancelRoutine(irp, 0);
                m_writers.remove(irp);
                return irp;
            }

            continue;
        }

        TrTRACE(AC, "* CStorage::GetWriteRequest, irp is multi packet *");
        List<CPacketIterator::CEntry>& entries = CIrp2Pkt::GetPacketIteratorEntries(irp);
        for(List<CPacketIterator::CEntry>::Iterator pEntry(entries); 
            pEntry != NULL; 
            ++pEntry)
        {
            ASSERT(pEntry->m_pPacket != NULL);
            TrTRACE(AC, "* CStorage::GetWriteRequest, pEntry->m_pPacket=%p *", pEntry->m_pPacket);

            if (pEntry->m_pPacket == pContext)
            {
                IoSetCancelRoutine(irp, 0);
                m_writers.remove(irp);
                CIrp2Pkt::IsHeld(irp, false);
                return irp;
            }
        }
    }

    return 0;
}


//---------------------------------------------------------
//
//  ACpStorageCompletedSuccess
//
//---------------------------------------------------------

inline
NTSTATUS
ACpStorageCompletedSuccess(
    ULONG count,
    CPacket** ppPacket
    )
{
    if (g_pQM->Process() == 0)
    {
        //
        //  we are at QM rundown, storage will fail
        //
        return MQ_ERROR_MESSAGE_STORAGE_FAILED;
    }

    //
    // Attach to QM process so we could reference memory mapped to QM when updating the bitmap
    //
    PEPROCESS pDetach = ACAttachProcess(g_pQM->Process());

    for(ULONG ix = 0; ix < count; )
    {
        CMMFAllocator* pAllocator = ppPacket[ix]->Allocator();
        for(; (ix < count) && (ppPacket[ix]->Allocator() == pAllocator) ; ix++)
        {
            CAllocatorBlockOffset abo = ppPacket[ix]->AllocatorBlockOffset();
            if (!abo.IsValidOffset())
                continue;

            CAccessibleBlock* pab = pAllocator->GetQmAccessibleBufferNoMapping(abo);
            if(pab == 0)
                continue;

            ppPacket[ix]->UpdateBitmap(pab->m_size);
        }
    }

    ACDetachProcess(pDetach);

    return STATUS_SUCCESS;
}


//---------------------------------------------------------
//
//  ACpCompleteStorage
//
//---------------------------------------------------------

void
ACpCompleteStorage(
    ULONG count,
    CPacket** ppPacket,
    NTSTATUS status
   )
{
    if(NT_SUCCESS(status))
    {
        status = ACpStorageCompletedSuccess(count, ppPacket);
    }

    for(ULONG ix = 0; ix < count; ix++)
    {
		CMMFAllocator* pAllocator = ppPacket[ix]->Allocator();

		pAllocator->ReleaseOutstandingStorage();
		ppPacket[ix]->HandleStorageCompleted(status);
		ppPacket[ix]->ReleaseBuffer();
        ppPacket[ix]->Release();
    }
}


static
void
ACpCompleteStorageCancelled(
    ULONG count,
    CPacket** ppPacket,
    NTSTATUS status
   )
{
    CS lock(g_pLock);

    for(ULONG ix = 0; ix < count; ix++)
    {
		ppPacket[ix]->HandleStorageCompleted(status);
		ppPacket[ix]->ReleaseBuffer();
        ppPacket[ix]->Release();
    }
}

//---------------------------------------------------------
//
//  ACCancelStorageNotification
//
//---------------------------------------------------------
VOID
ACCancelNotification(
    IN PDEVICE_OBJECT /*pDevice*/,
    IN PIRP irp
    )
{
    ACpRemoveEntryList(&irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(irp->CancelIrql);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
	ULONG count = irpSp->Parameters.DeviceIoControl.InputBufferLength / sizeof(VOID*);
    NTSTATUS status = (NTSTATUS)DWORD_PTR_TO_DWORD(irp->UserBuffer);

    TrTRACE(AC, "ACCancelStorageNotification (irp=0x%p, count=%d, rc=0x%x)", irp, count, status);

    ACpCompleteStorageCancelled(
        count,
        (CPacket**)irp->AssociatedIrp.SystemBuffer,
        status
        );

    irp->IoStatus.Information = 0;
    irp->IoStatus.Status = STATUS_CANCELLED;

    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

//---------------------------------------------------------
//
//  class CStorageComplete
//
//---------------------------------------------------------

void CStorageComplete::HoldNotification(PIRP irp)
{
    {
        ASL asl;

        m_notifications.insert(irp);
        ASSERT(irp->CancelRoutine == 0);
        IoSetCancelRoutine(irp, ACCancelNotification);
        IoMarkIrpPending(irp);
    }

    if(!m_fWorkItemInQueue)
    {
        m_fWorkItemInQueue = true;
        IoQueueWorkItem(m_pWorkItem, WorkerRoutine, DelayedWorkQueue, 0);
    }
}


inline PIRP CStorageComplete::GetNotification()
{
    ASL asl;
    PIRP irp = m_notifications.gethead();
    if(irp != 0)
    {
        IoSetCancelRoutine(irp, 0);
    }

    return irp;
}


inline void CStorageComplete::CompleteStorage()
{
    m_fWorkItemInQueue = false;

    PIRP irp;
    while((irp = GetNotification()) != 0)
    {
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);

		ULONG count = irpSp->Parameters.DeviceIoControl.InputBufferLength / sizeof(VOID*);
        NTSTATUS status = (NTSTATUS)DWORD_PTR_TO_DWORD(irp->UserBuffer);
		{
		    CS lock(g_pLock);

		    ACpCompleteStorage(
		        count,
		        (CPacket**)irp->AssociatedIrp.SystemBuffer,
		        status
		        );
        }
		TrTRACE(AC, " *CompleteStorage(irp=0x%p, count=%d, rc=0x%x)*", irp, count, status);

        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = STATUS_SUCCESS;

        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}

void NTAPI CStorageComplete::WorkerRoutine(PDEVICE_OBJECT, PVOID)
{
    g_pStorageComplete->CompleteStorage();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\sortq.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sortq.h

Abstract:

    Definitions for a generic sorted queue.

Author:

    Boaz Feldbaum (BoazF) Apr 5, 1996

Revision History:

--*/

#ifndef SORTQ_H
#define SORTQ_H

#include "avl.h"

// Queue handling routins passed to the queue constructor.
typedef NODEDOUBLEINSTANCEPROC QUEUEITEMDOUBLEINSTANCEPROC ;
typedef NODECOMPAREPROC QUEUEITEMCOMPAREPROC;
typedef NODEDELETEPROC QUEUEITEMDELETEPROC;

// A cursor structure used for scanning the queue.
typedef CAVLTreeCursor SortQCursor;

// The queue class definition.
class CSortQ {
public:
    CSortQ(BOOL, QUEUEITEMDOUBLEINSTANCEPROC, QUEUEITEMCOMPAREPROC, QUEUEITEMDELETEPROC);
    BOOL Insert(PVOID); // Insert an item to the queue
    void Delete(PVOID); // Delete an item from the queue.
    PVOID Find(PVOID); // Find data in the tree.
    void GetHead(PVOID *); // Get the item at the head of the queue and remove the item.
    void GetTail(PVOID *); // Get the item at the tail of the queue and remove the item.
    BOOL PeekHead(PVOID *, SortQCursor * =NULL); // Get the item at the head of the queue.
    BOOL PeekTail(PVOID *, SortQCursor * =NULL); // Get the item at the tail of the queue.
    BOOL PeekNext(PVOID *, SortQCursor *); // Get the next item in the queue relatively to the cursor.
    BOOL PeekPrev(PVOID *, SortQCursor *); // Get the previous item in the queue relatively to the cursor.
    BOOL IsEmpty(void); // TRUE if the queue is empty.
private:
    CAVLTree m_AVLT; // The ALV tree that is used for implementing the queue.
    BOOL m_bAccending; // Indicates whether it is an accesding ordered queue.
};

inline PVOID CSortQ::Find(PVOID p)
{
    return m_AVLT.FindNode(p);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\timer.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.cxx

Abstract:

    Represintaion for NT timers, to allow callback at IRQL PASSIVE_LEVEL.

Author:

    Erez Haba (erezh) 31-Mar-96

Revision History:

--*/

#include "internal.h"
#include "timer.h"

#ifndef MQDUMP
#include "timer.tmh"
#endif

void NTAPI CTimer::DefferedRoutine(PKDPC pDPC, PVOID pWorkItem, PVOID, PVOID)
{
    CTimer* pTimer = CONTAINING_RECORD(pDPC, CTimer, m_DPC);
    if(pTimer->Busy(1) == 0)
    {
        PIO_WORKITEM_ROUTINE pCallback;
        PVOID pContext;
        pTimer->GetCallback(&pCallback, &pContext);

        IoQueueWorkItem(static_cast<PIO_WORKITEM>(pWorkItem), pCallback, DelayedWorkQueue, pContext);
    }
    else
    {
        //
        //  Use KdPrint and not TrTRACE, we are at raised IRQL
        //
        KdPrint(("CTimer(0x%0p)::DefferedRoutine: Timer exprired while work item is busy", pTimer));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\sortq.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sortq.cxx

Abstract:

    This module contains the code for a generic sorted queue.

Author:

    Boaz Feldbaum (BoazF) Apr 5, 1996

Environment:

    Kernel mode

Revision History:

--*/

#include "internal.h"
#include "sortq.h"

#ifndef MQDUMP
#include "sortq.tmh"
#endif

//
// Initialize the sorted queue object.
//
// Parameters:
//      bAccending - TRUE - The queue holds the data in accending order - the lowest
//                   value in the queue is in the queue head.
//      pfnDblInst - A function that deals double instances in the queue. This
//                   function gets called whenever an item is inserted to the queue
//                   and it already exist in the queue, and whenever an item is being
//                   deleted from the queue.
//                   BOOL DblInstProc(PVOID pNew, PVOID pOld, BOOL bInsert)
//                      pNew - Points to the data passed to added or deleted.
//                      pOld - Points to the data in the queue.
//                      bInsert - Indicates whether the function is called upon item
//                                insertion or item deletion.
//                      Return value: Upon item insertion, the return value of
//                                    DblInstProc is the return value of Insert().
//                                    Upon item deletion, the return value detrmines
//                                    whether the item should be deleted from the queue.
//                                    If DblInstProc returns TRUE, the item is
//                                    deleted.
//      pfnCompare  - A function that is called in order to compare an item in the
//                    queue with a searched data.
//                    int CompNodeProc(PVOID v1, PVOID v2)
//                      v1 - Points to the searched data.
//                      v2 - Points to the data that the item points to.
//                      Returned value: 0 - If the items are equal.
//                                      <0 - If the searched item is smaller than
//                                           the data in the queue item.
//                                      >0 - Else.
//      pfnDelNode - A function that is called for each of the items upon the queue
//                   distruction. When the queue is being destroyed, the application
//                   is given a chance to also destroy the data that is being held
//                   by the items in the queue. The function is called once per each
//                   queue item.
//                   void DelNodeProc(PVOID pData)
//                      pData - Points to the data that is pointed by the item.
//      pMutex - An optional pointer to a fast mutex object that is to be used for
//               mutexing the queue operations. This is an optional parameter.
//
CSortQ::CSortQ( BOOL bAccending,
                QUEUEITEMDOUBLEINSTANCEPROC pfnDblInstance,
                QUEUEITEMCOMPAREPROC pfnCompare,
                QUEUEITEMDELETEPROC pfDelete
                ) :
                m_AVLT(pfnDblInstance, pfnCompare, pfDelete),
                m_bAccending(bAccending)
{
}

//
// Insert data into the queue.
//
BOOL CSortQ::Insert(PVOID pData)
{
    CAVLTreeCursor c;
    return m_AVLT.AddNode(pData, &c);
}

//
// Delete an item from the queue.
//
void CSortQ::Delete(PVOID pData)
{
    m_AVLT.DelNode(pData);
}

//
// Get a pointer to the data in the queue head and remove the item from the queue.
// The actual removal of the item is determined by DblInstProc (see queue
// initialization function).
//
void CSortQ::GetHead(PVOID *pData)
{
    if(PeekHead(pData))
    {
        m_AVLT.DelNode(*pData);
    }
}

#ifdef UNUSED
//
// Get a pointer to the data in the queue tail and remove the item from the queue.
// The actual removal of the item is determined by DblInstProc (see queue
// initialization function).
//
void CSortQ::GetTail(PVOID *pData)
{
    if (PeekTail(pData))
    {
        m_AVLT.DelNode(*pData);
    }
}
#endif // UNUSED

//
// Get a pointer to the data in the queue head, the data remains in the queue.
//
// Is is possible to optionally pass a pointer to a cursor and use the cursor
// afterwards in order to scan the queue. If the queue was modified (and item was
// added and/or removed), it is not possbile to use the cursor anymore.
//
BOOL CSortQ::PeekHead(PVOID *pData, SortQCursor *c)
{
    SortQCursor ic;
    CAVLTreeCursor *pic;
    BOOL bRet;

    if (!c) {
        pic = (CAVLTreeCursor *)&ic;
    } else {
        pic = (CAVLTreeCursor *)c;
    }

    bRet = m_AVLT.SetCursor(m_bAccending ? POINT_TO_SMALLEST : POINT_TO_LARGEST, pic,
        pData);

    return bRet;
}

#ifdef UNUSED
//
// Get a pointer to the data in the queue tail, the data remains in the queue.
//
// Is is possible to optionally pass a pointer to a cursor and use the cursor
// afterwards in order to scan the queue. If the queue was modified (and item was
// added and/or removed), it is not possbile to use the cursor anymore.
//
//
BOOL CSortQ::PeekTail(PVOID *pData, SortQCursor *c)
{
    SortQCursor ic;
    CAVLTreeCursor *pic;
    BOOL bRet;

    if (!c) {
        pic = (CAVLTreeCursor *)&ic;
    } else {
        pic = (CAVLTreeCursor *)c;
    }

    bRet = m_AVLT.SetCursor(m_bAccending ? POINT_TO_LARGEST : POINT_TO_SMALLEST, pic,
        pData);

    return bRet;
}
#endif // UNUSED

//
// Get the next data in the queue relatively to the cursor.
//
// PeekNext() fails if the cursor points to the item with the highest value in the
// queue.
//
BOOL CSortQ::PeekNext(PVOID *pData, SortQCursor *c)
{
    CAVLTreeCursor *ic = (SortQCursor *)c;
    BOOL bRet;

    bRet = m_bAccending ? m_AVLT.GetNext(ic, pData) : m_AVLT.GetPrev(ic, pData);

    return bRet;
}

#ifdef UNUSED
//
// Get the previous data in the queue relatively to the cursor.
//
// PeekPrev() fails if the cursor points to the item with the lowes value in the
// queue.
//
BOOL CSortQ::PeekPrev(PVOID *pData, SortQCursor *c)
{
    CAVLTreeCursor *ic = (SortQCursor *)c;
    BOOL bRet;

    bRet = m_bAccending ? m_AVLT.GetPrev(ic, pData) : m_AVLT.GetNext(ic, pData);

    return bRet;
}

//
// IsEmpty() returns TRUE if the queue is empty and FALSE otherwise.
//
BOOL CSortQ::IsEmpty()
{
    return m_AVLT.IsEmpty();
}
#endif // UNUSED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\store.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    store.h

Abstract:

    AC Storage Manager

Author:

    Erez Haba (erezh) 5-May-96

Revision History:

--*/

#ifndef __STORE_H
#define __STORE_H

#include "irplist.h"
#include "packet.h"

//---------------------------------------------------------
//
//  class CStorage
//
//---------------------------------------------------------
class CStorage {
public:

    void HoldWriteRequest(PIRP irp);
    PIRP GetWriteRequest(CPacket * pContext);

private:
    CIRPList m_writers;
};

//---------------------------------------------------------
//
//  class CStorageComplete
//
//---------------------------------------------------------
class CStorageComplete {
public:

    CStorageComplete();
    ~CStorageComplete();

    bool AllocateWorkItem(PDEVICE_OBJECT pDevice);
    void HoldNotification(PIRP irp);

private:
    void CompleteStorage();
    PIRP GetNotification();

private:
    static void NTAPI WorkerRoutine(PDEVICE_OBJECT, PVOID);

private:
    CIRPList m_notifications;
    PIO_WORKITEM m_pWorkItem;
    bool m_fWorkItemInQueue;
};


inline CStorageComplete::CStorageComplete() : m_pWorkItem(NULL), m_fWorkItemInQueue(false)
{
}


inline CStorageComplete::~CStorageComplete()
{
    if (m_pWorkItem != NULL)
    {
        IoFreeWorkItem(m_pWorkItem);
    }
}


inline bool CStorageComplete::AllocateWorkItem(PDEVICE_OBJECT pDevice)
{
    ASSERT(m_pWorkItem == NULL);
    m_pWorkItem = IoAllocateWorkItem(pDevice);

    return (m_pWorkItem != NULL);
}

void
ACpCompleteStorage(
    ULONG count,
    CPacket** ppPacket,
    NTSTATUS status
   );


#endif // __STORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\timer.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.h

Abstract:

    Represintaion for NT timers, to allow callback at IRQL PASSIVE_LEVEL.

Author:

    Erez Haba (erezh) 31-Mar-96

Revision History:

--*/

#ifndef __TIMER_H
#define __TIMER_H

//---------------------------------------------------------
//
//  class CTimer
//
//---------------------------------------------------------

class CTimer {
public:
    CTimer();
    ~CTimer();

    BOOL SetTo(LARGE_INTEGER& liTime);
    BOOL Cancel();

    void GetCurrentTime(LARGE_INTEGER& liTime);
    bool SetCallback(PDEVICE_OBJECT pDevice, PIO_WORKITEM_ROUTINE pCallback, PVOID pContext);
    void GetCallback(PIO_WORKITEM_ROUTINE * ppCallback, PVOID * ppContext) const;
    LONG Busy(LONG ulBusy);

private:
    static void NTAPI DefferedRoutine(PKDPC, PVOID, PVOID, PVOID);


private:
    PIO_WORKITEM_ROUTINE m_pCallback;
    PVOID m_pContext;
    KTIMER m_timer;
    KDPC m_DPC;
    PIO_WORKITEM m_pWorkItem;
    LONG m_ulBusy;
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

inline CTimer::CTimer() :
    m_ulBusy(0),
    m_pWorkItem(NULL)
{
}


inline CTimer::~CTimer()
{
	ASSERT (m_ulBusy == 0);
	if (m_pWorkItem != NULL)
	{
		IoFreeWorkItem(m_pWorkItem);
	}
}


inline BOOL CTimer::SetTo(LARGE_INTEGER& liTime)
{
    return KeSetTimer(&m_timer, liTime, &m_DPC);
}


inline BOOL CTimer::Cancel()
{
    return KeCancelTimer(&m_timer);
}


inline void CTimer::GetCurrentTime(LARGE_INTEGER& liTime)
{
    KeQuerySystemTime(&liTime);
}


inline bool CTimer::SetCallback(PDEVICE_OBJECT pDevice, PIO_WORKITEM_ROUTINE pCallback, PVOID pContext)
{
	ASSERT (m_pWorkItem == NULL);
    m_pWorkItem = IoAllocateWorkItem(pDevice);
    if (m_pWorkItem == NULL)
    {
        return false;
    }

    m_pCallback = pCallback;
    m_pContext = pContext;

    KeInitializeTimer(&m_timer);
    KeInitializeDpc(&m_DPC, DefferedRoutine, m_pWorkItem);

    return true;
}


inline void CTimer::GetCallback(PIO_WORKITEM_ROUTINE * ppCallback, PVOID * ppContext) const
{
    (*ppCallback) = m_pCallback;
    (*ppContext) = m_pContext;
}


inline LONG CTimer::Busy(LONG ulBusy)
{
    return InterlockedExchange(&m_ulBusy, ulBusy);
}

#endif // __TIMER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\actest.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    AcTest.cpp

Abstract:

    AC unit test main module.

Author:

    Shai Kariv  (shaik)  06-Jun-2000

Environment:

    User mode.

Revision History:

--*/

#include "stdh.h"
#include "globals.h"
#include "init.h"
#include "connect.h"
#include "queue.h"
#include "message.h"
#include "handle.h"
#include "packet.h"

static
VOID
ActpTestQueue(
    VOID
    )
/*++

Routine Description:

    Test AC APIs for queue manipulation:

    ACCreateQueue
    ACAssociateQueue
    ACSetQueueProperties
    ACGetQueueProperties
    ACGetQueueHandleProperties
    ACCanCloseQueue
    ACCloseHandle

Arguments:

    None.

Return Value:

    None. Exception is raised on failure.

--*/
{
    wprintf(L"Testing AC APIs for Queue manipulation...\n");

    //
    // Create queue
    //
    HANDLE hQueue = ActpCreateQueue(L"OS:shaik10\\private$\\AcTestQueue1");

    //
    // Set queue properties
    //
    ActpSetQueueProperties(hQueue);

    //
    // Associate queue
    //
    HANDLE hAssociatedQueue1 = ActpAssociateQueue(hQueue, MQ_SEND_ACCESS);
    HANDLE hAssociatedQueue2 = ActpAssociateQueue(hQueue, MQ_RECEIVE_ACCESS);

    //
    // Get queue properties
    //
    ActpGetQueueProperties(hQueue);

    //
    // Get queue handle properties
    //
    ActpGetQueueHandleProperties(hAssociatedQueue1);
    ActpGetQueueHandleProperties(hAssociatedQueue2);

    //
    // Can close queue
    //
    if (ActpCanCloseQueue(hQueue))
    {
        wprintf(L"Can close queue (Expected: Cannot close queue)\n");
        throw exception();
    }

    //
    // Close handles
    //
    ActpCloseHandle(hAssociatedQueue2);
    ActpCloseHandle(hAssociatedQueue1);

    //
    // Can close queue
    //
    if (!ActpCanCloseQueue(hQueue))
    {
        wprintf(L"Cannot close queue (Expected: Can close queue)\n");
        throw exception();
    }

    ActpCloseHandle(hQueue);

    wprintf(L"Success!\n");

} // ActpTestQueue


static
VOID
ActpTestMessage(
    VOID
    )
/*++

Routine Description:

    Test AC APIs for message manipulation:

    ACSendMessage
    ACReceiveMessage
    ACReceiveMessageByLookupId

Arguments:

    None.

Return Value:

    None. Exception is raised on failure.

--*/
{
    wprintf(L"Testing AC APIs for Message manipulation...\n");

    //
    // Create the destination queue
    //
    HANDLE hQueue = ActpCreateQueue(L"OS:shaik10\\private$\\AcTestQueue1");
    ActpSetQueueProperties(hQueue);

    //
    // Associate the queue for send access and send message
    //
    HANDLE hQueueSend = ActpAssociateQueue(hQueue, MQ_SEND_ACCESS);
    ActpSendMessage(hQueueSend);
    ActpCloseHandle(hQueueSend);

    //
    // Associate the queue for peek access and peek first message by lookup id
    //
    HANDLE hQueuePeek = ActpAssociateQueue(hQueue, MQ_PEEK_ACCESS);
    ULONGLONG LookupId;
    LookupId = ActpReceiveMessageByLookupId(hQueuePeek, MQ_LOOKUP_PEEK_NEXT, 0);
    ActpCloseHandle(hQueuePeek);

    //
    // Associate the queue for receive access and receive message
    //
    HANDLE hQueueReceive = ActpAssociateQueue(hQueue, MQ_RECEIVE_ACCESS);
    ULONGLONG LookupId0;
    LookupId0 = ActpReceiveMessage(hQueueReceive);

    if (LookupId != LookupId0)
    {
        wprintf(L"Received different LookupIDs for same message (Expected: Same LookupID)\n");
        throw exception();
    }

    ActpCloseHandle(hQueueReceive);

    //
    // Close handles
    //
    ActpCloseHandle(hQueue);

    wprintf(L"Success!\n");

} // ActpTestMessage


static
VOID
ActpTestHandleToFormatName(
    VOID
    )
/*++

Routine Description:

    Test AC API ACHandleToFormatName.

Arguments:

    None.

Return Value:

    None. Exception is raised on failure.

--*/
{
    wprintf(L"Testing AC API ACHandleToFormatName...\n");

    //
    // Create a queue
    //
    LPWSTR pFormatName = L"OS:shaik10\\private$\\AcTestQueue1";
    HANDLE hQueue = ActpCreateQueue(pFormatName);

    //
    // Get the format name
    //
    WCHAR FormatName[255];
    ActpHandleToFormatName(hQueue, FormatName, TABLE_SIZE(FormatName));

    if (wcsstr(FormatName, pFormatName) == NULL)
    {
        wprintf(L"ACHandleToFormatName returned unexpected format name '%s'\n", FormatName);
        throw exception();
    }

    //
    // Close handles
    //
    ActpCloseHandle(hQueue);

    wprintf(L"Success!\n");

} // ActpTestHandleToFormatName


static
VOID
ActpTestPurge(
    VOID
    )
/*++

Routine Description:

    Test AC API ACPurgeQueue.

Arguments:

    None.

Return Value:

    None. Exception is raised on failure.

--*/
{
    wprintf(L"Testing AC API ACPurgeQueue...\n");

    //
    // Create a queue and send some messages to it
    //
    LPWSTR pFormatName = L"OS:shaik10\\private$\\AcTestQueue1";
    HANDLE hQueue = ActpCreateQueue(pFormatName);
    HANDLE hQueueSend = ActpAssociateQueue(hQueue, MQ_SEND_ACCESS);
    for (DWORD ix = 0; ix < 3; ++ix)
    {
        ActpSendMessage(hQueueSend);
    }
    ActpCloseHandle(hQueueSend);

    //
    // Purge the queue
    //
    HANDLE hQueuePurge = ActpAssociateQueue(hQueue, MQ_RECEIVE_ACCESS);
    HRESULT hr;
    hr = ACPurgeQueue(hQueuePurge);

    if (FAILED(hr))
    {
        wprintf(L"ACPurgeQueue failed, status 0x%x\n", hr);
        throw exception();
    }

    //
    // Close handles
    //
    ActpCloseHandle(hQueuePurge);
    ActpCloseHandle(hQueue);

    wprintf(L"Success!\n");

} // ActpTestPurge


static
VOID
ActpTestDistribution(
    VOID
    )
/*++

Routine Description:

    Test AC API related to Distribution.

Arguments:

    None.

Return Value:

    None. Exception is raised on failure.

--*/
{
    wprintf(L"Testing AC APIs related to Distribution...\n");

    LPWSTR FormatName[2] = {L"OS:shaik10\\private$\\AcTestQueue0", L"OS:shaik10\\private$\\AcTestQueue1"};
    QUEUE_FORMAT qf[2] = {FormatName[0], FormatName[1]};
    bool HttpSend[2] = {false, false};
    HANDLE hQueue[2];

    //
    // Create member queues
    //
    hQueue[0] = ActpCreateQueue(FormatName[0]);
    hQueue[1] = ActpCreateQueue(FormatName[1]);
    ActpSetQueueProperties(hQueue[0]);
    ActpSetQueueProperties(hQueue[1]);

    //
    // Create a distribution
    //
    HANDLE hDistribution;
    HRESULT hr;
    hr = ACCreateDistribution(
             2, 
             hQueue, 
             HttpSend, 
             2,
             qf,
             &hDistribution
             );

    if (FAILED(hr))
    {
        wprintf(L"ACCreateDistribution failed, status 0x%x\n", hr);
        throw exception();
    }

    //
    // Send to distribution
    //
    HANDLE hDistributionSend = ActpAssociateQueue(hDistribution, MQ_SEND_ACCESS);
    ActpSendMessage(hDistributionSend);
    ActpCloseHandle(hDistributionSend);
    
    //
    // Receive from the member queues
    //
    HANDLE hQueueReceive0 = ActpAssociateQueue(hQueue[0], MQ_RECEIVE_ACCESS);
    HANDLE hQueueReceive1 = ActpAssociateQueue(hQueue[1], MQ_RECEIVE_ACCESS);
    ActpReceiveMessage(hQueueReceive0);
    ActpReceiveMessage(hQueueReceive1);
    ActpCloseHandle(hQueueReceive0);
    ActpCloseHandle(hQueueReceive1);

    //
    // Close handles
    //
    ActpCloseHandle(hDistribution);
    ActpCloseHandle(hQueue[0]);
    ActpCloseHandle(hQueue[1]);

    wprintf(L"Success!\n");

} // ActpTestDistribution


static
VOID
ActpTestPacket(
    VOID
    )
/*++

Routine Description:

    Test AC APIs for packet manipulation:

    ACPutPacket
    ACGetPacket
    ACFreePacket

Arguments:

    None.

Return Value:

    None. Exception is raised on failure.

--*/
{
    wprintf(L"Testing AC APIs for Packet manipulation...\n");

    //
    // Create the destination queue and send a message to it
    //
    HANDLE hQueue = ActpCreateQueue(L"OS:shaik10\\private$\\AcTestQueue1");
    ActpSetQueueProperties(hQueue);
    HANDLE hQueueSend = ActpAssociateQueue(hQueue, MQ_SEND_ACCESS);
    ActpSendMessage(hQueueSend);
    ActpCloseHandle(hQueueSend);

    //
    // Get packet
    //
    CPacket * pPacket1;
    pPacket1 = ActpGetPacket(hQueue);

    //
    // Put packet
    //
    ActpPutPacket(hQueue, pPacket1);

    //
    // Get packet again, verify it's the same packet
    //
    CPacket * pPacket2;
    pPacket2 = ActpGetPacket(hQueue);

    if (pPacket1 != pPacket2)
    {
        wprintf(L"ACGetPacket did not return the packet that ACPutPacket put\n");
        throw exception();
    }

    //
    // Free packet
    //
    ActpFreePacket(pPacket1);

    //
    // Close handles
    //
    ActpCloseHandle(hQueue);

    wprintf(L"Success!\n");

} // ActpTestPacket


static
VOID
ActpTestGroup(
    VOID
    )
/*++

Routine Description:

    Test AC APIs for group manipulation:

    ACCreateGroup
    ACMoveQueueToGroup

Arguments:

    None.

Return Value:

    None. Exception is raised on failure.

--*/
{
    wprintf(L"Testing AC APIs for Group manipulation...\n");

    //
    // Create group
    //
    HRESULT hr;
    HANDLE hGroup;
    hr = ACCreateGroup(&hGroup, FALSE);

    if (FAILED(hr))
    {
        wprintf(L"ACCreateGroup failed, status 0x%x\n", hr);
        throw exception();
    }

    //
    // Create queue
    //
    HANDLE hQueue = ActpCreateQueue(L"OS:shaik10\\private$\\AcTestQueue1");

    //
    // Move queue to group
    //
    hr = ACMoveQueueToGroup(hQueue, hGroup);
    if (FAILED(hr))
    {
        wprintf(L"ACMoveQueueToGroup failed, status 0x%x\n", hr);
        throw exception();
    }

    //
    // Close handles
    //
    ActpCloseHandle(hQueue);
    ActpCloseHandle(hGroup);

    wprintf(L"Success!\n");

} // ActpTestGroup


static
VOID
ActpTestAc(
    VOID
    )
/*++

Routine Description:

    Test AC APIs.
    Each test if self contained and there is no dependency on the order of tests.

Arguments:

    None.

Return Value:

    None. Exception is raised on failure.

--*/
{
    //
    // Test queue manipulation APIs: create, set/get props, associate, get handle props, can close, close.
    //
    ActpTestQueue();

    //
    // Test message manipulation APIs: send, receive, receive by lookupid.
    //
    ActpTestMessage();

    //
    // Test handle to format name APIs
    //
    ActpTestHandleToFormatName();

    //
    // Test purge APIs
    //
    ActpTestPurge();
   
    //
    // Test distribution related APIs: create, send, close.
    //
    ActpTestDistribution();

    //
    // Test packet manipulation APIs: get, put, free.
    //
    ActpTestPacket();

    //
    // Test group manipulation APIs: create, move.
    //
    ActpTestGroup();

} // ActpTestAc


extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
{
    try
    {
        ActpInitialize();

        ActpConnect2Ac();

        ActpTestAc();
    }
    catch (const bad_alloc&)
    {
        wprintf(L"bad_alloc exception, exiting...\n");
        return 1;
    }
    catch (const exception&)
    {
        wprintf(L"Exiting...\n");
        return 1;
    }

    wprintf(L"AcTest completed successfully.\n");
    return 0; 

} // _tmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\connect.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    connect.cpp

Abstract:

    Connect to AC: implementation.

Author:

    Shai Kariv  (shaik)  06-Jun-2000

Environment:

    User mode.

Revision History:

--*/

#include "stdh.h"
#include "connect.h"
#include "globals.h"

//
// AC name prefix. Hardcoded in mqutil.
//
static LPCWSTR x_DEVICE_DRIVER_PERFIX = L"\\\\.\\";

//
// AC name. Hardcoded in acapi.h, QM, RT, Local Admin.
//
WCHAR g_wzDeviceName[256];

//
// Handle to AC
//
static HANDLE s_hAc;


HANDLE
ActpAcHandle(
    VOID
    )
{
    return s_hAc;

} // ActpAcHandle


static
VOID
ActpStorageDirectory(
    UINT BufferLength,
    LPWSTR Buffer
    )
{
    ASSERT(("Buffer length must be at least MAX_PATH", BufferLength >= MAX_PATH));
    UINT rc = GetSystemDirectory(Buffer, BufferLength);
    if (rc == 0)
    {
        wprintf(L"GetSystemDirectory failed, status 0x%x\n", rc);
        throw exception();
    }

    wcscat(Buffer, L"\\MSMQ\\AcTest");

    wprintf(L"AcTest storage directory = %ls\n", Buffer);

} // ActpStorageDirectory


VOID
ActpConnect2Ac(
    VOID
    )
{
    WCHAR StorageDirectory[MAX_PATH];
    ActpStorageDirectory(
        MAX_PATH,
        StorageDirectory
        );

    C_ASSERT(AC_PATH_COUNT == 4);
    PWSTR StoragePathPointers[AC_PATH_COUNT];
    StoragePathPointers[0] = StorageDirectory;
    StoragePathPointers[1] = StorageDirectory;
    StoragePathPointers[2] = StorageDirectory;
    StoragePathPointers[3] = StorageDirectory;
     
    wcscpy(g_wzDeviceName, x_DEVICE_DRIVER_PERFIX);
    wcscat(g_wzDeviceName, MSMQ_DEFAULT_DRIVER) ;

    HRESULT rc = ACCreateHandle(&s_hAc);
    if(FAILED(rc))
    {
        wprintf(L"ACCreateHandle failed, status 0x%x. Failed to connect\n", rc);
        throw exception();
    }

    rc = ACConnect(
             ActpAcHandle(),
             ActpQmId(),
             StoragePathPointers,
             0,
             MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT,
             0,
             TRUE
             );
    if (FAILED(rc))
    {
        wprintf(L"ACConnect failed, status 0x%x\n", rc);
        throw exception();
    }

    wprintf(L"AcTest connected to AC\n");

} // ActpConnect2Ac
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\treenode.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    treenode.h

Abstract:

    Definitions for basic AVL tree node.

Author:

    Erez Haba (ErezH) Oct 20, 2001

Revision History:

--*/

#ifndef __TREENODE_H
#define __TREENODE_H


#pragma once

class CTreeNode {
public:
    void init();
    bool inserted() const;

protected:
    CTreeNode* m_pParent;
    CTreeNode* m_pRight;
    CTreeNode* m_pLeft;
    int m_height;
};



inline void CTreeNode::init()
{
    m_height=0;
    m_pParent=0;
    m_pRight=0;
    m_pLeft=0;    
}

inline bool CTreeNode::inserted() const
{
    return (m_height != 0);
}

#endif __TREENODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\connect.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    connect.h

Abstract:

    Connect to AC: declaration.

Author:

    Shai Kariv  (shaik)  06-Jun-2000

Environment:

    User mode.

Revision History:

--*/

#ifndef _ACTEST_CONNECT_H_
#define _ACTEST_CONNECT_H_


HANDLE
ActpAcHandle(
    VOID
    );

VOID
ActpConnect2Ac(
    VOID
    );


#endif // _ACTEST_CONNECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\globals.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    globals.cpp

Abstract:

    Global variables definition.

Author:

    Shai Kariv  (shaik)  06-Jun-2000

Environment:

    User mode.

Revision History:

--*/

#include "stdh.h"
#include "globals.h"

//
// QM Guid
//
static GUID s_QmId;

const GUID *
ActpQmId(
    VOID
    )
{
    return &s_QmId;
}

VOID
ActpQmId(
    GUID QmId
    )
{
    s_QmId = QmId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\handle.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    handle.h

Abstract:

    Handle manipulation: declaration.

Author:

    Shai Kariv  (shaik)  03-Jun-2001

Environment:

    User mode.

Revision History:

--*/

#ifndef _ACTEST_HANDLE_H_
#define _ACTEST_HANDLE_H_


VOID
ActpCloseHandle(
    HANDLE handle
    );

VOID
ActpHandleToFormatName(
    HANDLE hQueue,
    LPWSTR pFormatName,
    DWORD  FormatNameLength
    );

#endif // _ACTEST_HANDLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\globals.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    globals.h

Abstract:

    Global variables declaration.

Author:

    Shai Kariv  (shaik)  06-Jun-2000

Environment:

    User mode.

Revision History:

--*/

#ifndef _ACTEST_GLOBALS_H_
#define _ACTEST_GLOBALS_H_


//
// QM Guid
//
const GUID *
ActpQmId(
    VOID
    );

VOID
ActpQmId(
    GUID
    );


#endif // _ACTEST_GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\handle.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    handle.cpp

Abstract:

    Handle manipulation: implementation.

Author:

    Shai Kariv  (shaik)  03-Jun-2001

Environment:

    User mode.

Revision History:

--*/

#include "stdh.h"
#include "handle.h"


VOID
ActpCloseHandle(
    HANDLE handle
    )
{
    HRESULT hr;
    hr = ACCloseHandle(handle);

    if (FAILED(hr))
    {
        wprintf(L"ACCloseHandle failed, status 0x%x\n", hr);
        throw exception();
    }
} // ActpCloseHandle


VOID
ActpHandleToFormatName(
    HANDLE hQueue,
    LPWSTR pFormatName,
    DWORD  FormatNameLength
    )
{
    HRESULT hr;
    hr = ACHandleToFormatName(hQueue, pFormatName, &FormatNameLength);

    if (FAILED(hr))
    {
        wprintf(L"ACHandleToFormatName failed, status 0x%x\n", hr);
        throw exception();
    }
} // ActpHandleToFormatName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\message.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    message.h

Abstract:

    Message manipulation: declaration.

Author:

    Shai Kariv  (shaik)  11-Apr-2001

Environment:

    User mode.

Revision History:

--*/

#ifndef _ACTEST_MESSAGE_H_
#define _ACTEST_MESSAGE_H_


VOID
ActpSendMessage(
    HANDLE hQueue
    );

ULONGLONG
ActpReceiveMessage(
    HANDLE    hQueue
    );

ULONGLONG
ActpReceiveMessageByLookupId(
    HANDLE    hQueue,
    ULONG     Action,
    ULONGLONG LookupId
    );


#endif // _ACTEST_MESSAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\init.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    init.cpp

Abstract:

    Initialization implementation.

Author:

    Shai Kariv  (shaik)  06-Jun-2000

Environment:

    User mode.

Revision History:

--*/

#include "stdh.h"
#include "init.h"
#include "globals.h"

VOID
ActpInitialize(
    VOID
    )
{
    TrInitialize();

    GUID QmId = {0x04902a24, 0x4587, 0x4c60, {0xa5, 0x06, 0x35, 0x7c, 0x8f, 0x14, 0x8b}};
    ActpQmId(QmId);

} // ActpInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\init.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    init.h

Abstract:

    Initialization declaration.

Author:

    Shai Kariv  (shaik)  06-Jun-2000

Environment:

    User mode.

Revision History:

--*/

#ifndef _ACTEST_INIT_H_
#define _ACTEST_INIT_H_


VOID
ActpInitialize(
    VOID
    );


#endif // _ACTEST_INIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\packet.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    packet.h

Abstract:

    Packet manipulation: declaration.

Author:

    Shai Kariv  (shaik)  04-Jun-2001

Environment:

    User mode.

Revision History:

--*/

#ifndef _ACTEST_PACKET_H_
#define _ACTEST_PACKET_H_


CPacket*
ActpGetPacket(
    HANDLE hQueue
    );

VOID
ActpPutPacket(
    HANDLE    hQueue,
    CPacket * pPacket
    );

VOID
ActpFreePacket(
    CPacket * pPacket
    );


#endif // _ACTEST_PACKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\queue.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    queue.cpp

Abstract:

    Queue manipulation: implementation.

Author:

    Shai Kariv  (shaik)  13-Jun-2000

Environment:

    User mode.

Revision History:

--*/

#include "stdh.h"
#include "queue.h"
#include "globals.h"


HANDLE
ActpCreateQueue(
    LPWSTR pFormatName
    )
{
    QUEUE_FORMAT qf(pFormatName);

    HANDLE hQueue;
    HRESULT hr;
    hr = ACCreateQueue(
             TRUE,          // fTargetQueue
             ActpQmId(),    // pDestGUID
             &qf,           // pQueueID
             NULL,          // pQueueCounters
             5,             // liSeqID
             0,             // ulSeqNo
             NULL,          // SenderStream
             &hQueue
             );

    if (FAILED(hr))
    {
        wprintf(L"ACCreateQueue failed, status 0x%x\n", hr);
        throw exception();
    }

    return hQueue;

} // ActpCreateQueue


VOID
ActpSetQueueProperties(
    HANDLE hQueue
    )
{
    HRESULT hr;
    hr = ACSetQueueProperties(
             hQueue,
             FALSE,                            // IsJournalQueue
             FALSE,                            // ShouldMessagesBeSigned
             MQMSG_PRIV_LEVEL_NONE,            // GetPrivLevel
             DEFAULT_Q_QUOTA,                  // GetQueueQuota
             DEFAULT_Q_JOURNAL_QUOTA,          // GetJournalQueueQuota
             DEFAULT_Q_BASEPRIORITY,           // GetBaseQueuePriority
             FALSE,                            // IsTransactionalQueue
             NULL,                             // GetConnectorQM
             FALSE                             // IsUnkownQueueType
             );

    if (FAILED(hr))
    {
        wprintf(L"ACSetQueueProperties failed, status 0x%x\n", hr);
        throw exception();
    }
} // ActpSetQueueProperties


VOID
ActpGetQueueProperties(
    HANDLE hQueue
    )
{
    HRESULT hr;
    CACGetQueueProperties qp;
    hr = ACGetQueueProperties(hQueue, qp);

    if (FAILED(hr))
    {
        wprintf(L"ACGetQueueProperties failed, status 0x%x\n", hr);
        throw exception();
    }

    if (qp.ulJournalCount != 0)
    {
        wprintf(L"ACGetQueueProperties succeeded but returned ulJournalCount != 0\n");
        throw exception();
    }
} // ActpGetQueueProperties


VOID
ActpGetQueueHandleProperties(
    HANDLE hQueue
    )
{
    HRESULT hr;
    CACGetQueueHandleProperties qhp;
    hr = ACGetQueueHandleProperties(hQueue, qhp);

    if (FAILED(hr))
    {
        wprintf(L"ACGetQueueHandleProperties failed, status 0x%x\n", hr);
        throw exception();
    }

    if (qhp.fProtocolSrmp)
    {
        wprintf(L"ACGetQueueHandleProperties succeeded but returned fProtocolSrmp == true\n");
        throw exception();
    }

    if (!qhp.fProtocolMsmq)
    {
        wprintf(L"ACGetQueueHandleProperties succeeded but returned fProtocolMsmq == false\n");
        throw exception();
    }
} // ActpGetQueueHandleProperties


HANDLE
ActpAssociateQueue(
    HANDLE hQueue,
    DWORD  Access
    )
{
    HANDLE hAssociatedQueue;
    HRESULT hr;
    hr = ACCreateHandle(&hAssociatedQueue);
    if (FAILED(hr))
    {
        wprintf(L"ACCreateHandle failed, status 0x%x\n", hr);
        throw exception();
    }

    hr = ACAssociateQueue(
             hQueue, 
             hAssociatedQueue, 
             Access, 
             MQ_DENY_NONE, 
             FALSE                // fProtocolSrmp
             );

    if (FAILED(hr))
    {
        wprintf(L"ACAssociateQueue failed, status 0x%x\n", hr);
        throw exception();
    }

    return hAssociatedQueue;

} // ActpAssociateQueue


bool
ActpCanCloseQueue(
    HANDLE hQueue
    )
{
    HRESULT hr;
    hr = ACCanCloseQueue(hQueue);

    if (hr == STATUS_HANDLE_NOT_CLOSABLE)
    {
        return false;
    }

    if (FAILED(hr))
    {
        wprintf(L"ACCanCloseQueue failed, status 0x%x\n", hr);
        throw exception();
    }

    return true;

} // ActpCanCloseQueue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\packet.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    packet.cpp

Abstract:

    Packet manipulation: implementation.

Author:

    Shai Kariv  (shaik)  04-Jun-2001

Environment:

    User mode.

Revision History:

--*/

#include "stdh.h"
#include "packet.h"
#include "connect.h"


CPacket*
ActpGetPacket(
    HANDLE hQueue
    )
{
    OVERLAPPED ov = {0};
    CACPacketPtrs ptrs;
    HRESULT hr;
    hr = ACGetPacket(hQueue, ptrs, &ov);

    if (FAILED(hr))
    {
        wprintf(L"ACGetPacket failed, status 0x%x\n", hr);
        throw exception();
    }

    if (hr == STATUS_PENDING)
    {
        wprintf(L"ACGetPacket returned STATUS_PENDING (Expected: STATUS_SUCCESS)\n", hr);
        throw exception();
    }

    return ptrs.pDriverPacket;

} // ActpGetPacket


VOID
ActpPutPacket(
    HANDLE    hQueue,
    CPacket * pPacket
    )
{
    OVERLAPPED ov = {0};
    HRESULT hr;
    hr = ACPutPacket(hQueue, pPacket, &ov);

    if (FAILED(hr))
    {
        wprintf(L"ACPutPacket failed, status 0x%x\n", hr);
        throw exception();
    }

    if (hr == STATUS_PENDING)
    {
        wprintf(L"ACPutPacket returned STATUS_PENDING (Expected: STATUS_SUCCESS)\n", hr);
        throw exception();
    }
} // ActpPutPacket


VOID
ActpFreePacket(
    CPacket * pPacket
    )
{
    HRESULT hr;
    hr = ACFreePacket(ActpAcHandle(), pPacket);
    if (FAILED(hr))
    {
        wprintf(L"ACFreePacket failed, status 0x%x\n", hr);
        throw exception();
    }
} // ActpFreePacket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\message.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    message.cpp

Abstract:

    Message manipulation: implementation.

Author:

    Shai Kariv  (shaik)  11-Apr-2001

Environment:

    User mode.

Revision History:

--*/

#include "stdh.h"
#include <mqcrypt.h>
#include "message.h"


VOID
ActpSendMessage(
    HANDLE hQueue
    )
/*++

Routine Description:

    Encapsulate ACSendMessage.

Arguments:

    hQueue - Handle of the queue to send to.

Return Value:

    None. Exception is thrown in case of failure.

--*/
{
    CACSendParameters SendParams;

    SendParams.MsgProps.fDefaultProvider = TRUE;

    ULONG ulDefHashAlg = CALG_SHA1;
    SendParams.MsgProps.pulHashAlg = &ulDefHashAlg;

    ULONG ulDefEncryptAlg = PROPID_M_DEFUALT_ENCRYPT_ALG;
    SendParams.MsgProps.pulEncryptAlg = &ulDefEncryptAlg;
    
    ULONG ulDefPrivLevel = DEFAULT_M_PRIV_LEVEL;
    SendParams.MsgProps.pulPrivLevel = &ulDefPrivLevel;

    ULONG ulDefSenderIdType = DEFAULT_M_SENDERID_TYPE;
    SendParams.MsgProps.pulSenderIDType = &ulDefSenderIdType;

    LPWSTR pSoapHeader = L"SoapHeader";
    SendParams.ppSoapHeader = &pSoapHeader;

    LPWSTR pSoapBody = L"SoapBody";
    SendParams.ppSoapBody = &pSoapBody;

    OVERLAPPED ov = {0};

    HRESULT hr = ACSendMessage(hQueue, SendParams, &ov);
    if (FAILED(hr))
    {
        wprintf(L"ACSendMessage failed, status 0x%x\n", hr);
        throw exception();
    }

    if (hr == STATUS_PENDING)
    {
        wprintf(L"ACSendMessage returned STATUS_PENDING (Expected: STATUS_SUCCESS)\n", hr);
        throw exception();
    }

} // ActpSendMessage


ULONGLONG
ActpReceiveMessage(
    HANDLE hQueue
    )
/*++

Routine Description:

    Encapsulate ACReceiveMessage.

Arguments:

    hQueue - Handle of the queue to receive from.

Return Value:

    LookupId of the received message. Exception is thrown in case of failure.

--*/
{
    CACReceiveParameters ReceiveParams;

    ULONGLONG LookupId = 0;
    ReceiveParams.MsgProps.pLookupId = &LookupId;

    OVERLAPPED ov = {0};
    ov.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (ov.hEvent == NULL)
    {
        DWORD error = GetLastError();
        wprintf(L"CreateEvent failed, error %d\n", error);
        throw exception();
    }

    //
    // Set the Event first bit to disable completion port posting
    //
    ov.hEvent = (HANDLE)((DWORD_PTR)ov.hEvent | (DWORD_PTR)0x1);

    HRESULT hr;
    hr = ACReceiveMessage(hQueue, ReceiveParams, &ov);

    if (hr == STATUS_PENDING)
    {
        DWORD rc = WaitForSingleObject(ov.hEvent, INFINITE);
        ASSERT(rc == WAIT_OBJECT_0);
        DBG_USED(rc);
        hr = DWORD_PTR_TO_DWORD(ov.Internal);
    }

    CloseHandle(ov.hEvent);

    if (FAILED(hr))
    {
        wprintf(L"Receive Message failed, status 0x%x\n", hr);
        throw exception();
    }

    return LookupId;

} // ActpReceiveMessage


ULONGLONG
ActpReceiveMessageByLookupId(
    HANDLE    hQueue,
    ULONG     Action,
    ULONGLONG LookupId
    )
/*++

Routine Description:

    Encapsulate ACReceiveMessageByLookupId.

Arguments:

    hQueue   - Handle of the queue to receive from.

    Action   - Receive action to perform (e.g. MQ_LOOKUP_PEEK_FIRST).

    LookupId - Identifies the message to lookup.

Return Value:

    LookupId of the received message. Exception is thrown in case of failure.

--*/
{
    CACReceiveParameters ReceiveParams;
    ReceiveParams.Action = Action;
    ReceiveParams.LookupId = LookupId;

    ULONGLONG LookupId0 = 0;
    ReceiveParams.MsgProps.pLookupId = &LookupId0;

    OVERLAPPED ov = {0};
    ov.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (ov.hEvent == NULL)
    {
        DWORD error = GetLastError();
        wprintf(L"CreateEvent failed, error %d\n", error);
        throw exception();
    }

    //
    // Set the Event first bit to disable completion port posting
    //
    ov.hEvent = (HANDLE)((DWORD_PTR)ov.hEvent | (DWORD_PTR)0x1);

    HRESULT hr;
    hr = ACReceiveMessageByLookupId(hQueue, ReceiveParams, &ov);

    CloseHandle(ov.hEvent);

    if (FAILED(hr))
    {
        wprintf(L"Receive Message by LookupId failed, status 0x%x\n", hr);
        throw exception();
    }

    return LookupId0;

} // ActpReceiveMessageByLookupId
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\queue.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    queue.h

Abstract:

    Queue manipulation: declaration.

Author:

    Shai Kariv  (shaik)  13-Jun-2000

Environment:

    User mode.

Revision History:

--*/

#ifndef _ACTEST_QUEUE_H_
#define _ACTEST_QUEUE_H_


HANDLE
ActpCreateQueue(
    LPWSTR pFormatName
    );

VOID
ActpSetQueueProperties(
    HANDLE hQueue
    );

VOID
ActpGetQueueProperties(
    HANDLE hQueue
    );

VOID
ActpGetQueueHandleProperties(
    HANDLE hQueue
    );

HANDLE
ActpAssociateQueue(
    HANDLE hQueue,
    DWORD  Access
    );

bool
ActpCanCloseQueue(
    HANDLE hQueue
    );

#endif // _ACTEST_QUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\winnt\mm.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mm.h

Abstract:

    Falcon AC device driver memory managment

Author:

    Erez Haba (erezh) 1-Aug-95

Revision History:
--*/

#ifndef _MM_H
#define _MM_H

// --- implementation -----------------
//
//  Allocators
//
inline void* _cdecl operator new(size_t n, POOL_TYPE pool, EX_POOL_PRIORITY priority = LowPoolPriority)
{
    return ExAllocatePoolWithTagPriority(pool, n, 'CAQM', priority);
}


inline void _cdecl operator delete(void* p)
{
    if(p != 0)
    {
        ExFreePool(p);
    }
}


// --- implementation -----------------
//
//  Placement operators
//

inline void* _cdecl operator new(size_t /*size*/, void* p)
{
    //
    //  This is a placement operator new. The caller provide its own
    //  buffer to put the object in
    //

    return p;
}

#endif // _MM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\test\stdh.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Standard header file used for precompilation.

Author:

    Shai Kariv  (shaik)  06-Jun-2000

Environment:

    User mode.

Revision History:

--*/


#ifndef _ACTEST_STDH_H_
#define _ACTEST_STDH_H_


#include <libpch.h>
#include <mqprops.h>
#include <mqwin64a.h>
#include <mqsymbls.h>
#include <_mqini.h>
#include <ac.h>
#include <qformat.h>


#endif // _ACTEST_STDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\winnt\platform.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    platform.h

Abstract:

    NT DDK, platform dependent include header

Author:

    Erez Haba (erezh) 1-Sep-96

Revision History:
--*/

#ifndef _PLATFORM_H
#define _PLATFORM_H

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#pragma warning(disable: 4324)  //  '__unnamed' : structure was padded due to __declspec(align())

extern "C" {
#include <ntosp.h>
#include <evntrace.h>
#include <wmikm.h>
#include <zwapi.h>

#include <wmistr.h>

NTKERNELAPI
NTSTATUS
MmMapViewInSystemSpace (
    IN PVOID Section,
    OUT PVOID *MappedBase,
    IN PSIZE_T ViewSize
    );

NTKERNELAPI
NTSTATUS
MmUnmapViewInSystemSpace (
    IN PVOID MappedBase
    );
}

#define ExDeleteFastMutex(a)
#define ACpCloseSection(a)          ObDereferenceObject(a)

#define DOSDEVICES_PATH L"\\DosDevices\\"
#define UNC_PATH L"UNC\\"
#define UNC_PATH_SKIP 2

//
//  Definition of BOOL as in windef.h
//
typedef int BOOL;

typedef int INT;
typedef unsigned short WORD;
typedef unsigned long DWORD;
#define LOWORD(l)           ((WORD)((DWORD_PTR)(l) & 0xffff))
#define HIWORD(l)           ((WORD)((DWORD_PTR)(l) >> 16))

//
//  ASSERT macros that work on NT free builds
//
//
#if !defined(_AC_NT_CHECKED_) && defined(_DEBUG)

#undef ASSERT
#undef ASSERTMSG

#define ASSERT(exp) \
    if(!(exp)) {\
        KdPrint(("\n\n"\
                "*** Assertion failed: %s\n"\
                "***   Source File: %s, line %i\n\n",\
                #exp, __FILE__, __LINE__));\
        KdBreakPoint(); }

#define ASSERTMSG(msg, exp) \
    if(!(exp)) {\
        KdPrint(("\n\n"\
                "*** Assertion failed: %s\n"\
                "***   '%s'\n"\
                "***   Source File: %s, line %i\n\n",\
                #exp, msg, __FILE__, __LINE__));\
        KdBreakPoint(); }

#endif // !_AC_NT_CHECKED_

#include "mm.h"

#endif // _PLATFORM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\win95\platform.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    platform.h

Abstract:

    Win95 platform dependent include header

Author:

    Erez Haba (erezh) 1-Sep-96

Revision History:
--*/

#ifndef _PLATFORM_H
#define _PLATFORM_H

#pragma warning(disable: 4100)
#pragma warning(disable: 4101)
#pragma warning(disable: 4127) // conditional expression is constant
#pragma warning(disable: 4189) // local variable is initialized but not referenced

#define STRICT
#define WIN32_EXTRA_LEAN

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif


#define NOSERVICE
#define NOMCX          
#define NOIME           
#define INC_OLE2
#define WIN32_NO_STATUS
#define _NTSYSTEM_

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#include <windows.h>
#include <stddef.h>

#pragma warning(disable: 4201) // nameless struct/union

//
//  We include all NT status codes
//
#undef WIN32_NO_STATUS
#define NTSTATUS HRESULT
#include <ntstatus.h>
#include <assert.h>
#include <new.h>

extern "C"
{
#include "ntdef95.h"
#include "ntddk95.h"
#include "..\ntp.h"
}
//
//  Collision with CTimer::GetCurrentTime
//
#undef GetCurrentTime

#define RtlFreeAnsiString(a)
#define RtlUnicodeStringToAnsiString(a, b, c)

//
//  BUGBUG: return value not 100% compatible with RtlCompareMemory
//
#define RtlCompareMemory(a, b, c)                   ((memcmp(a, b, c) == 0) ? (c) : 0)

 #undef ObDereferenceObject
#define ObDereferenceObject(a)
#define ObReferenceObjectByHandle(a, b, c, d, e, f) (((*e = a)), STATUS_SUCCESS)

 #undef ExInitializeFastMutex
#define ExInitializeFastMutex(a)                    InitializeCriticalSection(a)
#define ExAcquireFastMutex(a)						EnterCriticalSection(a)
#define ExReleaseFastMutex(a)						LeaveCriticalSection(a)
#define ExAcquireFastMutexUnsafe(a) 				EnterCriticalSection(a)
#define ExReleaseFastMutexUnsafe(a)					LeaveCriticalSection(a)
#define ExDeleteFastMutex(a)                        DeleteCriticalSection(a)

//
//  do nothing since memory *should be* in user address space
//
#define ExRaiseAccessViolation()

#define ExQueueWorkItem(a, b)                       ((a)->WorkerRoutine((a)->Parameter))
#define IoAllocateWorkItem(a)                       ((PIO_WORKITEM)1)
#define IoFreeWorkItem(a)                           
#define IoQueueWorkItem(a, b, c, d)                 (b(0, d))

#define MmUnmapViewInSystemSpace(a)                 STATUS_SUCCESS
#define MmMapViewInSystemSpace(a, b, c)             STATUS_SUCCESS

#define IoDeleteDevice(a)                           STATUS_SUCCESS
#define IoCreateSymbolicLink(a, b)                  STATUS_SUCCESS
#define IoDeleteSymbolicLink(a)                     STATUS_SUCCESS
#define IoGetRequestorProcess(irp)                  ((PEPROCESS)1)
#define IoGetCurrentProcess()                       ((PEPROCESS)1)

#define KeDetachProcess()
#define KeEnterCriticalRegion()                   
#define KeLeaveCriticalRegion()                   
#define KeAttachProcess(a)
#define KeBugCheck(a)                               exit(a)
#define DbgBreakPoint()                             exit(1)
#define KeInitializeDpc(d, b, c)                    ((void)(((d)->DeferredRoutine = b), ((d)->DeferredContext = c)))
#define KeInitializeTimer(a)
#define KeQuerySystemTime(a)                        GetSystemTimeAsFileTime((FILETIME*)(a))

#define ACpCloseSection(a)                          CloseHandle(a)
#define WPP_INIT_TRACING(a, b)
#define WPP_CLEANUP(a)

#define DOSDEVICES_PATH L""
#define UNC_PATH L""
#define UNC_PATH_SKIP 0
#define WPP_LEVEL_COMPID_ENABLED(a, b) 0

extern void TrERROR(...);
extern void TrWARNING(...);
extern void TrTRACE(...);

const ULONG AC = 0;
const ULONG PROFILING=1;

//
//  Pool Allocator
//
inline void* _cdecl operator new(size_t n, POOL_TYPE /*pool*/, EX_POOL_PRIORITY priority = LowPoolPriority)
{
	(void)priority;
    return ::operator new(n);
}

inline PVOID ExAllocatePoolWithTag(IN POOL_TYPE /*PoolType*/, IN ULONG NumberOfBytes, IN ULONG /*Tag*/)
{
    return new char[NumberOfBytes];
} 


#endif // _PLATFORM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\win95\ntdef95.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ntdef.h

Abstract:

    Type definitions for the basic types.

Author:

    Mark Lucovsky (markl)   02-Feb-1989

Revision History:

--*/

#ifndef _NTDEF_
#define _NTDEF_


// begin_ntminiport begin_ntndis

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#endif


#ifndef CONST
#define CONST               const
#endif


//
// Void
//


// end_ntminiport end_ntndis



typedef double DOUBLE;

typedef struct _QUAD {              // QUAD is for those times we want
    double  DoNotUseThisField;      // an 8 byte aligned 8 byte long structure
} QUAD;                             // which is NOT really a floating point
                                    // number.  Use DOUBLE if you want an FP
                                    // number.

//
// Pointer to Basics
//

typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

// end_ntminiport end_ntndis

//
// NLS basics (Locale and Language Ids)
//


// begin_ntndis
//
// NTSTATUS
//

typedef LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)


// end_ntndis
//
// Large (64-bit) integer types and operations
//

#define TIME LARGE_INTEGER
#define _TIME _LARGE_INTEGER
#define PTIME PLARGE_INTEGER
#define LowTime LowPart
#define HighTime HighPart


// begin_ntminiport begin_ntndis

//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS; // windbgkd

// end_ntminiport end_ntndis


//
// Event type
//

typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
    } EVENT_TYPE;

//
// Wait type
//

typedef enum _WAIT_TYPE {
    WaitAll,
    WaitAny
    } WAIT_TYPE;

//
// Pointer to an Asciiz string
//

typedef CHAR *PSZ;
typedef CONST char *PCSZ;

// begin_ntndis
//
// Counted String
//

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength), length_is(Length) ]
#endif // MIDL_PASS
    PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;

//
// CONSTCounted String
//

typedef struct _CSTRING {
    USHORT Length;
    USHORT MaximumLength;
    CONST char *Buffer;
} CSTRING;
typedef CSTRING *PCSTRING;

typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;

//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;

// begin_ntminiport

//
// Boolean
//


// end_ntminiport



//
// Valid values for the Attributes field
//

#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_VALID_ATTRIBUTES    0x000000F2L
#define OBJ_KERNEL_HANDLE       0x00000200L

//
// Object Attributes structure
//

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

//++
//
// VOID
// InitializeObjectAttributes(
//     OUT POBJECT_ATTRIBUTES p,
//     IN PUNICODE_STRING n,
//     IN ULONG a,
//     IN HANDLE r,
//     IN PSECURITY_DESCRIPTOR s
//     )
//
//--

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

// begin_ntminiport begin_ntndis

//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif // NULL

// end_ntminiport end_ntndis




//
// Useful Helper Macros
//

// begin_ntndis
//
// Determine if an argument is present by testing the value of the pointer
// to the argument value.
//

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )


//
// Exception handler routine definition.
//

struct _CONTEXT;
struct _EXCEPTION_RECORD;

typedef
EXCEPTION_DISPOSITION
(*PEXCEPTION_ROUTINE) (
    IN struct _EXCEPTION_RECORD *ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT struct _CONTEXT *ContextRecord,
    IN OUT PVOID DispatcherContext
    );

// begin_ntminiport begin_ntndis

//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;

// end_ntminiport end_ntndis

//
// Product types
//

typedef enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt,
    NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;





#endif // _NTDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\lib\utilx.h ===
//=--------------------------------------------------------------------------=
// utilx.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// utilities header
//
//
#ifndef _UTILX_H_

// Falcon is UNICODE
#ifndef UNICODE
#define UNICODE 1
#endif

#include "time.h"
#include "oaidl.h"


// useful VARIANT helpers...
extern UINT GetNumber(VARIANT *pvar, UINT uiDefault);
extern BOOL GetBool(VARIANT *pvar);
extern BSTR GetBstr(VARIANT *pvar);
extern HRESULT GetTrueBstr(VARIANT *pvar, BSTR *pbstr);
extern IUnknown *GetPunk(VARIANT *pvar);
extern IDispatch *GetPdisp(VARIANT *pvar);
extern double GetDateVal(VARIANT *pvar);
extern HRESULT GetSafeArrayDataOfVariant(
    VARIANT *pvarSrc,
    BYTE **ppbBuf,
    ULONG *pcbBuf);
extern HRESULT GetSafeArrayOfVariant(
    VARIANT *pvarSrc,
    BYTE **prgbBuf,
    ULONG *pcbBuf);
extern HRESULT PutSafeArrayOfBuffer(
    BYTE *rgbBuf,
    UINT cbBuf,
    VARIANT FAR* pvarDest);
extern HRESULT GetDefaultPropertyOfVariant(
    VARIANT *pvar, 
    VARIANT *pvarDefault);
extern HRESULT GetNewEnumOfObject(
    IDispatch *pdisp, 
    IEnumVARIANT *ppenum);
extern BOOL TimeToVariantTime(time_t iTime, double *pvtime);
extern BOOL VariantTimeToTime(VARIANT *pvarTime, time_t *piTime);
extern HRESULT GetVariantTimeOfTime(time_t iTime, VARIANT FAR* pvarTime);

// useful formatname helpers...
// stolen from rt
#define SPECIAL_QUEUE_DELIMITER L';'
#define JOURNAL_QUEUE_INDICATOR L";JOURNAL"
#define JOURNAL_QUEUE_INDICATOR_LENGTH (sizeof(JOURNAL_QUEUE_INDICATOR)/sizeof(WCHAR)-1)
#define DEADLETTER_QUEUE_INDICATOR L";DEADLETTER"
#define DEADLETTER_QUEUE_INDICATOR_LENGTH (sizeof(DEADLETTER_QUEUE_INDICATOR)/sizeof(WCHAR)-1)

#define MACHINE_QUEUE_INDICATOR L"MACHINE"
#define MACHINE_QUEUE_INDICATOR_LENGTH (sizeof(MACHINE_QUEUE_INDICATOR)/sizeof(WCHAR)-1)

#define CONNECTOR_QUEUE_INDICATOR L"CONNECTOR"
#define CONNECTOR_QUEUE_INDICATOR_LENGTH (sizeof(CONNECTOR_QUEUE_INDICATOR)/sizeof(WCHAR)-1)

#define PRIVATE_QUEUE_INDICATOR_LENGTH (sizeof(PRIVATE_QUEUE_INDICATOR)/sizeof(WCHAR)-1)
#define PUBLIC_QUEUE_INDICATOR_LENGTH  (sizeof(PUBLIC_QUEUE_INDICATOR )/sizeof(WCHAR)-1)
#define DIRECT_QUEUE_INDICATOR_LENGTH  (sizeof(DIRECT_QUEUE_INDICATOR )/sizeof(WCHAR)-1)
#define DIRECT_ANY_QUEUE_INDICATOR_LENGTH  (sizeof(DIRECT_ANY_QUEUE_INDICATOR )/sizeof(WCHAR)-1)
#define DIRECT_TCP_QUEUE_INDICATOR_LENGTH  (sizeof(DIRECT_TCP_QUEUE_INDICATOR )/sizeof(WCHAR)-1)
#define DIRECT_SPX_QUEUE_INDICATOR_LENGTH  (sizeof(DIRECT_SPX_QUEUE_INDICATOR )/sizeof(WCHAR)-1)

//
// UNDONE: undef since defined in mqprops.h
//
#undef  PRIVATE_QUEUE_PATH_INDICATIOR
#define PRIVATE_QUEUE_PATH_INDICATIOR L"PRIVATE$"
#define PRIVATE_QUEUE_INDICATOR L"PRIVATE"
#define PUBLIC_QUEUE_INDICATOR L"PUBLIC"
#define DIRECT_QUEUE_INDICATOR L"DIRECT"
#define DIRECT_ANY_QUEUE_INDICATOR L"OS:"
#define DIRECT_TCP_QUEUE_INDICATOR L"TCP:"
#define DIRECT_SPX_QUEUE_INDICATOR L"SPX:"
#define PATH_DELIMITERS L"\\/"
#define FORMAT_NAME_EQUAL_SIGN L'='
#define OUT_PATH_DELIMITER L'\\'
#define LOCAL_MACHINE_SPECIFICATION L'.'

enum QUEUE_FORMAT_TYPE {
    QUEUE_FORMAT_TYPE_UNKNOWN = 0,
    QUEUE_FORMAT_TYPE_PUBLIC,
    QUEUE_FORMAT_TYPE_PRIVATE,
    QUEUE_FORMAT_TYPE_DIRECT,
    QUEUE_FORMAT_TYPE_MACHINE,
    QUEUE_FORMAT_TYPE_CONNECTOR,
};

extern QUEUE_FORMAT_TYPE GetFormatNameType(BSTR bstrFormatName);
extern BOOL IsPrivateQueueOfFormatName(BSTR bstrFormatName);
extern BOOL IsPublicQueueOfFormatName(BSTR bstrFormatName);
extern BOOL IsDirectQueueOfFormatName(BSTR bstrFormatName);


// Some useful macros
#define RELEASE(punk) if (punk) { (punk)->Release(); (punk) = NULL; }
#define ADDREF(punk) ((punk) ? (punk)->AddRef() : 0)
#define GLOBALFREE(hMem) if (hMem) { \
                           HGLOBAL hMemFree = GlobalFree(hMem); \
                           ASSERTMSG(hMemFree == NULL, "GlobalFree failed."); \
                           UNREFERENCED_PARAMETER(hMemFree); \
                           hMem = NULL; \
                         }
#define GLOBALALLOC_MOVEABLE_NONDISCARD(cbBody) GlobalAlloc( \
                       GMEM_MOVEABLE | GMEM_NODISCARD, \
                       cbBody)
#define GLOBALUNLOCK(hMem) if (hMem) { \
							if (!GlobalUnlock(hMem)) \
							{ \
								DWORD dwErr = GetLastError(); \
	      						ASSERTMSG(dwErr == NO_ERROR, "GlobalUnlock failed."); \
	                            UNREFERENCED_PARAMETER(dwErr); \
							} \
                           }
#define ARRAYSIZE(array) (sizeof(array) / sizeof(array[0]))

//
// The following are the correct/current OLE failure code macros
//
#define IfFailRet(s) { \
	hresult = (s); \
	if(FAILED(GetScode(hresult))){ \
          return hresult; }}
#define IfFailGo(s) { \
	hresult = (s); \
	if(FAILED(GetScode(hresult))){ \
	  goto Error; }}
#define IfFailGoTo(s, label) { \
	hresult = (s); \
	if(FAILED(GetScode(hresult))){ \
	  goto label; }}

#define IfNullFail(s) { \
      	if ((s)== NULL) { \
      	  hresult = ResultFromScode(E_OUTOFMEMORY); \
      	  goto Error;}}
#define IfNullRet(s) { \
	if ((s)== NULL) { \
	  return ResultFromScode(E_OUTOFMEMORY); }}
//
// BUGBUG: RaananH - there is a bug in the below macro usage - it doesn't set hresult
// but in most places it is used it is assumed hresult is set.
//
#define IfNullGo(s) { \
	if ((s)== NULL) { \
	  goto Error; }}
#define IfNullGoTo(s, label) { \
	if ((s)== NULL) { \
	  goto label; }}

#define IfFalseFailLastError(s) { \
	  if (!(s)) { \
	    hresult = GetLastError(); \
	    if (SUCCEEDED(hresult)) { \
              hresult = E_FAIL; \
            } \
	    goto Error; \
          } \
        }

// String macros
#define SYSALLOCSTRING(s) ((s == NULL) ? SysAllocString(L"") : SysAllocString(s))

#if 0
// Memory tracking allocation
void* __cdecl operator new(
    size_t nSize, 
    LPCSTR lpszFileName, 
    int nLine);
#ifdef _DEBUG
#define DEBUG_NEW new(__FILE__, __LINE__)
#else
#define DEBUG_NEW new
#endif // _DEBUG

// bstr tracking
void DebSysFreeString(BSTR bstr);
BSTR DebSysAllocString(const OLECHAR FAR* sz);
BSTR DebSysAllocStringLen(const OLECHAR *sz, unsigned int cch);
BSTR DebSysAllocStringByteLen(const OLECHAR *sz, unsigned int cb);
BOOL DebSysReAllocString(BSTR *pbstr, const OLECHAR *sz);
BOOL DebSysReAllocStringLen(
    BSTR *pbstr, 
    const OLECHAR *sz, 
    unsigned int cch);
#endif // 0


// UNDONE: there must be a WIN32 const for this...
#define LENSTRCLSID 38

extern BOOL GetMessageOfError(DWORD dwMsgId, BSTR *pbstrMessage);
extern BOOL GetMessageOfId(DWORD dwMsgId, LPSTR szDllFile, BOOL fUseDefaultLcid, BSTR *pbstrMessage);
extern HRESULT CreateError(
    HRESULT hrExcep,
    GUID *pguid,
    LPSTR szName);

#define _UTILX_H_
#endif // _UTILX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\ac\win95\ntddk95.h ===
/*++ BUILD Version: 0185    // Increment this if a change has global effects

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    ntddk.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed to device drivers.

Revision History:

--*/

#ifndef _NTDDK_
#define _NTDDK_

#define NT_INCLUDED
#define _CTYPE_DISABLE_MACROS

//
// Define types that are not exported.
//

typedef struct _KTHREAD *PKTHREAD;
typedef struct _ETHREAD *PETHREAD;
typedef struct _EPROCESS *PEPROCESS;
typedef struct _PEB *PPEB;
typedef struct _KINTERRUPT *PKINTERRUPT;
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;

#if defined(_M_ALPHA)
void *__rdthread(void);
#pragma intrinsic(__rdthread)

unsigned char __swpirql(unsigned char);
#pragma intrinsic(__swpirql)

void *__rdpcr(void);
#pragma intrinsic(__rdpcr)
#define PCR ((PKPCR)__rdpcr())

#define KeGetCurrentThread() ((struct _KTHREAD *) __rdthread())
KIRQL KeGetCurrentIrql();
#endif // defined(_M_ALPHA)

#if defined(_M_MRX000)
#define KIPCR 0xfffff000
#define PCR ((volatile KPCR * const)KIPCR)
#define KeGetCurrentThread() PCR->CurrentThread
#define KeGetCurrentIrql() PCR->CurrentIrql
#endif // defined(_M_MRX000)

#if defined(_M_IX86)
PKTHREAD KeGetCurrentThread();
#endif // defined(_M_IX86)

#define PsGetCurrentProcess() IoGetCurrentProcess()
#define PsGetCurrentThread() ((PETHREAD) (KeGetCurrentThread()))
extern PCCHAR KeNumberProcessors;

#if !defined(MIDL_PASS)

#ifdef __cplusplus
extern "C"
#endif
#pragma warning(disable:4124)               // re-enable below
__inline
#if defined(_ALPHA_)
static
#endif
#if defined(_PPC_)
static
#endif
LARGE_INTEGER
#if defined(_MIPS_)
__fastcall
#endif
_LiCvt_ (
    IN LONGLONG Operand
    )

{

    LARGE_INTEGER Temp;

    Temp.QuadPart = Operand;
    return Temp;
}
#pragma warning(default:4124)

#define LiTemps        VOID _LiNeverCalled_(VOID)
#define LiNeg(a)       _LiCvt_(-(a).QuadPart)
#define LiAdd(a,b)     _LiCvt_((a).QuadPart + (b).QuadPart)
#define LiSub(a,b)     _LiCvt_((a).QuadPart - (b).QuadPart)
#define LiNMul(a,b)    (RtlEnlargedIntegerMultiply((a), (b)))          // (Long * Long)
#define LiXMul(a,b)    (RtlExtendedIntegerMultiply((a), (b)))          // (Large * Long)
#define LiDiv(a,b)     _LiCvt_((a).QuadPart / (b).QuadPart)
#define LiXDiv(a,b)    (RtlExtendedLargeIntegerDivide((a), (b), NULL)) // (Large / Long)
#define LiMod(a,b)     _LiCvt_((a).QuadPart % (b).QuadPart)
#define LiShr(a,b)     _LiCvt_((ULONGLONG)(a).QuadPart >> (CCHAR)(b))
#define LiShl(a,b)     _LiCvt_((a).QuadPart << (CCHAR)(b))
#define LiGtr(a,b)     ((a).QuadPart > (b).QuadPart)
#define LiGeq(a,b)     ((a).QuadPart >= (b).QuadPart)
#define LiEql(a,b)     ((a).QuadPart == (b).QuadPart)
#define LiNeq(a,b)     ((a).QuadPart != (b).QuadPart)
#define LiLtr(a,b)     ((a).QuadPart < (b).QuadPart)
#define LiLeq(a,b)     ((a).QuadPart <= (b).QuadPart)
#define LiGtrZero(a)   ((a).QuadPart > 0)
#define LiGeqZero(a)   ((a).QuadPart >= 0)
#define LiEqlZero(a)   ((a).QuadPart == 0)
#define LiNeqZero(a)   ((a).QuadPart != 0)
#define LiLtrZero(a)   ((a).QuadPart < 0)
#define LiLeqZero(a)   ((a).QuadPart <= 0)
#define LiFromLong(a)  _LiCvt_((LONGLONG)(a))
#define LiFromUlong(a) _LiCvt_((LONGLONG)(a))

#define LiGtrT_        LiGtr
#define LiGtr_T        LiGtr
#define LiGtrTT        LiGtr
#define LiGeqT_        LiGeq
#define LiGeq_T        LiGeq
#define LiGeqTT        LiGeq
#define LiEqlT_        LiEql
#define LiEql_T        LiEql
#define LiEqlTT        LiEql
#define LiNeqT_        LiNeq
#define LiNeq_T        LiNeq
#define LiNeqTT        LiNeq
#define LiLtrT_        LiLtr
#define LiLtr_T        LiLtr
#define LiLtrTT        LiLtr
#define LiLeqT_        LiLeq
#define LiLeq_T        LiLeq
#define LiLeqTT        LiLeq
#define LiGtrZeroT     LiGtrZero
#define LiGeqZeroT     LiGeqZero
#define LiEqlZeroT     LiEqlZero
#define LiNeqZeroT     LiNeqZero
#define LiLtrZeroT     LiLtrZero
#define LiLeqZeroT     LiLeqZero

#else // MIDL_PASS

#define LiNeg(a)       (RtlLargeIntegerNegate((a)))                   // -a
#define LiAdd(a,b)     (RtlLargeIntegerAdd((a),(b)))                  // a + b
#define LiSub(a,b)     (RtlLargeIntegerSubtract((a),(b)))             // a - b
#define LiNMul(a,b)    (RtlEnlargedIntegerMultiply((a),(b)))          // a * b (Long * Long)
#define LiXMul(a,b)    (RtlExtendedIntegerMultiply((a),(b)))          // a * b (Large * Long)
#define LiDiv(a,b)     (RtlLargeIntegerDivide((a),(b),NULL))          // a / b (Large / Large)
#define LiXDiv(a,b)    (RtlExtendedLargeIntegerDivide((a),(b),NULL))  // a / b (Large / Long)
#define LiMod(a,b)     (RtlLargeIntegerModulo((a),(b)))               // a % b
#define LiShr(a,b)     (RtlLargeIntegerShiftRight((a),(CCHAR)(b)))    // a >> b
#define LiShl(a,b)     (RtlLargeIntegerShiftLeft((a),(CCHAR)(b)))     // a << b
#define LiGtr(a,b)     (RtlLargeIntegerGreaterThan((a),(b)))          // a > b
#define LiGeq(a,b)     (RtlLargeIntegerGreaterThanOrEqualTo((a),(b))) // a >= b
#define LiEql(a,b)     (RtlLargeIntegerEqualTo((a),(b)))              // a == b
#define LiNeq(a,b)     (RtlLargeIntegerNotEqualTo((a),(b)))           // a != b
#define LiLtr(a,b)     (RtlLargeIntegerLessThan((a),(b)))             // a < b
#define LiLeq(a,b)     (RtlLargeIntegerLessThanOrEqualTo((a),(b)))    // a <= b
#define LiGtrZero(a)   (RtlLargeIntegerGreaterThanZero((a)))          // a > 0
#define LiGeqZero(a)   (RtlLargeIntegerGreaterOrEqualToZero((a)))     // a >= 0
#define LiEqlZero(a)   (RtlLargeIntegerEqualToZero((a)))              // a == 0
#define LiNeqZero(a)   (RtlLargeIntegerNotEqualToZero((a)))           // a != 0
#define LiLtrZero(a)   (RtlLargeIntegerLessThanZero((a)))             // a < 0
#define LiLeqZero(a)   (RtlLargeIntegerLessOrEqualToZero((a)))        // a <= 0
#define LiFromLong(a)  (RtlConvertLongToLargeInteger((a)))
#define LiFromUlong(a) (RtlConvertUlongToLargeInteger((a)))

#define LiTemps        LARGE_INTEGER _LiT1,_LiT2
#define LiGtrT_(a,b)   ((_LiT1 = a,_LiT2),     LiGtr(_LiT1,(b)))
#define LiGtr_T(a,b)   ((_LiT1,_LiT2 = b),     LiGtr((a),_LiT2))
#define LiGtrTT(a,b)   ((_LiT1 = a, _LiT2 = b),LiGtr(_LiT1,_LiT2))
#define LiGeqT_(a,b)   ((_LiT1 = a,_LiT2),     LiGeq(_LiT1,(b)))
#define LiGeq_T(a,b)   ((_LiT1,_LiT2 = b),     LiGeq((a),_LiT2))
#define LiGeqTT(a,b)   ((_LiT1 = a, _LiT2 = b),LiGeq(_LiT1,_LiT2))
#define LiEqlT_(a,b)   ((_LiT1 = a,_LiT2),     LiEql(_LiT1,(b)))
#define LiEql_T(a,b)   ((_LiT1,_LiT2 = b),     LiEql((a),_LiT2))
#define LiEqlTT(a,b)   ((_LiT1 = a, _LiT2 = b),LiEql(_LiT1,_LiT2))
#define LiNeqT_(a,b)   ((_LiT1 = a,_LiT2),     LiNeq(_LiT1,(b)))
#define LiNeq_T(a,b)   ((_LiT1,_LiT2 = b),     LiNeq((a),_LiT2))
#define LiNeqTT(a,b)   ((_LiT1 = a, _LiT2 = b),LiNeq(_LiT1,_LiT2))
#define LiLtrT_(a,b)   ((_LiT1 = a,_LiT2),     LiLtr(_LiT1,(b)))
#define LiLtr_T(a,b)   ((_LiT1,_LiT2 = b),     LiLtr((a),_LiT2))
#define LiLtrTT(a,b)   ((_LiT1 = a, _LiT2 = b),LiLtr(_LiT1,_LiT2))
#define LiLeqT_(a,b)   ((_LiT1 = a,_LiT2),     LiLeq(_LiT1,(b)))
#define LiLeq_T(a,b)   ((_LiT1,_LiT2 = b),     LiLeq((a),_LiT2))
#define LiLeqTT(a,b)   ((_LiT1 = a, _LiT2 = b),LiLeq(_LiT1,_LiT2))
#define LiGtrZeroT(a)  ((_LiT1 = a,_LiT2),     LiGtrZero(_LiT1))
#define LiGeqZeroT(a)  ((_LiT1 = a,_LiT2),     LiGeqZero(_LiT1))
#define LiEqlZeroT(a)  ((_LiT1 = a,_LiT2),     LiEqlZero(_LiT1))
#define LiNeqZeroT(a)  ((_LiT1 = a,_LiT2),     LiNeqZero(_LiT1))
#define LiLtrZeroT(a)  ((_LiT1 = a,_LiT2),     LiLtrZero(_LiT1))
#define LiLeqZeroT(a)  ((_LiT1 = a,_LiT2),     LiLeqZero(_LiT1))

#endif // MIDL_PASS

#define POOL_TAGGING 1

#ifndef DBG
#define DBG 0
#endif

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

#if DEVL
//
// Global flag set by NtPartyByNumber(6) controls behaviour of
// NT.  See \nt\sdk\inc\ntexapi.h for flag definitions
//

extern ULONG NtGlobalFlag;

#define IF_NTOS_DEBUG( FlagName ) \
    if (NtGlobalFlag & (FLG_ ## FlagName))

#else
#define IF_NTOS_DEBUG( FlagName ) if (FALSE)
#endif

//
// Kernel definitions that need to be here for forward reference purposes
//

// begin_ntndis
//
// Processor modes.
//

typedef CCHAR KPROCESSOR_MODE;

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;

// end_ntndis
//
// APC function types
//

//
// Put in an empty definition for the KAPC so that the
// routines can reference it before it is declared.
//

struct _KAPC;

typedef
VOID
(*PKNORMAL_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

typedef
VOID
(*PKKERNEL_ROUTINE) (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

typedef
VOID
(*PKRUNDOWN_ROUTINE) (
    IN struct _KAPC *Apc
    );

typedef
BOOLEAN
(*PKSYNCHRONIZE_ROUTINE) (
    IN PVOID SynchronizeContext
    );

typedef
BOOLEAN
(*PKTRANSFER_ROUTINE) (
    VOID
    );

//
//
// Asynchronous Procedure Call (APC) object
//

typedef struct _KAPC {
    CSHORT Type;
    CSHORT Size;
    ULONG Spare0;
    struct _KTHREAD *Thread;
    LIST_ENTRY ApcListEntry;
    PKKERNEL_ROUTINE KernelRoutine;
    PKRUNDOWN_ROUTINE RundownRoutine;
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;

    //
    // N.B. The following two members MUST be together.
    //

    PVOID SystemArgument1;
    PVOID SystemArgument2;
    CCHAR ApcStateIndex;
    KPROCESSOR_MODE ApcMode;
    BOOLEAN Inserted;
} KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;

// begin_ntndis
//
// DPC routine
//

struct _KDPC;

typedef
VOID
(*PKDEFERRED_ROUTINE) (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Define DPC importance.
//
// LowImportance - Queue DPC at end of target DPC queue.
// MediumImportance - Queue DPC at front of target DPC queue.
// HighImportance - Queue DPC at front of target DPC DPC queue and interrupt
//     the target processor if the DPC is targeted and the system is an MP
//     system.
//
// N.B. If the target processor is the same as the processor on which the DPC
//      is queued on, then the processor is always interrupted if the DPC queue
//      was previously empty.
//

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance
} KDPC_IMPORTANCE;

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC {
    CSHORT Type;
    UCHAR Number;
    UCHAR Importance;
    LIST_ENTRY DpcListEntry;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PULONG Lock;
} KDPC, *PKDPC, *RESTRICTED_POINTER PRKDPC;

//
// I/O system definitions.
//
// Define a Memory Descriptor List (MDL)
//
// An MDL describes pages in a virtual buffer in terms of physical pages.  The
// pages associated with the buffer are described in an array that is allocated
// just after the MDL header structure itself.  In a future compiler this will
// be placed at:
//
//      ULONG Pages[];
//
// Until this declaration is permitted, however, one simply calculates the
// base of the array by adding one to the base MDL pointer:
//
//      Pages = (PULONG) (Mdl + 1);
//
// Notice that while in the context of the subject thread, the base virtual
// address of a buffer mapped by an MDL may be referenced using the following:
//
//      Mdl->StartVa | Mdl->ByteOffset
//

typedef struct _MDL {
    struct _MDL *Next;
    CSHORT Size;
    CSHORT MdlFlags;
    struct _EPROCESS *Process;
    PVOID MappedSystemVa;
    PVOID StartVa;
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, *PMDL;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FROM_ZONE     0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_LOCK_HELD               0x0200
#define MDL_SYSTEM_VA               0x0400
#define MDL_IO_SPACE                0x0800

#define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_LOCK_HELD               | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )

// end_ntndis
//
// switch to DBG when appropriate
//

#if DBG
#define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
	KdPrint(( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
        ASSERT(FALSE); \
        }
#else
#define PAGED_CODE()
#endif


//
// A PCI driver can read the complete 256 bytes of configuration
// information for any PCI device by calling:
//
//      ULONG
//      HalGetBusData (
//          IN BUS_DATA_TYPE        PCIConfiguration,
//          IN ULONG                PciBusNumber,
//          IN PCI_SLOT_NUMBER      VirtualSlotNumber,
//          IN PPCI_COMMON_CONFIG   &PCIDeviceConfig,
//          IN ULONG                sizeof (PCIDeviceConfig)
//      );
//
//      A return value of 0 means that the specified PCI bus does not exist.
//
//      A return value of 2, with a VendorID of PCI_INVALID_VENDORID means
//      that the PCI bus does exist, but there is no device at the specified
//      VirtualSlotNumber (PCI Device/Function number).
//
//

// begin_ntminiport

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;

#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   Reserved1[2];
            ULONG   ROMBaseAddress;
            ULONG   Reserved2[2];

            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;


    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000


//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//

// end_ntminiport
//
//  Define an access token from a programmer's viewpoint.  The structure is
//  completely opaque and the programer is only allowed to have pointers
//  to tokens.
//


//
// Pointer to a SECURITY_DESCRIPTOR  opaque data type.
//


//
// Define a pointer to the Security ID data type (an opaque data type)
//


typedef ULONG ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;

// end_winnt
//
//  The following are masks for the predefined standard access types
//

#define DELETE                           (0x00010000L)
#define READ_CONTROL                     (0x00020000L)
#define WRITE_DAC                        (0x00040000L)
#define WRITE_OWNER                      (0x00080000L)
#define SYNCHRONIZE                      (0x00100000L)

#define STANDARD_RIGHTS_REQUIRED         (0x000F0000L)

#define STANDARD_RIGHTS_READ             (READ_CONTROL)
#define STANDARD_RIGHTS_WRITE            (READ_CONTROL)
#define STANDARD_RIGHTS_EXECUTE          (READ_CONTROL)

#define STANDARD_RIGHTS_ALL              (0x001F0000L)

#define SPECIFIC_RIGHTS_ALL              (0x0000FFFFL)

//
// AccessSystemAcl access type
//

#define ACCESS_SYSTEM_SECURITY           (0x01000000L)

//
// MaximumAllowed access type
//

#define MAXIMUM_ALLOWED                  (0x02000000L)

//
//  These are the generic rights.
//

#define GENERIC_READ                     (0x80000000L)
#define GENERIC_WRITE                    (0x40000000L)
#define GENERIC_EXECUTE                  (0x20000000L)
#define GENERIC_ALL                      (0x10000000L)



#define LOW_PRIORITY 0              // Lowest thread priority level
#define LOW_REALTIME_PRIORITY 16    // Lowest realtime priority level
#define HIGH_PRIORITY 31            // Highest thread priority level
#define MAXIMUM_PRIORITY 32         // Number of thread priority levels

//
// Thread affinity
//

typedef ULONG KAFFINITY;
typedef KAFFINITY *PKAFFINITY;

//
// Thread priority
//

typedef LONG KPRIORITY;

//
// Spin Lock
//


typedef KSPIN_LOCK *PKSPIN_LOCK;

//
// Interrupt routine (first level dispatch)
//

typedef
VOID
(*PKINTERRUPT_ROUTINE) (
    VOID
    );

//
// Profile source types
//
typedef enum _KPROFILE_SOURCE {
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE;

//
// for move macros
//
#include <string.h>
//
// If debugging support enabled, define an ASSERT macro that works.  Otherwise
// define the ASSERT macro to expand to an empty expression.
//

#if DBG
NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


#if defined(_M_MRX000) || defined(_M_ALPHA)
PVOID
_ReturnAddress (
    VOID
    );

#pragma intrinsic(_ReturnAddress)

#define RtlGetCallersAddress(CallersAddress, CallersCaller) \
    *CallersAddress = (PVOID)_ReturnAddress(); \
    *CallersCaller = NULL;
#else
NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress(
    OUT PVOID *CallersAddress,
    OUT PVOID *CallersCaller
    );
#endif

//
// Subroutines for dealing with the Registry
//

typedef NTSTATUS (*PRTL_QUERY_REGISTRY_ROUTINE)(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

typedef struct _RTL_QUERY_REGISTRY_TABLE {
    PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
    ULONG Flags;
    PWSTR Name;
    PVOID EntryContext;
    ULONG DefaultType;
    PVOID DefaultData;
    ULONG DefaultLength;

} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;


//
// The following flags specify how the Name field of a RTL_QUERY_REGISTRY_TABLE
// entry is interpreted.  A NULL name indicates the end of the table.
//

#define RTL_QUERY_REGISTRY_SUBKEY   0x00000001  // Name is a subkey and remainder of
                                                // table or until next subkey are value
                                                // names for that subkey to look at.

#define RTL_QUERY_REGISTRY_TOPKEY   0x00000002  // Reset current key to original key for
                                                // this and all following table entries.

#define RTL_QUERY_REGISTRY_REQUIRED 0x00000004  // Fail if no match found for this table
                                                // entry.

#define RTL_QUERY_REGISTRY_NOVALUE  0x00000008  // Used to mark a table entry that has no
                                                // value name, just wants a call out, not
                                                // an enumeration of all values.

#define RTL_QUERY_REGISTRY_NOEXPAND 0x00000010  // Used to suppress the expansion of
                                                // REG_MULTI_SZ into multiple callouts or
                                                // to prevent the expansion of environment
                                                // variable values in REG_EXPAND_SZ

#define RTL_QUERY_REGISTRY_DIRECT   0x00000020  // QueryRoutine field ignored.  EntryContext
                                                // field points to location to store value.
                                                // For null terminated strings, EntryContext
                                                // points to UNICODE_STRING structure that
                                                // that describes maximum size of buffer.
                                                // If .Buffer field is NULL then a buffer is
                                                // allocated.
                                                //

#define RTL_QUERY_REGISTRY_DELETE   0x00000040  // Used to delete value keys after they
                                                // are queried.

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryRegistryValues(
    IN ULONG RelativeTo,
    IN PWSTR Path,
    IN PRTL_QUERY_REGISTRY_TABLE QueryTable,
    IN PVOID Context,
    IN PVOID Environment OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlWriteRegistryValue(
    IN ULONG RelativeTo,
    IN PWSTR Path,
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteRegistryValue(
    IN ULONG RelativeTo,
    IN PWSTR Path,
    IN PWSTR ValueName
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateRegistryKey(
    IN ULONG RelativeTo,
    IN PWSTR Path
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCheckRegistryKey(
    IN ULONG RelativeTo,
    IN PWSTR Path
    );

//
// The following values for the RelativeTo parameter determine what the
// Path parameter to RtlQueryRegistryValues is relative to.
//

#define RTL_REGISTRY_ABSOLUTE     0   // Path is a full path
#define RTL_REGISTRY_SERVICES     1   // \Registry\Machine\System\CurrentControlSet\Services
#define RTL_REGISTRY_CONTROL      2   // \Registry\Machine\System\CurrentControlSet\Control
#define RTL_REGISTRY_WINDOWS_NT   3   // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
#define RTL_REGISTRY_DEVICEMAP    4   // \Registry\Machine\Hardware\DeviceMap
#define RTL_REGISTRY_USER         5   // \Registry\User\CurrentUser
#define RTL_REGISTRY_MAXIMUM      6
#define RTL_REGISTRY_HANDLE       0x40000000    // Low order bits are registry handle
#define RTL_REGISTRY_OPTIONAL     0x80000000    // Indicates the key node is optional

NTSYSAPI                                            
NTSTATUS                                            
NTAPI                                               
RtlCharToInteger (                                  
    PCSZ String,                                    
    ULONG Base,                                     
    PULONG Value                                    
    );                                              
NTSYSAPI                                            
NTSTATUS                                            
NTAPI                                               
RtlIntegerToUnicodeString (                         
    ULONG Value,                                    
    ULONG Base,                                     
    PUNICODE_STRING String                          
    );                                              
//
//  String manipulation routines
//

#ifdef _NTSYSTEM_

#define NLS_MB_CODE_PAGE_TAG NlsMbCodePageTag
#define NLS_MB_OEM_CODE_PAGE_TAG NlsMbOemCodePageTag

#else

#define NLS_MB_CODE_PAGE_TAG (*NlsMbCodePageTag)
#define NLS_MB_OEM_CODE_PAGE_TAG (*NlsMbOemCodePageTag)

#endif // _NTSYSTEM_

extern BOOLEAN NLS_MB_CODE_PAGE_TAG;     // TRUE -> Multibyte CP, FALSE -> Singlebyte
extern BOOLEAN NLS_MB_OEM_CODE_PAGE_TAG; // TRUE -> Multibyte CP, FALSE -> Singlebyte

NTSYSAPI
VOID
NTAPI
RtlInitString(
    PSTRING DestinationString,
    PCSZ SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlInitAnsiString(
    PANSI_STRING DestinationString,
    PCSZ SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );


NTSYSAPI
VOID
NTAPI
RtlCopyString(
    PSTRING DestinationString,
    PSTRING SourceString
    );


NTSYSAPI
LONG
NTAPI
RtlCompareString(
    PSTRING String1,
    PSTRING String2,
    BOOLEAN CaseInSensitive
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualString(
    PSTRING String1,
    PSTRING String2,
    BOOLEAN CaseInSensitive
    );


NTSYSAPI
VOID
NTAPI
RtlUpperString(
    PSTRING DestinationString,
    PSTRING SourceString
    );

//
// NLS String functions
//

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    PUNICODE_STRING DestinationString,
    PANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    PANSI_STRING DestinationString,
    PUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
    PUNICODE_STRING String1,
    PUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    PUNICODE_STRING String1,
    PUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    PUNICODE_STRING DestinationString,
    PUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    PUNICODE_STRING DestinationString,
    PUNICODE_STRING SourceString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString (
    PUNICODE_STRING Destination,
    PUNICODE_STRING Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString (
    PUNICODE_STRING Destination,
    PWSTR Source
    );


NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    PUNICODE_STRING UnicodeString
    );

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    PANSI_STRING AnsiString
    );


NTSYSAPI
ULONG
NTAPI
RtlxAnsiStringToUnicodeSize(
    PANSI_STRING AnsiString
    );

//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlAnsiStringToUnicodeSize(
//      PANSI_STRING AnsiString
//      );
//

#define RtlAnsiStringToUnicodeSize(STRING) (                 \
    NLS_MB_CODE_PAGE_TAG ?                                   \
    RtlxAnsiStringToUnicodeSize(STRING) :                    \
    ((STRING)->Length + sizeof((UCHAR)NULL)) * sizeof(WCHAR) \
)

//
// Fast primitives to compare, move, and zero memory
//

#if defined(_M_ALPHA)

//
// Guaranteed byte granularity memory copy function.
//

NTSYSAPI
VOID
NTAPI
RtlCopyBytes (
   PVOID Destination,
   CONST VOID *Source,
   ULONG Length
   );

#else

#define RtlCopyBytes RtlCopyMemory

#endif

//
// Define kernel debugger print prototypes and macros.
//

VOID                                        // ntddk nthal ntifs
NTAPI                                       // ntddk nthal ntifs
DbgBreakPoint(                              // ntddk nthal ntifs
    VOID                                    // ntddk nthal ntifs
    );                                      // ntddk nthal ntifs


#if DBG

#define KdPrint(_x_) DbgPrint _x_
#define KdPrintEx(_x_) DbgPrintEx _x_
#define KdBreakPoint() DbgBreakPoint()

#else

#define KdPrint(_x_)
#define KdPrintEx(_x_)
#define KdBreakPoint()

#endif

#ifndef _DBGNT_
ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );
#endif // _DBGNT_
//
// Large integer arithmetic routines.
//

#if defined(MIDL_PASS) || defined(__cplusplus) || !defined(_M_IX86)

//
// Large integer add - 64-bits + 64-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerAdd (
    LARGE_INTEGER Addend1,
    LARGE_INTEGER Addend2
    );

//
// Enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlEnlargedIntegerMultiply (
    LONG Multiplicand,
    LONG Multiplier
    );

//
// Unsigned enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlEnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    );

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

NTSYSAPI
ULONG
NTAPI
RtlEnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    );


//
// Large integer negation - -(64-bits)
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerNegate (
    LARGE_INTEGER Subtrahend
    );

//
// Large integer subtract - 64-bits - 64-bits -> 64-bits.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    );

#else

#pragma warning(disable:4035)               // re-enable below

//
// Large integer add - 64-bits + 64-bits -> 64-bits
//

__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerAdd (
    LARGE_INTEGER Addend1,
    LARGE_INTEGER Addend2
    )
{
    _asm {
        mov     eax,Addend1.LowPart     ; (eax)=add1.low
        mov     edx,Addend1.HighPart    ; (edx)=add1.hi
        add     eax,Addend2.LowPart     ; (eax)=sum.low
        adc     edx,Addend2.HighPart    ; (edx)=sum.hi
    }
}

//
// Enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

__inline LARGE_INTEGER
NTAPI
RtlEnlargedIntegerMultiply (
    LONG Multiplicand,
    LONG Multiplier
    )
{
    _asm {
        mov     eax, Multiplicand
        imul    Multiplier
    }
}

//
// Unsigned enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

__inline LARGE_INTEGER
NTAPI
RtlEnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    )
{
    _asm {
        mov     eax, Multiplicand
        mul     Multiplier
    }
}

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

__inline ULONG
NTAPI
RtlEnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
    _asm {
        mov     eax, Dividend.LowPart
        mov     edx, Dividend.HighPart
        mov     ecx, Remainder
        div     Divisor             ; eax = eax:edx / divisor
        or      ecx, ecx            ; save remainer?
        jz      short done
        mov     [ecx], edx
done:
    }
}


//
// Large integer negation - -(64-bits)
//

__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerNegate (
    LARGE_INTEGER Subtrahend
    )
{
    _asm {
        mov     eax, Subtrahend.LowPart
        mov     edx, Subtrahend.HighPart
        neg     edx                 ; (edx) = 2s comp of hi part
        neg     eax                 ; if ((eax) == 0) CF = 0
                                    ; else CF = 1
        sbb     edx,0               ; (edx) = (edx) - CF
    }
}

//
// Large integer subtract - 64-bits - 64-bits -> 64-bits.
//

__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    )
{
    _asm {
        mov     eax, Minuend.LowPart
        mov     edx, Minuend.HighPart
        sub     eax, Subtrahend.LowPart
        sbb     edx, Subtrahend.HighPart
    }
}

#pragma warning(default:4035)
#endif


//
// Extended large integer magic divide - 64-bits / 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    );

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    PLARGE_INTEGER Remainder
    );

//
// Extended integer multiply - 32-bits * 64-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    );

//
// Large integer and - 64-bite & 64-bits -> 64-bits.
//

#define RtlLargeIntegerAnd(Result, Source, Mask)   \
        {                                           \
            Result.HighPart = Source.HighPart & Mask.HighPart; \
            Result.LowPart = Source.LowPart & Mask.LowPart; \
        }

//
// Large integer conversion routines.
//

#if defined(MIDL_PASS) || defined(__cplusplus) || !defined(_M_IX86)

//
// Convert signed integer to large integer.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlConvertLongToLargeInteger (
    LONG SignedInteger
    );

//
// Convert unsigned integer to large integer.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    );


//
// Large integer shift routines.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

#else

#pragma warning(disable:4035)               // re-enable below

//
// Convert signed integer to large integer.
//

__inline LARGE_INTEGER
NTAPI
RtlConvertLongToLargeInteger (
    LONG SignedInteger
    )
{
    _asm {
        mov     eax, SignedInteger
        cdq                 ; (edx:eax) = signed LargeInt
    }
}

//
// Convert unsigned integer to large integer.
//

__inline LARGE_INTEGER
NTAPI
RtlConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    )
{
    _asm {
        sub     edx, edx    ; zero highpart
        mov     eax, UnsignedInteger
    }
}

//
// Large integer shift routines.
//

__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    _asm    {
        mov     cl, ShiftCount
        and     cl, 0x3f                    ; mod 64

        cmp     cl, 32
        jc      short sl10

        mov     edx, LargeInteger.LowPart   ; ShiftCount >= 32
        xor     eax, eax                    ; lowpart is zero
        shl     edx, cl                     ; store highpart
        jmp     short done

sl10:
        mov     eax, LargeInteger.LowPart   ; ShiftCount < 32
        mov     edx, LargeInteger.HighPart
        shld    edx, eax, cl
        shl     eax, cl
done:
    }
}


__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    _asm    {
        mov     cl, ShiftCount
        and     cl, 0x3f               ; mod 64

        cmp     cl, 32
        jc      short sr10

        mov     eax, LargeInteger.HighPart  ; ShiftCount >= 32
        xor     edx, edx                    ; lowpart is zero
        shr     eax, cl                     ; store highpart
        jmp     short done

sr10:
        mov     eax, LargeInteger.LowPart   ; ShiftCount < 32
        mov     edx, LargeInteger.HighPart
        shrd    eax, edx, cl
        shr     edx, cl
done:
    }
}


__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    _asm {
        mov     cl, ShiftCount
        and     cl, 3fh                 ; mod 64

        cmp     cl, 32
        jc      short sar10

        mov     eax, LargeInteger.HighPart
        sar     eax, cl
        bt      eax, 31                     ; sign bit set?
        sbb     edx, edx                    ; duplicate sign bit into highpart
        jmp     short done
sar10:
        mov     eax, LargeInteger.LowPart   ; (eax) = LargeInteger.LowPart
        mov     edx, LargeInteger.HighPart  ; (edx) = LargeInteger.HighPart
        shrd    eax, edx, cl
        sar     edx, cl
done:
    }
}

#pragma warning(default:4035)

#endif

//
// Large integer comparison routines.
//
// BOOLEAN
// RtlLargeIntegerGreaterThan (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerGreaterThanOrEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerNotEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerLessThan (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerLessThanOrEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerGreaterThanZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerGreaterOrEqualToZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerEqualToZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerNotEqualToZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerLessThanZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerLessOrEqualToZero (
//     LARGE_INTEGER Operand
//     );
//

#define RtlLargeIntegerGreaterThan(X,Y) (                              \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart > (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                      \
)

#define RtlLargeIntegerGreaterThanOrEqualTo(X,Y) (                      \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart >= (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                       \
)

#define RtlLargeIntegerEqualTo(X,Y) (                              \
    !(((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerNotEqualTo(X,Y) (                          \
    (((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerLessThan(X,Y) (                                 \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart < (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                      \
)

#define RtlLargeIntegerLessThanOrEqualTo(X,Y) (                         \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart <= (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                       \
)

#define RtlLargeIntegerGreaterThanZero(X) (       \
    (((X).HighPart == 0) && ((X).LowPart > 0)) || \
    ((X).HighPart > 0 )                           \
)

#define RtlLargeIntegerGreaterOrEqualToZero(X) ( \
    (X).HighPart >= 0                            \
)

#define RtlLargeIntegerEqualToZero(X) ( \
    !((X).LowPart | (X).HighPart)       \
)

#define RtlLargeIntegerNotEqualToZero(X) ( \
    ((X).LowPart | (X).HighPart)           \
)

#define RtlLargeIntegerLessThanZero(X) ( \
    ((X).HighPart < 0)                   \
)

#define RtlLargeIntegerLessOrEqualToZero(X) (           \
    ((X).HighPart < 0) || !((X).LowPart | (X).HighPart) \
)


//
//  Time conversion routines
//

typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;


NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields (
    PLARGE_INTEGER Time,
    PTIME_FIELDS TimeFields
    );

//
//  A time field record (Weekday ignored) -> 64 bit Time value
//

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime (
    PTIME_FIELDS TimeFields,
    PLARGE_INTEGER Time
    );

//
// The following macros store and retrieve USHORTS and ULONGS from potentially
// unaligned addresses, avoiding alignment faults.  they should probably be
// rewritten in assembler
//

#define SHORT_SIZE  (sizeof(USHORT))
#define SHORT_MASK  (SHORT_SIZE - 1)
#define LONG_SIZE       (sizeof(LONG))
#define LONG_MASK       (LONG_SIZE - 1)
#define LOWBYTE_MASK 0x00FF

#define FIRSTBYTE(VALUE)  (VALUE & LOWBYTE_MASK)
#define SECONDBYTE(VALUE) ((VALUE >> 8) & LOWBYTE_MASK)
#define THIRDBYTE(VALUE)  ((VALUE >> 16) & LOWBYTE_MASK)
#define FOURTHBYTE(VALUE) ((VALUE >> 24) & LOWBYTE_MASK)

//
// if MIPS Big Endian, order of bytes is reversed.
//

#define SHORT_LEAST_SIGNIFICANT_BIT  0
#define SHORT_MOST_SIGNIFICANT_BIT   1

#define LONG_LEAST_SIGNIFICANT_BIT       0
#define LONG_3RD_MOST_SIGNIFICANT_BIT    1
#define LONG_2ND_MOST_SIGNIFICANT_BIT    2
#define LONG_MOST_SIGNIFICANT_BIT        3

//++
//
// VOID
// RtlStoreUshort (
//     PUSHORT ADDRESS
//     USHORT VALUE
//     )
//
// Routine Description:
//
// This macro stores a USHORT value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store USHORT value
//     VALUE - USHORT to store
//
// Return Value:
//
//     none.
//
//--

#define RtlStoreUshort(ADDRESS,VALUE)                     \
         if ((ULONG)ADDRESS & SHORT_MASK) {               \
             ((PUCHAR) ADDRESS)[SHORT_LEAST_SIGNIFICANT_BIT] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) ADDRESS)[SHORT_MOST_SIGNIFICANT_BIT ] = (UCHAR)(SECONDBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PUSHORT) ADDRESS) = (USHORT) VALUE;       \
         }


//++
//
// VOID
// RtlStoreUlong (
//     PULONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG value
//     VALUE - ULONG to store
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call storeushort in the
//     unaligned case.
//
//--

#define RtlStoreUlong(ADDRESS,VALUE)                      \
         if ((ULONG)ADDRESS & LONG_MASK) {                \
             ((PUCHAR) ADDRESS)[LONG_LEAST_SIGNIFICANT_BIT      ] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) ADDRESS)[LONG_3RD_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(SECONDBYTE(VALUE));   \
             ((PUCHAR) ADDRESS)[LONG_2ND_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(THIRDBYTE(VALUE));    \
             ((PUCHAR) ADDRESS)[LONG_MOST_SIGNIFICANT_BIT       ] = (UCHAR)(FOURTHBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PULONG) ADDRESS) = (ULONG) VALUE;         \
         }

//++
//
// VOID
// RtlRetrieveUshort (
//     PUSHORT DESTINATION_ADDRESS
//     PUSHORT SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a USHORT value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store USHORT value
//     SOURCE_ADDRESS - where to retrieve USHORT value from
//
// Return Value:
//
//     none.
//
//--

#define RtlRetrieveUshort(DEST_ADDRESS,SRC_ADDRESS)                   \
         if ((ULONG)SRC_ADDRESS & SHORT_MASK) {                       \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
         }                                                            \
         else {                                                       \
             *((PUSHORT) DEST_ADDRESS) = *((PUSHORT) SRC_ADDRESS);    \
         }                                                            \

//++
//
// VOID
// RtlRetrieveUlong (
//     PULONG DESTINATION_ADDRESS
//     PULONG SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a ULONG value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store ULONG value
//     SOURCE_ADDRESS - where to retrieve ULONG value from
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call retrieveushort in the
//     unaligned case.
//
//--

#define RtlRetrieveUlong(DEST_ADDRESS,SRC_ADDRESS)                    \
         if ((ULONG)SRC_ADDRESS & LONG_MASK) {                        \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
             ((PUCHAR) DEST_ADDRESS)[2] = ((PUCHAR) SRC_ADDRESS)[2];  \
             ((PUCHAR) DEST_ADDRESS)[3] = ((PUCHAR) SRC_ADDRESS)[3];  \
         }                                                            \
         else {                                                       \
             *((PULONG) DEST_ADDRESS) = *((PULONG) SRC_ADDRESS);      \
         }
//
//  SecurityDescriptor RTL routine definitions
//

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG Revision
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlValidSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );


NTSYSAPI
ULONG
NTAPI
RtlLengthSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    BOOLEAN DaclPresent,
    PACL Dacl,
    BOOLEAN DaclDefaulted
    );

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe




//
// Define share access rights to files and directories
//

#define FILE_SHARE_DELETE               0x00000004



//
// Define the file attributes values
//
// Note:  0x00000008 is reserved for use for the old DOS VOLID (volume ID)
//        and is therefore not considered valid in NT.
//
// Note:  0x00000010 is reserved for use for the old DOS SUBDIRECTORY flag
//        and is therefore not considered valid in NT.  This flag has
//        been disassociated with file attributes since the other flags are
//        protected with READ_ and WRITE_ATTRIBUTES access to the file.
//
// Note:  Note also that the order of these flags is set to allow both the
//        FAT and the Pinball File Systems to directly set the attributes
//        flags in attributes words without having to pick each flag out
//        individually.  The order of these flags should not be changed!
//

#define FILE_ATTRIBUTE_RESERVED0        0x00000200
#define FILE_ATTRIBUTE_RESERVED1        0x00000400


#define FILE_ATTRIBUTE_VALID_FLAGS      0x00001fb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS  0x00000fa7

//
// Define the create disposition values
//

#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005


//
// Define the create/open option flags
//

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_DISABLE_TUNNELING                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000


#define FILE_VALID_OPTION_FLAGS                 0x000FFFFF

#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00001036

//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
//

#define FILE_SUPERSEDED                 0x00000000
#define FILE_OPENED                     0x00000001
#define FILE_CREATED                    0x00000002
#define FILE_OVERWRITTEN                0x00000003
#define FILE_EXISTS                     0x00000004
#define FILE_DOES_NOT_EXIST             0x00000005

//
// Define special ByteOffset parameters for read and write operations
//

#define FILE_WRITE_TO_END_OF_FILE       0xffffffff
#define FILE_USE_FILE_POINTER_POSITION  0xfffffffe

//
// Define alignment requirement values
//

#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff

//
// Define the maximum length of a filename string
//

#define MAXIMUM_FILENAME_LENGTH         256

//
// Define the various device characteristics flags
//

#define FILE_REMOVABLE_MEDIA            0x00000001
#define FILE_READ_ONLY_DEVICE           0x00000002
#define FILE_FLOPPY_DISKETTE            0x00000004
#define FILE_WRITE_ONCE_MEDIA           0x00000008
#define FILE_REMOTE_DEVICE              0x00000010
#define FILE_DEVICE_IS_MOUNTED          0x00000020
#define FILE_VIRTUAL_VOLUME             0x00000040

//
// Define the base asynchronous I/O argument types
//

typedef struct _IO_STATUS_BLOCK {
    NTSTATUS Status;
    ULONG Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

//
// Define an Asynchronous Procedure Call from I/O viewpoint
//

typedef
VOID
(*PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

//
// Define the file information class values
//
// WARNING:  The order of the following values are assumed by the I/O system.
//           Any changes made here should be reflected there as well.
//

typedef enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation,
    FileBothDirectoryInformation,
    FileBasicInformation,
    FileStandardInformation,
    FileInternalInformation,
    FileEaInformation,
    FileAccessInformation,
    FileNameInformation,
    FileRenameInformation,
    FileLinkInformation,
    FileNamesInformation,
    FileDispositionInformation,
    FilePositionInformation,
    FileFullEaInformation,
    FileModeInformation,
    FileAlignmentInformation,
    FileAllInformation,
    FileAllocationInformation,
    FileEndOfFileInformation,
    FileAlternateNameInformation,
    FileStreamInformation,
    FilePipeInformation,
    FilePipeLocalInformation,
    FilePipeRemoteInformation,
    FileMailslotQueryInformation,
    FileMailslotSetInformation,
    FileCompressionInformation,
    FileCopyOnWriteInformation,
    FileCompletionInformation,
    FileMoveClusterInformation,
    FileOleClassIdInformation,
    FileOleStateBitsInformation,
    FileApplicationExplorableInformation,
    FileApplicationExplorableChildrenInformation,
    FileObjectIdInformation,
    FileOleAllInformation,
    FileOleDirectoryInformation,
    FileTransactionCommitInformation,
    FileContentIndexInformation,
    FileInheritContentIndexInformation,
    FileOleInformation,
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

//
// Define the various structures which are returned on query operations
//

typedef struct _FILE_BASIC_INFORMATION {                    
    LARGE_INTEGER CreationTime;                             
    LARGE_INTEGER LastAccessTime;                           
    LARGE_INTEGER LastWriteTime;                            
    LARGE_INTEGER ChangeTime;                               
    ULONG FileAttributes;                                   
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;         
                                                            
typedef struct _FILE_STANDARD_INFORMATION {                 
    LARGE_INTEGER AllocationSize;                           
    LARGE_INTEGER EndOfFile;                                
    ULONG NumberOfLinks;                                    
    BOOLEAN DeletePending;                                  
    BOOLEAN Directory;                                      
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;   
                                                            
typedef struct _FILE_POSITION_INFORMATION {                 
    LARGE_INTEGER CurrentByteOffset;                        
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;   
                                                            
typedef struct _FILE_ALIGNMENT_INFORMATION {                
    ULONG AlignmentRequirement;                             
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION; 
                                                            
typedef struct _FILE_DISPOSITION_INFORMATION {                  
    BOOLEAN DeleteFile;                                         
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION; 
                                                                
typedef struct _FILE_END_OF_FILE_INFORMATION {                  
    LARGE_INTEGER EndOfFile;                                    
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION; 
                                                                

typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

//
// Define the file system information class values
//
// WARNING:  The order of the following values are assumed by the I/O system.
//           Any changes made here should be reflected there as well.

typedef enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation,
    FileFsSizeInformation,
    FileFsDeviceInformation,
    FileFsAttributeInformation,
    FileFsQuotaQueryInformation,
    FileFsQuotaSetInformation,
    FileFsControlQueryInformation,
    FileFsControlSetInformation,
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef struct _FILE_FS_DEVICE_INFORMATION {                    
    DEVICE_TYPE DeviceType;                                     
    ULONG Characteristics;                                      
} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;     
                                                                
//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define I/O Driver error log packet structure.  This structure is filled in
// by the driver.
//

typedef struct _IO_ERROR_LOG_PACKET {
    UCHAR MajorFunctionCode;
    UCHAR RetryCount;
    USHORT DumpDataSize;
    USHORT NumberOfStrings;
    USHORT StringOffset;
    USHORT EventCategory;
    NTSTATUS ErrorCode;
    ULONG UniqueErrorValue;
    NTSTATUS FinalStatus;
    ULONG SequenceNumber;
    ULONG IoControlCode;
    LARGE_INTEGER DeviceOffset;
    ULONG DumpData[1];
}IO_ERROR_LOG_PACKET, *PIO_ERROR_LOG_PACKET;

//
// Define the I/O error log message.  This message is sent by the error log
// thread over the lpc port.
//

typedef struct _IO_ERROR_LOG_MESSAGE {
    USHORT Type;
    USHORT Size;
    USHORT DriverNameLength;
    LARGE_INTEGER TimeStamp;
    ULONG DriverNameOffset;
    IO_ERROR_LOG_PACKET EntryData;
}IO_ERROR_LOG_MESSAGE, *PIO_ERROR_LOG_MESSAGE;

//
// Define the maximum message size that will be sent over the LPC to the
// application reading the error log entries.
//

#define IO_ERROR_LOG_MESSAGE_LENGTH  PORT_MAXIMUM_MESSAGE_LENGTH

//
// Define the maximum packet size a driver can allocate.
//

#define ERROR_LOG_MAXIMUM_SIZE (IO_ERROR_LOG_MESSAGE_LENGTH + sizeof(IO_ERROR_LOG_PACKET) -    \
                        sizeof(IO_ERROR_LOG_MESSAGE) - (sizeof(WCHAR) * 40))

#define PORT_MAXIMUM_MESSAGE_LENGTH 256
//
// Registry Specific Access Rights.
//

#define KEY_QUERY_VALUE         (0x0001)
#define KEY_SET_VALUE           (0x0002)
#define KEY_CREATE_SUB_KEY      (0x0004)
#define KEY_ENUMERATE_SUB_KEYS  (0x0008)
#define KEY_NOTIFY              (0x0010)
#define KEY_CREATE_LINK         (0x0020)

#define KEY_READ                ((STANDARD_RIGHTS_READ       |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY)                 \
                                  &                           \
                                 (~SYNCHRONIZE))


#define KEY_WRITE               ((STANDARD_RIGHTS_WRITE      |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY)         \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_EXECUTE             ((KEY_READ)                   \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_ALL_ACCESS          ((STANDARD_RIGHTS_ALL        |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY         |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY                 |\
                                  KEY_CREATE_LINK)            \
                                  &                           \
                                 (~SYNCHRONIZE))

//
// Open/Create Options
//

#define REG_OPTION_RESERVED         (0x00000000L)   // Parameter is reserved

#define REG_OPTION_NON_VOLATILE     (0x00000000L)   // Key is preserved
                                                    // when system is rebooted

#define REG_OPTION_VOLATILE         (0x00000001L)   // Key is not preserved
                                                    // when system is rebooted

#define REG_OPTION_CREATE_LINK      (0x00000002L)   // Created key is a
                                                    // symbolic link

#define REG_OPTION_BACKUP_RESTORE   (0x00000004L)   // open for backup or restore
                                                    // special access rules
                                                    // privilege required

//
// Key creation/open disposition
//

#define REG_CREATED_NEW_KEY         (0x00000001L)   // New Registry Key created
#define REG_OPENED_EXISTING_KEY     (0x00000002L)   // Existing Key opened

//
// Key restore flags
//

#define REG_WHOLE_HIVE_VOLATILE     (0x00000001L)   // Restore whole hive volatile
#define REG_REFRESH_HIVE            (0x00000002L)   // Unwind changes to last flush

//
// Key query structures
//

typedef struct _KEY_BASIC_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef struct _KEY_NODE_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
//          Class[1];           // Variable length string not declared
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;

typedef struct _KEY_FULL_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];           // Variable length
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation
} KEY_INFORMATION_CLASS;

typedef struct _KEY_WRITE_TIME_INFORMATION {
    LARGE_INTEGER LastWriteTime;
} KEY_WRITE_TIME_INFORMATION, *PKEY_WRITE_TIME_INFORMATION;

typedef enum _KEY_SET_INFORMATION_CLASS {
    KeyWriteTimeInformation
} KEY_SET_INFORMATION_CLASS;

//
// Value entry query structures
//

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
//          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation
} KEY_VALUE_INFORMATION_CLASS;


#define OBJ_NAME_PATH_SEPARATOR ((WCHAR)L'\\')

//
// Object Manager Object Type Specific Access Rights.
//

#define OBJECT_TYPE_CREATE (0x0001)

#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

//
// Object Manager Directory Specific Access Rights.
//

#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)

#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

//
// Object Manager Symbolic Link Specific Access Rights.
//

#define SYMBOLIC_LINK_QUERY (0x0001)

#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

typedef struct _OBJECT_NAME_INFORMATION {               
    UNICODE_STRING Name;                                
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;   

//
// Section Information Structures.
//

typedef enum _SECTION_INHERIT {
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

//
// Section Access Rights.
//


#define SEGMENT_ALL_ACCESS SECTION_ALL_ACCESS


#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_DECOMMIT         0x4000     
#define MEM_RELEASE          0x8000     
#define MEM_FREE            0x10000     
#define MEM_PRIVATE         0x20000     
#define MEM_MAPPED          0x40000     
#define MEM_TOP_DOWN       0x100000     
#define MEM_LARGE_PAGES  0x20000000     
#define SEC_RESERVE       0x4000000     
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFF)

// end_winnt

//
// Thread Specific Access Rights
//


#define THREAD_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0x3FF)

//
// ClientId
//

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

//
// Thread Environment Block (and portable part of Thread Information Block)
//

//
// Process Information Classes
//

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation,
    ProcessQuotaLimits,
    ProcessIoCounters,
    ProcessVmCounters,
    ProcessTimes,
    ProcessBasePriority,
    ProcessRaisePriority,
    ProcessDebugPort,
    ProcessExceptionPort,
    ProcessAccessToken,
    ProcessLdtInformation,
    ProcessLdtSize,
    ProcessDefaultHardErrorMode,
    ProcessIoPortHandlers,          // Note: this is kernel mode only
    ProcessPooledUsageAndLimits,
    ProcessWorkingSetWatch,
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup,
    ProcessPriorityClass,
    MaxProcessInfoClass
    } PROCESSINFOCLASS;

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    MaxThreadInfoClass
    } THREADINFOCLASS;
//
// Process Information Structures
//

//
// PageFaultHistory Information
//  NtQueryInformationProcess using ProcessWorkingSetWatch
//
typedef struct _PROCESS_WS_WATCH_INFORMATION {
    PVOID FaultingPc;
    PVOID FaultingVa;
} PROCESS_WS_WATCH_INFORMATION, *PPROCESS_WS_WATCH_INFORMATION;

//
// Basic Process Information
//  NtQueryInformationProcess using ProcessBasicInfo
//

typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    KAFFINITY AffinityMask;
    KPRIORITY BasePriority;
    ULONG UniqueProcessId;
    ULONG InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;
typedef PROCESS_BASIC_INFORMATION *PPROCESS_BASIC_INFORMATION;

//
// Process Quotas
//  NtQueryInformationProcess using ProcessQuotaLimits
//  NtQueryInformationProcess using ProcessPooledQuotaLimits
//  NtSetInformationProcess using ProcessQuotaLimits
//


//
// Process Virtual Memory Counters
//  NtQueryInformationProcess using ProcessVmCounters
//

typedef struct _VM_COUNTERS {
    ULONG PeakVirtualSize;
    ULONG VirtualSize;
    ULONG PageFaultCount;
    ULONG PeakWorkingSetSize;
    ULONG WorkingSetSize;
    ULONG QuotaPeakPagedPoolUsage;
    ULONG QuotaPagedPoolUsage;
    ULONG QuotaPeakNonPagedPoolUsage;
    ULONG QuotaNonPagedPoolUsage;
    ULONG PagefileUsage;
    ULONG PeakPagefileUsage;
} VM_COUNTERS;
typedef VM_COUNTERS *PVM_COUNTERS;

//
// Process Pooled Quota Usage and Limits
//  NtQueryInformationProcess using ProcessPooledUsageAndLimits
//

typedef struct _POOLED_USAGE_AND_LIMITS {
    ULONG PeakPagedPoolUsage;
    ULONG PagedPoolUsage;
    ULONG PagedPoolLimit;
    ULONG PeakNonPagedPoolUsage;
    ULONG NonPagedPoolUsage;
    ULONG NonPagedPoolLimit;
    ULONG PeakPagefileUsage;
    ULONG PagefileUsage;
    ULONG PagefileLimit;
} POOLED_USAGE_AND_LIMITS;
typedef POOLED_USAGE_AND_LIMITS *PPOOLED_USAGE_AND_LIMITS;

//
// Process Security Context Information
//  NtSetInformationProcess using ProcessAccessToken
// PROCESS_SET_ACCESS_TOKEN access to the process is needed
// to use this info level.
//

typedef struct _PROCESS_ACCESS_TOKEN {

    //
    // Handle to Primary token to assign to the process.
    // TOKEN_ASSIGN_PRIMARY access to this token is needed.
    //

    HANDLE Token;

    //
    // Handle to the initial thread of the process.
    // A process's access token can only be changed if the process has
    // no threads or one thread.  If the process has no threads, this
    // field must be set to NULL.  Otherwise, it must contain a handle
    // open to the process's only thread.  THREAD_QUERY_INFORMATION access
    // is needed via this handle.

    HANDLE Thread;

} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

//
// Process/Thread System and User Time
//  NtQueryInformationProcess using ProcessTimes
//  NtQueryInformationThread using ThreadTimes
//

typedef struct _KERNEL_USER_TIMES {
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES;
typedef KERNEL_USER_TIMES *PKERNEL_USER_TIMES;
NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );
#define NtCurrentProcess() ( (HANDLE) -1 )

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef enum _SYSTEM_DOCK_STATE {
    SystemDockStateUnknown,
    SystemUndocked,
    SystemDocked
} SYSTEM_DOCK_STATE, *PSYSTEM_DOCK_STATE;


//
//
// Define system event type codes.
//

typedef enum {
    SystemEventVirtualKey,
    SystemEventLidState,
    SystemEventTimeChanged
} SYSTEM_EVENT_ID, *PSYSTEM_EVENT_ID;


#if defined(_X86_)

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1
//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1

//
// Define function decoration depending on whether a driver, a file system,
// or a kernel component is being built.
//

#if (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)) && !defined (_BLDR_)

//#define NTKERNELAPI DECLSPEC_IMPORT

//#else

#define NTKERNELAPI

#endif

//
// Define function decoration depending on whether the HAL or other kernel
// component is being build.
//

#if !defined(_NTHAL_) && !defined(_BLDR_)

#define NTHALAPI DECLSPEC_IMPORT

#else

#define NTHALAPI

#endif

//
// Define function decoration for FASTCALL calling convention
//

#define FASTCALL    _fastcall

#define NORMAL_DISPATCH_LENGTH 106                  
#define DISPATCH_LENGTH NORMAL_DISPATCH_LENGTH      
//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0             // Passive release level
#define LOW_LEVEL 0                 // Lowest interrupt level
#define APC_LEVEL 1                 // APC interrupt level
#define DISPATCH_LEVEL 2            // Dispatcher level

#define PROFILE_LEVEL 27            // timer used for profiling.
#define CLOCK1_LEVEL 28             // Interval clock 1 level - Not used on x86
#define CLOCK2_LEVEL 28             // Interval clock 2 level
#define IPI_LEVEL 29                // Interprocessor interrupt level
#define POWER_LEVEL 30              // Power failure level
#define HIGH_LEVEL 31               // Highest interrupt level

//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTKERNELAPI
UCHAR
READ_REGISTER_UCHAR(
    PUCHAR  Register
    );

NTKERNELAPI
USHORT
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTKERNELAPI
ULONG
READ_REGISTER_ULONG(
    PULONG  Register
    );

NTKERNELAPI
VOID
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );


NTKERNELAPI
VOID
WRITE_REGISTER_UCHAR(
    PUCHAR  Register,
    UCHAR   Value
    );

NTKERNELAPI
VOID
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTKERNELAPI
VOID
WRITE_REGISTER_ULONG(
    PULONG  Register,
    ULONG   Value
    );

NTKERNELAPI
VOID
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTKERNELAPI
UCHAR
READ_PORT_UCHAR(
    PUCHAR  Port
    );

NTKERNELAPI
USHORT
READ_PORT_USHORT(
    PUSHORT Port
    );

NTKERNELAPI
ULONG
READ_PORT_ULONG(
    PULONG  Port
    );

NTKERNELAPI
VOID
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTKERNELAPI
VOID
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTKERNELAPI
VOID
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTKERNELAPI
VOID
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

// end_ntndis
//
// Get data cache fill size.
//

#define KeGetDcacheFillSize() 1L


#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)


#if defined(_NTDDK_) || defined(_NTIFS_)

#define KeQueryTickCount(CurrentCount ) { \
    PKSYSTEM_TIME _TickCount = *((PKSYSTEM_TIME *)(&KeTickCount)); \
    do {                                                          \
        (CurrentCount)->HighPart = _TickCount->High1Time;          \
        (CurrentCount)->LowPart = _TickCount->LowPart;             \
    } while ((CurrentCount)->HighPart != _TickCount->High2Time);   \
}

#else

#define KiQueryTickCount(CurrentCount) \
    do {                                                        \
        (CurrentCount)->HighPart = KeTickCount.High1Time;       \
        (CurrentCount)->LowPart = KeTickCount.LowPart;          \
    } while ((CurrentCount)->HighPart != KeTickCount.High2Time)

VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif


//
// Processor Control Region Structure Definition
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    NT_TIB  NtTib;
    struct _KPCR *SelfPcr;              // flat address of this PCR
    struct _KPRCB *Prcb;                // pointer to Prcb
    KIRQL   Irql;
    ULONG   IRR;
    ULONG   IrrActive;
    ULONG   IDR;
    ULONG   Reserved2;

    struct _KIDTENTRY *IDT;
    struct _KGDTENTRY *GDT;
    struct _KTSS      *TSS;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    KAFFINITY SetMember;
    ULONG   StallScaleFactor;
    UCHAR   DebugActive;
    UCHAR   Number;

} KPCR;
typedef KPCR *PKPCR;

//
// i386 Specific portions of mm component
//

//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE (ULONG)0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L

// end_ntndis
//
// The highest user address reserves 64K bytes for a guard
// page.  This allows the probing of address from kernel mode to
// only have to check the starting address for strucutures of 64k bytes
// or less.
//

#define MM_HIGHEST_USER_ADDRESS (PVOID)0x7FFEFFFF // temp should be 0xBFFEFFFF

#define MM_USER_PROBE_ADDRESS 0x7FFF0000    // starting address of guard page

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS  (PVOID)0x00010000

//
// The lowest address for system space.
//

#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0800000

#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

//
// Result type definition for i386.  (Machine specific enumerate type
// which is return type for portable exinterlockedincrement/decrement
// procedures.)  In general, you should use the enumerated type defined
// in ex.h instead of directly referencing these constants.
//

// Flags loaded into AH by LAHF instruction

#define EFLAG_SIGN      0x8000
#define EFLAG_ZERO      0x4000
#define EFLAG_SELECT    (EFLAG_SIGN | EFLAG_ZERO)

#define RESULT_NEGATIVE ((EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_ZERO     ((~EFLAG_SIGN & EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_POSITIVE ((~EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)

//
// Convert various portable ExInterlock apis into their architecural
// equivalents.
//

#define ExInterlockedIncrementLong(Addend,Lock) \
        Exfi386InterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend,Lock) \
        Exfi386InterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target,Value,Lock) \
        Exfi386InterlockedExchangeUlong(Target,Value)

#define ExInterlockedAddUlong           ExfInterlockedAddUlong
#define ExInterlockedInsertHeadList     ExfInterlockedInsertHeadList
#define ExInterlockedInsertTailList     ExfInterlockedInsertTailList
#define ExInterlockedRemoveHeadList     ExfInterlockedRemoveHeadList
#define ExInterlockedPopEntryList       ExfInterlockedPopEntryList
#define ExInterlockedPushEntryList      ExfInterlockedPushEntryList

//
// Prototypes for architecural specific versions of Exi386 api
//

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for value are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedIncrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedDecrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
ULONG
FASTCALL
Exfi386InterlockedExchangeUlong (
    IN PULONG Target,
    IN ULONG Value
    );

//
// Intrinsic interlocked functions
//

#if defined(_NTDDK_) || defined(_NTIFS_) || !defined(NT_UP)
#ifndef _WINBASE_

LONG
FASTCALL
InterlockedIncrement(
    IN PLONG Addend
    );

LONG
FASTCALL
InterlockedDecrement(
    IN PLONG Addend
    );

LONG
FASTCALL
InterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );

#endif
#endif


#if !defined(MIDL_PASS) && defined(_M_IX86)
#ifndef __cplusplus

//
// i386 function definitions
//

#pragma warning(disable:4035)               // re-enable below

    #define _PCR   fs:[0]                   

//
// Get current IRQL.
//
// On x86 this function resides in the HAL
//

KIRQL
KeGetCurrentIrql();

//
// Get the current processor number
//

__inline ULONG KeGetCurrentProcessorNumber(VOID)
{
    _asm {  movzx eax, _PCR KPCR.Number  }
}


#else // ifdef __cplusplus

struct _KTHREAD *KeGetCurrentThread (VOID);
KIRQL
KeGetCurrentIrql();

#endif // ifdef __cplusplus
#endif // !defined(MIDL_PASS) && defined(_M_IX86)


#endif // defined(_X86_)


#if defined(_MIPS_)

//
// Indicate that the MIPS compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Define function decoration depending on whether a driver, a file system,
// or a kernel component is being built.
//

#if (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)) && !defined (_BLDR_)

#define NTKERNELAPI DECLSPEC_IMPORT

#else

#define NTKERNELAPI

#endif

//
// Define function decoration depending on whether the HAL or other kernel
// component is being build.
//

#if !defined(_NTHAL_) && !defined(_BLDR_)

#define NTHALAPI DECLSPEC_IMPORT

#else

#define NTHALAPI

#endif

// end_ntndis
//
// Define macro to generate import names.
//

#define IMPORT_NAME(name) __imp_##name

// begin_ntndis
//
// Define function decoration for FASTCALL calling convention
//

#define FASTCALL

// end_ntndis
//
// MIPS specific interlocked operation result values.
//

#define RESULT_ZERO 0
#define RESULT_NEGATIVE -2
#define RESULT_POSITIVE -1

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for value are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

//
// Convert portable interlock interfaces to architecure specific interfaces.
//

#define ExInterlockedIncrementLong(Addend, Lock) \
    ExMipsInterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend, Lock) \
    ExMipsInterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target, Value, Lock) \
    ExMipsInterlockedExchangeUlong(Target, Value)

NTKERNELAPI
INTERLOCKED_RESULT
ExMipsInterlockedIncrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
ExMipsInterlockedDecrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
ULONG
ExMipsInterlockedExchangeUlong (
    IN PULONG Target,
    IN ULONG Value
    );

//
// Intrinsic interlocked functions.
//

#if defined(_M_MRX000) && !defined(RC_INVOKED)

#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedExchange _InterlockedExchange

LONG
InterlockedIncrement(
    PLONG Addend
    );

LONG
InterlockedDecrement(
    PLONG Addend
    );

LONG
InterlockedExchange(
    PLONG Target,
    LONG Value
    );

#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)

#endif

//
// MIPS Interrupt Definitions.
//
// Define length on interupt object dispatch code in longwords.
//

#define DISPATCH_LENGTH 4               // Length of dispatch code in instructions

//
// Define Interrupt Request Levels.
//

#define PASSIVE_LEVEL 0                 // Passive release level
#define LOW_LEVEL 0                     // Lowest interrupt level
#define APC_LEVEL 1                     // APC interrupt level
#define DISPATCH_LEVEL 2                // Dispatcher level
#define IPI_LEVEL 7                     // Interprocessor interrupt level
#define POWER_LEVEL 7                   // Power failure level
#define FLOAT_LEVEL 8                   // Floating interrupt level
#define HIGH_LEVEL 8                    // Highest interrupt level

#if defined(R3000)

#define PROFILE_LEVEL 7                 // Profiling level

#endif

#if defined(R4000)

#define PROFILE_LEVEL 8                 // Profiling level

#endif

//
// Define profile intervals.
//

#if defined(R3000)

#define DEFAULT_PROFILE_INTERVAL (10 * 1000)  // 1 millisecond
#define MAXIMUM_PROFILE_INTERVAL (10 * 1000 * 1000) // 1 second
#define MINIMUM_PROFILE_INTERVAL (10 * 1000) // 1 millisecond

#endif

#if defined(R4000)

#define DEFAULT_PROFILE_COUNT 0x40000000 // ~= 20 seconds @50mhz
#define DEFAULT_PROFILE_INTERVAL (10 * 500) // 500 microseconds
#define MAXIMUM_PROFILE_INTERVAL (10 * 1000 * 1000) // 1 second
#define MINIMUM_PROFILE_INTERVAL (10 * 40) // 40 microseconds

#endif


//
// Get current processor number.
//

#define KeGetCurrentProcessorNumber() PCR->Number

//
// Get data cache fill size.
//

#define KeGetDcacheFillSize() PCR->DcacheFillSize

//
// Cache and write buffer flush functions.
//

NTKERNELAPI
VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );


#if defined(_NTDDK_) || defined(_NTIFS_)

#define KeQueryTickCount(CurrentCount ) { \
    PKSYSTEM_TIME _TickCount = *((PKSYSTEM_TIME *)(&KeTickCount)); \
    do {                                                          \
        (CurrentCount)->HighPart = _TickCount->High1Time;          \
        (CurrentCount)->LowPart = _TickCount->LowPart;             \
    } while ((CurrentCount)->HighPart != _TickCount->High2Time);   \
}

#else

#define KiQueryTickCount(CurrentCount) \
    do {                                                        \
        (CurrentCount)->HighPart = KeTickCount.High1Time;       \
        (CurrentCount)->LowPart = KeTickCount.LowPart;          \
    } while ((CurrentCount)->HighPart != KeTickCount.High2Time)

NTKERNELAPI
VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif

//
// I/O space read and write macros.
//

#define READ_REGISTER_UCHAR(x) \
    *(volatile UCHAR * const)(x)

#define READ_REGISTER_USHORT(x) \
    *(volatile USHORT * const)(x)

#define READ_REGISTER_ULONG(x) \
    *(volatile ULONG * const)(x)

#define READ_REGISTER_BUFFER_UCHAR(x, y, z) {                           \
    PUCHAR registerBuffer = x;                                          \
    PUCHAR readBuffer = y;                                              \
    ULONG readCount;                                                    \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile UCHAR * const)(registerBuffer);        \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_USHORT(x, y, z) {                          \
    PUSHORT registerBuffer = x;                                         \
    PUSHORT readBuffer = y;                                             \
    ULONG readCount;                                                    \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile USHORT * const)(registerBuffer);       \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_ULONG(x, y, z) {                           \
    PULONG registerBuffer = x;                                          \
    PULONG readBuffer = y;                                              \
    ULONG readCount;                                                    \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile ULONG * const)(registerBuffer);        \
    }                                                                   \
}

#define WRITE_REGISTER_UCHAR(x, y) {    \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_USHORT(x, y) {   \
    *(volatile USHORT * const)(x) = y;  \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_ULONG(x, y) {    \
    *(volatile ULONG * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_BUFFER_UCHAR(x, y, z) {                            \
    PUCHAR registerBuffer = x;                                            \
    PUCHAR writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile UCHAR * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_USHORT(x, y, z) {                           \
    PUSHORT registerBuffer = x;                                           \
    PUSHORT writeBuffer = y;                                              \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile USHORT * const)(registerBuffer) = *writeBuffer;        \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_ULONG(x, y, z) {                            \
    PULONG registerBuffer = x;                                            \
    PULONG writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile ULONG * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}


#define READ_PORT_UCHAR(x) \
    *(volatile UCHAR * const)(x)

#define READ_PORT_USHORT(x) \
    *(volatile USHORT * const)(x)

#define READ_PORT_ULONG(x) \
    *(volatile ULONG * const)(x)

#define READ_PORT_BUFFER_UCHAR(x, y, z) {                             \
    PUCHAR readBuffer = y;                                            \
    ULONG readCount;                                                  \
    for (readCount = 0; readCount < z; readCount++, readBuffer++) {   \
        *readBuffer = *(volatile UCHAR * const)(x);                   \
    }                                                                 \
}

#define READ_PORT_BUFFER_USHORT(x, y, z) {                            \
    PUSHORT readBuffer = y;                                            \
    ULONG readCount;                                                  \
    for (readCount = 0; readCount < z; readCount++, readBuffer++) {   \
        *readBuffer = *(volatile USHORT * const)(x);                  \
    }                                                                 \
}

#define READ_PORT_BUFFER_ULONG(x, y, z) {                             \
    PULONG readBuffer = y;                                            \
    ULONG readCount;                                                  \
    for (readCount = 0; readCount < z; readCount++, readBuffer++) {   \
        *readBuffer = *(volatile ULONG * const)(x);                   \
    }                                                                 \
}

#define WRITE_PORT_UCHAR(x, y) {        \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_PORT_USHORT(x, y) {       \
    *(volatile USHORT * const)(x) = y;  \
    KeFlushWriteBuffer();               \
}

#define WRITE_PORT_ULONG(x, y) {        \
    *(volatile ULONG * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_PORT_BUFFER_UCHAR(x, y, z) {                                \
    PUCHAR writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = 0; writeCount < z; writeCount++, writeBuffer++) {   \
        *(volatile UCHAR * const)(x) = *writeBuffer;                      \
        KeFlushWriteBuffer();                                             \
    }                                                                     \
}

#define WRITE_PORT_BUFFER_USHORT(x, y, z) {                               \
    PUSHORT writeBuffer = y;                                              \
    ULONG writeCount;                                                     \
    for (writeCount = 0; writeCount < z; writeCount++, writeBuffer++) {   \
        *(volatile USHORT * const)(x) = *writeBuffer;                     \
        KeFlushWriteBuffer();                                             \
    }                                                                     \
}

#define WRITE_PORT_BUFFER_ULONG(x, y, z) {                                \
    PULONG writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = 0; writeCount < z; writeCount++, writeBuffer++) {   \
        *(volatile ULONG * const)(x) = *writeBuffer;                      \
        KeFlushWriteBuffer();                                             \
    }                                                                     \
}

//
// Define the page size for the MIPS r3000 and r4000 as 4096 (0x1000).
//

#define PAGE_SIZE (ULONG)0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L

//
// The highest user address reserves 64K bytes for a guard page. This
// the probing of address from kernel mode to only have to check the
// starting address for structures of 64k bytes or less.
//

#define MM_HIGHEST_USER_ADDRESS (PVOID)0x7FFEFFFF // highest user address
#define MM_USER_PROBE_ADDRESS 0x7FFF0000    // starting address of guard page

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS  (PVOID)0x00010000

#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

//
// The lowest address for system space.
//

#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0800000
#define SYSTEM_BASE 0xc0800000          // start of system space (no typecast)

// begin_ntndis
#endif // defined(_MIPS_)

#if defined(_ALPHA_)

//
// Indicate that the MIPS compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Define function decoration for FASTCALL calling convention
//

#define FASTCALL

// end_ntndis
//
// Include the alpha instruction definitions
//

#include "alphaops.h"

//
// Include reference machine definitions.
//

#include "alpharef.h"


//
// Define function decoration depending on whether a driver, a file system,
// or a kernel component is being built.
//

#if (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)) && !defined (_BLDR_)

#define NTKERNELAPI DECLSPEC_IMPORT

#else

#define NTKERNELAPI

#endif

//
// Define function decoration depending on whether the HAL or other kernel
// component is being build.
//

#if !defined(_NTHAL_) && !defined(_BLDR_)

#define NTHALAPI DECLSPEC_IMPORT

#else

#define NTHALAPI

#endif

// end_ntndis
//
// Define macro to generate import names.
//

#define IMPORT_NAME(name) __imp_##name

//
// Define length of interrupt vector table.
//

#define MAXIMUM_VECTOR 256

//
// Define bus error routine type.
//

struct _EXCEPTION_RECORD;
struct _KEXCEPTION_FRAME;
struct _KTRAP_FRAME;

typedef
BOOLEAN
(*PKBUS_ERROR_ROUTINE) (
    IN struct _EXCEPTION_RECORD *ExceptionRecord,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );


#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Major and minor version numbers of the PCR.
//

    ULONG MinorVersion;
    ULONG MajorVersion;

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific PAL/HAL code and will
// not change from version to version of NT.

//
// PALcode information.
//

    ULONGLONG PalBaseAddress;
    ULONG PalMajorVersion;
    ULONG PalMinorVersion;
    ULONG PalSequenceVersion;
    ULONG PalMajorSpecification;
    ULONG PalMinorSpecification;

//
// Firmware restart information.
//

    ULONGLONG FirmwareRestartAddress;
    PVOID RestartBlock;

//
// Reserved per-processor region for the PAL (3K bytes).
//

    ULONGLONG PalReserved[384];

//
// Panic Stack Address.
//

    ULONG PanicStack;

//
// Processor parameters.
//

    ULONG ProcessorType;
    ULONG ProcessorRevision;
    ULONG PhysicalAddressBits;
    ULONG MaximumAddressSpaceNumber;
    ULONG PageSize;
    ULONG FirstLevelDcacheSize;
    ULONG FirstLevelDcacheFillSize;
    ULONG FirstLevelIcacheSize;
    ULONG FirstLevelIcacheFillSize;

//
// System Parameters.
//

    ULONG FirmwareRevisionId;
    UCHAR SystemType[8];
    ULONG SystemVariant;
    ULONG SystemRevision;
    UCHAR SystemSerialNumber[16];
    ULONG CycleClockPeriod;
    ULONG SecondLevelCacheSize;
    ULONG SecondLevelCacheFillSize;
    ULONG ThirdLevelCacheSize;
    ULONG ThirdLevelCacheFillSize;
    ULONG FourthLevelCacheSize;
    ULONG FourthLevelCacheFillSize;

//
// Pointer to processor control block.
//

    struct _KPRCB *Prcb;

//
// Processor identification.
//

    CCHAR Number;
    KAFFINITY SetMember;

//
// Reserved per-processor region for the HAL (.5K bytes).
//

    ULONGLONG HalReserved[64];

//
// IRQL mapping tables.
//

    ULONG IrqlTable[8];

#define SFW_IMT_ENTRIES 4
#define HDW_IMT_ENTRIES 128

    struct _IRQLMASK {
        USHORT IrqlTableIndex;   // synchronization irql level
        USHORT IDTIndex;         // vector in IDT
    } IrqlMask[SFW_IMT_ENTRIES + HDW_IMT_ENTRIES];

//
// Interrupt Dispatch Table (IDT).
//

    PKINTERRUPT_ROUTINE InterruptRoutine[MAXIMUM_VECTOR];

//
// Reserved vectors mask, these vectors cannot be attached to via
// standard interrupt objects.
//

    ULONG ReservedVectors;

//
// Complement of processor affinity mask.
//

    KAFFINITY NotMember;

    ULONG InterruptInProgress;
    ULONG DpcRequested;

//
// Pointer to machine check handler
//

    PKBUS_ERROR_ROUTINE MachineCheckError;

//
// DPC Stack.
//

    ULONG DpcStack;

//
// End of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.  Some of these values are
// reserved for chip-specific palcode.
} KPCR, *PKPCR; 
//
// length of dispatch code in interrupt template
//
#define DISPATCH_LENGTH 4

//
// Define IRQL levels across the architecture.
//

#define PASSIVE_LEVEL   0
#define LOW_LEVEL       0
#define APC_LEVEL       1
#define DISPATCH_LEVEL  2
#define HIGH_LEVEL      7

//
// Processor Control Block (PRCB)
//

#define PRCB_MINOR_VERSION 1
#define PRCB_MAJOR_VERSION 2
#define PRCB_BUILD_DEBUG        0x0001
#define PRCB_BUILD_UNIPROCESSOR 0x0002

typedef struct _KPRCB {

//
// Major and minor version numbers of the PCR.
//

    USHORT MinorVersion;
    USHORT MajorVersion;

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *NextThread;
    struct _KTHREAD *IdleThread;
    CCHAR Number;
    CCHAR Reserved;
    USHORT BuildType;
    KAFFINITY SetMember;
    struct _RESTART_BLOCK *RestartBlock;

//
// End of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;      
//
// I/O space read and write macros.
//
//  These have to be actual functions on Alpha, because we need
//  to shift the VA and OR in the BYTE ENABLES.
//
//  These can become INLINEs if we require that ALL Alpha systems shift
//  the same number of bits and have the SAME byte enables.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space?
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space?
//

NTHALAPI
UCHAR
READ_REGISTER_UCHAR(
    PUCHAR Register
    );

NTHALAPI
USHORT
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTHALAPI
ULONG
READ_REGISTER_ULONG(
    PULONG Register
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );


NTHALAPI
VOID
WRITE_REGISTER_UCHAR(
    PUCHAR Register,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_REGISTER_ULONG(
    PULONG Register,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
READ_PORT_UCHAR(
    PUCHAR Port
    );

NTHALAPI
USHORT
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

// end_ntndis
//
// Define Interlocked operation result values.
//

#define RESULT_ZERO 0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for value are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

//
// Convert portable interlock interfaces to architecure specific interfaces.
//

#define ExInterlockedIncrementLong(Addend, Lock) \
    ExAlphaInterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend, Lock) \
    ExAlphaInterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target, Value, Lock) \
    ExAlphaInterlockedExchangeUlong(Target, Value)

NTKERNELAPI
INTERLOCKED_RESULT
ExAlphaInterlockedIncrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
ExAlphaInterlockedDecrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
ULONG
ExAlphaInterlockedExchangeUlong (
    IN PULONG Target,
    IN ULONG Value
    );

#if defined(_M_ALPHA) && !defined(RC_INVOKED)

#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedExchange _InterlockedExchange

LONG
InterlockedIncrement(
    PLONG Addend
    );

LONG
InterlockedDecrement(
    PLONG Addend
    );

LONG
InterlockedExchange(
    PLONG Target,
    LONG Value
    );

#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)

#endif

// there is a lot of other stuff that could go in here
//   probe macros
//   others

//
// Define the page size for the Alpha ev4 and lca as 8k.
//

#define PAGE_SIZE (ULONG)0x2000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 13L


//
// The highest user address reserves 64K bytes for a guard page. This
// the probing of address from kernel mode to only have to check the
// starting address for structures of 64k bytes or less.
//

#define MM_HIGHEST_USER_ADDRESS (PVOID)0x7FFEFFFF // highest user address
#define MM_USER_PROBE_ADDRESS 0x7FFF0000    // starting address of guard page

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS  (PVOID)0x00010000

#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

//
// The lowest address for system space.
//

#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0800000
//
// Get address of current PRCB.
//

#define KeGetCurrentPrcb() (PCR->Prcb)

//
// Get current processor number.
//

#define KeGetCurrentProcessorNumber() KeGetCurrentPrcb()->Number

//
// Cache and write buffer flush functions.
//

VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );


#if defined(_NTDDK_) || defined(_NTIFS_)

#define KeQueryTickCount(CurrentCount ) \
    *(PULONGLONG)(CurrentCount) = **((volatile ULONGLONG **)(&KeTickCount));

#else

#define KiQueryTickCount(CurrentCount) \
    *(PULONGLONG)(CurrentCount) = KeTickCount;

VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif

#endif // _ALPHA_

#if defined(_PPC_)

//
// Indicate that the compiler (with MIPS front-end) supports
// the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Define function decoration depending on whether a driver, a file system,
// or a kernel component is being built.
//

#if defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

#define NTKERNELAPI DECLSPEC_IMPORT

#else

#define NTKERNELAPI

#endif

//
// Define function decoration depending on whether the HAL or other kernel
// component is being build.
//

#if !defined(_NTHAL_)

#define NTHALAPI DECLSPEC_IMPORT

#else

#define NTHALAPI

#endif

// end_ntndis
//
// Define macro to generate import names.
//

#define IMPORT_NAME(name) __imp_##name

// begin_ntndis
//
// Define function decoration for FASTCALL calling convention
//

#define FASTCALL

// end_ntndis
//
// PowerPC specific interlocked operation result values.
//
// These are the values used on MIPS; there appears to be no
// need to change them for PowerPC.
//

#define RESULT_ZERO      0
#define RESULT_NEGATIVE -2
#define RESULT_POSITIVE -1

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for value are in i386.h, mips.h, ppc.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;


//
// Convert portable interlock interfaces to architecure specific interfaces.
//

#define ExInterlockedIncrementLong(Addend, Lock) \
    ExPpcInterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend, Lock) \
    ExPpcInterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target, Value, Lock) \
    ExPpcInterlockedExchangeUlong(Target, Value)

NTKERNELAPI
INTERLOCKED_RESULT
ExPpcInterlockedIncrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
ExPpcInterlockedDecrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
ULONG
ExPpcInterlockedExchangeUlong (
    IN PULONG Target,
    IN ULONG Value
    );

//
// Intrinsic interlocked functions
//

NTKERNELAPI
LONG
InterlockedIncrement(
    IN PLONG Addend
    );

NTKERNELAPI
LONG
InterlockedDecrement(
    IN PLONG Addend
    );

NTKERNELAPI
LONG
InterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );



//
// PowerPC Interrupt Definitions.
//
// Define length of interupt object dispatch code in 32-bit words.
//

#define DISPATCH_LENGTH 4               // Length of dispatch code in instructions

//
// Define Interrupt Request Levels.
//

#define PASSIVE_LEVEL   0               // Passive release level
#define LOW_LEVEL       0               // Lowest interrupt level
#define APC_LEVEL       1               // APC interrupt level
#define DISPATCH_LEVEL  2               // Dispatcher level
#define PROFILE_LEVEL   27              // Profiling level
#define IPI_LEVEL       29              // Interprocessor interrupt level
#define POWER_LEVEL     30              // Power failure level
#define FLOAT_LEVEL     31              // Floating interrupt level
#define HIGH_LEVEL      31              // Highest interrupt level

//
// Define profile intervals.
//
// **FINISH**  These are the MIPS R4000 values; investigate for PPC

#define DEFAULT_PROFILE_COUNT 0x40000000             // ~= 20 seconds @50mhz
#define DEFAULT_PROFILE_INTERVAL (10 * 500)          // 500 microseconds
#define MAXIMUM_PROFILE_INTERVAL (10 * 1000 * 1000)  // 1 second
#define MINIMUM_PROFILE_INTERVAL (10 * 40)           // 40 microseconds

//
// Define length of interrupt vector table.
//

#define MAXIMUM_VECTOR 256

//
// Processor Control Region
//
//   On PowerPC, this cannot be at a fixed virtual address;
//   it must be at a different address on each processor of an MP.
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Major and minor version numbers of the PCR.
//

    USHORT MinorVersion;
    USHORT MajorVersion;

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
// Interrupt and error exception vectors.
//

    PKINTERRUPT_ROUTINE InterruptRoutine[MAXIMUM_VECTOR];
    ULONG PcrPage2;
    ULONG Spare7[31];

//
// First and second level cache parameters.
//

    ULONG FirstLevelDcacheSize;
    ULONG FirstLevelDcacheFillSize;
    ULONG FirstLevelIcacheSize;
    ULONG FirstLevelIcacheFillSize;
    ULONG SecondLevelDcacheSize;
    ULONG SecondLevelDcacheFillSize;
    ULONG SecondLevelIcacheSize;
    ULONG SecondLevelIcacheFillSize;

//
// Pointer to processor control block.
//

    struct _KPRCB *Prcb;

//
// Pointer to the thread environment block.  A fast-path system call
// is provided that will return this value to user-mode code.
//

    PVOID Teb;

//
// Data cache alignment and fill size used for cache flushing and alignment.
// These fields are set to the larger of the first and second level data
// cache fill sizes.
//

    ULONG DcacheAlignment;
    ULONG DcacheFillSize;

//
// Instruction cache alignment and fill size used for cache flushing and
// alignment. These fields are set to the larger of the first and second
// level data cache fill sizes.
//

    ULONG IcacheAlignment;
    ULONG IcacheFillSize;

//
// Processor identification information from PVR.
//

    ULONG ProcessorVersion;
    ULONG ProcessorRevision;

//
// Profiling data.
//

    ULONG ProfileInterval;
    ULONG ProfileCount;

//
// Stall execution count and scale factor.
//

    ULONG StallExecutionCount;
    ULONG StallScaleFactor;

//
// Spare cell.
//

    ULONG Spare;

//
// Cache policy, right justified, as read from the processor configuration
// register at startup.
//

    union {
        ULONG CachePolicy;
        struct {
	        UCHAR IcacheMode;	// Dynamic cache mode for PPC
	        UCHAR DcacheMode;	// Dynamic cache mode for PPC
	        USHORT ModeSpare;
    	};
    };

//
// IRQL mapping tables.
//

    UCHAR IrqlMask[32];
    UCHAR IrqlTable[9];

//
// Current IRQL.
//

    UCHAR CurrentIrql;

//
// Processor identification
//
    CCHAR Number;
    KAFFINITY SetMember;

//
// Reserved interrupt vector mask.
//

    ULONG ReservedVectors;

//
// Current state parameters.
//

    struct _KTHREAD *CurrentThread;

//
// Cache policy, PTE field aligned, as read from the processor configuration
// register at startup.
//

    ULONG AlignedCachePolicy;

//
// Flag for determining pending software interrupts
//
    union {
        ULONG SoftwareInterrupt;        // any bit 1 => some s/w interrupt pending
        struct {
            UCHAR ApcInterrupt;         // 0x01 if APC int pending
            UCHAR DispatchInterrupt;    // 0x01 if dispatch int pending
            UCHAR Spare4;
            UCHAR Spare5;
        };
    };

//
// Complement of the processor affinity mask.
//

    KAFFINITY NotMember;

//
// Space reserved for the system.
//

    ULONG   SystemReserved[16];

//
// Space reserved for the HAL
//

    ULONG   HalReserved[16];

//
// End of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
} KPCR, *PKPCR;                     

KPCR * __builtin_get_sprg1(VOID);
#define KIPCR   0xffffd000              // kernel address of first PCR

#define PCRsprg1 ((volatile KPCR * volatile)__builtin_get_sprg1())

#define PCR ((volatile KPCR * const)KIPCR)

//
// Get current IRQL.
//

#define KeGetCurrentIrql() PCR->CurrentIrql

//
// Get address of current processor block.
//

#define KeGetCurrentPrcb() PCR->Prcb

//
// Get address of processor control region.
//

#define KeGetPcr() PCR

//
// Get address of current kernel thread object.
//

#define KeGetCurrentThread() PCR->CurrentThread

//
// Get Processor Version Register
//

ULONG __builtin_get_pvr(VOID);
#define KeGetPvr() __builtin_get_pvr()

// begin_ntddk

//
// Get current processor number.
//

#define KeGetCurrentProcessorNumber() PCR->Number

//
// Get data cache fill size.
//
// **FINISH**  See that proper PowerPC parameter is accessed here

#define KeGetDcacheFillSize() PCR->DcacheFillSize

//
// Cache and write buffer flush functions.
//

NTKERNELAPI
VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );


#if defined(_NTDDK_) || defined(_NTIFS_)

#define KeQueryTickCount(CurrentCount) { \
    PKSYSTEM_TIME _TickCount = *((PKSYSTEM_TIME *)(&KeTickCount)); \
    do {                                                           \
        (CurrentCount)->HighPart = _TickCount->High1Time;          \
        (CurrentCount)->LowPart = _TickCount->LowPart;             \
    } while ((CurrentCount)->HighPart != _TickCount->High2Time);    \
}

#else

#define KiQueryTickCount(CurrentCount) \
    do {                                                        \
        (CurrentCount)->HighPart = KeTickCount.High1Time;       \
        (CurrentCount)->LowPart = KeTickCount.LowPart;          \
    } while ((CurrentCount)->HighPart != KeTickCount.High2Time)

NTKERNELAPI
VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif


//
// I/O space read and write macros.
//
// **FINISH** Ensure that these are appropriate for PowerPC

#define READ_REGISTER_UCHAR(x) \
    *(volatile UCHAR * const)(x)

#define READ_REGISTER_USHORT(x) \
    *(volatile USHORT * const)(x)

#define READ_REGISTER_ULONG(x) \
    *(volatile ULONG * const)(x)

#define READ_REGISTER_BUFFER_UCHAR(x, y, z) {                           \
    PUCHAR registerBuffer = x;                                          \
    PUCHAR readBuffer = y;                                              \
    ULONG readCount;                                                    \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile UCHAR * const)(registerBuffer);        \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_USHORT(x, y, z) {                          \
    PUSHORT registerBuffer = x;                                         \
    PUSHORT readBuffer = y;                                             \
    ULONG readCount;                                                    \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile USHORT * const)(registerBuffer);       \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_ULONG(x, y, z) {                           \
    PULONG registerBuffer = x;                                          \
    PULONG readBuffer = y;                                              \
    ULONG readCount;                                                    \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile ULONG * const)(registerBuffer);        \
    }                                                                   \
}

#define WRITE_REGISTER_UCHAR(x, y) {    \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_USHORT(x, y) {   \
    *(volatile USHORT * const)(x) = y;  \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_ULONG(x, y) {    \
    *(volatile ULONG * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_BUFFER_UCHAR(x, y, z) {                            \
    PUCHAR registerBuffer = x;                                            \
    PUCHAR writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile UCHAR * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_USHORT(x, y, z) {                           \
    PUSHORT registerBuffer = x;                                           \
    PUSHORT writeBuffer = y;                                              \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile USHORT * const)(registerBuffer) = *writeBuffer;        \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_ULONG(x, y, z) {                            \
    PULONG registerBuffer = x;                                            \
    PULONG writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile ULONG * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}


#define READ_PORT_UCHAR(x) \
    *(volatile UCHAR * const)(x)

#define READ_PORT_USHORT(x) \
    *(volatile USHORT * const)(x)

#define READ_PORT_ULONG(x) \
    *(volatile ULONG * const)(x)

#define READ_PORT_BUFFER_UCHAR(x, y, z) {                             \
    PUCHAR readBuffer = y;                                            \
    ULONG readCount;                                                  \
    for (readCount = 0; readCount < z; readCount++, readBuffer++) {   \
        *readBuffer = *(volatile UCHAR * const)(x);                   \
    }                                                                 \
}

#define READ_PORT_BUFFER_USHORT(x, y, z) {                            \
    PUSHORT readBuffer = y;                                            \
    ULONG readCount;                                                  \
    for (readCount = 0; readCount < z; readCount++, readBuffer++) {   \
        *readBuffer = *(volatile USHORT * const)(x);                  \
    }                                                                 \
}

#define READ_PORT_BUFFER_ULONG(x, y, z) {                             \
    PULONG readBuffer = y;                                            \
    ULONG readCount;                                                  \
    for (readCount = 0; readCount < z; readCount++, readBuffer++) {   \
        *readBuffer = *(volatile ULONG * const)(x);                   \
    }                                                                 \
}

#define WRITE_PORT_UCHAR(x, y) {        \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_PORT_USHORT(x, y) {       \
    *(volatile USHORT * const)(x) = y;  \
    KeFlushWriteBuffer();               \
}

#define WRITE_PORT_ULONG(x, y) {        \
    *(volatile ULONG * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_PORT_BUFFER_UCHAR(x, y, z) {                                \
    PUCHAR writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = 0; writeCount < z; writeCount++, writeBuffer++) {   \
        *(volatile UCHAR * const)(x) = *writeBuffer;                      \
        KeFlushWriteBuffer();                                             \
    }                                                                     \
}

#define WRITE_PORT_BUFFER_USHORT(x, y, z) {                               \
    PUSHORT writeBuffer = y;                                              \
    ULONG writeCount;                                                     \
    for (writeCount = 0; writeCount < z; writeCount++, writeBuffer++) {   \
        *(volatile USHORT * const)(x) = *writeBuffer;                     \
        KeFlushWriteBuffer();                                             \
    }                                                                     \
}

#define WRITE_PORT_BUFFER_ULONG(x, y, z) {                                \
    PULONG writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = 0; writeCount < z; writeCount++, writeBuffer++) {   \
        *(volatile ULONG * const)(x) = *writeBuffer;                      \
        KeFlushWriteBuffer();                                             \
    }                                                                     \
}

//
// PowerPC page size = 4 KB
//

#define PAGE_SIZE (ULONG)0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L

//
// The highest user address reserves 64K bytes for a guard page. This
// the probing of address from kernel mode to only have to check the
// starting address for structures of 64k bytes or less.
//

#define MM_HIGHEST_USER_ADDRESS (PVOID)0x7FFEFFFF // highest user address
#define MM_USER_PROBE_ADDRESS 0x7FFF0000    // starting address of guard page

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS  (PVOID)0x00010000

#define MmLockPagableCodeSection(Address) \
    MmLockPagableDataSection(*((PVOID *)(Address)))

//
// The lowest address for system space.
//

#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0x80000000
#define SYSTEM_BASE 0x80000000          // start of system space (no typecast)

// begin_ntndis
#endif // defined(_PPC_)

#if defined(_X86_)

//
// Define system time structure.
//

typedef struct _KSYSTEM_TIME {
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;

#endif


#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#pragma warning(default:4164)   // reenable C4164 warning

#endif
#endif

//
// Size of kernel mode stack.
//

#define KERNEL_STACK_SIZE 8192

//
// Define size of large kernel mode stack for callbacks.
//

#define KERNEL_LARGE_STACK_SIZE 61440

//
// Define number of pages to initialize in a large kernel stack.
//

#define KERNEL_LARGE_STACK_COMMIT 12288


#endif // _X86_


//
// Resource List definitions
//

// begin_ntminiport begin_ntndis

//
// Defines the Type in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_RESOURCE_TYPE {
    CmResourceTypeNull = 0,    // Reserved
    CmResourceTypePort,
    CmResourceTypeInterrupt,
    CmResourceTypeMemory,
    CmResourceTypeDma,
    CmResourceTypeDeviceSpecific,
    CmResourceTypeMaximum
} CM_RESOURCE_TYPE;

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY 0
#define CM_RESOURCE_PORT_IO 1

// end_ntminiport end_ntndis

//
// This structure defines one type of resource used by a driver.
//
// There can only be *1* DeviceSpecificData block. It must be located at
// the end of all resource descriptors in a full descriptor block.
//

//
// BUGBUG Make sure alignment is made properly by compiler; otherwise move
// flags back to the top of the structure (common to all members of the
// union).
//
// begin_ntndis

#include "pshpack4.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of port numbers, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        // IRQL and vector. Should be same values as were passed to
        // HalGetInterruptVector().
        //

        struct {
            ULONG Level;
            ULONG Vector;
            ULONG Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#include "poppack.h"

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// Note: The BusNumber and Type are redundant information, but we will keep
// it since it allows the driver _not_ to append it when it is creating
// a resource list which could possibly span multiple buses.
//
// Note2: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;

// end_ntndis
//
// Define the structures used to interpret configuration data of
// \\Registry\machine\hardware\description tree.
// Basically, these structures are used to interpret component
// sepcific data.
//

//
// Define DEVICE_FLAGS
//

typedef struct _DEVICE_FLAGS {
    ULONG Failed : 1;
    ULONG ReadOnly : 1;
    ULONG Removable : 1;
    ULONG ConsoleIn : 1;
    ULONG ConsoleOut : 1;
    ULONG Input : 1;
    ULONG Output : 1;
} DEVICE_FLAGS, *PDEVICE_FLAGS;

//
// Define Component Information structure
//

typedef struct _CM_COMPONENT_INFORMATION {
    DEVICE_FLAGS Flags;
    ULONG Version;
    ULONG Key;
    ULONG AffinityMask;
} CM_COMPONENT_INFORMATION, *PCM_COMPONENT_INFORMATION;

//
// The following structures are used to interpret x86
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
// (Most of the structures are defined by BIOS.  They are
// not aligned on word (or dword) boundary.
//

//
// Define the Rom Block structure
//

typedef struct _CM_ROM_BLOCK {
    ULONG Address;
    ULONG Size;
} CM_ROM_BLOCK, *PCM_ROM_BLOCK;

// begin_ntminiport begin_ntndis

#include "pshpack1.h"

// end_ntminiport end_ntndis

//
// Define INT13 driver parameter block
//

typedef struct _CM_INT13_DRIVE_PARAMETER {
    USHORT DriveSelect;
    ULONG MaxCylinders;
    USHORT SectorsPerTrack;
    USHORT MaxHeads;
    USHORT NumberDrives;
} CM_INT13_DRIVE_PARAMETER, *PCM_INT13_DRIVE_PARAMETER;

// begin_ntminiport begin_ntndis

//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86

// end_ntminiport end_ntndis

//
// The following structures are used to interpret mips
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
//

//
// Device data records for adapters.
//

//
// The device data record for the Emulex SCSI controller.
//

typedef struct _CM_SCSI_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR HostIdentifier;
} CM_SCSI_DEVICE_DATA, *PCM_SCSI_DEVICE_DATA;

//
// Device data records for controllers.
//

//
// The device data record for the Video controller.
//

typedef struct _CM_VIDEO_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG VideoClock;
} CM_VIDEO_DEVICE_DATA, *PCM_VIDEO_DEVICE_DATA;

//
// The device data record for the SONIC network controller.
//

typedef struct _CM_SONIC_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT DataConfigurationRegister;
    UCHAR EthernetAddress[8];
} CM_SONIC_DEVICE_DATA, *PCM_SONIC_DEVICE_DATA;

//
// The device data record for the serial controller.
//

typedef struct _CM_SERIAL_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG BaudClock;
} CM_SERIAL_DEVICE_DATA, *PCM_SERIAL_DEVICE_DATA;

//
// Device data records for peripherals.
//

//
// The device data record for the Monitor peripheral.
//

typedef struct _CM_MONITOR_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT HorizontalScreenSize;
    USHORT VerticalScreenSize;
    USHORT HorizontalResolution;
    USHORT VerticalResolution;
    USHORT HorizontalDisplayTimeLow;
    USHORT HorizontalDisplayTime;
    USHORT HorizontalDisplayTimeHigh;
    USHORT HorizontalBackPorchLow;
    USHORT HorizontalBackPorch;
    USHORT HorizontalBackPorchHigh;
    USHORT HorizontalFrontPorchLow;
    USHORT HorizontalFrontPorch;
    USHORT HorizontalFrontPorchHigh;
    USHORT HorizontalSyncLow;
    USHORT HorizontalSync;
    USHORT HorizontalSyncHigh;
    USHORT VerticalBackPorchLow;
    USHORT VerticalBackPorch;
    USHORT VerticalBackPorchHigh;
    USHORT VerticalFrontPorchLow;
    USHORT VerticalFrontPorch;
    USHORT VerticalFrontPorchHigh;
    USHORT VerticalSyncLow;
    USHORT VerticalSync;
    USHORT VerticalSyncHigh;
} CM_MONITOR_DEVICE_DATA, *PCM_MONITOR_DEVICE_DATA;

//
// The device data record for the Floppy peripheral.
//

typedef struct _CM_FLOPPY_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    CHAR Size[8];
    ULONG MaxDensity;
    ULONG MountDensity;
    //
    // New data fields for version >= 2.0
    //
    UCHAR StepRateHeadUnloadTime;
    UCHAR HeadLoadTime;
    UCHAR MotorOffTime;
    UCHAR SectorLengthCode;
    UCHAR SectorPerTrack;
    UCHAR ReadWriteGapLength;
    UCHAR DataTransferLength;
    UCHAR FormatGapLength;
    UCHAR FormatFillCharacter;
    UCHAR HeadSettleTime;
    UCHAR MotorSettleTime;
    UCHAR MaximumTrackValue;
    UCHAR DataTransferRate;
} CM_FLOPPY_DEVICE_DATA, *PCM_FLOPPY_DEVICE_DATA;

//
// The device data record for the Keyboard peripheral.
// The KeyboardFlags is defined (by x86 BIOS INT 16h, function 02) as:
//      bit 7 : Insert on
//      bit 6 : Caps Lock on
//      bit 5 : Num Lock on
//      bit 4 : Scroll Lock on
//      bit 3 : Alt Key is down
//      bit 2 : Ctrl Key is down
//      bit 1 : Left shift key is down
//      bit 0 : Right shift key is down
//

typedef struct _CM_KEYBOARD_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR Type;
    UCHAR Subtype;
    USHORT KeyboardFlags;
} CM_KEYBOARD_DEVICE_DATA, *PCM_KEYBOARD_DEVICE_DATA;

//
// Declaration of the structure for disk geometries
//

typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA {
    ULONG BytesPerSector;
    ULONG NumberOfCylinders;
    ULONG SectorsPerTrack;
    ULONG NumberOfHeads;
} CM_DISK_GEOMETRY_DEVICE_DATA, *PCM_DISK_GEOMETRY_DEVICE_DATA;

// begin_ntminiport

//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_ALTERNATIVE     0x08


//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;

// end_ntminiport


typedef struct _IO_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;

    ULONG Count;
    IO_RESOURCE_DESCRIPTOR Descriptors[1];
} IO_RESOURCE_LIST, *PIO_RESOURCE_LIST;


typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
    ULONG ListSize;
    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    ULONG SlotNumber;
    ULONG Reserved[3];
    ULONG AlternativeLists;
    IO_RESOURCE_LIST  List[1];
} IO_RESOURCE_REQUIREMENTS_LIST, *PIO_RESOURCE_REQUIREMENTS_LIST;

//
// Exception flag definitions.
//


//
// Define maximum number of exception parameters.
//


//
// Define configuration routine types.
//
// Configuration information.
//

typedef enum _CONFIGURATION_TYPE {
    ArcSystem,
    CentralProcessor,
    FloatingPointProcessor,
    PrimaryIcache,
    PrimaryDcache,
    SecondaryIcache,
    SecondaryDcache,
    SecondaryCache,
    EisaAdapter,
    TcAdapter,
    ScsiAdapter,
    DtiAdapter,
    MultiFunctionAdapter,
    DiskController,
    TapeController,
    CdromController,
    WormController,
    SerialController,
    NetworkController,
    DisplayController,
    ParallelController,
    PointerController,
    KeyboardController,
    AudioController,
    OtherController,
    DiskPeripheral,
    FloppyDiskPeripheral,
    TapePeripheral,
    ModemPeripheral,
    MonitorPeripheral,
    PrinterPeripheral,
    PointerPeripheral,
    KeyboardPeripheral,
    TerminalPeripheral,
    OtherPeripheral,
    LinePeripheral,
    NetworkPeripheral,
    SystemMemory,
    MaximumType
} CONFIGURATION_TYPE, *PCONFIGURATION_TYPE;


//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;

//
// Wait reasons
//

typedef enum _KWAIT_REASON {
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    Spare1,
    Spare2,
    Spare3,
    Spare4,
    Spare5,
    Spare6,
    WrKernel,
    MaximumWaitReason
    } KWAIT_REASON;

//
// Common dispatcher object header
//

typedef struct _DISPATCHER_HEADER {
    UCHAR Type;
    UCHAR Spare;
    USHORT Size;
    LONG SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER;


typedef struct _KWAIT_BLOCK {
    LIST_ENTRY WaitListEntry;
    struct _KTHREAD *RESTRICTED_POINTER Thread;
    PVOID Object;
    struct _KWAIT_BLOCK *RESTRICTED_POINTER NextWaitBlock;
    USHORT WaitKey;
    USHORT WaitType;
} KWAIT_BLOCK, *PKWAIT_BLOCK, *RESTRICTED_POINTER PRKWAIT_BLOCK;

//
// Thread start function
//

typedef
VOID
(*PKSTART_ROUTINE) (
    IN PVOID StartContext
    );

//
// Kernel object structure definitions
//

//
// Device Queue object and entry
//

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    KSPIN_LOCK Lock;
    BOOLEAN Busy;
} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *RESTRICTED_POINTER PRKDEVICE_QUEUE;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *RESTRICTED_POINTER PRKDEVICE_QUEUE_ENTRY;

// begin_ntndis
//
// Event object
//

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *RESTRICTED_POINTER PRKEVENT;

//
// Define the interrupt service function type and the empty struct
// type.
//
typedef
BOOLEAN
(*PKSERVICE_ROUTINE) (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
    );
//
// Mutant object
//

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *RESTRICTED_POINTER OwnerThread;
    BOOLEAN Abandoned;
    UCHAR ApcDisable;
} KMUTANT, *PKMUTANT, *RESTRICTED_POINTER PRKMUTANT, KMUTEX, *PKMUTEX, *RESTRICTED_POINTER PRKMUTEX;

//
//
// Semaphore object
//

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *RESTRICTED_POINTER PRKSEMAPHORE;

// begin_ntndis
//
// Timer object
//

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    BOOLEAN Inserted;
} KTIMER, *PKTIMER, *RESTRICTED_POINTER PRKTIMER;

//
// DPC object
//

NTKERNELAPI
VOID
KeInitializeDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext
    );

NTKERNELAPI
BOOLEAN
KeInsertQueueDpc (
    IN PRKDPC Dpc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTKERNELAPI
BOOLEAN
KeRemoveQueueDpc (
    IN PRKDPC Dpc
    );

NTKERNELAPI
VOID
KeSetImportanceDpc (
    IN PRKDPC Dpc,
    IN KDPC_IMPORTANCE Importance
    );

NTKERNELAPI
VOID
KeSetTargetProcessorDpc (
    IN PRKDPC Dpc,
    IN CCHAR Number
    );

//
// Device queue object
//

NTKERNELAPI
VOID
KeInitializeDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
BOOLEAN
KeInsertDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

NTKERNELAPI
BOOLEAN
KeInsertByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    );

NTKERNELAPI
BOOLEAN
KeRemoveEntryDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

NTKERNELAPI                                         
BOOLEAN                                             
KeSynchronizeExecution (                            
    IN PKINTERRUPT Interrupt,                       
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,    
    IN PVOID SynchronizeContext                     
    );                                              
                                                    
//
// Kernel dispatcher object functions
//
// Event Object
//

NTKERNELAPI
VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    );

#if defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

VOID
KeClearEvent (
    IN PRKEVENT Event
    );

#else

#define KeClearEvent(Event) (Event)->Header.SignalState = 0

#endif


NTKERNELAPI
LONG
KeReadStateEvent (
    IN PRKEVENT Event
    );

NTKERNELAPI
LONG
KeResetEvent (
    IN PRKEVENT Event
    );

NTKERNELAPI
LONG
KeSetEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

//
// Mutex object
//

NTKERNELAPI
VOID
KeInitializeMutex (
    IN PRKMUTEX Mutex,
    IN ULONG Level
    );

#define KeReadStateMutex(Mutex) KeReadStateMutant(Mutex)

NTKERNELAPI
LONG
KeReleaseMutex (
    IN PRKMUTEX Mutex,
    IN BOOLEAN Wait
    );

//
// Semaphore object
//

NTKERNELAPI
VOID
KeInitializeSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN LONG Count,
    IN LONG Limit
    );

NTKERNELAPI
LONG
KeReadStateSemaphore (
    IN PRKSEMAPHORE Semaphore
    );

NTKERNELAPI
LONG
KeReleaseSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN KPRIORITY Increment,
    IN LONG Adjustment,
    IN BOOLEAN Wait
    );

NTKERNELAPI                                         
NTSTATUS                                            
KeDelayExecutionThread (                            
    IN KPROCESSOR_MODE WaitMode,                    
    IN BOOLEAN Alertable,                           
    IN PLARGE_INTEGER Interval                      
    );                                              
                                                    
NTKERNELAPI                                         
LONG                                                
KeSetBasePriorityThread (                           
    IN PKTHREAD Thread,                             
    IN LONG Increment                               
    );                                              
                                                    
NTKERNELAPI                                         
KPRIORITY                                           
KeSetPriorityThread (                               
    IN PKTHREAD Thread,                             
    IN KPRIORITY Priority                           
    );                                              
                                                    

#if defined(_NTDDK_) || defined(_NTIFS_)

NTKERNELAPI
VOID
KeEnterCriticalRegion (
    VOID
    );

#else

//++
//
// VOID
// KeEnterCriticalRegion (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function disables kernel APC's.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeEnterCriticalRegion() KeGetCurrentThread()->KernelApcDisable -= 1;

#endif

NTKERNELAPI
VOID
KeLeaveCriticalRegion (
    VOID
    );

//
// Timer object
//

NTKERNELAPI
VOID
KeInitializeTimer (
    IN PKTIMER Timer
    );

NTKERNELAPI
BOOLEAN
KeCancelTimer (
    IN PKTIMER
    );

NTKERNELAPI
BOOLEAN
KeReadStateTimer (
    PKTIMER Timer
    );

NTKERNELAPI
BOOLEAN
KeSetTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc OPTIONAL
    );


#define KeWaitForMutexObject KeWaitForSingleObject

NTKERNELAPI
NTSTATUS
KeWaitForMultipleObjects (
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PKWAIT_BLOCK WaitBlockArray OPTIONAL
    );

NTKERNELAPI
NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

//
// spin lock functions
//

NTKERNELAPI
VOID
NTAPI
KeInitializeSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#if defined(_X86_)

NTKERNELAPI
VOID
FASTCALL
KefAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
FASTCALL
KefReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLockAtDpcLevel(a)      KefAcquireSpinLockAtDpcLevel(a)
#define KeReleaseSpinLockFromDpcLevel(a)    KefReleaseSpinLockFromDpcLevel(a)

#else

NTKERNELAPI
VOID
KeAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
KeReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#endif

#if defined(_NTDDK_) || defined(_NTIFS_) || (defined(_X86_) && !defined(_NTHAL_))

#if defined(_X86_)

__declspec(dllimport)
KIRQL
FASTCALL
KfAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

__declspec(dllimport)
VOID
FASTCALL
KfReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#define KeAcquireSpinLock(a,b)  *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b)  KfReleaseSpinLock(a,b)

#elif defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)

__declspec(dllimport)
VOID
KeAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock,
    OUT PKIRQL OldIrql
    );

__declspec(dllimport)
VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#endif

#else

#if defined(_X86_)

KIRQL
FASTCALL
KfAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

VOID
FASTCALL
KfReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#define KeAcquireSpinLock(a,b)  *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b)  KfReleaseSpinLock(a,b)

#else

VOID
KeAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock,
    OUT PKIRQL OldIrql
    );

VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#endif

#endif


#if defined(_NTDDK_) || defined(_NTIFS_) || ((defined(_X86_) || defined(_PPC_)) && !defined(_NTHAL_))

#if defined(_X86_)

__declspec(dllimport)
VOID
FASTCALL
KfLowerIrql (
    IN KIRQL NewIrql
    );

__declspec(dllimport)
KIRQL
FASTCALL
KfRaiseIrql (
    IN KIRQL NewIrql
    );

#define KeLowerIrql(a)      KfLowerIrql(a)
#define KeRaiseIrql(a,b)    *(b) = KfRaiseIrql(a)

#elif defined(_MIPS_) || defined(_PPC_)

__declspec(dllimport)
VOID
KeLowerIrql (
    IN KIRQL NewIrql
    );

__declspec(dllimport)
VOID
KeRaiseIrql (
    IN KIRQL NewIrql,
    OUT PKIRQL OldIrql
    );

#elif defined(_ALPHA_)

#define KeLowerIrql(a)      __swpirql(a)
#define KeRaiseIrql(a,b)    *(b) = __swpirql(a)

#endif

#else

#if defined(_X86_)

VOID
FASTCALL
KfLowerIrql (
    IN KIRQL NewIrql
    );

KIRQL
FASTCALL
KfRaiseIrql (
    IN KIRQL NewIrql
    );

#define KeLowerIrql(a)      KfLowerIrql(a)
#define KeRaiseIrql(a,b)    *(b) = KfRaiseIrql(a)

#else

VOID
KeLowerIrql (
    IN KIRQL NewIrql
    );

VOID
KeRaiseIrql (
    IN KIRQL NewIrql,
    OUT PKIRQL OldIrql
    );

#endif

#endif

//
// Miscellaneous kernel functions
//

BOOLEAN
KeGetBugMessageText(
    IN ULONG MessageId,
    IN PANSI_STRING ReturnedString OPTIONAL
    );

typedef enum _KBUGCHECK_BUFFER_DUMP_STATE {
    BufferEmpty,
    BufferInserted,
    BufferStarted,
    BufferFinished,
    BufferIncomplete
} KBUGCHECK_BUFFER_DUMP_STATE;

typedef
VOID
(*PKBUGCHECK_CALLBACK_ROUTINE) (
    IN PVOID Buffer,
    IN ULONG Length
    );

typedef struct _KBUGCHECK_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Buffer;
    ULONG Length;
    PUCHAR Component;
    ULONG Checksum;
    UCHAR State;
} KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;

NTKERNELAPI
VOID
NTAPI
KeBugCheck (
    IN ULONG BugCheckCode
    );

NTKERNELAPI
VOID
KeBugCheckEx(
    IN ULONG BugCheckCode,
    IN ULONG BugCheckParameter1,
    IN ULONG BugCheckParameter2,
    IN ULONG BugCheckParameter3,
    IN ULONG BugCheckParameter4
    );

#define KeInitializeCallbackRecord(CallbackRecord) \
    (CallbackRecord)->State = BufferEmpty

NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckCallback (
    IN PKBUGCHECK_CALLBACK_RECORD CallbackRecord
    );

NTKERNELAPI
BOOLEAN
KeRegisterBugCheckCallback (
    IN PKBUGCHECK_CALLBACK_RECORD CallbackRecord,
    IN PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PUCHAR Component
    );

NTKERNELAPI
VOID
KeEnterKernelDebugger (
    VOID
    );


NTKERNELAPI
VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    );

NTKERNELAPI
ULONG
KeQueryTimeIncrement (
    VOID
    );

extern volatile KSYSTEM_TIME KeTickCount;           
//
// Define external data.
//

extern BOOLEAN KdDebuggerNotPresent;
extern BOOLEAN KdDebuggerEnabled;


NTKERNELAPI
VOID
FASTCALL
ExInterlockedAddLargeStatistic (
    IN PLARGE_INTEGER Addend,
    IN ULONG Increment
    );

NTKERNELAPI
LARGE_INTEGER
ExInterlockedAddLargeInteger (
    IN PLARGE_INTEGER Addend,
    IN LARGE_INTEGER Increment,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
ULONG
FASTCALL
ExInterlockedAddUlong (
    IN PULONG Addend,
    IN ULONG Increment,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertHeadList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertTailList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedRemoveHeadList (
    IN PLIST_ENTRY ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPopEntryList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPushEntryList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

//
// Pool Allocation routines (in pool.c)
//

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType
    } POOL_TYPE;

typedef enum _EX_POOL_PRIORITY {
    LowPoolPriority,
    LowPoolPrioritySpecialPoolOverrun = 8,
    LowPoolPrioritySpecialPoolUnderrun = 9,
    NormalPoolPriority = 16,
    NormalPoolPrioritySpecialPoolOverrun = 24,
    NormalPoolPrioritySpecialPoolUnderrun = 25,
    HighPoolPriority = 32,
    HighPoolPrioritySpecialPoolOverrun = 40,
    HighPoolPrioritySpecialPoolUnderrun = 41

    } EX_POOL_PRIORITY;


NTKERNELAPI
PVOID
ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

NTKERNELAPI
PVOID
ExAllocatePoolWithQuota(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

NTKERNELAPI
PVOID
ExAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Tag
    );

#ifndef POOL_TAGGING
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif //POOL_TAGGING


NTKERNELAPI
PVOID
ExAllocatePoolWithQuotaTag(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Tag
    );

#ifndef POOL_TAGGING
#define ExAllocatePoolWithQuotaTag(a,b,c) ExAllocatePoolWithQuota(a,b)
#endif //POOL_TAGGING


NTKERNELAPI
VOID
NTAPI
ExFreePool(
    IN PVOID P
    );

//
// Routines to support fast mutexes.
//

typedef CRITICAL_SECTION FAST_MUTEX, *PFAST_MUTEX;

#define ExInitializeFastMutex(_FastMutex)                            \
    (_FastMutex)->Count = 1;                                         \
    (_FastMutex)->Contention = 0;                                    \
    KeInitializeEvent(&(_FastMutex)->Event,                          \
                      SynchronizationEvent,                          \
                      FALSE);

NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutexUnsafe (
    IN PFAST_MUTEX FastMutex
    );

NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutexUnsafe (
    IN PFAST_MUTEX FastMutex
    );

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_) || (defined(_X86_) && defined(_NTHAL_))

NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutex (
    IN PFAST_MUTEX FastMutex
    );

NTKERNELAPI
BOOLEAN
FASTCALL
ExTryToAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

#elif defined(_X86_) && !defined(_NTHAL_)

__declspec(dllimport)
VOID
FASTCALL
ExAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

__declspec(dllimport)
VOID
FASTCALL
ExReleaseFastMutex (
    IN PFAST_MUTEX FastMutex
    );

__declspec(dllimport)
BOOLEAN
FASTCALL
ExTryToAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

#elif

#error "Target architecture not defined"

#endif

//
// Worker Thread
//

typedef enum _WORK_QUEUE_TYPE {
    CriticalWorkQueue,
    DelayedWorkQueue,
    HyperCriticalWorkQueue,
    MaximumWorkQueue
} WORK_QUEUE_TYPE;

typedef
VOID
(*PWORKER_THREAD_ROUTINE)(
    IN PVOID Parameter
    );

typedef struct _WORK_QUEUE_ITEM {
    LIST_ENTRY List;
    PWORKER_THREAD_ROUTINE WorkerRoutine;
    PVOID Parameter;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;


#define ExInitializeWorkItem(Item, Routine, Context) \
    (Item)->WorkerRoutine = (Routine);               \
    (Item)->Parameter = (Context);                   \
    (Item)->List.Flink = NULL;

NTKERNELAPI
VOID
ExQueueWorkItem(
    IN PWORK_QUEUE_ITEM WorkItem,
    IN WORK_QUEUE_TYPE QueueType
    );


//
// Define empty typedefs for the _IRP, _DEVICE_OBJECT, and _DRIVER_OBJECT
// structures so they may be referenced by function types before they are
// actually defined.
//
struct _DEVICE_DESCRIPTION;
struct _DEVICE_OBJECT;
struct _DMA_ADAPTER;
struct _DRIVER_OBJECT;
struct _DRIVE_LAYOUT_INFORMATION;
struct _DISK_PARTITION;
struct _FILE_OBJECT;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;
struct _SCATTER_GATHER_LIST;


//
// Volume Parameter Block (VPB)
//

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

typedef struct _VPB {
    CSHORT Type;
    CSHORT Size;
    USHORT Flags;
    USHORT VolumeLabelLength; // in bytes
    struct _DEVICE_OBJECT *DeviceObject;
    struct _DEVICE_OBJECT *RealDevice;
    ULONG SerialNumber;
    ULONG ReferenceCount;
    WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, *PVPB;


//
// Define the actions that a driver execution routine may request of the
// adapter/controller allocation routines upon return.
//

typedef enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject,
    DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION, *PIO_ALLOCATION_ACTION;


//
// Define device driver adapter/controller execution routine.
//

typedef
IO_ALLOCATION_ACTION
(*PDRIVER_CONTROL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );


//
// Define Wait Context Block (WCB)
//

typedef struct _WAIT_CONTEXT_BLOCK {
    KDEVICE_QUEUE_ENTRY WaitQueueEntry;
    PDRIVER_CONTROL DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;


//
// Device Object structure definition
//

typedef struct _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT *DriverObject;
    struct _DEVICE_OBJECT *NextDevice;
    struct _DEVICE_OBJECT *AttachedDevice;
    struct _IRP *CurrentIrp;
    PIO_TIMER Timer;
    ULONG Flags;                                // See above:  DO_...
    ULONG Characteristics;                      // See ntioapi:  FILE_...
    PVPB Vpb;
    PVOID DeviceExtension;
    DEVICE_TYPE DeviceType;
    CCHAR StackSize;
    union {
        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;

    //
    //  The following field is for exclusive use by the filesystem to keep
    //  track of the number of Fsp threads currently using the device
    //

    ULONG ActiveThreadCount;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    KEVENT DeviceLock;

    USHORT SectorSize;
    USHORT Spare1;

    struct _DEVOBJ_EXTENSION  *DeviceObjectExtension;
    PVOID  Reserved;
} DEVICE_OBJECT;

typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; // ntndis

typedef struct _IO_WORKITEM *PIO_WORKITEM;

typedef
VOID
(*PIO_WORKITEM_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

PIO_WORKITEM
IoAllocateWorkItem(
    PDEVICE_OBJECT DeviceObject
    );

VOID
IoFreeWorkItem(
    PIO_WORKITEM IoWorkItem
    );

VOID
IoQueueWorkItem(
    IN PIO_WORKITEM IoWorkItem,
    IN PIO_WORKITEM_ROUTINE WorkerRoutine,
    IN WORK_QUEUE_TYPE QueueType,
    IN PVOID Context
    );

//
// Zone Allocation
//

typedef struct _ZONE_SEGMENT_HEADER {
    SINGLE_LIST_ENTRY SegmentList;
    PVOID Reserved;
} ZONE_SEGMENT_HEADER, *PZONE_SEGMENT_HEADER;

typedef struct _ZONE_HEADER {
    SINGLE_LIST_ENTRY FreeList;
    SINGLE_LIST_ENTRY SegmentList;
    ULONG BlockSize;
    ULONG TotalSegmentSize;
} ZONE_HEADER, *PZONE_HEADER;


NTKERNELAPI
NTSTATUS
ExInitializeZone(
    IN PZONE_HEADER Zone,
    IN ULONG BlockSize,
    IN PVOID InitialSegment,
    IN ULONG InitialSegmentSize
    );

NTKERNELAPI
NTSTATUS
ExExtendZone(
    IN PZONE_HEADER Zone,
    IN PVOID Segment,
    IN ULONG SegmentSize
    );

NTKERNELAPI
NTSTATUS
ExInterlockedExtendZone(
    IN PZONE_HEADER Zone,
    IN PVOID Segment,
    IN ULONG SegmentSize,
    IN PKSPIN_LOCK Lock
    );

//++
//
// PVOID
// ExAllocateFromZone(
//     IN PZONE_HEADER Zone
//     )
//
// Routine Description:
//
//     This routine removes an entry from the zone and returns a pointer to it.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage from which the
//         entry is to be allocated.
//
// Return Value:
//
//     The function value is a pointer to the storage allocated from the zone.
//
//--

#define ExAllocateFromZone(Zone) \
    (PVOID)((Zone)->FreeList.Next); \
    if ( (Zone)->FreeList.Next ) (Zone)->FreeList.Next = (Zone)->FreeList.Next->Next


//++
//
// PVOID
// ExFreeToZone(
//     IN PZONE_HEADER Zone,
//     IN PVOID Block
//     )
//
// Routine Description:
//
//     This routine places the specified block of storage back onto the free
//     list in the specified zone.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         entry is to be inserted.
//
//     Block - Pointer to the block of storage to be freed back to the zone.
//
// Return Value:
//
//     Pointer to previous block of storage that was at the head of the free
//         list.  NULL implies the zone went from no available free blocks to
//         at least one free block.
//
//--

#define ExFreeToZone(Zone,Block)                                    \
    ( ((PSINGLE_LIST_ENTRY)(Block))->Next = (Zone)->FreeList.Next,  \
      (Zone)->FreeList.Next = ((PSINGLE_LIST_ENTRY)(Block)),        \
      ((PSINGLE_LIST_ENTRY)(Block))->Next                           \
    )


//++
//
// BOOLEAN
// ExIsFullZone(
//     IN PZONE_HEADER Zone
//     )
//
// Routine Description:
//
//     This routine determines if the specified zone is full or not.  A zone
//     is considered full if the free list is empty.
//
// Arguments:
//
//     Zone - Pointer to the zone header to be tested.
//
// Return Value:
//
//     TRUE if the zone is full and FALSE otherwise.
//
//--

#define ExIsFullZone(Zone) \
    ( (Zone)->FreeList.Next == (PSINGLE_LIST_ENTRY)NULL )

//++
//
// PVOID
// ExInterlockedAllocateFromZone(
//     IN PZONE_HEADER Zone,
//     IN PKSPIN_LOCK Lock
//     )
//
// Routine Description:
//
//     This routine removes an entry from the zone and returns a pointer to it.
//     The removal is performed with the specified lock owned for the sequence
//     to make it MP-safe.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage from which the
//         entry is to be allocated.
//
//     Lock - Pointer to the spin lock which should be obtained before removing
//         the entry from the allocation list.  The lock is released before
//         returning to the caller.
//
// Return Value:
//
//     The function value is a pointer to the storage allocated from the zone.
//
//--

#define ExInterlockedAllocateFromZone(Zone,Lock) \
    (PVOID) ExInterlockedPopEntryList( &(Zone)->FreeList, Lock )

//++
//
// PVOID
// ExInterlockedFreeToZone(
//     IN PZONE_HEADER Zone,
//     IN PVOID Block,
//     IN PKSPIN_LOCK Lock
//     )
//
// Routine Description:
//
//     This routine places the specified block of storage back onto the free
//     list in the specified zone.  The insertion is performed with the lock
//     owned for the sequence to make it MP-safe.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         entry is to be inserted.
//
//     Block - Pointer to the block of storage to be freed back to the zone.
//
//     Lock - Pointer to the spin lock which should be obtained before inserting
//         the entry onto the free list.  The lock is released before returning
//         to the caller.
//
// Return Value:
//
//     Pointer to previous block of storage that was at the head of the free
//         list.  NULL implies the zone went from no available free blocks to
//         at least one free block.
//
//--

#define ExInterlockedFreeToZone(Zone,Block,Lock) \
    ExInterlockedPushEntryList( &(Zone)->FreeList, ((PSINGLE_LIST_ENTRY) (Block)), Lock )


//++
//
// BOOLEAN
// ExIsObjectInFirstZoneSegment(
//     IN PZONE_HEADER Zone,
//     IN PVOID Object
//     )
//
// Routine Description:
//
//     This routine determines if the specified pointer lives in the zone.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         object may belong.
//
//     Object - Pointer to the object in question.
//
// Return Value:
//
//     TRUE if the Object came from the first segment of zone.
//
//--

#define ExIsObjectInFirstZoneSegment(Zone,Object) ((BOOLEAN)     \
    (((PUCHAR)(Object) >= (PUCHAR)(Zone)->SegmentList.Next) &&   \
     ((PUCHAR)(Object) < (PUCHAR)(Zone)->SegmentList.Next +      \
                         (Zone)->TotalSegmentSize))              \
)

//
//  Define executive resource data structures.
//

typedef ULONG ERESOURCE_THREAD;
typedef ERESOURCE_THREAD *PERESOURCE_THREAD;

typedef struct _OWNER_ENTRY {
    ERESOURCE_THREAD OwnerThread;
    SHORT OwnerCount;
    USHORT TableSize;
} OWNER_ENTRY, *POWNER_ENTRY;

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    POWNER_ENTRY OwnerTable;
    SHORT ActiveCount;
    USHORT Flag;
    PKSEMAPHORE SharedWaiters;
    PKEVENT ExclusiveWaiters;
    OWNER_ENTRY OwnerThreads[2];
    ULONG ContentionCount;
    USHORT NumberOfSharedWaiters;
    USHORT NumberOfExclusiveWaiters;
    union {
        PVOID Address;
        ULONG CreatorBackTraceIndex;
    };
    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;

//
//  Values for ERESOURCE.Flag
//
#define ResourceNeverExclusive          0x10
#define ResourceReleaseByOtherThread    0x20
#define ResourceOwnedExclusive          0x80

#define RESOURCE_HASH_TABLE_SIZE 64

typedef struct _RESOURCE_HASH_ENTRY {
    LIST_ENTRY ListEntry;
    PVOID Address;
    ULONG ContentionCount;
    ULONG Number;
} RESOURCE_HASH_ENTRY, *PRESOURCE_HASH_ENTRY;

typedef struct _RESOURCE_PERFORMANCE_DATA {
    ULONG ActiveResourceCount;
    ULONG TotalResourceCount;
    ULONG ExclusiveAcquire;
    ULONG SharedFirstLevel;
    ULONG SharedSecondLevel;
    ULONG StarveFirstLevel;
    ULONG StarveSecondLevel;
    ULONG WaitForExclusive;
    ULONG OwnerTableExpands;
    ULONG MaximumTableExpand;
    LIST_ENTRY HashTable[RESOURCE_HASH_TABLE_SIZE];
} RESOURCE_PERFORMANCE_DATA, *PRESOURCE_PERFORMANCE_DATA;

//
// Define executive resource function prototypes.
//

NTKERNELAPI
NTSTATUS
ExInitializeResourceLite(
    IN PERESOURCE Resource
    );

NTKERNELAPI
NTSTATUS
ExReinitializeResourceLite(
    IN PERESOURCE Resource
    );

NTKERNELAPI
BOOLEAN
ExAcquireResourceSharedLite(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );

NTKERNELAPI
BOOLEAN
ExAcquireResourceExclusiveLite(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );

NTKERNELAPI
BOOLEAN
ExAcquireSharedStarveExclusive(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );

NTKERNELAPI
BOOLEAN
ExAcquireSharedWaitForExclusive(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );

NTKERNELAPI
BOOLEAN
ExTryToAcquireResourceExclusiveLite(
    IN PERESOURCE Resource
    );

//
//  VOID
//  ExReleaseResource(
//      IN PERESOURCE Resource
//      );
//

#define ExReleaseResource(R) (ExReleaseResourceLite(R))

NTKERNELAPI
VOID
FASTCALL
ExReleaseResourceLite(
    IN PERESOURCE Resource
    );

NTKERNELAPI
VOID
ExReleaseResourceForThreadLite(
    IN PERESOURCE Resource,
    IN ERESOURCE_THREAD ResourceThreadId
    );

NTKERNELAPI
VOID
ExConvertExclusiveToSharedLite(
    IN PERESOURCE Resource
    );

NTKERNELAPI
NTSTATUS
ExDeleteResourceLite (
    IN PERESOURCE Resource
    );

NTKERNELAPI
ULONG
ExGetExclusiveWaiterCount (
    IN PERESOURCE Resource
    );

NTKERNELAPI
ULONG
ExGetSharedWaiterCount (
    IN PERESOURCE Resource
    );

//
//  ERESOURCE_THREAD
//  ExGetCurrentResourceThread(
//      );
//

#define ExGetCurrentResourceThread() ((ULONG)PsGetCurrentThread())

NTKERNELAPI
BOOLEAN
ExIsResourceAcquiredExclusiveLite (
    IN PERESOURCE Resource
    );

NTKERNELAPI
USHORT
ExIsResourceAcquiredSharedLite (
    IN PERESOURCE Resource
    );

//
//  ntddk.h stole the entry points we wanted, so fix them up here.
//

#define ExInitializeResource ExInitializeResourceLite
#define ExAcquireResourceShared ExAcquireResourceSharedLite
#define ExAcquireResourceExclusive ExAcquireResourceExclusiveLite
#define ExReleaseResourceForThread ExReleaseResourceForThreadLite
#define ExConvertExclusiveToShared ExConvertExclusiveToSharedLite
#define ExDeleteResource ExDeleteResourceLite
#define ExIsResourceAcquiredExclusive ExIsResourceAcquiredExclusiveLite
#define ExIsResourceAcquiredShared ExIsResourceAcquiredSharedLite


//
// Raise status from kernel mode.
//

NTKERNELAPI
VOID
NTAPI
ExRaiseStatus (
    IN NTSTATUS Status
    );

NTKERNELAPI
VOID
ExRaiseDatatypeMisalignment (
    VOID
    );

NTKERNELAPI
VOID
ExRaiseAccessViolation (
    VOID
    );


//
// Subtract time zone bias from system time to get local time.
//
NTKERNELAPI
VOID
ExSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    );

//
// Add time zone bias to local time to get system time.
//
NTKERNELAPI
VOID
ExLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    );



NTKERNELAPI
VOID
ExPostSystemEvent(
    IN SYSTEM_EVENT_ID EventID,
    IN PVOID           EventData OPTIONAL,
    IN ULONG           EventDataLength
    );


//
// Define the type for Callback function.
//

typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;

typedef VOID (*PCALLBACK_FUNCTION ) (
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );


NTKERNELAPI
NTSTATUS
ExCreateCallback (
    OUT PCALLBACK_OBJECT *CallbackObject,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN Create,
    IN BOOLEAN AllowMultipleCallbacks
    );

NTKERNELAPI
PVOID
ExRegisterCallback (
    IN PCALLBACK_OBJECT CallbackObject,
    IN PCALLBACK_FUNCTION CallbackFunction,
    IN PVOID CallbackContext
    );

NTKERNELAPI
VOID
ExUnregisterCallback (
    IN PVOID CallbackRegistration
    );

NTKERNELAPI
VOID
ExNotifyCallback (
    IN PVOID CallbackObject,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

//
// Priority increment definitions.  The comment for each definition gives
// the names of the system services that use the definition when satisfying
// a wait.
//
//
// Priority increment when no I/O has been done.  This is used by device
// and file system drivers when completing an IRP (IoCompleteRequest).
//

#define IO_NO_INCREMENT                 0

//
// Priority increment for completing CD-ROM I/O.  This is used by CD-ROM device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_CD_ROM_INCREMENT             1

//
// Priority increment for completing disk I/O.  This is used by disk device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_DISK_INCREMENT               1

//
// Priority increment for completing keyboard I/O.  This is used by keyboard
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_KEYBOARD_INCREMENT           6

//
// Priority increment for completing mailslot I/O.  This is used by the mail-
// slot file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_MAILSLOT_INCREMENT           2

//
// Priority increment for completing mouse I/O.  This is used by mouse device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_MOUSE_INCREMENT              6

//
// Priority increment for completing named pipe I/O.  This is used by the
// named pipe file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_NAMED_PIPE_INCREMENT         2

//
// Priority increment for completing network I/O.  This is used by network
// device and network file system drivers when completing an IRP
// (IoCompleteRequest).
//

#define IO_NETWORK_INCREMENT            2

//
// Priority increment for completing parallel I/O.  This is used by parallel
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_PARALLEL_INCREMENT           1

//
// Priority increment for completing serial I/O.  This is used by serial device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SERIAL_INCREMENT             2

//
// Priority increment for completing sound I/O.  This is used by sound device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SOUND_INCREMENT              8

//
// Priority increment for completing video I/O.  This is used by video device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_VIDEO_INCREMENT              1

//
// Priority increment used when satisfying a wait on an executive semaphore
// (NtReleaseSemaphore)
//

#define SEMAPHORE_INCREMENT             1

//
// Define maximum disk transfer size to be used by MM and Cache Manager,
// so that packet-oriented disk drivers can optimize their packet allocation
// to this size.
//

#define MM_MAXIMUM_DISK_IO_SIZE          (0x10000)

//++
//
// ULONG
// ROUND_TO_PAGES (
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The ROUND_TO_PAGES macro takes a size in bytes and rounds it up to a
//     multiple of the page size.
//
//     NOTE: This macro fails for values 0xFFFFFFFF - (PAGE_SIZE - 1).
//
// Arguments:
//
//     Size - Size in bytes to round up to a page multiple.
//
// Return Value:
//
//     Returns the size rounded up to a multiple of the page size.
//
//--

#define ROUND_TO_PAGES(Size)  (((ULONG)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

//++
//
// ULONG
// BYTES_TO_PAGES (
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The BYTES_TO_PAGES macro takes the size in bytes and calculates the
//     number of pages required to contain the bytes.
//
// Arguments:
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages required to contain the specified size.
//
//--

#define BYTES_TO_PAGES(Size)  (((ULONG)(Size) >> PAGE_SHIFT) + \
                               (((ULONG)(Size) & (PAGE_SIZE - 1)) != 0))

//++
//
// ULONG
// BYTE_OFFSET (
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET(Va) ((ULONG)(Va) & (PAGE_SIZE - 1))

//++
//
// PVOID
// PAGE_ALIGN (
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN(Va) ((PVOID)((ULONG)(Va) & ~(PAGE_SIZE - 1)))

//++
//
// ULONG
// ADDRESS_AND_SIZE_TO_SPAN_PAGES (
//     IN PVOID Va,
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The ADDRESS_AND_SIZE_TO_SPAN_PAGES macro takes a virtual address and
//     size and returns the number of pages spanned by the size.
//
// Arguments:
//
//     Va - Virtual address.
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages spanned by the size.
//
//--

#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size) \
   ((((ULONG)((ULONG)(Size) - 1L) >> PAGE_SHIFT) + \
   (((((ULONG)(Size-1)&(PAGE_SIZE-1)) + ((ULONG)Va & (PAGE_SIZE -1)))) >> PAGE_SHIFT)) + 1L)

#define COMPUTE_PAGES_SPANNED(Va, Size) \
    ((((ULONG)Va & (PAGE_SIZE -1)) + (Size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT)

//++
//
// PVOID
// MmGetMdlVirtualAddress (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlVirtualAddress returns the virual address of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the buffer described by the Mdl
//
//--

#define MmGetMdlVirtualAddress(Mdl)  ((PVOID) ((PCHAR) (Mdl)->StartVa + (Mdl)->ByteOffset))

//++
//
// ULONG
// MmGetMdlByteCount (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteCount returns the length in bytes of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte count of the buffer described by the Mdl
//
//--

#define MmGetMdlByteCount(Mdl)  ((Mdl)->ByteCount)

//++
//
// ULONG
// MmGetMdlByteOffset (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteOffset returns the byte offset within the page
//     of the buffer described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte offset within the page of the buffer described by the Mdl
//
//--

#define MmGetMdlByteOffset(Mdl)  ((Mdl)->ByteOffset)

typedef enum _MM_SYSTEM_SIZE {
    MmSmallSystem,
    MmMediumSystem,
    MmLargeSystem
} MM_SYSTEMSIZE;

NTKERNELAPI
MM_SYSTEMSIZE
MmQuerySystemSize(
    VOID
    );

NTKERNELAPI
BOOLEAN
MmIsThisAnNtAsSystem(
    VOID
    );

typedef enum _LOCK_OPERATION {
    IoReadAccess,
    IoWriteAccess,
    IoModifyAccess
} LOCK_OPERATION;

//
// I/O support routines.
//

NTKERNELAPI
VOID
MmProbeAndLockPages (
    IN OUT PMDL MemoryDescriptorList,
    IN KPROCESSOR_MODE AccessMode,
    IN LOCK_OPERATION Operation
    );

NTKERNELAPI
VOID
MmUnlockPages (
    IN PMDL MemoryDescriptorList
    );

NTKERNELAPI
VOID
MmBuildMdlForNonPagedPool (
    IN OUT PMDL MemoryDescriptorList
    );

NTKERNELAPI
PVOID
MmMapLockedPages (
    IN PMDL MemoryDescriptorList,
    IN KPROCESSOR_MODE AccessMode
    );

NTKERNELAPI
VOID
MmUnmapLockedPages (
    IN PVOID BaseAddress,
    IN PMDL MemoryDescriptorList
    );


NTKERNELAPI
PVOID
MmMapIoSpace (
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN CacheEnable
    );

NTKERNELAPI
VOID
MmUnmapIoSpace (
    IN PVOID BaseAddress,
    IN ULONG NumberOfBytes
    );

NTKERNELAPI
PHYSICAL_ADDRESS
MmGetPhysicalAddress (
    IN PVOID BaseAddress
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemory (
    IN ULONG NumberOfBytes,
    IN PHYSICAL_ADDRESS HighestAcceptableAddress
    );

NTKERNELAPI
VOID
MmFreeContiguousMemory (
    IN PVOID BaseAddress
    );

NTKERNELAPI
PVOID
MmAllocateNonCachedMemory (
    IN ULONG NumberOfBytes
    );

NTKERNELAPI
VOID
MmFreeNonCachedMemory (
    IN PVOID BaseAddress,
    IN ULONG NumberOfBytes
    );

NTKERNELAPI
BOOLEAN
MmIsAddressValid (
    IN PVOID VirtualAddress
    );


NTKERNELAPI
BOOLEAN
MmIsNonPagedSystemAddressValid (
    IN PVOID VirtualAddress
    );

NTKERNELAPI
ULONG
MmSizeOfMdl(
    IN PVOID Base,
    IN ULONG Length
    );

NTKERNELAPI
PMDL
MmCreateMdl(
    IN PMDL MemoryDescriptorList OPTIONAL,
    IN PVOID Base,
    IN ULONG Length
    );

NTKERNELAPI
PVOID
MmLockPagableDataSection(
    IN PVOID AddressWithinSection
    );

NTKERNELAPI
VOID
MmLockPagableSectionByHandle (
    IN PVOID ImageSectionHandle
    );


NTKERNELAPI
VOID
MmResetDriverPaging (
    IN PVOID AddressWithinSection
    );


NTKERNELAPI
PVOID
MmPageEntireDriver (
    IN PVOID AddressWithinSection
    );

NTKERNELAPI
VOID
MmUnlockPagableImageSection(
    IN PVOID ImageSectionHandle
    );


NTKERNELAPI
HANDLE
MmSecureVirtualMemory (
    IN PVOID Address,
    IN ULONG Size,
    IN ULONG ProbeMode
    );

NTKERNELAPI
VOID
MmUnsecureVirtualMemory (
    IN HANDLE SecureHandle
    );

NTKERNELAPI
NTSTATUS
MmMapViewInSystemSpace (
    IN PVOID Section,
    OUT PVOID *MappedBase,
    IN PULONG ViewSize
    );

NTKERNELAPI
NTSTATUS
MmUnmapViewInSystemSpace (
    IN PVOID MappedBase
    );



//++
//
// VOID
// MmInitializeMdl (
//     IN PMDL MemoryDescriptorList,
//     IN PVOID BaseVa,
//     IN ULONG Length
//     )
//
// Routine Description:
//
//     This routine initializes the header of a Memory Descriptor List (MDL).
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to initialize.
//
//     BaseVa - Base virtual address mapped by the MDL.
//
//     Length - Length, in bytes, of the buffer mapped by the MDL.
//
// Return Value:
//
//     None.
//
//--

#define MmInitializeMdl(MemoryDescriptorList, BaseVa, Length) { \
    (MemoryDescriptorList)->Next = (PMDL) NULL; \
    (MemoryDescriptorList)->Size = (CSHORT)(sizeof(MDL) +  \
            (sizeof(ULONG) * ADDRESS_AND_SIZE_TO_SPAN_PAGES((BaseVa), (Length)))); \
    (MemoryDescriptorList)->MdlFlags = 0; \
    (MemoryDescriptorList)->StartVa = (PVOID) PAGE_ALIGN((BaseVa)); \
    (MemoryDescriptorList)->ByteOffset = BYTE_OFFSET((BaseVa)); \
    (MemoryDescriptorList)->ByteCount = (Length); \
    }

//++
//
// PVOID
// MmGetSystemAddressForMdl (
//     IN PMDL MDL
//     )
//
// Routine Description:
//
//     This routine returns the mapped address of an MDL, if the
//     Mdl is not already mapped or a system address, it is mapped.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to map.
//
// Return Value:
//
//     Returns the base address where the pages are mapped.  The base address
//     has the same offset as the virtual address in the MDL.
//
//--

//#define MmGetSystemAddressForMdl(MDL)
//     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA)) ?
//                             ((MDL)->MappedSystemVa) :
//                ((((MDL)->MdlFlags & (MDL_SOURCE_IS_NONPAGED_POOL)) ?
//                      ((PVOID)((ULONG)(MDL)->StartVa | (MDL)->ByteOffset)) :
//                            (MmMapLockedPages((MDL),KernelMode)))))

#define MmGetSystemAddressForMdl(MDL)                                  \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |                    \
                        MDL_SOURCE_IS_NONPAGED_POOL)) ?                \
                             ((MDL)->MappedSystemVa) :                 \
                             (MmMapLockedPages((MDL),KernelMode)))

//++
//
// VOID
// MmPrepareMdlForReuse (
//     IN PMDL MDL
//     )
//
// Routine Description:
//
//     This routine will take all of the steps necessary to allow an MDL to be
//     re-used.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL that will be re-used.
//
// Return Value:
//
//     None.
//
//--

#define MmPrepareMdlForReuse(MDL)                                       \
    if (((MDL)->MdlFlags & MDL_PARTIAL_HAS_BEEN_MAPPED) != 0) {         \
        ASSERT(((MDL)->MdlFlags & MDL_PARTIAL) != 0);                   \
        MmUnmapLockedPages( (MDL)->MappedSystemVa, (MDL) );             \
    } else if (((MDL)->MdlFlags & MDL_PARTIAL) == 0) {                  \
        ASSERT(((MDL)->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0);       \
    }


//
//  Security operation codes
//

typedef enum _SECURITY_OPERATION_CODE {
    SetSecurityDescriptor,
    QuerySecurityDescriptor,
    DeleteSecurityDescriptor,
    AssignSecurityDescriptor
    } SECURITY_OPERATION_CODE, *PSECURITY_OPERATION_CODE;

//
//  Data structure used to capture subject security context
//  for access validations and auditing.
//
//  THE FIELDS OF THIS DATA STRUCTURE SHOULD BE CONSIDERED OPAQUE
//  BY ALL EXCEPT THE SECURITY ROUTINES.
//

typedef struct _SECURITY_SUBJECT_CONTEXT {
    PACCESS_TOKEN ClientToken;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PACCESS_TOKEN PrimaryToken;
    PVOID ProcessAuditId;
    } SECURITY_SUBJECT_CONTEXT, *PSECURITY_SUBJECT_CONTEXT;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                  ACCESS_STATE and related structures                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//  Initial Privilege Set - Room for three privileges, which should
//  be enough for most applications.  This structure exists so that
//  it can be imbedded in an ACCESS_STATE structure.  Use PRIVILEGE_SET
//  for all other references to Privilege sets.
//

#define INITIAL_PRIVILEGE_COUNT         3

typedef struct _INITIAL_PRIVILEGE_SET {
    ULONG PrivilegeCount;
    ULONG Control;
    LUID_AND_ATTRIBUTES Privilege[INITIAL_PRIVILEGE_COUNT];
    } INITIAL_PRIVILEGE_SET, * PINITIAL_PRIVILEGE_SET;



//
// Combine the information that describes the state
// of an access-in-progress into a single structure
//


typedef struct _ACCESS_STATE {
   LUID OperationID;
   BOOLEAN SecurityEvaluated;
   BOOLEAN GenerateAudit;
   BOOLEAN GenerateOnClose;
   BOOLEAN PrivilegesAllocated;
   ULONG Flags;
   ACCESS_MASK RemainingDesiredAccess;
   ACCESS_MASK PreviouslyGrantedAccess;
   ACCESS_MASK OriginalDesiredAccess;
   SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
   PSECURITY_DESCRIPTOR SecurityDescriptor;
   PPRIVILEGE_SET PrivilegesUsed;
   union {
      INITIAL_PRIVILEGE_SET InitialPrivilegeSet;
      PRIVILEGE_SET PrivilegeSet;
      } Privileges;
          
   BOOLEAN AuditPrivileges;
   UNICODE_STRING ObjectName;
   UNICODE_STRING ObjectTypeName;

   } ACCESS_STATE, *PACCESS_STATE;


NTKERNELAPI
NTSTATUS
SeAssignSecurity (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR ExplicitDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    IN BOOLEAN IsDirectoryObject,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext,
    IN PGENERIC_MAPPING GenericMapping,
    IN POOL_TYPE PoolType
    );

NTKERNELAPI
NTSTATUS
SeDeassignSecurity (
    IN OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );


NTKERNELAPI
BOOLEAN
SeAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN BOOLEAN SubjectContextLocked,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK PreviouslyGrantedAccess,
    OUT PPRIVILEGE_SET *Privileges OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN KPROCESSOR_MODE AccessMode,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );


BOOLEAN
SeValidSecurityDescriptor(
    IN ULONG Length,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTKERNELAPI                                                     
BOOLEAN                                                         
SeSinglePrivilegeCheck(                                         
    LUID PrivilegeValue,                                        
    KPROCESSOR_MODE PreviousMode                                
    );                                                          
//
// System Thread and Process Creation and Termination
//

NTKERNELAPI
NTSTATUS
PsCreateSystemThread(
    OUT PHANDLE ThreadHandle,
    IN ULONG DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle OPTIONAL,
    OUT PCLIENT_ID ClientId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    );

NTKERNELAPI
NTSTATUS
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    );

//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d

//
// Define the major function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_SET_POWER                0x16
#define IRP_MJ_QUERY_POWER              0x17
#define IRP_MJ_MAXIMUM_FUNCTION         0x17

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

//
// Directory control minor function codes
//

#define IRP_MN_QUERY_DIRECTORY          0x01
#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02

//
// File system control minor function codes.  Note that "user request" is
// assumed to be zero by both the I/O system and file systems.  Do not change
// this value.
//

#define IRP_MN_USER_FS_REQUEST          0x00
#define IRP_MN_MOUNT_VOLUME             0x01
#define IRP_MN_VERIFY_VOLUME            0x02
#define IRP_MN_LOAD_FILE_SYSTEM         0x03

//
// Lock control minor function codes
//

#define IRP_MN_LOCK                     0x01
#define IRP_MN_UNLOCK_SINGLE            0x02
#define IRP_MN_UNLOCK_ALL               0x03
#define IRP_MN_UNLOCK_ALL_BY_KEY        0x04

//
// Read and Write minor function codes for file systems supporting Lan Manager
// software.  All of these subfunction codes are invalid if the file has been
// opened with FO_NO_INTERMEDIATE_BUFFERING.  They are also invalid in combi-
// nation with synchronous calls (Irp Flag or file open option).
//
// Note that "normal" is assumed to be zero by both the I/O system and file
// systems.  Do not change this value.
//

#define IRP_MN_NORMAL                   0x00
#define IRP_MN_DPC                      0x01
#define IRP_MN_MDL                      0x02
#define IRP_MN_COMPLETE                 0x04

#define IRP_MN_MDL_DPC                  (IRP_MN_MDL | IRP_MN_DPC)
#define IRP_MN_COMPLETE_MDL             (IRP_MN_COMPLETE | IRP_MN_MDL)
#define IRP_MN_COMPLETE_MDL_DPC         (IRP_MN_COMPLETE_MDL | IRP_MN_DPC)

//
// Device Control Request minor function codes for SCSI support. Note that
// user requests are assumed to be zero.
//

#define IRP_MN_SCSI_CLASS               0x01

//
// Define option flags for IoCreateFile.  Note that these values must be
// exactly the same as the SL_... flags for a create function.  Note also
// that there are flags that may be passed to IoCreateFile that are not
// placed in the stack location for the create IRP.  These flags start in
// the next byte.
//

#define IO_FORCE_ACCESS_CHECK           0x0001
#define IO_OPEN_PAGING_FILE             0x0002
#define IO_OPEN_TARGET_DIRECTORY        0x0004

//
// Define callout routine type for use in IoQueryDeviceDescription().
//

typedef NTSTATUS (*PIO_QUERY_DEVICE_ROUTINE)(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

//
// Defines the order of the information in the array of
// PKEY_VALUE_FULL_INFORMATION.
//

typedef enum _IO_QUERY_DEVICE_DATA_FORMAT {
    IoQueryDeviceIdentifier = 0,
    IoQueryDeviceConfigurationData,
    IoQueryDeviceComponentInformation,
    IoQueryDeviceMaxData
} IO_QUERY_DEVICE_DATA_FORMAT, *PIO_QUERY_DEVICE_DATA_FORMAT;

//
// Define the objects that can be created by IoCreateFile.
//

typedef enum _CREATE_FILE_TYPE {
    CreateFileTypeNone,
    CreateFileTypeNamedPipe,
    CreateFileTypeMailslot
} CREATE_FILE_TYPE;

//
// Define the structures used by the I/O system
//

//
// Define empty typedefs for the _IRP, _DEVICE_OBJECT, and _DRIVER_OBJECT
// structures so they may be referenced by function types before they are
// actually defined.
//

struct _DEVICE_OBJECT;
struct _DRIVER_OBJECT;
struct _DRIVE_LAYOUT_INFORMATION;
struct _DISK_PARTITION;
struct _FILE_OBJECT;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;

//
// Define the I/O version of a DPC routine.
//

typedef
VOID
(*PIO_DPC_ROUTINE) (
    IN PKDPC Dpc,
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID Context
    );

//
// Define driver timer routine type.
//

typedef
VOID
(*PIO_TIMER_ROUTINE) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN PVOID Context
    );

//
// Define driver initialization routine type.
//

typedef
NTSTATUS
(*PDRIVER_INITIALIZE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

//
// Define driver reinitialization routine type.
//

typedef
VOID
(*PDRIVER_REINITIALIZE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PVOID Context,
    IN ULONG Count
    );

//
// Define driver cancel routine type.
//

typedef
VOID
(*PDRIVER_CANCEL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISPATCH) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver start I/O routine type.
//

typedef
VOID
(*PDRIVER_STARTIO) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver unload routine type.
//

typedef
VOID
(*PDRIVER_UNLOAD) (
    IN struct _DRIVER_OBJECT *DriverObject
    );


//
// Define fast I/O procedure prototypes.
//
// Fast I/O read and write procedures.
//

typedef
BOOLEAN
(*PFAST_IO_CHECK_IF_POSSIBLE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_READ) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O query basic and standard information procedures.
//

typedef
BOOLEAN
(*PFAST_IO_QUERY_BASIC_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_QUERY_STANDARD_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O lock and unlock procedures.
//

typedef
BOOLEAN
(*PFAST_IO_LOCK) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_SINGLE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_ALL) (
    IN struct _FILE_OBJECT *FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_ALL_BY_KEY) (
    IN struct _FILE_OBJECT *FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O device control procedure.
//

typedef
BOOLEAN
(*PFAST_IO_DEVICE_CONTROL) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define callbacks for NtCreateSection to synchronize correctly with
// the file system.  It pre-acquires the resources that will be needed
// when calling to query and set file/allocation size in the file system.
//

typedef
VOID
(*PFAST_IO_ACQUIRE_FILE) (
    IN struct _FILE_OBJECT *FileObject
    );

typedef
VOID
(*PFAST_IO_RELEASE_FILE) (
    IN struct _FILE_OBJECT *FileObject
    );

//
// Define callback for drivers that have device objects attached to lower-
// level drivers' device objects.  This callback is made when the lower-level
// driver is deleting its device object.
//

typedef
VOID
(*PFAST_IO_DETACH_DEVICE) (
    IN struct _DEVICE_OBJECT *SourceDevice,
    IN struct _DEVICE_OBJECT *TargetDevice
    );

//
// Define the structure to describe the Fast I/O dispatch routines.  Any
// additions made to this structure MUST be added monotonically to the end
// of the structure, and fields CANNOT be removed from the middle.
//

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PFAST_IO_CHECK_IF_POSSIBLE FastIoCheckIfPossible;
    PFAST_IO_READ FastIoRead;
    PFAST_IO_WRITE FastIoWrite;
    PFAST_IO_QUERY_BASIC_INFO FastIoQueryBasicInfo;
    PFAST_IO_QUERY_STANDARD_INFO FastIoQueryStandardInfo;
    PFAST_IO_LOCK FastIoLock;
    PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle;
    PFAST_IO_UNLOCK_ALL FastIoUnlockAll;
    PFAST_IO_UNLOCK_ALL_BY_KEY FastIoUnlockAllByKey;
    PFAST_IO_DEVICE_CONTROL FastIoDeviceControl;
    PFAST_IO_ACQUIRE_FILE AcquireFileForNtCreateSection;
    PFAST_IO_RELEASE_FILE ReleaseFileForNtCreateSection;
    PFAST_IO_DETACH_DEVICE FastIoDetachDevice;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

//
// Define device driver adapter/controller execution routine.
//

typedef
IO_ALLOCATION_ACTION
(*PDRIVER_CONTROL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

//
// Define the I/O system's security context type for use by file system's
// when checking access to volumes, files, and directories.
//

typedef struct _IO_SECURITY_CONTEXT {
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    PACCESS_STATE AccessState;
    ACCESS_MASK DesiredAccess;
} IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;

//
// Define Volume Parameter Block (VPB) flags.
//

#define VPB_MOUNTED                     0x00000001
#define VPB_LOCKED                      0x00000002
#define VPB_PERSISTENT                  0x00000004

//
// Define object type specific fields of various objects used by the I/O system
//

typedef struct _ADAPTER_OBJECT *PADAPTER_OBJECT; // ntndis

typedef struct _CONTROLLER_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PVOID ControllerExtension;
    KDEVICE_QUEUE DeviceWaitQueue;

    ULONG Spare1;
    LARGE_INTEGER Spare2;

} CONTROLLER_OBJECT, *PCONTROLLER_OBJECT;


//
// Define Device Object (DO) flags
//

#define DO_UNLOAD_PENDING               0x00000001
#define DO_VERIFY_VOLUME                0x00000002
#define DO_BUFFERED_IO                  0x00000004
#define DO_EXCLUSIVE                    0x00000008
#define DO_DIRECT_IO                    0x00000010
#define DO_MAP_IO_BUFFER                0x00000020
#define DO_DEVICE_HAS_NAME              0x00000040
#define DO_DEVICE_INITIALIZING          0x00000080
#define DO_SYSTEM_BOOT_PARTITION        0x00000100
#define DO_LONG_TERM_REQUESTS           0x00000200
#define DO_NEVER_LAST_DEVICE            0x00000400
#define DO_SHUTDOWN_REGISTERED          0x00000800



typedef struct _DEVOBJ_EXTENSION {

    //
    //
    //

    CSHORT          Type;
    USHORT          Size;

    //
    // Public part of the DeviceObjectExtension structure
    //

    PDEVICE_OBJECT  DeviceObject;               // owning device object

} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

//
// Define Driver Object (DRVO) flags
//

#define DRVO_UNLOAD_INVOKED             0x00000001

typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection;
    ULONG Count;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  Thise is a pointer
    // to the path to the hardware information in the registry
    //

    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PDRIVER_INITIALIZE DriverInit;
    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_UNLOAD DriverUnload;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; // ntndis

//
// The following structure is pointed to by the SectionObject pointer field
// of a file object, and is allocated by the various NT file systems.
//

typedef struct _SECTION_OBJECT_POINTERS {
    PVOID DataSectionObject;
    PVOID SharedCacheMap;
    PVOID ImageSectionObject;
} SECTION_OBJECT_POINTERS;
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    ULONG Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;

//
// Define File Object (FO) flags
//

#define FO_FILE_OPEN                    0x00000001
#define FO_SYNCHRONOUS_IO               0x00000002
#define FO_ALERTABLE_IO                 0x00000004
#define FO_NO_INTERMEDIATE_BUFFERING    0x00000008
#define FO_WRITE_THROUGH                0x00000010
#define FO_SEQUENTIAL_ONLY              0x00000020
#define FO_CACHE_SUPPORTED              0x00000040
#define FO_NAMED_PIPE                   0x00000080
#define FO_STREAM_FILE                  0x00000100
#define FO_MAILSLOT                     0x00000200
#define FO_GENERATE_AUDIT_ON_CLOSE      0x00000400
#define FO_DIRECT_DEVICE_OPEN           0x00000800
#define FO_FILE_MODIFIED                0x00001000
#define FO_FILE_SIZE_CHANGED            0x00002000
#define FO_CLEANUP_COMPLETE             0x00004000
#define FO_TEMPORARY_FILE               0x00008000
#define FO_DELETE_ON_CLOSE              0x00010000
#define FO_OPENED_CASE_SENSITIVE        0x00020000
#define FO_HANDLE_CREATED               0x00040000
#define FO_FILE_FAST_IO_READ            0x00080000
#define FO_FILE_OLE_ACCESS              0x00100000

typedef struct _FILE_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
    PVPB Vpb;
    PVOID FsContext;
    PVOID FsContext2;
    PSECTION_OBJECT_POINTERS SectionObjectPointer;
    PVOID PrivateCacheMap;
    NTSTATUS FinalStatus;
    struct _FILE_OBJECT *RelatedFileObject;
    BOOLEAN LockOperation;
    BOOLEAN DeletePending;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN SharedDelete;
    ULONG Flags;
    UNICODE_STRING FileName;
    LARGE_INTEGER CurrentByteOffset;
    ULONG Waiters;
    ULONG Busy;
    PVOID LastLock;
    KEVENT Lock;
    KEVENT Event;
    PIO_COMPLETION_CONTEXT CompletionContext;
} FILE_OBJECT;
typedef struct _FILE_OBJECT *PFILE_OBJECT; // ntndis

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400
#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000

//
// I/O Request Packet (IRP) definition
//

typedef struct _IRP {
    CSHORT Type;
    USHORT Size;

    //
    // Define the common fields used to control the IRP.
    //

    //
    // Define a pointer to the Memory Descriptor List (MDL) for this I/O
    // request.  This field is only used if the I/O is "direct I/O".
    //

    PMDL MdlAddress;

    //
    // Flags word - used to remember various flags.
    //

    ULONG Flags;

    //
    // The following union is used for one of three purposes:
    //
    //    1. This IRP is an associated IRP.  The field is a pointer to a master
    //       IRP.
    //
    //    2. This is the master IRP.  The field is the count of the number of
    //       IRPs which must complete (associated IRPs) before the master can
    //       complete.
    //
    //    3. This operation is being buffered and the field is the address of
    //       the system space buffer.
    //

    union {
        struct _IRP *MasterIrp;
        LONG IrpCount;
        PVOID SystemBuffer;
    } AssociatedIrp;

    //
    // Thread list entry - allows queueing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Requestor mode - mode of the original requestor of this operation.
    //

    KPROCESSOR_MODE RequestorMode;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Stack state information.
    //

    CHAR StackCount;
    CHAR CurrentLocation;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // Cancel Irql - Irql at which the cancel spinlock was acquired.
    //

    KIRQL CancelIrql;

    //
    // ApcEnvironment - Used to save the APC environment at the time that the
    // packet was initialized.
    //

    CCHAR ApcEnvironment;

    //
    // Allocation control flags.
    //

    UCHAR AllocationFlags;

    //
    // User parameters.
    //

    PIO_STATUS_BLOCK UserIosb;
    PKEVENT UserEvent;
    union {
        struct {
            PIO_APC_ROUTINE UserApcRoutine;
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    //
    // CancelRoutine - Used to contain the address of a cancel routine supplied
    // by a device driver when the IRP is in a cancelable state.
    //

    PDRIVER_CANCEL CancelRoutine;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    PVOID UserBuffer;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    PVOID DriverContext[4];

                } ;

            } ;

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            PETHREAD Thread;

            //
            // Auxiliary buffer - pointer to any auxiliary buffer that is
            // required to pass information to a driver that is not contained
            // in a normal buffer.
            //

            PCHAR AuxiliaryBuffer;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION *CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    ULONG PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            PFILE_OBJECT OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file handle.
        //

        PVOID CompletionKey;

    } Tail;

} IRP, *PIRP;

//
// Define completion routine types for use in stack locations in an IRP
//

typedef
NTSTATUS
(*PIO_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define flags for various functions
//

//
// Create / Create Named Pipe
//
// The following flags must exactly match those in the IoCreateFile call's
// options.  The case sensitive flag is added in later, by the parse routine,
// and is not an actual option to open.  Rather, it is part of the object
// manager's attributes structure.
//

#define SL_FORCE_ACCESS_CHECK           0x01
#define SL_OPEN_PAGING_FILE             0x02
#define SL_OPEN_TARGET_DIRECTORY        0x04

#define SL_CASE_SENSITIVE               0x80

//
// Read / Write
//

#define SL_KEY_SPECIFIED                0x01
#define SL_OVERRIDE_VERIFY_VOLUME       0x02
#define SL_WRITE_THROUGH                0x04
#define SL_FT_SEQUENTIAL_WRITE          0x08

//
// Device I/O Control
//
//
// Same SL_OVERRIDE_VERIFY_VOLUME as for read/write above.
//

//
// Lock
//

#define SL_FAIL_IMMEDIATELY             0x01
#define SL_EXCLUSIVE_LOCK               0x02

//
// QueryDirectory / QueryEa
//

#define SL_RESTART_SCAN                 0x01
#define SL_RETURN_SINGLE_ENTRY          0x02
#define SL_INDEX_SPECIFIED              0x04

//
// NotifyDirectory
//

#define SL_WATCH_TREE                   0x01

//
// FileSystemControl
//
//    minor: mount/verify volume
//

#define SL_ALLOW_RAW_MOUNT              0x01

//
// Define I/O Request Packet (IRP) stack locations
//

#if !defined(_ALPHA_)
#include "pshpack4.h"
#endif
typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT FileAttributes;
            USHORT ShareAccess;
            ULONG EaLength;
        } Create;


        //
        // System service parameters for:  NtReadFile
        //

        struct {
            ULONG Length;
            ULONG Key;
            LARGE_INTEGER ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            ULONG Length;
            ULONG Key;
            LARGE_INTEGER ByteOffset;
        } Write;


        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS FileInformationClass;
            PFILE_OBJECT FileObject;
            union {
                struct {
                    BOOLEAN ReplaceIfExists;
                    BOOLEAN AdvanceOnly;
                };
                ULONG ClusterCount;
            };
        } SetFile;


        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS FsInformationClass;
        } QueryVolume;


        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //


        //
        // System service parameters for:  NtDeviceIoControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG InputBufferLength;
            ULONG IoControlCode;
            PVOID Type3InputBuffer;
        } DeviceIoControl;

        //
        // System service parameters for:  NtQuerySecurityObject
        //

        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG Length;
        } QuerySecurity;

        //
        // System service parameters for:  NtSetSecurityObject
        //

        struct {
            SECURITY_INFORMATION SecurityInformation;
            PSECURITY_DESCRIPTOR SecurityDescriptor;
        } SetSecurity;

        //
        // Non-system service parameters.
        //
        // Parameters for MountVolume
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } MountVolume;

        //
        // Parameters for VerifyVolume
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } VerifyVolume;

        //
        // Parameters for Scsi with internal device contorl.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK *Srb;
        } Scsi;

        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //

        //
        // Others - driver-specific
        //

        struct {
            PVOID Argument1;
            PVOID Argument2;
            PVOID Argument3;
            PVOID Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    //

    PFILE_OBJECT FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    PIO_COMPLETION_ROUTINE CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    PVOID Context;

} IO_STACK_LOCATION, *PIO_STACK_LOCATION;
#if !defined(_ALPHA_)
#include "poppack.h"
#endif

//
// Define the share access structure used by file systems to determine
// whether or not another accessor may open the file.
//

typedef struct _SHARE_ACCESS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    ULONG Deleters;
    ULONG SharedRead;
    ULONG SharedWrite;
    ULONG SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;

// begin_nthal

//
// The following structure is used by drivers that are initializing to
// determine the number of devices of a particular type that have already
// been initialized.  It is also used to track whether or not the AtDisk
// address range has already been claimed.  Finally, it is used by the
// NtQuerySystemInformation system service to return device type counts.
//

typedef struct _CONFIGURATION_INFORMATION {

    //
    // This field indicates the total number of disks in the system.  This
    // number should be used by the driver to determine the name of new
    // disks.  This field should be updated by the driver as it finds new
    // disks.
    //

    ULONG DiskCount;                // Count of hard disks thus far
    ULONG FloppyCount;              // Count of floppy disks thus far
    ULONG CdRomCount;               // Count of CD-ROM drives thus far
    ULONG TapeCount;                // Count of tape drives thus far
    ULONG ScsiPortCount;            // Count of SCSI port adapters thus far
    ULONG SerialCount;              // Count of serial devices thus far
    ULONG ParallelCount;            // Count of parallel devices thus far

    //
    // These next two fields indicate ownership of one of the two IO address
    // spaces that are used by WD1003-compatable disk controllers.
    //

    BOOLEAN AtDiskPrimaryAddressClaimed;    // 0x1F0 - 0x1FF
    BOOLEAN AtDiskSecondaryAddressClaimed;  // 0x170 - 0x17F

} CONFIGURATION_INFORMATION, *PCONFIGURATION_INFORMATION;


//
// Public I/O routine definitions
//

NTKERNELAPI
VOID
IoAcquireCancelSpinLock(
    OUT PKIRQL Irql
    );


NTKERNELAPI
NTSTATUS
IoAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

NTKERNELAPI
VOID
IoAllocateController(
    IN PCONTROLLER_OBJECT ControllerObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

NTKERNELAPI
PVOID
IoAllocateErrorLogEntry(
    IN PVOID IoObject,
    IN UCHAR EntrySize
    );

NTKERNELAPI
PIRP
IoAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota
    );

NTKERNELAPI
PMDL
IoAllocateMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp OPTIONAL
    );

//++
//
// VOID
// IoAssignArcName(
//     IN PUNICODE_STRING ArcName,
//     IN PUNICODE_STRING DeviceName
//     )
//
// Routine Description:
//
//     This routine is invoked by drivers of bootable media to create a symbolic
//     link between the ARC name of their device and its NT name.  This allows
//     the system to determine which device in the system was actually booted
//     from since the ARC firmware only deals in ARC names, and NT only deals
//     in NT names.
//
// Arguments:
//
//     ArcName - Supplies the Unicode string representing the ARC name.
//
//     DeviceName - Supplies the name to which the ARCname refers.
//
// Return Value:
//
//     None.
//
//--

#define IoAssignArcName( ArcName, DeviceName ) (  \
    IoCreateSymbolicLink( (ArcName), (DeviceName) ) )

NTKERNELAPI
NTSTATUS
IoAssignResources (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIO_RESOURCE_REQUIREMENTS_LIST RequestedResources,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );


NTKERNELAPI
NTSTATUS
IoAttachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PUNICODE_STRING TargetDevice,
    OUT PDEVICE_OBJECT *AttachedDevice
    );

NTKERNELAPI
NTSTATUS
IoAttachDeviceByPointer(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

NTKERNELAPI
PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );

NTKERNELAPI
PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
VOID
IoBuildPartialMdl(
    IN PMDL SourceMdl,
    IN OUT PMDL TargetMdl,
    IN PVOID VirtualAddress,
    IN ULONG Length
    );

NTKERNELAPI
PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#define IoCallDriver(a,b)   \
        IofCallDriver(a,b)

NTKERNELAPI
BOOLEAN
IoCancelIrp(
    IN PIRP Irp
    );


NTKERNELAPI
NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    );

NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

#define IoCompleteRequest(a,b)  \
        IofCompleteRequest(a,b)

NTKERNELAPI
NTSTATUS
IoConnectInterrupt(
    OUT PKINTERRUPT *InterruptObject,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN PKSPIN_LOCK SpinLock OPTIONAL,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KIRQL SynchronizeIrql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector,
    IN KAFFINITY ProcessorEnableMask,
    IN BOOLEAN FloatingSave
    );

NTKERNELAPI
PCONTROLLER_OBJECT
IoCreateController(
    IN ULONG Size
    );

NTKERNELAPI
NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN PUNICODE_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    );


NTKERNELAPI
NTSTATUS
IoCreateSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    );

NTKERNELAPI
PKEVENT
IoCreateSynchronizationEvent(
    IN PUNICODE_STRING EventName,
    OUT PHANDLE EventHandle
    );

NTKERNELAPI
NTSTATUS
IoCreateUnprotectedSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    );

//++
//
// VOID
// IoDeassignArcName(
//     IN PUNICODE_STRING ArcName
//     )
//
// Routine Description:
//
//     This routine is invoked by drivers to deassign an ARC name that they
//     created to a device.  This is generally only called if the driver is
//     deleting the device object, which means that the driver is probably
//     unloading.
//
// Arguments:
//
//     ArcName - Supplies the ARC name to be removed.
//
// Return Value:
//
//     None.
//
//--

#define IoDeassignArcName( ArcName ) (  \
    IoDeleteSymbolicLink( (ArcName) ) )

NTKERNELAPI
VOID
IoDeleteController(
    IN PCONTROLLER_OBJECT ControllerObject
    );

NTKERNELAPI
VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDeleteSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName
    );

NTKERNELAPI
VOID
IoDetachDevice(
    IN OUT PDEVICE_OBJECT TargetDevice
    );

NTKERNELAPI
VOID
IoDisconnectInterrupt(
    IN PKINTERRUPT InterruptObject
    );


NTKERNELAPI
VOID
IoFreeController(
    IN PCONTROLLER_OBJECT ControllerObject
    );

NTKERNELAPI
VOID
IoFreeIrp(
    IN PIRP Irp
    );

NTKERNELAPI
VOID
IoFreeMdl(
    IN PMDL Mdl
    );

NTKERNELAPI                                 
PCONFIGURATION_INFORMATION                  
IoGetConfigurationInformation( VOID );      

//++
//
// PIO_STACK_LOCATION
// IoGetCurrentIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the current stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the current stack location in the
//     packet.
//
//--

#define IoGetCurrentIrpStackLocation( Irp ) ( (Irp)->Tail.Overlay.CurrentStackLocation )

// end_nthal

NTKERNELAPI
PDEVICE_OBJECT
IoGetDeviceToVerify(
    IN PETHREAD Thread
    );

NTKERNELAPI
PEPROCESS
IoGetCurrentProcess(
    VOID
    );

// begin_nthal

NTKERNELAPI
NTSTATUS
IoGetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTKERNELAPI
PGENERIC_MAPPING
IoGetFileObjectGenericMapping(
    VOID
    );

// end_nthal

//++
//
// ULONG
// IoGetFunctionCodeFromCtlCode(
//     IN ULONG ControlCode
//     )
//
// Routine Description:
//
//     This routine extracts the function code from IOCTL and FSCTL function
//     control codes.
//     This routine should only be used by kernel mode code.
//
// Arguments:
//
//     ControlCode - A function control code (IOCTL or FSCTL) from which the
//         function code must be extracted.
//
// Return Value:
//
//     The extracted function code.
//
// Note:
//
//     The CTL_CODE macro, used to create IOCTL and FSCTL function control
//     codes, is defined in ntioapi.h
//
//--

#define IoGetFunctionCodeFromCtlCode( ControlCode ) (\
    ( ControlCode >> 2) & 0x00000FFF )

// begin_nthal

NTKERNELAPI
PVOID
IoGetInitialStack(
    VOID
    );

//++
//
// PIO_STACK_LOCATION
// IoGetNextIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the next stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the next stack location in the packet.
//
//--

#define IoGetNextIrpStackLocation( Irp ) (\
    (Irp)->Tail.Overlay.CurrentStackLocation - 1 )

NTKERNELAPI
PDEVICE_OBJECT
IoGetRelatedDeviceObject(
    IN PFILE_OBJECT FileObject
    );


//++
//
// VOID
// IoInitializeDpcRequest(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIO_DPC_ROUTINE DpcRoutine
//     )
//
// Routine Description:
//
//     This routine is invoked to initialize the DPC in a device object for a
//     device driver during its initialization routine.  The DPC is used later
//     when the driver interrupt service routine requests that a DPC routine
//     be queued for later execution.
//
// Arguments:
//
//     DeviceObject - Pointer to the device object that the request is for.
//
//     DpcRoutine - Address of the driver's DPC routine to be executed when
//         the DPC is dequeued for processing.
//
// Return Value:
//
//     None.
//
//--

#define IoInitializeDpcRequest( DeviceObject, DpcRoutine ) (\
    KeInitializeDpc( &(DeviceObject)->Dpc,                  \
                     (PKDEFERRED_ROUTINE) (DpcRoutine),     \
                     (DeviceObject) ) )

NTKERNELAPI
VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    );

NTKERNELAPI
NTSTATUS
IoInitializeTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    );


//++
//
// BOOLEAN
// IoIsErrorUserInduced(
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This routine is invoked to determine if an error was as a
//     result of user actions.  Typically these error are related
//     to removable media and will result in a pop-up.
//
// Arguments:
//
//     Status - The status value to check.
//
// Return Value:
//
//     The function value is TRUE if the user induced the error,
//     otherwise FALSE is returned.
//
//--
#define IoIsErrorUserInduced( Status ) ((BOOLEAN)  \
    (((Status) == STATUS_DEVICE_NOT_READY) ||      \
     ((Status) == STATUS_IO_TIMEOUT) ||            \
     ((Status) == STATUS_MEDIA_WRITE_PROTECTED) || \
     ((Status) == STATUS_NO_MEDIA_IN_DEVICE) ||    \
     ((Status) == STATUS_VERIFY_REQUIRED) ||       \
     ((Status) == STATUS_UNRECOGNIZED_MEDIA) ||    \
     ((Status) == STATUS_WRONG_VOLUME)))


NTKERNELAPI
PIRP
IoMakeAssociatedIrp(
    IN PIRP Irp,
    IN CCHAR StackSize
    );

//++
//
// VOID
// IoMarkIrpPending(
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine marks the specified I/O Request Packet (IRP) to indicate
//     that an initial status of STATUS_PENDING was returned to the caller.
//     This is used so that I/O completion can determine whether or not to
//     fully complete the I/O operation requested by the packet.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet to be marked pending.
//
// Return Value:
//
//     None.
//
//--

#define IoMarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED )

NTKERNELAPI                                             
NTSTATUS                                                
IoQueryDeviceDescription(                               
    IN PINTERFACE_TYPE BusType OPTIONAL,                
    IN PULONG BusNumber OPTIONAL,                       
    IN PCONFIGURATION_TYPE ControllerType OPTIONAL,     
    IN PULONG ControllerNumber OPTIONAL,                
    IN PCONFIGURATION_TYPE PeripheralType OPTIONAL,     
    IN PULONG PeripheralNumber OPTIONAL,                
    IN PIO_QUERY_DEVICE_ROUTINE CalloutRoutine,         
    IN PVOID Context                                    
    );                                                  

NTKERNELAPI
VOID
IoRaiseHardError(
    IN PIRP Irp,
    IN PVPB Vpb OPTIONAL,
    IN PDEVICE_OBJECT RealDeviceObject
    );

NTKERNELAPI
BOOLEAN
IoRaiseInformationalHardError(
    IN NTSTATUS ErrorStatus,
    IN PUNICODE_STRING String OPTIONAL,
    IN PKTHREAD Thread OPTIONAL
    );

NTKERNELAPI
VOID
IoRegisterDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    );


NTKERNELAPI
NTSTATUS
IoRegisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoReleaseCancelSpinLock(
    IN KIRQL Irql
    );


NTKERNELAPI
VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );


NTKERNELAPI
NTSTATUS
IoReportResourceUsage(
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    IN BOOLEAN OverrideConflict,
    OUT PBOOLEAN ConflictDetected
    );

//++
//
// VOID
// IoRequestDpc(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIRP Irp,
//     IN PVOID Context
//     )
//
// Routine Description:
//
//     This routine is invoked by the device driver's interrupt service routine
//     to request that a DPC routine be queued for later execution at a lower
//     IRQL.
//
// Arguments:
//
//     DeviceObject - Device object for which the request is being processed.
//
//     Irp - Pointer to the current I/O Request Packet (IRP) for the specified
//         device.
//
//     Context - Provides a general context parameter to be passed to the
//         DPC routine.
//
// Return Value:
//
//     None.
//
//--

#define IoRequestDpc( DeviceObject, Irp, Context ) ( \
    KeInsertQueueDpc( &(DeviceObject)->Dpc, (Irp), (Context) ) )

//++
//
// VOID
// IoSetCancelRoutine(
//     IN PIRP Irp,
//     IN PDRIVER_CANCEL CancelRoutine
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a cancel routine which
//     is to be invoked when an I/O packet has been canceled.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CancelRoutine - Address of the cancel routine that is to be invoked
//         if the IRP is cancelled.
//
// Return Value:
//
//     None.
//
// Note:
//
//     The I/O cancel spin lock must be held when this routine is invoked.
//
//--

#define IoSetCancelRoutine( Irp, NewCancelRoutine ) (  \
    (Irp)->CancelRoutine = (NewCancelRoutine) )

//++
//
// VOID
// IoSetCompletionRoutine(
//     IN PIRP Irp,
//     IN PIO_COMPLETION_ROUTINE CompletionRoutine,
//     IN PVOID Context,
//     IN BOOLEAN InvokeOnSuccess,
//     IN BOOLEAN InvokeOnError,
//     IN BOOLEAN InvokeOnCancel
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--

#define IoSetCompletionRoutine( Irp, Routine, CompletionContext, Success, Error, Cancel ) { \
    PIO_STACK_LOCATION irpSp;                                               \
    ASSERT( (Success) | (Error) | (Cancel) ? (Routine) != NULL : TRUE );    \
    irpSp = IoGetNextIrpStackLocation( (Irp) );                             \
    irpSp->CompletionRoutine = (Routine);                                   \
    irpSp->Context = (CompletionContext);                                   \
    irpSp->Control = 0;                                                     \
    if ((Success)) { irpSp->Control = SL_INVOKE_ON_SUCCESS; }               \
    if ((Error)) { irpSp->Control |= SL_INVOKE_ON_ERROR; }                  \
    if ((Cancel)) { irpSp->Control |= SL_INVOKE_ON_CANCEL; } }


NTKERNELAPI
VOID
IoSetHardErrorOrVerifyDevice(
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject
    );


//++
//
// VOID
// IoSetNextIrpStackLocation (
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to set the current IRP stack location to
//     the next stack location, i.e. it "pushes" the stack.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet (IRP).
//
// Return Value:
//
//     None.
//
//--

#define IoSetNextIrpStackLocation( Irp ) {      \
    (Irp)->CurrentLocation--;                   \
    (Irp)->Tail.Overlay.CurrentStackLocation--; }

NTKERNELAPI
VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    );


//++
//
// USHORT
// IoSizeOfIrp(
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))

NTKERNELAPI
VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable
    );

NTKERNELAPI
VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable,
    IN ULONG Key
    );

NTKERNELAPI
VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL
    );

NTKERNELAPI
VOID
IoStartTimer(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoStopTimer(
    IN PDEVICE_OBJECT DeviceObject
    );


NTKERNELAPI
VOID
IoUnregisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoUpdateShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );

NTKERNELAPI                                     
VOID                                            
IoWriteErrorLogEntry(                           
    IN PVOID ElEntry                            
    );                                          

//
// The following definitions are for HAL structures.
//

// begin_ntminiport
//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

//
// Define the device description structure.
//

typedef struct _DEVICE_DESCRIPTION {
    ULONG Version;
    BOOLEAN Master;
    BOOLEAN ScatterGather;
    BOOLEAN DemandMode;
    BOOLEAN AutoInitialize;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN IgnoreCount;
    BOOLEAN Reserved1;          // must be false
    BOOLEAN Reserved2;          // must be false
    ULONG BusNumber;
    ULONG DmaChannel;
    INTERFACE_TYPE  InterfaceType;
    DMA_WIDTH DmaWidth;
    DMA_SPEED DmaSpeed;
    ULONG MaximumLength;
    ULONG DmaPort;
} DEVICE_DESCRIPTION, *PDEVICE_DESCRIPTION;

//
// Define the supported version numbers for the device description structure.
//

#define DEVICE_DESCRIPTION_VERSION  0
#define DEVICE_DESCRIPTION_VERSION1 1

//
// The following function prototypes are for HAL routines with a prefix of Hal.
//
// General functions.
//

typedef
BOOLEAN
(*PHAL_RESET_DISPLAY_PARAMETERS) (
    IN ULONG Columns,
    IN ULONG Rows
    );

NTHALAPI
VOID
HalAcquireDisplayOwnership (
    IN PHAL_RESET_DISPLAY_PARAMETERS  ResetDisplayParameters
    );

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_) 
                                                
NTHALAPI                                        
ULONG                                           
HalGetDmaAlignmentRequirement (                 
    VOID                                        
    );                                          
                                                
#endif                                          
                                                
#if defined(_M_IX86)                            
                                                
#define HalGetDmaAlignmentRequirement() 1L      
                                                
#endif                                          
                                                
NTHALAPI                                        
VOID                                            
KeFlushWriteBuffer (                            
    VOID                                        
    );                                          
                                                
//
// I/O driver configuration functions.
//

NTHALAPI
NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );

NTHALAPI
ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

NTHALAPI
ULONG
HalSetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

NTHALAPI
ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


NTHALAPI
BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

//
// Values for AddressSpace parameter of HalTranslateBusAddress
//
//      0x0         - Memory space
//      0x1         - Port space
//      0x2 - 0x1F  - Address spaces specific for Alpha
//                      0x2 - UserMode view of memory space
//                      0x3 - UserMode view of port space
//                      0x4 - Dense memory space
//                      0x5 - reserved
//                      0x6 - UserMode view of dense memory space
//                      0x7 - 0x1F - reserved
//


//
// DMA adapter object functions.
//

NTHALAPI
NTSTATUS
HalAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PWAIT_CONTEXT_BLOCK Wcb,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine
    );


NTHALAPI
PVOID
HalAllocateCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

NTHALAPI
PVOID
HalAllocateCrashDumpRegisters(
    IN PADAPTER_OBJECT AdapterObject,
    IN OUT PULONG NumberOfMapRegisters
    );

NTHALAPI
VOID
HalFreeCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

NTHALAPI
ULONG
HalGetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

NTHALAPI
ULONG
HalGetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTHALAPI
PADAPTER_OBJECT
HalGetAdapter(
    IN PDEVICE_DESCRIPTION DeviceDescription,
    IN OUT PULONG NumberOfMapRegisters
    );


//
// The following function prototypes are for HAL routines with a prefix of Io.
//
// DMA adapter object functions.
//

NTHALAPI
ULONG
HalReadDmaCounter(
    IN PADAPTER_OBJECT AdapterObject
    );

NTHALAPI
BOOLEAN
IoFlushAdapterBuffers(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

NTHALAPI
VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    );

NTHALAPI
VOID
IoFreeMapRegisters(
   IN PADAPTER_OBJECT AdapterObject,
   IN PVOID MapRegisterBase,
   IN ULONG NumberOfMapRegisters
   );

NTHALAPI
PHYSICAL_ADDRESS
IoMapTransfer(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    );

NTHALAPI
NTSTATUS
IoReadPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer
    );

NTHALAPI
NTSTATUS
IoSetPartitionInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

NTHALAPI
NTSTATUS
IoWritePartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

//
// Performance counter function.
//

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceCounter (
   IN PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

// begin_ntndis
//
// Stall processor execution function.
//

NTHALAPI
VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    );


typedef
VOID
(*PSLOT_CONTROL_COMPLETION)(
    IN struct _SLOT_CONTROL_CONTEXT     *ControlContext
    );

typedef struct _SLOT_CONTROL_CONTEXT {
    NTSTATUS            Status;
    INTERFACE_TYPE      InterfaceType;
    ULONG               BusNumber;
    PDEVICE_OBJECT      DeviceObject;
    ULONG               SlotNumber;
    ULONG               ControlCode;
    PVOID               Buffer;
    PULONG              BufferLength;
    PVOID               Context;
} SLOT_CONTROL_CONTEXT, *PSLOT_CONTROL_CONTEXT;


//*****************************************************************************
//      HAL Function dispatch
//

typedef enum _HAL_QUERY_INFORMATION_CLASS {
    HalInstalledBusInformation,
    HalProfileSourceInformation,
    HalSystemDockInformation,
    HalPowerInformation,
    HalProcessorSpeedInformation,
    HalCallbackInformation
    // information levels >= 0x8000000 reserved for OEM use
} HAL_QUERY_INFORMATION_CLASS, *PHAL_QUERY_INFORMATION_CLASS;


typedef enum _HAL_SET_INFORMATION_CLASS {
    HalProfileSourceInterval
} HAL_SET_INFORMATION_CLASS, *PHAL_SET_INFORMATION_CLASS;


typedef
NTSTATUS
(*pHalQuerySystemInformation)(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    );

NTSTATUS
HaliQuerySystemInformation(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    );

typedef
NTSTATUS
(*pHalSetSystemInformation)(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    );

NTSTATUS
HaliSetSystemInformation(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    );

typedef
VOID
(FASTCALL *pHalExamineMBR)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG MBRTypeIdentifier,
    OUT PVOID *Buffer
    );

typedef
VOID
(FASTCALL *pHalIoAssignDriveLetters)(
    IN struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
    IN PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    );

typedef
NTSTATUS
(FASTCALL *pHalIoReadPartitionTable)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer
    );

typedef
NTSTATUS
(FASTCALL *pHalIoSetPartitionInformation)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

typedef
NTSTATUS
(FASTCALL *pHalIoWritePartitionTable)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

typedef
NTSTATUS
(*pHalQueryBusSlots)(
    IN INTERFACE_TYPE       BusType,
    IN ULONG                BusNumber,
    IN ULONG                BufferSize,
    OUT PULONG              SlotNumbers,
    OUT PULONG              ReturnedLength
    );

//
// Define control codes of HalSlotControl function
//

#define BCTL_EJECT                                  0x0001
#define BCTL_QUERY_DEVICE_ID                        0x0002
#define BCTL_QUERY_DEVICE_RESOURCES                 0x0003
#define BCTL_QUERY_DEVICE_RESOURCE_REQUIREMENTS     0x0004
#define BCTL_QUERY_EJECT                            0x0005
#define BCTL_SET_LOCK                               0x0006
#define BCTL_SET_POWER                              0x0007
#define BCTL_SET_RESUME                             0x0008
#define BCTL_SET_DEVICE_RESOURCES                   0x0009

//
// Defines for BCTL structures
//

typedef struct {
    ULONG       Handle;
    WCHAR       ID[1];              // Varible length ID string
} BCTL_DEVICE_ID, *PBCTL_DEVICE_ID;

typedef struct {
    ULONG       Handle;
    BOOLEAN     Control;
} BCTL_SET_CONTROL, *PBCTL_SET_CONTROL;

typedef
NTSTATUS
(*pHalSlotControl)(
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN PDEVICE_OBJECT           DeviceObject,
    IN ULONG                    ControlCode,
    IN OUT PVOID                Buffer OPTIONAL,
    IN OUT PULONG               BufferLength OPTIONAL,
    IN PVOID                    Context,
    IN PSLOT_CONTROL_COMPLETION CompletionRoutine
    );


typedef struct {
    ULONG                           Version;
    pHalQuerySystemInformation      HalQuerySystemInformation;
    pHalSetSystemInformation        HalSetSystemInformation;
    pHalQueryBusSlots               HalQueryBusSlots;
    pHalSlotControl                 HalSlotControl;
    pHalExamineMBR                  HalExamineMBR;
    pHalIoAssignDriveLetters        HalIoAssignDriveLetters;
    pHalIoReadPartitionTable        HalIoReadPartitionTable;
    pHalIoSetPartitionInformation   HalIoSetPartitionInformation;
    pHalIoWritePartitionTable       HalIoWritePartitionTable;
} HAL_DISPATCH, *PHAL_DISPATCH;

#if defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

extern  PHAL_DISPATCH   HalDispatchTable;
#define HALDISPATCH     HalDispatchTable

#else

extern  HAL_DISPATCH    HalDispatchTable;
#define HALDISPATCH     (&HalDispatchTable)

#endif

#define HAL_DISPATCH_VERSION        1

#define HalDispatchTableVersion      HALDISPATCH->Version
#define HalQuerySystemInformation    HALDISPATCH->HalQuerySystemInformation
#define HalSetSystemInformation      HALDISPATCH->HalSetSystemInformation
#define HalQueryBusSlots             HALDISPATCH->HalQueryBusSlots
#define HalSlotControl               HALDISPATCH->HalSlotControl
#define HalExamineMBR                HALDISPATCH->HalExamineMBR
#define HalIoAssignDriveLetters      HALDISPATCH->HalIoAssignDriveLetters
#define HalIoReadPartitionTable      HALDISPATCH->HalIoReadPartitionTable
#define HalIoSetPartitionInformation HALDISPATCH->HalIoSetPartitionInformation
#define HalIoWritePartitionTable     HALDISPATCH->HalIoWritePartitionTable


//
// HAL System Information Structures.
//

// for the information class "HalInstalledBusInformation"
typedef struct _HAL_BUS_INFORMATION{
    INTERFACE_TYPE  BusType;
    BUS_DATA_TYPE   ConfigurationType;
    ULONG           BusNumber;
    PDEVICE_OBJECT  DeviceObject;
} HAL_BUS_INFORMATION, *PHAL_BUS_INFORMATION;

typedef struct _HAL_PROFILE_SOURCE_INFORMATION {
    KPROFILE_SOURCE Source;
    BOOLEAN Supported;
    ULONG Interval;
} HAL_PROFILE_SOURCE_INFORMATION, *PHAL_PROFILE_SOURCE_INFORMATION;

typedef struct _HAL_PROFILE_SOURCE_INTERVAL {
    KPROFILE_SOURCE Source;
    ULONG Interval;
} HAL_PROFILE_SOURCE_INTERVAL, *PHAL_PROFILE_SOURCE_INTERVAL;

typedef struct _HAL_SYSTEM_DOCK_INFORMATION {
    SYSTEM_DOCK_STATE DockState;
    ULONG DockIdLength;
    ULONG SerialNumberOffset;
    ULONG SerialNumberLength;
    WCHAR DockId[1];
} HAL_SYSTEM_DOCK_INFORMATION, *PHAL_SYSTEM_DOCK_INFORMATION;

// for the information class "HalPowerInformation"
typedef struct _HAL_POWER_INFORMATION{
    BOOLEAN  SuspendSupported;
    BOOLEAN  ResumeTimerSupportsSuspend;
    BOOLEAN  ResumeTimerSupportsHibernate;
    BOOLEAN  SoftPowerDownSupported;
    BOOLEAN  LidPresent;
    BOOLEAN  TurboSettingSupported;
    BOOLEAN  TurboMode;
} HAL_POWER_INFORMATION, *PHAL_POWER_INFORMATION;

// for the information class "HalProcessorSpeedInformation"
typedef struct _HAL_PROCESSOR_SPEED_INFO{
    ULONG       MaximumProcessorSpeed;
    ULONG       CurrentAvailableSpeed;
    ULONG       ConfiguredSpeedLimit;
    BOOLEAN     PowerLimit;
    BOOLEAN     ThermalLimit;
    BOOLEAN     TurboLimit;
} HAL_PROCESSOR_SPEED_INFORMATION, *PHAL_PROCESSOR_SPEED_INFORMATION;

// for the information class "HalCallbackInformation"
typedef struct _HAL_CALLBACKS{
    PCALLBACK_OBJECT  SetSystemInformation;
    PCALLBACK_OBJECT  BusCheck;
} HAL_CALLBACKS, *PHAL_CALLBACKS;

//
// Determine if there is a complete device failure on an error.
//

NTKERNELAPI
BOOLEAN
FsRtlIsTotalDeviceFailure(
    IN NTSTATUS Status
    );

//
// Object Manager types
//

typedef struct _OBJECT_HANDLE_INFORMATION {
    ULONG HandleAttributes;
    ACCESS_MASK GrantedAccess;
} OBJECT_HANDLE_INFORMATION, *POBJECT_HANDLE_INFORMATION;

NTKERNELAPI                                                     
NTSTATUS                                                        
ObReferenceObjectByHandle(                                      
    IN HANDLE Handle,                                           
    IN ACCESS_MASK DesiredAccess,                               
    IN POBJECT_TYPE ObjectType OPTIONAL,                        
    IN KPROCESSOR_MODE AccessMode,                              
    OUT PVOID *Object,                                          
    OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL   
    );                                                          

#define ObDereferenceObject(a)                  \
        ObfDereferenceObject(a)

NTKERNELAPI
NTSTATUS
ObReferenceObjectByPointer(
    IN PVOID Object,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE ObjectType,
    IN KPROCESSOR_MODE AccessMode
    );

NTKERNELAPI
VOID
FASTCALL
ObfDereferenceObject(
    IN PVOID Object
    );



#ifdef POOL_TAGGING
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,' kdD')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,' kdD')
#endif

extern POBJECT_TYPE *IoFileObjectType;

//
// Define exported ZwXxx routines to device drivers.
//

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PULONG ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    OUT PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );


#endif // _NTDDK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\lib\utilx.cpp ===
//=--------------------------------------------------------------------------=
// utilx.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// various routines et all that aren't in a file for a particular automation
// object, and don't need to be in the generic ole automation code.
//
//
#include <windows.h>
#include <assert.h>
#include "utilx.h"
#include "mq.h"
#include "limits.h"
#include "time.h"


//=--------------------------------------------------------------------------=
// HELPER: GetSafeArrayDataOfVariant
//=--------------------------------------------------------------------------=
// Gets safe array out of variant 
//
// Parameters:
//    pvarSrc   [in]    source variant containing array
//    ppbBuf    [out]   points to array data
//    pcbBuf    [out]   data size
//
// Output:
//
// Notes:
//
HRESULT GetSafeArrayDataOfVariant(
    VARIANT *pvarSrc,
    BYTE **ppbBuf,
    ULONG *pcbBuf)
{
    SAFEARRAY *psa = NULL;
    UINT nDim, i, cbElem, cbBuf;
    long lLBound, lUBound;
    VOID *pvData;
    HRESULT hresult = NOERROR;

    // UNDONE: for now only support arrays
	if (pvarSrc == NULL || !V_ISARRAY(pvarSrc)) {
      return E_INVALIDARG;
    }
    *pcbBuf = cbBuf = 0;
    //
    // array: compute byte count
    //
    psa = V_ISBYREF(pvarSrc) ? 
            *pvarSrc->pparray : 
            pvarSrc->parray;
    if (psa) {
      nDim = SafeArrayGetDim(psa);
      cbElem = SafeArrayGetElemsize(psa);
      for (i = 1; i <= nDim; i++) {
        IfFailRet(SafeArrayGetLBound(psa, i, &lLBound));
        IfFailRet(SafeArrayGetUBound(psa, i, &lUBound));
        cbBuf += (lUBound - lLBound + 1) * cbElem;
      }
      IfFailRet(SafeArrayAccessData(psa, &pvData));
      *ppbBuf = (BYTE *)pvData;
    }
    *pcbBuf = cbBuf;
    if (psa) {
      SafeArrayUnaccessData(psa);
    }
    return hresult;
}


//=--------------------------------------------------------------------------=
// HELPER: GetSafeArrayOfVariant
//=--------------------------------------------------------------------------=
// Gets safe array out of variant and puts in user-supplied
//  byte buffer.
//
// Parameters:
//    pvarSrc   [in]    source variant containing array
//    prgbBuf   [out]   target buffer
//    pcbBuf    [out]   buffer size
//
// Output:
//
// Notes:
//
HRESULT GetSafeArrayOfVariant(
    VARIANT *pvarSrc,
    BYTE **prgbBuf,
    ULONG *pcbBuf)
{
    BYTE *pbBuf = NULL;
    ULONG cbBuf;
    HRESULT hresult = NOERROR;

	assert(*prgbBuf == NULL);

    IfFailRet(GetSafeArrayDataOfVariant(
                pvarSrc,
                &pbBuf,
                &cbBuf));
    if (pbBuf) {
 	  
      //
      // create new buffer and copy data
      //
      IfNullRet(*prgbBuf = new BYTE[cbBuf]);
      memcpy(*prgbBuf, pbBuf, cbBuf);
    }
    *pcbBuf = cbBuf;
    // fall through...

    return hresult;
}


//=--------------------------------------------------------------------------=
// HELPER: PutSafeArrayOfBuffer
//=--------------------------------------------------------------------------=
// Converts byte buffer into safe array.
//
// Parameters:
//    rgbBuf    [in]    byte buffer to convert
//    cbBuf     [in]    buffer size
//    pvarDest  [out]   destination variant to place safe array
//
// Output:
//
// Notes:
//
HRESULT PutSafeArrayOfBuffer(
    BYTE *rgbBuf,
    UINT cbBuf,
    VARIANT FAR* pvarDest)
{
    SAFEARRAY *psa;
    SAFEARRAYBOUND rgsabound[1];
    long rgIndices[1];
    UINT i;
    HRESULT hresult = NOERROR, hresult2 = NOERROR;

    assert(pvarDest);
    VariantClear(pvarDest);

    // create a 1D byte array
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cbBuf;
    IfNullRet(psa = SafeArrayCreate(VT_UI1, 1, rgsabound));

    if (rgbBuf) {
      //
      // now copy array
      //
      for (i = 0; i < cbBuf; i++) {
        rgIndices[0] = i;
        IfFailGo(SafeArrayPutElement(psa, rgIndices, (VOID *)&rgbBuf[i]));
      }
    }

    // set variant to reference safearray of bytes
    V_VT(pvarDest) = VT_ARRAY | VT_UI1;
    pvarDest->parray = psa;
    return hresult;

Error:
    hresult2 = SafeArrayDestroy(psa);
    if (FAILED(hresult2)) {
      return hresult2;
    }
    return hresult;
}


//=--------------------------------------------------------------------------=
// HELPERS: GetFormatNameType, Is{Private, Public, Direct}OfFormatName
//=--------------------------------------------------------------------------=
// Determines kind of queue: direct, private, public
//
//
// Parameters:
//    bstrFormatName  [in]  names queue
//
// Output:
//    QUEUE_FORMAT_TYPE
//
// Notes:
//    Inspects format name string up to first "=" for
//     literal "DIRECT", "PRIVATE", "PUBLIC"
//
//
// Find out the type of a format name (private, public or direct).
//
QUEUE_FORMAT_TYPE
GetFormatNameType(BSTR bstrFormatName)
{
    LPWSTR lpwcsEqualSign;
    DWORD_PTR dwIDLen;

    while (*bstrFormatName != L'\0' && iswspace(*bstrFormatName)) {
      bstrFormatName++;
    }
    if (*bstrFormatName == L'\0') {
      return QUEUE_FORMAT_TYPE_UNKNOWN;
    }
    lpwcsEqualSign = wcschr(bstrFormatName, FORMAT_NAME_EQUAL_SIGN);
    if (!lpwcsEqualSign) {
      return QUEUE_FORMAT_TYPE_UNKNOWN;
    }
    while ((lpwcsEqualSign > bstrFormatName) && iswspace(*(--lpwcsEqualSign)));
    dwIDLen = (lpwcsEqualSign - bstrFormatName) + 1;
    if (dwIDLen == PRIVATE_QUEUE_INDICATOR_LENGTH) {
      if (_wcsnicmp(bstrFormatName, PRIVATE_QUEUE_INDICATOR, dwIDLen) == 0) {
        return QUEUE_FORMAT_TYPE_PRIVATE;
      }
    }

    if (dwIDLen == PUBLIC_QUEUE_INDICATOR_LENGTH) {
      if (_wcsnicmp(bstrFormatName, PUBLIC_QUEUE_INDICATOR, dwIDLen) == 0) {
        return QUEUE_FORMAT_TYPE_PUBLIC;
      }
    }

    if (dwIDLen == DIRECT_QUEUE_INDICATOR_LENGTH) {
      if (_wcsnicmp(bstrFormatName, DIRECT_QUEUE_INDICATOR, dwIDLen) == 0) {
        return QUEUE_FORMAT_TYPE_DIRECT;
      }
    }

    if (dwIDLen == MACHINE_QUEUE_INDICATOR_LENGTH) {
      if (_wcsnicmp(bstrFormatName, MACHINE_QUEUE_INDICATOR, dwIDLen) == 0) {
        return QUEUE_FORMAT_TYPE_MACHINE;
      }
    }

    if (dwIDLen == CONNECTOR_QUEUE_INDICATOR_LENGTH) {
      if (_wcsnicmp(bstrFormatName, CONNECTOR_QUEUE_INDICATOR, dwIDLen) == 0) {
        return QUEUE_FORMAT_TYPE_CONNECTOR;
      }
    }
    return QUEUE_FORMAT_TYPE_UNKNOWN;
}

BOOL IsPrivateQueueOfFormatName(BSTR bstrFormatName)
{
    return GetFormatNameType(bstrFormatName) == QUEUE_FORMAT_TYPE_PRIVATE;
}

BOOL IsPublicQueueOfFormatName(BSTR bstrFormatName)
{
    return GetFormatNameType(bstrFormatName) == QUEUE_FORMAT_TYPE_PUBLIC;
}

BOOL IsDirectQueueOfFormatName(BSTR bstrFormatName)
{
    return GetFormatNameType(bstrFormatName) == QUEUE_FORMAT_TYPE_DIRECT;
}


//=--------------------------------------------------------------------------=
// SystemTimeOfTime
//=--------------------------------------------------------------------------=
// Converts time into systemtime
//
//
// Parameters:
//    iTime       [in] time
//
// Output:
//    [out] SYSTEMTIME
//
// Notes:
//    Various weird conversions: off-by-one months, 1900 blues.
//
BOOL SystemTimeOfTime(time_t iTime, SYSTEMTIME *psystime)
{
    tm *ptmTime; 

    ptmTime = localtime(&iTime);
    if (ptmTime == NULL) {
      // 
      // can't convert time
      //
      return FALSE;
    }
    psystime->wYear = (WORD)(ptmTime->tm_year + 1900);
    psystime->wMonth = (WORD)(ptmTime->tm_mon + 1);
    psystime->wDayOfWeek = (WORD)ptmTime->tm_wday;
    psystime->wDay = (WORD)ptmTime->tm_mday;
    psystime->wHour = (WORD)ptmTime->tm_hour;
    psystime->wMinute = (WORD)ptmTime->tm_min;
    psystime->wSecond = (WORD)ptmTime->tm_sec;
    psystime->wMilliseconds = 0;
    return TRUE;
}


//=--------------------------------------------------------------------------=
// TimeOfSystemTime
//=--------------------------------------------------------------------------=
// Converts systemtime into time
//
//
// Parameters:
//    [in] SYSTEMTIME
//
// Output:
//    piTime       [out] time
//
// Notes:
//    Various weird conversions: off-by-one months, 1900 blues.
//
BOOL TimeOfSystemTime(SYSTEMTIME *psystime, time_t *piTime)
{
    tm tmTime;

    tmTime.tm_year = psystime->wYear - 1900;
    tmTime.tm_mon = psystime->wMonth - 1;
    tmTime.tm_wday = psystime->wDayOfWeek;
    tmTime.tm_mday = psystime->wDay;
    tmTime.tm_hour = psystime->wHour; 
    tmTime.tm_min = psystime->wMinute;
    tmTime.tm_sec = psystime->wSecond; 

    //
    // set daylight savings time flag from localtime() #3325 RaananH
    //
    time_t tTmp = time(NULL);
    struct tm * ptmTmp = localtime(&tTmp);
    if (ptmTmp)
    {
        tmTime.tm_isdst = ptmTmp->tm_isdst;
    }
    else
    {
        tmTime.tm_isdst = -1;
    }

    *piTime = mktime(&tmTime);
    return (*piTime != -1); //#3325
}


//=--------------------------------------------------------------------------=
// TimeToVariantTime(time_t iTime, pvtime)
//  Converts time_t to Variant time
//
// Parameters:
//    iTime       [in] time
//    pvtime      [out] 
//
// Output:
//    TRUE if successful else FALSE.
//
// Notes:
//
BOOL TimeToVariantTime(time_t iTime, double *pvtime)
{
    SYSTEMTIME systemtime;

    if (SystemTimeOfTime(iTime, &systemtime)) {
      return SystemTimeToVariantTime(&systemtime, pvtime);
    }
    return FALSE;
}


//=--------------------------------------------------------------------------=
// VariantTimeToTime
//  Converts Variant time to time_t
//
// Parameters:
//    pvarTime   [in]  Variant datetime
//    piTime     [out] time_t
//
// Output:
//    TRUE if successful else FALSE.
//
// Notes:
//
BOOL VariantTimeToTime(VARIANT *pvarTime, time_t *piTime)
{
    // WORD wFatDate, wFatTime;
    SYSTEMTIME systemtime;
    double vtime;

    vtime = GetDateVal(pvarTime);
    if (vtime == 0) {
      return FALSE;
    }
    if (VariantTimeToSystemTime(vtime, &systemtime)) {
      return TimeOfSystemTime(&systemtime, piTime);
    }
    return FALSE;
}


//=--------------------------------------------------------------------------=
// GetVariantTimeOfTime
//=--------------------------------------------------------------------------=
// Converts time to variant time
//
// Parameters:
//    iTime      [in]  time to convert to variant
//    pvarTime - [out] variant time
//
// Output:
//
// Notes:
//
HRESULT GetVariantTimeOfTime(time_t iTime, VARIANT FAR* pvarTime)
{
    double vtime;
    VariantInit(pvarTime);
    if (TimeToVariantTime(iTime, &vtime)) {
      V_VT(pvarTime) = VT_DATE;
      V_DATE(pvarTime) = vtime;
    }
    else {
      V_VT(pvarTime) = VT_ERROR;
      V_ERROR(pvarTime) = 13; // UNDONE: VB type mismatch
    }
    return NOERROR;
}


// helper: gets default property of VARIANT
//  pvar        [in]
//  pvarDefault [out]
//
HRESULT GetDefaultPropertyOfVariant(
    VARIANT *pvar, 
    VARIANT *pvarDefault)
{
    IDispatch *pdisp;
    LCID lcid = LOCALE_USER_DEFAULT;
    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0}; 
    HRESULT hresult;

    pdisp = GetPdisp(pvar);
    if (pdisp) {
      hresult = pdisp->Invoke(DISPID_VALUE,
                              IID_NULL,
			      lcid,
			      DISPATCH_PROPERTYGET,
			      &dispparamsNoArgs,
			      pvarDefault,
			      NULL, // pexcepinfo,
			      NULL  // puArgErr
                              );
      return hresult;
    }
    else {
      return E_INVALIDARG;
    }
}


// helper: gets newenum from object
//  pdisp        [in]
//  ppenum       [out]
//
HRESULT GetNewEnumOfObject(
    IDispatch *pdisp, 
    IEnumVARIANT **ppenum)
{
    LCID lcid = LOCALE_USER_DEFAULT;
    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0}; 
    VARIANT varNewEnum;
    IDispatch *pdispNewEnum = NULL;
    HRESULT hresult = NOERROR;

    VariantInit(&varNewEnum);
    assert(pdisp);
    IfFailRet(pdisp->Invoke(DISPID_NEWENUM,
                            IID_NULL,
			    lcid,
			    DISPATCH_PROPERTYGET,
			    &dispparamsNoArgs,
			    &varNewEnum,
			    NULL, // pexcepinfo,
			    NULL  // puArgErr
                            ));
    IfFailRet(VariantChangeType(
                &varNewEnum, 
                &varNewEnum, 
                0, 
                VT_DISPATCH));
    //
    // cast to IEnumVariant
    //
    pdispNewEnum = V_DISPATCH(&varNewEnum);
    IfFailRet(pdispNewEnum->QueryInterface(
                              IID_IEnumVARIANT, 
                              (LPVOID *)ppenum));
    return hresult;
}


// helper: gets a VARIANT VT_<number> or VT_<number> | VT_BYREF
// returns -1 if invalid
//
UINT GetNumber(VARIANT *pvar, UINT uiDefault)
{
    VARIANT varDest;
    HRESULT hresult;

    // attempt to convert to an I4
    VariantInit(&varDest);
    hresult = VariantChangeType(&varDest, pvar, 0, VT_I4);
    return (UINT)(SUCCEEDED(hresult) ? varDest.lVal : uiDefault);
}


// helper: gets a VARIANT VT_BOOL or VT_BOOL | VT_BYREF
// returns FALSE if invalid
//
BOOL GetBool(VARIANT *pvar)
{
    switch (pvar->vt) {
    case (VT_BOOL | VT_BYREF):
      return (BOOL)*pvar->pboolVal;
    case VT_BOOL:
      return (BOOL)pvar->boolVal;
    default:
      return FALSE;
    }
}


// helper: gets a VARIANT VT_BSTR or VT_BSTR | VT_BYREF
// returns NULL if invalid
//
BSTR GetBstr(VARIANT *pvar)
{
    BSTR bstr;
    HRESULT hresult;

    hresult = GetTrueBstr(pvar, &bstr);
    return FAILED(hresult) ? NULL : bstr;
}


// helper: gets a VARIANT VT_BSTR or VT_BSTR | VT_BYREF
// returns error if invalid
//
HRESULT GetTrueBstr(VARIANT *pvar, BSTR *pbstr)
{
    VARIANT varDefault;
    HRESULT hresult = NOERROR;
	if (pvar == NULL) {
      return E_INVALIDARG;
    }

    switch (pvar->vt) {
    case (VT_BSTR | VT_BYREF):
      *pbstr = *pvar->pbstrVal;
      break;
    case VT_BSTR:
      *pbstr = pvar->bstrVal;
      break;
    default:
      // see if it has a default string property
      VariantInit(&varDefault);
      hresult = GetDefaultPropertyOfVariant(pvar, &varDefault);
      if (SUCCEEDED(hresult)) {
        return GetTrueBstr(&varDefault, pbstr);
      }
      break;
    }
    return hresult;
}


// helper: gets a VARIANT VT_UNKNOWN or VT_UNKNOWN | VT_BYREF
// returns NULL if invalid
//
IUnknown *GetPunk(VARIANT *pvar)
{
    if (pvar) {
      if (pvar->vt == (VT_UNKNOWN | VT_BYREF)) {
        return *pvar->ppunkVal;
      }
      else if (pvar->vt == VT_UNKNOWN) {
        return pvar->punkVal;
      }
    }
    return NULL;
}


// helper: gets a VARIANT VT_DISPATCH or VT_DISPATCH | VT_BYREF
// returns NULL if invalid
//
IDispatch *GetPdisp(VARIANT *pvar)
{
    if (pvar) {
      if (pvar->vt == (VT_DISPATCH | VT_BYREF)) {
        return *pvar->ppdispVal;
      }
      else if (pvar->vt == VT_DISPATCH) {
        return pvar->pdispVal;
      }
    }
    return NULL;
}


// helper: gets a VARIANT VT_DATE or VT_DATE | VT_BYREF
// returns 0 if invalid
//
double GetDateVal(VARIANT *pvar)
{
    if (pvar) {
      if (pvar->vt == (VT_DATE | VT_BYREF)) {
        return *V_DATEREF(pvar);
      }
      else if (pvar->vt == VT_DATE) {
        return V_DATE(pvar);
      }
    }
    return 0;
}


#define MAXMSGBYTELEN 2048
/*=======================================================
GetMessageOfId
  dwMsgId         [in]
  szDllFile       [in]
  fUseDefaultLcid [in]
  pbstrMessage    [out]

  Returns callee-allocated buffer containing message.
  Caller must release.

 ========================================================*/
BOOL GetMessageOfId(
    DWORD dwMsgId, 
    LPSTR szDllFile, 
    BOOL fUseDefaultLcid,
    BSTR *pbstrMessage)
{
    DWORD cbMsg;
    HINSTANCE hInst = 0;
    WCHAR wszTmp[MAXMSGBYTELEN/2];   // unicode chars
    LPSTR szBuf;
    DWORD dwFlags = FORMAT_MESSAGE_MAX_WIDTH_MASK;
    
    szBuf = new CHAR[sizeof(wszTmp)];
    if (szBuf == NULL) {
      return FALSE;
    }

    *pbstrMessage = NULL;
    if (0 == szDllFile)
    {
      dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
      hInst = LoadLibraryA(szDllFile);
      if (hInst == 0) {
		delete [] szBuf;
        return FALSE;
      }
      dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    if (fUseDefaultLcid) {
      cbMsg = FormatMessageA(dwFlags,
                             hInst,
                             dwMsgId,
                             0,
                             szBuf,
                             MAXMSGBYTELEN,
                             NULL);
	  IfNullGo(cbMsg);
    }
    else {
      cbMsg = LoadStringA(hInst, dwMsgId, szBuf, MAXMSGBYTELEN); 
	  IfNullGo(cbMsg);
    }
    	
    UINT cchMsg =  MultiByteToWideChar(CP_ACP, 0, szBuf, -1, wszTmp, sizeof(wszTmp)/sizeof(WCHAR));
    if (cchMsg == 0) {
		DWORD dwErr;
		dwErr = GetLastError();
      	assert(dwErr == 0);
		goto Error;
    }
    *pbstrMessage = SysAllocString(wszTmp);

Error:
    if (hInst)
    {
      FreeLibrary(hInst);
    }
    delete [] szBuf;
    
	return (cbMsg != 0 && *pbstrMessage != NULL);

}


/*=======================================================
GetMessageOfError

  Translate an MQError to a string
  hardwired to loaded error messages from mqutil.dll
  Returns callee-allocated buffer containing message.
  Caller must release.

 ========================================================*/
BOOL GetMessageOfError(DWORD dwMsgId, BSTR *pbstrMessage)
{
    LPSTR szDllFile;
    DWORD dwErrorCode = dwMsgId;

    switch (HRESULT_FACILITY(dwMsgId))
    {
        case FACILITY_MSMQ:
            szDllFile = "MQUTIL.DLL";
            break;

        case FACILITY_NULL:
        case FACILITY_WIN32:
            szDllFile = 0;
            break;

        case FACILITY_ITF:
            szDllFile = 0;
            break;


        default:
            szDllFile = "ACTIVEDS.DLL";
            break;
    }

    return GetMessageOfId(dwErrorCode, 
                          szDllFile, 
                          TRUE, /* fUseDefaultLcid */
                          pbstrMessage);
}


//=--------------------------------------------------------------------------=
// CreateError
//=--------------------------------------------------------------------------=
// fills in the rich error info object so that both our vtable bound interfaces
// and calls through ITypeInfo::Invoke get the right error informaiton.
//
// Parameters:
//    hrExcep          - [in] the SCODE that should be associated with this err
//    pguid            - [in] the interface id of the offending object:
//                              can be NULL.
//    szName           - [in] the name of the offending object:
//                              can be NULL.
//
// Output:
//    HRESULT          - the HRESULT that was passed in.
//
// Notes:
//
HRESULT CreateError(
    HRESULT hrExcep,
    GUID *pguid,
    LPSTR szName)
{
    ICreateErrorInfo *pCreateErrorInfo;
    IErrorInfo *pErrorInfo;
    BSTR bstrMessage = NULL;
    WCHAR wszTmp[256];
    HRESULT hresult = NOERROR;
    
    // first get the createerrorinfo object.
    //
    hresult = CreateErrorInfo(&pCreateErrorInfo);
    if (FAILED(hresult)) return hrExcep;

    // set up some default information on it.
    //
    if (pguid) {
      pCreateErrorInfo->SetGUID(*pguid);
    }
    // pCreateErrorInfo->SetHelpFile(wszHelpFile);
    // pCreateErrorInfo->SetHelpContext(dwHelpContextID);

    // load in the actual error string value.  max of 256.
    if (!GetMessageOfError(hrExcep, &bstrMessage)) {
      return hrExcep;
    }
    pCreateErrorInfo->SetDescription(bstrMessage);

    if (szName) {
      // load in the source
      MultiByteToWideChar(CP_ACP, 0, szName, -1, wszTmp, 256);
      pCreateErrorInfo->SetSource(wszTmp);
    }

    // now set the Error info up with the system
    //
    IfFailGo(pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void **)&pErrorInfo));
    SetErrorInfo(0, pErrorInfo);
    pErrorInfo->Release();

Error:
    pCreateErrorInfo->Release();
    SysFreeString(bstrMessage);
    return hrExcep;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\app.cpp ===
//=--------------------------------------------------------------------------=
// app.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQApplication object
//
//
#include "stdafx.h"
#include "dispids.h"
#include "oautil.h"
#include "app.h"
#include <mqmacro.h>


const MsmqObjType x_ObjectType = eMSMQApplication;

// debug...
#include "debug.h"
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
extern VOID RemBstrNode(void *pv);
#endif // _DEBUG



//=-------------------------------------------------------------------------=
// CMSMQApplication::MachineIdOfMachineName
//=-------------------------------------------------------------------------=
//  Maps machine name to its guid via DS.
//
// Parameters:
//    bstrMachineName  [in] 
//    pbstrGuid        [out]  callee allocated/caller freed
//	
HRESULT CMSMQApplication::MachineIdOfMachineName(
    BSTR bstrMachineName, 
    BSTR FAR* pbstrGuid
    )
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    MQQMPROPS qmprops;
    DWORD cProp;
    HRESULT hresult = NOERROR;



    qmprops.aPropID = NULL;
    qmprops.aPropVar = NULL;
    qmprops.aStatus = NULL;

    cProp = 1;
    IfNullFail(qmprops.aPropID = new QUEUEPROPID[cProp]);
    IfNullFail(qmprops.aStatus = new HRESULT[cProp]);
    IfNullFail(qmprops.aPropVar = new MQPROPVARIANT[cProp]);
    qmprops.cProp = cProp;
    //
    //  if machine name is NULL, the calls refers to the
    //  local machine
    //
    qmprops.aPropID[0] = PROPID_QM_MACHINE_ID;
    qmprops.aPropVar[0].vt = VT_NULL;
    IfFailGo(MQGetMachineProperties(
               bstrMachineName,
               NULL,
               &qmprops));
    IfFailGoTo(GetBstrFromGuidWithoutBraces(qmprops.aPropVar[0].puuid, pbstrGuid), Error2);
#ifdef _DEBUG
      RemBstrNode(*pbstrGuid);
#endif // _DEBUG
    //
    // fall through...
    //
Error2:
    MQFreeMemory(qmprops.aPropVar[0].puuid);
    //
    // fall through...
    //
Error:
    delete [] qmprops.aPropID;
    delete [] qmprops.aPropVar;
    delete [] qmprops.aStatus;
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// GetOptionalExternalCertificate
//=--------------------------------------------------------------------------=
// get the optional external certificate in the form of a BLOB
//
// pvarExternalCertificate - [in]  external certificate, can be NULL
// prgbCertBuffer          - [out] blob for certificate (allocated here)
// pcbCertBuffer           - [out] size of blob
//
// *prgbCertBuffer is set to NULL if the optional certificate was not specified
// caller needs to delete [] *prgbCertBuffer when done
// 
static HRESULT GetOptionalExternalCertificate(
    VARIANT * pvarExternalCertificate,
    BYTE ** prgbCertBuffer,
    DWORD * pcbCertBuffer)
{
    //
    // set return certificate as empty
    //
    *prgbCertBuffer = NULL;
    *pcbCertBuffer = 0;

    //
    // check if a variant was supplied for external certificates
    //
    BOOL fHasCertificates = FALSE;
    if (pvarExternalCertificate) {
      //
      // check that it is not missing
      //
      if (V_VT(pvarExternalCertificate) != VT_ERROR) {
        fHasCertificates = TRUE;
      }
    }

    //
    // if a variant was not supplied, return (with the empty certificates)
    //
    if (!fHasCertificates) {
      return NOERROR;
    }

    //
    // variant should be a byte array (VT_ARRAY|VT_UI1) or VT_BYREF to it
    //
    if ((pvarExternalCertificate->vt != (VT_ARRAY|VT_UI1)) &&
        (pvarExternalCertificate->vt != (VT_BYREF|VT_ARRAY|VT_UI1))) {
      return E_INVALIDARG;
    }

    //
    // translate the byte array to a blob
    //
    return GetSafeArrayOfVariant(pvarExternalCertificate, prgbCertBuffer, pcbCertBuffer);
}


//=-------------------------------------------------------------------------=
// CMSMQApplication::RegisterCertificate
//=-------------------------------------------------------------------------=
//  Register certificates for MSMQ
//
// Parameters:
//    pvarFlags               [in, optional] - flags, values from MQCERT_REGISTER enum
//    pvarExternalCertificate [in, optional] - external certificate
//	
HRESULT CMSMQApplication::RegisterCertificate(
    VARIANT * pvarFlags,
    VARIANT * pvarExternalCertificate
    )
{
    if(m_Machine != NULL)
    {
        return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
    }
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    HRESULT hresult;
    //
    // get external certificate blob from variant
    // blob is set to NULL if variant was not supplied, or external certificate was not specified
    //
    BYTE * rgbCertBuffer = NULL;
    DWORD cbCertBuffer = 0;
    IfFailGo(GetOptionalExternalCertificate(pvarExternalCertificate,
                                            &rgbCertBuffer,
                                            &cbCertBuffer));
    //
    // get register flags from variant, default value is MQCERT_REGISTER_ALWAYS
    //
    DWORD dwFlags;
    dwFlags = GetNumber(pvarFlags, MQCERT_REGISTER_ALWAYS);
    //
    // call MQRegisterCertificate with the blob (NULL means register internal certificate)
    //
    IfFailGo(MQRegisterCertificate(dwFlags, rgbCertBuffer, cbCertBuffer));
    //
    // fall through...
    //
Error:
    delete [] rgbCertBuffer;
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQApplication::~CMSMQApplication
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//
CMSMQApplication::~CMSMQApplication ()
{
    // TODO: clean up anything here.
}


//=--------------------------------------------------------------------------=
// CMSMQApplication::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQApplication::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQApplication3,
		&IID_IMSMQApplication2,
		&IID_IMSMQApplication,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//=--------------------------------------------------------------------------=
// HELPER - GetGuidFromBstrWithoutBraces
//=--------------------------------------------------------------------------=
//
// Parameters:
//    bstrGuid [in]  guid bstr
//    pguid    [out] guid pointer
//
// Output:
//    HRESULT
//
// Notes:
//    Returns a guid from a guid string without the curly braces
//
HRESULT GetGuidFromBstrWithoutBraces(BSTR bstrGuid, GUID * pguid)
{   
   //
   // compose a bstr with braces
   //
   WCHAR awcName[LENSTRCLSID + 1];
   awcName[0] = L'{';
   ULONG idxEndName;
   if (bstrGuid != NULL) {
     wcsncpy(awcName+1, bstrGuid, LENSTRCLSID - 2);
     idxEndName = LENSTRCLSID - 1;
   }
   else { // NULL bstr
     idxEndName = 1;
   }
   awcName[idxEndName] = L'}';
   awcName[idxEndName+1] = L'\0';
   //
   // get guid from bstr
   //
   HRESULT hresult = CLSIDFromString(awcName, pguid);
   if (FAILED(hresult)) {
     // 1194: map OLE error to Falcon
     hresult = MQ_ERROR_ILLEGAL_PROPERTY_VALUE;
   }	
   return hresult;
}


//
// new MSMQ 2.0 props should be last. keep enum and propid array in the same order.
//
static const enum {
  e_NAMEOFID_PATHNAME,
  e_NAMEOFID_PATHNAME_DNS,
  e_COUNT_NAMEOFID_PROPS
};
static const QUEUEPROPID x_rgpropidNameOfId[e_COUNT_NAMEOFID_PROPS] = {
  PROPID_QM_PATHNAME,
  PROPID_QM_PATHNAME_DNS
};
//
// number of MSMQ2.0 properties
//
static const ULONG x_cpropsNameOfIdMSMQ2 = 1; // PROPID_QM_PATHNAME_DNS

//=-------------------------------------------------------------------------=
// CMSMQApplication::MachineNameOfMachineId
//=-------------------------------------------------------------------------=
//  Maps machine guid to its name via DS.
//
// Parameters:
//    bstrGuid         [in]  machine guid string
//    pbstrMachineName [out] machine name. callee allocated/caller freed
//	
// Notes:
//    Returns PROPID_QM_PATHNAME_DNS if possible, otherwise returns PROPID_QM_PATHNAME
//
HRESULT CMSMQApplication::MachineNameOfMachineId(
    BSTR bstrGuid, 
    BSTR FAR* pbstrMachineName
    )
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    MQQMPROPS qmprops;
    HRESULT hresult = NOERROR;
    HRESULT       aStatus [e_COUNT_NAMEOFID_PROPS];
    MQPROPVARIANT aPropVar[e_COUNT_NAMEOFID_PROPS];

    qmprops.aPropID  = const_cast<QUEUEPROPID *>(x_rgpropidNameOfId);
    qmprops.aStatus  = aStatus;
    for (ULONG ulTmp = 0; ulTmp < e_COUNT_NAMEOFID_PROPS; ulTmp++) {
      aPropVar[ulTmp].vt = VT_NULL;
    }
    qmprops.aPropVar = aPropVar;
    qmprops.cProp = e_COUNT_NAMEOFID_PROPS;
    //
    // extract guid from guid string.
    // accept guid string with or without surrounding curly braces.
    // msg.SourceMachineGuid is w/o curly braces, also the output of MachineIdOfMachineName,
    // but regular OLE representation of guid is with braces.
    //
    GUID * pguidToUse;
    GUID guid;
    if (bstrGuid != NULL) {
      if (bstrGuid[0] == L'{') {
        //
        // guid has surrounding braces
        //
        IfFailGo(GetGuidFromBstr(bstrGuid, &guid));
      }
      else {
        //
        // guid doesn't have surrounding braces
        //
        IfFailGo(GetGuidFromBstrWithoutBraces(bstrGuid, &guid));
      }
      //
      // in both cases use the guid that was extracted
      //
      pguidToUse = &guid;
    }
    else {
      //
      //  guid bstr is NULL. use a NULL guid ptr to refer to the local machine
      //
      pguidToUse = NULL;
    }
    //
    // get queue properties by guid
    //
    hresult = MQGetMachineProperties(NULL, pguidToUse, &qmprops);
    //
    // if we fail, it might be that we are talking to MSMQ 1.0 DS server that doesn't understand
    // the new MSMQ 2.0 props such as PROPID_QM_PATHNAME_DNS.
    // Currently a generic error (MQ_ERROR) is returned in this case, however we can't rely on
    // this generic error to retry the operation since it might change in a future service pack
    // to something more specific. On the other side there are errors that when we get them we
    // know there is no point to retry the operation, like no ds, no security,
    // so we do not retry the operation in these cases. RaananH
    //
    if (FAILED(hresult)) {
      if ((hresult != MQ_ERROR_NO_DS) &&
          (hresult != MQ_ERROR_ACCESS_DENIED) &&
          (hresult != MQ_ERROR_MACHINE_NOT_FOUND)) {
        //
        // we retry the call with only MSMQ 1.0 props (and mark the pathname dns as empty)
        //
        qmprops.aPropVar[e_NAMEOFID_PATHNAME_DNS].vt = VT_EMPTY;
        qmprops.cProp = e_COUNT_NAMEOFID_PROPS - x_cpropsNameOfIdMSMQ2;
        IfFailGo(MQGetMachineProperties(NULL, pguidToUse, &qmprops));
      }
      else {
        //
        // first MQGetMachineProperties returned a real error, return the error
        //
        IfFailGo(hresult);
      }
    }
    //
    // if pathname dns is filled use it, otherwise use pathname
    //
    LPWSTR pwszMachineName;
    pwszMachineName = NULL;
    if (qmprops.aPropVar[e_NAMEOFID_PATHNAME_DNS].vt == VT_LPWSTR) {
      pwszMachineName = qmprops.aPropVar[e_NAMEOFID_PATHNAME_DNS].pwszVal;
    }
    else if (qmprops.aPropVar[e_NAMEOFID_PATHNAME].vt == VT_LPWSTR) {
      pwszMachineName = qmprops.aPropVar[e_NAMEOFID_PATHNAME].pwszVal;
    }
    else {
      //
      // both are not filled. should never happen.
      //
      ASSERTMSG(0, "neither pathname_dns nor pathname are filled");
      IfFailGo(MQ_ERROR);
    }
    //
    // create bstr of machine name and return it
    //
    ASSERTMSG(pwszMachineName != NULL, "pwszMachineName is NULL");
    *pbstrMachineName = SysAllocString(pwszMachineName);
    if (*pbstrMachineName == NULL) {
      IfFailGoTo(E_OUTOFMEMORY, Error2);
    }
#ifdef _DEBUG
      RemBstrNode(*pbstrMachineName);
#endif // _DEBUG
    //
    // fall through...
    //
Error2:
    //
    // free MSMQ returned props
    //
    if (qmprops.aPropVar[e_NAMEOFID_PATHNAME_DNS].vt == VT_LPWSTR) {
      MQFreeMemory(qmprops.aPropVar[e_NAMEOFID_PATHNAME_DNS].pwszVal);
    }
    if (qmprops.aPropVar[e_NAMEOFID_PATHNAME].vt == VT_LPWSTR) {
      MQFreeMemory(qmprops.aPropVar[e_NAMEOFID_PATHNAME].pwszVal);
    }
    //
    // fall through...
    //
Error:
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// HELPER: GetSinglePrivateComputerProp
//=-------------------------------------------------------------------------=
//  gets a single private computer prop
//
// Parameters:
//    propidIn  - [in] propid to get
//    ppropvar  - [in] ptr to propvar in which to put the result
//	
inline static HRESULT GetSinglePrivateComputerProp(PROPID propidIn, PROPVARIANT * ppropvar, LPCWSTR Machine)
{
    //
    // prepare private props
    //
    MQPRIVATEPROPS sPrivateProps;
    PROPID propid = propidIn;
    sPrivateProps.aPropID = &propid;
    ppropvar->vt = VT_NULL;
    sPrivateProps.aPropVar = ppropvar;
    HRESULT hrStatus; 
    sPrivateProps.aStatus = &hrStatus;
    sPrivateProps.cProp = 1;
    //
    // get private props
    //
    HRESULT hresult = MQGetPrivateComputerInformation(Machine, &sPrivateProps);
    return hresult;
}


//=-------------------------------------------------------------------------=
// CMSMQApplication::GetMSMQVersion
//=-------------------------------------------------------------------------=
//  gets version of local MSMQ if not cached yet
//
HRESULT CMSMQApplication::GetMSMQVersion()
{
	HRESULT hresult = NOERROR;

	//
	// Critical section is Redundant here. There is no need to serialize 
	// calls to GetSinglePrivateComputerProp(), and assignment to 
	// m_uMSMQVersion.dwVersion is atomic
	//

    MQPROPVARIANT propvar;
    IfFailGo(GetSinglePrivateComputerProp(PROPID_PC_VERSION, &propvar, m_Machine));
    //
    // cache value
    //
    ASSERTMSG(propvar.vt == VT_UI4, "bad MSMQ version");
    ASSERTMSG(propvar.ulVal != 0, "MSMQ version is 0");
    m_uMSMQVersion.dwVersion = propvar.ulVal;


	//
    // fall through...
    //
Error:
    return hresult;
}


//=-------------------------------------------------------------------------=
// CMSMQApplication::get_MSMQVersionMajor
//=-------------------------------------------------------------------------=
//  gets major version of local MSMQ
//
// Parameters:
//    psMSMQVersionMajor [out] major version of local MSMQ
//	
HRESULT CMSMQApplication::get_MSMQVersionMajor(short *psMSMQVersionMajor)
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    HRESULT hresult = NOERROR;
    unsigned short usTmp;
    //
    // get MSMQ Version if not cached already
    //
    IfFailGo(GetMSMQVersion());
    //
    // return value
    //
    usTmp = m_uMSMQVersion.bMajor;
    *psMSMQVersionMajor = usTmp;
    //
    // fall through...
    //
Error:
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQApplication::get_MSMQVersionMinor
//=-------------------------------------------------------------------------=
//  gets minor version of local MSMQ
//
// Parameters:
//    psMSMQVersionMinor [out] minor version of local MSMQ
//	
HRESULT CMSMQApplication::get_MSMQVersionMinor(short *psMSMQVersionMinor)
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    HRESULT hresult = NOERROR;
    unsigned short usTmp;
    //
    // get MSMQ Version if not cached already
    //
    IfFailGo(GetMSMQVersion());
    //
    // return value
    //
    usTmp = m_uMSMQVersion.bMinor;
    *psMSMQVersionMinor = usTmp;
    //
    // fall through...
    //
Error:
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQApplication::get_MSMQVersionBuild
//=-------------------------------------------------------------------------=
//  gets build version of local MSMQ
//
// Parameters:
//    psMSMQVersionBuild [out] build version of local MSMQ
//	
HRESULT CMSMQApplication::get_MSMQVersionBuild(short *psMSMQVersionBuild)
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    HRESULT hresult = NOERROR;
    unsigned short usTmp;
    //
    // get MSMQ Version if not cached already
    //
    IfFailGo(GetMSMQVersion());
    //
    // return value
    //
    usTmp = m_uMSMQVersion.wBuild;
    *psMSMQVersionBuild = usTmp;
    //
    // fall through...
    //
Error:
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQApplication::get_IsDsEnabled
//=-------------------------------------------------------------------------=
//  sets a flag to true if the local MSMQ is in DS mode, or false if it is in
//  DS-less mode.
//
// Parameters:
//    pfIsDsEnabled [out] whether LOCAL MSMQ is in DS mode
//	
HRESULT CMSMQApplication::get_IsDsEnabled(VARIANT_BOOL *pfIsDsEnabled)
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    HRESULT hresult = NOERROR;
    //
    // get local ds mode
    // BUGBUG we can cache IsDsEnabled if it cannot be changed while an MSMQ app is running.
    // we would then need to guard the chached data with a critical section
    //
    MQPROPVARIANT propvar;
    IfFailGo(GetSinglePrivateComputerProp(PROPID_PC_DS_ENABLED, &propvar, m_Machine));
    //
    // return value (real automation boolean)
    //
    ASSERTMSG(propvar.vt == VT_BOOL, "bad DS enabled flag");
    *pfIsDsEnabled = CONVERT_BOOL_TO_VARIANT_BOOL(propvar.boolVal);
    //
    // fall through...
    //
Error:
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQApplication::get_Properties
//=-------------------------------------------------------------------------=
// Gets object's properties collection
//
// Parameters:
//    ppcolProperties - [out] object's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQApplication::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}

//
// Local admin api
//
HRESULT CMSMQApplication::OapMgmtGetInfo(MGMTPROPID PropId, MQPROPVARIANT& PropVar)const
{
    PropVar.vt = VT_NULL;
    MQMGMTPROPS MgmtProps;

    MgmtProps.cProp = 1;
    MgmtProps.aPropID = &PropId;
    MgmtProps.aPropVar = &PropVar;
    MgmtProps.aStatus = NULL;
    
    return MQMgmtGetInfo(
				m_Machine,
				MO_MACHINE_TOKEN,
				&MgmtProps
				);
}


HRESULT CMSMQApplication::get_BytesInAllQueues(VARIANT* pvBytesInQueues)
{
	MQPROPVARIANT PropVar;
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_MSMQ_BYTES_IN_ALL_QUEUES, PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }

	pvBytesInQueues->vt = VT_I8;
    pvBytesInQueues->llVal = (PropVar.hVal).QuadPart;
 
    return MQ_OK;
}


HRESULT CMSMQApplication::get_ActiveQueues(VARIANT* pvActiveQueues) 
{
    MQPROPVARIANT PropVar;
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_MSMQ_ACTIVEQUEUES, PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }

    ASSERTMSG(PropVar.vt == (VT_VECTOR | VT_LPWSTR), "vt must be VT_VECTOR|VT_LPWSTR");

    hr = VariantStringArrayToBstringSafeArray(PropVar, pvActiveQueues);
    OapArrayFreeMemory(PropVar.calpwstr);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }

    return MQ_OK;
}


HRESULT CMSMQApplication::get_PrivateQueues(VARIANT* pvPrivateQueues) 
{
    MQPROPVARIANT PropVar;
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_MSMQ_PRIVATEQ, PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }

    ASSERTMSG(PropVar.vt == (VT_VECTOR | VT_LPWSTR), "vt must be VT_VECTOR|VT_LPWSTR");

    hr = VariantStringArrayToBstringSafeArray(PropVar, pvPrivateQueues);
    OapArrayFreeMemory(PropVar.calpwstr);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }

    return MQ_OK;
}


HRESULT CMSMQApplication::get_DirectoryServiceServer(BSTR* pbstrDirectoryServiceServer) 
{
    MQPROPVARIANT PropVar;
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_MSMQ_DSSERVER, PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }

    if(PropVar.vt == VT_NULL)
    {
        *pbstrDirectoryServiceServer = NULL;
        return MQ_OK;  
    }

    ASSERTMSG(PropVar.vt == (VT_LPWSTR), "vt must be VT_LPWSTR");
    
    *pbstrDirectoryServiceServer = SysAllocString(PropVar.pwszVal);
    if(*pbstrDirectoryServiceServer == NULL)
    {
        MQFreeMemory(PropVar.pwszVal);
        return CreateErrorHelper(E_OUTOFMEMORY, x_ObjectType);
    }
    
    MQFreeMemory(PropVar.pwszVal);
    return MQ_OK;
}


HRESULT CMSMQApplication::get_IsConnected(VARIANT_BOOL* pfIsConnected) 
{
    MQPROPVARIANT PropVar;
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_MSMQ_CONNECTED, PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }
    
    ASSERTMSG(PropVar.vt == (VT_LPWSTR), "vt must be VT_LPWSTR");
    
    if(wcscmp(PropVar.pwszVal, MSMQ_CONNECTED) == 0)
    {
        *pfIsConnected = VARIANT_TRUE;
    }
    else if(wcscmp( PropVar.pwszVal, MSMQ_DISCONNECTED) == 0)
    {
        *pfIsConnected = VARIANT_FALSE;
    }
    else 
    {
        ASSERTMSG(TRUE, "True or False expected.");
    }
    
    MQFreeMemory(PropVar.pwszVal);
    return MQ_OK;
}


HRESULT CMSMQApplication::OapMgmtAction(LPCWSTR Action)const 
{
    HRESULT hr = MQMgmtAction(
                        m_Machine,
                        MO_MACHINE_TOKEN,
                        Action
                        );
    return hr;
}


HRESULT CMSMQApplication::Connect() 
{
    HRESULT hr = OapMgmtAction(MACHINE_ACTION_CONNECT);
    return CreateErrorHelper(hr, x_ObjectType);
}


HRESULT CMSMQApplication::Disconnect() 
{
    HRESULT hr = OapMgmtAction(MACHINE_ACTION_DISCONNECT);
    return CreateErrorHelper(hr, x_ObjectType);
}


HRESULT CMSMQApplication::Tidy() 
{
    HRESULT hr = OapMgmtAction(MACHINE_ACTION_TIDY);
    return CreateErrorHelper(hr, x_ObjectType);
}


BOOL inline IsBstrEmpty(const BSTR bstr)
{
    if(SysStringLen(bstr) == 0)
    {
        return TRUE;
    }
    return FALSE;
}


BSTR inline FixBstr(BSTR bstr)
{
    if(SysStringLen(bstr) == 0)
    {
        return NULL;
    }
    return bstr;
}
 

HRESULT CMSMQApplication::get_Machine(BSTR* pbstrMachine) 
{
    if(IsBstrEmpty(m_Machine))
    {
        //
        // The Local Machine.
        //

        WCHAR MachineName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD MachineNameLength = TABLE_SIZE(MachineName);

        if (!GetComputerName(MachineName, &MachineNameLength))
        {
           return CreateErrorHelper(GetLastError(), x_ObjectType);
        }

        CharLower(MachineName);

        *pbstrMachine = SysAllocString(MachineName);
        if(*pbstrMachine == NULL)
        {
            return CreateErrorHelper(E_OUTOFMEMORY, x_ObjectType);
        }
    }
    else
    {
        *pbstrMachine  = m_Machine.Copy();
    }
    if(*pbstrMachine == NULL)
    {
        return CreateErrorHelper(E_OUTOFMEMORY, x_ObjectType);
    }

    return MQ_OK;
}


HRESULT CMSMQApplication::put_Machine(BSTR bstrMachine)
{
    m_Machine = FixBstr(bstrMachine);
    if(!m_Machine && !IsBstrEmpty(bstrMachine))
    {
        return CreateErrorHelper(E_OUTOFMEMORY, x_ObjectType);
    }

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\app.h ===
//=--------------------------------------------------------------------------=
// MSMQApplicationObj.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQApplication object.
//
//
#ifndef _MSMQApplication_H_

#include "resrc1.h"       // main symbols
#include "mq.h"

#include "oautil.h"
#include "cs.h"

//
// format of the dword that is returned by PROPID_PC_VERSION
//
union MQOA_MSMQ_VERSION
{
  struct
  {
    WORD wBuild;
    BYTE bMinor;
    BYTE bMajor;
  };
  DWORD dwVersion;
};

class ATL_NO_VTABLE CMSMQApplication : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQApplication, &CLSID_MSMQApplication>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQApplication3, &IID_IMSMQApplication3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
    CMSMQApplication():
        m_pUnkMarshaler(NULL)
    {
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQAPPLICATION)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQApplication)
	COM_INTERFACE_ENTRY(IMSMQApplication3)
	COM_INTERFACE_ENTRY(IMSMQApplication2)
	COM_INTERFACE_ENTRY(IMSMQApplication)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQApplication
public:
    virtual ~CMSMQApplication();

    // IMSMQApplication methods
    // TODO: copy over the interface methods for IMSMQApplication from
    //       mqInterfaces.H here.
    STDMETHOD(MachineIdOfMachineName)(THIS_ BSTR bstrMachineName, BSTR FAR* pbstrGuid);
    // IMSMQApplication2 methods (in addition to IMSMQApplication)
    STDMETHOD(RegisterCertificate)(THIS_ VARIANT * pvarFlags, VARIANT * pvarExternalCertificate);
    STDMETHOD(MachineNameOfMachineId)(THIS_ BSTR bstrGuid, BSTR FAR* pbstrMachineName);
    STDMETHOD(get_MSMQVersionMajor)(THIS_ short *psMSMQVersionMajor);
    STDMETHOD(get_MSMQVersionMinor)(THIS_ short *psMSMQVersionMinor);
    STDMETHOD(get_MSMQVersionBuild)(THIS_ short *psMSMQVersionBuild);
    STDMETHOD(get_IsDsEnabled)(THIS_ VARIANT_BOOL *pfIsDsEnabled);
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);
    //
    // IMSMQApplication3 additional methods
    //
    STDMETHOD(get_ActiveQueues)(THIS_ VARIANT* pvActiveQueues);
	STDMETHOD(get_PrivateQueues)(THIS_ VARIANT* pvPrivateQueues);
	STDMETHOD(get_BytesInAllQueues)(THIS_ VARIANT* pvBytesInAllQueues);
    STDMETHOD(get_DirectoryServiceServer)(THIS_ BSTR* pbstrDirectoryServiceServer);
	STDMETHOD(get_IsConnected)(THIS_ VARIANT_BOOL* pfIsConnected);
    STDMETHOD(get_Machine)(THIS_ BSTR* pbstrMachine);
    STDMETHOD(put_Machine)(THIS_ BSTR bstrMachine);

   	STDMETHOD(Connect)(THIS);
	STDMETHOD(Disconnect)(THIS);
	STDMETHOD(Tidy)(THIS);

    //
    // Critical section to guard object's data and be thread safe
    //
    // Serialization not needed for this object, no per-instance members.
    // CCriticalSection m_csObj;
    //
    // MSMQ Version is cached since it is constant throughout the life of the object
    // There is a critical section to guard it. This will need to be changed if we serialize calls
    // to this object using the critical section m_csObj above
    //
    MQOA_MSMQ_VERSION m_uMSMQVersion;
protected:
    HRESULT GetMSMQVersion();

private:
    HRESULT OapMgmtAction(LPCWSTR Action)const;
    HRESULT OapMgmtGetInfo(MGMTPROPID PropId, MQPROPVARIANT& PropVar)const;

private:
    CComBSTR m_Machine;
};


#define _MSMQApplication_H_
#endif // _MSMQApplication_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\collection.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corparation
Module Name:
    collection.h

Abstract:
    Implementation file for MSMQCollection class.
    This class holds a collection of VARIANTs keyd by strings.

Author:
    Uri Ben-zeev (uribz) 16-jul-01

Envierment: 
    NT
--*/


#include "stdafx.h"
#include "dispids.h"
#include "oautil.h"
#include "collection.h"
#include <mqexception.h>

const MsmqObjType x_ObjectType = eMSMQCollection;


STDMETHODIMP CMSMQCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQManagement,
		&IID_IMSMQOutgoingQueueManagement,
		&IID_IMSMQQueueManagement,
	};
	for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); ++i)
	{
		if (InlineIsEqualGUID(*arr[i], riid))
			return S_OK;
	}
	return S_FALSE;
}


HRESULT CMSMQCollection::get_Count(long* pCount)
{
    *pCount = static_cast<long>(m_map.size());
    return MQ_OK;
}

void CMSMQCollection::Add(LPCWSTR key, const VARIANT& Value)
{
    ASSERTMSG(key != NULL, "key should not be NULL");

    CComBSTR bstrKey(key);
    if(bstrKey.m_str == NULL)
    {
        throw bad_hresult(E_OUTOFMEMORY);
    }

    //
    // ASSERT key does not exist.
    //
    MAP_SOURCE::iterator it;
    it = m_map.find(bstrKey);
    ASSERTMSG(it == m_map.end(), "Key already exists");

    std::pair<MAP_SOURCE::iterator, bool> p;
    p = m_map.insert(MAP_SOURCE::value_type(key, Value));
    if(!(p.second))
    {
        throw bad_hresult(E_OUTOFMEMORY);
    }
}


HRESULT CMSMQCollection::Item(VARIANT* pvKey, VARIANT* pvRet)
{
    BSTR bstrKey;
    HRESULT hr = GetTrueBstr(pvKey, &bstrKey);
    if(FAILED(hr))
    {
        return CreateErrorHelper(hr, x_ObjectType);
    }
    
    MAP_SOURCE::iterator it;
    it = m_map.find(bstrKey);
    if(it == m_map.end())
    {
        //
        // Element not found.
        //
        return CreateErrorHelper(MQ_ERROR_INVALID_PARAMETER, x_ObjectType);
    }

    VariantInit(pvRet);
    hr = VariantCopy(pvRet, &(it->second));
    if(FAILED(hr))
    {
        return CreateErrorHelper(hr, x_ObjectType);
    }
    return MQ_OK;
}
    
//
// NOTE! This function returns an enumeration of keys.
//

HRESULT CMSMQCollection::_NewEnum(IUnknown** ppunk)
{
    UINT size = static_cast<long>(m_map.size());
    ASSERTMSG(size != 0, "Collection should contain elements.");
    
    //
    // Create temporary array and fill it with Keys to be returned
    //
    AP<VARIANT> aTemp = new VARIANT[size];
    if(aTemp == NULL)
    {
        return CreateErrorHelper(E_OUTOFMEMORY, x_ObjectType);
    }

    UINT i = 0;
    MAP_SOURCE::iterator it;
    for(it = m_map.begin(); it != m_map.end() ; ++it, ++i)
    {
        aTemp[i].vt = VT_BSTR;
        aTemp[i].bstrVal = (*it).first;
    }
 
    //
    // Create EnumQbject (this is the return value.)
    //
    typedef CComObject< CComEnum< 
                            IEnumVARIANT,
                            &IID_IEnumVARIANT,
                            VARIANT,
                            _Copy<VARIANT> > > EnumVar;
                                    
    EnumVar* pVar = new EnumVar;
    if (pVar == NULL)
    {
        return CreateErrorHelper(E_OUTOFMEMORY, x_ObjectType);
    }
    
    //
    // Fill EnumQbject with the array.
    //
    HRESULT hr = pVar->Init(&aTemp[0], &aTemp[i], NULL, AtlFlagCopy);
    if FAILED(hr)
    {
        return CreateErrorHelper(hr, x_ObjectType);
    }

    //
    // Return EnumQbject.
    //
    pVar->QueryInterface(IID_IUnknown, (void**)ppunk);
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\debug_thread_id.h ===
//=--------------------------------------------------------------------------=
// debug_thread_id.h
//=--------------------------------------------------------------------------=
// Copyright  2002  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the DEBUG_THREAD_ID macro
//
#ifndef _DEBUG_THREAD_ID_H_

#ifdef _DEBUG

#include <stdio.h>
#include <mqmacro.h>
#include <strsafe.h>

#define DEBUG_THREAD_ID(szmsg) \
{ \
    char szTmp[400]; \
    DWORD dwtid = GetCurrentThreadId(); \
    StringCchPrintfA(szTmp, TABLE_SIZE(szTmp), "****** %s on thread %ld %lx\n", szmsg, dwtid, dwtid); \
    OutputDebugStringA(szTmp); \
}

#else  // !_DEBUG

#define DEBUG_THREAD_ID(szmsg)
#endif	// _DEBUG


#define _DEBUG_THREAD_ID_H_
#endif // _DEBUG_THREAD_ID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\debug.h ===
//=--------------------------------------------------------------------------=
// Debug.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the various macros and the like which are only useful in DEBUG
// builds
//
#ifndef _DEBUG_H_

//=---------------------------------------------------------------------------=
// all the things required to handle our ASSERTMSG mechanism
//=---------------------------------------------------------------------------=
//
// UNDONE: workaround for Falcon
#undef ASSERT
#define ASSERT(x) ASSERTMSG(x, "")

#ifdef _DEBUG

// Function Prototypes
//
void DisplayAssert(char * pszMsg, char * pszAssert, char * pszFile, unsigned int line);

// Macros
//

// our versions of the ASSERTMSG and FAIL macros.
//
#define ASSERTMSG(fTest, szMsg)                \
    if (!(fTest))  {                                        \
        static char szMsgCode[] = szMsg;                    \
        static char szAssert[] = #fTest;                    \
        DisplayAssert(szMsgCode, szAssert, __FILE__, __LINE__); \
    }

#define FAIL(szMsg)                                         \
        { static char szMsgCode[] = szMsg;                    \
        DisplayAssert(szMsgCode, "FAIL", __FILE__, __LINE__); }



// macro that checks a pointer for validity on input
//
#define CHECK_POINTER(val) if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) return E_POINTER


#else  // !_DEBUG

#define ASSERTMSG(fTest, err)
#define FAIL(err)

#define CHECK_POINTER(val)
#endif	// _DEBUG




#define _DEBUG_H_
#endif // _DEBUG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\collection.h ===
/*++

  Copyright (c) 2001 Microsoft Corparation
Module Name:
    collection.h

Abstract:
    Header file for MSMQCollection class.

Author:
    Uri Ben-zeev (uribz) 16-jul-01

Envierment: 
    NT
--*/

#ifndef _MSMQCollection_H_
#define _MSMQCollection_H_

#include "resrc1.h"       
#include "mq.h"
#include "dispids.h"

#include "oautil.h"
#include <cs.h>
#pragma warning(push, 3)
#include <map>
#pragma warning (pop)

typedef std::map<CComBSTR, CComVariant> MAP_SOURCE;

class ATL_NO_VTABLE CMSMQCollection : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQCollection, &IID_IMSMQCollection,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>

{
public:

DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQCollection)
    COM_INTERFACE_ENTRY(IMSMQCollection)
    COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(),
            &m_pUnkMarshaler.p
            );
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

    //
    // Critical section to guard object's data and be thread safe.
	// It is initialized to preallocate its resources with flag CCriticalSection::xAllocateSpinCount.
	// This means it may throw bad_alloc() on construction but not during usage.
    //
    CCriticalSection m_csObj;

    // ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);


    STDMETHOD(Item)(THIS_ VARIANT* pvKey, VARIANT* pvRet);
    STDMETHOD(get_Count)(THIS_ long* pCount);
    STDMETHOD(_NewEnum)(THIS_ IUnknown** ppunk);

    void Add(LPCWSTR key, const VARIANT& Value);
    
private:
    void ReleaseRefrences();
    MAP_SOURCE m_map; 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\dest.cpp ===
//=--------------------------------------------------------------------------=
// dest.Cpp
//=--------------------------------------------------------------------------=
// Copyright  2000  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQDestination object
//
//

#include "stdafx.h"
#include <autoptr.h>
#include "oautil.h"
#include "dest.h"


#ifdef _DEBUG
extern VOID RemBstrNode(void *pv);
#endif // _DEBUG



const MsmqObjType x_ObjectType = eMSMQDestination;

// debug...
#include "debug.h"
#include <strsafe.h>
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#endif // _DEBUG


//=--------------------------------------------------------------------------=
// CMSMQDestination::CMSMQDestination
//=--------------------------------------------------------------------------=
//
// Notes:
//
CMSMQDestination::CMSMQDestination() :
	m_csObj(CCriticalSection::xAllocateSpinCount)
{
    m_pUnkMarshaler = NULL; // ATL's Free Threaded Marshaler
    m_bstrADsPath = NULL;
    m_bstrPathName = NULL;
    m_bstrFormatName = NULL;
    m_hDest = INVALID_HANDLE_VALUE;
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::~CMSMQDestination
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//
CMSMQDestination::~CMSMQDestination()
{
    // TODO: clean up anything here.
    Close();
    ASSERTMSG(m_hDest == INVALID_HANDLE_VALUE, "Close failed");
    SysFreeString(m_bstrFormatName);
    SysFreeString(m_bstrADsPath);
    SysFreeString(m_bstrPathName);
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQDestination::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQDestination,
		&IID_IMSMQPrivateDestination,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//=--------------------------------------------------------------------------=
// HELPER CMSMQDestination::Close
//=--------------------------------------------------------------------------=
//
// Closes an MSMQ destination
//
// Notes:
//   Returns S_FALSE if the destination not opened
//           S_OK    if closed successfully
//           Other errors
//
HRESULT CMSMQDestination::Close()
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    //
    // Check if already closed
    //
    if (m_hDest == INVALID_HANDLE_VALUE) {
      //
      // Not opened, return success, but S_FALSE, not S_OK
      //
		return S_FALSE;
    }
    //
    // Close handle
    //
    HRESULT hresult = MQCloseQueue(m_hDest);

    m_hDest = INVALID_HANDLE_VALUE;
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::Open
//=--------------------------------------------------------------------------=
//
// Open an MSMQ destination (for send)
//
// Notes:
//   Returns S_FALSE if the destination already opened
//           S_OK    if opened successfully
//           Other errors
//
STDMETHODIMP CMSMQDestination::Open()
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    //
    // Check if already opened
    //
    HRESULT hresult;
    if (m_hDest != INVALID_HANDLE_VALUE) {
      //
      // Already opened, return succeess, but S_FALSE, not S_OK
      //
      return S_FALSE;
    }
    //
    // m_bstrFormatName should be set anytime the object is initialized in any way.
    // It can be NULL only if the object was not inited, in this case MQOpenQueue
    // would return an appropriate error anyway.
    //
    HANDLE hDest;
    IfFailGo(MQOpenQueue(m_bstrFormatName, MQ_SEND_ACCESS, MQ_DENY_NONE, &hDest));
    m_hDest = hDest;
    hresult = S_OK;

    // fall through
Error:
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::get_IsOpen
//=--------------------------------------------------------------------------=
//
// Indicates if this MSMQ destination is open
//
// Notes:
//   Retval is VARIANT_BOOL
//
STDMETHODIMP CMSMQDestination::get_IsOpen(VARIANT_BOOL * pfIsOpen)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);

    *pfIsOpen = CONVERT_BOOL_TO_VARIANT_BOOL(m_hDest != INVALID_HANDLE_VALUE);
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::get_IADs
//=--------------------------------------------------------------------------=
//
// Notes:
//    Not implemented yet
//
STDMETHODIMP CMSMQDestination::get_IADs(IDispatch ** /*ppIADs*/ )
{    
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::putref_IADs
//=--------------------------------------------------------------------------=
//
// Notes:
//    Not implemented yet
//
STDMETHODIMP CMSMQDestination::putref_IADs(IDispatch * /*pIADs*/ )
{    
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::get_ADsPath
//=--------------------------------------------------------------------------=
//
// Returns ADsPath of object (as set by user)
//
// Notes:
//
STDMETHODIMP CMSMQDestination::get_ADsPath(BSTR *pbstrADsPath)
{    
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *pbstrADsPath = SYSALLOCSTRING(m_bstrADsPath);
	if(*pbstrADsPath == NULL)
		return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
#ifdef _DEBUG
    RemBstrNode(*pbstrADsPath);
#endif // _DEBUG
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// GetFormatNameFromADsPath
//=--------------------------------------------------------------------------=
//
// Function to call MQADsPathToFormatName with retries on formatname
// buffer size
//
// Notes:
//
HRESULT GetFormatNameFromADsPath(LPCWSTR pwszPathName, BSTR *pbstrFormatName)
{
    HRESULT hresult;
    //
    // Convert to format name
    //
    CStaticBufferGrowing<WCHAR, FORMAT_NAME_INIT_BUFFER_EX> wszFormatName;
    DWORD dwFormatNameLen = wszFormatName.GetBufferMaxSize();
    hresult = MQADsPathToFormatName(pwszPathName,
                                    wszFormatName.GetBuffer(),
                                    &dwFormatNameLen);
    while (hresult == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL) {
      //
      // format name buffer too small, realloc buffer and retry
      //
      ASSERTMSG(dwFormatNameLen > wszFormatName.GetBufferMaxSize(), "ADsPathToFormatName error");
      IfFailGo(wszFormatName.AllocateBuffer(dwFormatNameLen));
      hresult = MQADsPathToFormatName(pwszPathName,
                                      wszFormatName.GetBuffer(),
                                      &dwFormatNameLen);
    }
    //
    // We either failed the call, or succeeded
    //
    IfFailGo(hresult);
    //
    // Alloc bstr and return
    //
    BSTR bstrFormatName;
    IfNullFail(bstrFormatName = SysAllocString(wszFormatName.GetBuffer()));
    *pbstrFormatName = bstrFormatName;
    hresult = S_OK;

    // fall through
Error:
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::put_ADsPath
//=--------------------------------------------------------------------------=
//
// Sets ADsPath of object. This in turn also sets the format name, invalidates PathName, 
// and closes the MSMQ handle if opened
//
// Notes:
//
STDMETHODIMP CMSMQDestination::put_ADsPath(BSTR bstrADsPath)
{    
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);

    BSTR bstrFormatName = NULL;
    BSTR bstrADsPathTmp = NULL;
    HRESULT hresult;
    //
    // Get Formatname
    //
    IfFailGo(GetFormatNameFromADsPath(bstrADsPath, &bstrFormatName));
    //
    // Alloc ADsPath
    //
    IfNullFail(bstrADsPathTmp = SysAllocString(bstrADsPath));
    //
    // replace m_bstrADsPath
    //
    SysFreeString(m_bstrADsPath);
    m_bstrADsPath = bstrADsPathTmp;
    bstrADsPathTmp = NULL; //no delete on exit
    //
    // empty m_bstrPathName
    //
    SysFreeString(m_bstrPathName);
    m_bstrPathName = NULL;
    //
    // replace m_bstrFormatName
    //
    SysFreeString(m_bstrFormatName);
    m_bstrFormatName = bstrFormatName;
    bstrFormatName = NULL; //no delete on exit
    //
    // Close opened handle if any
    //
    Close();
    ASSERTMSG(m_hDest == INVALID_HANDLE_VALUE, "Close failed");
    //
    // Wer'e OK
    //
    hresult = S_OK;
    
    // fall through
Error:
    SysFreeString(bstrADsPathTmp);
    SysFreeString(bstrFormatName);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::get_PathName
//=--------------------------------------------------------------------------=
//
// Returns PathName of object (as set by user)
//
// Notes:
//
STDMETHODIMP CMSMQDestination::get_PathName(BSTR *pbstrPathName)
{    
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *pbstrPathName = SYSALLOCSTRING(m_bstrPathName);
	if(*pbstrPathName == NULL)
		return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
#ifdef _DEBUG
    RemBstrNode(*pbstrPathName);
#endif // _DEBUG
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// GetFormatNameFromPathName
//=--------------------------------------------------------------------------=
//
// Function to call MQPathToFormatName with retries on formatname
// buffer size
//
// Notes:
//
HRESULT GetFormatNameFromPathName(LPCWSTR pwszPathName, BSTR *pbstrFormatName)
{
    HRESULT hresult;
    //
    // Convert to format name
    //
    CStaticBufferGrowing<WCHAR, FORMAT_NAME_INIT_BUFFER> wszFormatName;
    DWORD dwFormatNameLen = wszFormatName.GetBufferMaxSize();
    hresult = MQPathNameToFormatName(pwszPathName,
                                     wszFormatName.GetBuffer(),
                                     &dwFormatNameLen);
    while (hresult == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL) {
      //
      // format name buffer too small, realloc buffer and retry
      //
      ASSERTMSG(dwFormatNameLen > wszFormatName.GetBufferMaxSize(), "MQPathNameToFormatName error");
      IfFailGo(wszFormatName.AllocateBuffer(dwFormatNameLen));
      hresult = MQPathNameToFormatName(pwszPathName,
                                       wszFormatName.GetBuffer(),
                                       &dwFormatNameLen);
    }
    //
    // We either failed the call, or succeeded
    //
    IfFailGo(hresult);
    //
    // Alloc bstr and return
    //
    BSTR bstrFormatName;
    IfNullFail(bstrFormatName = SysAllocString(wszFormatName.GetBuffer()));
    *pbstrFormatName = bstrFormatName;
    hresult = S_OK;

    // fall through
Error:
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::put_PathName
//=--------------------------------------------------------------------------=
//
// Sets PathName of object. This in turn also sets the format name, invalidates the ADsPath,
// and closes the MSMQ handle if opened
//
// Notes:
//
STDMETHODIMP CMSMQDestination::put_PathName(BSTR bstrPathName)
{    
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);

    BSTR bstrFormatName = NULL;
    BSTR bstrPathNameTmp = NULL;
    HRESULT hresult;
    //
    // Get Formatname
    //
    IfFailGo(GetFormatNameFromPathName(bstrPathName, &bstrFormatName));
    //
    // Alloc bstrPathName
    //
    IfNullFail(bstrPathNameTmp = SysAllocString(bstrPathName));
    //
    // replace m_bstrPathName
    //
    SysFreeString(m_bstrPathName);
    m_bstrPathName = bstrPathNameTmp;
    bstrPathNameTmp = NULL; //no delete on exit
    //
    // empty m_bstrADsPath
    //
    SysFreeString(m_bstrADsPath);
    m_bstrADsPath = NULL;
    //
    // replace m_bstrFormatName
    //
    SysFreeString(m_bstrFormatName);
    m_bstrFormatName = bstrFormatName;
    bstrFormatName = NULL; //no delete on exit
    //
    // Close opened handle if any
    //
    Close();
    ASSERTMSG(m_hDest == INVALID_HANDLE_VALUE, "Close failed");
    //
    // Wer'e OK
    //
    hresult = S_OK;
    
    // fall through
Error:
    SysFreeString(bstrPathNameTmp);
    SysFreeString(bstrFormatName);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::get_FormatName
//=--------------------------------------------------------------------------=
//
// Returns MSMQ format name of object (as set by user, or computed when setting
// the ADsPath of the object)
//
// Notes:
//
STDMETHODIMP CMSMQDestination::get_FormatName(BSTR *pbstrFormatName)
{    
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *pbstrFormatName = SYSALLOCSTRING(m_bstrFormatName);
	if(*pbstrFormatName == NULL)
	    return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
#ifdef _DEBUG
    RemBstrNode(*pbstrFormatName);
#endif // _DEBUG
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::put_FormatName
//=--------------------------------------------------------------------------=
//
// Sets formatname of object. This in turn also empties the ADsPath and PathName of the
// object (if any), and close the MSMQ handle if opened
//
// Notes:
//
STDMETHODIMP CMSMQDestination::put_FormatName(BSTR bstrFormatName)
{    
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);

    BSTR bstrFormatNameTmp = NULL;
    HRESULT hresult;
    //
    // Alloc FormatName
    //
    IfNullFail(bstrFormatNameTmp = SysAllocString(bstrFormatName));
    //
    // empty m_bstrADsPath (we do not support providing an ADsPath given a format name)
    //
    SysFreeString(m_bstrADsPath);
    m_bstrADsPath = NULL;
    //
    // empty m_bstrPathName (we do not support providing a PathName given a format name)
    //
    SysFreeString(m_bstrPathName);
    m_bstrPathName = NULL;
    //
    // replace m_bstrFormatName
    //
    SysFreeString(m_bstrFormatName);
    m_bstrFormatName = bstrFormatNameTmp;
    bstrFormatNameTmp = NULL; //no delete on exit
    //
    // Close opened handle if any
    //
    Close();
    ASSERTMSG(m_hDest == INVALID_HANDLE_VALUE, "Close failed");
    //
    // Wer'e OK
    //
    hresult = S_OK;
    
    // fall through
Error:
    SysFreeString(bstrFormatNameTmp);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::get_Destinations
//=--------------------------------------------------------------------------=
//
// Notes:
//    Not implemented yet
//
STDMETHODIMP CMSMQDestination::get_Destinations(IDispatch ** /*ppDestinations*/ )
{    
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::putref_Destinations
//=--------------------------------------------------------------------------=
//
// Notes:
//    Not implemented yet
//
STDMETHODIMP CMSMQDestination::putref_Destinations(IDispatch * /*pDestinations*/ )
{    
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::get_Properties
//=--------------------------------------------------------------------------=
//
// Notes:
//    Not implemented yet
//
HRESULT CMSMQDestination::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::get_Handle (IMSMQPrivateDestination)
//=--------------------------------------------------------------------------=
//
// Returns the MSMQ handle opened for this object (opens it if not opened)
//
// Notes:
//   Method on a private interface for MSMQ use only
//
STDMETHODIMP CMSMQDestination::get_Handle(VARIANT * pvarHandle)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);

    ASSERTMSG(pvarHandle != NULL, "NULL pvarHandle");
    //
    // open (and cache) handle if not opened
    //
    HRESULT hresult;
    if (m_hDest == INVALID_HANDLE_VALUE) {
      IfFailGo(Open());
    }
    ASSERTMSG(m_hDest != INVALID_HANDLE_VALUE, "Open failed");
    //
    // return handle
    //
    pvarHandle->vt = VT_I8;
    V_I8(pvarHandle) = (LONGLONG) m_hDest;
    hresult = S_OK;

    // fall through
Error:
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// GetFormatNameFromHandle
//=--------------------------------------------------------------------------=
//
// Function to call MQHandleToFormatName with retries on formatname
// buffer size
//
// Notes:
//
HRESULT GetFormatNameFromHandle(QUEUEHANDLE hQueue, BSTR *pbstrFormatName)
{
    HRESULT hresult;
    //
    // Convert to format name
    //
    CStaticBufferGrowing<WCHAR, FORMAT_NAME_INIT_BUFFER_EX> wszFormatName;
    DWORD dwFormatNameLen = wszFormatName.GetBufferMaxSize();
    hresult = MQHandleToFormatName(hQueue,
                                   wszFormatName.GetBuffer(),
                                   &dwFormatNameLen);
    while (hresult == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL) {
      //
      // format name buffer too small, realloc buffer and retry
      //
      ASSERTMSG(dwFormatNameLen > wszFormatName.GetBufferMaxSize(), "MQHandleToFormatName error");
      IfFailGo(wszFormatName.AllocateBuffer(dwFormatNameLen));
      hresult = MQHandleToFormatName(hQueue,
                                     wszFormatName.GetBuffer(),
                                     &dwFormatNameLen);
    }
    //
    // We either failed the call, or succeeded
    //
    IfFailGo(hresult);
    //
    // Alloc bstr and return
    //
    BSTR bstrFormatName;
    IfNullFail(bstrFormatName = SysAllocString(wszFormatName.GetBuffer()));
    *pbstrFormatName = bstrFormatName;
    hresult = S_OK;

    // fall through
Error:
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQDestination::put_Handle (IMSMQPrivateDestination)
//=--------------------------------------------------------------------------=
//
// Sets the MSMQ handle opened for this object. This in turn invalidates the 
// ADsPath, and PathName (if any set by the user), and sets the formatname based on the handle.
// It also closes existing MSMQ handle if opened.
//
// Notes:
//   Method on a private interface for MSMQ use only
//
STDMETHODIMP CMSMQDestination::put_Handle(VARIANT varHandle)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);

    HRESULT hresult;
    BSTR bstrFormatName = NULL;
    QUEUEHANDLE hHandle;
    VARIANT varHandleToUse;
    VariantInit(&varHandleToUse);
    //
    // Get VT_I8
    //
    if (FAILED(VariantChangeType(&varHandleToUse, &varHandle, 0, VT_I8))) {
      IfFailGo(E_INVALIDARG);
    }
    hHandle = (QUEUEHANDLE) V_I8(&varHandleToUse);
    //
    // Get Formatname
    //
    IfFailGo(GetFormatNameFromHandle(hHandle, &bstrFormatName));
    //
    // empty m_bstrADsPath (not describing this handle)
    //
    SysFreeString(m_bstrADsPath);
    m_bstrADsPath = NULL;
    //
    // empty m_bstrPathName (not describing this handle)
    //
    SysFreeString(m_bstrPathName);
    m_bstrPathName = NULL;
    //
    // replace m_bstrFormatName
    //
    SysFreeString(m_bstrFormatName);
    m_bstrFormatName = bstrFormatName;
    bstrFormatName = NULL; //no delete on exit
    //
    // Close opened handle if any
    //
    Close();
    //
    // Set new handle
    //
    ASSERTMSG(m_hDest == INVALID_HANDLE_VALUE, "Close failed");
    m_hDest = hHandle;
    //
    // Wer'e OK
    //
    hresult = S_OK;

    // fall through
Error:
    SysFreeString(bstrFormatName);
    return CreateErrorHelper(hresult, x_ObjectType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\debug.cpp ===
//=--------------------------------------------------------------------------=
// debug.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
//  debug stuff
//

// We need this module ONLY in debug mode

#include "stdafx.h"

#include <cs.h>



UINT g_cAlloc = 0;
UINT g_cAllocBstr = 0;

// All folowing is taken only in debug mode
#ifdef _DEBUG

#include "debug.h"
#include <mqmacro.h>
#include <strsafe.h>

struct MemNode *g_pmemnodeFirst = NULL;
struct BstrNode *g_pbstrnodeFirst = NULL;

//#2619 RaananH Multithread async receive
CCriticalSection g_csDbgMem(CCriticalSection::xAllocateSpinCount);
CCriticalSection g_csDbgBstr(CCriticalSection::xAllocateSpinCount);

// debug memory tracking
struct MemNode
{
    MemNode *m_pmemnodeNext;
    UINT m_cAlloc;
    size_t m_nSize;
    LPCSTR m_lpszFileName;
    int m_nLine;
    VOID *m_pv;

    MemNode() { 
      m_pmemnodeNext = NULL;
      m_cAlloc = 0;
      m_pv = NULL;
      m_nSize = 0;
      m_lpszFileName = NULL;
      m_nLine = 0;
    }
};

//#2619 RaananH Multithread async receive
void AddMemNode(void *pv, size_t nSize, LPCSTR lpszFileName, int nLine)
{
    MemNode *pmemnode;
    HRESULT hresult = NOERROR;

    pmemnode = (MemNode *)::operator new(sizeof(MemNode));
    if (pmemnode == NULL) {
      ASSERTMSG(hresult == NOERROR, "OOM");
    }
    else {
      // cons
      pmemnode->m_pv = pv;
      pmemnode->m_nSize = nSize;
      pmemnode->m_lpszFileName = lpszFileName;
      pmemnode->m_nLine = nLine;
      CS lock(g_csDbgMem); //#2619
      pmemnode->m_cAlloc = g_cAlloc;
      pmemnode->m_pmemnodeNext = g_pmemnodeFirst;
      g_pmemnodeFirst = pmemnode;
    }
    return;
}

//#2619 RaananH Multithread async receive
VOID RemMemNode(void *pv)
{
    CS lock(g_csDbgMem); //#2619
    MemNode *pmemnodeCur = g_pmemnodeFirst;
    MemNode *pmemnodePrev = NULL;

    while (pmemnodeCur) {
      if (pmemnodeCur->m_pv == pv) {

        // remove
        if (pmemnodePrev) {
          pmemnodePrev->m_pmemnodeNext = pmemnodeCur->m_pmemnodeNext;
        }
        else {
          g_pmemnodeFirst = pmemnodeCur->m_pmemnodeNext;
        }
        ::operator delete(pmemnodeCur);
        break;
      }
      pmemnodePrev = pmemnodeCur;
      pmemnodeCur = pmemnodeCur->m_pmemnodeNext;
    } // while
    return;
}


//#2619 RaananH Multithread async receive
void* __cdecl operator new(
    size_t nSize, 
    LPCSTR lpszFileName, 
    int nLine)
{
    void *pv = malloc(nSize);
    
    CS lock(g_csDbgMem); //#2619
    g_cAlloc++;
    if (pv) {
      AddMemNode(pv, nSize, lpszFileName, nLine);
    }
    return pv;
}

void __cdecl operator delete(void* pv)
{
    RemMemNode(pv);    
    free(pv);
}

#if _MSC_VER >= 1200
void __cdecl operator delete(void* pv, LPCSTR, int)
{
    operator delete(pv);
}
#endif //_MSC_VER >= 1200

//#2619 RaananH Multithread async receive
void DumpMemLeaks()                
{
    CS lock(g_csDbgMem); //#2619
    MemNode *pmemnodeCur = g_pmemnodeFirst;
    CHAR szMessage[_MAX_PATH];

    //ASSERTMSG(pmemnodeCur == NULL, "operator new leaked: View | Output");
    while (pmemnodeCur != NULL) {
      // assume the debugger or auxiliary port
      // WIN95: can use ANSI versions on NT as well...
      //
      StringCchPrintfA(
		  szMessage,
		  TABLE_SIZE(szMessage),
          "operator new leak: pv %p cAlloc %u File %hs, Line %d\n",
          pmemnodeCur->m_pv,
          pmemnodeCur->m_cAlloc,
	      pmemnodeCur->m_lpszFileName, 
          pmemnodeCur->m_nLine
		  );

	   OutputDebugStringA(szMessage);
       pmemnodeCur = pmemnodeCur->m_pmemnodeNext;
    }    
}


// BSTR debugging...
struct BstrNode
{
    BstrNode *m_pbstrnodeNext;
    UINT m_cAlloc;
    size_t m_nSize;
    VOID *m_pv;

    BstrNode() { 
      m_pbstrnodeNext = NULL;
      m_cAlloc = 0;
      m_pv = NULL;
      m_nSize = 0;
    }
};

//#2619 RaananH Multithread async receive
void AddBstrNode(void *pv, size_t nSize)
{
    BstrNode *pbstrnode;
    HRESULT hresult = NOERROR;

    pbstrnode = (BstrNode *)::operator new(sizeof(BstrNode));
    if (pbstrnode == NULL) {
      ASSERTMSG(hresult == NOERROR, "OOM");
    }
    else {
      // cons
      pbstrnode->m_pv = pv;
      pbstrnode->m_nSize = nSize;
      CS lock(g_csDbgBstr); //#2619
      pbstrnode->m_cAlloc = g_cAllocBstr;
      pbstrnode->m_pbstrnodeNext = g_pbstrnodeFirst;
      g_pbstrnodeFirst = pbstrnode;
    }
    return;
}

//#2619 RaananH Multithread async receive
VOID RemBstrNode(void *pv)
{
    CS lock(g_csDbgBstr); //#2619
    BstrNode *pbstrnodeCur = g_pbstrnodeFirst;
    BstrNode *pbstrnodePrev = NULL;

    if (pv == NULL) {
      return;
    }
    while (pbstrnodeCur) {
      if (pbstrnodeCur->m_pv == pv) {

        // remove
        if (pbstrnodePrev) {
          pbstrnodePrev->m_pbstrnodeNext = pbstrnodeCur->m_pbstrnodeNext;
        }
        else {
          g_pbstrnodeFirst = pbstrnodeCur->m_pbstrnodeNext;
        }
        ::operator delete(pbstrnodeCur);
        break;
      }
      pbstrnodePrev = pbstrnodeCur;
      pbstrnodeCur = pbstrnodeCur->m_pbstrnodeNext;
    } // while
    return;
}

void DebSysFreeString(BSTR bstr)
{
    if (bstr) {
      RemBstrNode(bstr);
    }
    SysFreeString(bstr);  
}

//#2619 RaananH Multithread async receive
BSTR DebSysAllocString(const OLECHAR FAR* sz)
{
    BSTR bstr = SysAllocString(sz);
    if (bstr) {
      CS lock(g_csDbgBstr); //#2619
      g_cAllocBstr++;
      AddBstrNode(bstr, SysStringByteLen(bstr));
    }
    return bstr;
}

//#2619 RaananH Multithread async receive
BSTR DebSysAllocStringLen(const OLECHAR *sz, unsigned int cch)
{
    BSTR bstr = SysAllocStringLen(sz, cch);
    if (bstr) {
      CS lock(g_csDbgBstr); //#2619
      g_cAllocBstr++;
      AddBstrNode(bstr, SysStringByteLen(bstr));
    }
    return bstr;
}

//#2619 RaananH Multithread async receive
BSTR DebSysAllocStringByteLen(const CHAR *sz, unsigned int cb)
{
    BSTR bstr = SysAllocStringByteLen(sz, cb);
    if (bstr) {
      CS lock(g_csDbgBstr); //#2619
      g_cAllocBstr++;
      AddBstrNode(bstr, SysStringByteLen(bstr));
    }
    return bstr;
}

BOOL DebSysReAllocString(BSTR *pbstr, const OLECHAR *sz)
{
    BSTR bstr = DebSysAllocString(sz);
    if (bstr == NULL) {
      return FALSE;
    }
    if (*pbstr) {
      DebSysFreeString(*pbstr);
    }
    *pbstr = bstr;
    return TRUE;
}

BOOL DebSysReAllocStringLen(
    BSTR *pbstr, 
    const OLECHAR *sz, 
    unsigned int cch)
{
    BSTR bstr = DebSysAllocStringLen(sz, cch);
    if (bstr == NULL) {
      return FALSE;
    }
    if (*pbstr) {
      DebSysFreeString(*pbstr);
    }
    *pbstr = bstr;
    return TRUE;
}

//#2619 RaananH Multithread async receive
void DumpBstrLeaks()
{
    CS lock(g_csDbgBstr); //#2619
    BstrNode *pbstrnodeCur = g_pbstrnodeFirst;
    CHAR szMessage[_MAX_PATH];

    //ASSERTMSG(pbstrnodeCur == NULL, "BSTRs leaked: View | Output");
    while (pbstrnodeCur != NULL) {
      // assume the debugger or auxiliary port
      // WIN95: can use ANSI versions on NT as well...
      //
      StringCchPrintfA(
		  szMessage, 
		  TABLE_SIZE(szMessage),
          "bstr leak: pv %p cAlloc %u size %d\n",
          pbstrnodeCur->m_pv,
          pbstrnodeCur->m_cAlloc,
          pbstrnodeCur->m_nSize
		  );
      OutputDebugStringA(szMessage);
      pbstrnodeCur = pbstrnodeCur->m_pbstrnodeNext;
    }    
}

//
// taken from debug.cpp of lwfw
//

//#include "IPServer.H"
#include <stdlib.h>


//=--------------------------------------------------------------------------=
// Private Constants
//---------------------------------------------------------------------------=
//
static const char szFormat[]  = "%s\nFile %s, Line %d";
static const char szFormat2[] = "%s\n%s\nFile %s, Line %d";

#define _SERVERNAME_ "ActiveX Framework"

static const char szTitle[]  = _SERVERNAME_ " Assertion  (Abort = UAE, Retry = INT 3, Ignore = Continue)";


//=--------------------------------------------------------------------------=
// Local functions
//=--------------------------------------------------------------------------=
int NEAR _IdMsgBox(LPSTR pszText, LPCSTR pszTitle, UINT mbFlags);

//=--------------------------------------------------------------------------=
// DisplayAssert
//=--------------------------------------------------------------------------=
// Display an assert message box with the given pszMsg, pszAssert, source
// file name, and line number. The resulting message box has Abort, Retry,
// Ignore buttons with Abort as the default.  Abort does a FatalAppExit;
// Retry does an int 3 then returns; Ignore just returns.
//
VOID DisplayAssert
(
    LPSTR	 pszMsg,
    LPSTR	 pszAssert,
    LPSTR	 pszFile,
    UINT	 line
)
{
    char	szMsg[250];
    LPSTR	lpszText;

    lpszText = pszMsg;		// Assume no file & line # info

    // If C file assert, where you've got a file name and a line #
    //
    if (pszFile) {

        // Then format the assert nicely
        //
        StringCchPrintfA(
			szMsg, 
			TABLE_SIZE(szMsg), 
			szFormat, 
			(pszMsg&&*pszMsg) ? pszMsg : pszAssert, 
			pszFile, 
			line
			);

        lpszText = szMsg;
    }

    // Put up a dialog box
    //
    switch (_IdMsgBox(lpszText, szTitle, MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SYSTEMMODAL)) {
        case IDABORT:
            FatalAppExitA(0, lpszText);
            return;

        case IDRETRY:
            // call the win32 api to break us.
            //
            DebugBreak();
            return;
    }

    return;
}


//=---------------------------------------------------------------------------=
// Beefed-up version of WinMessageBox.
//=---------------------------------------------------------------------------=
//
int NEAR _IdMsgBox
(
    LPSTR	pszText,
    LPCSTR	pszTitle,
    UINT	mbFlags
)
{
    HWND hwndActive;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBoxA(hwndActive, pszText, pszTitle, mbFlags);

    return id;
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\dest.h ===
//=--------------------------------------------------------------------------=
// dest.H
//=--------------------------------------------------------------------------=
// Copyright  2000 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQDestination object.
//
//
#ifndef _MSMQDestination_H_
#define _MSMQDestination_H_

#include "resrc1.h"       // main symbols
#include "dispids.h"
#include "mq.h"

#include "oautil.h"
#include "cs.h"

class ATL_NO_VTABLE CMSMQDestination : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQDestination, &CLSID_MSMQDestination>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQDestination, &IID_IMSMQDestination,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>,
	public IDispatchImpl<IMSMQPrivateDestination, &IID_IMSMQPrivateDestination,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQDestination();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQDESTINATION)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQDestination)
	COM_INTERFACE_ENTRY(IMSMQDestination)
	COM_INTERFACE_ENTRY(IMSMQPrivateDestination)
	COM_INTERFACE_ENTRY2(IDispatch, IMSMQDestination)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQDestination
public:

    virtual ~CMSMQDestination();

    // IMSMQDestination methods
    // TODO: copy over the interface methods for IMSMQDestination
    //
    STDMETHOD(Open)(THIS);
    STDMETHOD(Close)(THIS);
    STDMETHOD(get_IsOpen)(THIS_ VARIANT_BOOL *pfIsOpen);
    STDMETHOD(get_IADs)(THIS_ IDispatch FAR* FAR* ppIADs);
    STDMETHOD(putref_IADs)(THIS_ IDispatch FAR* pIADs);
    STDMETHOD(get_ADsPath)(THIS_ BSTR FAR* pbstrADsPath);
    STDMETHOD(put_ADsPath)(THIS_ BSTR bstrADsPath);
    STDMETHOD(get_PathName)(THIS_ BSTR FAR* pbstrPathName);
    STDMETHOD(put_PathName)(THIS_ BSTR bstrPathName);
    STDMETHOD(get_FormatName)(THIS_ BSTR FAR* pbstrFormatName);
    STDMETHOD(put_FormatName)(THIS_ BSTR bstrFormatName);
    STDMETHOD(get_Destinations)(THIS_ IDispatch FAR* FAR* ppDestinations);
    STDMETHOD(putref_Destinations)(THIS_ IDispatch FAR* pDestinations);
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);
    //
    // IMSMQPrivateDestination methods (private interface for MSMQ use)
    //
    STDMETHOD(get_Handle)(THIS_ VARIANT FAR* pvarHandle);
    STDMETHOD(put_Handle)(THIS_ VARIANT varHandle);

    //
    // Critical section to guard object's data and be thread safe.
	// It is initialized to preallocate its resources with flag CCriticalSection::xAllocateSpinCount.
	// This means it may throw bad_alloc() on construction but not during usage.
    //
    CCriticalSection m_csObj;

protected:

private:
    // member variables that nobody else gets to look at.
    // TODO: add your member variables and private functions here.
    BSTR m_bstrADsPath;
    BSTR m_bstrPathName;
    BSTR m_bstrFormatName;
    HANDLE m_hDest;
};

#endif // _MSMQDestination_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\dispids.h ===
//=--------------------------------------------------------------------------=
// Dispids.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// dispids for use in an automation or control object.
//
#ifndef _DISPIDS_H_

// MqMessage dispids
#define DISPID_MQMESSAGE_BODY               0
#define DISPID_MQMESSAGE_DELIVERY           1
#define DISPID_MQMESSAGE_PRIORITY           2
#define DISPID_MQMESSAGE_JOURNAL            3
#define DISPID_MQMESSAGE_QUEUEINFORESPONSE  4
#define DISPID_MQMESSAGE_APPSPECIFIC        5
#define DISPID_MQMESSAGE_GUIDSRCMACHINE     6
#define DISPID_MQMESSAGE_MSGCLASS           7
#define DISPID_MQMESSAGE_QUEUEINFOADMIN     8
#define DISPID_MQMESSAGE_ID                 9
#define DISPID_MQMESSAGE_IDCORRELATION      10
#define DISPID_MQMESSAGE_ACKNOWLEDGE        11
#define DISPID_MQMESSAGE_LABEL              12
#define DISPID_MQMESSAGE_LENBODY            13 
#define DISPID_MQMESSAGE_MAXTIMETOREACHQUEUE          14
#define DISPID_MQMESSAGE_MAXTIMETORECEIVE   15
#define DISPID_MQMESSAGE_ENCRYPTALG         16
#define DISPID_MQMESSAGE_HASHALG            17
#define DISPID_MQMESSAGE_SENTTIME           18
#define DISPID_MQMESSAGE_ARRIVEDTIME        19
#define DISPID_MQMESSAGE_QUEUEINFODEST      20
#define DISPID_MQMESSAGE_SENDERCERT         21
#define DISPID_MQMESSAGE_SENDERID           22
#define DISPID_MQMESSAGE_SENDERIDTYPE       23
#define DISPID_MQMESSAGE_TRACE              24
#define DISPID_MQMESSAGE_PRIVLEVEL          25
#define DISPID_MQMESSAGE_AUTHLEVEL          26
#define DISPID_MQMESSAGE_AUTHENTICATED      27
#define DISPID_MQMESSAGE_SENDERVERSION      28
#define DISPID_MQMESSAGE_EXTENSION          29
#define DISPID_MQMESSAGE_GUIDCONNECTORTYPE  30
#define DISPID_MQMESSAGE_QUEUEINFOXACTSTATUS          31
#define DISPID_MQMESSAGE_DESTSYMMKEY        32
#define DISPID_MQMESSAGE_SIGNATURE          33
#define DISPID_MQMESSAGE_AUTHPROVTYPE       34
#define DISPID_MQMESSAGE_AUTHPROVNAME       35
#define DISPID_MQMESSAGE_MSGCLASS2          36
#define DISPID_MQMESSAGE_PROPERTIES         37
#define DISPID_MQMESSAGE_IDXACT             38
#define DISPID_MQMESSAGE_FIRSTINXACT        39
#define DISPID_MQMESSAGE_LASTINXACT         40
#define DISPID_MQMESSAGE_QUEUEINFORESPONSE_v2         41
#define DISPID_MQMESSAGE_QUEUEINFOADMIN_v2            42
#define DISPID_MQMESSAGE_RECEIVEDAUTHENTICATIONLEVEL  43
#define DISPID_MQMESSAGE_QUEUEINFORESPONSE_v3         44
#define DISPID_MQMESSAGE_QUEUEINFOADMIN_v3            45
#define DISPID_MQMESSAGE_DESTRESPONSE                 46
#define DISPID_MQMESSAGE_DESTINATION                  48
#define DISPID_MQMESSAGE_LOOKUPID                     49
#define DISPID_MQMESSAGE_AUTHENTICATED2               50
#define DISPID_MQMESSAGE_FIRSTINXACT2                 51
#define DISPID_MQMESSAGE_LASTINXACT2                  52
#define DISPID_MQMESSAGE_SOAPENVELOPE                 53
#define DISPID_MQMESSAGE_COMPOUNDMESSAGE              54
#define DISPID_MQMESSAGE_SOAPHEADER                   55
#define DISPID_MQMESSAGE_SOAPBODY                     56

// MqQueue dispids
#define DISPID_MQQUEUE_HANDLE               0
#define DISPID_MQQUEUE_ACCESS               1
#define DISPID_MQQUEUE_SHAREMODE            2
#define DISPID_MQQUEUE_QUEUEINFO            3
#define DISPID_MQQUEUE_ISOPEN               4
#define DISPID_MQQUEUE_PROPERTIES           5
#define DISPID_MQQUEUE_HANDLE2              6
#define DISPID_MQQUEUE_ISOPEN2              7

// MqQueueInfo
#define DISPID_MQQUEUEINFO_GUIDQUEUE         0
#define DISPID_MQQUEUEINFO_GUIDSERVICETYPE   1
#define DISPID_MQQUEUEINFO_LABEL             2
#define DISPID_MQQUEUEINFO_PATHNAME          3
#define DISPID_MQQUEUEINFO_MACHINE           4
#define DISPID_MQQUEUEINFO_FORMATNAME        5
#define DISPID_MQQUEUEINFO_ISTRANSACTIONAL   6
#define DISPID_MQQUEUEINFO_PRIVLEVEL         7
#define DISPID_MQQUEUEINFO_JOURNAL           8
#define DISPID_MQQUEUEINFO_BASEPRIORITY      9
#define DISPID_MQQUEUEINFO_CREATETIME        10
#define DISPID_MQQUEUEINFO_MODIFYTIME        11
#define DISPID_MQQUEUEINFO_AUTHENTICATE      12
#define DISPID_MQQUEUEINFO_QUOTA             13
#define DISPID_MQQUEUEINFO_JOURNALQUOTA      14
#define DISPID_MQQUEUEINFO_ISWORLDREADABLE   15
#define DISPID_MQQUEUEINFO_PATHNAME_DNS      16
#define DISPID_MQQUEUEINFO_PROPERTIES        17
#define DISPID_MQQUEUEINFO_SECURITY          18
#define DISPID_MQQUEUEINFO_ADSPATH           19
#define DISPID_MQQUEUEINFO_ISTRANSACTIONAL2  20
#define DISPID_MQQUEUEINFO_ISWORLDREADABLE2  21
#define DISPID_MQQUEUEINFO_MULTICAST_ADDRESS 22
#define DISPID_MQQUEUEINFO_QUEUE_TYPE        23
#define DISPID_MQQUEUEINFO_IS_LOCAL          24
#define DISPID_MQQUEUEINFO_FOREIGN_STATUS    25
#define DISPID_MQQUEUEINFO_USED_QUOTA        26
#define DISPID_MQQUEUEINFO_QUEUE_STATE       27
#define DISPID_MQQUEUEINFO_NEXT_HOPS         28


// MqQueueEvents
#define DISPID_MQEVENTEVENTS_ARRIVED        0
#define DISPID_MQEVENTEVENTS_ARRIVEDERROR   1

// MqTransaction
#define DISPID_MQTRANSACTION_TRANSACTION    0
#define DISPID_MQTRANSACTION_PROPERTIES     1
#define DISPID_MQTRANSACTION_ITRANSACTION   2

// MqApplication
#define DISPID_MQAPPLICATION_PROPERTIES             0
#define DISPID_MQAPPLICATION_MSMQVERSIONMAJOR       1
#define DISPID_MQAPPLICATION_MSMQVERSIONMINOR       2
#define DISPID_MQAPPLICATION_MSMQVERSIONBUILD       3
#define DISPID_MQAPPLICATION_ISDSENABLED            4
#define DISPID_MQAPPLICATION_ACTIVE_QUEUES            5
#define DISPID_MQAPPLICATION_PRIVATE_QUEUES           6
#define DISPID_MQAPPLICATION_DIRECTORY_SERVICE_SERVER 7
#define DISPID_MQAPPLICATION_IS_CONNECTED             8
#define DISPID_MQAPPLICATION_BYTES_IN_ALL_QUEUES      9
#define DISPID_MQAPPLICATION_MACHINE                  10

// MqQuery
#define DISPID_MQQUERY_PROPERTIES           0

// MqEvent
#define DISPID_MQEVENT_PROPERTIES           0

// MqQueueInfos
#define DISPID_MQQUEUEINFOS_PROPERTIES      0

// MqCoordinatedTransactionDispenser
#define DISPID_MQXDISPDTC_PROPERTIES        0

// MqTransactionDispenser
#define DISPID_MQXDISPER_PROPERTIES         0

// MqDestination
#define DISPID_MQDEST_PROPERTIES            0
#define DISPID_MQDEST_ISOPEN                1
#define DISPID_MQDEST_IADS                  2
#define DISPID_MQDEST_ADSPATH               3
#define DISPID_MQDEST_PATHNAME              4
#define DISPID_MQDEST_FORMATNAME            5
#define DISPID_MQDEST_DESTINATIONS          6
#define DISPID_MQDEST_HANDLE                7


// #3844 versions of MSMQ type libraries
// current version
#define MSMQ_LIB_VER_MAJOR 3
#define MSMQ_LIB_VER_MINOR 0
#define MSMQ_LIB_VER 3.0
// msmq 2.0
#define MSMQ20_LIB_VER_MAJOR 2
#define MSMQ20_LIB_VER_MINOR 0
#define MSMQ20_LIB_VER 2.0
// msmq 1.0
#define MSMQ10_LIB_VER_MAJOR 1
#define MSMQ10_LIB_VER_MINOR 0
#define MSMQ10_LIB_VER 1.0

#define _DISPIDS_H_
#endif // _DISPIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\guids.h ===
//=--------------------------------------------------------------------------=
// Guids.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// guids that we define locally
//
#ifndef _GUIDS_H_

//
// This is the libid of MSMQ 1.0/2.0 type library.
// Same value as LIBID_MSMQ, only the versions are different between model upgrades
//
DEFINE_GUID(LIBID_MSMQ10,0xD7D6E071L,0xDCCD,0x11D0,0xAA,0x4B,0x00,0x60,0x97,0x0D,0xEB,0xAE);
DEFINE_GUID(LIBID_MSMQ20,0xD7D6E071L,0xDCCD,0x11D0,0xAA,0x4B,0x00,0x60,0x97,0x0D,0xEB,0xAE);

#define _GUIDS_H_
#endif // _GUIDS_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\event.cpp ===
//=--------------------------------------------------------------------------=
// event.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQEvent object
//
//
#include "stdafx.h"
#include "dispids.h"
#include "oautil.h"
#include "msg.h"
#include "q.h"
#include <autoptr.h>


const MsmqObjType x_ObjectType = eMSMQEvent;

// debug...
#include "debug.h"
#include "debug_thread_id.h"
#include "event.h"

#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#include <stdio.h>

#include "cs.h"
#include <mqmacro.h>
#include <strsafe.h>
#define MY_DISP_ASSERT(fTest, szMsg) { \
         static char szAssert[] = #fTest; \
         DisplayAssert(szMsg, szAssert, __FILE__, __LINE__); }

#define MY_ASSERT1(fTest, szFmt, p1) \
       if (!(fTest))  { \
         char errmsg[200]; \
         StringCchPrintfA(errmsg, TABLE_SIZE(errmsg), szFmt, p1); \
         MY_DISP_ASSERT(fTest, errmsg); \
       }

#define MY_ASSERT2(fTest, szFmt, p1, p2) \
       if (!(fTest))  { \
         char errmsg[200]; \
         StringCchPrintfA(errmsg, TABLE_SIZE(errmsg), szFmt, p1, p2); \
         MY_DISP_ASSERT(fTest, errmsg); \
       }
#endif // _DEBUG

// Used to coordinate user-thread queue ops and 
//  queue lookup in falcon-thread callback 
//
CCriticalSection g_csCallback(CCriticalSection::xAllocateSpinCount);

// window class
extern WNDCLASSA g_wndclassAsyncRcv;
extern ATOM g_atomWndClass;

//=--------------------------------------------------------------------------=
// CMSMQEvent::CMSMQEvent
//=--------------------------------------------------------------------------=
// create the object
//
// Parameters:
//
// Notes:
//#2619 RaananH Multithread async receive
//
CMSMQEvent::CMSMQEvent()
{

    // TODO: initialize anything here

    // Register our "sub-classed" windowproc so that we can
    //  send a message from the Falcon thread to the user's VB
    //  thread in order to fire async events in the correct
    //  context.
    //
    m_hwnd = CreateHiddenWindow();
    DEBUG_THREAD_ID("creating hidden window");
    ASSERTMSG(IsWindow(m_hwnd), "should have a valid window.");
}


//=--------------------------------------------------------------------------=
// CMSMQEvent::~CMSMQEvent
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//#2619 RaananH Multithread async receive
//
CMSMQEvent::~CMSMQEvent ()
{
    // TODO: clean up anything here.

    DestroyHiddenWindow();
	DEBUG_THREAD_ID("Event Destructor");
}


//=--------------------------------------------------------------------------=
// CMSMQEvent::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQEvent::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQEvent3,
		&IID_IMSMQEvent2,
		&IID_IMSMQEvent,
		&IID_IMSMQPrivateEvent,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

    //
    // IMSMQPrivateEvent methods
    //

//=--------------------------------------------------------------------------=
// CMSMQEvent::FireArrivedEvent
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//
// Notes:
HRESULT CMSMQEvent::FireArrivedEvent(
    IMSMQQueue __RPC_FAR *pq,
    long msgcursor)
{
    DEBUG_THREAD_ID("firing Arrived");
    return Fire_Arrived(pq, msgcursor);
}



//=--------------------------------------------------------------------------=
// CMSMQEvent::FireArrivedErrorEvent
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//
// Notes:
HRESULT CMSMQEvent::FireArrivedErrorEvent(
    IMSMQQueue __RPC_FAR *pq,
    HRESULT hrStatus,
    long msgcursor)
{
    DEBUG_THREAD_ID("firing ArrivedError");
    return Fire_ArrivedError(pq, hrStatus, msgcursor);
}


//=--------------------------------------------------------------------------=
// CMSMQEvent::get_Hwnd
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//
// Notes:
//#2619 RaananH Multithread async receive
//
HRESULT CMSMQEvent::get_Hwnd(
    long __RPC_FAR *phwnd)
{
    *phwnd = (long) DWORD_PTR_TO_DWORD(m_hwnd); //safe cast since NT handles are 32 bits also on win64
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// InternalReceiveCallback
//=--------------------------------------------------------------------------=
// Async callback handler.  Runs in Falcon created thread.
// We send message to user thread so that event is fired
//  in correct execution context.
//
// Parameters:
//	hrStatus,
//	hReceiveQueue,
//    	dwTimeout,
//    	dwAction,
//    	pMessageProps,
//    	lpOverlapped,
//    	hCursor
//      MQMSG_CURSOR
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//#2619 RaananH Multithread async receive
//
void APIENTRY InternalReceiveCallback(
    HRESULT hrStatus,
    QUEUEHANDLE hReceiveQueue,
    DWORD /*dwTimeout*/ ,
    DWORD /*dwAction*/ ,
    MQMSGPROPS* pmsgprops,
    LPOVERLAPPED /*lpOverlapped*/ ,
    HANDLE /*hCursor*/ ,
    MQMSGCURSOR msgcursor)
{
    DEBUG_THREAD_ID("callback called");
    // FireEvent...
    // Map handle to associated queue object
    //
    QueueNode * pqnode;
    HWND hwnd;
    BOOL fPostSucceeded;

    ASSERTMSG(pmsgprops == NULL, "received props in callback !"); //#2619
    UNREFERENCED_PARAMETER(pmsgprops);

    //
    // UNDONE: 905: decrement dll refcount that we incremented
    //  when we registered the callback.
    //
    CS lock(g_csCallback);      // syncs other queue ops

	pqnode = CMSMQQueue::PqnodeOfHandle(hReceiveQueue);
    
	// if no queue, then ignore the callback otherwise
	//  if the queue is open and it has a window
	//  then send message to user-thread that will
	//  trigger event firing.
	//
	if (pqnode) {
		//
		// 1884: allow event handler to reenable notifications
		//
		hwnd = pqnode->m_hwnd;
		ASSERTMSG(hwnd, "in callback but no active handler");
		pqnode->m_hwnd = NULL;
		if (IsWindow(hwnd)) {
		  //
		  // #4092: get an unused window message
		  // Note that we are currently locking the qnode so it is safe to call GetFreeWinmsg -
		  // we are in a critical section (locked by g_csCallback)
		  //
		  WindowsMessage *pWinmsg = pqnode->GetFreeWinmsg();
		  ASSERTMSG(pWinmsg != NULL, "Couldn't get a free winmsg");
		  if (pWinmsg != NULL) {
			//
			// 1212: In principle, need to special case BUFFER_OVERFLOW
			//  by growing buffer and synchronously peeking...
			//  but since it's the user's responsibility to 
			//  receive the actual message, we'll just let our
			//  usual InternalReceive handling deal with the
			//  overflow...
			//
			//
			// 1900: pass msgcursor to event handler 
			//
			pWinmsg->m_msgcursor = msgcursor;
			ASSERTMSG(hrStatus != MQ_ERROR_BUFFER_OVERFLOW, "unexpected buffer overflow!");
			if (SUCCEEDED(hrStatus)) {
			  //
			  // Since we are in a Falcon created callback thread,
			  //  send a message to the user thread to trigger
			  //  event firing...
			  // UNDONE: need to register unique Windows message.
			  // Bug 1430: need to use PostMessage instead of
			  //  SendMessage otherwise get RPC_E_CANCALLOUT_ININPUTSYNCCALL
			  //  when attempting to call to exe (only?) server like
			  //  Excel in user-defined event handler.
			  ASSERTMSG(g_uiMsgidArrived != 0, "g_uiMsgidArrived == 0"); //sanity
			  DEBUG_THREAD_ID("in callback before post Arrived");
			  fPostSucceeded = PostMessageA(hwnd, 
									  g_uiMsgidArrived, 
									  (WPARAM)hReceiveQueue, 
									  (LPARAM)pWinmsg);
			  DEBUG_THREAD_ID("in callback after post Arrived");
			  ASSERTMSG(fPostSucceeded, "PostMessage(Arrived) failed.");
			}
			else {
			  pWinmsg->m_hrStatus = hrStatus;
			  ASSERTMSG(g_uiMsgidArrivedError != 0, "g_uiMsgidArrivedError == 0"); //sanity
			  DEBUG_THREAD_ID("in callback before post ArrivedError");
			  fPostSucceeded = PostMessageA(hwnd, 
									  g_uiMsgidArrivedError, 
									  (WPARAM)hReceiveQueue, 
									  (LPARAM)pWinmsg);
			  DEBUG_THREAD_ID("in callback after post ArrivedError");
			  ASSERTMSG(fPostSucceeded, "PostMessage(ArrivedError) failed.");
			}
		  } // if pWinmsg != NULL
		} // if IsWindow
	} // pqnode

    return;
}


//=--------------------------------------------------------------------------=
// ReceiveCallback, ReceiveCallbackCurrent, ReceiveCallbackNext
//=--------------------------------------------------------------------------=
// Async callback handler.  Runs in Falcon created thread.
// We send message to user thread so that event is fired
//  in correct execution context.
// NOTE: no cursor
//
// Parameters:
//	hrStatus,
//	hReceiveQueue,
//    	dwTimeout,
//    	dwAction,
//    	pMessageProps,
//    	lpOverlapped,
//    	hCursor
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
void APIENTRY ReceiveCallback(
    HRESULT hrStatus,
    QUEUEHANDLE hReceiveQueue,
    DWORD dwTimeout,
    DWORD dwAction,
    MQMSGPROPS* pmsgprops,
    LPOVERLAPPED lpOverlapped,
    HANDLE /*hCursor*/ )
{
    InternalReceiveCallback(
      hrStatus,
      hReceiveQueue,
      dwTimeout,
      dwAction,
      pmsgprops,
      lpOverlapped,
      0,               // no cursor
      MQMSG_FIRST
    );
}


void APIENTRY ReceiveCallbackCurrent(
    HRESULT hrStatus,
    QUEUEHANDLE hReceiveQueue,
    DWORD dwTimeout,
    DWORD dwAction,
    MQMSGPROPS* pmsgprops,
    LPOVERLAPPED lpOverlapped,
    HANDLE hCursor)
{
    InternalReceiveCallback(
      hrStatus,
      hReceiveQueue,
      dwTimeout,
      dwAction,
      pmsgprops,
      lpOverlapped,
      hCursor,
      MQMSG_CURRENT
    );
}


void APIENTRY ReceiveCallbackNext(
    HRESULT hrStatus,
    QUEUEHANDLE hReceiveQueue,
    DWORD dwTimeout,
    DWORD dwAction,
    MQMSGPROPS* pmsgprops,
    LPOVERLAPPED lpOverlapped,
    HANDLE hCursor)
{
    InternalReceiveCallback(
      hrStatus,
      hReceiveQueue,
      dwTimeout,
      dwAction,
      pmsgprops,
      lpOverlapped,
      hCursor,
      MQMSG_NEXT
    );
}


//=--------------------------------------------------------------------------=
// global CMSMQEvent_WindowProc
//=--------------------------------------------------------------------------=
// "derived" windowproc so that we can process our async event
//   msg.  This is a nop if notification has been disabled.
//
// Parameters:
//  hwnd
//  msg         we can handle Arrived/ArrivedError
//  wParam      QUEUEHANDLE: hReceiveQueue
//  lParam      [lErrorCode]:
//              lErrorCode: if ArrivedError
//
// Output:
//    LRESULT
//
// Notes:
//#2619 RaananH Multithread async receive
//
LRESULT APIENTRY CMSMQEvent_WindowProc(
    HWND hwnd, 
    UINT msg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    QueueNode *pqnode;
    HRESULT hresult;
    R<IMSMQQueue> pq;
	WindowsMessage winmsg;

    if((msg != g_uiMsgidArrived) && (msg != g_uiMsgidArrivedError)) 
		return DefWindowProcA(hwnd, msg, wParam, lParam);	

	DEBUG_THREAD_ID("winproc called");
	//
	// Need to revalidate incoming hReceiveQueue by
	//  lookup up (again) in queue list -- it might
	//  have been deleted already since we previously
	//  looked it up in another thread (falcon-created
	//  callback thread).
	//
	{
		CS lock(g_csCallback);      // syncs other queue ops

		pqnode = CMSMQQueue::PqnodeOfHandle((QUEUEHANDLE)wParam);
		if(!pqnode) 
			return 0;

		//
		// #4092: consume winmsg and free it
		// Note that we are currently locking the qnode so it is safe to call FreeWinmsg -
		// we are in a critical section (locked by g_csCallback)
		//
		WindowsMessage * pWinmsg = (WindowsMessage *)lParam;
		ASSERTMSG(!pWinmsg->m_fIsFree, "received a free winmsg");
		winmsg = *pWinmsg;
		pqnode->FreeWinmsg(pWinmsg);
		//
		//  we exit critsect now so that we don't deadlock with user closing queue or
		//  getting event in user thread.
		//
		// But before we exit critsect, we QI for IMSMQQueue to pass to the event handler.
		// This will also force it to stay alive while the handler is running.
		// We can use m_pq from here since now m_pq is Thread-Safe.
		//
		hresult = pqnode->m_pq->GetUnknown()->QueryInterface(IID_IMSMQQueue, (void **)&pq.ref());
		ASSERTMSG(SUCCEEDED(hresult), "QI for IMSMQQueue on CMSMQQueue failed");		
		if(FAILED(hresult)) 
			return 0;
	}

	//
	// get a pointer to the event object that created this window from the
	// window's extra bytes
	//
	CMSMQEvent * pCEvent = (CMSMQEvent *) GetWindowLongPtr(hwnd, 0);
	ASSERTMSG(pCEvent != NULL, "pCEvent from window is NULL");
	if(pCEvent == NULL)
		return 0;

	//
	// fire event.
	//
	// this window procedure is now executed by the STA thread of the event obj (because
	// the window was created on that thread) therefore we can call the event object
	// directly without going through marshalling and interfaces
	//
	if(msg == g_uiMsgidArrived)
	{
		pCEvent->FireArrivedEvent(
					pq.get(),
					(long)winmsg.m_msgcursor
					);
	}
	else 
	{
		pCEvent->FireArrivedErrorEvent(
					pq.get(),
					(long)winmsg.m_hrStatus,
					(long)winmsg.m_msgcursor
					);
	}

	return 0;
}


//=--------------------------------------------------------------------------=
// CMSMQEvent::CreateHiddenWindow
//=--------------------------------------------------------------------------=
// creates a per-instance hidden window that is used for inter-thread
//  messaging from the Falcon async thread and the user thread.
//
// Parameters:
//
// Output:
//
// Notes:
//#2619 RaananH Multithread async receive
//
HWND CMSMQEvent::CreateHiddenWindow()
{
    HWND hwnd;
    LPCSTR lpClassName;

    lpClassName = (LPCSTR)g_atomWndClass;
    // can use ANSI version
    hwnd  = CreateWindowA(
              // (LPCSTR)g_wndclassAsyncRcv.lpszClassName,
              lpClassName,
              "EventWindow",
              WS_DISABLED,
              CW_USEDEFAULT,
              CW_USEDEFAULT,
              CW_USEDEFAULT,
              CW_USEDEFAULT,
              NULL,	// handle to parent or owner window
              NULL,	// handle to menu or child-window identifier
              g_wndclassAsyncRcv.hInstance,
              NULL      // pointer to window-creation data
            );	
    //
    // save a pointer to the event object that created the window in the window's extra bytes
    //
    // NOTE: We MUST NOT addref the event object here when we save a reference to it in the window's
    // data since the event object (and only the event object) controls the windows lifetime,
    // so if we addref here, the event object will never get to zero refcount threfore will never
    // be released
    //
    if (hwnd != NULL)
    {
#ifdef _DEBUG
        SetLastError(0);
        LONG_PTR dwOldVal = SetWindowLongPtr(hwnd, 0, (LONG_PTR)this);
        if (dwOldVal == 0)
        {
          DWORD dwErr = GetLastError();
          ASSERTMSG(dwErr == 0, "SetWindowLongPtr returned an error.");
        }
#else // not _DEBUG
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)this);
#endif //_DEBUG
    }

#ifdef _DEBUG
    m_dwDebugTid = GetCurrentThreadId();
    DWORD dwErr;
    if (hwnd == 0) {
      dwErr = GetLastError();
      ASSERTMSG(dwErr == 0, "CreateWindow returned an error.");
    }
#endif // _DEBUG

    return hwnd;
}


//=--------------------------------------------------------------------------=
// CMSMQEvent::DestroyHiddenWindow
//=--------------------------------------------------------------------------=
// destroys per-class hidden window that is used for inter-thread
//  messaging from the Falcon async thread and the user thread.
//
// Parameters:
//
// Output:
//
// Notes:
//#2619 RaananH Multithread async receive
//
void CMSMQEvent::DestroyHiddenWindow()
{
    ASSERTMSG(m_hwnd != 0, "should have a window handle.");
    if (IsWindow(m_hwnd)) {
      BOOL fDestroyed;
      //
      // NOTE: We don't release the event object in the window's data since we never
      // addref'ed it when setting the window's data. The reason we didn't addref it is that
      // if we did, the event object would never get to zero refcount becuase it controls
      // the life time of the window.
      //
	  SetWindowLongPtr(m_hwnd, 0, (LONG_PTR)NULL);
	  SetWindowPos(m_hwnd, 0,0,0,0,0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOMOVE | SWP_FRAMECHANGED);
      fDestroyed = DestroyWindow(m_hwnd);
#ifdef _DEBUG
      if (fDestroyed == FALSE) {
        DWORD dwErr = GetLastError();
        DWORD dwTid = GetCurrentThreadId();
        MY_ASSERT2(m_dwDebugTid == dwTid, "thread (%lx) destroying window created by thread (%lx)", dwTid, m_dwDebugTid);
        MY_ASSERT1(0, "hmm... couldn't destroy window (%lx).", dwErr);
      }
#endif // _DEBUG
    }
    m_hwnd = NULL;
}


//=-------------------------------------------------------------------------=
// CMSMQEvent::get_Properties
//=-------------------------------------------------------------------------=
// Gets object's properties collection
//
// Parameters:
//    ppcolProperties - [out] object's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQEvent::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, it is an apartment threaded object.
    // CS lock(m_csObj);
    //
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\eod_info.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corparation
Module Name:
    eod_info.cpp

Abstract:
    Helper functions for CMSMQManagement::GetEodSendInfo and CMSMQManagement::GetEodReceiveInfo .

Author:
    Uri Ben-zeev (uribz) 16-jul-01

Envierment: 
    NT
--*/

#include "stdafx.h"
#include "oautil.h"
#include "collection.h"
#include "management.h"
#include <mqmacro.h>
#include <mqexception.h>


//
// Functions to add members to the collection.
//

static 
void 
SequenceInfoToICollection(
                const BLOB& blob, 
                IMSMQCollection** ppICollection
                )
{
    CComObject<CMSMQCollection> *pInnerCollection;
    HRESULT hr = CNewMsmqObj<CMSMQCollection>::NewObj(
                    &pInnerCollection, 
                    &IID_IMSMQCollection, 
                    (IUnknown **)ppICollection
                    );
    if(FAILED(hr))
    {
        throw bad_hresult(hr);
    }
    
    SEQUENCE_INFO* psi = reinterpret_cast<SEQUENCE_INFO*>(blob.pBlobData);
    VARIANT var;
    var.vt = VT_UI8;
    var.ullVal = psi->SeqID;
    pInnerCollection->Add(L"SeqID", var);

    var.vt = VT_UI4;
    var.ulVal = psi->SeqNo;
    pInnerCollection->Add(L"SeqNo", var);

    var.vt = VT_UI4;
    var.ulVal = psi->PrevNo;
    pInnerCollection->Add(L"PrevNo", var);
}


static 
void 
AddBlob(
    const MQPROPVARIANT& mqp, 
    LPCWSTR strKey,
    CMSMQCollection* pCollection
    )
{
    VARIANT var;
    if(mqp.vt == VT_NULL)
    {
		var.pdispVal = NULL;    
    }
    else
    {
        ASSERTMSG(mqp.vt == VT_BLOB, "vt must be VT_BLOB");

		//
		// Create an MSMQCollection object, and add values from blob.
		//
		IMSMQCollection* pInnerICollection;
        SequenceInfoToICollection(mqp.blob, &pInnerICollection);
		var.pdispVal = pInnerICollection;
    }

    var.vt = VT_DISPATCH;
    pCollection->Add(strKey, var);
}


static 
void 
AddInt(
    const MQPROPVARIANT& mqp, 
    LPCWSTR strKey, 
    CMSMQCollection* pCollection
    ) 
{
	ASSERTMSG((mqp.vt == VT_UI4) || (mqp.vt == VT_I4) || (mqp.vt == VT_NULL), "vt must be VT_UI4 or VT_I4 or VT_NULL"); 

    VARIANT var;
    
    switch(mqp.vt)
    {
	case VT_NULL:
		var.vt = VT_I4;
		var.lVal = 0;
		break;
	case VT_I4:
		var.vt = VT_I4;
		var.lVal = mqp.lVal;
		break;
	case VT_UI4:
		var.vt = VT_UI4;
		var.ulVal = mqp.ulVal;
		break;
	default:
		ASSERTMSG((mqp.vt == VT_UI4) || (mqp.vt == VT_I4) || (mqp.vt == VT_NULL), "vt must be VT_UI4 or VT_I4 or VT_NULL"); 
		break;
    }
    
	pCollection->Add(strKey, var);
}


//
// Table maping PROPID, AddFunction and string used as key
// 

typedef void (*AddFunction)(const MQPROPVARIANT&, LPCWSTR, CMSMQCollection*);

struct PropEntry
{
    MGMTPROPID PropId;
    AddFunction add;
    LPCWSTR key;
};


PropEntry g_aEntries[] = 
{
    {PROPID_MGMT_QUEUE_EOD_LAST_ACK,        &AddBlob,   L"EodLastAck"},
    {PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME,   &AddInt,   L"EodLastAckTime" },
    {PROPID_MGMT_QUEUE_EOD_LAST_ACK_COUNT,  &AddInt,   L"EodLastAckCount"},
    {PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK,   &AddBlob,   L"EodFirstNonAck"},
    {PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK,    &AddBlob,   L"EodLastNonAck"},
    {PROPID_MGMT_QUEUE_EOD_NEXT_SEQ,        &AddBlob,   L"EodNextSeq"},
    {PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT,   &AddInt,   L"EodNoReadCount"},
    {PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT,    &AddInt,   L"EodNoAckCount"},
    {PROPID_MGMT_QUEUE_EOD_RESEND_TIME,     &AddInt,   L"EodResendTime"},
    {PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL, &AddInt,   L"EodResendInterval"},
    {PROPID_MGMT_QUEUE_EOD_RESEND_COUNT,    &AddInt,   L"EodResendCount"},
};


const int g_cProps = TABLE_SIZE(g_aEntries);
  

//
// Main helper function for EodGetSendInfo.
//

void 
CMSMQManagement::OapEodGetSendInfo(
                        IMSMQCollection** ppICollection
                        )const
{
    //
    // Construct an array of PROP_IDs 
    //
    
    MGMTPROPID aPropId[g_cProps];
    for(UINT i = 0; i < g_cProps; ++i)
    {
        aPropId[i] = g_aEntries[i].PropId;   
    }

    //
    // Construct a MQMGMTPROPS structure, fill in prop IDs and query RT.
    //
    CPMQMgmtProps pMgmtProps;
    MQPROPVARIANT aPropVar[g_cProps];
    pMgmtProps->cProp = g_cProps;
    pMgmtProps->aPropID = aPropId;
    pMgmtProps->aPropVar = aPropVar;
    pMgmtProps->aStatus = NULL;
    HRESULT hr = MQMgmtGetInfo(m_Machine, m_ObjectName, pMgmtProps);
    if(FAILED(hr))
    {
        throw bad_hresult(hr);
    }
    //
    // Create an MSMQCollection object.
    //
    CComObject<CMSMQCollection>* pCollection;
    hr = CNewMsmqObj<CMSMQCollection>::NewObj(
                    &pCollection, 
                    &IID_IMSMQCollection, 
                    (IUnknown **)ppICollection
                    );
    if(FAILED(hr))
    {
        throw bad_hresult(hr);
    }

    //
    // Fill the collection.
    //
    for(i = 0; i < g_cProps; ++i)
    {
        g_aEntries[i].add(
                (pMgmtProps->aPropVar)[i], 
                g_aEntries[i].key, 
                pCollection
                );
    }
}


//
// Helper functions for ReceiveInfo. 
// These function add elements to a collection.
//

static 
void
AddStr(
    LPCWSTR str, 
    LPCWSTR strKey, 
    CMSMQCollection* pCollection
    )
{
    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(str);
    if((var.bstrVal == NULL) && (str != NULL))
    {
        throw bad_hresult(E_OUTOFMEMORY);
    }

    pCollection->Add(strKey, var);
}


static 
void
AddClsid(
    GUID& guid, 
    LPCWSTR strKey, 
    CMSMQCollection* pCollection
    )
{
    VARIANT var;
    var.vt = VT_BSTR;
    HRESULT hr = GetBstrFromGuid(&guid, &(var.bstrVal));
    if(FAILED(hr))
    {
        throw bad_hresult(hr);
    }

    pCollection->Add(strKey, var);
}


static 
void
AddULongLong(
        ULONGLONG num, 
        LPCWSTR strKey, 
        CMSMQCollection* pCollection
        )
{
    VARIANT var;
    var.vt = VT_UI8;
    var.llVal = num;
    pCollection->Add(strKey, var);
}


static 
void
AddLong(
    LONG num, 
    LPCWSTR strKey, 
    CMSMQCollection* pCollection
    )
{
    VARIANT var;
    var.vt = VT_I4;
    var.lVal = num;
    pCollection->Add(strKey, var);
}


static
void
PutEmptyArrayInVariant(
	VARIANT* pvGetInfo
	)
{


	VariantInit(pvGetInfo);
	pvGetInfo->vt = VT_ARRAY|VT_VARIANT;

    SAFEARRAYBOUND bounds = {0, 0};
    SAFEARRAY* pSA = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    if(pSA == NULL)
    {
        throw bad_hresult(E_OUTOFMEMORY);
    }

	pvGetInfo->parray = pSA;
}


//
// Main helper function for ReceiveInfo.
//
static 
void
EodParseReceiveInfo(
			const MQPROPVARIANT* pPropVariant,
            VARIANT* pvGetInfo
            )
{
	if(pPropVariant->vt == VT_NULL)
	{
		//
		// Return an empty array.
		//
		PutEmptyArrayInVariant(pvGetInfo);
		return;
	}

	const CAPROPVARIANT& aPropVar = pPropVariant->capropvar; 
    PROPVARIANT* pVar = aPropVar.pElems;
    ULONG cQueues = (pVar->calpwstr).cElems;

    //
    // Construct a Safe Array to return to caller.
    //
    SAFEARRAYBOUND bounds = {cQueues, 0};
    SAFEARRAY* pSA = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    if(pSA == NULL)
    {
        throw bad_hresult(E_OUTOFMEMORY);
    }

    VARIANT HUGEP* aVar;
    HRESULT hr = SafeArrayAccessData(pSA, reinterpret_cast<void**>(&aVar));
    if (FAILED(hr))
    {
        throw bad_hresult(hr);
    }

    for (ULONG i = 0; i < cQueues; ++i)
    {
        pVar = aPropVar.pElems;

        //
        // Create a new MSMQCollection, fill it and add it to the SafeArray.
        //
        IMSMQCollection* pICollection;
        CComObject<CMSMQCollection>* pCollection;
        hr = CNewMsmqObj<CMSMQCollection>::NewObj(
                        &pCollection, 
                        &IID_IMSMQCollection, 
                        (IUnknown **)&pICollection
                        );
        if(FAILED(hr))
        {
            throw bad_hresult(hr);
        }
        
        //
        // Return the format name
        //
        AddStr((pVar->calpwstr).pElems[i], L"QueueFormatName", pCollection);
        ++pVar;

        AddClsid((pVar->cauuid).pElems[i], L"SenderID", pCollection);
        ++pVar;

        AddULongLong(((pVar->cauh).pElems[i]).QuadPart, L"SeqID", pCollection);
        ++pVar;

        AddLong(pVar->caul.pElems[i], L"SeqNo", pCollection);
        ++pVar;

        AddLong(pVar->cal.pElems[i], L"LastAccessTime", pCollection);
        ++pVar;

        AddLong(pVar->caul.pElems[i], L"RejectCount", pCollection);
        
        aVar[i].vt = VT_DISPATCH;
        aVar[i].pdispVal = pICollection;
    }
    
    hr = SafeArrayUnaccessData(pSA);
    ASSERTMSG(SUCCEEDED(hr), "SafeArrayUnaccessData must succeed!");

    VariantInit(pvGetInfo);
    pvGetInfo->vt = VT_ARRAY|VT_VARIANT;
    pvGetInfo->parray = pSA;
}


void CMSMQManagement::OapEodGetReceiveInfo(VARIANT* pvGetInfo)const
{
    CPMQVariant pPropVar;
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_QUEUE_EOD_SOURCE_INFO, pPropVar);
    if(FAILED(hr))
    {
       throw bad_hresult(hr);
    }
    
    EodParseReceiveInfo(pPropVar, pvGetInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\guids.cpp ===
//=--------------------------------------------------------------------------=
// Guids.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the guids we will define ourselves.
//


#include "stdafx.H"
#include "initguid.h"           // define all the guids.

#include "Guids.H"
#include "olectl.h"

#include "mqoai.H"
#include "txdtc.h"             // transaction support.
#include "mtxdm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\event.h ===
//=--------------------------------------------------------------------------=
// event.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQEvent object.
//
//
#ifndef _MSMQEvent_H_

#include "resrc1.h"       // main symbols
#include "mq.h"

#include "oautil.h"
#include "event2.h" //CProxy_DMSMQEventEvents

// forwards
class CMSMQEvent;

LRESULT APIENTRY CMSMQEvent_WindowProc(
                     HWND hwnd, 
                     UINT msg, 
                     WPARAM wParam, 
                     LPARAM lParam);

// #4110, #3687
// We changed all MSMQ objects to be Both-threaded and incorporate
// the Free-Threaded-marshaler, EXCEPT for the MSMQEvent object, which stays
// as apartment model.
// The reason is AsyncRcv performance in the typical case of a VB app.
// The way we currently do AsyncReceive is to post a windows message from the falcon
// callback thread to the window that the MSMQEvent object created, and let the window
// procedure (in the correct thread) handle the firing of the event.
// We are certain that there is a message loop and that our window proc will be
// called because the object is apartment threaded, and it runs in an STA and
// COM STA's must have a message loop.
// If we were to change the Event object to Both-Threaded, we wouldn't be able
// to keep this mechanism, since the Event could have been created in an MTA thread
// that may not have a window-message loop.
// We could change the mechanism, and instead of posting window to a message, we
// could directly call the sink from the falcon callback, however this requires
// the Falcon callback to initialize COM (which it doesn't, and for compatibility reasons
// it is not safe to add that to it), and call the sink through a marshaled interface
// and in the case of a VB sink (STA) it is much slower than the mechanism we use now.
// We could also do it by creating our own thread and use completion ports, but
// we'll have problems creating and terminating thread(s) in a COM inproc server
// since we can't export functions that users can call to init/deinit the dll (which is
// the safe way to go if creating threads inside a dll. RaananH, May 2nd, 1999.
//

//#2619 RaananH Multithread async receive
//#2174 Added IProvideClassInfo(2) support so that IE page could do async receive
class ATL_NO_VTABLE CMSMQEvent : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSMQEvent, &CLSID_MSMQEvent>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CMSMQEvent>,
	public CProxy_DMSMQEventEvents<CMSMQEvent>,
	public IDispatchImpl<IMSMQEvent3, &IID_IMSMQEvent3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>,
	public IDispatchImpl<IMSMQPrivateEvent, &IID_IMSMQPrivateEvent,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>,
	public IProvideClassInfo2Impl<&CLSID_MSMQEvent, &DIID__DMSMQEventEvents,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQEvent();

#ifdef _DEBUG
    STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie)
    {
      DEBUG_THREAD_ID("Advise called");
      //DebugBreak();
      return CProxy_DMSMQEventEvents<CMSMQEvent>::Advise(pUnkSink, pdwCookie);
    }
#endif //_DEBUG

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQEVENT)

BEGIN_COM_MAP(CMSMQEvent)
	COM_INTERFACE_ENTRY(IMSMQEvent3)
	COM_INTERFACE_ENTRY(IMSMQEvent2)
	COM_INTERFACE_ENTRY(IMSMQEvent)
	COM_INTERFACE_ENTRY(IMSMQPrivateEvent)
	COM_INTERFACE_ENTRY2(IDispatch, IMSMQEvent2)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSMQEvent)
   CONNECTION_POINT_ENTRY(DIID__DMSMQEventEvents)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQEvent
public:
    virtual ~CMSMQEvent();

    // IMSMQEvent methods
    // TODO: copy over the interface methods for IMSMQEvent from
    //       mqInterfaces.H here.
    // IMSMQEvent2 additional members
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);

    // IMSMQPrivateEvent properties
    virtual HRESULT STDMETHODCALLTYPE get_Hwnd(long __RPC_FAR *phwnd); //#2619

     // IMSMQPrivateEvent methods
     virtual HRESULT STDMETHODCALLTYPE FireArrivedEvent( 
         IMSMQQueue __RPC_FAR *pq,
         long msgcursor);
     
     virtual HRESULT STDMETHODCALLTYPE FireArrivedErrorEvent( 
         IMSMQQueue __RPC_FAR *pq,
         HRESULT hrStatus,
         long msgcursor);


    // introduced methods
    //
    // Critical section to guard object's data and be thread safe
    //
    // Serialization not needed for this object, it is an apartment threaded object.
    // CCriticalSection m_csObj;
    //
    
protected:

private:
    // member variables that nobody else gets to look at.
    // TODO: add your member variables and private functions here.

    // per-instance hwnd
    HWND m_hwnd;

#ifdef _DEBUG
    DWORD m_dwDebugTid;
#endif

public:
    HWND CreateHiddenWindow();
    void DestroyHiddenWindow();
};


#define _MSMQEvent_H_
#endif // _MSMQEvent_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\event2.h ===
#include <mqmacro.h>

//////////////////////////////////////////////////////////////////////////////
// CProxy_DMSMQEventEvents
template <class T>
class CProxy_DMSMQEventEvents : public IConnectionPointImpl<T, &DIID__DMSMQEventEvents, CComDynamicUnkArray>
{
public:
//methods:
//_DMSMQEventEvents : IDispatch
public:
	HRESULT
	Fire_Arrived(
		IDispatch * Queue,
		long Cursor
		)
	{
		AP<VARIANTARG> pvars = new VARIANTARG[2];
		if(pvars == NULL)
		{
			return E_OUTOFMEMORY;
		}
		for (int i = 0; i < 2; i++)
		{
			VariantInit(&pvars[i]);
		}
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[1].vt = VT_DISPATCH;
				pvars[1].pdispVal= Queue;
				pvars[0].vt = VT_I4;
				pvars[0].lVal= Cursor;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				R<IDispatch> pDispatch;
				HRESULT hr = (*pp)->QueryInterface(IID_IDispatch, (void**)&(pDispatch.ref()));
				DBG_USED(hr);
				ASSERT(SUCCEEDED(hr));
				hr = pDispatch->Invoke(
						0x0, 
						IID_NULL, 
						LOCALE_USER_DEFAULT, 
						DISPATCH_METHOD, 
						&disp, 
						NULL, 
						NULL, 
						NULL
						);
				ASSERT(SUCCEEDED(hr));
			}
			pp++;
		}
		pT->Unlock();
		return MQ_OK;
	}


	HRESULT
	Fire_ArrivedError(
		IDispatch * Queue,
		long ErrorCode,
		long Cursor)
	{
		AP<VARIANTARG> pvars = new VARIANTARG[3];
		if(pvars == NULL)
		{
			return E_OUTOFMEMORY;
		}
		for (int i = 0; i < 3; i++)
		{
			VariantInit(&pvars[i]);
		}
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[2].vt = VT_DISPATCH;
				pvars[2].pdispVal= Queue;
				pvars[1].vt = VT_I4;
				pvars[1].lVal= ErrorCode;
				pvars[0].vt = VT_I4;
				pvars[0].lVal= Cursor;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				R<IDispatch> pDispatch;
				HRESULT hr = (*pp)->QueryInterface(IID_IDispatch, (void**)&(pDispatch.ref()));
				DBG_USED(hr);
				ASSERT(SUCCEEDED(hr));
				pDispatch->Invoke(
					0x1, 
					IID_NULL, 
					LOCALE_USER_DEFAULT, 
					DISPATCH_METHOD, 
					&disp, 
					NULL, 
					NULL, 
					NULL
					);
			}
			pp++;
		}
		pT->Unlock();
		return MQ_OK;
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\ilock.cpp ===
//--------------------------------------------------------------------------=
// ilock.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// Implementation of ILockBytes on memory which uses a chain of variable sized
// blocks
//
#include "stdafx.h"
#include "ilock.h"
// needed for ASSERTs and FAIL
//
#include "debug.h"

#include "mq.h"


//
// min allocation size starts from 256 bytes, and doubles until it reaches 256K
//
const ULONG x_ulStartMinAlloc = 256;
const ULONG x_cMaxAllocIncrements = 10; // up to 256*1024 (1024 == 2^10). must fit in a ULONG;


//=--------------------------------------------------------------------------=
// HELPER: WriteInBlocks
//=--------------------------------------------------------------------------=
// Given a starting block and an offset in this block (e.g. location in chain), write
// a given number of bytes to the chain starting from the starting location (e.g. first
// byte is written on the starting location.
// The blocks chain should already be allocated to contain the new data, so we shouldn't
// get past eof when writing.
//
// Parameters:
//     pBlockStart     [in]  - strating block
//     ulInBlockStart  [in]  - offset in starting block
//     pbData          [in]  - buffer to write (can be NULL if number of bytes is 0)
//     cbData          [in]  - number of bytes to write (can be 0)
//
// Output:
//
// Notes:
//
void WriteInBlocks(CMyMemNode * pBlockStart,
                   ULONG ulInBlockStart,
                   BYTE * pbData,
                   ULONG cbData)
{
    //
    // we get to this function only when the chains are already allocated for the new data
    // so we shouldn't fail.
    //
    // we can get here also for writing zero bytes
    // in this case we exit quickly (performance), and don't check input since the starting
    // location can be NULL if the chains are empty
    //
    if (cbData == 0)
    {
        return;
    }
    //
    // cbData > 0, there is a real write
    // prepare to write loop 
    //
    ULONG ulYetToWrite = cbData;
    BYTE * pbYetToWrite = pbData;
    CMyMemNode * pBlock = pBlockStart;
    ULONG ulInBlock = ulInBlockStart;
    //
    // write as long as there is a need
    //
    while (ulYetToWrite > 0)
    {
        //
        // if we have anything to write, then the chains should be ready to accept it
        // since we already allocated space for this write
        //
        ASSERTMSG(pBlock != NULL, "");
        ASSERTMSG(pBlock->cbSize > ulInBlock, ""); // offset is always smaller than block size
        //
        // compute how many bytes to write in this block
        //
        ULONG ulAllowedWriteInThisBlock = pBlock->cbSize - ulInBlock;
        ASSERTMSG(ulAllowedWriteInThisBlock > 0, ""); // since pBlock->cbSize always > ulInBlock
        //
        // ulAllowedWriteInThisBlock is not fully correct incase this is the last block
        // since we need to deduct the spare bytes. however, since we make sure
        // we call WriteInBlocks only when the blocks are allocated to accept
        // the data, we're OK, and we are guaranteed to never get into the spare
        // bytes
        //
        ULONG ulToWrite = Min1(ulYetToWrite, ulAllowedWriteInThisBlock);
        ASSERTMSG(ulToWrite > 0, ""); // since both ulYetToWrite and ulAllowedWriteInThisBlock > 0
        //
        // do the write in the block
        //
        BYTE * pbDest = ((BYTE *)pBlock) + sizeof(CMyMemNode) + ulInBlock;
        memcpy(pbDest, pbYetToWrite, ulToWrite);
        //
        // adjust data values to reflect what was written
        //
        pbYetToWrite += ulToWrite;
        ulYetToWrite -= ulToWrite;
        //
        // advance to next block if needed
        //
        if (ulYetToWrite > 0)
        {
            //
            // need to advance past this block
            // move to the beginning of next block
            //
            pBlock = pBlock->pNext;
            ulInBlock = 0;
        }
    } // while (ulYetToWrite > 0)
}


//=--------------------------------------------------------------------------=
// CMyLockBytes::DeleteBlocks
//=--------------------------------------------------------------------------=
// Deletes a chain of blocks starting from a given block (that is deleted as well)
//
// Parameters:
//    pBlockHead   [in] - head of chain to delete
//
// Output:
//
// Notes:
//
void CMyLockBytes::DeleteBlocks(CMyMemNode * pBlockHead)
{
    CMyMemNode * pBlock = pBlockHead;
    while (pBlock != NULL)
    {
        CMyMemNode * pNextBlock = pBlock->pNext;
        delete pBlock;
        pBlock = pNextBlock;
        //
        // update number of blocks
        //
        ASSERTMSG(m_cBlocks > 0, "");
        m_cBlocks--;
    }
}


//=--------------------------------------------------------------------------=
// CMyLockBytes::IsInSpareBytes
//=--------------------------------------------------------------------------=
// Given a block and an offset in the block, decides whether we are in the spare bytes
// (e.g. past the logical eof)
//
// Parameters:
//    pBlock    [in] - block
//    ulInBlock [in] - offset in block
//
// Output:
//    whether we are past the logical eof (e.g. in spare bytes of the last block)
//
// Notes:
//
BOOL CMyLockBytes::IsInSpareBytes(CMyMemNode * pBlock, ULONG ulInBlock)
{
    //
    // NULL reference can't be in spare bytes
    //
    if (pBlock == NULL)
    {
        return FALSE;
    }
    //
    // if this is not the last block, can't be in spare bytes
    //
    if (pBlock != m_pLastBlock)
    {
        return FALSE;
    }
    //
    // pBlock == m_pLastBlock, we're in last block
    // if block offset is before the logical end of block we're not in spare bytes
    //
    ASSERTMSG(pBlock->cbSize - m_ulUnusedInLastBlock > 0, ""); // we can't have a block totally unused
    if (ulInBlock < pBlock->cbSize - m_ulUnusedInLastBlock)
    {
        return FALSE;
    }
    //
    // we're in spare bytes
    //
    return TRUE;
}


//=--------------------------------------------------------------------------=
// CMyLockBytes::AdvanceInBlocks
//=--------------------------------------------------------------------------=
// Given a starting block and an offset in this block (e.g. location in chain), finds
// a location which is a given number of bytes after the starting location. It can also return
// pointer to the block which is just before the block that contains the end location
//
// Parameters:
//     pBlockStart     [in]  - strating block
//     ulInBlockStart  [in]  - offset in starting block
//     ullAdvance      [in]  - number of bytes to advance (can be 0 bytes)
//     ppBlockEnd      [out] - ending block
//     pulInBlockEnd   [out] - offset in ending block
//     pBlockStartPrev [in]  - optional (can be NULL) - prevoius block of starting block
//     ppBlockEndPrev  [out] - optional (can be NULL) - prevoius block of ending block
//
// Output:
//
// Notes:
//    The new location is set to NULL if the end location is pass the logical eof (e.g. in or
//    past the unused bytes in the last block).
//    If ppBlockEndPrev is passed, we also return the block that is just before the block of
//    the end location. Incase we didn't advance a block we return in it what was passed as
//    the previous block of the starting block (pBlockStartPrev).
//
void CMyLockBytes::AdvanceInBlocks(CMyMemNode * pBlockStart,
                                   ULONG ulInBlockStart,
                                   ULONGLONG ullAdvance,
                                   CMyMemNode ** ppBlockEnd,
                                   ULONG * pulInBlockEnd,
                                   CMyMemNode * pBlockStartPrev,
                                   CMyMemNode ** ppBlockEndPrev)
{
    ULONGLONG ullLeftAdvance = ullAdvance;
    CMyMemNode * pBlock = pBlockStart;
    ULONG ulInBlock = ulInBlockStart;
    CMyMemNode * pBlockPrev = pBlockStartPrev;
    //
    // advance as long as there is a need, and we didn't reach the end yet
    //
    while ((ullLeftAdvance > 0) && (pBlock != NULL))
    {
        ASSERTMSG(pBlock->cbSize > ulInBlock, ""); // offset is always smaller than block size
        //
        // check if we need to advance past this block
        // max that we can advance is past the last element. in this case we
        // advance to the beginning of next block
        //
        ULONG ulMaxAdvanceInThisBlock = pBlock->cbSize - ulInBlock;
        //
        // ulMaxAdvanceInThisBlock is not fully correct incase this is the last block
        // since we need to deduct the spare bytes. however, after we finish
        // advancing, we check if we didn't enter the spare bytes, and if we did,
        // we return NULL
        //
        if (ullLeftAdvance >= ulMaxAdvanceInThisBlock) // advance past last element ?
        {
            //
            // advance past last element, need to move to the beginning of next block
            //
            ullLeftAdvance -= ulMaxAdvanceInThisBlock; // could become zero
            //
            // move to the beginning of next block
            //
            pBlockPrev = pBlock;
            pBlock = pBlock->pNext;
            ulInBlock = 0;
        }
        else
        {
            //
            // the final advance is in this block, do it
            //
            ASSERTMSG(HighPart(ullLeftAdvance) == 0, ""); //must be because it is less than block size which is ulong
            ulInBlock += LowPart(ullLeftAdvance);
            //
            // no need to touch pBlock, we didn't move to next block
            // no more bytes to advance
            //
            ullLeftAdvance = 0;
        }
    }
    //
    // return results
    // need to check if we finished advancing
    // even if we finished, it might be that we are at the spare bytes of the last
    // block, so we check that too
    //
    if ((ullLeftAdvance == 0) &&               // if finished advancing AND
        (!IsInSpareBytes(pBlock, ulInBlock)))  //    not in spare bytes
    {
        //
        // finished advancing and not in spare bytes
        // return location (this can NULL as well if the start point was NULL, and advancing zero bytes)
        //
        *ppBlockEnd = pBlock;
        *pulInBlockEnd = ulInBlock;
    }
    else
    {
        //
        // either not finished advancing, or finished but in spare bytes (which is not
        // a legal location)
        // return NULL as the new location
        //
        *ppBlockEnd = NULL;
		*pulInBlockEnd = 0;
    }
    //
    // if previous block required, return it
    //
    if (ppBlockEndPrev)
    {
        *ppBlockEndPrev = pBlockPrev;
    }
}


//=--------------------------------------------------------------------------=
// CMyLockBytes::GrowBlocks
//=--------------------------------------------------------------------------=
// Grow the chain of blocks by a given number of bytes
//
// Parameters:
//     ullGrow     [in] - number of bytes to grow the chain of blocks (can be 0)
//
// Output:
//     Returns E_OUTOFMEMORY, or E_FAIL if the size of the requested grow is too big
//     to fit in 32 bits
//
// Notes:
//     We may grow into the spare bytes without allocating a new block.
//     If we need to allocate a new block, we allocate just one block. The size of
//     the allocated block is at least a predefined minimum size, but can be bigger
//     incase more bytes than the minimum are needed
//
HRESULT CMyLockBytes::GrowBlocks(ULONGLONG ullGrow)
{
    //
    // return immediately if growing with 0 bytes
    //
    if (ullGrow == 0)
    {
        return NOERROR;
    }
    //
    // check if we can just use the spare bytes in the last block
    //
    if (ullGrow <= m_ulUnusedInLastBlock)
    {
        ASSERTMSG(HighPart(ullGrow) == 0, ""); // since it is less or equal to 32 bit ulong
        //
        // we can grow just by using the spare bytes in the last block
        // update number of spare bytes
        //
        m_ulUnusedInLastBlock -= LowPart(ullGrow);
        //
        // no need to touch m_pLastBlock, m_pBlocks, no new block
        //
    }
    else //ullGrow.QuadPart > m_ulUnusedInLastBlock
    {
        //
        // we need to allocate a new block
        //
        // compute how many bytes are needed after using the spare bytes
        //
        ULONGLONG ullNeededInNewBlock = ullGrow - m_ulUnusedInLastBlock;
        ASSERTMSG(ullNeededInNewBlock > 0, ""); // we really need a new block here
        //
        // compute min alloc size for next alloc to be 2 times bigger
        // than the minimum size for the last block.
        // this is to avoid memory fragmentation for really large lockbytes,
        // but also allow small initial allocation for small lockbytes
        // however this is done only until some limit (256K)
        //
        // number of increments has an upper limit (x_cMaxAllocIncrements)
        //
        ULONG cAllocIncrements = Min1(m_cBlocks, x_cMaxAllocIncrements);
        ULONG ulMinAllocSize = x_ulStartMinAlloc; //256 bytes
        //
        // each increment is double the previous value, that is a shift left
        // for the first block there is no increment since m_cBlocks == 0,
        // thereofre cAllocIncrements == 0
        //
        if (cAllocIncrements > 0)
        {
            ulMinAllocSize = ulMinAllocSize << cAllocIncrements;
        }
        //
        // allocate at least the minimum block size
        //
        ULONGLONG ullToAlloc = Max1(ulMinAllocSize, ullNeededInNewBlock + sizeof(CMyMemNode));
        //
        // currently we cannot allocate really big numbers
        //
        ASSERTMSG(HighPart(ullToAlloc) == 0, "");
        if (HighPart(ullToAlloc) != 0)
        {
            return E_FAIL;
        }
        CMyMemNode * pNewBlock = (CMyMemNode *) new BYTE[LowPart(ullToAlloc)];
        if (pNewBlock == NULL)
        {
            return E_OUTOFMEMORY;
        }
        //
        // update number of blocks
        //
        m_cBlocks++;
        //
        // prepare the block
        // set size
        //
        ASSERTMSG(LowPart(ullToAlloc) > sizeof(CMyMemNode), ""); // really needed a new block
        pNewBlock->cbSize = LowPart(ullToAlloc) - sizeof(CMyMemNode);
        ASSERTMSG(pNewBlock->cbSize > 0, "");
        //
        // insert to the end of chain
        //
        if (m_pLastBlock != NULL)
        {
            ASSERTMSG(m_pLastBlock->pNext == NULL, ""); // pNext of last block should be NULL
            m_pLastBlock->pNext = pNewBlock;
        }
        //
        // this should be the last block
        //
        pNewBlock->pNext = NULL;
        m_pLastBlock = pNewBlock;
        //
        // this might be the first block as well (incase this is the first block allocated)
        //
        if (m_pBlocks == NULL)
        {
            m_pBlocks = pNewBlock;
        }
        //
        // it might be that there are spare bytes in the last block, because
        // we have a minimum allocation size that can be greater than what
        // was really needed.
        // update size of unused bytes in this last block
        //
        ASSERTMSG(HighPart(ullNeededInNewBlock) == 0, ""); // since ullToAlloc which is bigger was also as 32 bit number
        ASSERTMSG(pNewBlock->cbSize >= LowPart(ullNeededInNewBlock), ""); //new block ia allocated to contain at least what is needed
        m_ulUnusedInLastBlock = pNewBlock->cbSize - LowPart(ullNeededInNewBlock);
    }
    //
    // set size to new size and return result
    //
    m_ullSize += ullGrow; 
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMyLockBytes::CMyLockBytes
//=--------------------------------------------------------------------------=
// Initialize ref count, and critical sections
// Initialize the blocks chain to an empty chain of size 0
//
// Parameters:
//
// Output:
//
// Notes:
//
CMyLockBytes::CMyLockBytes() :
	m_critBlocks(CCriticalSection::xAllocateSpinCount)
{
    m_cRef = 0;
    m_ullSize = 0;
    m_pBlocks = NULL;
    m_pLastBlock = NULL;
    m_ulUnusedInLastBlock = 0;
    m_cBlocks = 0;
}


//=--------------------------------------------------------------------------=
// CMyLockBytes::~CMyLockBytes
//=--------------------------------------------------------------------------=
// Delete critical sections
// Delete blocks chain
//
// Parameters:
//
// Output:
//
// Notes:
//
CMyLockBytes::~CMyLockBytes()
{
    DeleteBlocks(m_pBlocks);
    ASSERTMSG(m_cBlocks == 0, "");
}


//=--------------------------------------------------------------------------=
// CMyLockBytes::QueryInterface
//=--------------------------------------------------------------------------=
// Supports IID_ILockBytes and IID_IUnknown
//
// Parameters:
//
// Output:
//
// Notes:
//
HRESULT STDMETHODCALLTYPE CMyLockBytes::QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = (IUnknown *) this;
    }
    else if (IsEqualIID(riid, IID_ILockBytes))
    {
        *ppvObject = (ILockBytes *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    //
    // AddRef before returning an interface
    //
    AddRef();
    return NOERROR;        
}
        

//=--------------------------------------------------------------------------=
// CMyLockBytes::AddRef
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//
// Notes:
//
ULONG STDMETHODCALLTYPE CMyLockBytes::AddRef( void)
{
    return InterlockedIncrement(&m_cRef);
}
        

//=--------------------------------------------------------------------------=
// CMyLockBytes::Release
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//
// Notes:
//
ULONG STDMETHODCALLTYPE CMyLockBytes::Release( void)
{
	ULONG cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}


//=--------------------------------------------------------------------------=
// CMyLockBytes::ReadAt
//=--------------------------------------------------------------------------=
// ILockBytes virtual function
// Reads at most cb bytes of data from the given offset into the given buffer
//
// Parameters:
//    ullOffset [in]  - offset of the first byte to read
//    pv        [in]  - buffer to read the bytes into
//    cb        [in]  - max number of bytes to read
//    pcbRead   [out] - number of bytes read
//
// Output:
//    Cannot fail (always NOERROR)
//
// Notes:
//    When starting offset is past eof we return 0 bytes read, but we don't grow the chain
//    We read until eof, so pcbRead can be less than the requested cb incase we reached eof
//
HRESULT STDMETHODCALLTYPE CMyLockBytes::ReadAt( 
            /* [in] */ ULARGE_INTEGER ullOffset,
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead)
{
    CS lock(m_critBlocks);
    //
    // if the starting location is at or beyond eof, or we are asked
    // to read 0 bytes, we return immediately
    //
    if ((ullOffset.QuadPart >= m_ullSize) ||
        (cb == 0))
    {
        if (pcbRead)
        {
            *pcbRead = 0;
        }
        return NOERROR;
    }
    //
    // (ullOffset.QuadPart < m_ullSize) AND (cb > 0)
    // the blocks are not empty AND we need to read some bytes
    // compute how many bytes can be read
    // minimum of requested size and until-eof size
    //
    ULONGLONG ullAllowedRead = m_ullSize - ullOffset.QuadPart;
    ULONGLONG ullToRead = Min1(cb, ullAllowedRead);
    ASSERTMSG(HighPart(ullToRead) == 0, ""); //min with a 32 bit number
    ULONG cbToRead = LowPart(ullToRead);
    //
    // find starting location (offset from beginning)
    // BUGBUG optimization we can save the call if the offset is 0 since
    // we seek from the beginning
    //
    CMyMemNode * pBlock;
    ULONG ulOffsetInBlock = 0;
    AdvanceInBlocks(m_pBlocks,
                    0 /*ulInBlockStart*/,
                    ullOffset.QuadPart,
                    &pBlock,
                    &ulOffsetInBlock,
                    NULL /*pBlockStartPrev*/,
                    NULL /*ppBlockEndPrev*/);
    //
    // there has got to be a location, since the offset was smaller than the chain size
    //
    ASSERTMSG(pBlock != NULL, "");
    ASSERTMSG(ulOffsetInBlock < pBlock->cbSize, ""); // always true for a location
    //
    // read from blocks chain until finished reading
    //
    BYTE * pBuffer = (BYTE *)pv;
    while (cbToRead > 0)
    {
        //
        // compute how many bytes can be read in this block
        // minimum of requested size and until-end-of-block size
        //
        ULONG ulAllowedReadInBlock = pBlock->cbSize - ulOffsetInBlock;
        //
        // ulAllowedReadInBlock is not fully correct incase this is the last block
        // since we need to deduct the spare bytes. however, since we make sure
        // above that we cannot pass the eof (cbToRead is the minimum of the size
        // requested and size until eof), were OK and we never read from the
        // spare bytes
        //
        ULONG cbToReadInBlock = Min1(cbToRead, ulAllowedReadInBlock);
        //
        // copy bytes to buffer
        //
        BYTE * pbSrc = ((BYTE *)pBlock) + sizeof(CMyMemNode) + ulOffsetInBlock;
        memcpy(pBuffer, pbSrc, cbToReadInBlock);
        //
        // move pass the copied data in the receive buffer
        //
        pBuffer += cbToReadInBlock;
        //
        // update how many bytes are left to read
        //
        cbToRead -= cbToReadInBlock;
        //
        // move to next block of data
        //
        pBlock = pBlock->pNext;
        //
        // for next block we always start at the beginning
        //
        ulOffsetInBlock = 0;
    } // while (cbToRead > 0)
    //
    // return results 
    //
    if (pcbRead)
    {
        *pcbRead = DWORD_PTR_TO_DWORD(pBuffer - (BYTE *)pv);
    }
    return NOERROR;
}
        

//=--------------------------------------------------------------------------=
// CMyLockBytes::WriteAt
//=--------------------------------------------------------------------------=
// ILockBytes virtual function
// Write cb bytes of data from the given buffer starting from a given offset
//
// Parameters:
//    ullOffset   [in]  - offset of where to start theh write
//    pv          [in]  - buffer to write
//    cb          [in]  - number of bytes to write
//    pcbWritten  [out] - number of bytes written
//
// Output:
//    E_OUTOFMEMORY
//
// Notes:
//    When starting offset is past eof we grow the chain even if requested write is for 0 bytes
//    pcbWritten should always be the same as requested
//
HRESULT STDMETHODCALLTYPE CMyLockBytes::WriteAt( 
            /* [in] */ ULARGE_INTEGER ullOffset,
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten)
{
    CS lock(m_critBlocks);
    //
    // check if start of new data is at or beyond eof
    //
    if (ullOffset.QuadPart >= m_ullSize)
    {
        //
        // we are writing at or past eof
        // eliminate the obvious case of writing zero bytes at eof (the only case
        // here where we don't grow the blocks). this case can cause confusion later
        // if not handled separately
        //
        if ((ullOffset.QuadPart == m_ullSize) &&
            (cb == 0))
        {
            if (pcbWritten)
            {
                *pcbWritten = 0;
            }
            return NOERROR;
        }
        //
        // here we must grow the blocks
        //
        // start of new data is at or beyond eof
        // we save last eof location
        //
        ULONGLONG ullSaveSize = m_ullSize;
        CMyMemNode * pSaveLastBlock = m_pLastBlock;
        ULONG ulSaveUnusedInLastBlock = m_ulUnusedInLastBlock;
        //
        // compute the number of bytes to grow the chain
        //
        ULONGLONG ullGrow = ullOffset.QuadPart + cb - m_ullSize;
        //
        // grow the blocks
        // here we must grow the blocks (eliminated already the obvious case when writing
        // zero bytes at eof)
        //
        ASSERTMSG (ullGrow > 0, "");
        HRESULT hr = GrowBlocks(ullGrow);
        if (FAILED(hr))
        {
            return hr;
        }
        //
        // now if we have something to write, we need to do it, otherwise we don't have
        // anything more to do in this case
        //
        if (cb > 0)
        {
            //
            // we need to write some data
            //
            // set location of previous eof in the blocks.
            // if chain was empty, last eof should be set to the beginning of the blocks chain.
            // if last block was full, then last eof is at the beginning of next block. Next block
            // in this case of full last block cannot be NULL since we had to grow the blocks,
            // therefore had to create a new block if the last block was full
            //
            CMyMemNode * pBlockLastEof;
            ULONG ulInBlockLastEof;
            if (pSaveLastBlock == NULL)
            {
                //
                // chain was empty before growing, now after grow, last eof is at the beginning
                // of the chain (must be a starting block)
                //
                ASSERTMSG(m_pBlocks != NULL, "");
                pBlockLastEof = m_pBlocks;
                ulInBlockLastEof = 0;
            }
            else // pSaveLastBlock != NULL
            {
                //
                // check if last eof block was full
                //
                if (ulSaveUnusedInLastBlock == 0)
                {
                    //
                    // last eof block was full. last eof location is set to beginning of the block
                    // next to the last eof block (must be one since we grew the blocks)
                    //
                    ASSERTMSG(pSaveLastBlock->pNext != NULL, "");
                    pBlockLastEof = pSaveLastBlock->pNext;
                    ulInBlockLastEof = 0;
                }
                else // ulSaveUnusedInLastBlock > 0
                {
                    //
                    // last eof block was not full. last eof location is set just after
                    // the last valid byte
                    //
                    ASSERTMSG(pSaveLastBlock != NULL, ""); // we're in that case now
                    pBlockLastEof = pSaveLastBlock;
                    ulInBlockLastEof = pSaveLastBlock->cbSize - ulSaveUnusedInLastBlock;
                }
            }
            //
            // chain cannot be empty, so we have to have a real last eof position
            // that cannot be the beginning of an empty chain
            //
            ASSERTMSG(pBlockLastEof != NULL, "");
            ASSERTMSG(ulInBlockLastEof < pBlockLastEof->cbSize, ""); // always true for a location
            //
            // find the start write location by seeking from the last eof location
            // this is an optimization (we don't seek from the head of blocks) since we know the
            // data cannot start before the previous eof (that is the case we are handling here,
            // where the write starts at ot after eof)
            //
            // compute how much we need to seek. Note that m_ullSize now contains the new value and
            // we should use the saved value to find out how many bytes to seek
            // could be 0 (when writing at eof)
            //
            ULONGLONG ullToSeek = ullOffset.QuadPart - ullSaveSize;
            //
            // get location of starting write
            //
            CMyMemNode * pStartWrite;
            ULONG ulInBlockStartWrite;
            //
            // optimization - seek only if we really need to seek (even though it would work
            // with 0 advance)
            //
            if (ullToSeek > 0)
            {
                //
                // seek from last eof to start of write
                //
                AdvanceInBlocks(pBlockLastEof,
                                ulInBlockLastEof,
                                ullToSeek,
                                &pStartWrite,
                                &ulInBlockStartWrite,
                                NULL /*pBlockStartPrev*/,
                                NULL /*ppBlockStartPrev*/);
                //
                // there has got to be a start write location, since we have to 
                // write somthing and we grew the blocks for that
                //
                ASSERTMSG(pStartWrite != NULL, "");
                ASSERTMSG(ulInBlockStartWrite < pStartWrite->cbSize, ""); // always true for a location
            }
            else // ullToSeek.QuadPart == 0
            {
                //
                // start of write is actually the previous eof
                // if the inblock location is past the valid bytes in this
                //
                pStartWrite = pBlockLastEof;
                ulInBlockStartWrite = ulInBlockLastEof;
            }
            //
            // do the write, now that the blocks are allocated to contain the data.
            //
            WriteInBlocks(pStartWrite, ulInBlockStartWrite, (BYTE *)pv, cb);
        } // if (cb > 0)
    } // if (ullOffset.QuadPart >= m_ullSize.QuadPart)
    else //ullOffset.QuadPart < m_ullSize.QuadPart
    {
        //
        // start of write is before eof, also means m_ullSize > 0 (since ulOffset >= 0),
        // so we have start and end blocks
        //
        ASSERTMSG(m_pBlocks != NULL, "");
        ASSERTMSG(m_pLastBlock != NULL, "");
        //
        // check end of write
        // if we need to grow the blocks do it
        //
        ULONGLONG ullEndOfWrite = ullOffset.QuadPart + cb;
        if (ullEndOfWrite > m_ullSize)
        {
            //
            // we need to grow the chains, compute by how many, and do it
            //
            ULONGLONG ullGrow = ullEndOfWrite - m_ullSize;
            ASSERTMSG(ullGrow > 0, ""); // this is the case we handle
            HRESULT hr = GrowBlocks(ullGrow);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        //
        // now if we have something to write, we need to do it, otherwise we don't have
        // anything more to do in this case
        //
        if (cb > 0)
        {
            //
            // now find the beginning of the write (look from the beginning - no other clue)
            // we may do optimization to save a cache of last used offsets and block pointers
            // BUGBUG optimization we can save the call if the offset is 0 since
            // we seek from the beginning
            //
            CMyMemNode * pStartWrite;
            ULONG ulInBlockStartWrite = 0;
            AdvanceInBlocks(m_pBlocks,
                            0,
                            ullOffset.QuadPart,
                            &pStartWrite,
                            &ulInBlockStartWrite,
                            NULL /*pBlockStartPrev*/,
                            NULL /*ppBlockStartPrev*/);
            //
            // there must be alocation to write since the start of write is
            // before eof
            //
            ASSERTMSG(pStartWrite != NULL, "");
            ASSERTMSG(ulInBlockStartWrite < pStartWrite->cbSize, ""); //always true for locations
            //
            // do the write
            //
            WriteInBlocks(pStartWrite, ulInBlockStartWrite, (BYTE *)pv, cb);
        } // if (cb > 0)
    } //if (ullOffset.QuadPart >= m_ullSize.QuadPart)
    //
    // set written bytes and return
    //
    if (pcbWritten)
    {
        *pcbWritten = cb;
    }
    return NOERROR;
}
        

//=--------------------------------------------------------------------------=
// CMyLockBytes::SetSize
//=--------------------------------------------------------------------------=
// ILockBytes virtual function
// Set the size to the specified size
//
// Parameters:
//    cb          [in]  - new size of lockbytes
//
// Output:
//    E_OUTOFMEMORY
//
// Notes:
//
HRESULT STDMETHODCALLTYPE CMyLockBytes::SetSize( 
            /* [in] */ ULARGE_INTEGER cb)
{
    CS lock(m_critBlocks);
    if (cb.QuadPart == m_ullSize)
    {
        //
        // no change needed, just return
        //
    }
    else if (cb.QuadPart == 0)
    {
        //
        // delete the blocks and reset the data
        //
        DeleteBlocks(m_pBlocks);
        ASSERTMSG(m_cBlocks == 0, "");
        m_cBlocks = 0;
        m_pBlocks = NULL;
        m_pLastBlock = NULL;
        m_ulUnusedInLastBlock = 0;
        m_ullSize = 0;
    }
    else if (cb.QuadPart < m_ullSize)
    {
        //
        // need to truncate, find starting block (from the beginning, no other clue)
        // BUGBUG optimization we can save the call if the offset is 0 since
        // we seek from the beginning
        //
        CMyMemNode * pBlock;
        CMyMemNode * pBlockPrev;
        ULONG ulOffsetInBlock;
        AdvanceInBlocks(m_pBlocks,
                        0 /*ulInBlockStart*/,
                        cb.QuadPart,
                        &pBlock,
                        &ulOffsetInBlock,
                        NULL /*pBlockStartPrev*/,
                        &pBlockPrev);
        //
        // there has got to be a location, since the offset was smaller than the chain size
        //
        ASSERTMSG(pBlock != NULL, "");
        ASSERTMSG(ulOffsetInBlock < pBlock->cbSize, ""); // always true for a location
        //
        // delete unneeded blocks
        //
        if (ulOffsetInBlock == 0)
        {
            //
            // we need to delete this block as well as the next blocks
            //
            DeleteBlocks(pBlock);
            //
            // update last block to be the previous block
            // this cannot be the first block, since that means we need
            // to set size to 0 (since the offset-in-block is also zero),
            // however this case is already handled as a special case
            // before, so we don't get here for that. This also means the
            // previous block cannot be NULL
            //
            ASSERTMSG(pBlock != m_pBlocks, "");
            ASSERTMSG(pBlockPrev != NULL, "");
            pBlockPrev->pNext = NULL;
            m_pLastBlock = pBlockPrev;
            //
            // new last block (previous block) is not touched, so it stays full
            //
            m_ulUnusedInLastBlock = 0;
            //
            // no need to touch m_pBlocks (the deleted pBlock cannot be the first block)
            //
        } //if (ulOffsetInBlock == 0)
        else // ulOffsetInBlock != 0
        {
            //
            // this should be the new last block
            // delete all blocks after this block
            //
            DeleteBlocks(pBlock->pNext);
            //
            // update last block to this block
            //
            pBlock->pNext = NULL;
            m_pLastBlock = pBlock;
            //
            // we should have unused space in the last block now, since otherwise
            // we would have seeked to the beginning of next block (which is handled by
            // another case above)
            //
            ASSERTMSG(ulOffsetInBlock < pBlock->cbSize, ""); //always true for locations
            m_ulUnusedInLastBlock = pBlock->cbSize - ulOffsetInBlock;
            //
            // no need to touch m_pBlocks (we didn't delete pBlock)
            //
        } //if (ulOffsetInBlock == 0)
        //
        // set new size
        //
        m_ullSize = cb.QuadPart;
    }
    else // (cb.QuadPart > m_ullSize.QuadPart)
    {
        //
        // need to grow. check by how much
        //
        ULONGLONG ullToAdd = cb.QuadPart - m_ullSize;
        ASSERTMSG(ullToAdd > 0, ""); //this is the case we handle
        //
        // grow (this will also update m_ullSize and other relevant data)
        //
        HRESULT hr = GrowBlocks(ullToAdd);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    //
    // return
    //
    return NOERROR;
}
        

//=--------------------------------------------------------------------------=
// CMyLockBytes::Stat
//=--------------------------------------------------------------------------=
// ILockBytes virtual function
// Returns information on lockbytes
//
// Parameters:
//    pstatstg    [out] - where to put the information
//    grfStatFlag [in]  - whether to return the name of lockbytes or not (ignored)
//
// Output:
//    Can't fail
//
// Notes:
//
HRESULT STDMETHODCALLTYPE CMyLockBytes::Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD /*grfStatFlag*/ )
{
    //
    // fill only the necessary data (as IlockBytesOnHGlobal does)
    //
    ZeroMemory(pstatstg, sizeof(STATSTG));
    pstatstg->type = STGTY_LOCKBYTES;
    pstatstg->cbSize.QuadPart = m_ullSize;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\ilock.h ===
//--------------------------------------------------------------------------=
// ilock.H
//=--------------------------------------------------------------------------=
// Copyright  2000  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// Definition of ILockBytes on memory which uses a chain of variable sized
// blocks
//
#ifndef _ILOCK_H_
#define _ILOCK_H_

#include <windows.h>
#include <cs.h>

//
// low and high parts of 64 bit int
//
static inline ULONG HighPart(ULONGLONG ull)
{
    ULARGE_INTEGER ullTmp;
    ullTmp.QuadPart = ull;
    return ullTmp.HighPart;
}
static inline ULONG LowPart(ULONGLONG ull)
{
    ULARGE_INTEGER ullTmp;
    ullTmp.QuadPart = ull;
    return ullTmp.LowPart;
}

//
// type safe min/max functions
//
static inline ULONG Min1(ULONG ul1, ULONG ul2)
{
    if (ul1 <= ul2) return ul1;
    return ul2;
}
static inline ULONGLONG Min1(ULONG ul1, ULONGLONG ull2)
{
    if (ul1 <= ull2) return ul1;
    return ull2;
}
static inline ULONGLONG Min1(ULONGLONG ull1, ULONGLONG ull2)
{
    if (ull1 <= ull2) return ull1;
    return ull2;
}
static inline ULONGLONG Max1(ULONG ul1, ULONGLONG ull2)
{
    if (ul1 >= ull2) return ul1;
    return ull2;
}

//
// memory block header
//
struct CMyMemNode
{
    CMyMemNode * pNext;
    ULONG cbSize;
};

//
// CMyLockBytes
//
class CMyLockBytes: public ILockBytes
{
public:
    //
    // IUnknown
    //
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
    
    virtual ULONG STDMETHODCALLTYPE AddRef( void);
    
    virtual ULONG STDMETHODCALLTYPE Release( void);

    //
    // ILockBytes in addition to IUnknown
    //
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE ReadAt( 
        /* [in] */ ULARGE_INTEGER ulOffset,
        /* [length_is][size_is][out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead);
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE WriteAt( 
        /* [in] */ ULARGE_INTEGER ulOffset,
        /* [size_is][in] */ const void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbWritten);
    
    virtual HRESULT STDMETHODCALLTYPE Flush( void)
    {
        return NOERROR;
    }
    
    virtual HRESULT STDMETHODCALLTYPE SetSize( 
        /* [in] */ ULARGE_INTEGER cb);
    
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
        /* [in] */ ULARGE_INTEGER /*libOffset*/ ,
        /* [in] */ ULARGE_INTEGER /*cb*/ ,
        /* [in] */ DWORD /*dwLockType*/ )
    {
        return NOERROR;
    }
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
        /* [in] */ ULARGE_INTEGER /*libOffset*/ ,
        /* [in] */ ULARGE_INTEGER /*cb*/ ,
        /* [in] */ DWORD /*dwLockType*/)
    {
        return NOERROR;
    }
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        /* [out] */ STATSTG __RPC_FAR *pstatstg,
        /* [in] */ DWORD grfStatFlag);

    //
    // Class
    //
    CMyLockBytes();

    virtual ~CMyLockBytes();

    static HRESULT STDMETHODCALLTYPE CreateInstance(
        /* [in] */ REFIID riid,
        /* [out] */ void **ppvObject)
    {
		CMyLockBytes *pcMyLockBytes;

		try
		{
			pcMyLockBytes = new CMyLockBytes;
		}
		catch(const std::bad_alloc&)
		{
			//
			// Exception might be thrown while constructing the 
			// critical section member of the MSMQ object.
			//
			return E_OUTOFMEMORY;
		}

        if (pcMyLockBytes == NULL)
        {
            return E_OUTOFMEMORY;
        }
        HRESULT hr = pcMyLockBytes->QueryInterface(riid, ppvObject);
        if (FAILED(hr))
        {
            delete pcMyLockBytes;
        }
        return hr;
    }

private:
    void DeleteBlocks(CMyMemNode * pBlockHead);
    BOOL IsInSpareBytes(CMyMemNode * pBlock, ULONG ulInBlock);
    void AdvanceInBlocks(CMyMemNode * pBlockStart,
                         ULONG ulInBlockStart,
                         ULONGLONG ullAdvance,
                         CMyMemNode ** ppBlockEnd,
                         ULONG * pulInBlockEnd,
                         CMyMemNode * pBlockStartPrev,
                         CMyMemNode ** ppBlockEndPrev);
    HRESULT GrowBlocks(ULONGLONG ullGrow);

private:
	//
	// Critical section is initialized to preallocate its resources 
	// with flag CCriticalSection::xAllocateSpinCount. This means it may throw bad_alloc() on 
	// construction but not during usage.
	//
    CCriticalSection m_critBlocks;
    LONG m_cRef;
    ULONGLONG m_ullSize;
    CMyMemNode * m_pBlocks;
    CMyMemNode * m_pLastBlock;
    ULONG m_ulUnusedInLastBlock;
    ULONG m_cBlocks;
};

#endif //_ILOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\istm.cpp ===
//--------------------------------------------------------------------------=
// istm.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// Implementation of IStream on ILockBytes
//
#include "stdafx.h"
#include "ilock.h" //for some inline functions
#include "istm.h"

// needed for ASSERTs and FAIL
//
#include "debug.h"

#include "cs.h"

//=--------------------------------------------------------------------------=
// CMyStream::CMyStream
//=--------------------------------------------------------------------------=
// Initialize ref count, and critical sections
// Initialize lockbytes, cursor
//
// Parameters:
//
// Output:
//
// Notes:
//
CMyStream::CMyStream(ILockBytes * pLockBytes) :
	m_critStm(CCriticalSection::xAllocateSpinCount)
{
    m_cRef = 0;
    m_ullCursor = 0;
    m_pLockBytes = pLockBytes;
    ASSERTMSG(m_pLockBytes != NULL, "");
    m_pLockBytes->AddRef();
}


//=--------------------------------------------------------------------------=
// CMyStream::~CMyStream
//=--------------------------------------------------------------------------=
// Delete critical sections
// Release lockbytes
//
// Parameters:
//
// Output:
//
// Notes:
//
CMyStream::~CMyStream()
{
    ASSERTMSG(m_pLockBytes != NULL, "");
    m_pLockBytes->Release();
}


//=--------------------------------------------------------------------------=
// CMyStream::QueryInterface
//=--------------------------------------------------------------------------=
// Supports IID_IStream, IID_ISequentialStream, and IID_IUnknown
//
// Parameters:
//
// Output:
//
// Notes:
//
HRESULT STDMETHODCALLTYPE CMyStream::QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = (IUnknown *) this;
    }
    else if (IsEqualIID(riid, IID_IStream))
    {
        *ppvObject = (IStream *) this;
    }
    else if (IsEqualIID(riid, IID_ISequentialStream))
    {
        *ppvObject = (ISequentialStream *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    //
    // AddRef before returning an interface
    //
    AddRef();
    return NOERROR;        
}
        

//=--------------------------------------------------------------------------=
// CMyStream::AddRef
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//
// Notes:
//
ULONG STDMETHODCALLTYPE CMyStream::AddRef( void)
{
    return InterlockedIncrement(&m_cRef);
}
        

//=--------------------------------------------------------------------------=
// CMyStream::Release
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//
// Notes:
//
ULONG STDMETHODCALLTYPE CMyStream::Release( void)
{
	ULONG cRef = InterlockedDecrement(&m_cRef);

	if (cRef == 0)
    {
        delete this;
    }
    return cRef;
}


//=--------------------------------------------------------------------------=
// CMyStream::Read
//=--------------------------------------------------------------------------=
// ISequentialStream virtual function
// Read data from stream
//
// Parameters:
//    pv [in]       - buffer to read into
//    cb [in]       - number of bytes to read
//    pcbRead [out] - number of bytes read
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT STDMETHODCALLTYPE CMyStream::Read( 
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead)
{
    CS lock(m_critStm);
    //
    // read from lockbytes
    //
    ULONG cbRead;
    ULARGE_INTEGER ullCursor;
    ullCursor.QuadPart = m_ullCursor;
    ASSERTMSG(m_pLockBytes != NULL, "");
    HRESULT hr = m_pLockBytes->ReadAt(ullCursor, pv, cb, &cbRead);
    if (FAILED(hr))
    {
        return hr;
    }
    //
    // update cursor
    //
    m_ullCursor += cbRead;
    //
    // return results
    //
    if (pcbRead != NULL)
    {
        *pcbRead = cbRead;
    }
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMyStream::Write
//=--------------------------------------------------------------------------=
// ISequentialStream virtual function
// Write data to stream
//
// Parameters:
//    pv [in]          - buffer to write
//    cb [in]          - number of bytes to write
//    pcbWritten [out] - number of bytes written
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT STDMETHODCALLTYPE CMyStream::Write( 
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten)
{
    CS lock(m_critStm);
    //
    // write to lockbytes
    //
    ULONG cbWritten;
    ULARGE_INTEGER ullCursor;
    ullCursor.QuadPart = m_ullCursor;
    ASSERTMSG(m_pLockBytes != NULL, "");
    HRESULT hr = m_pLockBytes->WriteAt(ullCursor, pv, cb, &cbWritten);
    if (FAILED(hr))
    {
        return hr;
    }
    //
    // update cursor
    //
    m_ullCursor += cbWritten;
    //
    // return results
    //
    if (pcbWritten != NULL)
    {
        *pcbWritten = cbWritten;
    }
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMyStream::Seek
//=--------------------------------------------------------------------------=
// IStream virtual function
// Changes the position of the stream cursor
//
// Parameters:
//    dlibMove [in]          - offset to move
//    dwOrigin [in]          - where to start the move
//    plibNewPosition [out]  - new cursor position
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT STDMETHODCALLTYPE CMyStream::Seek( 
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
    CS lock(m_critStm);
    //
    // find start of seek
    //
    LONGLONG llStartSeek;
    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:
        llStartSeek = 0;
        break;

    case STREAM_SEEK_CUR:
        llStartSeek = m_ullCursor;
        break;

    case STREAM_SEEK_END:
        {
            STATSTG statstg;
            ASSERTMSG(m_pLockBytes != NULL, "");
            HRESULT hr = m_pLockBytes->Stat(&statstg, STATFLAG_NONAME);
            if (FAILED(hr))
            {
                return hr;
            }
            llStartSeek = statstg.cbSize.QuadPart;
        }
        break;

    default:
        return STG_E_SEEKERROR;
        break;
    }
    //
    // compute new cursor position
    //
    LONGLONG llCursor = llStartSeek + dlibMove.QuadPart;
    //
    // we can't have negative cursors
    //
    if (llCursor < 0)
    {
        return STG_E_SEEKERROR;
    }
    //
    // set new cursor
    //
    m_ullCursor = llCursor;
    //
    // return results
    //
    if (plibNewPosition != NULL)
    {
        plibNewPosition->QuadPart = m_ullCursor;
    }
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMyStream::SetSize
//=--------------------------------------------------------------------------=
// IStream virtual function
// Changes the size of the stream
//
// Parameters:
//    libNewSize [in]        - new size of stream
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT STDMETHODCALLTYPE CMyStream::SetSize( 
        /* [in] */ ULARGE_INTEGER libNewSize)
{
    CS lock(m_critStm);
    //
    // just change the size of lockbytes. must not touch the cursor
    //
    ASSERTMSG(m_pLockBytes != NULL, "");
    HRESULT hr = m_pLockBytes->SetSize(libNewSize);
    return hr;
}


//=--------------------------------------------------------------------------=
// CMyStream::CopyTo
//=--------------------------------------------------------------------------=
// IStream virtual function
// Copies data to another stream
//
// Parameters:
//    pstatstg    [out] - where to put the information
//    grfStatFlag [in]  - whether to return the name of lockbytes or not (ignored)
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT STDMETHODCALLTYPE CMyStream::CopyTo( 
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten)
{
    CS lock(m_critStm);
    STATSTG statstg;
    ASSERTMSG(m_pLockBytes != NULL, "");
    HRESULT hr = m_pLockBytes->Stat(&statstg, STATFLAG_NONAME);
    if (FAILED(hr))
    {
        return hr;
    }
    //
    // we have something to copy only if cursor is before eof
    //
    ULONGLONG ullRead = 0;
    ULONGLONG ullWritten = 0;
    if (m_ullCursor < statstg.cbSize.QuadPart)
    {
        //
        // cursor is before eof. calculate read buffer size
        //
        ULONGLONG ullAllowedRead = statstg.cbSize.QuadPart - m_ullCursor;
        ULONGLONG ullNeedToRead = Min1(ullAllowedRead, cb.QuadPart);
        //
        // we can't copy more than a ULONG
        //
        if (HighPart(ullNeedToRead) != 0)
        {
            return E_FAIL;
        }
        ULONG ulToRead = LowPart(ullNeedToRead);
        //
        // allocate read buffer
        //
        BYTE * pbBuffer = new BYTE[ulToRead];
        if (pbBuffer == NULL)
        {
            return E_OUTOFMEMORY;
        }
        //
        // read from lockbytes
        //
        ULONG cbRead;
        ULARGE_INTEGER ullCursor;
        ullCursor.QuadPart = m_ullCursor;
        hr = m_pLockBytes->ReadAt(ullCursor, pbBuffer, ulToRead, &cbRead);
        if (FAILED(hr))
        {
            delete [] pbBuffer;
            return hr;
        }
        //
        // write to stream, and delete read buffer
        //
        ULONG cbWritten;
        hr = pstm->Write(pbBuffer, cbRead, &cbWritten);
        delete [] pbBuffer;
        if (FAILED(hr))
        {
            return hr;
        }
        //
        // mark how many read and how many written
        //
        ullRead = cbRead;
        ullWritten = cbWritten;
    }
    //
    // adjust cursor to skip the bytes that were read from this stream
    //
    m_ullCursor += ullRead;
    //
    // return results
    //
    if (pcbRead != NULL)
    {
        pcbRead->QuadPart = ullRead;
    }
    if (pcbWritten != NULL)
    {
        pcbWritten->QuadPart = ullWritten;
    }
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMyStream::Stat
//=--------------------------------------------------------------------------=
// IStream virtual function
// Returns information on stream
//
// Parameters:
//    pstatstg    [out] - where to put the information
//    grfStatFlag [in]  - whether to return the name of lockbytes or not (ignored)
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT STDMETHODCALLTYPE CMyStream::Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag)
{
    CS lock(m_critStm);
    //
    // get information from lockbytes
    //
    STATSTG statstg;
    ASSERTMSG(m_pLockBytes != NULL, "");
    HRESULT hr = m_pLockBytes->Stat(&statstg, grfStatFlag);
    if (FAILED(hr))
    {
        return hr;
    }
    //
    // change type to stream and return
    //
    statstg.type = STGTY_STREAM;
    *pstatstg = statstg;
    return NOERROR;    
}


//=--------------------------------------------------------------------------=
// CMyStream::Clone
//=--------------------------------------------------------------------------=
// IStream virtual function
// Returns another stream for the same data as this stream
//
// Parameters:
//    ppstm   [out] - returned IStream
//
// Output:
//
// Notes:
//
HRESULT STDMETHODCALLTYPE CMyStream::Clone( 
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    CS lock(m_critStm);
    //
    // create new stream class using our LockBytes (e.g same underlying data)
    //
    CMyStream *pcNewStream = new CMyStream(m_pLockBytes);
    if (pcNewStream == NULL)
    {
        return E_OUTOFMEMORY;
    }
    //
    // set cursor same as this cursor
    //
    pcNewStream->m_ullCursor = m_ullCursor;
    //
    // get IStream interface from the new stream class
    //
    IStream *pstm;
    HRESULT hr = pcNewStream->QueryInterface(IID_IStream, (void **)&pstm);
    if (FAILED(hr))
    {
        delete pcNewStream;
        return hr;
    }
    //
    // return results
    //
    *ppstm = pstm;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\mqoai_i_.c ===
#include <mqoai_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\management.h ===
//=--------------------------------------------------------------------------=
// management.h
//=--------------------------------------------------------------------------=
// Copyright  2001 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// The MSMQManagement object.
//
//
#ifndef _MSMQManagement_H_
#define _MSMQManagement_H_

#include "resrc1.h"       
#include "mq.h"
#include "dispids.h"

#include "oautil.h"
#include <cs.h>


typedef IDispatchImpl<
            IMSMQManagement, 
            &IID_IMSMQManagement, 
            &LIBID_MSMQ, 
            MSMQ_LIB_VER_MAJOR, 
            MSMQ_LIB_VER_MINOR
            > CDispImplIMSMQManagement;

typedef IDispatchImpl<
            IMSMQOutgoingQueueManagement,
            &IID_IMSMQOutgoingQueueManagement, 
            &LIBID_MSMQ, 
            MSMQ_LIB_VER_MAJOR, 
            MSMQ_LIB_VER_MINOR
            >CDispImplIMSMQOutgoingQueueManagement;

typedef	IDispatchImpl<
            IMSMQQueueManagement,
            &IID_IMSMQQueueManagement, 
            &LIBID_MSMQ, 
            MSMQ_LIB_VER_MAJOR, 
            MSMQ_LIB_VER_MINOR
            >CDispImplIMSMQQueueManagement;


class ATL_NO_VTABLE CMSMQManagement : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQManagement, &CLSID_MSMQManagement>,
	public ISupportErrorInfo,
	public CDispImplIMSMQManagement,
   	public CDispImplIMSMQOutgoingQueueManagement,
	public CDispImplIMSMQQueueManagement
{

public:

    CMSMQManagement();
    virtual ~CMSMQManagement();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQMANAGEMENT)

DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQManagement)
    COM_INTERFACE_ENTRY(IMSMQOutgoingQueueManagement)
    COM_INTERFACE_ENTRY(IMSMQQueueManagement)
 	COM_INTERFACE_ENTRY2(IMSMQManagement, IMSMQOutgoingQueueManagement)
	COM_INTERFACE_ENTRY2(IDispatch, IMSMQOutgoingQueueManagement)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(),
            &m_pUnkMarshaler.p
            );
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

    //
    // Critical section to guard object's data and be thread safe.
	// It is initialized to preallocate its resources with flag CCriticalSection::xAllocateSpinCount.
	// This means it may throw bad_alloc() on construction but not during usage.
    //
    CCriticalSection m_csObj;

public:
    
    HRESULT WINAPI InternalQueryInterface(
                                void* pThis,
                                const _ATL_INTMAP_ENTRY* pEntries, 
                                REFIID iid, 
                                void** ppvObject
                                );

public:

    //
    // ISupportsErrorInfo
    //

	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(Invoke)(
        DISPID dispidMember, 
        REFIID riid, 
        LCID lcid, 
        WORD wFlags, 
        DISPPARAMS* pdispparams, 
        VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, 
        UINT* puArgErr
        );
    STDMETHOD(GetIDsOfNames)(
        REFIID riid,
        LPOLESTR* rgszNames,
        UINT cNames,
        LCID lcid,
        DISPID* rgdispid
        );


public:
    
    //
    // IManagement
    //

    STDMETHOD(Init)(THIS_ VARIANT *pvMachineName, VARIANT *pvPathName, VARIANT *pvFormatName);
    STDMETHOD(get_FormatName)(THIS_ BSTR *pbstrFormatName);
    STDMETHOD(get_Machine)(THIS_ BSTR *pbstrMachine);
    STDMETHOD(get_MessageCount)(THIS_ long* plMessageCount);
    STDMETHOD(get_ForeignStatus)(THIS_ long* plForeignStatus);
    STDMETHOD(get_QueueType)(THIS_ long* plQueueType);
    STDMETHOD(get_IsLocal)(THIS_ VARIANT_BOOL* pfIsLocal);
    STDMETHOD(get_TransactionalStatus)(THIS_ long* plTransactionalStatus); 
    STDMETHOD(get_BytesInQueue)(THIS_ VARIANT* pvBytesInQueue);

    //
    // OutgoingQueueManagement
    //

    STDMETHOD(get_State)(THIS_ long* plQueueState);
    STDMETHOD(get_NextHops)(THIS_ VARIANT* pvNextHops);
    
    STDMETHOD(EodGetSendInfo)(THIS_ IMSMQCollection** ppCollection);
    STDMETHOD(Pause)(THIS);
    STDMETHOD(Resume)(THIS);
    STDMETHOD(EodResend)(THIS);

    //
    // QueueManagement
    //

    STDMETHOD(get_JournalMessageCount)(THIS_ long* plJournalMessageCount);
    STDMETHOD(get_BytesInJournal)(THIS_ VARIANT* pvBytesInJournal);
    STDMETHOD(EodGetReceiveInfo)(THIS_ VARIANT* pvGetInfo);


private:

    HRESULT 
    OapMgmtGetInfo(
        MGMTPROPID PropId,
        MQPROPVARIANT* pPropVar
        ) const;
    HRESULT OapMgmtAction(LPCWSTR Action)const;
    void OapEodGetReceiveInfo(VARIANT* pvGetInfo)const;
    void OapEodGetSendInfo(IMSMQCollection** ppICollection)const;

private:

    BOOL m_fIsLocal;
    BOOL m_fInitialized;
    CComBSTR m_Machine;
    CComBSTR m_FormatName;
    CComBSTR m_ObjectName;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\management.cpp ===
//=--------------------------------------------------------------------------=
// management.cpp
//=--------------------------------------------------------------------------=
// Copyright  2001  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//

#include "stdafx.h"
#include "dispids.h"
#include "oautil.h"
#include "management.h"
#include <mqmacro.h>
#include "collection.h"
#include <mqexception.h>


const MsmqObjType x_ObjectType = eMSMQManagement;


CMSMQManagement::CMSMQManagement():
                m_fInitialized(FALSE),
                m_csObj(CCriticalSection::xAllocateSpinCount),
                m_pUnkMarshaler(NULL)
{
};


CMSMQManagement::~CMSMQManagement()
{
}


STDMETHODIMP CMSMQManagement::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQManagement,
		&IID_IMSMQOutgoingQueueManagement,
		&IID_IMSMQQueueManagement,
	};
	for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); ++i)
	{
		if (InlineIsEqualGUID(*arr[i], riid))
			return S_OK;
	}
	return S_FALSE;
}


HRESULT
WINAPI 
CMSMQManagement::InternalQueryInterface(
                            void* pThis,
                            const _ATL_INTMAP_ENTRY* pEntries, 
                            REFIID iid, 
                            void** ppvObject
                            )
{
    if(iid == IID_IMSMQOutgoingQueueManagement)
    {
        if(!m_fInitialized)
        {
             return MQ_ERROR_UNINITIALIZED_OBJECT;
        }
        
        if(m_fIsLocal)
        {
            return E_NOINTERFACE;
        }
    }

    if(iid == IID_IMSMQQueueManagement)
    {
        if(!m_fInitialized)
        {
             return MQ_ERROR_UNINITIALIZED_OBJECT;
        }

        if(!m_fIsLocal)
        {
            return E_NOINTERFACE;
        }
    }

    return CComObjectRootEx<CComMultiThreadModel>::InternalQueryInterface(
                                                        pThis,
                                                        pEntries, 
                                                        iid, 
                                                        ppvObject
                                                        );
};


HRESULT
WINAPI 
CMSMQManagement::GetIDsOfNames(
        REFIID riid,
        LPOLESTR* rgszNames,
        UINT cNames,
        LCID lcid,
        DISPID* rgdispid
        )
{
    if(!m_fInitialized)
    {
        return CDispImplIMSMQManagement::GetIDsOfNames(
                    riid,
                    rgszNames,
                    cNames,
                    lcid,
                    rgdispid
                    );
    }
    
    if(m_fIsLocal)
    {
        return CDispImplIMSMQQueueManagement::GetIDsOfNames(
            riid,
            rgszNames,
            cNames,
            lcid,
            rgdispid
            );
    }

    return CDispImplIMSMQOutgoingQueueManagement::GetIDsOfNames(
            riid,
            rgszNames,
            cNames,
            lcid,
            rgdispid
            );
}


HRESULT 
WINAPI 
CMSMQManagement::Invoke(
                    DISPID dispidMember, 
                    REFIID riid, 
                    LCID lcid, 
                    WORD wFlags, 
                    DISPPARAMS* pdispparams, 
                    VARIANT* pvarResult,
                    EXCEPINFO* pexcepinfo, 
                    UINT* puArgErr
                    )
{
    if(!m_fInitialized)
    {
        return CDispImplIMSMQManagement::Invoke(
                    dispidMember, 
                    riid, 
                    lcid, 
                    wFlags, 
                    pdispparams, 
                    pvarResult,
                    pexcepinfo, 
                    puArgErr
                    );
    }

    if(m_fIsLocal)
    {
        return CDispImplIMSMQQueueManagement::Invoke(
                dispidMember, 
                riid, 
                lcid, 
                wFlags, 
                pdispparams, 
                pvarResult,
                pexcepinfo, 
                puArgErr
                );
    }

    return CDispImplIMSMQOutgoingQueueManagement::Invoke(
            dispidMember, 
            riid, 
            lcid, 
            wFlags, 
            pdispparams, 
            pvarResult,
            pexcepinfo, 
            puArgErr
            );
}


static HRESULT OapPathNameToFormatName(LPCWSTR pPathName, CComBSTR& FormatName)
{
    WCHAR aFormatName[FORMAT_NAME_INIT_BUFFER];
    DWORD length = FORMAT_NAME_INIT_BUFFER;
    HRESULT hr = MQPathNameToFormatName(
                        pPathName, 
                        aFormatName, 
                        &length
                        );

    if(SUCCEEDED(hr))
    {
        FormatName = aFormatName;
        if(FormatName.m_str == NULL)
        {
            return E_OUTOFMEMORY;
        }

        return MQ_OK;
    }
    
    if(hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
    {
        return hr;
    }
    
    //
    // MQPathNameToFormatName failed because the buffer was too small.
    //

    AP<WCHAR> pBuffer = new WCHAR[length];
    if(pBuffer == NULL)
    {
        return E_OUTOFMEMORY; 
    }

    hr = MQPathNameToFormatName(pPathName, pBuffer, &length);
    if FAILED(hr)
    {
        return hr;
    }

    FormatName = pBuffer.get();
    if(FormatName.m_str == NULL)
    {
        return E_OUTOFMEMORY; 
    }

    return MQ_OK;
}


static HRESULT OapGetCorrectedBstr(VARIANT* pvar, BSTR& bstr)
{
    if((pvar->vt == VT_EMPTY) || (pvar->vt == VT_NULL)  || (pvar->vt == VT_ERROR))
    {
        bstr = NULL;
        return MQ_OK;
    }

    HRESULT hr = GetTrueBstr(pvar, &bstr);
    if(FAILED(hr))
    {
        return hr;
    }
    if(SysStringLen(bstr) == 0)
    {
       bstr = NULL;
    }
    return MQ_OK;
}


//
// This function constructs a string: "QUEUE=FormatName" to use with MQMgmtGetInfo
//
static HRESULT OapGetObjectName(const CComBSTR& FormatName, CComBSTR& ObjectName)
{
    ObjectName = L"QUEUE=";
    if (ObjectName.m_str == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = ObjectName.Append(FormatName);
    if FAILED(hr)
    {
        return hr;
    }
    return MQ_OK;
}


//
// IManagement
//

HRESULT 
CMSMQManagement::Init(
                    VARIANT* pvMachineName,
                    VARIANT* pvPathName,
                    VARIANT* pvFormatName                            
                    )
{
    CS lock(m_csObj);

    if(m_fInitialized)
    {
        return CreateErrorHelper(HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED), x_ObjectType);
    }

    BSTR bstrMachineName, bstrPathName, bstrFormatName;
    HRESULT hr = OapGetCorrectedBstr(pvMachineName, bstrMachineName);
    if FAILED(hr)
    {
        return hr;
    }

    hr = OapGetCorrectedBstr(pvPathName, bstrPathName);
    if FAILED(hr)
    {
        return hr;
    }

    hr = OapGetCorrectedBstr(pvFormatName, bstrFormatName);
    if FAILED(hr)
    {
        return hr;
    }

    if( !((bstrPathName == NULL) ^ (bstrFormatName == NULL)) )
    {
        return CreateErrorHelper(MQ_ERROR_INVALID_PARAMETER, x_ObjectType);
    }

    if(bstrMachineName != NULL)
    {
        //
        // The user specified a Machin.
        //
        m_Machine = bstrMachineName;
        if(m_Machine.m_str == NULL)
        {
            return CreateErrorHelper(E_OUTOFMEMORY, x_ObjectType);
        }
    }
    
    if(bstrFormatName != NULL)
    {
        //
        // The user specified a FormatName
        //

        m_FormatName = bstrFormatName;
        if(m_FormatName.m_str == NULL)
        {
            return CreateErrorHelper(E_OUTOFMEMORY, x_ObjectType);
        }
    }
    if(bstrPathName != NULL)
    {
        //
        // The user specified a PathName
        //
     
        HRESULT hr = OapPathNameToFormatName(bstrPathName, m_FormatName);
        if(FAILED(hr)) 
        {
            return CreateErrorHelper(hr, x_ObjectType);
        }
    }

    m_fInitialized = TRUE;

    VARIANT_BOOL fIsLocal;
    hr = get_IsLocal(&fIsLocal);
    if(FAILED(hr))
    {
        m_fInitialized = FALSE;
        return CreateErrorHelper(hr, x_ObjectType);
    }

    m_fIsLocal = (fIsLocal == VARIANT_TRUE);

    hr = OapGetObjectName(m_FormatName, m_ObjectName);
    if FAILED(hr)
    {
        return CreateErrorHelper(hr, x_ObjectType);
    }

    return MQ_OK;
}


HRESULT CMSMQManagement::get_FormatName(BSTR *pbstrFormatName)
{
    CS lock(m_csObj);

    if(!m_fInitialized)
    {
         return CreateErrorHelper(MQ_ERROR_UNINITIALIZED_OBJECT, x_ObjectType);
    }

    *pbstrFormatName = SysAllocString(m_FormatName.m_str);
    if(pbstrFormatName == NULL)
    {
        return CreateErrorHelper(E_OUTOFMEMORY, x_ObjectType);
    }
    
    return MQ_OK;
}


HRESULT CMSMQManagement::get_Machine( BSTR *pbstrMachine)
{
    CS lock(m_csObj);

    if(!m_fInitialized)
    {
        return CreateErrorHelper(MQ_ERROR_UNINITIALIZED_OBJECT, x_ObjectType);
    }

    if(m_Machine.m_str != NULL)
    {
        //
        // Not the local machine.
        //

        *pbstrMachine = SysAllocString(m_Machine.m_str);
        if(*pbstrMachine == NULL)
        {
            return CreateErrorHelper(E_OUTOFMEMORY, x_ObjectType);
        }
    
        return MQ_OK;    
    }

    //
    // The Local Machine.
    //

    WCHAR MachineName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD MachineNameLength = TABLE_SIZE(MachineName);
   
    if (!GetComputerName(MachineName, &MachineNameLength))
    {
       return CreateErrorHelper(GetLastError(), x_ObjectType);
    }

    CharLower(MachineName);

    *pbstrMachine = SysAllocString(MachineName);
    if(*pbstrMachine == NULL)
    {
        return CreateErrorHelper(E_OUTOFMEMORY, x_ObjectType);
    }

    return MQ_OK;    
}


//
// Helper Functions
//


HRESULT CMSMQManagement::OapMgmtGetInfo(MGMTPROPID PropId, MQPROPVARIANT* pPropVar) const
{
    CComBSTR ObjectName;
    HRESULT hr = OapGetObjectName(m_FormatName, ObjectName);
    if FAILED(hr)
    {
        return hr;
    }

    pPropVar->vt = VT_NULL;
    MQMGMTPROPS MgmtProps;

    MgmtProps.cProp = 1;
    MgmtProps.aPropID = &PropId;
    MgmtProps.aPropVar = pPropVar;
    MgmtProps.aStatus = NULL;
    
    return MQMgmtGetInfo(
                    m_Machine,
                    ObjectName.m_str,
                    &MgmtProps
                    );
}


HRESULT CMSMQManagement::get_MessageCount( long* plMessageCount)
{
    CS lock(m_csObj);

    if(!m_fInitialized)
    {
       return CreateErrorHelper(MQ_ERROR_UNINITIALIZED_OBJECT, x_ObjectType);
    }

    MQPROPVARIANT PropVar;
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_QUEUE_MESSAGE_COUNT, &PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }
    
    ASSERTMSG(PropVar.vt == VT_UI4, "vt must be VT_UI4");
    
    *plMessageCount = PropVar.ulVal;
    
    return MQ_OK;
}


HRESULT CMSMQManagement::get_IsLocal(VARIANT_BOOL* pfIsLocal)
{
    CS lock(m_csObj);

    if(!m_fInitialized)
    {
        return CreateErrorHelper(MQ_ERROR_UNINITIALIZED_OBJECT, x_ObjectType);
    }

    MQPROPVARIANT PropVar;
    
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_QUEUE_LOCATION, &PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }

    ASSERTMSG(PropVar.vt == VT_LPWSTR, "vt must be VT_LPWSTR");
    
    LPCWSTR QueueLocation = PropVar.pwszVal;
    if(wcscmp(QueueLocation, MGMT_QUEUE_LOCAL_LOCATION) == 0)
    {
        *pfIsLocal = VARIANT_TRUE;
    }
    else if(wcscmp(QueueLocation, MGMT_QUEUE_REMOTE_LOCATION) == 0)
    {
        *pfIsLocal = VARIANT_FALSE;
    }
    else
    {
        ASSERTMSG(0, "Bad IsLocal value");
    }
    
    MQFreeMemory(PropVar.pwszVal);

    return MQ_OK;
}


HRESULT CMSMQManagement::get_QueueType(long* plQueueType)
{   
    CS lock(m_csObj);

    if(!m_fInitialized)
    {
        return CreateErrorHelper(MQ_ERROR_UNINITIALIZED_OBJECT, x_ObjectType);;
    }

    MQPROPVARIANT PropVar;
    
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_QUEUE_TYPE, &PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }
    
    ASSERTMSG(PropVar.vt == VT_LPWSTR, "vt must be VT_LPWSTR");
    
    LPCWSTR QueueType = PropVar.pwszVal;
    if(wcscmp(QueueType,MGMT_QUEUE_TYPE_PUBLIC) == 0)
    {
        *plQueueType = MQ_TYPE_PUBLIC;
    }
    else if(wcscmp(QueueType, MGMT_QUEUE_TYPE_PRIVATE) == 0)
    {
        *plQueueType = MQ_TYPE_PRIVATE;
    }
    else if(wcscmp(QueueType, MGMT_QUEUE_TYPE_MACHINE) == 0)
    {
        *plQueueType = MQ_TYPE_MACHINE;
    }
    else if(wcscmp(QueueType, MGMT_QUEUE_TYPE_CONNECTOR) == 0)
    {
        *plQueueType = MQ_TYPE_CONNECTOR;
    }
    else if(wcscmp(QueueType, MGMT_QUEUE_TYPE_MULTICAST) == 0)
    {
        *plQueueType = MQ_TYPE_MULTICAST;
    }
    else
    {
        ASSERTMSG(0, "Bad QueueType value");
    }
    
    MQFreeMemory(PropVar.pwszVal);

    return MQ_OK;
}


HRESULT CMSMQManagement::get_ForeignStatus(long* plForeignStatus)
{
    CS lock(m_csObj);

    if(!m_fInitialized)
    {
        return CreateErrorHelper(MQ_ERROR_UNINITIALIZED_OBJECT, x_ObjectType);;
    }

    MQPROPVARIANT PropVar;
    
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_QUEUE_FOREIGN, &PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }
   
    ASSERTMSG(PropVar.vt == VT_LPWSTR, "vt must be VT_LPWSTR");
    
    LPCWSTR ForeignStatus = PropVar.pwszVal;

    if(wcscmp(ForeignStatus,MGMT_QUEUE_CORRECT_TYPE) == 0)
    {
        *plForeignStatus = MQ_STATUS_FOREIGN;
    }
    else if(wcscmp(ForeignStatus, MGMT_QUEUE_INCORRECT_TYPE) == 0)
    {
        *plForeignStatus = MQ_STATUS_NOT_FOREIGN;
    }
    else if(wcscmp(ForeignStatus, MGMT_QUEUE_UNKNOWN_TYPE) == 0)
    {
        *plForeignStatus = MQ_STATUS_UNKNOWN;
    }
    else
    {
        ASSERTMSG(0, "Bad ForeignStatus value");
    }
    
    MQFreeMemory(PropVar.pwszVal);

    return MQ_OK;
}


HRESULT CMSMQManagement::get_TransactionalStatus(long* plTransactionalStatus)
{
    CS lock(m_csObj);

    if(!m_fInitialized)
    {
        return CreateErrorHelper(MQ_ERROR_UNINITIALIZED_OBJECT, x_ObjectType);
    }

    MQPROPVARIANT PropVar;
    
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_QUEUE_XACT, &PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }
   
    ASSERTMSG(PropVar.vt == VT_LPWSTR, "vt must be VT_LPWSTR");
    
    if(wcscmp(PropVar.pwszVal, MGMT_QUEUE_CORRECT_TYPE) == 0)
    {
        *plTransactionalStatus = MQ_XACT_STATUS_XACT;
    }
    else if(wcscmp(PropVar.pwszVal, MGMT_QUEUE_INCORRECT_TYPE) == 0)
    {
        *plTransactionalStatus = MQ_XACT_STATUS_NOT_XACT;
    }
    else if(wcscmp(PropVar.pwszVal, MGMT_QUEUE_UNKNOWN_TYPE) == 0)
    {
        *plTransactionalStatus = MQ_XACT_STATUS_UNKNOWN;
    }
    else
    {
        ASSERTMSG(0, "Bad TransactionalStatus value");
    }
    
    MQFreeMemory(PropVar.pwszVal);

    return MQ_OK;   
}


HRESULT CMSMQManagement::get_BytesInQueue(VARIANT* pvBytesInQueue)
{
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(MQ_ERROR_UNINITIALIZED_OBJECT, x_ObjectType);
    }

    MQPROPVARIANT PropVar;
    
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_QUEUE_BYTES_IN_QUEUE, &PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }
    
    ASSERTMSG(PropVar.vt == VT_UI4, "vt must be VT_UI4");

    pvBytesInQueue->vt = VT_UI8;
    pvBytesInQueue->ullVal = static_cast<ULONGLONG>(PropVar.ulVal);
    
    return MQ_OK;
}


//
// OutgoingQueueManagement
//

HRESULT CMSMQManagement::get_State(long* plQueueState)
{
    CS lock(m_csObj);

    MQPROPVARIANT PropVar;
    
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_QUEUE_STATE, &PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }
    
    ASSERTMSG(PropVar.vt == VT_LPWSTR, "vt must be VT_LPWSTR");
    
    LPCWSTR QueueState = PropVar.pwszVal;
    
    if(wcscmp(QueueState,MGMT_QUEUE_STATE_LOCAL) == 0)
    {
        *plQueueState = MQ_QUEUE_STATE_LOCAL_CONNECTION;
    }
    else if(wcscmp(QueueState, MGMT_QUEUE_STATE_DISCONNECTED) == 0)
    {
        *plQueueState = MQ_QUEUE_STATE_DISCONNECTED;
    }
    else if(wcscmp(QueueState, MGMT_QUEUE_STATE_LOCKED) == 0)
    {
        *plQueueState = MQ_QUEUE_STATE_LOCKED;
    }

    else if(wcscmp(QueueState, MGMT_QUEUE_STATE_WAITING) == 0)
    {
        *plQueueState = MQ_QUEUE_STATE_WAITING;
    }
    else if(wcscmp(QueueState, MGMT_QUEUE_STATE_NEED_VALIDATE) == 0)
    {
        *plQueueState = MQ_QUEUE_STATE_NEEDVALIDATE;
    }
    else if(wcscmp(QueueState, MGMT_QUEUE_STATE_ONHOLD) == 0)
    {
        *plQueueState = MQ_QUEUE_STATE_ONHOLD;
    }
    else if(wcscmp(QueueState, MGMT_QUEUE_STATE_NONACTIVE) == 0)
    {
        *plQueueState = MQ_QUEUE_STATE_NONACTIVE;   
    }
    else if(wcscmp(QueueState, MGMT_QUEUE_STATE_CONNECTED) == 0)
    {
        *plQueueState = MQ_QUEUE_STATE_CONNECTED;
    }
    else if(wcscmp(QueueState, MGMT_QUEUE_STATE_DISCONNECTING) == 0)
    {
        *plQueueState = MQ_QUEUE_STATE_DISCONNECTING;
    }
    else
    {
        ASSERTMSG(0, "Bad QueueState value");
    }
    
    MQFreeMemory(PropVar.pwszVal);

    return MQ_OK;
}


HRESULT CMSMQManagement::get_NextHops(VARIANT* pvNextHops)
{
    CS lock(m_csObj);

    MQPROPVARIANT PropVar;

    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_QUEUE_NEXTHOPS, &PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }

    if(PropVar.vt == VT_NULL)
    {
        PropVar.vt = VT_VECTOR | VT_LPWSTR;
        PropVar.calpwstr.cElems = 0;
        PropVar.calpwstr.pElems = NULL;
    }

    ASSERTMSG(PropVar.vt == (VT_VECTOR | VT_LPWSTR), "vt must be VT_VECTOR|VT_LPWSTR");

    hr = VariantStringArrayToBstringSafeArray(PropVar, pvNextHops);
    OapArrayFreeMemory(PropVar.calpwstr);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }

    return MQ_OK;
}


HRESULT CMSMQManagement::EodGetSendInfo(IMSMQCollection** ppCollection)
{
    try
    {
        OapEodGetSendInfo(ppCollection);
        return MQ_OK;
    }
    catch(const bad_hresult e)
    {
        return CreateErrorHelper(e.error(), x_ObjectType);
    }
}


//
// Helper Function
//

HRESULT CMSMQManagement::OapMgmtAction(LPCWSTR Action) const
{
    CComBSTR ObjectName;
    HRESULT hr = OapGetObjectName(m_FormatName, ObjectName);
    if FAILED(hr)
    {
        return hr;
    }

    hr = MQMgmtAction(
                m_Machine,
                ObjectName.m_str,
                Action
                );
    
    return hr;
}


HRESULT CMSMQManagement::Pause()
{
    CS lock(m_csObj);

    HRESULT hr = OapMgmtAction(QUEUE_ACTION_PAUSE);
    
    return CreateErrorHelper(hr, x_ObjectType);
}


HRESULT CMSMQManagement::Resume()
{
    CS lock(m_csObj);

    HRESULT hr = OapMgmtAction(QUEUE_ACTION_RESUME);
        
    return CreateErrorHelper(hr, x_ObjectType);
}


HRESULT CMSMQManagement::EodResend()
{
    CS lock(m_csObj);

    HRESULT hr = OapMgmtAction(QUEUE_ACTION_EOD_RESEND);
        
    return CreateErrorHelper(hr, x_ObjectType);
}


//
// QueueManagement
//

HRESULT CMSMQManagement::get_JournalMessageCount(long* plJournalMessageCount)
{
    CS lock(m_csObj);

    MQPROPVARIANT PropVar;
    
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT, &PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }
    
    ASSERTMSG(PropVar.vt == VT_UI4, "vt must be VT_UI4");

    *plJournalMessageCount = PropVar.ulVal;
    
    return MQ_OK;
}


HRESULT CMSMQManagement::get_BytesInJournal(VARIANT* pvBytesInJournal)
{
    CS lock(m_csObj);

    MQPROPVARIANT PropVar;
    
    HRESULT hr = OapMgmtGetInfo(PROPID_MGMT_QUEUE_BYTES_IN_JOURNAL, &PropVar);
    if(FAILED(hr))
    {
       return CreateErrorHelper(hr, x_ObjectType);
    }
    
    ASSERTMSG(PropVar.vt == VT_UI4, "vt must be VT_UI4");

    pvBytesInJournal->vt = VT_UI8;
    pvBytesInJournal->ullVal = static_cast<ULONGLONG>(PropVar.ulVal);
   
    return MQ_OK;
}


HRESULT CMSMQManagement::EodGetReceiveInfo(VARIANT* pvGetInfo)
{
    VariantInit(pvGetInfo);
    pvGetInfo->vt = VT_ARRAY|VT_VARIANT;
 
    try
    {
        OapEodGetReceiveInfo(pvGetInfo);
        return MQ_OK;
    }
    catch(bad_hresult& e)
    {
        return CreateErrorHelper(e.error(), x_ObjectType);
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\istm.h ===
//--------------------------------------------------------------------------=
// istm.H
//=--------------------------------------------------------------------------=
// Copyright  2000  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// Definition of IStream on ILockBytes
//
#ifndef _ISTM_H_
#define _ISTM_H_

#include <windows.h>

class CMyStream: public IStream
{
public:
    //
    // IUnknown
    //
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    virtual ULONG STDMETHODCALLTYPE AddRef( void);
        
    virtual ULONG STDMETHODCALLTYPE Release( void);

    //
    // ISequentialStream in addition to IUnknown
    //
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read( 
        /* [length_is][size_is][out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead);
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write( 
        /* [size_is][in] */ const void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbWritten);

    //
    // IStream in addition to ISequentialStream
    //
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek( 
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition);
    
    virtual HRESULT STDMETHODCALLTYPE SetSize( 
        /* [in] */ ULARGE_INTEGER libNewSize);
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo( 
        /* [unique][in] */ IStream __RPC_FAR *pstm,
        /* [in] */ ULARGE_INTEGER cb,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten);
    
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        /* [in] */ DWORD /*grfCommitFlags*/ )
    {
        return NOERROR;
    }
    
    virtual HRESULT STDMETHODCALLTYPE Revert( void)
    {
        return NOERROR;
    }
    
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
        /* [in] */ ULARGE_INTEGER /*libOffset*/ ,
        /* [in] */ ULARGE_INTEGER /*cb*/ ,
        /* [in] */ DWORD /*dwLockType*/ )
    {
        return STG_E_INVALIDFUNCTION;
    }
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
        /* [in] */ ULARGE_INTEGER /*libOffset*/ ,
        /* [in] */ ULARGE_INTEGER /*cb*/ ,
        /* [in] */ DWORD /*dwLockType*/)
    {
        return STG_E_INVALIDFUNCTION;
    }
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        /* [out] */ STATSTG __RPC_FAR *pstatstg,
        /* [in] */ DWORD grfStatFlag);
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);

    //
    // Class
    //
    CMyStream(ILockBytes * pLockBytes);

    virtual ~CMyStream();

    static HRESULT STDMETHODCALLTYPE CreateInstance(
            /* [in] */ ILockBytes * pLockBytes,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject)
    {
        if (pLockBytes == NULL)
        {
            return E_INVALIDARG;
        }

        CMyStream *pcMyStream;

		try
		{
			pcMyStream = new CMyStream(pLockBytes);
		}
		catch(const std::bad_alloc&)
		{
			//
			// Exception might be thrown while constructing the 
			// critical section member of the MSMQ object.
			//
			return E_OUTOFMEMORY;
		}

        if (pcMyStream == NULL)
        {
            return E_OUTOFMEMORY;
        }

        HRESULT hr = pcMyStream->QueryInterface(riid, ppvObject);
        if (FAILED(hr))
        {
            delete pcMyStream;
        }        
        return hr;
   }

//private:

private:
	//
	// Critical section is initialized to preallocate its resources 
	// with flag CCriticalSection::xAllocateSpinCount. This means it may throw bad_alloc() on 
	// construction but not during usage.
	//
    CCriticalSection m_critStm;
    LONG m_cRef;
    ILockBytes * m_pLockBytes;
    ULONGLONG m_ullCursor;
};

#endif //_ISTM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\mqoa.cpp ===
//=--------------------------------------------------------------------------=
// mqoa.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// various routines et all that aren't in a file for a particular automation
// object, and don't need to be in the generic ole automation code.
//
//
#include "stdafx.h"
#include "initguid.h"
#include "oautil.h"
#include "Query.H"
#include "qinfo.H"
#include "q.h"
#include "msg.H"
#include "qinfos.H"
#include "mqsymbls.h"
#include "xact.h"
#include "xdisper.h"
#include "xdispdtc.h"
#include "app.h"
#include "dest.h"
#include "management.h"
#include "guids.h"
#include "mqnames.h"
#include "cs.h"
#include <mqexception.h>
#include "_mqres.h"
#include "debug.h"
#include "debug_thread_id.h"
#include "event.h"
#include <strsafe.h>


//  Tracing stuff that should be added
//  #include <tr.h>
//
// 	#include "detect.tmh"
//

const WCHAR MQOA10_TLB[] = L"mqoa10.tlb";
const WCHAR MQOA20_TLB[] = L"mqoa20.tlb";
const WCHAR MQOA_ARRIVED_MSGID_STR[] = L"mqoaArrived";
const WCHAR MQOA_ARRIVED_ERROR_MSGID_STR[] = L"mqoaArrivedError";

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MSMQQuery,                CMSMQQuery)
	OBJECT_ENTRY(CLSID_MSMQMessage,              CMSMQMessage)
	OBJECT_ENTRY(CLSID_MSMQQueue,                CMSMQQueue)
	OBJECT_ENTRY(CLSID_MSMQEvent,                CMSMQEvent)
	OBJECT_ENTRY(CLSID_MSMQQueueInfo,            CMSMQQueueInfo)
    OBJECT_ENTRY(CLSID_MSMQQueueInfos,           CMSMQQueueInfos)
    OBJECT_ENTRY(CLSID_MSMQTransaction,          CMSMQTransaction)
	OBJECT_ENTRY(CLSID_MSMQCoordinatedTransactionDispenser, CMSMQCoordinatedTransactionDispenser)
	OBJECT_ENTRY(CLSID_MSMQTransactionDispenser, CMSMQTransactionDispenser)
	OBJECT_ENTRY(CLSID_MSMQApplication,          CMSMQApplication)
	OBJECT_ENTRY(CLSID_MSMQDestination,          CMSMQDestination)
    OBJECT_ENTRY(CLSID_MSMQManagement,           CMSMQManagement)
END_OBJECT_MAP()

//
// keep in the same order as MsmqObjType enum (oautil.h)
//
MsmqObjInfo g_rgObjInfo[] = {
  {"MSMQQuery",                           &IID_IMSMQQuery3},
  {"MSMQMessage",                         &IID_IMSMQMessage3},
  {"MSMQQueue",                           &IID_IMSMQQueue3},
  {"MSMQEvent",                           &IID_IMSMQEvent3},
  {"MSMQQueueInfo",                       &IID_IMSMQQueueInfo3},
  {"MSMQQueueInfos",                      &IID_IMSMQQueueInfos3},
  {"MSMQTransaction",                     &IID_IMSMQTransaction3},
  {"MSMQCoordinatedTransactionDispenser", &IID_IMSMQCoordinatedTransactionDispenser3},
  {"MSMQTransactionDispenser",            &IID_IMSMQTransactionDispenser3},
  {"MSMQApplication",                     &IID_IMSMQApplication3},
  {"MSMQDestination",                     &IID_IMSMQDestination},
  {"MSMQManagement",                      &IID_IMSMQManagement},
  {"MSMQCollection",                      &IID_IMSMQCollection}
};

//
// We get a reference to the GIT (Global Interface Table) before we manipulate
// our COM objects. This is needed because we are Both threaded, and aggregate the Free-Threaded-marshaler,
// therefore we need to store ALL interface pointers that are object members, and are stored
// between calls as marshaled interfaces, because they can be used by us directly from a different thread
// (apartment) than they were set (or intended to be used)
//
IGlobalInterfaceTable * g_pGIT = NULL;
//
// We obtain unique winmsg ids for Arrived and ArrivedError in the first call to
// DllGetClassObject. If we can't get unique ID's mqoa will not load.
//
UINT g_uiMsgidArrived      = 0;
UINT g_uiMsgidArrivedError = 0;
//
// Support dep client with MSMQ2.0 functionality
//
BOOL g_fDependentClient = FALSE;
//
// we want to do complex initialization before the first class factory
// is created (e.g. before any of our objects are used). This complex initialization
// cannot be done in DllMain (e.g. in the existing InitializeLibrary())
// because according to MSDN complex actions (other than TLS, synchronization and
// file system function) might load other dlls and/or cause deadlock in DllMain.
// Below are the critical section object and the flag which are used to verify
// that the initialization is done by only one thread.
//
CCriticalSection g_csComplexInit;
BOOL g_fComplexInit = FALSE;

void InitializeLibrary();
void UninitializeLibrary(LPVOID lpReserved);
static HRESULT DoComplexLibraryInitIfNeeded();
EXTERN_C BOOL APIENTRY RTIsDependentClient(); //implemented in mqrt.dll

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		try
		{
			InitializeLibrary();
			_Module.Init(ObjectMap, hInstance);
			DisableThreadLibraryCalls(hInstance);
		}
		catch(const std::exception&)
		{
			return FALSE;
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		_Module.Term();
		UninitializeLibrary(lpReserved);
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        //
        // we want to do complex initialization before the first class factory
        // is created (e.g. before any of our objects are used). This complex initialization
        // cannot be done in DllMain (e.g. in the existing InitializeLibrary())
        // because according to MSDN complex actions (other than TLS, synchronization and
        // file system function) might load other dlls and/or cause deadlock in DllMain
        //
        HRESULT hr = DoComplexLibraryInitIfNeeded();
        if (FAILED(hr))
        {
          return hr;
        }

        return _Module.GetClassObject(rclsid, riid, ppv);
}

//=-------------------------------------------------------------------------=
// Helper - ComputeModuleDirectory
//=-------------------------------------------------------------------------=
// Called to retrieve the directory path (ended with '\\') of the current module
// e.g. d:\winnt\system32\ for mqoa.dll
//
// Parameters:
//	pwszBuf	[in] - Buffer to store the directory
//	cchBuf  [in] - number of characters in the buffer
//      pcchBuf [out]- number of characters stored in the buffer (not including NULL term)
//	
static HRESULT ComputeModuleDirectory(WCHAR * pwszBuf, ULONG cchBuf, ULONG_PTR * pcchBuf)
{
  //
  // get module filename
  //
  DWORD cchModule = GetModuleFileName(_Module.GetModuleInstance(), pwszBuf, cchBuf-1);
  if (cchModule == 0) {
    return HRESULT_FROM_WIN32(GetLastError());
  }
  if (cchModule == cchBuf-1) 
  {
	//
    // The file name is too long, return an error.
	//
	return CO_E_PATHTOOLONG;
  }

  //
  // find last backslash
  //
  LPWSTR lpwszBS = wcsrchr(pwszBuf, L'\\');
  if (lpwszBS == NULL) {
    return E_FAIL;
  }
  //
  // set the string to end after last backslash 
  //
  *(lpwszBS+1) = L'\0';
  *pcchBuf = lpwszBS + 1 - pwszBuf;
  return NOERROR;
}
  

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer(FALSE);
    if (SUCCEEDED(hr))
	{
        long	lRegResult;
		HKEY	hMSMQAppIdKey;
		lRegResult = RegOpenKeyEx(HKEY_CLASSES_ROOT,
								  L"AppID\\{DCBCADF5-DB1b-4764-9320-9a5082af1581}",
								  0,
								  KEY_WRITE,
								  &hMSMQAppIdKey);
		if (lRegResult == ERROR_SUCCESS)
		{
			lRegResult = RegSetValueEx(hMSMQAppIdKey,
									   L"DllSurrogate",
									   0,
									   REG_SZ,
									   (const BYTE *)" ",
									   //NULL,
									   2);
				
			if (lRegResult != ERROR_SUCCESS)
			{
				hr = HRESULT_FROM_WIN32(lRegResult);
			}
				
			RegCloseKey(hMSMQAppIdKey);
		} 
		else
		{
			//
			// Could not read key from registry
			//
			hr = REGDB_E_READREGDB;
		}
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer(FALSE);
        		
		//
		// remove DllSurrogate value from 
		// [HKEY_CLASSES_ROOT\AppID\{DCBCADF5-DB1b-4764-9320-9a5082af1581}]
		// This allows the machine return to be DCOM Client for MQOA
		//

		long	lRegResult;
		HKEY	hMSMQAppIdKey;
		lRegResult = RegOpenKeyEx(HKEY_CLASSES_ROOT,
								  L"AppID\\{DCBCADF5-DB1b-4764-9320-9a5082af1581}",
								  0,
								  KEY_WRITE,
								  &hMSMQAppIdKey);
		if (lRegResult == ERROR_SUCCESS)
		{
			lRegResult = RegDeleteValue(hMSMQAppIdKey,
				                        L"DllSurrogate");

			RegCloseKey(hMSMQAppIdKey);

			// 
			// If the value "DllSurrogate" does not exist this is ok since this
			// is our desired end result
			//
			if ((lRegResult != ERROR_SUCCESS) && (lRegResult != ERROR_FILE_NOT_FOUND))
			{
				return HRESULT_FROM_WIN32(lRegResult);
			}
				
		} 
		else
		{
			//
			// Could not read key from registry
			//
			return REGDB_E_READREGDB;
		}

	return S_OK;
}


#ifdef _DEBUG
extern VOID RemBstrNode(void *pv);
#endif // _DEBUG

// debug...
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#endif // _DEBUG



WNDCLASSA g_wndclassAsyncRcv;
ATOM g_atomWndClass;

//=--------------------------------------------------------------------------=
// IntializeLibrary
//=--------------------------------------------------------------------------=
// called from DllMain:DLL_PROCESS_ATTACH.  allows the user to do any sort of
// initialization they want to.
//
// Notes:
//#2619 RaananH Multithread async receive
//
void InitializeLibrary
(
    void
)
{
    // TODO: initialization here.  control window class should be set up in
    // RegisterClassData.

    //
    // #2619 register our Async Rcv window class
    // we do it here instead of in the first CreateHiddenWindow because it is a light operation
    // and otherwise we would have to get into a critical section in each CreateHiddenWindow
    // and we want to avoid that.
    //
    memset(&g_wndclassAsyncRcv, 0, sizeof(WNDCLASSA));
    g_wndclassAsyncRcv.lpfnWndProc = CMSMQEvent_WindowProc;
    g_wndclassAsyncRcv.lpszClassName = "MSMQEvent";
    // can use ANSI version
    g_wndclassAsyncRcv.hInstance = GetModuleHandleA(NULL);
    //
    // reserve space for a pointer to the event object that created this window
    //
    g_wndclassAsyncRcv.cbWndExtra = sizeof(LONG_PTR);
    g_atomWndClass = RegisterClassA(&g_wndclassAsyncRcv); // use ANSI version
    if(g_atomWndClass == NULL)
    {
    	DWORD gle = GetLastError();
        throw bad_hresult(HRESULT_FROM_WIN32(gle));
    }
}

extern void DumpMemLeaks();
extern void DumpBstrLeaks();

//=--------------------------------------------------------------------------=
// UninitializeLibrary
//=--------------------------------------------------------------------------=
// called from DllMain:DLL_PROCESS_DETACH.  allows the user to clean up anything
// they want.
//
// Notes:
//#2619 RaananH Multithread async receive
//
void UninitializeLibrary(LPVOID lpReserved)
{
    // TODO: uninitialization here.  control window class will be unregistered
    // for you, but anything else needs to be cleaned up manually.
    // Please Note that the Window 95 DLL_PROCESS_DETACH isn't quite as stable
    // as NT's, and you might crash doing certain things here ...

#ifdef _DEBUG
    DumpMemLeaks();
    DumpBstrLeaks();
#endif //_DEBUG

#if 0
    //
    // UNDONE: for beta2 let this leak, need to synch
    //  with mqrt.dll unload via a common critsect
    //  so that async thread termination/callback
    //  does the right thing.
    //
#endif // 0
    //
    // release our global transaction manager: if allocated
    //  at all by a call to BeginTransaction
    //
    RELEASE(CMSMQCoordinatedTransactionDispenser::m_ptxdispenser);

    //
    // #2619 unregister our Async Rcv window class
    //
    BOOL fUnregistered = UnregisterClassA(
                            g_wndclassAsyncRcv.lpszClassName,
                            g_wndclassAsyncRcv.hInstance
                            );
    UNREFERENCED_PARAMETER(fUnregistered);
	UNREFERENCED_PARAMETER(lpReserved);

#ifdef _DEBUG
    if (!fUnregistered && (lpReserved == NULL))
    {
		//
		// lpReserved == NULL, Meens that the process did not terminate.
		//
        DWORD dwErr = GetLastError();

		ASSERTMSG(dwErr == ERROR_CANNOT_FIND_WND_CLASS || dwErr == ERROR_CLASS_DOES_NOT_EXIST, "hmm... couldn't unregister window class.");
    }
#endif // _DEBUG
#if 0
    // UNDONE: 2028: DTC can't be unloaded...
    //
    // Free DTC proxy library - if it was loaded
    //
    if (CMSMQCoordinatedTransactionDispenser::m_hLibDtc) {
      FreeLibrary(CMSMQCoordinatedTransactionDispenser::m_hLibDtc);
      CMSMQCoordinatedTransactionDispenser::m_hLibDtc = NULL;
    }
#endif // 0 
}


#if 0
//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// we'll just define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
// extern "C" int __cdecl _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
  FAIL("Pure virtual function called.");
  return 0;
}
#endif //0

//=--------------------------------------------------------------------------=
// CreateErrorHelper
//=--------------------------------------------------------------------------=
// fills in the rich error info object so that both our vtable bound interfaces
// and calls through ITypeInfo::Invoke get the right error informaiton.
//
// Parameters:
//    HRESULT          - [in] the SCODE that should be associated with this err
//    MsmqObjType      - [in] object type
//
// Output:
//    HRESULT          - the HRESULT that was passed in.
//
// Notes:
//
HRESULT CreateErrorHelper(
    HRESULT hrExcep,
    MsmqObjType eObjectType)
{
    return SUCCEEDED(hrExcep) ? 
             hrExcep :
             CreateError(
               hrExcep,
               (GUID *)g_rgObjInfo[eObjectType].piid,
               g_rgObjInfo[eObjectType].szName);
}


//=-------------------------------------------------------------------------=
// DLLGetDocumentation
//=-------------------------------------------------------------------------=
// Called by OLEAUT32.DLL for ITypeInfo2::GetDocumentation2.  This gives us
// a chance to return a localized string for a given help context value.
//
// Parameters:
//	ptlib	[in] - TypeLib associated w/ help context
//	ptinfo  [in]-  TypeInfo associated w/ help context
//      dwHelpStringContext - [in] Cookie value representing the help context
//				   id being looked for.
//	pbstrHelpString - [out] localized help string associated with the
//				context id passed in.
//	
STDAPI DLLGetDocumentation
(
  ITypeLib * /*ptlib*/ , 
  ITypeInfo * /*ptinfo*/ ,
  LCID lcid,
  DWORD dwCtx,
  BSTR * pbstrHelpString
)
{
LPSTR szDllFile="MQUTIL.DLL";
LCID tmpLCID;

	//
	// Added the code below to avoid compile error for unrefernce parameter
	//
	tmpLCID = lcid;
    if (pbstrHelpString == NULL)
      return E_POINTER;
    *pbstrHelpString = NULL;

    if (!GetMessageOfId(dwCtx, 
                        szDllFile, 
                        FALSE, /* fUseDefaultLcid */
                        pbstrHelpString)) 
	{
    
		return TYPE_E_ELEMENTNOTFOUND;
    }
#ifdef _DEBUG
    RemBstrNode(*pbstrHelpString);  
#endif // _DEBUG
    return S_OK;
}

//=-------------------------------------------------------------------------=
// Helper - GetUniqueWinmsgIds
//=-------------------------------------------------------------------------=
// We need to obtain unique window message ids for posting Arrived and ArrivedError
// We can't use WM_USER for that because this interferes with other components that
// subclass our event window (like COM+).
//	
static HRESULT GetUniqueWinmsgIds(UINT *puiMsgidArrived, UINT *puiMsgidArrivedError)
{
  //
  // Arrived
  //
  UINT uiMsgidArrived = RegisterWindowMessage(MQOA_ARRIVED_MSGID_STR);
  ASSERTMSG(uiMsgidArrived != 0, "RegisterWindowMessage(Arrived) failed.");
  if (uiMsgidArrived == 0) {
    return GetWin32LastErrorAsHresult();
  }
  //
  // ArrivedError
  //
  UINT uiMsgidArrivedError = RegisterWindowMessage(MQOA_ARRIVED_ERROR_MSGID_STR);
  ASSERTMSG(uiMsgidArrivedError != 0, "RegisterWindowMessage(ArrivedError) failed.");
  if (uiMsgidArrivedError == 0) {
    return GetWin32LastErrorAsHresult();
  }    
  //
  // return results
  //
  *puiMsgidArrived = uiMsgidArrived;
  *puiMsgidArrivedError = uiMsgidArrivedError;
  return S_OK;
}

//=-------------------------------------------------------------------------=
// Helper - DoComplexLibraryInit
//=-------------------------------------------------------------------------=
// We want to do some complex initialization before any of our objects are used.
// This initialization is called complex because it cannot be done in DllMain
// (e.g. in the existing InitializeLibrary()) because according to MSDN complex
// actions (e.g. other than TLS, synchronization and file system function) might
// load other dlls and/or cause deadlock in DllMain.
// This routine is called by DoComplexLibraryInit which makes sure it is run only once
//	
static HRESULT DoComplexLibraryInit()
{
  HRESULT hr;
  //
  // Get the global GIT instance
  //
  R<IGlobalInterfaceTable> pGIT;
  hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_ALL,
                        IID_IGlobalInterfaceTable, (void**)&pGIT.ref());
  if (FAILED(hr))
  {
    return hr;
  }
  //
  // Obtain unique window msgid's for posting Arrived/ArrivedError
  //
  UINT uiMsgidArrived, uiMsgidArrivedError;
  hr = GetUniqueWinmsgIds(&uiMsgidArrived, &uiMsgidArrivedError);
  if (FAILED(hr))
  {
    return hr;
  }
  //
  // Check if we are a dependent client or not
  //
  g_fDependentClient = RTIsDependentClient();
  //
  // return results
  //
  g_pGIT = pGIT.detach();
  g_uiMsgidArrived = uiMsgidArrived;
  g_uiMsgidArrivedError = uiMsgidArrivedError;
  return S_OK;
}

//=-------------------------------------------------------------------------=
// Helper - DoComplexLibraryInitIfNeeded
//=-------------------------------------------------------------------------=
// We want to do some complex initialization before any of our objects are used.
// This initialization is called complex because it cannot be done in DllMain
// (e.g. in the existing InitializeLibrary()) because according to MSDN complex
// actions (e.g. other than TLS, synchronization and file system function) might
// load other dlls and/or cause deadlock in DllMain.
// This routine checks if the dll is not initialized yet, and does the initialization
// if needed.
// This routine is called by DllGetClassObject. This way we can initialize the dll
// before any of our objects are created.
//	
static HRESULT DoComplexLibraryInitIfNeeded()
{
	try
	{
		CS lock(g_csComplexInit);

		//
		// if already initialized return immediately
		//
		if (g_fComplexInit)
		{
			return S_OK;
		}
		//
		// not initialized, do initialization
		//
		HRESULT hr = DoComplexLibraryInit();
		if (FAILED(hr))
		{
			return hr;
		}
		//
		// mark init succeeded
		//
		g_fComplexInit = TRUE;

		return S_OK;
	}
	catch(const std::bad_alloc&)
	{
		//
		// Exception could have been thrown by CS consruction.
		//
		return E_OUTOFMEMORY;
	}
}


//
// This function takes an array of wstrings from an MSMQ Variant and places it
// inside a COM Variant as a SafeArray of Variants of bstrings.
//
HRESULT 
VariantStringArrayToBstringSafeArray(
                        const MQPROPVARIANT& PropVar, 
                        VARIANT* pOleVar
                        )  
{
    SAFEARRAYBOUND bounds = {PropVar.calpwstr.cElems, 0};
    SAFEARRAY* pSA = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    if(pSA == NULL)
    {
        return E_OUTOFMEMORY;
    }

    VARIANT HUGEP* aVar;
    HRESULT hr = SafeArrayAccessData(pSA, reinterpret_cast<void**>(&aVar));
    if (FAILED(hr))
    {
        return hr;
    }

    for (UINT i = 0; i < PropVar.calpwstr.cElems; ++i)
    {
        aVar[i].vt = VT_BSTR;
        aVar[i].bstrVal = SysAllocString((PropVar.calpwstr.pElems)[i]); 
        if(aVar[i].bstrVal == NULL)
        {
            SafeArrayUnaccessData(pSA);
            //
            // SafeArrayDestroy calls VariantClear for all elements. 
            // VariantClear frees the string.
            //
            SafeArrayDestroy(pSA);
            return E_OUTOFMEMORY;
        }
    }

    hr = SafeArrayUnaccessData(pSA);
    ASSERTMSG(SUCCEEDED(hr), "SafeArrayUnaccessData must succeed!");

    VariantInit(pOleVar);
    pOleVar->vt = VT_ARRAY|VT_VARIANT;
    pOleVar->parray = pSA;
    return MQ_OK;
}


void OapArrayFreeMemory(CALPWSTR& calpwstr)
{
    for(UINT i = 0 ;i < calpwstr.cElems; ++i)
    {
        MQFreeMemory(calpwstr.pElems[i]);
    }
    MQFreeMemory(calpwstr.pElems);
}


void
OapFreeVariant(PROPVARIANT& var)
{
    ULONG i;
    switch (var.vt)
    {
        case VT_CLSID:
            MQFreeMemory(var.puuid);
            break;

        case VT_LPWSTR:
            MQFreeMemory(var.pwszVal);
            break;

        case VT_BLOB:
            MQFreeMemory(var.blob.pBlobData);
            break;

        case (VT_I4 | VT_VECTOR):
            MQFreeMemory(var.cal.pElems);
            break;

        case (VT_UI4 | VT_VECTOR):
            MQFreeMemory(var.caul.pElems);
            break;

        case (VT_UI8 | VT_VECTOR):
            MQFreeMemory(var.cauh.pElems);
            break;

        case (VT_VECTOR | VT_CLSID):
            MQFreeMemory(var.cauuid.pElems);
            break;

        case (VT_VECTOR | VT_LPWSTR):
            for(i = 0; i < var.calpwstr.cElems; i++)
            {
                MQFreeMemory(var.calpwstr.pElems[i]);
            }
            MQFreeMemory(var.calpwstr.pElems);
            break;

        case (VT_VECTOR | VT_VARIANT):
            for(i = 0; i < var.capropvar.cElems; i++)
            {
                OapFreeVariant(var.capropvar.pElems[i]);
            }

            MQFreeMemory(var.capropvar.pElems);
            break;

        default:
            break;
    }
    var.vt = VT_NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\oautil.h ===
//=--------------------------------------------------------------------------=
// oautil.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// MQOA utilities header
//
//
#ifndef _OAUTIL_H_

// Falcon is UNICODE
#ifndef UNICODE
#define UNICODE 1
#endif

#include "mqoai.h"
#include "txdtc.h"             // transaction support.
#include "utilx.h"
#include "mq.h"
#include "debug.h"
#include "autoptr.h"

//
// enforce that we return 1 for true and 0 for false.
// It was decided not to fix #3715 - we do not return VARIANT_TRUE (-1) as TRUE, but the value 1 -
// Either TRUE (windef.h), or C's bool operator (e.g. (expression)) or propids from MSMQ that return
// 1 or 0.
// The fix was to return -1 for true, but this would break VB apps that probably hacked
// around this bug by seeing that the value is 1 and acting accordingly.
//
#define CONVERT_TRUE_TO_1_FALSE_TO_0(boolVal) ((boolVal) ? 1 : 0)

//
// enforce that we return VARIANT_TRUE for true and VARIANT_FALSE for false
//
#define CONVERT_BOOL_TO_VARIANT_BOOL(boolVal) ((boolVal) ? VARIANT_TRUE : VARIANT_FALSE)

// MSGOP: used by CreateMessageProperties
enum MSGOP {
    MSGOP_Send,
    MSGOP_Receive,
    MSGOP_AsyncReceive
};



// Memory tracking allocation
void* __cdecl operator new(
    size_t nSize, 
    LPCSTR lpszFileName, 
    int nLine);
#if _MSC_VER >= 1200
void __cdecl operator delete(void* pv, LPCSTR, int);
#endif //_MSC_VER >= 1200
void __cdecl operator delete(void* pv);

#ifdef _DEBUG
#define DEBUG_NEW new(__FILE__, __LINE__)
#else
#define DEBUG_NEW new
#endif // _DEBUG

// bstr tracking
void DebSysFreeString(BSTR bstr);
BSTR DebSysAllocString(const OLECHAR FAR* sz);
BSTR DebSysAllocStringLen(const OLECHAR *sz, unsigned int cch);
BSTR DebSysAllocStringByteLen(const OLECHAR *sz, unsigned int cb);
BOOL DebSysReAllocString(BSTR *pbstr, const OLECHAR *sz);
BOOL DebSysReAllocStringLen(
    BSTR *pbstr, 
    const OLECHAR *sz, 
    unsigned int cch);

// Default initial body and format name buffer sizes
#define BODY_INIT_SIZE 2048 
//
// The init sizes below for format names are just init sizes, there is a realloc
// upon msg receive to the proper size if needed. So we keep one size of init buffer for
// format names that define one queue, and another init size for formatnames that
// can hold mqf sizes. Again - even the "smaller" can be reallocated on demand - this is just
// thee init size so we don't occupy to much space most of the time
//
#define FORMAT_NAME_INIT_BUFFER     128 //init size for formatname props that cannot hold mqf
#define FORMAT_NAME_INIT_BUFFER_EX 1024 //init size for formatname props that can hold mqf


// Messages sent to the QUEUE window from the AsyncReceive Thread
// Initialized in the first call to DllGetClassObject
extern UINT g_uiMsgidArrived;
extern UINT g_uiMsgidArrivedError;

//
// This routine is called in error situations, and must always return an HRESULT error
// In the theoretical (erroneous) cases when GetLastError() is 0 we return E_FAIL
//
inline HRESULT GetWin32LastErrorAsHresult()
{
    DWORD dwErr = GetLastError();
    if (dwErr != 0) {
      return HRESULT_FROM_WIN32(dwErr);
    }
    //
    // GetLastError() is 0, don't know if we ever get here, but we must return an error
    //
    return E_FAIL;
}

//
// Object information needed for CreateErrorHelper
//
struct MsmqObjInfo {
  LPSTR szName;
  const IID * piid;
};
//
// keep in the same order as g_rgObjInfo (mqoa.cpp)
//
enum MsmqObjType {
  eMSMQQuery,
  eMSMQMessage,
  eMSMQQueue,
  eMSMQEvent,
  eMSMQQueueInfo,
  eMSMQQueueInfos,
  eMSMQTransaction,
  eMSMQCoordinatedTransactionDispenser,
  eMSMQTransactionDispenser,
  eMSMQApplication,
  eMSMQDestination,
  eMSMQManagement,
  eMSMQCollection
};

extern HRESULT CreateErrorHelper(
    HRESULT hrExcep,
    MsmqObjType eObjectType);

//
// Create COM object for the templated user class. It is a static method. Usage is:
// hresult = CNewMsmqObj<CMSMQxxx>.NewObj(&xxxObj, &IID_IMSMQxxx, &pxxxInterface)
//
template<class T>
class CNewMsmqObj
{
public:
  static HRESULT NewObj(CComObject<T> **ppT, const IID * piid, IUnknown ** ppunkInterface)
  {
    HRESULT hresult;
    CComObject<T> *pT;
    IUnknown *punkInterface = NULL;

	try
	{
		IfFailRet(CComObject<T>::CreateInstance(&pT));
	}
	catch(const std::bad_alloc&)
	{
		//
		// Exception might be thrown while constructing the 
		// critical section member of the MSMQ object.
		//
		return E_OUTOFMEMORY;
	}

    if (piid) {
      hresult = pT->QueryInterface(*piid, (void **)&punkInterface);
      if (FAILED(hresult)) {
        delete pT;
        return hresult;
      }
    }

    *ppT = pT;
    if (piid) {
      *ppunkInterface = punkInterface;
    }
    return NOERROR;
  }
};


///////////////////////////////////////////////////////////////
// Base class of a buffer of ITEM_TYPE that starts with a static allocation but
// can grow with dynamic allocations. This base class can provide uniform access
// to inherited classes (CStaticBufferGrowing<>) who defer by the size of their static buffer
//
template<class ITEM_TYPE>
class CBaseStaticBufferGrowing
{
public:

  ///////////////////////////////////////////////////////////////
  // pure virtual. needs to be implemented by child (CStaticBufferGrowing<>)
  //
  virtual ITEM_TYPE * GetStaticBuffer() = 0;
  virtual ULONG GetStaticBufferMaxSize() = 0;

  CBaseStaticBufferGrowing()
  {
    m_rgtAllocated = NULL;
    m_ctUsed = 0;
  }

  virtual ~CBaseStaticBufferGrowing()
  {
    if (m_rgtAllocated) {
      delete [] m_rgtAllocated;
    }
  }

  ///////////////////////////////////////////////////////////////
  // get current buffer, either allocated or static
  //
  virtual ITEM_TYPE * GetBuffer()
  {
    if (m_rgtAllocated) {
      return m_rgtAllocated;
    }
    else {
      return GetStaticBuffer();
    }
  }

  ///////////////////////////////////////////////////////////////
  // max size of current buffer
  //
  virtual ULONG GetBufferMaxSize()
  {
    if (m_rgtAllocated) {
      return m_ctAllocated;
    }
    else {
      return GetStaticBufferMaxSize();
    }
  }

  ///////////////////////////////////////////////////////////////
  // get number of entries used in current buffer
  //
  virtual ULONG GetBufferUsedSize()
  {
    return m_ctUsed;
  }

  ///////////////////////////////////////////////////////////////
  // set number of entries used in current buffer
  //
  virtual void SetBufferUsedSize(ULONG ct)
  {
    ASSERTMSG(ct <= GetBufferMaxSize(), "SetBufferUsedSize arg is too big");
    if (ct <= GetBufferMaxSize())
    {
      m_ctUsed = ct;
    }
  }

  ///////////////////////////////////////////////////////////////
  // Allocate a buffer of at least the given size.
  // check if it can fit in static buffer, or in existing allocated buffer, otherwise reallocate
  //
  virtual HRESULT AllocateBuffer(ULONG ct)
  {
    if (ct <= GetStaticBufferMaxSize()) { // can fit in static buffer
      //
      // delete the existing allocated buffer (if any)
      //
      if (m_rgtAllocated) {
        delete [] m_rgtAllocated;
        m_rgtAllocated = NULL;
      }
    }
    else if (!m_rgtAllocated || (ct > m_ctAllocated)) { // no allocated buffer or it is too small
      //
      // allocate a new buffer
      //
      ITEM_TYPE * rgbNewBuffer;
      IfNullRet(rgbNewBuffer = new ITEM_TYPE[ct]);
      //
      // delete the existing allocated buffer (if any)
      //
      if (m_rgtAllocated) {
        delete [] m_rgtAllocated;
      }
      //
      // set the existing allocated buffer to the newly allocated buffer
      //
      m_rgtAllocated = rgbNewBuffer;
      m_ctAllocated = ct;
    }
    //
    // old data is invalid
    //
    m_ctUsed = 0;
    return NOERROR;
  }

  ///////////////////////////////////////////////////////////////
  // copy buffer
  // allocate buffer of the requested size and copy data to it
  //
  virtual HRESULT CopyBuffer(ITEM_TYPE * rgt, ULONG ct)
  {
    HRESULT hresult;
    //
    // Allocate buffer of the requested size
    //
    IfFailRet(AllocateBuffer(ct));
    //
    // copy buffer, and save number of used entries in buffer
    //
    memcpy(GetBuffer(), rgt, ct * sizeof(ITEM_TYPE));
    m_ctUsed = ct;
    return NOERROR;
  }


private:
  ITEM_TYPE *m_rgtAllocated;
  ULONG m_ctAllocated;
  ULONG m_ctUsed;
};

///////////////////////////////////////////////////////////////
// A buffer of ITEM_TYPE that starts with a static allocation of INITIAL_SIZE but
// can grow with dynamic allocations
//
template<class ITEM_TYPE, long INITIAL_SIZE>
class CStaticBufferGrowing : public CBaseStaticBufferGrowing<ITEM_TYPE>
{
public:

  virtual ITEM_TYPE * GetStaticBuffer()
  {
    return m_rgtStatic;
  }

  virtual ULONG GetStaticBufferMaxSize()
  {
    return INITIAL_SIZE;
  }

private:
  ITEM_TYPE m_rgtStatic[INITIAL_SIZE];
};

//
// Declaration of common functions implementated in various files
//
HRESULT GetBstrFromGuid(GUID *pguid, BSTR *pbstrGuid);
HRESULT GetGuidFromBstr(BSTR bstrGuid, GUID *pguid);
HRESULT GetBstrFromGuidWithoutBraces(GUID * pguid, BSTR *pbstrGuid);
HRESULT GetGuidFromBstrWithoutBraces(BSTR bstrGuid, GUID * pguid);
void FreeFalconQueuePropvars(ULONG cProps, QUEUEPROPID * rgpropid, MQPROPVARIANT * rgpropvar);

#define ARRAY_SIZE(array) (sizeof(array)/sizeof(array[0]))



///////////////////////////////////////////////////////////////
// HANDLE GIT interfaces
//
//
// pure virtual template class to handle GIT interfaces, defines the methods.
// it assumes that calls to this class are serialized by the caller
// (e.g this class doesn't guard agains simultaneous Register and Revoke)
//
class CBaseGITInterface
{
public:
    CBaseGITInterface() {}
    virtual ~CBaseGITInterface() {}
    virtual HRESULT Register(IUnknown *pInterface, const IID *piid) = 0;
    virtual void Revoke() = 0;
    virtual HRESULT Get(const IID *piid, IUnknown **ppInterface) = 0;
    virtual BOOL IsRegistered() = 0;
    virtual HRESULT GetWithDefault(const IID *piid, IUnknown **ppInterface, IUnknown *pDefault)
    {
      if (IsRegistered())
      {
        return Get(piid, ppInterface);
      }
      else
      {
        *ppInterface = pDefault;
        if (pDefault != NULL)
        {
          pDefault->AddRef();
        }
        return S_OK;
      }
    }
};
//
// template class to handle GIT interfaces
// it assumes that calls to this class are serialized by the caller
// (e.g this class doesn't guard agains simultaneous Register and Revoke)
//
extern IGlobalInterfaceTable * g_pGIT; //initialized by DllGetClassObject
class CGITInterface : public CBaseGITInterface
{
public:
    CGITInterface()
    {
      m_fCookie = FALSE;
    }

    virtual ~CGITInterface()
    {
      Revoke();
    }

    virtual HRESULT Register(IUnknown *pInterface, const IID *piid)
    {
      Revoke();
      HRESULT hr = S_OK;
      if (pInterface != NULL)
      {
        ASSERTMSG(g_pGIT != NULL, "g_pGIT not initialized");
        hr = g_pGIT->RegisterInterfaceInGlobal(pInterface, *piid, &m_dwCookie);
        if (SUCCEEDED(hr))
        {
          m_fCookie = TRUE;
		  m_iid = *piid;
        }
      }
      return hr;
    }

    virtual void Revoke()
    {
      if (m_fCookie)
      {
        ASSERTMSG(g_pGIT != NULL, "g_pGIT not initialized");
        HRESULT hr = g_pGIT->RevokeInterfaceFromGlobal(m_dwCookie);
        ASSERTMSG(SUCCEEDED(hr), "RevokeInterfaceFromGlobal failed");
        UNREFERENCED_PARAMETER(hr);
        m_fCookie = FALSE;
      }
    }

    virtual HRESULT Get(const IID *piid, IUnknown **ppInterface)
    {
      ASSERTMSG(m_fCookie, "Get called without Register first")
      if (m_fCookie)
      {
        IUnknown *pInterface;
        ASSERTMSG(g_pGIT != NULL, "g_pGIT not initialized");
		HRESULT hr = g_pGIT->GetInterfaceFromGlobal(m_dwCookie, m_iid, (void**)&pInterface);
        if (SUCCEEDED(hr))
        {
          if (IsEqualIID(m_iid, *piid))
          {
            *ppInterface = pInterface;
          }
          else
          {
            hr = pInterface->QueryInterface(*piid, (void **)ppInterface);
            pInterface->Release();
          }
        }
        return hr;
      }
      else
      {
        return E_NOINTERFACE;
      }
    }

    virtual BOOL IsRegistered()
    {
      return m_fCookie;
    }

private:
    //
    // there is no invalid value defined for a GIT cookie, so we use a flag
    // to keep track whether we have a valid GIT cookie or not
    //
    BOOL m_fCookie;
    //
    // the GIT cookie (valid only when m_fCookie is TRUE)
    //
    DWORD m_dwCookie;
	//
	// the IID of the stored interface
	//
	IID m_iid;
};
//
// template class to FAKE GIT interfaces - e.g. interfaces that we know
// are Free-Threaded-Marshalled (e.g. our objects) we can fake
// the GIT operation defines in the base class above, and keep direct pointer
//
class CFakeGITInterface : public CBaseGITInterface
{
public:
    CFakeGITInterface()
    {
      m_pInterface = NULL;
    }

    virtual ~CFakeGITInterface()
    {
      Revoke();
    }

    virtual HRESULT Register(IUnknown *pInterface, const IID *piid)
    {
      Revoke();
      if (pInterface != NULL)
      {
        m_pInterface = pInterface;
        m_pInterface->AddRef();
        m_iid = *piid;
      }
      return S_OK;
    }

    virtual void Revoke()
    {
      if (m_pInterface)
      {
        m_pInterface->Release();
        m_pInterface = NULL;
      }
    }

    virtual HRESULT Get(const IID *piid, IUnknown **ppInterface)
    {
      ASSERTMSG(m_pInterface, "Get called without Register first")
      if (m_pInterface)
      {
        if (IsEqualIID(m_iid, *piid))
        {
          *ppInterface = m_pInterface;
          m_pInterface->AddRef();
          return S_OK;
        }
        return m_pInterface->QueryInterface(*piid, (void **)ppInterface);
      }
      else
      {
        return E_NOINTERFACE;
      }
    }

    virtual BOOL IsRegistered()
    {
      return (m_pInterface != NULL);
    }

private:
    //
    // Always keep an addref'ed interface as a direct pointer in Faked GIT wrapper
    //
    IUnknown * m_pInterface;
	//
	// the IID of the stored interface
	//
    IID m_iid;
};
//
// Support dep client with MSMQ2.0 functionality
//
extern BOOL g_fDependentClient;

HRESULT 
VariantStringArrayToBstringSafeArray(
                    const MQPROPVARIANT& PropVar, 
                    VARIANT* pOleVar
                    );

void 
OapArrayFreeMemory(
        CALPWSTR& calpwstr
        );

//
// Safely free a prop variant.
//
void
OapFreeVariant(PROPVARIANT& var);


//
// Auto class encaplulating a PropVariant.
//
class CPMQVariant
{
public:
    MQPROPVARIANT* operator->()
    {
        return &m_PropVar;
    }


    operator MQPROPVARIANT*()
    {
        return &m_PropVar;
    }

    
    ~CPMQVariant()
    {
        OapFreeVariant(m_PropVar);
    }

private:
    MQPROPVARIANT m_PropVar;
};

//
// Auto pointer safely encapsulating MQMGMTPROPS.
//
 
class CPMQMgmtProps
{
public:
    MQMGMTPROPS* operator->()
    {
        return &m_MgmtProps;
    }


    operator MQMGMTPROPS*()
    {
        return &m_MgmtProps;
    }

    
    ~CPMQMgmtProps()
    {
        for(UINT i = 0; i < m_MgmtProps.cProp; ++i)
        {
            OapFreeVariant(m_MgmtProps.aPropVar[i]);
        }
    }

private:
    MQMGMTPROPS m_MgmtProps;
};


#define _OAUTIL_H_
#endif // _OAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\q.cpp ===
//=--------------------------------------------------------------------------=
// MSMQQueueObj.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQQueue object
//
//
#include "stdafx.h"
#include "dispids.h"
#include "oautil.h"
#include "q.H"
#include "msg.h"
#include "qinfo.h"
#include "txdtc.h"             // transaction support.
#include "xact.h"
#include "mqnames.h"

extern HRESULT GetCurrentViperTransaction(ITransaction **pptransaction);

const MsmqObjType x_ObjectType = eMSMQQueue;

// debug...
#include "debug.h"
#include "debug_thread_id.h"
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#endif // _DEBUG



// Used to coordinate user-thread queue ops and 
//  queue lookup in falcon-thread callback 
//
// !!! NOTE - anyone which locks g_csCallback MUST NOT call a queue method that tries to lock
// a queue object (e.g. its m_csObj member) - this might cause a deadlock since queue
// objects (in several methods e.g. EnableNotification, etc...) lock their m_csObj
// before trying to lock g_csCallback. If it is needed, we need to lock g_csCallback first
// in these queue object methods
//
// Note - The critical section is initialized to preallocate its resources 
// with flag CCriticalSection::xAllocateSpinCount. This means it may throw bad_alloc() on 
// construction but not during usage.
//
extern CCriticalSection g_csCallback;

// Global list of instances of open MSMQQueue objects.
// Queues are inserted to the list when they are opened, and removed from the list when
// they are closed (or released without being closed - this implicitly closes them)
// Used to map queue handle to queue object for the Async Receive handlers
//
QueueNode *g_pqnodeFirst = NULL;

//#2619 RaananH Multithread async receive
static BOOL g_fWeirdLoadLibraryWorkaround = FALSE;
CCriticalSection g_csWeirdLoadLibraryWorkaround;

// helper: provided by msg.cpp
extern HRESULT GetOptionalTransaction(
    VARIANT *pvarTransaction,
    ITransaction **pptransaction,
    BOOL *pisRealXact);

//=--------------------------------------------------------------------------=
// static CMSMQQueue::AddQueue
//=--------------------------------------------------------------------------=
// Add an open queue instance to the open queue list
//
// Parameters:
//    pq           [in]  queue to be added to list
//    ppqnodeAdded [out] queue node where the queue was added
//
// Output:
//
// Notes:
//    pq is not addref'ed.
//    We critsect queue closure/removal and the callback.
//#2619 RaananH Multithread async receive
//
HRESULT CMSMQQueue::AddQueue(CMSMQQueue *pq, QueueNode **ppqnodeAdded)
{
    QueueNode *pqnode;
    HRESULT hresult = NOERROR;

    pqnode = new QueueNode;
    if (pqnode == NULL) {
      hresult = E_OUTOFMEMORY;
    }
    else {
		CS lock(g_csCallback);    // synchs falcon callback queue lookup

		// cons
		pqnode->m_pq = pq;
		pqnode->m_lHandle = pq->m_lHandle;
		pqnode->m_pqnodeNext = g_pqnodeFirst;
		pqnode->m_pqnodePrev = NULL;
		if (g_pqnodeFirst) {
		  g_pqnodeFirst->m_pqnodePrev = pqnode;
		}
		g_pqnodeFirst = pqnode;
		*ppqnodeAdded = pqnode;
    }
    return hresult;
}


//=--------------------------------------------------------------------------=
// static CMSMQQueue::RemQueue
//=--------------------------------------------------------------------------=
// Remove a queue node from the open queue list
//
// Parameters:
//    pqnode [in] queue node to remove
//
// Output:
//
// Notes:
//    We critsect queue closure/removal and the callback.
//#2619 RaananH Multithread async receive
//
void CMSMQQueue::RemQueue(QueueNode *pqnode)
{
    ASSERTMSG(pqnode, "NULL node passed to RemQueue");

	CS lock(g_csCallback);    // synchs falcon callback queue lookup

	//
	// fix next node if any
	//
	if (pqnode->m_pqnodeNext) {
		pqnode->m_pqnodeNext->m_pqnodePrev = pqnode->m_pqnodePrev;
	}
	//
	// fix previous node if any
	//
	if (pqnode->m_pqnodePrev) {
		pqnode->m_pqnodePrev->m_pqnodeNext = pqnode->m_pqnodeNext;
	}
	else {
	//
	// no previous node, this should be the head of the list
	//
	ASSERTMSG(g_pqnodeFirst == pqnode, "queue list is invalid");
	//
	// set head of list to next node (if any)
	//
	g_pqnodeFirst = pqnode->m_pqnodeNext;
	}
	//
	// delete node
	//
	delete pqnode;
}


//=--------------------------------------------------------------------------=
// static CMSMQQueue::PqnodeOfHandle
//=--------------------------------------------------------------------------=
// returns the queue node which correcponds to a queue handle
//
// Parameters:
//    lHandle    [in]  queue handle to search
//
// Output:
//    queue node that correcponds to the queue handle given
//
// Notes:
//    We critsect queue closure/removal and the callback.
//#2619 RaananH Multithread async receive
//
QueueNode *CMSMQQueue::PqnodeOfHandle(QUEUEHANDLE lHandle)
{
    QueueNode *pqnodeRet = NULL;
	
	CS lock(g_csCallback);    // synchs falcon callback queue lookup

	QueueNode *pqnodeCur = g_pqnodeFirst;
	while (pqnodeCur) {
		if (pqnodeCur->m_lHandle == lHandle) {
		  pqnodeRet = pqnodeCur;
		  break;
		}
		pqnodeCur = pqnodeCur->m_pqnodeNext;
	} // while
    
	return pqnodeRet;
}


//
// HELPER: get optional timeout param
//  defaults to INFINITE
//
static HRESULT GetOptionalReceiveTimeout(
    VARIANT *pvarReceiveTimeout,
    long *plReceiveTimeout)
{
    long lReceiveTimeout = INFINITE;
    HRESULT hresult = NOERROR;

    if (pvarReceiveTimeout) {
      if (V_VT(pvarReceiveTimeout) != VT_ERROR) {
        IfFailRet(VariantChangeType(pvarReceiveTimeout, 
                                    pvarReceiveTimeout, 
                                    0, 
                                    VT_I4));
        lReceiveTimeout = V_I4(pvarReceiveTimeout);
      }
    }
    *plReceiveTimeout = lReceiveTimeout;
    return hresult;
}


// forwards decls...
void APIENTRY ReceiveCallback(
    HRESULT hrStatus,
    QUEUEHANDLE hReceiveQueue,
    DWORD dwTimeout,
    DWORD dwAction,
    MQMSGPROPS* pmsgprops,
    LPOVERLAPPED lpOverlapped,
    HANDLE hCursor);
void APIENTRY ReceiveCallbackCurrent(
    HRESULT hrStatus,
    QUEUEHANDLE hReceiveQueue,
    DWORD dwTimeout,
    DWORD dwAction,
    MQMSGPROPS* pmsgprops,
    LPOVERLAPPED lpOverlapped,
    HANDLE hCursor);
void APIENTRY ReceiveCallbackNext(
    HRESULT hrStatus,
    QUEUEHANDLE hReceiveQueue,
    DWORD dwTimeout,
    DWORD dwAction,
    MQMSGPROPS* pmsgprops,
    LPOVERLAPPED lpOverlapped,
    HANDLE hCursor);


//=--------------------------------------------------------------------------=
// CMSMQQueue::CMSMQQueue
//=--------------------------------------------------------------------------=
// create the object
//
// Parameters:
//
// Notes:
//#2619 RaananH Multithread async receive
//
CMSMQQueue::CMSMQQueue() :
	m_csObj(CCriticalSection::xAllocateSpinCount),
    m_fInitialized(FALSE)
{
    // TODO: initialize anything here
    m_pUnkMarshaler = NULL; // ATL's Free Threaded Marshaler
    m_lAccess = 0;                  
    m_lShareMode = MQ_DENY_NONE;               
    m_lHandle = INVALID_HANDLE_VALUE;
    m_hCursor = 0;
    m_pqnode = NULL;
}

//=--------------------------------------------------------------------------=
// CMSMQQueue::~CMSMQQueue
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//#2619 RaananH Multithread async receive
//
CMSMQQueue::~CMSMQQueue ()
{
    // TODO: clean up anything here.
    HRESULT hresult;

    hresult = Close();

	return;
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQQueue::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQQueue3,
		&IID_IMSMQQueue2,
		&IID_IMSMQQueue,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::get_Access
//=--------------------------------------------------------------------------=
// Gets access
//
// Parameters:
//    plAccess [out] 
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueue::get_Access(long FAR* plAccess)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    *plAccess = m_lAccess;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::get_ShareMode
//=--------------------------------------------------------------------------=
// Gets sharemode
//
// Parameters:
//    plShareMode [out] 
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueue::get_ShareMode(long FAR* plShareMode)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    *plShareMode = m_lShareMode;
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQQueue::get_queueinfo
//=--------------------------------------------------------------------------=
// Gets defining queueinfo
//
// Parameters:
//    ppqinfo [out] 
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueue::get_QueueInfo(IMSMQQueueInfo3 FAR* FAR* ppqinfo)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    ASSERTMSG(m_pqinfo.IsRegistered(), "m_pqinfo is not set");
    //
    // We can also get here from old apps that want the old IMSMQQueueInfo/info2 back, but since
    // IMSMQQueueInfo3 is binary backwards compatible we can always return the new interface
    //
    HRESULT hresult = m_pqinfo.GetWithDefault(&IID_IMSMQQueueInfo3, (IUnknown **)ppqinfo, NULL);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::get_Handle
//=--------------------------------------------------------------------------=
// Gets queue handle
//
// Parameters:
//    plHandle [out] 
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueue::get_Handle(long FAR* plHandle)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    // could be -1 if closed.
    *plHandle = (long)HANDLE_TO_DWORD(m_lHandle); //win64 - safe cast since MSMQ queue handles are ALWAYS 32 bit values
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::get_IsOpen
//=--------------------------------------------------------------------------=
// Tests if queue is open, i.e. has a valid handle
//
// Parameters:
//    pisOpen [out] 
//
// Output:
//
// Notes:
//    returns 1 if true, 0 if false
//
HRESULT CMSMQQueue::get_IsOpen(VARIANT_BOOL FAR* pisOpen)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    *pisOpen = (VARIANT_BOOL)CONVERT_TRUE_TO_1_FALSE_TO_0(m_lHandle != INVALID_HANDLE_VALUE);
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::get_IsOpen2
//=--------------------------------------------------------------------------=
// Tests if queue is open, i.e. has a valid handle
//
// Parameters:
//    pisOpen [out] 
//
// Output:
//
// Notes:
//    same as get_IsOpen, but returns VARIANT_TRUE (-1) if true, VARIANT_FALSE (0) if false
//
HRESULT CMSMQQueue::get_IsOpen2(VARIANT_BOOL FAR* pisOpen)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    *pisOpen = CONVERT_BOOL_TO_VARIANT_BOOL(m_lHandle != INVALID_HANDLE_VALUE);
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::Close
//=--------------------------------------------------------------------------=
// Closes queue if open.
//
// Parameters:
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueue::Close()
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    HRESULT hresult = NOERROR;
    //
    // no deadlock - no one which locks g_csCallback calls a q method that
    // locks m_csObj inside the lock
    //
	
	CS lock2(g_csCallback);    // synchs falcon callback queue lookup

	//
	// remove from global open queues list
	//
	if (m_pqnode) {
		RemQueue(m_pqnode);
		m_pqnode = NULL;
	}
	if (m_hCursor) {
		hresult = MQCloseCursor(m_hCursor);
		m_hCursor = 0;      
	}
	if (m_lHandle != INVALID_HANDLE_VALUE) {
		hresult = MQCloseQueue(m_lHandle);
		m_lHandle = INVALID_HANDLE_VALUE;
	}
	// REVIEW: should it be an error to attempt to close
	//  an already closed queue?
	//

    return CreateErrorHelper(hresult, x_ObjectType);
}                   

//=--------------------------------------------------------------------------=
// CMSMQQueue::InternalReceive
//=--------------------------------------------------------------------------=
// Synchronously receive or peek next, matching msg.
//
// Parameters:
//  dwAction      [in]  either MQ_ACTION_XXX, or MQ_LOOKUP_XXX(when using LookupId)
//  hCursor       [in]
//  ptransaction  [in]
//  wantDestQueue [in]  if missing -> FALSE
//  wantBody      [in]  if missing -> TRUE
//  lReceiveTimeout [in]
//  wantConnectorType [in]  if missing -> FALSE
//  pvarLookupId  [in]  if exists -> receive by Id 
//  
//  ppmsg         [out] pointer to pointer to received message.  
//                      NULL if don't want msg.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously receive a message.  
//  Execution is blocked until either a matching message arrives 
//   or ReceiveTimeout expires.
//
HRESULT CMSMQQueue::InternalReceive(
    DWORD dwAction, 
    HANDLE hCursor,
    VARIANT *pvarTransaction,
    VARIANT *wantDestQueue,
    VARIANT *wantBody,
    VARIANT *pvarReceiveTimeout,
    VARIANT *wantConnectorType,
    VARIANT *pvarLookupId,
    IMSMQMessage3 FAR* FAR* ppmsg)
{
    CComObject<CMSMQMessage> *pmsgObj;
    IMSMQMessage3 * pmsg = NULL;
    ITransaction *ptransaction = NULL;
    BOOL fWantDestQueue = FALSE;
    BOOL fWantBody = TRUE;
    BOOL fWantConnectorType = FALSE;
    BOOL isRealXact = FALSE;
    long lReceiveTimeout = INFINITE;
#ifdef _DEBUG
    UINT iLoop = 0;
#endif // _DEBUG
    HRESULT hresult = NOERROR;
    MQMSGPROPS * pmsgprops = NULL;
    BOOL fRetryReceive = FALSE;
    ULONGLONG ullLookupId = DEFAULT_M_LOOKUPID;

    if (ppmsg == NULL) {
      return E_INVALIDARG;
    }
    *ppmsg = NULL;     
    //
    // process optional params
    //
    if (V_VT(wantDestQueue) != VT_ERROR ) {
      fWantDestQueue = GetBool(wantDestQueue);
    }
    if (V_VT(wantBody) != VT_ERROR ) {
      fWantBody = GetBool(wantBody);
    }
    if (V_VT(wantConnectorType) != VT_ERROR ) {
      fWantConnectorType = GetBool(wantConnectorType);
    }
    IfFailRet(GetOptionalReceiveTimeout(
                pvarReceiveTimeout,
                &lReceiveTimeout));
    //
    // We can also get here from old apps that want the old IMSMQMessage/Message2 back, but since
    // IMSMQMessage3 is binary backwards compatible we can always return the new interface
    //
    IfFailRet(CNewMsmqObj<CMSMQMessage>::NewObj(&pmsgObj, &IID_IMSMQMessage3, (IUnknown **)&pmsg));
    IfFailGo(pmsgObj->CreateReceiveMessageProps(
              fWantDestQueue,
              fWantBody,
              fWantConnectorType));
    pmsgprops = pmsgObj->Pmsgprops_rcv();
    //
    // get optional transaction...
    //
    IfFailGo(GetOptionalTransaction(
               pvarTransaction,
               &ptransaction,
               &isRealXact));
    //
    // get 64 bit lookup id if used
    //
    if (pvarLookupId) {
      if (pvarLookupId->vt == VT_ERROR) {
        //
        // VT_ERROR is an internal flag that we set in InternalReceiveByLookupId to specify that
        // we don't have a value for the lookup id because it is one of the First/Last ByLookupId
        // methods.
        //
        ASSERT((dwAction == MQ_LOOKUP_PEEK_FIRST)   ||
               (dwAction == MQ_LOOKUP_PEEK_LAST)    ||
               (dwAction == MQ_LOOKUP_RECEIVE_FIRST)||
               (dwAction == MQ_LOOKUP_RECEIVE_LAST));
        //
        // We set the lookupid value to 0 (reserved for future use)
        //
        ullLookupId = 0;
      }
      else {
        //
        // One of the current/next/previous actions
        //
        ASSERT((dwAction == MQ_LOOKUP_PEEK_CURRENT)     ||
               (dwAction == MQ_LOOKUP_PEEK_NEXT)        ||
               (dwAction == MQ_LOOKUP_PEEK_PREV)        ||
               (dwAction == MQ_LOOKUP_RECEIVE_CURRENT)  ||
               (dwAction == MQ_LOOKUP_RECEIVE_NEXT)     ||
               (dwAction == MQ_LOOKUP_RECEIVE_PREV));
        //
        // lookup ID is already processed by InternalReceiveByLookupId and should be VT_BSTR
        //
        ASSERT(pvarLookupId->vt == VT_BSTR);
        ASSERT(pvarLookupId->bstrVal != NULL);

        //
        // get 64 bit number. Use temp to insure that there is no an extra data after
		// the lookup id number.
        //
        int iFields;
		WCHAR temp;
        iFields = _snwscanf(pvarLookupId->bstrVal, SysStringLen(pvarLookupId->bstrVal), L"%I64d%c", &ullLookupId, &temp);
        if (iFields != 1) {
          IfFailGo(E_INVALIDARG);
        }
      }
    }
    //
    // receive with retries if buffers are small
    //
    do {
#ifdef _DEBUG
      //
      // we can get into situations where someone else grabs the message after we got one of
      // the errors that require realloc buffers, and therefore we might need to realloc again
      // for the next message.
      // however, it is highly unlikely to happen over and over again, so we assume that if
      // we performed this loop 10 times that it is something we need to look at (possibly a bug)
      //
      ASSERTMSG(iLoop < 30, "possible infinite recursion?");
#endif // _DEBUG
      //
      // 1694: need to special-case retrying PeekNext 
      //  after a buffer overflow by using vanilla
      //  Peek on retries since otherwise Falcon will
      //  advance the peek cursor unnecessarily.
      //
      // No need to touch MQ_LOOKUP_XXX since the underlying lookupid
      // doesn't change for the retry
      //
      if (fRetryReceive) {
        if (dwAction == MQ_ACTION_PEEK_NEXT) {
          dwAction = MQ_ACTION_PEEK_CURRENT;
        }  
      }
      //
      // check receive/peek type (by ID or not)
      //
      if (pvarLookupId) {
        //
        // receive/peek by ID, ullLookupId is already processed
        //
        hresult = MQReceiveMessageByLookupId(m_lHandle, 
                                             ullLookupId,
                                             dwAction,
                                             pmsgprops,
                                             0,   // dwAppDefined
                                             0,   // fnRcvClbk
                                             ptransaction);
      }
      else {
        //
        // regular receive/peek
        //
        hresult = MQReceiveMessage(m_lHandle, 
                                   lReceiveTimeout,
                                   dwAction,
                                   pmsgprops,
                                   0,   // dwAppDefined
                                   0,   // fnRcvClbk
                                   hCursor,
                                   ptransaction);
      }
      fRetryReceive = FALSE;
      if (FAILED(hresult)) {
        switch(hresult) {
        case MQ_ERROR_BUFFER_OVERFLOW:
        case MQ_ERROR_SENDER_CERT_BUFFER_TOO_SMALL:
        case MQ_ERROR_SENDERID_BUFFER_TOO_SMALL:
        case MQ_ERROR_SYMM_KEY_BUFFER_TOO_SMALL:
        case MQ_ERROR_SIGNATURE_BUFFER_TOO_SMALL:
        case MQ_ERROR_PROV_NAME_BUFFER_TOO_SMALL:
        case MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL:
          //
          // We may get ANY of the above errors when SOME of the properties
          // encounters buffer overflow (the one that the error refers to definitely had
          // buffer overflow, but there may be others). We go over all the buffers and
          // realloc if necessary.
          //
          IfFailGo(pmsgObj->ReallocReceiveMessageProps());
          fRetryReceive = TRUE;
          break;
        default:
          break;
        }
      }
#ifdef _DEBUG
      iLoop++;
#endif // _DEBUG
    } while (fRetryReceive);
    if (SUCCEEDED(hresult)) {
      // set message props
      IfFailGo(pmsgObj->SetReceivedMessageProps());
      *ppmsg = pmsg;
    }
    //
    // fall through...
    //

Error:
    if (FAILED(hresult)) {
      ASSERTMSG(*ppmsg == NULL, "msg should be NULL.");
      if (pvarLookupId != NULL) {
        //
        // failing receive/peek was done by LookupID
        //
        ASSERTMSG(hresult != MQ_ERROR_IO_TIMEOUT, "can't get timeout error when using LookupId");
        //
        // map LookupId no-match error to NULL msg return
        //
        if (hresult == MQ_ERROR_MESSAGE_NOT_FOUND) {
          hresult = NOERROR;
        }
      }
      else {
        //
        // failing regular receive/peek 
        //
        ASSERTMSG(hresult != MQ_ERROR_MESSAGE_NOT_FOUND, "can't get no-match error when not using LookupId");
        //
        // map time-out error to NULL msg return
        //
        if (hresult == MQ_ERROR_IO_TIMEOUT) {
          hresult = NOERROR;
        }
      }
      RELEASE(pmsg);
    }
    if (isRealXact) {
      RELEASE(ptransaction);
    }
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::Receive_v1
//=--------------------------------------------------------------------------=
// Synchronously receives a message.
//
// Parameters:
//  ptransaction  [in, optional]
//  ppmsg         [out] pointer to pointer to received message.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously receive a message.  
//  Execution is blocked until either a matching message arrives 
//   or ReceiveTimeout expires.
//
HRESULT CMSMQQueue::Receive_v1(
    VARIANT *ptransaction,
    VARIANT *wantDestQueue,
    VARIANT *wantBody,
    VARIANT *lReceiveTimeout,
    IMSMQMessage FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    //
    // IMSMQQueue users (MSMQ 1.0 apps) should not get connector type
    //
    VARIANT varMissing;
    varMissing.vt = VT_ERROR;
    //
    // since IMSMQMesssage2 is binary backwards compatible we can return it instead
    // of IMSMQMessage
    //
    HRESULT hresult = InternalReceive(MQ_ACTION_RECEIVE, 
                                      0, // no cursor
                                      ptransaction,
                                      wantDestQueue,
                                      wantBody,
                                      lReceiveTimeout,
                                      &varMissing /*wantConnectorType*/,
                                      NULL /*pvarLookupId*/,
                                      (IMSMQMessage3 **)ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::Receive for IMSMQQueue2/3
//=--------------------------------------------------------------------------=
// Synchronously receives a message.
//
// Parameters:
//  ptransaction  [in, optional]
//  ppmsg         [out] pointer to pointer to received message.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously receive a message.  
//  Execution is blocked until either a matching message arrives 
//   or ReceiveTimeout expires.
//
HRESULT CMSMQQueue::Receive(
    VARIANT *ptransaction,
    VARIANT *wantDestQueue,
    VARIANT *wantBody,
    VARIANT *lReceiveTimeout,
    VARIANT *wantConnectorType,
    IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    //
    // We can also get here from old apps (through IDispatch) that want the old IMSMQMessage/Message2 back,
    // but since IMSMQMessage3 is binary backwards compatible we can return it instead
    //
    HRESULT hresult = InternalReceive(MQ_ACTION_RECEIVE, 
                                      0, // no cursor
                                      ptransaction,
                                      wantDestQueue,
                                      wantBody,
                                      lReceiveTimeout,
                                      wantConnectorType,
                                      NULL /*pvarLookupId*/,
                                      ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::Peek_v1
//=--------------------------------------------------------------------------=
// Synchronously peeks at a message.
//
// Parameters:
//  ppmsg     [out] pointer to pointer to peeked message.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously peek at a message.  
//  Execution is blocked until either a matching message arrives 
//   or ReceiveTimeout expires.
//
HRESULT CMSMQQueue::Peek_v1(
    VARIANT *wantDestQueue,
    VARIANT *wantBody,
    VARIANT *lReceiveTimeout,
    IMSMQMessage FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    //
    // IMSMQQueue users (MSMQ 1.0 apps) should not get connector type
    //
    VARIANT varMissing;
    varMissing.vt = VT_ERROR;
    //
    // since IMSMQMesssage2 is binary backwards compatible we can return it instead
    // of IMSMQMessage
    //
    HRESULT hresult = InternalReceive(MQ_ACTION_PEEK_CURRENT, 
                                      0,             // bug 1900
                                      NULL,          // no transaction
                                      wantDestQueue,
                                      wantBody,
                                      lReceiveTimeout,
                                      &varMissing /*wantConnectorType*/,
                                      NULL /*pvarLookupId*/,
                                      (IMSMQMessage3 **)ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::Peek for IMSMQQueue2/3
//=--------------------------------------------------------------------------=
// Synchronously peeks at a message.
//
// Parameters:
//  ppmsg     [out] pointer to pointer to peeked message.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously peek at a message.  
//  Execution is blocked until either a matching message arrives 
//   or ReceiveTimeout expires.
//
HRESULT CMSMQQueue::Peek(
    VARIANT *wantDestQueue,
    VARIANT *wantBody,
    VARIANT *lReceiveTimeout,
    VARIANT *wantConnectorType,
    IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    //
    // We can also get here from old apps (through IDispatch) that want the old IMSMQMessage/Message2 back,
    // but since IMSMQMessage3 is binary backwards compatible we can return it instead
    //
    HRESULT hresult = InternalReceive(MQ_ACTION_PEEK_CURRENT, 
                                      0,             // bug 1900
                                      NULL,          // no transaction
                                      wantDestQueue,
                                      wantBody,
                                      lReceiveTimeout,
                                      wantConnectorType,
                                      NULL /*pvarLookupId*/,
                                      ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::PeekCurrent_v1
//=--------------------------------------------------------------------------=
// Synchronously peeks at a message with cursor.
//
// Parameters:
//  ppmsg     [out] pointer to pointer to peeked message.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously peek at a message.  
//  Execution is blocked until either a matching message arrives 
//   or ReceiveTimeout expires.
//
HRESULT CMSMQQueue::PeekCurrent_v1(
    VARIANT *wantDestQueue,
    VARIANT *wantBody,
    VARIANT *lReceiveTimeout,
    IMSMQMessage FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    //
    // IMSMQQueue users (MSMQ 1.0 apps) should not get connector type
    //
    VARIANT varMissing;
    varMissing.vt = VT_ERROR;
    //
    // since IMSMQMesssage2 is binary backwards compatible we can return it instead
    // of IMSMQMessage
    //
    HRESULT hresult = InternalReceive(MQ_ACTION_PEEK_CURRENT, 
                                      m_hCursor,     // bug 1900
                                      NULL,          // no transaction
                                      wantDestQueue,
                                      wantBody,
                                      lReceiveTimeout,
                                      &varMissing /*wantConnectorType*/,
                                      NULL /*pvarLookupId*/,
                                      (IMSMQMessage3 **)ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::PeekCurrent for IMSMQQueue2/3
//=--------------------------------------------------------------------------=
// Synchronously peeks at a message with cursor.
//
// Parameters:
//  ppmsg     [out] pointer to pointer to peeked message.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously peek at a message.  
//  Execution is blocked until either a matching message arrives 
//   or ReceiveTimeout expires.
//
HRESULT CMSMQQueue::PeekCurrent(
    VARIANT *wantDestQueue,
    VARIANT *wantBody,
    VARIANT *lReceiveTimeout,
    VARIANT *wantConnectorType,
    IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    //
    // We can also get here from old apps (through IDispatch) that want the old IMSMQMessage/Message2 back,
    // but since IMSMQMessage3 is binary backwards compatible we can return it instead
    //
    HRESULT hresult = InternalReceive(MQ_ACTION_PEEK_CURRENT, 
                                      m_hCursor,     // bug 1900
                                      NULL,          // no transaction
                                      wantDestQueue,
                                      wantBody,
                                      lReceiveTimeout,
                                      wantConnectorType,
                                      NULL /*pvarLookupId*/,
                                      ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::ReceiveCurrent_v1
//=--------------------------------------------------------------------------=
// Synchronously receive next matching message.
//
// Parameters:
//  ppmsg     [out] pointer to pointer to received message.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously receive a message.  
//  Execution is blocked until either a matching message arrives 
//   or ReceiveTimeout expires.
//
HRESULT CMSMQQueue::ReceiveCurrent_v1(
    VARIANT *ptransaction,
    VARIANT *wantDestQueue,
    VARIANT *wantBody,
    VARIANT *lReceiveTimeout,
    IMSMQMessage FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    //
    // IMSMQQueue users (MSMQ 1.0 apps) should not get connector type
    //
    VARIANT varMissing;
    varMissing.vt = VT_ERROR;
    //
    // since IMSMQMesssage2 is binary backwards compatible we can return it instead
    // of IMSMQMessage
    //
    HRESULT hresult = InternalReceive(MQ_ACTION_RECEIVE, 
                                      m_hCursor,
                                      ptransaction,
                                      wantDestQueue,
                                      wantBody,
                                      lReceiveTimeout,
                                      &varMissing /*wantConnectorType*/,
                                      NULL /*pvarLookupId*/,
                                      (IMSMQMessage3 **)ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::ReceiveCurrent for IMSMQQueue2/3
//=--------------------------------------------------------------------------=
// Synchronously receive next matching message.
//
// Parameters:
//  ppmsg     [out] pointer to pointer to received message.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously receive a message.  
//  Execution is blocked until either a matching message arrives 
//   or ReceiveTimeout expires.
//
HRESULT CMSMQQueue::ReceiveCurrent(
    VARIANT *ptransaction,
    VARIANT *wantDestQueue,
    VARIANT *wantBody,
    VARIANT *lReceiveTimeout,
    VARIANT *wantConnectorType,
    IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    //
    // We can also get here from old apps (through IDispatch) that want the old IMSMQMessage/Message2 back,
    // but since IMSMQMessage3 is binary backwards compatible we can return it instead
    //
    HRESULT hresult = InternalReceive(MQ_ACTION_RECEIVE, 
                                      m_hCursor,
                                      ptransaction,
                                      wantDestQueue,
                                      wantBody,
                                      lReceiveTimeout,
                                      wantConnectorType,
                                      NULL /*pvarLookupId*/,
                                      ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::PeekNext_v1
//=--------------------------------------------------------------------------=
// Synchronously peek at next matching message.
//
// Parameters:
//  ppmsg     [out] pointer to pointer to peeked message.
//
// Output:
//  Returns NULL in *ppmsg if no peekable msg.
//
// Notes:
//  Synchronously peek at a message.  
//  Execution is blocked until either a matching message arrives 
//   or ReceiveTimeout expires.
//
HRESULT CMSMQQueue::PeekNext_v1(
    VARIANT *wantDestQueue,
    VARIANT *wantBody,
    VARIANT *lReceiveTimeout,
    IMSMQMessage FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    //
    // IMSMQQueue users (MSMQ 1.0 apps) should not get connector type
    //
    VARIANT varMissing;
    varMissing.vt = VT_ERROR;
    //
    // since IMSMQMesssage2 is binary backwards compatible we can return it instead
    // of IMSMQMessage
    //
    HRESULT hresult = InternalReceive(MQ_ACTION_PEEK_NEXT, 
                                      m_hCursor,
                                      NULL,   // no transaction
                                      wantDestQueue,
                                      wantBody,
                                      lReceiveTimeout,
                                      &varMissing /*wantConnectorType*/,
                                      NULL /*pvarLookupId*/,
                                      (IMSMQMessage3 **)ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::PeekNext for IMSMQQueue2/3
//=--------------------------------------------------------------------------=
// Synchronously peek at next matching message.
//
// Parameters:
//  ppmsg     [out] pointer to pointer to peeked message.
//
// Output:
//  Returns NULL in *ppmsg if no peekable msg.
//
// Notes:
//  Synchronously peek at a message.  
//  Execution is blocked until either a matching message arrives 
//   or ReceiveTimeout expires.
//
HRESULT CMSMQQueue::PeekNext(
    VARIANT *wantDestQueue,
    VARIANT *wantBody,
    VARIANT *lReceiveTimeout,
    VARIANT *wantConnectorType,
    IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    //
    // We can also get here from old apps (through IDispatch) that want the old IMSMQMessage/Message2 back,
    // but since IMSMQMessage3 is binary backwards compatible we can return it instead
    //
    HRESULT hresult = InternalReceive(MQ_ACTION_PEEK_NEXT, 
                                      m_hCursor,
                                      NULL,   // no transaction
                                      wantDestQueue,
                                      wantBody,
                                      lReceiveTimeout,
                                      wantConnectorType,
                                      NULL /*pvarLookupId*/,
                                      ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::EnableNotification
//=--------------------------------------------------------------------------=
// Enables async message arrival notification
//
// Parameters:
//  pqvent          [in]  queue's event handler
//  msgcursor       [in]  indicates whether they want
//                        to wait on first, current or next.
//                        Default: MQMSG_FIRST
//
// Output:
//
// Notes:
//#2619 RaananH Multithread async receive
//
HRESULT CMSMQQueue::EnableNotification(
    IMSMQEvent3 *pqevent,
    VARIANT *pvarMsgCursor,
    VARIANT *pvarReceiveTimeout)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    DEBUG_THREAD_ID("EnableNotification called");
    MQMSGCURSOR msgcursor = MQMSG_FIRST;
    long lReceiveTimeout = INFINITE;
    HRESULT hresult;
    IMSMQPrivateEvent *pPrivEvent = NULL;

    //
    // Even though pqevent is typed as IMSMQEvent3 it can be IMSMQEvent/Event2 since we can also get
    // here from old apps that pass the old IMSMQEvent/Event2 interface.
    // Since IMSMQEvent3 is binary backwards compatible to IMSMQEvent/Event2 we can safely cast pqevent
    // to IMSMQEvent and use it whether it was IMSMQEvent or IMSMQEvent2/Event3.
    // NOTE: If we need new IMSMQEvent2/Event3 functionality here we must explicitly QI pqevent for it.
    //
    IMSMQEvent *pqeventToUse = (IMSMQEvent *)pqevent;
    if (pqeventToUse == NULL) {
      IfFailGo(hresult = E_INVALIDARG);
    }
    hresult = pqeventToUse->QueryInterface(IID_IMSMQPrivateEvent, (void **)&pPrivEvent);
    if (FAILED(hresult)) {
      IfFailGo(hresult = E_INVALIDARG);
    }
    if (pvarMsgCursor) {
      if (V_VT(pvarMsgCursor) != VT_ERROR) {
        IfFailGo(VariantChangeType(pvarMsgCursor, 
                                    pvarMsgCursor, 
                                    0, 
                                    VT_I4));
        msgcursor = (MQMSGCURSOR)(V_I4(pvarMsgCursor));
        if ((msgcursor != MQMSG_FIRST) &&
            (msgcursor != MQMSG_CURRENT) &&
            (msgcursor != MQMSG_NEXT)) {
           IfFailGo(hresult = E_INVALIDARG);
        }
      }
    }
    IfFailGo(GetOptionalReceiveTimeout(
                pvarReceiveTimeout,
                &lReceiveTimeout));

    // UNDONE: need to load mqoa.dll one extra time to workaround
    //  case in which Falcon rt calls to ActiveX
    //  ReceiveCallback after its dl, i.e. this one,
    //  has been unloaded.  This might happen if it wants
    //  to report that the callback has been canceled!
    // Note: this means that once you've made an async
    //  receive request then this dll will remain loaded.
    //
    // The flag g_fWeirdLoadLibraryWorkaround is never set to FALSE after it
    // is set to TRUE so there is no need to enter a critical section if it is
    // TRUE. However if it is FALSE, we need to enter and re-check that it is
    // FALSE to make sure only one thread will load the dll
    if (!g_fWeirdLoadLibraryWorkaround) {
      //
      // #2619 protect global vars to be thread safe in multi-threaded environment
      //
      CS lock(g_csWeirdLoadLibraryWorkaround);

      if (!g_fWeirdLoadLibraryWorkaround) {
        LoadLibraryW(MQOA_DLL_NAME);
        g_fWeirdLoadLibraryWorkaround = TRUE;
      }
    }
    //
    // register callback for the async notification.
    //
    // 2016: workaround VC5.0 codegen: operator ?: doesn't
    /// work correctly?
    //
    DWORD dwAction;
    PMQRECEIVECALLBACK fnReceiveCallback;
    HANDLE hCursor;

    dwAction = MQ_ACTION_RECEIVE;
    fnReceiveCallback = NULL;
    hCursor = NULL;
    
    switch (msgcursor) {
    case MQMSG_FIRST:
      dwAction = MQ_ACTION_PEEK_CURRENT;
      fnReceiveCallback = ReceiveCallback;
      hCursor = 0;
      break;
    case MQMSG_CURRENT:
      dwAction = MQ_ACTION_PEEK_CURRENT;
      fnReceiveCallback = ReceiveCallbackCurrent;
      hCursor = m_hCursor;
      break;
    case MQMSG_NEXT:
      dwAction = MQ_ACTION_PEEK_NEXT;
      fnReceiveCallback = ReceiveCallbackNext;
      hCursor = m_hCursor;
      break;
    default:
      ASSERTMSG(0, "bad msgcursor!");
      break;
    } // switch

    //
    // HWND can be passed as a 32 bit value on win64 since it is an NT handle
    // 6264 - get_Hwnd moved before entering g_csCallback because it may need to perform
    // on an STA thread that might be blocking on trying to enter g_csCallback, hence get_Hwnd
    // will block in the message loop, and we will have a deadlock
    //
    long lhwnd;
    pPrivEvent->get_Hwnd(&lhwnd);
    //
    // prepare for callback, maybe the callback will be called immediately after
    // MQReceiveMessage and before we can check if it succeeded
    //
    // no deadlock - no one which locks g_csCallback calls a q method that
    // locks m_csObj inside the lock
    //
    {
		CS lock(g_csCallback);    // synchs falcon callback queue lookup
		//
		// 1884: error if queue still has outstanding event
		//  handler. 
		// UNDONE: need specific error
		//
		if (m_pqnode->m_hwnd) {
			IfFailGo(hresult = E_INVALIDARG);
		}
		m_pqnode->m_hwnd = (HWND) DWORD_TO_HANDLE(lhwnd); //enlarge to HANDLE
    } //critical section block

    hresult = MQReceiveMessage(
                m_lHandle,
                lReceiveTimeout,
                dwAction,
                NULL,  //pmsgprops #2619 no need for props in enable notification
                0,                            // overlapped
                fnReceiveCallback,
                hCursor,
                NULL               // no transaction
              );
    if (FAILED(hresult)) {
      ASSERTMSG(hresult != MQ_ERROR_BUFFER_OVERFLOW, "unexpected buffer overflow!");
      //
      // clean the preparation in queue node - e.g. no pending callback
      //
      //
      // no deadlock - no one which locks g_csCallback calls a q method that
      // locks m_csObj inside the lock
      //

	  CS lock(g_csCallback);    // synchs falcon callback queue lookup       
	  m_pqnode->m_hwnd = NULL;
    }

Error:
    RELEASE(pPrivEvent);
    return CreateErrorHelper(hresult, x_ObjectType);
}

//=--------------------------------------------------------------------------=
// CMSMQQueue::Reset
//=--------------------------------------------------------------------------=
// Resets message queue
//
// Parameters:
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueue::Reset()
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    HRESULT hresult = NOERROR;

    if (m_hCursor) {
      hresult = MQCloseCursor(m_hCursor);
    }
    m_hCursor = 0;
    if (SUCCEEDED(hresult)) {
      hresult = MQCreateCursor(m_lHandle, &m_hCursor);
    }
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::Init
//=--------------------------------------------------------------------------=
// Inits new instance with handle and creating MSMQQueueInfo instance.
//
// Parameters:
//    pwszFormatName       [in]  
//    lHandle     [in] 
//    lAccess     [in]
//    lShareMode  [in]
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//  Dtor must release.
//
HRESULT CMSMQQueue::Init(
    LPCWSTR pwszFormatName, 
    QUEUEHANDLE lHandle,
    long lAccess,
    long lShareMode)
{
    m_fInitialized = TRUE;
    HRESULT hresult = NOERROR;
    CComObject<CMSMQQueueInfo> * pqinfoObj;
    IMSMQQueueInfo3 * pqinfo = NULL;

    m_lHandle = lHandle;
    m_lAccess = lAccess;
    m_lShareMode = lShareMode;

    // Need to copy incoming pqinfo since we need
    //  to snapshot it otherwise it might change
    //  under our feet.
    // We do this by creating a new qinfo and initing
    //  it with the formatname of the incoming qinfo
    //  and then finally refreshing it.
    //
    // m_pqinfo released in dtor
    //
    IfFailRet(CNewMsmqObj<CMSMQQueueInfo>::NewObj(&pqinfoObj, &IID_IMSMQQueueInfo3, (IUnknown **)&pqinfo));
    //
    // m_pqinfo needs to hold reference to IMSMQQueueInfo3. Usually we would
    // need to use GIT for that, but we know that this qinfo is ours (just created) and
    // uses the free-threaded-marshaler by itself, so we use CFakeGITInterface
    // instead of CGITInterface for marshal/unmarshal (e.g. we keep this notation of
    // registering to emphasize we need to store it as GIT cookie if it wasn't our object
    //
    IfFailGo(m_pqinfo.Register(pqinfo, &IID_IMSMQQueueInfo3));
    RELEASE(pqinfo); //already addref'ed in m_pqinfo
    
    IfFailGo(pqinfoObj->Init(pwszFormatName)); 
    
    //
    // 2536: only attempt to use the DS when
    //  the first prop is accessed... or Refresh
    //  is called explicitly.
    //
    IfFailGo(AddQueue(this, &m_pqnode));              // add to global list
    //
    // #6172 create cursor only when object is opened for receive since it could have
    // been initialized with a multiple-element format name
    //
    hresult = NOERROR;
    if (lAccess == MQ_RECEIVE_ACCESS || 
        lAccess == MQ_PEEK_ACCESS || 
        lAccess == (MQ_PEEK_ACCESS | MQ_ADMIN_ACCESS) || 
        lAccess == (MQ_RECEIVE_ACCESS | MQ_ADMIN_ACCESS))
    {
        hresult = Reset(); //creates a cursor
    }
    return hresult;

Error:
    RELEASE(pqinfo);
    m_pqinfo.Revoke();
    return hresult;
}


//=-------------------------------------------------------------------------=
// CMSMQQueue::get_Properties
//=-------------------------------------------------------------------------=
// Gets object's properties collection
//
// Parameters:
//    ppcolProperties - [out] object's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQQueue::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}

//=--------------------------------------------------------------------------=
// CMSMQQueue::get_Handle2
//=--------------------------------------------------------------------------=
// Gets queue handle
//
// Parameters:
//    pvarHandle [out] 
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueue::get_Handle2(VARIANT FAR* pvarHandle)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    ASSERTMSG(pvarHandle != NULL, "NULL pvarHandle");
    pvarHandle->vt = VT_I8;
    V_I8(pvarHandle) = (LONGLONG) m_lHandle;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::InternalReceiveByLookupId
//=--------------------------------------------------------------------------=
// Synchronously receive/peek by LookupId
//
// Parameters:
//  dwAction           [in]  MQ_LOOKUP_[PEEK/RECEIVE]_[CURRENT/NEXT/PREV/FIRST/LAST]
//  ptransaction       [in]
//  pvarLookupIdParam  [in]  lookup id
//  
//  ppmsg         [out] pointer to pointer to received message.  
//                      NULL if don't want msg.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously receive/peek a message using LookupId
//  Doesn't block
//
HRESULT CMSMQQueue::InternalReceiveByLookupId(
      DWORD dwAction,
      VARIANT *pvarLookupIdParam,
      VARIANT FAR* ptransaction,
      VARIANT *wantDestQueue,
      VARIANT *wantBody,
      VARIANT *wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg)
{
    HRESULT hresult;
    VARIANT varLookupId;
    VariantInit(&varLookupId);
    //
    // verify lookupid
    //
    if (pvarLookupIdParam != NULL) 
    {
      //
      // Validate that the user specified a valid argument.
      //
        
      if(pvarLookupIdParam->vt == VT_EMPTY)
      { 
          return MQ_ERROR_INVALID_PARAMETER;
      }
      
      //
      // One of the CURRENT/PREV/NEXT actions. LookupId must be supplied
      //
      ASSERT((dwAction == MQ_LOOKUP_PEEK_CURRENT)     ||
             (dwAction == MQ_LOOKUP_PEEK_NEXT)        ||
             (dwAction == MQ_LOOKUP_PEEK_PREV)        ||
             (dwAction == MQ_LOOKUP_RECEIVE_CURRENT)  ||
             (dwAction == MQ_LOOKUP_RECEIVE_NEXT)     ||
             (dwAction == MQ_LOOKUP_RECEIVE_PREV));
      //
      // Change type to VT_BSTR
      //
      IfFailRet(VariantChangeType(&varLookupId, pvarLookupIdParam, 0, VT_BSTR));
    }
    else {
      //
      // One of the FIRST/LAST actions. We don't need a LookupId value, but we can't pass NULL
      // to InternalReceive since that would mean regular Peek/Receive, so we pass a missing
      // variant (VT_ERROR)
      //
      ASSERT((dwAction == MQ_LOOKUP_PEEK_FIRST)     ||
             (dwAction == MQ_LOOKUP_PEEK_LAST)      ||
             (dwAction == MQ_LOOKUP_RECEIVE_FIRST)  ||
             (dwAction == MQ_LOOKUP_RECEIVE_LAST));
      varLookupId.vt = VT_ERROR;
    }
    //
    // call InternalReceive
    //
    hresult = InternalReceive(dwAction, 
                              0, // no cursor
                              ptransaction,
                              wantDestQueue,
                              wantBody,
                              NULL,        /* pvarReceiveTimeout */
                              wantConnectorType,
                              &varLookupId,
                              ppmsg);
    VariantClear(&varLookupId);
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::ReceiveByLookupId
//=--------------------------------------------------------------------------=
// Synchronously receive by LookupId
//
// Parameters:
//  ptransaction  [in]
//  varLookupId   [in]  lookup id
//  
//  ppmsg         [out] pointer to pointer to received message.  
//                      NULL if don't want msg.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously receive a message with LookupId equals to varLookupId
//  Doesn't block
//
HRESULT CMSMQQueue::ReceiveByLookupId(
      VARIANT varLookupId,
      VARIANT FAR* ptransaction,
      VARIANT *wantDestQueue,
      VARIANT *wantBody,
      VARIANT *wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }
    HRESULT hresult = InternalReceiveByLookupId(MQ_LOOKUP_RECEIVE_CURRENT,
                                                &varLookupId,
                                                ptransaction,
                                                wantDestQueue,
                                                wantBody,
                                                wantConnectorType,
                                                ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::ReceiveNextByLookupId
//=--------------------------------------------------------------------------=
// Synchronously receive next by LookupId
//
// Parameters:
//  ptransaction  [in]
//  varLookupId   [in]  lookup id
//  
//  ppmsg         [out] pointer to pointer to received message.  
//                      NULL if don't want msg.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously receive a message with LookupId greater than varLookupId
//  Doesn't block
//
HRESULT CMSMQQueue::ReceiveNextByLookupId(
      VARIANT varLookupId,
      VARIANT FAR* ptransaction,
      VARIANT *wantDestQueue,
      VARIANT *wantBody,
      VARIANT *wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    HRESULT hresult = InternalReceiveByLookupId(MQ_LOOKUP_RECEIVE_NEXT,
                                                &varLookupId,
                                                ptransaction,
                                                wantDestQueue,
                                                wantBody,
                                                wantConnectorType,
                                                ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::ReceivePreviousByLookupId
//=--------------------------------------------------------------------------=
// Synchronously receive previous by LookupId
//
// Parameters:
//  ptransaction  [in]
//  varLookupId   [in]  lookup id
//  
//  ppmsg         [out] pointer to pointer to received message.  
//                      NULL if don't want msg.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously receive a message with LookupId smaller than varLookupId
//  Doesn't block
//
HRESULT CMSMQQueue::ReceivePreviousByLookupId(
      VARIANT varLookupId,
      VARIANT FAR* ptransaction,
      VARIANT *wantDestQueue,
      VARIANT *wantBody,
      VARIANT *wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    HRESULT hresult = InternalReceiveByLookupId(MQ_LOOKUP_RECEIVE_PREV,
                                                &varLookupId,
                                                ptransaction,
                                                wantDestQueue,
                                                wantBody,
                                                wantConnectorType,
                                                ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::ReceiveFirstByLookupId
//=--------------------------------------------------------------------------=
// Synchronously receive first by LookupId
//
// Parameters:
//  ptransaction  [in]
//  
//  ppmsg         [out] pointer to pointer to received message.  
//                      NULL if don't want msg.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously receive the first message based on LookupId order
//  Doesn't block
//
HRESULT CMSMQQueue::ReceiveFirstByLookupId(
      VARIANT FAR* ptransaction,
      VARIANT *wantDestQueue,
      VARIANT *wantBody,
      VARIANT *wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    HRESULT hresult = InternalReceiveByLookupId(MQ_LOOKUP_RECEIVE_FIRST,
                                                NULL /*pvarLookupIdParam*/,
                                                ptransaction,
                                                wantDestQueue,
                                                wantBody,
                                                wantConnectorType,
                                                ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::ReceiveLastByLookupId
//=--------------------------------------------------------------------------=
// Synchronously receive last by LookupId
//
// Parameters:
//  ptransaction  [in]
//  
//  ppmsg         [out] pointer to pointer to received message.  
//                      NULL if don't want msg.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously receive the last message based on LookupId order
//  Doesn't block
//
HRESULT CMSMQQueue::ReceiveLastByLookupId(
      VARIANT FAR* ptransaction,
      VARIANT *wantDestQueue,
      VARIANT *wantBody,
      VARIANT *wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    HRESULT hresult = InternalReceiveByLookupId(MQ_LOOKUP_RECEIVE_LAST,
                                                NULL /*pvarLookupIdParam*/,
                                                ptransaction,
                                                wantDestQueue,
                                                wantBody,
                                                wantConnectorType,
                                                ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::PeekByLookupId
//=--------------------------------------------------------------------------=
// Synchronously peek by LookupId
//
// Parameters:
//  varLookupId   [in]  lookup id
//  
//  ppmsg         [out] pointer to pointer to received message.  
//                      NULL if don't want msg.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously peek a message with LookupId equal to varLookupId
//  Doesn't block
//
HRESULT CMSMQQueue::PeekByLookupId(
      VARIANT varLookupId,
      VARIANT *wantDestQueue,
      VARIANT *wantBody,
      VARIANT *wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    HRESULT hresult = InternalReceiveByLookupId(MQ_LOOKUP_PEEK_CURRENT,
                                                &varLookupId,
                                                NULL /* no transaction*/,
                                                wantDestQueue,
                                                wantBody,
                                                wantConnectorType,
                                                ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::PeekNextByLookupId
//=--------------------------------------------------------------------------=
// Synchronously peek next by LookupId
//
// Parameters:
//  varLookupId   [in]  lookup id
//  
//  ppmsg         [out] pointer to pointer to received message.  
//                      NULL if don't want msg.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously peek a message with LookupId greater than varLookupId
//  Doesn't block
//
HRESULT CMSMQQueue::PeekNextByLookupId(
      VARIANT varLookupId,
      VARIANT *wantDestQueue,
      VARIANT *wantBody,
      VARIANT *wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    HRESULT hresult = InternalReceiveByLookupId(MQ_LOOKUP_PEEK_NEXT,
                                                &varLookupId,
                                                NULL /* no transaction*/,
                                                wantDestQueue,
                                                wantBody,
                                                wantConnectorType,
                                                ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::PeekPreviousByLookupId
//=--------------------------------------------------------------------------=
// Synchronously peek previous by LookupId
//
// Parameters:
//  varLookupId   [in]  lookup id
//  
//  ppmsg         [out] pointer to pointer to received message.  
//                      NULL if don't want msg.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously peek a message with LookupId smaller than varLookupId
//  Doesn't block
//
HRESULT CMSMQQueue::PeekPreviousByLookupId(
      VARIANT varLookupId,
      VARIANT *wantDestQueue,
      VARIANT *wantBody,
      VARIANT *wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    HRESULT hresult = InternalReceiveByLookupId(MQ_LOOKUP_PEEK_PREV,
                                                &varLookupId,
                                                NULL /* no transaction*/,
                                                wantDestQueue,
                                                wantBody,
                                                wantConnectorType,
                                                ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::PeekFirstByLookupId
//=--------------------------------------------------------------------------=
// Synchronously peek first by LookupId
//
// Parameters:
//  
//  ppmsg         [out] pointer to pointer to received message.  
//                      NULL if don't want msg.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously peek the first message based on LookupId order
//  Doesn't block
//
HRESULT CMSMQQueue::PeekFirstByLookupId(
      VARIANT *wantDestQueue,
      VARIANT *wantBody,
      VARIANT *wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    HRESULT hresult = InternalReceiveByLookupId(MQ_LOOKUP_PEEK_FIRST,
                                                NULL /*pvarLookupIdParam*/,
                                                NULL /* no transaction*/,
                                                wantDestQueue,
                                                wantBody,
                                                wantConnectorType,
                                                ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueue::PeekLastByLookupId
//=--------------------------------------------------------------------------=
// Synchronously peek last by LookupId
//
// Parameters:
//  
//  ppmsg         [out] pointer to pointer to received message.  
//                      NULL if don't want msg.
//
// Output:
//  Returns NULL in *ppmsg if no received msg.
//
// Notes:
//  Synchronously peek the last message based on LookupId order
//  Doesn't block
//
HRESULT CMSMQQueue::PeekLastByLookupId(
      VARIANT *wantDestQueue,
      VARIANT *wantBody,
      VARIANT *wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    HRESULT hresult = InternalReceiveByLookupId(MQ_LOOKUP_PEEK_LAST,
                                                NULL /*pvarLookupIdParam*/,
                                                NULL /* no transaction*/,
                                                wantDestQueue,
                                                wantBody,
                                                wantConnectorType,
                                                ppmsg);
    return CreateErrorHelper(hresult, x_ObjectType);
}


HRESULT CMSMQQueue::Purge()
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    HRESULT hresult = MQPurgeQueue(m_lHandle);
    return CreateErrorHelper(hresult, x_ObjectType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\msg.h ===
//=--------------------------------------------------------------------------=
// MSMQMessageObj.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQMessage object.
//
//
#ifndef _MSMQMessage_H_

#include "resrc1.h"       // main symbols
#include "oautil.h"
#include "cs.h"
#include "dispids.h"
#include "mq.h"

//
// 60 chars are long enough to store a string representation of a 64 bit value
//
#define MAX_I64_CHARS 60 

enum { // keep in the same order as props in msg.cpp (g_rgmsgpropXX)
  MSGPROP_MSGID,
  MSGPROP_CORRELATIONID,
  MSGPROP_PRIORITY,
  MSGPROP_DELIVERY,
  MSGPROP_ACKNOWLEDGE,
  MSGPROP_JOURNAL,
  MSGPROP_APPSPECIFIC,
  MSGPROP_LABEL,
  MSGPROP_LABEL_LEN,
  MSGPROP_TIME_TO_BE_RECEIVED,
  MSGPROP_TRACE,
  MSGPROP_TIME_TO_REACH_QUEUE,
  MSGPROP_SENDERID,
  MSGPROP_SENDERID_LEN,
  MSGPROP_SENDERID_TYPE,
  MSGPROP_PRIV_LEVEL,
  MSGPROP_AUTH_LEVEL,
  MSGPROP_AUTHENTICATED_EX,
  MSGPROP_HASH_ALG,
  MSGPROP_ENCRYPTION_ALG,
  MSGPROP_SENDER_CERT,
  MSGPROP_SENDER_CERT_LEN,
  MSGPROP_SRC_MACHINE_ID,
  MSGPROP_SENTTIME,
  MSGPROP_ARRIVEDTIME,
  MSGPROP_RESP_QUEUE,
  MSGPROP_RESP_QUEUE_LEN,
  MSGPROP_ADMIN_QUEUE,
  MSGPROP_ADMIN_QUEUE_LEN,
  MSGPROP_SECURITY_CONTEXT,
  MSGPROP_CLASS,
  MSGPROP_BODY_TYPE,

  MSGPROP_VERSION,
  MSGPROP_EXTENSION,
  MSGPROP_EXTENSION_LEN,
  MSGPROP_XACT_STATUS_QUEUE,
  MSGPROP_XACT_STATUS_QUEUE_LEN,
  MSGPROP_DEST_SYMM_KEY,
  MSGPROP_DEST_SYMM_KEY_LEN,
  MSGPROP_SIGNATURE,
  MSGPROP_SIGNATURE_LEN,
  MSGPROP_PROV_TYPE,
  MSGPROP_PROV_NAME,
  MSGPROP_PROV_NAME_LEN,

  MSGPROP_XACTID,
  MSGPROP_XACT_FIRST,
  MSGPROP_XACT_LAST,

  COUNT_MSGPROP_PROPS
};

enum { // keep in the same order as optional props in msg.cpp (g_rgmsgpropXXOptional)
  OPTPROP_DEST_QUEUE,
  OPTPROP_DEST_QUEUE_LEN,
  OPTPROP_BODY,
  OPTPROP_BODY_SIZE,
  OPTPROP_CONNECTOR_TYPE,
  //
  // The props below are optional in order to support dependent client with MSMQ 2.0 functionality
  // keep the same internal order for computing x_cPropsNotInDepClient below
  //
  OPTPROP_RESP_FORMAT_NAME,
  OPTPROP_RESP_FORMAT_NAME_LEN,
  OPTPROP_DEST_FORMAT_NAME,
  OPTPROP_DEST_FORMAT_NAME_LEN,
  OPTPROP_LOOKUPID,
  OPTPROP_SOAP_ENVELOPE,
  OPTPROP_SOAP_ENVELOPE_LEN,
  OPTPROP_COMPOUND_MESSAGE,
  OPTPROP_COMPOUND_MESSAGE_SIZE,
  OPTPROP_SOAP_HEADER,
  OPTPROP_SOAP_BODY,

  COUNT_OPTPROP_PROPS
};

const DWORD x_cPropsNotInDepClient = OPTPROP_COMPOUND_MESSAGE_SIZE - OPTPROP_RESP_FORMAT_NAME + 1;

// HELPER: describes message type
enum MSGTYPE {
    MSGTYPE_BINARY,
    MSGTYPE_STREAM,
    MSGTYPE_STORAGE,
    MSGTYPE_STREAM_INIT
};

//
// some message property buffer sizes (with margins over typical sizes)
//
const long SENDERID_INIT_SIZE     = 128;   // Currently SID is max 78 bytes, so this will do
const long SENDERCERT_INIT_SIZE   = 2048;  // Internal certificate is ~700 bytes
const long EXTENSION_INIT_SIZE    = 1024;  // Unpredictable size (like body)
const long DESTSYMMKEY_INIT_SIZE  = 256;   // from MSDN usually session key which is 5-250 bytes (40-2000 bits)
const long SIGNATURE_INIT_SIZE    = 128;   // according to BoazF
const long AUTHPROVNAME_INIT_SIZE = 127+1; // usually a string from wincrypt.h
const long SOAP_ENVELOPE_INIT_SIZE     = 4096;  // Unpredictable size (like body)
const long COMPOUND_MESSAGE_INIT_SIZE  = 4096;  // Unpredictable size (like body)

class ATL_NO_VTABLE CMSMQMessage : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQMessage, &CLSID_MSMQMessage>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQMessage3, &IID_IMSMQMessage3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQMessage();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQMESSAGE)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQMessage)
	COM_INTERFACE_ENTRY(IMSMQMessage3)
	COM_INTERFACE_ENTRY_IID(IID_IMSMQMessage2, IMSMQMessage3) //return IMSMQMessage3 for IMSMQMessage2
	COM_INTERFACE_ENTRY_IID(IID_IMSMQMessage, IMSMQMessage3) //return IMSMQMessage3 for IMSMQMessage
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQMessage
public:
    virtual ~CMSMQMessage();

    // IMSMQMessage methods
    // TODO: copy over the interface methods for IMSMQMessage from
    //       mqInterfaces.H here.
    STDMETHOD(get_Class)(THIS_ long FAR* plClass);
    STDMETHOD(get_PrivLevel)(THIS_ long FAR* plPrivLevel);
    STDMETHOD(put_PrivLevel)(THIS_ long lPrivLevel);
    STDMETHOD(get_AuthLevel)(THIS_ long FAR* plAuthLevel);
    STDMETHOD(put_AuthLevel)(THIS_ long lAuthLevel);
    STDMETHOD(get_IsAuthenticated)(THIS_ VARIANT_BOOL FAR* pisAuthenticated);
    STDMETHOD(get_Delivery)(THIS_ long FAR* plDelivery);
    STDMETHOD(put_Delivery)(THIS_ long lDelivery);
    STDMETHOD(get_Trace)(THIS_ long FAR* plTrace);
    STDMETHOD(put_Trace)(THIS_ long lTrace);
    STDMETHOD(get_Priority)(THIS_ long FAR* plPriority);
    STDMETHOD(put_Priority)(THIS_ long lPriority);
    STDMETHOD(get_Journal)(THIS_ long FAR* plJournal);
    STDMETHOD(put_Journal)(THIS_ long lJournal);
    STDMETHOD(get_ResponseQueueInfo_v1)(THIS_ IMSMQQueueInfo FAR* FAR* ppqinfoResponse);
    STDMETHOD(putref_ResponseQueueInfo_v1)(THIS_ IMSMQQueueInfo FAR* pqinfoResponse);
    STDMETHOD(get_AppSpecific)(THIS_ long FAR* plAppSpecific);
    STDMETHOD(put_AppSpecific)(THIS_ long lAppSpecific);
    STDMETHOD(get_SourceMachineGuid)(THIS_ BSTR FAR* pbstrGuidSrcMachine);
    STDMETHOD(get_BodyLength)(THIS_ long FAR* pcbBody);
    STDMETHOD(get_Body)(THIS_ VARIANT FAR* pvarBody);
    STDMETHOD(put_Body)(THIS_ VARIANT varBody);
    STDMETHOD(get_AdminQueueInfo_v1)(THIS_ IMSMQQueueInfo FAR* FAR* ppqinfoAdmin);
    STDMETHOD(putref_AdminQueueInfo_v1)(THIS_ IMSMQQueueInfo FAR* pqinfoAdmin);
    STDMETHOD(get_Id)(THIS_ VARIANT FAR* pvarMsgId);
    STDMETHOD(get_CorrelationId)(THIS_ VARIANT FAR* pvarMsgId);
    STDMETHOD(put_CorrelationId)(THIS_ VARIANT varMsgId);
    STDMETHOD(get_Ack)(THIS_ long FAR* plAck);
    STDMETHOD(put_Ack)(THIS_ long lAck);
    STDMETHOD(get_Label)(THIS_ BSTR FAR* pbstrLabel);
    STDMETHOD(put_Label)(THIS_ BSTR bstrLabel);
    STDMETHOD(get_MaxTimeToReachQueue)(THIS_ long FAR* plMaxTimeToReachQueue);
    STDMETHOD(put_MaxTimeToReachQueue)(THIS_ long lMaxTimeToReachQueue);
    STDMETHOD(get_MaxTimeToReceive)(THIS_ long FAR* plMaxTimeToReceive);
    STDMETHOD(put_MaxTimeToReceive)(THIS_ long lMaxTimeToReceive);
    STDMETHOD(get_HashAlgorithm)(THIS_ long FAR* plHashAlg);
    STDMETHOD(put_HashAlgorithm)(THIS_ long lHashAlg);
    STDMETHOD(get_EncryptAlgorithm)(THIS_ long FAR* plEncryptAlg);
    STDMETHOD(put_EncryptAlgorithm)(THIS_ long lEncryptAlg);
    STDMETHOD(get_SentTime)(THIS_ VARIANT FAR* pvarSentTime);
    STDMETHOD(get_ArrivedTime)(THIS_ VARIANT FAR* plArrivedTime);
    STDMETHOD(get_DestinationQueueInfo)(THIS_ IMSMQQueueInfo3 FAR* FAR* ppqinfoDest);
    STDMETHOD(get_SenderCertificate)(THIS_ VARIANT FAR* pvarSenderCert);
    STDMETHOD(put_SenderCertificate)(THIS_ VARIANT varSenderCert);
    STDMETHOD(get_SenderId)(THIS_ VARIANT FAR* pvarSenderId);
    STDMETHOD(get_SenderIdType)(THIS_ long FAR* plSenderIdType);
    STDMETHOD(put_SenderIdType)(THIS_ long lSenderIdType);
    STDMETHOD(Send)(THIS_ IDispatch FAR* pDest, VARIANT FAR* ptransaction);
    STDMETHOD(AttachCurrentSecurityContext)(THIS);
    // IMSMQMessage2 methods (in addition to IMSMQMessage)
    STDMETHOD(get_SenderVersion)(THIS_ long FAR* plSenderVersion);
    STDMETHOD(get_Extension)(THIS_ VARIANT FAR* pvarExtension);
    STDMETHOD(put_Extension)(THIS_ VARIANT varExtension);
    STDMETHOD(get_ConnectorTypeGuid)(THIS_ BSTR FAR* pbstrGuidConnectorType);
    STDMETHOD(put_ConnectorTypeGuid)(THIS_ BSTR bstrGuidConnectorType);
    STDMETHOD(get_TransactionStatusQueueInfo)(THIS_ IMSMQQueueInfo3 FAR* FAR* ppqinfoXactStatus);
    STDMETHOD(get_DestinationSymmetricKey)(THIS_ VARIANT FAR* pvarDestSymmKey);
    STDMETHOD(put_DestinationSymmetricKey)(THIS_ VARIANT varDestSymmKey);
    STDMETHOD(get_Signature)(THIS_ VARIANT FAR* pvarSignature);
    STDMETHOD(put_Signature)(THIS_ VARIANT varSignature);
    STDMETHOD(get_AuthenticationProviderType)(THIS_ long FAR* plAuthProvType);
    STDMETHOD(put_AuthenticationProviderType)(THIS_ long lAuthProvType);
    STDMETHOD(get_AuthenticationProviderName)(THIS_ BSTR FAR* pbstrAuthProvName);
    STDMETHOD(put_AuthenticationProviderName)(THIS_ BSTR bstrAuthProvName);
    STDMETHOD(put_SenderId)(THIS_ VARIANT varSenderId);
    STDMETHOD(get_MsgClass)(THIS_ long FAR* plMsgClass);
    STDMETHOD(put_MsgClass)(THIS_ long lMsgClass);
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);

    STDMETHOD(get_TransactionId)(THIS_ VARIANT FAR* pvarXactId);
    STDMETHOD(get_IsFirstInTransaction)(THIS_ VARIANT_BOOL FAR* pisFirstInXact);
    STDMETHOD(get_IsLastInTransaction)(THIS_ VARIANT_BOOL FAR* pisLastInXact);
    //
    // upgraded properties for IMSMQMessage2
    //
    STDMETHOD(get_ResponseQueueInfo_v2)(THIS_ IMSMQQueueInfo2 FAR* FAR* ppqinfoResponse);
    STDMETHOD(putref_ResponseQueueInfo_v2)(THIS_ IMSMQQueueInfo2 FAR* pqinfoResponse);
    STDMETHOD(get_AdminQueueInfo_v2)(THIS_ IMSMQQueueInfo2 FAR* FAR* ppqinfoAdmin);
    STDMETHOD(putref_AdminQueueInfo_v2)(THIS_ IMSMQQueueInfo2 FAR* pqinfoAdmin);
    //
	// authentication fix #2790 (PROPID_M_AUTHENTICATED_EX)
    //
    STDMETHOD(get_ReceivedAuthenticationLevel)(THIS_ short FAR* psReceivedAuthenticationLevel);
    //
    // upgraded properties for IMSMQMessage3
    //
    STDMETHOD(get_ResponseQueueInfo)(THIS_ IMSMQQueueInfo3 FAR* FAR* ppqinfoResponse);
    STDMETHOD(putref_ResponseQueueInfo)(THIS_ IMSMQQueueInfo3 FAR* pqinfoResponse);
    STDMETHOD(get_AdminQueueInfo)(THIS_ IMSMQQueueInfo3 FAR* FAR* ppqinfoAdmin);
    STDMETHOD(putref_AdminQueueInfo)(THIS_ IMSMQQueueInfo3 FAR* pqinfoAdmin);
    //
    // new properties for IMSMQMessage3
    //
    STDMETHOD(get_ResponseDestination)(THIS_ IDispatch FAR* FAR* ppdestResponse);
    STDMETHOD(putref_ResponseDestination)(THIS_ IDispatch FAR* pdestResponse);
    STDMETHOD(get_Destination)(THIS_ IDispatch FAR* FAR* ppdestDestination);
    STDMETHOD(get_LookupId)(THIS_ VARIANT FAR* pvarLookupId);
    STDMETHOD(get_IsAuthenticated2)(THIS_ VARIANT_BOOL FAR* pisAuthenticated);
    STDMETHOD(get_IsFirstInTransaction2)(THIS_ VARIANT_BOOL FAR* pisFirstInXact);
    STDMETHOD(get_IsLastInTransaction2)(THIS_ VARIANT_BOOL FAR* pisLastInXact);
    STDMETHOD(AttachCurrentSecurityContext2)(THIS);
    STDMETHOD(get_SoapEnvelope)(THIS_ BSTR FAR* pbstrSoapEnvelope);
    STDMETHOD(get_CompoundMessage)(THIS_ VARIANT FAR* pvarCompoundMessage);
    STDMETHOD(put_SoapHeader)(THIS_ BSTR bstrSoapHeader);
    STDMETHOD(put_SoapBody)(THIS_ BSTR bstrSoapBody);


    // introduced methods
    HRESULT CreateReceiveMessageProps(
      BOOL wantDestQueue,
      BOOL wantBody,
      BOOL wantConnectorType);
    HRESULT SetReceivedMessageProps();
    HRESULT ReallocReceiveMessageProps();
    MQMSGPROPS * Pmsgprops_rcv() {return &m_msgprops_rcv;}
    //
    // Critical section to guard object's data and be thread safe
	// It is initialized to preallocate its resources 
	// with flag CCriticalSection::xAllocateSpinCount. This means it may throw bad_alloc() on 
	// construction but not during usage.
	//
    CCriticalSection m_csObj;

protected:
    HRESULT GetStreamOfBody(ULONG cbBody, void *pvBody, IStream **ppstm);
    HRESULT GetStorageOfBody(ULONG cbBody, void *pvBody, IStorage **ppstg);
    HRESULT UpdateBodyBuffer(ULONG cbBody, void *pvBody, VARTYPE vt);
    HRESULT GetStreamedObject(VARIANT *pvarBody);
    HRESULT GetStoredObject(VARIANT *pvarBody);

    HRESULT 
    AllocateReceiveMessageProps(
        BOOL wantDestQueue,
        BOOL wantBody,
        BOOL wantConnectorType,
        MQMSGPROPS *pmsgprops,
        PROPID *rgpropid,
        VARTYPE *rgpropvt,
        UINT cProp,
        UINT *pcPropOut
        );

    HRESULT 
    CreateSendMessageProps(
        MQMSGPROPS *pmsgprops
        );
    
    HRESULT UpdateMsgId( MQMSGPROPS *pmsgprops);

    static 
    void 
    FreeMessageProps(
        MQMSGPROPS *pmsgprops,
        BOOL fDeleteArrays
        );

    UINT 
    CMSMQMessage::PreparePropIdArray(
        BOOL fCreate,
        PROPID* aPropId,
        MQPROPVARIANT* aPropVar
        );

    HRESULT GetBinBody(VARIANT FAR* pvarBody);
    HRESULT GetVarBody(VARIANT FAR* pvarBody);
    HRESULT PutBinBody(VARIANT varBody);
    HRESULT PutVarBody(VARIANT varBody);
    HRESULT InternalAttachCurrentSecurityContext(BOOL fUseMQGetSecurityContextEx);
    void SetSendMessageProps(MQMSGPROPS* pMsgProps);

private:

    // member variables that nobody else gets to look at.
    // TODO: add your member variables and private functions here.
    long m_lClass;
    long m_lDelivery;
    long m_lPriority;
    long m_lJournal;
    //
    // We are Both-threaded and aggregate the FTM, thererfore we must marshal any interface
    // pointer we store between method calls
    // m_pqinfoResponse can be set by the user, so we don't know if it supports FTM therefore
    // we must marshal it in GIT
    //
    CGITInterface m_pqinfoResponse;
    CGITInterface m_pdestResponseEx;
    long m_lAppSpecific;
    long m_lMaxTimeToReachQueue;
    long m_lMaxTimeToReceive;
    long m_lSentTime;
    long m_lArrivedTime;
    BYTE *m_pbBody;
    VARTYPE m_vtBody;
    HGLOBAL m_hMem;       // optimization: we could always reverse
                          //  engineer from m_pbBody
    ULONG m_cbBody;
    //
    // We are Both-threaded and aggregate the FTM, thererfore we must marshal any interface
    // pointer we store between method calls
    // m_pqinfoAdmin can be set by the user, so we don't know if it supports FTM therefore
    // we must marshal it in GIT
    //
    CGITInterface m_pqinfoAdmin;
    //
    // We are Both-threaded and aggregate the FTM, thererfore we must marshal any interface
    // pointer we store between method calls
    // m_pqinfoDest/m_pdestDestEx are Read-Only, so they are always our object, which we know
    // aggregates the FTM so we don't need the GIT for that, we use a "fake" GIT
    // wrapper
    //
    CFakeGITInterface m_pqinfoDest;
    CFakeGITInterface m_pdestDestEx;
    BYTE m_rgbMsgId[PROPID_M_MSGID_SIZE];
    ULONG m_cbMsgId;
    BYTE m_rgbCorrelationId[PROPID_M_CORRELATIONID_SIZE];
    ULONG m_cbCorrelationId;
    long m_lAck;
    long m_lTrace;
    CStaticBufferGrowing<BYTE, SENDERID_INIT_SIZE> m_cSenderId;
    long m_lSenderIdType;
    CStaticBufferGrowing<BYTE, SENDERCERT_INIT_SIZE> m_cSenderCert;
    long m_lPrivLevel;
    long m_lAuthLevel;
    unsigned short m_usAuthenticatedEx;
    long m_lHashAlg;
    long m_lEncryptAlg;
    HANDLE m_hSecurityContext;

    long m_lSenderVersion;
    CStaticBufferGrowing<BYTE, EXTENSION_INIT_SIZE> m_cExtension;
    CLSID m_guidConnectorType;
    CStaticBufferGrowing<WCHAR, FORMAT_NAME_INIT_BUFFER> m_pwszXactStatusQueue;
    UINT m_cchXactStatusQueue;
    long m_idxPendingRcvXactStatusQueue; // idx of pending xact status queue in receive props (-1 if none)
    //
    // We are Both-threaded and aggregate the FTM, thererfore we must marshal any interface
    // pointer we store between method calls
    // m_pqinfoXactStatus is Read-Only, so it is always our object, which we know
    // aggregates the FTM so we don't need the GIT for that, we use a "fake" GIT
    // wrapper
    //
    CFakeGITInterface m_pqinfoXactStatus;
    CStaticBufferGrowing<BYTE, DESTSYMMKEY_INIT_SIZE> m_cDestSymmKey;
    CStaticBufferGrowing<BYTE, SIGNATURE_INIT_SIZE> m_cSignature;
    long m_lAuthProvType;
    CStaticBufferGrowing<WCHAR, AUTHPROVNAME_INIT_SIZE> m_cAuthProvName;

    BYTE m_rgbXactId[PROPID_M_XACTID_SIZE];
    ULONG m_cbXactId;
    BOOL m_fFirstInXact;
    BOOL m_fLastInXact;

    CLSID m_guidSrcMachine;
    WCHAR m_pwszLabel[MQ_MAX_MSG_LABEL_LEN + 1];
    UINT m_cchLabel;

    CStaticBufferGrowing<WCHAR, FORMAT_NAME_INIT_BUFFER> m_pwszDestQueue;
    UINT m_cchDestQueue;
    CStaticBufferGrowing<WCHAR, FORMAT_NAME_INIT_BUFFER> m_pwszRespQueue;
    UINT m_cchRespQueue;
    CStaticBufferGrowing<WCHAR, FORMAT_NAME_INIT_BUFFER> m_pwszAdminQueue;
    UINT m_cchAdminQueue;

    CStaticBufferGrowing<WCHAR, FORMAT_NAME_INIT_BUFFER_EX> m_pwszDestQueueEx;
    UINT m_cchDestQueueEx;
    CStaticBufferGrowing<WCHAR, FORMAT_NAME_INIT_BUFFER_EX> m_pwszRespQueueEx;
    UINT m_cchRespQueueEx;

    long m_idxRcvBody;
    long m_idxRcvBodySize;

    long m_idxRcvDest;
    long m_idxRcvDestLen;

    //
    // The props below are optional in order to support dependent client with MSMQ 2.0 functionality
    //
    long m_idxRcvDestEx;
    long m_idxRcvDestExLen;
    long m_idxRcvRespEx;
    long m_idxRcvRespExLen;
    long m_idxRcvSoapEnvelope;
    long m_idxRcvSoapEnvelopeSize;
    long m_idxRcvCompoundMessage;
    long m_idxRcvCompoundMessageSize;

    MQMSGPROPS m_msgprops_rcv;
    long m_idxPendingRcvRespQueue;  // idx of pending resp  queue in receive props (-1 if none)
    long m_idxPendingRcvDestQueue;  // idx of pending dest  queue in receive props (-1 if none)
    long m_idxPendingRcvAdminQueue; // idx of pending admin queue in receive props (-1 if none)
    long m_idxPendingRcvRespQueueEx;  // idx of pending respEx  queue in receive props (-1 if none)
    long m_idxPendingRcvDestQueueEx;  // idx of pending destEx  queue in receive props (-1 if none)
    PROPID        m_rgpropids_rcv [COUNT_MSGPROP_PROPS + COUNT_OPTPROP_PROPS];
    MQPROPVARIANT m_rgpropvars_rcv[COUNT_MSGPROP_PROPS + COUNT_OPTPROP_PROPS];
    HRESULT       m_rghresults_rcv[COUNT_MSGPROP_PROPS + COUNT_OPTPROP_PROPS];

    ULONGLONG m_ullLookupId;
    WCHAR m_wszLookupId[MAX_I64_CHARS + 1];
    //
    // The flags below allow us in keeping track of the state of the corresponding properties.
    // This is needed in order to allow blind forwarding of a message after receive, and to
    // generate an error when the user tries to set both props.
    // Note that after Receive we can have (for example) both respQueue (PROPID_M_RESP_QUEUE) and respQueueEx
    // (PROPID_RESP_FORMAT_NAME) filled, and this is legal, but we must use only one when sending.
    //
    BOOL m_fRespIsFromRcv;

    CStaticBufferGrowing<WCHAR, SOAP_ENVELOPE_INIT_SIZE> m_cSoapEnvelope; 
    CStaticBufferGrowing<BYTE, COMPOUND_MESSAGE_INIT_SIZE> m_cCompoundMessage;
    
    LPWSTR  m_pSoapHeader;
    LPWSTR  m_pSoapBody;
};

#define _MSMQMessage_H_
#endif // _MSMQMessage_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\q.h ===
//=--------------------------------------------------------------------------=
// MSMQQueueObj.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQQueue object.
//
//
#ifndef _MSMQQueue_H_

#include "resrc1.h"       // main symbols
#include "mq.h"

#include "oautil.h"
#include "cs.h"
#include "dispids.h"
#include <autoptr.h>

// forwards
struct IMSMQQueueInfo;
class CMSMQQueue;
struct IMSMQEvent3;

//
// helper struct for inter-thread communication:
//  used by PostMessage to pass info from
//  callback to user-defined event handler
//
//#2619 RaananH Multithread async receive
//
struct WindowsMessage
{
    union {
      HRESULT m_hrStatus;
    };
    MQMSGCURSOR m_msgcursor;
    bool m_fIsFree;
    bool m_fAllocated;
    WindowsMessage() {
      m_fIsFree = true;
      m_fAllocated = false;
    }
};
//
// 4092: Number of static window messages in a qnode for async receive notifications.
// We don't want to alloc one for each notification, but one instance is not enough - we need extra in cases
// where EnableNotification is called outside of the event handler, and just in time between the
// callback and the msgproc on the receiving thread.
// The static pool size corresponds to the number of EnableNotifications that are called this way,
// which should be small. In extreme cases where there is a need for more winmsgs, the extra ones
// are allocated from the heap.
//
const x_cWinMsgs = 3;

// helper struct for queue list
struct QueueNode
{
    CMSMQQueue *m_pq;
    //
    // 1884: indicates whether queue has outstanding
    //  event handler
    // if the window is not NULL, the queue has outstanding event handler
    // and this is the hidden window of the event. The callback posts
    // the events into this window to switch to the thread of the event object
    // m_hwnd below is set by EnableNotification and cleared by the falcon callback
    //
    HWND m_hwnd;
    QUEUEHANDLE m_lHandle;
    //
    // 4092: static pool of winmsgs
    //
    WindowsMessage m_winmsgs[x_cWinMsgs];
    QueueNode *m_pqnodeNext;
    QueueNode *m_pqnodePrev;
    QueueNode() { m_pq = NULL;
                  m_hwnd = NULL;
                  m_lHandle = INVALID_HANDLE_VALUE;
                  m_pqnodeNext = NULL;
                  m_pqnodePrev = NULL;}

    //
    // 4092: Get a free winmsg - try the static pool, if all are used - allocate one
    // NOTE: caller should have exclusive lock on this qnode
    //
    inline WindowsMessage * GetFreeWinmsg()
    {
      //
      // find a free winmsg in static pool
      //
      for (int idxTmp = 0; idxTmp < x_cWinMsgs; idxTmp++) {
        if (m_winmsgs[idxTmp].m_fIsFree) {
          m_winmsgs[idxTmp].m_fIsFree = false;
          return &m_winmsgs[idxTmp];
        }
      }
      //
      // no free winmsgs in static pool, allocate a new one
      //
      WindowsMessage *pWinmsg = new WindowsMessage;
      if (pWinmsg != NULL) {
        pWinmsg->m_fAllocated = true;
        pWinmsg->m_fIsFree = false;
      }
      return pWinmsg;
    }

    //
    // 4092: Free a winmsg - if static just mark it free, if allocated delete it
    // NOTE: caller should have exclusive lock on this qnode
    //
    static inline void FreeWinmsg(WindowsMessage *pWinmsg)
    {
      if (pWinmsg->m_fAllocated) {
        delete pWinmsg;
      }
      else {
        pWinmsg->m_fIsFree = true;
      }
    }
};

LRESULT APIENTRY CMSMQQueue_WindowProc(
                     HWND hwnd, 
                     UINT msg, 
                     WPARAM wParam, 
                     LPARAM lParam);

class ATL_NO_VTABLE CMSMQQueue : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQQueue, &CLSID_MSMQQueue>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQQueue3, &IID_IMSMQQueue3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQQueue();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQQUEUE)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQQueue)
	COM_INTERFACE_ENTRY(IMSMQQueue3)
	COM_INTERFACE_ENTRY_IID(IID_IMSMQQueue2, IMSMQQueue3) // return IMSMQQueue3 for IMSMQQueue2
	COM_INTERFACE_ENTRY_IID(IID_IMSMQQueue, IMSMQQueue3) // return IMSMQQueue3 for IMSMQQueue
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQQueue
public:
    virtual ~CMSMQQueue();

    // IMSMQQueue methods
    // TODO: copy over the interface methods for IMSMQQueue from
    //       mqInterfaces.H here.
    /* IMSMQQueue methods */
    STDMETHOD(get_Access)(THIS_ long FAR* plAccess);
    STDMETHOD(get_ShareMode)(THIS_ long FAR* plShareMode);
    STDMETHOD(get_QueueInfo)(THIS_ IMSMQQueueInfo3 FAR* FAR* ppqinfo);
    STDMETHOD(get_Handle)(THIS_ long FAR* plHandle);
    STDMETHOD(get_IsOpen)(THIS_ VARIANT_BOOL FAR* pisOpen);
    STDMETHOD(Close)(THIS);
    STDMETHOD(Receive_v1)(THIS_ VARIANT FAR* ptransaction, VARIANT FAR* wantDestQueue, VARIANT FAR* wantBody, VARIANT FAR* lReceiveTimeout, IMSMQMessage FAR* FAR* ppmsg);
    STDMETHOD(Peek_v1)(THIS_ VARIANT FAR* wantDestQueue, VARIANT FAR* wantBody, VARIANT FAR* lReceiveTimeout, IMSMQMessage FAR* FAR* ppmsg);
    STDMETHOD(EnableNotification)(THIS_ IMSMQEvent3 FAR* pqevent, VARIANT FAR* msgcursor, VARIANT FAR* lReceiveTimeout);
    STDMETHOD(Reset)(THIS);
    STDMETHOD(ReceiveCurrent_v1)(THIS_ VARIANT FAR* ptransaction, VARIANT FAR* wantDestQueue, VARIANT FAR* wantBody, VARIANT FAR* lReceiveTimeout, IMSMQMessage FAR* FAR* ppmsg);
    STDMETHOD(PeekNext_v1)(THIS_ VARIANT FAR* wantDestQueue, VARIANT FAR* wantBody, VARIANT FAR* lReceiveTimeout, IMSMQMessage FAR* FAR* ppmsg);
    STDMETHOD(PeekCurrent_v1)(THIS_ VARIANT FAR* wantDestQueue, VARIANT FAR* wantBody, VARIANT FAR* lReceiveTimeout, IMSMQMessage FAR* FAR* ppmsg);
    /* IMSMQQueue2 ReceiveX/PeekX methods */
    STDMETHOD(Receive)(THIS_
      VARIANT FAR* ptransaction,
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* lReceiveTimeout,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(Peek)(THIS_
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* lReceiveTimeout,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(ReceiveCurrent)(THIS_
      VARIANT FAR* ptransaction,
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* lReceiveTimeout,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(PeekNext)(THIS_
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* lReceiveTimeout,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(PeekCurrent)(THIS_
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* lReceiveTimeout,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    // IMSMQQueue2 additional members
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);
    // IMSMQQueue3 additional members
	STDMETHOD(get_Handle2)(THIS_ VARIANT *pvarHandle);
    //
    // ReceiveByLookupId family
    //
    STDMETHOD(ReceiveByLookupId)(THIS_
      VARIANT varLookupId,
      VARIANT FAR* ptransaction,
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(ReceiveNextByLookupId)(THIS_
      VARIANT varLookupId,
      VARIANT FAR* ptransaction,
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(ReceivePreviousByLookupId)(THIS_
      VARIANT varLookupId,
      VARIANT FAR* ptransaction,
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(ReceiveFirstByLookupId)(THIS_
      VARIANT FAR* ptransaction,
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(ReceiveLastByLookupId)(THIS_
      VARIANT FAR* ptransaction,
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    //
    // PeekByLookupId family
    //
    STDMETHOD(PeekByLookupId)(THIS_
      VARIANT varLookupId,
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(PeekNextByLookupId)(THIS_
      VARIANT varLookupId,
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(PeekPreviousByLookupId)(THIS_
      VARIANT varLookupId,
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(PeekFirstByLookupId)(THIS_
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(PeekLastByLookupId)(THIS_
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    STDMETHOD(get_IsOpen2)(THIS_ VARIANT_BOOL FAR* pisOpen);
    STDMETHOD(Purge)(THIS);

    // introduced methods
    HRESULT Init(
      LPCWSTR pwszFormatName, 
      QUEUEHANDLE lHandle,
      long lAccess,
      long lShareMode);
    HRESULT InternalReceive(
      DWORD dwAction, 
      HANDLE hCursor,
      VARIANT *pvarTransaction,
      VARIANT *wantDestQueue,
      VARIANT *wantBody,
      VARIANT *pvarReceiveTimeout,
      VARIANT FAR* wantConnectorType,
      VARIANT FAR* pvarLookupId,
      IMSMQMessage3 FAR* FAR* ppmsg);
    HRESULT InternalReceiveByLookupId(
      DWORD dwAction,
      VARIANT * pvarLookupIdParam,
      VARIANT FAR* ptransaction,
      VARIANT FAR* wantDestQueue,
      VARIANT FAR* wantBody,
      VARIANT FAR* wantConnectorType,
      IMSMQMessage3 FAR* FAR* ppmsg);
    // static methods to manipulate instance list
    static QueueNode *PqnodeOfHandle(QUEUEHANDLE lHandle);

    //
    // Critical section to guard object's data and be thread safe
	// It is initialized to preallocate its resources 
	// with flag CCriticalSection::xAllocateSpinCount. This means it may throw bad_alloc() on 
	// construction but not during usage.
    //
    CCriticalSection m_csObj;

protected:
    // static methods to manipulate instance list
    static HRESULT AddQueue(CMSMQQueue *pq, QueueNode **ppqnodeAdded);
    static void RemQueue(QueueNode *pqnode);

private:
    // member variables that nobody else gets to look at.
    // TODO: add your member variables and private functions here.
    long m_lReceiveTimeout;
    long m_lAccess;
    long m_lShareMode;
    QUEUEHANDLE m_lHandle;
    BOOL m_fInitialized;
    //
    // We are Both-threaded and aggregate the FTM, thererfore we must marshal any interface
    // pointer we store between method calls
    // m_pqinfo is always our object (it is read/only property), and since we
    // know it aggragates the free-threaded-marshaller there is no need for us to
    // marshal it on set and unmarshal it on get, we can always return a direct pointer.
    // In other words we can use CFakeGITInterface that always uses a direct ptr.
    //
    CFakeGITInterface m_pqinfo;

    // current cursor position in queue
    HANDLE m_hCursor;

    //
    // pointer to open queue node in open queue list
    //
    QueueNode * m_pqnode;
};

#define _MSMQQueue_H_
#endif // _MSMQQueue_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\msg.cpp ===
//--------------------------------------------------------------------------=
// MSMQMessageObj.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQMessage object
//
//
//
// Needed for wincrypt.h
// But defined in stdafx.h below - removed this definition
//#ifndef _WIN32_WINNT
//#define _WIN32_WINNT 0x0400
//#endif
#include "stdafx.h"
#include <windows.h>
#include <winreg.h>
#include <mqcrypt.h>
#include "limits.h"   // for UINT_MAX
#include "utilx.h"
#include "msg.H"
#include "qinfo.h"
#include "dest.h"
#include "q.h"
#include "txdtc.h"             // transaction support.
#include "xact.h"
#include "mtxdm.h"
#include "oautil.h"
#include "ilock.h"
#include "istm.h"
#include "iads.h"

#ifdef _DEBUG
extern VOID RemBstrNode(void *pv);
#endif // _DEBUG

extern IUnknown *GetPunk(VARIANT *pvar);

const MsmqObjType x_ObjectType = eMSMQMessage;

// debug...
#include "debug.h"
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#endif // _DEBUG



//
// Keep in the same order as enum MSGPROP_xxx in msg.h
//
PROPID g_rgmsgpropid[COUNT_MSGPROP_PROPS] = {
   PROPID_M_MSGID,                        //VT_UI1|VT_VECTOR
   PROPID_M_CORRELATIONID,                //VT_UI1|VT_VECTOR
   PROPID_M_PRIORITY,                     //VT_UI1
   PROPID_M_DELIVERY,                     //VT_UI1
   PROPID_M_ACKNOWLEDGE,                  //VT_UI1
   PROPID_M_JOURNAL,                      //VT_UI1
   PROPID_M_APPSPECIFIC,                  //VT_UI4
   PROPID_M_LABEL,                        //VT_LPWSTR
   PROPID_M_LABEL_LEN,                    //VT_UI4
   PROPID_M_TIME_TO_BE_RECEIVED,          //VT_UI4
   PROPID_M_TRACE,                        //VT_UI1
   PROPID_M_TIME_TO_REACH_QUEUE,          //VT_UI4
   PROPID_M_SENDERID,                     //VT_UI1|VT_VECTOR
   PROPID_M_SENDERID_LEN,                 //VT_UI4
   PROPID_M_SENDERID_TYPE,                //VT_UI4
   PROPID_M_PRIV_LEVEL,                   //VT_UI4 // must precede ENCRYPTION_ALG
   PROPID_M_AUTH_LEVEL,                   //VT_UI4
   PROPID_M_AUTHENTICATED_EX,             //VT_UI1 // must precede HASH_ALG
   PROPID_M_HASH_ALG,                     //VT_UI4
   PROPID_M_ENCRYPTION_ALG,               //VT_UI4
   PROPID_M_SENDER_CERT,                  //VT_UI1|VT_VECTOR
   PROPID_M_SENDER_CERT_LEN,              //VT_UI4
   PROPID_M_SRC_MACHINE_ID,               //VT_CLSID
   PROPID_M_SENTTIME,                     //VT_UI4
   PROPID_M_ARRIVEDTIME,                  //VT_UI4
   PROPID_M_RESP_QUEUE,                   //VT_LPWSTR
   PROPID_M_RESP_QUEUE_LEN,               //VT_UI4
   PROPID_M_ADMIN_QUEUE,                  //VT_LPWSTR
   PROPID_M_ADMIN_QUEUE_LEN,              //VT_UI4
   PROPID_M_SECURITY_CONTEXT,             //VT_UI4
   PROPID_M_CLASS,                        //VT_UI2
   PROPID_M_BODY_TYPE,                    //VT_UI4

   PROPID_M_VERSION,                      //VT_UI4
   PROPID_M_EXTENSION,                    //VT_UI1|VT_VECTOR
   PROPID_M_EXTENSION_LEN,                //VT_UI4
   PROPID_M_XACT_STATUS_QUEUE,            //VT_LPWSTR
   PROPID_M_XACT_STATUS_QUEUE_LEN,        //VT_UI4
   PROPID_M_DEST_SYMM_KEY,                //VT_UI1|VT_VECTOR
   PROPID_M_DEST_SYMM_KEY_LEN,            //VT_UI4
   PROPID_M_SIGNATURE,                    //VT_UI1|VT_VECTOR
   PROPID_M_SIGNATURE_LEN,                //VT_UI4
   PROPID_M_PROV_TYPE,                    //VT_UI4
   PROPID_M_PROV_NAME,                    //VT_LPWSTR
   PROPID_M_PROV_NAME_LEN,                //VT_UI4

   PROPID_M_XACTID,                       //VT_UI1|VT_VECTOR
   PROPID_M_FIRST_IN_XACT,                //VT_UI1
   PROPID_M_LAST_IN_XACT,                 //VT_UI1
};
//
// Keep in the same order as enum MSGPROP_xxx in msg.h
//
VARTYPE g_rgmsgpropvt[COUNT_MSGPROP_PROPS] = {
   VT_UI1|VT_VECTOR,            //   PROPID_M_MSGID
   VT_UI1|VT_VECTOR,            //   PROPID_M_CORRELATIONID
   VT_UI1,                      //   PROPID_M_PRIORITY
   VT_UI1,                      //   PROPID_M_DELIVERY
   VT_UI1,                      //   PROPID_M_ACKNOWLEDGE
   VT_UI1,                      //   PROPID_M_JOURNAL
   VT_UI4,                      //   PROPID_M_APPSPECIFIC
   VT_LPWSTR,                   //   PROPID_M_LABEL
   VT_UI4,                      //   PROPID_M_LABEL_LEN
   VT_UI4,                      //   PROPID_M_TIME_TO_BE_RECEIVED
   VT_UI1,                      //   PROPID_M_TRACE
   VT_UI4,                      //   PROPID_M_TIME_TO_REACH_QUEUE
   VT_UI1|VT_VECTOR,            //   PROPID_M_SENDERID
   VT_UI4,                      //   PROPID_M_SENDERID_LEN
   VT_UI4,                      //   PROPID_M_SENDERID_TYPE
   VT_UI4,                      //   PROPID_M_PRIV_LEVEL
   VT_UI4,                      //   PROPID_M_AUTH_LEVEL
   VT_UI1,                      //   PROPID_M_AUTHENTICATED_EX
   VT_UI4,                      //   PROPID_M_HASH_ALG
   VT_UI4,                      //   PROPID_M_ENCRYPTION_ALG
   VT_UI1|VT_VECTOR,            //   PROPID_M_SENDER_CERT
   VT_UI4,                      //   PROPID_M_SENDER_CERT_LEN
   VT_CLSID,                    //   PROPID_M_SRC_MACHINE_ID
   VT_UI4,                      //   PROPID_M_SENTTIME
   VT_UI4,                      //   PROPID_M_ARRIVEDTIME
   VT_LPWSTR,                   //   PROPID_M_RESP_QUEUE
   VT_UI4,                      //   PROPID_M_RESP_QUEUE_LEN
   VT_LPWSTR,                   //   PROPID_M_ADMIN_QUEUE
   VT_UI4,                      //   PROPID_M_ADMIN_QUEUE_LEN
   VT_UI4,                      //   PROPID_M_SECURITY_CONTEXT
   VT_UI2,                      //   PROPID_M_CLASS
   VT_UI4,                      //   PROPID_M_BODY_TYPE

   VT_UI4,                      //   PROPID_M_VERSION
   VT_UI1|VT_VECTOR,            //   PROPID_M_EXTENSION
   VT_UI4,                      //   PROPID_M_EXTENSION_LEN
   VT_LPWSTR,                   //   PROPID_M_XACT_STATUS_QUEUE
   VT_UI4,                      //   PROPID_M_XACT_STATUS_QUEUE_LEN
   VT_UI1|VT_VECTOR,            //   PROPID_M_DEST_SYMM_KEY
   VT_UI4,                      //   PROPID_M_DEST_SYMM_KEY_LEN
   VT_UI1|VT_VECTOR,            //   PROPID_M_SIGNATURE
   VT_UI4,                      //   PROPID_M_SIGNATURE_LEN
   VT_UI4,                      //   PROPID_M_PROV_TYPE
   VT_LPWSTR,                   //   PROPID_M_PROV_NAME
   VT_UI4,                      //   PROPID_M_PROV_NAME_LEN

   VT_UI1|VT_VECTOR,            //   PROPID_M_XACTID
   VT_UI1,                      //   PROPID_M_XACT_FIRST
   VT_UI1,                      //   PROPID_M_XACT_LAST
};
ULONG g_cPropRec = sizeof g_rgmsgpropid / sizeof g_rgmsgpropid[0];

//
// Keep in the same order as enum OPTPROP_xxx in msg.h
//
PROPID g_rgmsgpropidOptional[COUNT_OPTPROP_PROPS] = {
   PROPID_M_DEST_QUEUE,                   //VT_LPWSTR
   PROPID_M_DEST_QUEUE_LEN,               //VT_UI4
   PROPID_M_BODY,                         //VT_UI1|VT_VECTOR
   PROPID_M_BODY_SIZE,                    //VT_UI4
   PROPID_M_CONNECTOR_TYPE,               //VT_CLSID
   //
   // The props below are optional in order to support dependent client with MSMQ 2.0 functionality
   //
   PROPID_M_RESP_FORMAT_NAME,             //VT_LPWSTR
   PROPID_M_RESP_FORMAT_NAME_LEN,         //VT_UI4
   PROPID_M_DEST_FORMAT_NAME,             //VT_LPWSTR
   PROPID_M_DEST_FORMAT_NAME_LEN,         //VT_UI4
   PROPID_M_LOOKUPID,                     //VT_UI8
   PROPID_M_SOAP_ENVELOPE,                //VT_LPWSTR
   PROPID_M_SOAP_ENVELOPE_LEN,            //VT_UI4
   PROPID_M_COMPOUND_MESSAGE,             //VT_UI1|VT_VECTOR
   PROPID_M_COMPOUND_MESSAGE_SIZE,        //VT_UI4
   PROPID_M_SOAP_HEADER,                  //VT_LPWSTR
   PROPID_M_SOAP_BODY,                    //VT_LPWSTR  
};
//
// Keep in the same order as enum OPTPROP_xxx in msg.h
//
VARTYPE g_rgmsgpropvtOptional[COUNT_OPTPROP_PROPS] = {
  VT_LPWSTR,               //PROPID_M_DEST_QUEUE
  VT_UI4,                  //PROPID_M_DEST_QUEUE_LEN
  VT_UI1|VT_VECTOR,        //PROPID_M_BODY
  VT_UI4,                  //PROPID_M_BODY_SIZE
  VT_CLSID,                //PROPID_M_CONNECTOR_TYPE
  //
  // The props below are optional in order to support dependent client with MSMQ 2.0 functionality
  //
  VT_LPWSTR,               //PROPID_M_RESP_FORMAT_NAME
  VT_UI4,                  //PROPID_M_RESP_FORMAT_NAME_LEN
  VT_LPWSTR,               //PROPID_M_DEST_FORMAT_NAME
  VT_UI4,                  //PROPID_M_DEST_FORMAT_NAME_LEN
  VT_UI8,                  //PROPID_M_LOOKUPID
  VT_LPWSTR,               //PROPID_M_SOAP_ENVELOPE
  VT_UI4,                  //PROPID_M_SOAP_ENVELOPE_LEN
  VT_UI1|VT_VECTOR,        //PROPID_M_COMPOUND_MESSAGE
  VT_UI4,                  //PROPID_M_COMPOUND_MESSAGE_SIZE
  VT_LPWSTR,               //PROPID_M_SOAP_HEADER
  VT_LPWSTR,               //PROPID_M_SOAP_BODY
};
ULONG g_cPropRecOptional = sizeof g_rgmsgpropidOptional / sizeof g_rgmsgpropidOptional[0];

//
// Mask for valid AuthLevel values
//
const DWORD x_dwMsgAuthLevelMask = MQMSG_AUTH_LEVEL_ALWAYS |
                                   MQMSG_AUTH_LEVEL_SIG10  |
                                   MQMSG_AUTH_LEVEL_SIG20  |
                                   MQMSG_AUTH_LEVEL_SIG30;

typedef HRESULT (STDAPIVCALLTYPE * LPFNGetDispenserManager)(
                                    IDispenserManager **ppdispmgr);
//=--------------------------------------------------------------------------=
// HELPER: FreeReceiveBodyBuffer
//=--------------------------------------------------------------------------=
// helper: free Receive body buffer
//
static void FreeReceiveBodyBuffer(
    MQMSGPROPS* pmsgprops,
    UINT iBody)
{
    HGLOBAL hMem = NULL;
    CAUB *pcau = &pmsgprops->aPropVar[iBody].caub;

    if (pcau->pElems) {
      hMem = GlobalHandle(pcau->pElems);
      ASSERTMSG(hMem, "bad handle.");
      GLOBALFREE(hMem);
      pcau->pElems = NULL;
    }
}

//=--------------------------------------------------------------------------=
// HELPER: AllocateReceiveBodyBuffer
//=--------------------------------------------------------------------------=
// helper: (re)allocate Receive body buffer
//
static HGLOBAL AllocateReceiveBodyBuffer(
    MQMSGPROPS* pmsgprops,
    UINT iBody,
    DWORD dwBodySize)
{
    HGLOBAL hMem = NULL;
    CAUB *pcau;
    //
    // free current body if any
    //
    FreeReceiveBodyBuffer(pmsgprops, iBody);
    //
    // Allocating buffer
    //
    pmsgprops->aPropVar[iBody].caub.cElems = dwBodySize;
    pcau = &pmsgprops->aPropVar[iBody].caub;
    IfNullGo(hMem = GLOBALALLOC_MOVEABLE_NONDISCARD(pcau->cElems));
    pcau->pElems = (UCHAR *)GlobalLock(hMem);
    GLOBALUNLOCK(hMem);

    // fall through...

Error:
    return hMem;
}

//=--------------------------------------------------------------------------=
// HELPER: GetOptionalTransaction
//=--------------------------------------------------------------------------=
// Gets optional transaction
//
// Parameters:
//    pvarTransaction   [in]
//    pptransaction     [out]
//    pisRealXact       [out] TRUE if true pointer else enum.
//
// Output:
//
// Notes:
//
HRESULT GetOptionalTransaction(
    VARIANT *pvarTransaction,
    ITransaction **pptransaction,
    BOOL *pisRealXact)
{
    IUnknown *pmqtransaction = NULL;
    VARIANT varXact;
    VariantInit(&varXact);
    IDispatch *pdisp = NULL;
    ITransaction *ptransaction = NULL;
    HRESULT hresult = NOERROR;
    //
    // get optional transaction...
    //
    *pisRealXact = FALSE;   // pessimism
    pdisp = GetPdisp(pvarTransaction);
    if (pdisp) {
      //
      // Try IMSMQTransaction3 ITransaction property (VARIANT)
      //
      hresult = pdisp->QueryInterface(IID_IMSMQTransaction3, (LPVOID *)&pmqtransaction);
      if (SUCCEEDED(hresult)) {
        //
        // extract ITransaction interface pointer
        //
        // no deadlock - we call xact's get_Transaction/ITransaction (therefore try
        // to lock xact) but xact never locks msgs (specifically not this one...)
        //
        IfFailGo(((IMSMQTransaction3 *)pmqtransaction)->get_ITransaction(&varXact));
        if (varXact.vt == VT_UNKNOWN) {
          ASSERTMSG(varXact.punkVal, "VT_UNKNOWN with NULL punkVal from get_ITransaction");
          IfFailGo(varXact.punkVal->QueryInterface(IID_ITransaction, (void**)&ptransaction));
        }
        else {
          ASSERTMSG(varXact.vt == VT_EMPTY, "get_ITransaction returned invalid VT.");
          ptransaction = NULL;
        }
      }
      else {
        //
        // QI for IMSMQTransaction3 failed
        //
#ifdef _WIN64
        //
        // On Win64 we cant use the 32 bit Transaction member
        //
        IfFailGo(hresult);
#else //!_WIN64
        //
        // Try IMSMQTransaction Transaction property (long)
        //
        IfFailGo(pdisp->QueryInterface(IID_IMSMQTransaction, (LPVOID *)&pmqtransaction));
        ASSERTMSG(pmqtransaction, "should have a transaction.");
        //
        // extract Transaction member
        //
        // no deadlock - we call xact's get_Transaction/ITransaction (therefore try
        // to lock xact) but xact never locks msgs (specifically not this one...)
        //
        long lTransaction = 0;
        IfFailGo(((IMSMQTransaction *)pmqtransaction)->get_Transaction(&lTransaction));
        ptransaction = (ITransaction *)lTransaction;
        ADDREF(ptransaction);
#endif //_WIN64
      }
      *pisRealXact = TRUE;
    } // pdisp
    else {
      //
      // 1890: no explicit transaction supplied: use current
      //  Viper transaction if there is one... unless
      //  Nothing explicitly supplied in Variant.  Note
      //  that if arg is NULL this means that it wasn't
      //  supplied as an optional param so just treat it
      //  like Nothing, i.e. don't user Viper.
      //
      // 1915: support:
      //  MQ_NO_TRANSACTION/VT_ERROR
      //  MQ_MTS_TRANSACTION
      //  MQ_XA_TRANSACTION
      //  MQ_SINGLE_MESSAGE
      //
      if (pvarTransaction) {
        if (V_VT(pvarTransaction) == VT_ERROR) {
          ptransaction = (ITransaction *)MQ_MTS_TRANSACTION;
        }
        else {
          UINT uXactType;
          uXactType = GetNumber(pvarTransaction, UINT_MAX);
          if (uXactType != (UINT_PTR)MQ_NO_TRANSACTION &&
              uXactType != (UINT_PTR)MQ_MTS_TRANSACTION &&
              uXactType != (UINT_PTR)MQ_XA_TRANSACTION &&
              uXactType != (UINT_PTR)MQ_SINGLE_MESSAGE) {
            IfFailGo(hresult = E_INVALIDARG);
          }
          ptransaction = (ITransaction *)(UINT_PTR)uXactType;
        }
      } // if
    }
    *pptransaction = ptransaction;
Error:
    if (varXact.vt != VT_EMPTY)
    {
      ASSERTMSG(varXact.vt == VT_UNKNOWN, "invalid vt");
      RELEASE(varXact.punkVal);
    }
    RELEASE(pmqtransaction);
    return hresult;
}


static 
void 
AddPropRecOfRgproprec(
    ULONG ulPropIdx,
    const PROPID* aPropId,
    const VARTYPE* aPropVt,
    UINT cPropRec,
    PROPID* aPropidOut,
    MQPROPVARIANT* aPropVarOut,
    UINT cPropRecOut
    )
{
    ASSERTMSG(ulPropIdx < cPropRec, "Bad prop index");
    UNREFERENCED_PARAMETER(cPropRec);

    aPropidOut[cPropRecOut] = aPropId[ulPropIdx];
    aPropVarOut[cPropRecOut].vt = aPropVt[ulPropIdx];
}


static 
void 
AddPropRecOptional(
    ULONG ulPropIdx,
    PROPID* aPropId,
    MQPROPVARIANT* aPropVar,
    UINT cPropRec
    )
{
    AddPropRecOfRgproprec(
        ulPropIdx,
        g_rgmsgpropidOptional,
        g_rgmsgpropvtOptional,
        g_cPropRecOptional,
        aPropId,
        aPropVar,
        cPropRec
        );
}


static 
void 
AddPropRec(
    ULONG ulPropIdx,
    PROPID* aPropId,
    MQPROPVARIANT* aPropVar,
    UINT  cPropRec
    )
{
    AddPropRecOfRgproprec(
        ulPropIdx,
        g_rgmsgpropid,
        g_rgmsgpropvt,
        g_cPropRec,
        aPropId,
        aPropVar,
        cPropRec
        );
}


static 
void 
InitMessageProps(
    MQMSGPROPS *pmsgprops
    )
{
    pmsgprops->aPropID = NULL;
    pmsgprops->aPropVar = NULL;
    pmsgprops->aStatus = NULL;
    pmsgprops->cProp = 0;
}


static 
HRESULT 
AllocateMessageProps(
    UINT cProp,
    MQMSGPROPS* pMsgProps
    )
{
    HRESULT hresult = NOERROR;

    InitMessageProps(pMsgProps);
    pMsgProps->cProp = cProp;
    IfNullRet(pMsgProps->aPropID = new MSGPROPID[cProp]);
    IfNullFail(pMsgProps->aPropVar = new MQPROPVARIANT[cProp]);
    IfNullFail(pMsgProps->aStatus = new HRESULT[cProp]);
 
Error:
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::AllocateReceiveMessageProps
//=--------------------------------------------------------------------------=
// Allocate and init message prop arrays for receive.
//
HRESULT 
CMSMQMessage::AllocateReceiveMessageProps(
    BOOL wantDestQueue,
    BOOL wantBody,
    BOOL wantConnectorType,
    MQMSGPROPS *pmsgprops,
    PROPID *rgpropid,
    VARTYPE *rgpropvt,
    UINT cProp,
    UINT *pcPropOut)
{
    MSGPROPID propid;
    UINT i, cPropOut = cProp, cPropOld = cProp;
    HRESULT hresult = NOERROR;

    if (wantDestQueue) {
      cPropOut++;      // PROPID_M_DEST_QUEUE
      cPropOut++;      // PROPID_M_DEST_QUEUE_LEN
    }
    if (wantBody) {
      cPropOut++;      // PROPID_M_BODY
      cPropOut++;      // PROPID_M_BODY_SIZE
    }
    if (wantConnectorType) {
      cPropOut++;      // PROPID_M_CONNECTOR_TYPE
    }
    if (!g_fDependentClient) {
      //
      // not dep client, receive all new props
      //
      cPropOut += x_cPropsNotInDepClient;
    }
    pmsgprops->cProp = cPropOut;

    memcpy(pmsgprops->aPropID, rgpropid, cPropOld*sizeof(PROPID));
    for (i = 0; i < cPropOld; i++) {
      pmsgprops->aPropVar[i].vt = rgpropvt[i];
    }
    if (wantDestQueue) {
      m_idxRcvDest = cPropOld;
      pmsgprops->aPropID[cPropOld] = propid = PROPID_M_DEST_QUEUE;
      pmsgprops->aPropVar[cPropOld++].vt = g_rgmsgpropvtOptional[OPTPROP_DEST_QUEUE];
      m_idxRcvDestLen = cPropOld;
      pmsgprops->aPropID[cPropOld] = propid = PROPID_M_DEST_QUEUE_LEN;
      pmsgprops->aPropVar[cPropOld++].vt = g_rgmsgpropvtOptional[OPTPROP_DEST_QUEUE_LEN];
    }
    if (wantBody) {
      //
      //PROPID_M_BODY
      //
      pmsgprops->aPropID[cPropOld] = propid = PROPID_M_BODY;
      m_idxRcvBody = cPropOld;
      pmsgprops->aPropVar[cPropOld].vt = g_rgmsgpropvtOptional[OPTPROP_BODY];
      //
      // nullify body buffer so that we won't try to free it in d'tor
      //
      pmsgprops->aPropVar[cPropOld].caub.pElems = NULL;
      pmsgprops->aPropVar[cPropOld].caub.cElems = 0;
      cPropOld++;
      //
      //PROPID_M_BODY_SIZE
      //
      pmsgprops->aPropID[cPropOld] = propid = PROPID_M_BODY_SIZE;
      m_idxRcvBodySize = cPropOld;
      pmsgprops->aPropVar[cPropOld].vt = g_rgmsgpropvtOptional[OPTPROP_BODY_SIZE];
      cPropOld++;
    }
    if (wantConnectorType) {
      pmsgprops->aPropID[cPropOld] = propid = PROPID_M_CONNECTOR_TYPE;
      pmsgprops->aPropVar[cPropOld].vt = g_rgmsgpropvtOptional[OPTPROP_CONNECTOR_TYPE];
      cPropOld++;
    }
    if (!g_fDependentClient) {
      //
      // not dep client, receive all new props
      //
      // PROPID_M_RESP_FORMAT_NAME, PROPID_M_RESP_FORMAT_NAME_LEN
      //
      m_idxRcvRespEx = cPropOld;
      pmsgprops->aPropID[cPropOld] = PROPID_M_RESP_FORMAT_NAME;
      pmsgprops->aPropVar[cPropOld++].vt = g_rgmsgpropvtOptional[OPTPROP_RESP_FORMAT_NAME];
      m_idxRcvRespExLen = cPropOld;
      pmsgprops->aPropID[cPropOld] = PROPID_M_RESP_FORMAT_NAME_LEN;
      pmsgprops->aPropVar[cPropOld++].vt = g_rgmsgpropvtOptional[OPTPROP_RESP_FORMAT_NAME_LEN];
      //
      // PROPID_M_DEST_FORMAT_NAME, PROPID_M_DEST_FORMAT_NAME_LEN
      //
      m_idxRcvDestEx = cPropOld;
      pmsgprops->aPropID[cPropOld] = PROPID_M_DEST_FORMAT_NAME;
      pmsgprops->aPropVar[cPropOld++].vt = g_rgmsgpropvtOptional[OPTPROP_DEST_FORMAT_NAME];
      m_idxRcvDestExLen = cPropOld;
      pmsgprops->aPropID[cPropOld] = PROPID_M_DEST_FORMAT_NAME_LEN;
      pmsgprops->aPropVar[cPropOld++].vt = g_rgmsgpropvtOptional[OPTPROP_DEST_FORMAT_NAME_LEN];
      //
      // PROPID_M_LOOKUPID
      //
      pmsgprops->aPropID[cPropOld] = PROPID_M_LOOKUPID;
      pmsgprops->aPropVar[cPropOld].vt = g_rgmsgpropvtOptional[OPTPROP_LOOKUPID];
      cPropOld++;
      //
      // PROPID_M_SOAP_ENVELOPE, PROPID_M_SOAP_ENVELOPE_LEN
      //
      m_idxRcvSoapEnvelope = cPropOld;
      pmsgprops->aPropID[cPropOld] = PROPID_M_SOAP_ENVELOPE;
      pmsgprops->aPropVar[cPropOld++].vt = g_rgmsgpropvtOptional[OPTPROP_SOAP_ENVELOPE];
      m_idxRcvSoapEnvelopeSize = cPropOld;
      pmsgprops->aPropID[cPropOld] = PROPID_M_SOAP_ENVELOPE_LEN;
      pmsgprops->aPropVar[cPropOld++].vt = g_rgmsgpropvtOptional[OPTPROP_SOAP_ENVELOPE_LEN];
      //
      // PROPID_M_COMPOUND_MESSAGE, PROPID_M_COMPOUND_MESSAGE_SIZE
      //
      m_idxRcvCompoundMessage = cPropOld;
      pmsgprops->aPropID[cPropOld] = PROPID_M_COMPOUND_MESSAGE;
      pmsgprops->aPropVar[cPropOld++].vt = g_rgmsgpropvtOptional[OPTPROP_COMPOUND_MESSAGE];
      m_idxRcvCompoundMessageSize = cPropOld;
      pmsgprops->aPropID[cPropOld] = PROPID_M_COMPOUND_MESSAGE_SIZE;
      pmsgprops->aPropVar[cPropOld++].vt = g_rgmsgpropvtOptional[OPTPROP_COMPOUND_MESSAGE_SIZE];

    }
    ASSERTMSG(cPropOld == cPropOut, "property count mismatch.");
    *pcPropOut = cPropOut;
    // fall through...

//Error:
    return hresult;
}


//=--------------------------------------------------------------------------=
// HELPER: GetPersistInfo
//=--------------------------------------------------------------------------=
// Gets persistance information
//
// Parameters:
//    punk              [in]  IUnknown
//    pmsgtype          [out] MSGTYPE_STORAGE, MSGTYPE_STREAM, MSGTYPE_STREAM_INIT
//    ppPersistIface    [out] IPersistStorage, IPersistStream, IPersistStreamInit
//
// Output:
//
// Notes:
//
static HRESULT GetPersistInfo(IUnknown * punk,
                              MSGTYPE * pmsgtype,
                              void **ppPersistIface)
{
    HRESULT hresult;

    //
    // try IPersistStream..
    //
    hresult = punk->QueryInterface(IID_IPersistStream, ppPersistIface);

    if (FAILED(hresult)) {
      //
      // try IPersistStreamInit...
      //
      hresult = punk->QueryInterface(IID_IPersistStreamInit, ppPersistIface);

      if (FAILED(hresult)) {
        //
        // try IPersistStorage...
        //
        hresult = punk->QueryInterface(IID_IPersistStorage, ppPersistIface);
        if (FAILED(hresult)) {
          //
          // no persist interfaces
          //
          return hresult;
        }
        else {//IPersistStorage
          *pmsgtype = MSGTYPE_STORAGE;
        }
      }
      else {//IPersistStreamInit
        *pmsgtype = MSGTYPE_STREAM_INIT;
      }
    }
    else {//IPersistStream
      *pmsgtype = MSGTYPE_STREAM;
    }

    return NOERROR;
}


//=--------------------------------------------------------------------------=
// HELPER: InternalOleLoadFromStream
//=--------------------------------------------------------------------------=
// Loads object from stream
//
// Parameters:
//    pStm          [in]  The stream to load from
//    iidInterface  [in]  The requested interface
//    ppvObj        [out] Output interface pointer
//
// Output:
//
// Notes:
//    OleLoadFromStream doesn't ask for IPersistStreamInit, so it fails for objects
//    that only implement it and not IPersistStream.
//    We immitate this helper function, and look at IPersistStreamInit as well
//
static InternalOleLoadFromStream(IStream * pStm,
                                 REFIID iidInterface,
                                 void ** ppvObj)
{
    HRESULT hresult = NOERROR;
    IUnknown * pUnk = NULL;
    IPersistStream * pPersistIface = NULL;

    //
    // create object
    //
    CLSID clsid;
    IfFailGo(ReadClassStm(pStm, &clsid));
    IfFailGo(CoCreateInstance(clsid,
                              NULL,
                              CLSCTX_SERVER,
                              iidInterface,
                              (void **)&pUnk));
    //
    // try IPersistStream
    //
    hresult = pUnk->QueryInterface(IID_IPersistStream, (void **)&pPersistIface);
    if (FAILED(hresult)) {
      //
      // try IPersistStreamInit
      // IPersistStreamInit and IPersistStream can both be treated as IPersistStream
      //
      IfFailGo(pUnk->QueryInterface(IID_IPersistStreamInit, (void **)&pPersistIface));
    }

    //
    // IPersistStreamInit and IPersistStream can both be treated as IPersistStream
    //
    IfFailGo(pPersistIface->Load(pStm));

    //
    // Query for requested interface
    //
    IfFailGo(pUnk->QueryInterface(iidInterface, ppvObj));

Error:
    RELEASE(pPersistIface);
    RELEASE(pUnk);
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::CMSMQMessage
//=--------------------------------------------------------------------------=
// create the object
//
// Parameters:
//
// Notes:
//
CMSMQMessage::CMSMQMessage() :
	m_csObj(CCriticalSection::xAllocateSpinCount)
{
    // TODO: initialize anything here
    //
    m_pUnkMarshaler = NULL; // ATL's Free Threaded Marshaler
    m_lClass = -1;      // illegal value...
    m_lDelivery = DEFAULT_M_DELIVERY;
    m_lPriority = DEFAULT_M_PRIORITY;
    m_lJournal = DEFAULT_M_JOURNAL;
    m_lAppSpecific = DEFAULT_M_APPSPECIFIC;
    m_pbBody = NULL;
    m_vtBody = VT_ARRAY | VT_UI1; // default: safearray of bytes
    m_hMem = NULL;
    m_cbBody = 0;
    m_cbMsgId = 0;
    m_cbCorrelationId = 0;
    m_lAck = DEFAULT_M_ACKNOWLEDGE;
    memset(m_pwszLabel, 0, sizeof(WCHAR));
    m_cchLabel = 0;           // empty
    m_lTrace = MQMSG_TRACE_NONE;
    m_lSenderIdType = DEFAULT_M_SENDERID_TYPE;
    m_lPrivLevel = DEFAULT_M_PRIV_LEVEL;
    m_lAuthLevel = DEFAULT_M_AUTH_LEVEL;
    m_usAuthenticatedEx = MQMSG_AUTHENTICATION_NOT_REQUESTED;

	//
	// Both those defaults are from mqcrypt.h, they are not exposed in mq.h
	//
    m_lHashAlg = PROPID_M_DEFUALT_HASH_ALG;
    m_lEncryptAlg = PROPID_M_DEFUALT_ENCRYPT_ALG;

    m_lMaxTimeToReachQueue = -1;
    m_lMaxTimeToReceive = -1;
    m_lSentTime = -1;
    m_lArrivedTime = -1;

    memset(m_pwszDestQueue.GetBuffer(), 0, sizeof(WCHAR));
    m_cchDestQueue = 0;            // empty
    memset(m_pwszRespQueue.GetBuffer(), 0, sizeof(WCHAR));
    m_cchRespQueue = 0;            // empty
    memset(m_pwszAdminQueue.GetBuffer(), 0, sizeof(WCHAR));
    m_cchAdminQueue = 0;            // empty

    memset(m_pwszDestQueueEx.GetBuffer(), 0, sizeof(WCHAR));
    m_cchDestQueueEx = 0;            // empty
    memset(m_pwszRespQueueEx.GetBuffer(), 0, sizeof(WCHAR));
    m_cchRespQueueEx = 0;            // empty
    
    m_hSecurityContext = NULL;   // ignored...
    m_guidSrcMachine = GUID_NULL;
    m_msgprops_rcv.cProp = 0;
    m_msgprops_rcv.aPropID  = m_rgpropids_rcv;
    m_msgprops_rcv.aPropVar = m_rgpropvars_rcv;
    m_msgprops_rcv.aStatus  = m_rghresults_rcv;

    m_idxPendingRcvRespQueue  = -1; //no pending resp  queue in receive props
    m_idxPendingRcvDestQueue  = -1; //no pending dest  queue in receive props
    m_idxPendingRcvAdminQueue = -1; //no pending admin queue in receive props

    m_idxPendingRcvRespQueueEx  = -1; //no pending resp  queue in receive props
    m_idxPendingRcvDestQueueEx  = -1; //no pending dest  queue in receive props

    m_lSenderVersion = 0;
    m_guidConnectorType = GUID_NULL;
    memset(m_pwszXactStatusQueue.GetBuffer(), 0, sizeof(WCHAR));
    m_cchXactStatusQueue = 0;            // empty
    m_idxPendingRcvXactStatusQueue = -1; //no pending xact status queue in receive props
    m_lAuthProvType = 0;

    m_cbXactId = 0;
    m_fFirstInXact = FALSE;
    m_fLastInXact = FALSE;

    m_idxRcvBody = -1;
    m_idxRcvBodySize = -1;

    m_idxRcvDest = -1;
    m_idxRcvDestLen = -1;

    m_idxRcvDestEx = -1;
    m_idxRcvDestExLen = -1;
    m_idxRcvRespEx = -1;
    m_idxRcvRespExLen = -1;

    m_ullLookupId = DEFAULT_M_LOOKUPID;
    m_wszLookupId[0] = '\0'; // String representation not initialized yet

    m_fRespIsFromRcv = FALSE;

    m_idxRcvSoapEnvelope = -1;
    m_idxRcvSoapEnvelopeSize = -1;
    m_idxRcvCompoundMessage = -1;
    m_idxRcvCompoundMessageSize = -1;
    m_pSoapHeader = NULL;
    m_pSoapBody = NULL;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::~CMSMQMessage
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//
CMSMQMessage::~CMSMQMessage ()
{
    // TODO: clean up anything here.
    if (m_idxRcvBody != -1) 
    {
        //
        // free current body if any
        //
        FreeReceiveBodyBuffer(&m_msgprops_rcv, m_idxRcvBody);
    }
    FreeMessageProps(&m_msgprops_rcv, FALSE/*fDeleteArrays*/);
    GLOBALFREE(m_hMem);
    if (m_hSecurityContext != NULL)
    {
        MQFreeSecurityContext(m_hSecurityContext);
    }
    delete [] m_pSoapHeader;
    delete [] m_pSoapBody;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQMessage::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
                &IID_IMSMQMessage3,
                &IID_IMSMQMessage2,
                &IID_IMSMQMessage,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Class
//=--------------------------------------------------------------------------=
// Gets message class of message
//
// Parameters:
//    plClass - [out] message's class
//
// Output:
//
// Notes:
// Obsolete, replaced by MsgClass
//
HRESULT CMSMQMessage::get_Class(long FAR* plClass)
{
    return get_MsgClass(plClass);
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::get_MsgClass
//=--------------------------------------------------------------------------=
// Gets message class of message
//
// Parameters:
//    plMsgClass - [out] message's class
//
// Output:
//
// Notes:
// we needed MsgClass so that Java can access the Class property (GetClass conflicts
// with Java's internal GetClass method).
//
HRESULT CMSMQMessage::get_MsgClass(long FAR* plMsgClass)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plMsgClass = m_lClass;
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::put_MsgClass
//=--------------------------------------------------------------------------=
// Sets message class of message
//
// Parameters:
//    lMsgClass - [in] message's class
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_MsgClass(long lMsgClass)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    m_lClass = lMsgClass;
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Delivery
//=--------------------------------------------------------------------------=
// Gets message's delivery option
//
// Parameters:
//    pdelivery - [in] message's delivery option
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_Delivery(long FAR* plDelivery)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plDelivery = m_lDelivery;
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::put_Delivery
//=--------------------------------------------------------------------------=
// Sets delivery option for message
//
// Parameters:
//    delivery - [in] message's delivery option
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_Delivery(long lDelivery)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    switch (lDelivery) {
    case MQMSG_DELIVERY_EXPRESS:
    case MQMSG_DELIVERY_RECOVERABLE:
      m_lDelivery = lDelivery;
      return NOERROR;
    default:
      return CreateErrorHelper(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, x_ObjectType);
    }
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_HashAlgorithm
//=--------------------------------------------------------------------------=
// Gets message's hash algorithm
//
// Parameters:
//    plHashAlg - [in] message's hash alg
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_HashAlgorithm(long FAR* plHashAlg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plHashAlg = m_lHashAlg;
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::put_HashAlgorithm
//=--------------------------------------------------------------------------=
// Sets message's hash alg
//
// Parameters:
//    lHashAlg - [in] message's hash alg
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_HashAlgorithm(long lHashAlg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    m_lHashAlg = lHashAlg;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_EncryptAlgorithm
//=--------------------------------------------------------------------------=
// Gets message's encryption algorithm
//
// Parameters:
//    plEncryptAlg - [out] message's encryption alg
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_EncryptAlgorithm(long FAR* plEncryptAlg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plEncryptAlg = m_lEncryptAlg;
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::put_EncryptAlgorithm
//=--------------------------------------------------------------------------=
// Sets message's encryption alg
//
// Parameters:
//    lEncryptAlg - [in] message's crypt alg
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_EncryptAlgorithm(long lEncryptAlg)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    m_lEncryptAlg = lEncryptAlg;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_SenderIdType
//=--------------------------------------------------------------------------=
// Gets message's sender id type
//
// Parameters:
//    plSenderIdType - [in] message's sender id type
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_SenderIdType(long FAR* plSenderIdType)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plSenderIdType = m_lSenderIdType;
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::put_SenderIdType
//=--------------------------------------------------------------------------=
// Sets sender id type for message
//
// Parameters:
//    lSenderIdType - [in] message's sender id type
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_SenderIdType(long lSenderIdType)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    switch (lSenderIdType) {
    case MQMSG_SENDERID_TYPE_NONE:
    case MQMSG_SENDERID_TYPE_SID:
      m_lSenderIdType = lSenderIdType;
      return NOERROR;
    default:
      return CreateErrorHelper(
               MQ_ERROR_ILLEGAL_PROPERTY_VALUE,
               x_ObjectType);
    }
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_PrivLevel
//=--------------------------------------------------------------------------=
// Gets message's privlevel
//
// Parameters:
//    plPrivLevel - [in] message's privlevel
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_PrivLevel(long FAR* plPrivLevel)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plPrivLevel = m_lPrivLevel;
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::put_PrivLevel
//=--------------------------------------------------------------------------=
// Sets privlevel for message
//
// Parameters:
//    lPrivLevel - [in] message's sender id type
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_PrivLevel(long lPrivLevel)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    switch (lPrivLevel) {
    case MQMSG_PRIV_LEVEL_NONE:
    case MQMSG_PRIV_LEVEL_BODY_BASE:
    case MQMSG_PRIV_LEVEL_BODY_ENHANCED:
      m_lPrivLevel = lPrivLevel;
      return NOERROR;
    default:
      return CreateErrorHelper(
               MQ_ERROR_ILLEGAL_PROPERTY_VALUE,
               x_ObjectType);
    }
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_AuthLevel
//=--------------------------------------------------------------------------=
// Gets message's authlevel
//
// Parameters:
//    plAuthLevel - [in] message's authlevel
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_AuthLevel(long FAR* plAuthLevel)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plAuthLevel = m_lAuthLevel;
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::put_AuthLevel
//=--------------------------------------------------------------------------=
// Sets authlevel for message
//
// Parameters:
//    lAuthLevel - [in] message's authlevel
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_AuthLevel(long lAuthLevel)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    //
    // lAuthLevel can be any combination of auth level values, check value is in mask
    //
    if (((DWORD)lAuthLevel) & (~x_dwMsgAuthLevelMask)) {
      return CreateErrorHelper(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, x_ObjectType);
    }
    m_lAuthLevel = lAuthLevel;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_IsAuthenticated
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pisAuthenticated  [out]
//
// Output:
//
// Notes:
//    returns 1 if true, 0 if false
//
HRESULT CMSMQMessage::get_IsAuthenticated(VARIANT_BOOL *pisAuthenticated)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *pisAuthenticated = (VARIANT_BOOL)CONVERT_TRUE_TO_1_FALSE_TO_0(m_usAuthenticatedEx != MQMSG_AUTHENTICATION_NOT_REQUESTED);
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_IsAuthenticated2
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pisAuthenticated  [out]
//
// Output:
//
// Notes:
//    same as get_IsAuthenticated, but returns VARIANT_TRUE (-1) if true, VARIANT_FALSE (0) if false
//
HRESULT CMSMQMessage::get_IsAuthenticated2(VARIANT_BOOL *pisAuthenticated)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *pisAuthenticated = CONVERT_BOOL_TO_VARIANT_BOOL(m_usAuthenticatedEx != MQMSG_AUTHENTICATION_NOT_REQUESTED);
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Trace
//=--------------------------------------------------------------------------=
// Gets message's trace option
//
// Parameters:
//    plTrace - [in] message's trace option
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_Trace(long FAR* plTrace)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plTrace = m_lTrace;
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::put_Trace
//=--------------------------------------------------------------------------=
// Sets trace option for message
//
// Parameters:
//    trace - [in] message's trace option
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_Trace(long lTrace)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    switch (lTrace) {
    case MQMSG_TRACE_NONE:
    case MQMSG_SEND_ROUTE_TO_REPORT_QUEUE:
      m_lTrace = lTrace;
      return NOERROR;
    default:
      return CreateErrorHelper(
               MQ_ERROR_ILLEGAL_PROPERTY_VALUE,
               x_ObjectType);
    }
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Priority
//=--------------------------------------------------------------------------=
// Gets message's priority
//
// Parameters:
//    plPriority - [out] message's priority
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_Priority(long FAR* plPriority)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plPriority = m_lPriority;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_Priority
//=--------------------------------------------------------------------------=
// Sets message's priority
//
// Parameters:
//    lPriority - [in] message's priority
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_Priority(long lPriority)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if ((lPriority >= MQ_MIN_PRIORITY) &&
        (lPriority <= MQ_MAX_PRIORITY)) {
      m_lPriority = lPriority;
      return NOERROR;
    }
    else {
      return CreateErrorHelper(
                 MQ_ERROR_ILLEGAL_PROPERTY_VALUE,
                 x_ObjectType);
    }
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Journal
//=--------------------------------------------------------------------------=
// Gets message's journaling option
//
// Parameters:
//    plJournal - [out] message's journaling option
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_Journal(long FAR* plJournal)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plJournal = m_lJournal;
    return NOERROR;
}

#define MQMSG_JOURNAL_MASK  (MQMSG_JOURNAL_NONE | \
                              MQMSG_DEADLETTER | \
                              MQMSG_JOURNAL)

//=--------------------------------------------------------------------------=
// CMSMQMessage::put_Journal
//=--------------------------------------------------------------------------=
// Sets journaling option for message
//
// Parameters:
//    lJournal - [in] message's admin queue
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_Journal(long lJournal)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    //
    // ensure that no bits are set in incoming lJournal
    //  flags word other than our mask.
    //
    if (lJournal & ~MQMSG_JOURNAL_MASK) {
      return CreateErrorHelper(
               MQ_ERROR_ILLEGAL_PROPERTY_VALUE,
               x_ObjectType);
    }
    else {
      m_lJournal = lJournal;
      return NOERROR;
    }
}


//=--------------------------------------------------------------------------=
// HELPER: GetQueueInfoOfFormatNameProp
//=--------------------------------------------------------------------------=
// Converts string message prop to bstr after send/receive.
//
// Parameters:
//    pmsgprops - [in] pointer to message properties struct
//    ppqinfo     [out]
//
// Output:
//
static HRESULT GetQueueInfoOfFormatNameProp(
    MQMSGPROPS *pmsgprops,
    UINT iProp,
    const WCHAR *pwsz,
    const IID * piidRequested,
    IUnknown **ppqinfo)
{
    CComObject<CMSMQQueueInfo> *pqinfoObj;
    IUnknown * pqinfo = NULL;
    HRESULT hresult = NOERROR;

    ASSERTMSG(ppqinfo, "bad param.");
    if (pmsgprops->aPropVar[iProp].lVal) {
      IfFailGo(CNewMsmqObj<CMSMQQueueInfo>::NewObj(&pqinfoObj, piidRequested, &pqinfo));
      IfFailGoTo(pqinfoObj->Init(pwsz), Error2);
      *ppqinfo = pqinfo;
      goto Error;         // 2657: fix memleak
    }
    return NOERROR;

Error2:
    RELEASE(pqinfo);
    // fall through...

Error:
    return hresult;
}

//=--------------------------------------------------------------------------=
// Helper - GetQueueInfoOfMessage
//=--------------------------------------------------------------------------=
// Gets Response/Admin/Dest/XactStatus queue of the message
//
// Parameters:
//    pidxPendingRcv       [in, out] - index of len property in rcv props (-1 if not pending)
//    pmsgpropsRcv         [in]      - msg props
//    pwszFormatNameBuffer [in]      - format name buffer
//    pGITQueueInfo        [in]      - Base GIT member for the qinfo interface (could be fake or real)
//    piidRequested        [in]      - either IMSMQQueueInfo/IMSMQQueueInfo2/IMSMQQueueInfo3
//    ppqinfo              [out]     - resulting qinfo
//
// Output:
//
// Notes:
//    caller must Release returned obj pointer.
//
static HRESULT GetQueueInfoOfMessage(
    long * pidxPendingRcv,
    MQMSGPROPS * pmsgpropsRcv,
    LPCWSTR pwszFormatNameBuffer,
    CBaseGITInterface * pGITQueueInfo,
    const IID *piidRequested,
    IUnknown ** ppqinfo)
{
    HRESULT hresult = NOERROR;
    //
    // if we have a queue pending in rcv props, create a qinfo for it,
    // register it in GIT object, and set returned qinfo with it
    //
    if (*pidxPendingRcv >= 0) {
      R<IUnknown> pqinfoPendingRcv;
      IfFailGo(GetQueueInfoOfFormatNameProp(pmsgpropsRcv,
                                            *pidxPendingRcv,
                                            pwszFormatNameBuffer,
                                            piidRequested,
                                            &pqinfoPendingRcv.ref()));
      //
      // Register qinfo in the GITInterface object
      //
      IfFailGo(pGITQueueInfo->Register(pqinfoPendingRcv.get(), piidRequested));
      *pidxPendingRcv = -1; // queue not pending anymore
      //
      // We just created the qinfo, we can return it as is, no need for marshling.
      // Note it is already addref'ed, so we just detach it from the auto release variable
      // which held it
      //
      *ppqinfo = pqinfoPendingRcv.detach();
    }
    else
    {
      //
      // qinfo was not pending from receive
      // We need to get it from the GIT object (we request NULL as default if qinfo
      // was not registered yet.
      //
      IfFailGo(pGITQueueInfo->GetWithDefault(piidRequested, ppqinfo, NULL));
    }

    //
    // Fall through
    //
Error:
    return hresult;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::get_ResponseQueueInfo_v1 (for IMSMQMessage)
//=--------------------------------------------------------------------------=
// Gets Response queue for message
//
// Parameters:
//    ppqResponse - [out] message's Response queue
//
// Output:
//
// Notes:
//    caller must Release returned obj pointer.
//
HRESULT CMSMQMessage::get_ResponseQueueInfo_v1(
    IMSMQQueueInfo FAR* FAR* ppqinfoResponse)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = GetQueueInfoOfMessage(&m_idxPendingRcvRespQueue,
                                            &m_msgprops_rcv,
                                            m_pwszRespQueue.GetBuffer(),
                                            &m_pqinfoResponse,
                                            &IID_IMSMQQueueInfo,
                                            (IUnknown **)ppqinfoResponse);
    return CreateErrorHelper(hresult, x_ObjectType);
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::get_ResponseQueueInfo_v2 (for IMSMQMessage2)
//=--------------------------------------------------------------------------=
// Gets Response queue for message
//
// Parameters:
//    ppqResponse - [out] message's Response queue
//
// Output:
//
// Notes:
//    caller must Release returned obj pointer.
//
HRESULT CMSMQMessage::get_ResponseQueueInfo_v2(
    IMSMQQueueInfo2 FAR* FAR* ppqinfoResponse)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = GetQueueInfoOfMessage(&m_idxPendingRcvRespQueue,
                                            &m_msgprops_rcv,
                                            m_pwszRespQueue.GetBuffer(),
                                            &m_pqinfoResponse,
                                            &IID_IMSMQQueueInfo2,
                                            (IUnknown **)ppqinfoResponse);
    return CreateErrorHelper(hresult, x_ObjectType);
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::get_ResponseQueueInfo (for IMSMQMessage3)
//=--------------------------------------------------------------------------=
// Gets Response queue for message
//
// Parameters:
//    ppqResponse - [out] message's Response queue
//
// Output:
//
// Notes:
//    caller must Release returned obj pointer.
//
HRESULT CMSMQMessage::get_ResponseQueueInfo(
    IMSMQQueueInfo3 FAR* FAR* ppqinfoResponse)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = GetQueueInfoOfMessage(&m_idxPendingRcvRespQueue,
                                            &m_msgprops_rcv,
                                            m_pwszRespQueue.GetBuffer(),
                                            &m_pqinfoResponse,
                                            &IID_IMSMQQueueInfo3,
                                            (IUnknown **)ppqinfoResponse);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// Helper - PutrefQueueInfoOfMessage
//=--------------------------------------------------------------------------=
// Putref's Response/Admin queue of the message
//
// Parameters:
//    pqinfo               [in]      - qinfo to putref
//    pidxPendingRcv       [out]     - index of len property in rcv props (-1 if not pending)
//    pwszFormatNameBuffer [in]      - format name buffer
//    pcchFormatNameBuffer [out]     - size of string in format name buffer
//    pGITQueueInfo        [in]      - Base GIT member for the qinfo interface (could be fake or real)
//    pidxPendingRcvDestination       [out] - index of len property to clear (xxxDestination) in rcv props (-1 if not pending)
//    pwszFormatNameBufferDestination [in]  - format name buffer to clear (xxxDestination)
//    pcchFormatNameBufferDestination [out] - size of string in format name buffer to clear (xxxDestination)
//    pGITDestination                 [in]  - Base GIT member for the destination obj interface to clear (could be fake or real)
//    pfIsFromRcv                     [out] - whether xxxDestination and xxxQueueInfo were both set by receive
//
// Output:
//
static HRESULT PutrefQueueInfoOfMessage(
    IUnknown * punkQInfo,
    long * pidxPendingRcv,
    CBaseStaticBufferGrowing<WCHAR> * pwszFormatNameBuffer,
    UINT * pcchFormatNameBuffer,
    CBaseGITInterface * pGITQueueInfo,    

    long * pidxPendingRcvDestination,
    CBaseStaticBufferGrowing<WCHAR> * pwszFormatNameBufferDestination,
    UINT * pcchFormatNameBufferDestination,
    CBaseGITInterface * pGITDestination,

    BOOL * pfIsFromRcv
    )
{
    //
    // can't set xxxQueueInfo if xxxDestination is set and not by receive
    //
    if ((pcchFormatNameBufferDestination != NULL) && (*pcchFormatNameBufferDestination != 0) && !(*pfIsFromRcv)) {
      return MQ_ERROR_PROPERTIES_CONFLICT;
    }
    //
    // either both xxxQueueInfo and xxxDestination were set by receive, or xxxDestination is empty
    //
    ASSERT((pcchFormatNameBufferDestination == NULL) || (*pcchFormatNameBufferDestination == 0) || (*pfIsFromRcv));
    HRESULT hresult;
    R<IUnknown> pqinfo;
    const IID * piid = &IID_NULL;
    //
    // Get best queue info
    //
    if (punkQInfo) {
      hresult = punkQInfo->QueryInterface(IID_IMSMQQueueInfo3, (void **)&pqinfo.ref());
      if (SUCCEEDED(hresult)) {
        piid = &IID_IMSMQQueueInfo3;
      }
      else {
        hresult = punkQInfo->QueryInterface(IID_IMSMQQueueInfo2, (void **)&pqinfo.ref());
        if (SUCCEEDED(hresult)) {
          piid = &IID_IMSMQQueueInfo2;
        }
        else {
          IfFailRet(punkQInfo->QueryInterface(IID_IMSMQQueueInfo, (void **)&pqinfo.ref()));
          piid = &IID_IMSMQQueueInfo;
        }      
      }
    }
    //
    // register interface in GIT object
    //
    IfFailRet(pGITQueueInfo->Register(pqinfo.get(), piid));
    *pidxPendingRcv = -1; // this is more current than pending queue from receive (if any)
    if(pfIsFromRcv != NULL)
	{
	    *pfIsFromRcv = FALSE; // the property was set by the user, not by last receive
	}
    //
    // Update our formatname buffer
    //
    if (pqinfo.get()) {
      //
      // no deadlock - we call qinfo's get_FormatName (therefore try
      // to lock qinfo) but qinfo never locks msgs (specifically not this one...)
      //
      // pqinfo has at least IMSMQQueueInfo functionality (any newer interface for qinfo
      // object is binary compatible to the older)
      //
      BSTR bstrFormatName;
      IfFailRet(((IMSMQQueueInfo*)pqinfo.get())->get_FormatName(&bstrFormatName));
      ASSERTMSG(bstrFormatName != NULL, "bstrFormatName is NULL");
      //
      // copy format name
      //
      ULONG cchFormatNameBuffer = static_cast<ULONG>(wcslen(bstrFormatName));
      IfFailRet(pwszFormatNameBuffer->CopyBuffer(bstrFormatName, cchFormatNameBuffer+1));
      *pcchFormatNameBuffer = cchFormatNameBuffer;
      SysFreeString(bstrFormatName);
    }
    else {
      //
      // we were passed NULL. we empty the formatname buffer.
      //
      memset(pwszFormatNameBuffer->GetBuffer(), 0, sizeof(WCHAR));
      *pcchFormatNameBuffer = 0;
    }

	if(pidxPendingRcvDestination == NULL)
		return NOERROR;
    //
    // Clear the xxxDestination formatname buffer
    //
    *pidxPendingRcvDestination = -1; // this is more current than pending destination from receive (if any)
    memset(pwszFormatNameBufferDestination->GetBuffer(), 0, sizeof(WCHAR));
    *pcchFormatNameBufferDestination = 0;
    IfFailRet(pGITDestination->Register(NULL, &IID_NULL));
    //
    // return
    //    
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::putref_ResponseQueueInfo_v1 (for IMSMQMessage)
//=--------------------------------------------------------------------------=
// Sets Response queue for message
//
// Parameters:
//    pqResponse - [in] message's Response queue
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::putref_ResponseQueueInfo_v1(
    IMSMQQueueInfo FAR* pqinfoResponse)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutrefQueueInfoOfMessage(pqinfoResponse,
                                               &m_idxPendingRcvRespQueue,
                                               &m_pwszRespQueue,
                                               &m_cchRespQueue,
                                               &m_pqinfoResponse,

                                               &m_idxPendingRcvRespQueueEx,
                                               &m_pwszRespQueueEx,
                                               &m_cchRespQueueEx,
                                               &m_pdestResponseEx,

                                               &m_fRespIsFromRcv);    
    return CreateErrorHelper(hresult, x_ObjectType);
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::putref_ResponseQueueInfo_v2 (for IMSMQMessage2)
//=--------------------------------------------------------------------------=
// Sets Response queue for message
//
// Parameters:
//    pqResponse - [in] message's Response queue
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::putref_ResponseQueueInfo_v2(
    IMSMQQueueInfo2 FAR* pqinfoResponse)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutrefQueueInfoOfMessage(pqinfoResponse,
                                               &m_idxPendingRcvRespQueue,
                                               &m_pwszRespQueue,
                                               &m_cchRespQueue,
                                               &m_pqinfoResponse,

                                               &m_idxPendingRcvRespQueueEx,
                                               &m_pwszRespQueueEx,
                                               &m_cchRespQueueEx,
                                               &m_pdestResponseEx,

                                               &m_fRespIsFromRcv);
    return CreateErrorHelper(hresult, x_ObjectType);
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::putref_ResponseQueueInfo (for IMSMQMessage3)
//=--------------------------------------------------------------------------=
// Sets Response queue for message
//
// Parameters:
//    pqResponse - [in] message's Response queue
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::putref_ResponseQueueInfo(
    IMSMQQueueInfo3 FAR* pqinfoResponse)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutrefQueueInfoOfMessage(pqinfoResponse,
                                               &m_idxPendingRcvRespQueue,
                                               &m_pwszRespQueue,
                                               &m_cchRespQueue,
                                               &m_pqinfoResponse,

                                               &m_idxPendingRcvRespQueueEx,
                                               &m_pwszRespQueueEx,
                                               &m_cchRespQueueEx,
                                               &m_pdestResponseEx,

                                               &m_fRespIsFromRcv);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_AppSpecific
//=--------------------------------------------------------------------------=
// Gets message's app specific info of message
//
// Parameters:
//    plAppSpecific - [out] message's app specific info
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_AppSpecific(long FAR* plAppSpecific)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plAppSpecific = m_lAppSpecific;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_AppSpecific
//=--------------------------------------------------------------------------=
// Sets app specific info for message
//
// Parameters:
//    lAppSpecific - [in] message's app specific info
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_AppSpecific(long lAppSpecific)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    m_lAppSpecific = lAppSpecific;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_SentTime
//=--------------------------------------------------------------------------=
// Gets message's sent time
//
// Parameters:
//    pvarSentTime - [out] time message was sent
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_SentTime(VARIANT FAR* pvarSentTime)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return GetVariantTimeOfTime(m_lSentTime, pvarSentTime);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_ArrivedTime
//=--------------------------------------------------------------------------=
// Gets message's arrival time
//
// Parameters:
//    pvarArrivedTime - [out] time message arrived
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_ArrivedTime(VARIANT FAR* pvarArrivedTime)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return GetVariantTimeOfTime(m_lArrivedTime, pvarArrivedTime);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::InternalAttachCurrentSecurityContext
//=--------------------------------------------------------------------------=
// Sets message's security context from current security context.
//
// Parameters:
//     fUseMQGetSecurityContextEx [in] - if true use MQGetSecurityContextEx otherwise use
//                                       MQGetSecurityContext.
//
// Output:
 //
// Notes:
//     fUseMQGetSecurityContextEx is true when called from AttachCurrentSecurityContext2, and
//     false when called from the obsolete AttachCurrentSecurityContext.
//
HRESULT CMSMQMessage::InternalAttachCurrentSecurityContext(BOOL fUseMQGetSecurityContextEx)
{
    //
    // pass binSenderCert property if set otherwise
    //  use default cert
    //
    BYTE * pSenderCert;
    if (m_cSenderCert.GetBufferUsedSize() > 0) {
      pSenderCert = m_cSenderCert.GetBuffer();
    }
    else {
      pSenderCert = NULL;
    }
    HANDLE hSecurityContext;
    HRESULT hresult;
    //
    // Get security context handle
    //
    if (fUseMQGetSecurityContextEx) {
      //
      // use MQGetSecurityContextEx
      //
      hresult = MQGetSecurityContextEx(
                         pSenderCert,
                         m_cSenderCert.GetBufferUsedSize(),
                         &hSecurityContext);
    }
    else {
      //
      // use MQGetSecurityContext
      //
      hresult = MQGetSecurityContext(
                         pSenderCert,
                         m_cSenderCert.GetBufferUsedSize(),
                         &hSecurityContext);
    } //fUseMQGetSecurityContextEx
    //
    // Update security context handle if succeeded
    //
    if (SUCCEEDED(hresult)) {
      if (m_hSecurityContext != NULL) {
        MQFreeSecurityContext(m_hSecurityContext);
      }
      m_hSecurityContext = hSecurityContext;
    }
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::AttachCurrentSecurityContext
//=--------------------------------------------------------------------------=
// Sets message's security context from current security context.
//
// Parameters:
//
// Output:
 //
// Notes:
//
HRESULT CMSMQMessage::AttachCurrentSecurityContext()
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = InternalAttachCurrentSecurityContext(FALSE /*fUseMQGetSecurityContextEx*/);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::AttachCurrentSecurityContext2
//=--------------------------------------------------------------------------=
// Sets message's security context from current security context.
//
// Parameters:
//
// Output:
 //
// Notes:
//    Replaces AttachCurrentSecurityContext
//    Uses MQGetSecurityContextEx instead of MQGetSecurityContext to allow impersonation
//
HRESULT CMSMQMessage::AttachCurrentSecurityContext2()
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = InternalAttachCurrentSecurityContext(TRUE /*fUseMQGetSecurityContextEx*/);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_MaxTimeToReachQueue
//=--------------------------------------------------------------------------=
// Gets message's lifetime
//
// Parameters:
//    plMaxTimeToReachQueue - [out] message's lifetime
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_MaxTimeToReachQueue(long FAR* plMaxTimeToReachQueue)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plMaxTimeToReachQueue = m_lMaxTimeToReachQueue;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_MaxTimeToReachQueue
//=--------------------------------------------------------------------------=
// Sets message's lifetime
//
// Parameters:
//    lMaxTimeToReachQueue - [in] message's lifetime
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_MaxTimeToReachQueue(long lMaxTimeToReachQueue)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    m_lMaxTimeToReachQueue = lMaxTimeToReachQueue;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_MaxTimeToReceive
//=--------------------------------------------------------------------------=
// Gets message's lifetime
//
// Parameters:
//    plMaxTimeToReceive - [out] message's lifetime
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_MaxTimeToReceive(long FAR* plMaxTimeToReceive)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plMaxTimeToReceive = m_lMaxTimeToReceive;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_MaxTimeToReceive
//=--------------------------------------------------------------------------=
// Sets message's lifetime
//
// Parameters:
//    lMaxTimeToReceive - [in] message's lifetime
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_MaxTimeToReceive(long lMaxTimeToReceive)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    m_lMaxTimeToReceive = lMaxTimeToReceive;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::GetVarBody
//=--------------------------------------------------------------------------=
// Gets message body
//
// Parameters:
//    pvarBody - [out] pointer to message body variant
//
// Output:
//
// Notes:
//    Supports intrinsic variant types
//
HRESULT CMSMQMessage::GetVarBody(VARIANT FAR* pvarBody)
{
    VARTYPE vt = m_vtBody;
    WCHAR *wszTmp = NULL;
    UINT cchBody;
    HRESULT hresult = NOERROR;

    //
    // UNDONE: VT_BYREF?
    //
    switch (vt) {
    case VT_I2:
    case VT_UI2:
      pvarBody->iVal = *(short *)m_pbBody;
      break;
    case VT_I4:
    case VT_UI4:
      pvarBody->lVal = *(long *)m_pbBody;
      break;
    case VT_R4:
      pvarBody->fltVal = *(float *)m_pbBody;
      break;
    case VT_R8:
      pvarBody->dblVal = *(double *)m_pbBody;
      break;
    case VT_CY:
      pvarBody->cyVal = *(CY *)m_pbBody;
      break;
    case VT_DATE:
      pvarBody->date = *(DATE *)m_pbBody;
      break;
    case VT_BOOL:
		pvarBody->boolVal = (*(VARIANT_BOOL *)m_pbBody) ? VARIANT_TRUE : VARIANT_FALSE;
      break;
    case VT_I1:
    case VT_UI1:
      pvarBody->bVal = *(UCHAR *)m_pbBody;
      break;
    case VT_LPSTR:
      //
      // coerce ansi to unicode
      //
      // alloc large enough unicode buffer
      IfNullFail(wszTmp = new WCHAR[m_cbBody * 2]);
      cchBody = MultiByteToWideChar(CP_ACP,
                                    0,
                                    (LPCSTR)m_pbBody,
                                    -1,
                                    wszTmp,
                                    m_cbBody * 2);
      if (cchBody != 0) {
        IfNullFail(pvarBody->bstrVal = SysAllocString(wszTmp));
      }
      else {
        IfFailGo(hresult = E_OUTOFMEMORY);
      }
      // map string to BSTR
      vt = VT_BSTR;
#ifdef _DEBUG
      RemBstrNode(pvarBody->bstrVal);
#endif // _DEBUG
      break;
    case VT_LPWSTR:
      // map wide string to BSTR
      vt = VT_BSTR;
      //
      // fall through...
      //
    case VT_BSTR:
      // Construct bstr to return
      //
      // if m_cbBody == 0 we need to return an empty string - so we cannot pass NULL to
      // SysAllocStringByteLen, this would return an uninitialized string instead.
      //
      if (m_cbBody > 0) {
        IfNullFail(pvarBody->bstrVal =
                     SysAllocStringByteLen(
                       (const char *)m_pbBody,
                       m_cbBody));
      }
      else { // m_cbBody == 0
        IfNullFail(pvarBody->bstrVal = SysAllocString(L""));
      }
#ifdef _DEBUG
      RemBstrNode(pvarBody->bstrVal);
#endif // _DEBUG
      break;
    default:
      IfFailGo(hresult = E_INVALIDARG);
      break;
    } // switch
    pvarBody->vt = vt;
    // fall through...

Error:
    delete [] wszTmp;
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::UpdateBodyBuffer
//=--------------------------------------------------------------------------=
// Sets message body
//
// Parameters:
//  cbBody    [in]    body length
//  pvBody    [in]    pointer to body buffer
//  vt        [in]    body type, can be VT_ARRAY|VT_UI1
//
// Output:
//
// Notes:
//    updates m_hMem, m_pbBody, m_cbBody, m_vtBody: might produce
//     empty message for VT_BSTR or VT_ARRAY|VT_UI1
//
HRESULT CMSMQMessage::UpdateBodyBuffer(ULONG cbBody, void *pvBody, VARTYPE vt)
{
    HRESULT hresult = NOERROR;

    GLOBALFREE(m_hMem);
    m_pbBody = NULL;
    m_cbBody = 0;
    m_vtBody = vt;
    if (cbBody > 0) {
      IfNullRet(m_hMem = GLOBALALLOC_MOVEABLE_NONDISCARD(cbBody));
      IfNullFail(m_pbBody = (BYTE *)GlobalLock(m_hMem));
      memcpy(m_pbBody, pvBody, cbBody);
      GLOBALUNLOCK(m_hMem);
      m_cbBody = cbBody;
    }
#ifdef _DEBUG
    else { //cbBody == 0
      //
      // zero sized body is allowed only on VT_BSTR or VT_ARRAY|VT_UI1
      //
      ASSERTMSG((vt == VT_BSTR) || (vt == (VT_ARRAY|VT_UI1)), "zero body not allowed")
    }
#endif //_DEBUG
    return hresult;

Error:
    GLOBALFREE(m_hMem);
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::GetStreamOfBody
//=--------------------------------------------------------------------------=
// Sets message body
//
// Parameters:
//  cbBody    [in]    body length
//  pvBody    [in]    pointer to body buffer
//  hMem      [in]    handle to body buffer
//  ppstm     [out]   points to stream inited with body
//
// Output:
//
// Notes:
//    Creates a new in-memory stream and inits it
//     with incoming buffer, resets the seek pointer
//     and returns the stream.
//
HRESULT CMSMQMessage::GetStreamOfBody(
    ULONG cbBody,
    void *pvBody,
    // HGLOBAL hMem,
    IStream **ppstm)
{
    LARGE_INTEGER li;
    IStream *pstm = NULL;
    HRESULT hresult;

    // pessimism
    *ppstm = NULL;
    HGLOBAL hMem = GlobalHandle(pvBody);
    ASSERTMSG(hMem, "bad handle.");

#ifdef _DEBUG
    DWORD_PTR cbSize;
    cbSize = GlobalSize(hMem);
#endif // _DEBUG
    IfFailRet(CreateStreamOnHGlobal(
                  hMem,  // NULL,   // hGlobal
                  FALSE, // TRUE,   // fDeleteOnRelease
                  &pstm));

#ifdef _DEBUG
    cbSize = GlobalSize(hMem);
#endif // _DEBUG

    // reset stream seek pointer
    LISet32(li, 0);
    IfFailGo(pstm->Seek(li, STREAM_SEEK_SET, NULL));

#ifdef _DEBUG
    STATSTG statstg;

    IfFailGo(pstm->Stat(&statstg, STATFLAG_NONAME));
    cbSize = GlobalSize(hMem);
    ASSERTMSG(cbSize >= cbBody, "hmem not big enough...");
#endif // _DEBUG

    // set stream size
    ULARGE_INTEGER ulibSize;
    ulibSize.QuadPart = cbBody;
    IfFailGo(pstm->SetSize(ulibSize));

#ifdef _DEBUG
    IfFailGo(pstm->Stat(&statstg, STATFLAG_NONAME));
    ASSERTMSG(statstg.cbSize.QuadPart == cbBody, "stream size not correct...");
    cbSize = GlobalSize(hMem);
    ASSERTMSG(cbSize >= cbBody, "hmem not big enough...");
#endif // _DEBUG

    *ppstm = pstm;
    return hresult;

Error:
    RELEASE(pstm);
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::GetStorageOfBody
//=--------------------------------------------------------------------------=
// Sets message body
//
// Parameters:
//  cbBody    [in]    body length
//  pvBody    [in]    pointer to body buffer
//  hMem      [in]    handle to body buffer
//  ppstg     [out]   pointer to storage inited with buffer
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::GetStorageOfBody(
    ULONG cbBody,
    void *pvBody,
    // HGLOBAL hMem,
    IStorage **ppstg)
{
    ULARGE_INTEGER ulibSize;
    ILockBytes *plockbytes = NULL;
    IStorage *pstg = NULL;
    HRESULT hresult;

    // pessimism
    *ppstg = NULL;

    HGLOBAL hMem = GlobalHandle(pvBody);
    ASSERTMSG(hMem, "bad handle.");

    // have to create and init ILockBytes before stg creation
    IfFailRet(CreateILockBytesOnHGlobal(
                hMem,  // NULL,  // hGlobal
                FALSE, // TRUE,  // fDeleteOnRelease
                &plockbytes));

    // set ILockBytes size
    ULISet32(ulibSize, cbBody);
    IfFailGo(plockbytes->SetSize(ulibSize));

#if 0
    // write bytes to ILockBytes
    ULONG cbWritten;
    ULARGE_INTEGER uliOffset;
    ULISet32(uliOffset, 0);
    IfFailGo(plockbytes->WriteAt(
                           uliOffset,
                           (void const *)pvBody,
                           cbBody,
                           &cbWritten));
    ASSERTMSG(cbBody == cbWritten, "not all bytes written.");
#endif // 0
    hresult = StgOpenStorageOnILockBytes(
               plockbytes,
               NULL,    // pstPriority
               STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
               NULL,    // SNB
               0,       //Reserved; must be zero
               &pstg);
    //
    // 1415: map FILEALREADYEXISTS to E_INVALIDARG
    // OLE returns former when bytearray exists (as it does
    //  since we just created one) but the contents aren't
    //  a storage -- e.g. when the message buffer isn't an
    //  object.
    //
    if (hresult == STG_E_FILEALREADYEXISTS) {
      IfFailGo(hresult = E_INVALIDARG);
    }

#ifdef _DEBUG
    STATSTG statstg, statstg2;
    IfFailGo(pstg->Stat(&statstg2, STATFLAG_NONAME));
    IfFailGo(plockbytes->Stat(&statstg, STATFLAG_NONAME));
#endif // _DEBUG
    *ppstg = pstg;
    RELEASE(plockbytes);
    return hresult;

Error:
    RELEASE(plockbytes);
    RELEASE(pstg);
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_lenBody
//=--------------------------------------------------------------------------=
// Gets message body len
//
// Parameters:
//    pcbBody - [out] pointer to message body len
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_BodyLength(long *pcbBody)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *pcbBody = m_cbBody;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Body
//=--------------------------------------------------------------------------=
// Gets message body
//
// Parameters:
//    pvarBody - [out] pointer to message body
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_Body(VARIANT FAR* pvarBody)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = NOERROR;

    //
    // inspect PROPID_M_BODY_TYPE to learn how
    //  to interpret message
    //
    if (m_vtBody & VT_ARRAY) {
      hresult = GetBinBody(pvarBody);
    }
    else if (m_vtBody == VT_STREAMED_OBJECT) {
      hresult = GetStreamedObject(pvarBody);
    }
    else if (m_vtBody == VT_STORED_OBJECT) {
      hresult = GetStoredObject(pvarBody);
    }
    else {
      hresult = GetVarBody(pvarBody);
    }
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::GetBinBody
//=--------------------------------------------------------------------------=
// Gets binary message body
//
// Parameters:
//    pvarBody - [out] pointer to binary message body
//
// Output:
//
// Notes:
//  produces a 1D array of BYTEs in a variant.
//
HRESULT CMSMQMessage::GetBinBody(VARIANT FAR* pvarBody)
{
    SAFEARRAY *psa;
    SAFEARRAYBOUND rgsabound[1];
    long rgIndices[1];
    HRESULT hresult = NOERROR, hresult2 = NOERROR;

    ASSERTMSG(pvarBody, "bad variant.");
    VariantClear(pvarBody);

    // create a 1D byte array
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = m_cbBody;
    IfNullRet(psa = SafeArrayCreate(VT_UI1, 1, rgsabound));

    // if (m_pbBody) {
    if (m_hMem) {
      ASSERTMSG(m_pbBody, "should have pointer to body.");
      ASSERTMSG(m_hMem == GlobalHandle(m_pbBody),
               "bad handle.");
      //
      // now copy array
      //
      // BYTE *pbBody;
      // IfNullFail(pbBody = (BYTE *)GlobalLock(m_hMem));
      for (ULONG i = 0; i < m_cbBody; i++) {
        rgIndices[0] = i;
        IfFailGo(SafeArrayPutElement(psa, rgIndices, (VOID *)&m_pbBody[i]));
        // IfFailGo(SafeArrayPutElement(psa, rgIndices, (VOID *)&pbBody[i]));
      }
    }

    // set variant to reference safearray of bytes
    V_VT(pvarBody) = VT_ARRAY | VT_UI1;
    pvarBody->parray = psa;
    //GLOBALUNLOCK(m_hMem); //BUGBUG may be redundant
    return hresult;

Error:
    hresult2 = SafeArrayDestroy(psa);
    if (FAILED(hresult2)) {
      return CreateErrorHelper(
               hresult2,
               x_ObjectType);
    }
    //GLOBALUNLOCK(m_hMem);
    return CreateErrorHelper(
             hresult,
             x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_Body
//=--------------------------------------------------------------------------=
// Sets message body
//
// Parameters:
//    varBody - [in] message body
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_Body(VARIANT varBody)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    VARTYPE vtBody = V_VT(&varBody);
    HRESULT hresult = NOERROR;

    //
    // We do not support VT_BYREF currently (used by VBSCript, SQL stored proc, etc), so better return an
    // error here...
    // Bug 507721 - YoelA, 2-Jan-2002
    //
    if (vtBody & VT_BYREF)
    {
        hresult = E_INVALIDARG;
    }
    else if ((vtBody & VT_ARRAY) ||
        (vtBody == VT_UNKNOWN) ||
        (vtBody == VT_DISPATCH))  {
      hresult = PutBinBody(varBody);
    }
    else {
      hresult = PutVarBody(varBody);
    }
    return CreateErrorHelper(
             hresult,
             x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::PutVarBody
//=--------------------------------------------------------------------------=
// Sets message body
//
// Parameters:
//    varBody [in]
//
// Output:
//
// Notes:
//    Supports intrinsic variant types
//
HRESULT CMSMQMessage::PutVarBody(VARIANT varBody)
{
    VARTYPE vt = V_VT(&varBody);
    void *pvBody = NULL;
    HRESULT hresult = NOERROR;

    // UNDONE: VT_BYREF?
    switch (vt) {
    case VT_I2:
    case VT_UI2:
      m_cbBody = 2;
      pvBody = &varBody.iVal;
      break;
    case VT_I4:
    case VT_UI4:
      m_cbBody = 4;
      pvBody = &varBody.lVal;
      break;
    case VT_R4:
      m_cbBody = 4;
      pvBody = &varBody.fltVal;
      break;
    case VT_R8:
      m_cbBody = 8;
      pvBody = &varBody.dblVal;
      break;
    case VT_CY:
      m_cbBody = sizeof(CY);
      pvBody = &varBody.cyVal;
      break;
    case VT_DATE:
      m_cbBody = sizeof(DATE);
      pvBody = &varBody.date;
      break;
    case VT_BOOL:
      m_cbBody = sizeof(VARIANT_BOOL);
      pvBody = &varBody.boolVal;
      break;
    case VT_I1:
    case VT_UI1:
      m_cbBody = 1;
      pvBody = &varBody.bVal;
      break;
    case VT_BSTR:
      BSTR bstrBody;

      IfFailGo(GetTrueBstr(&varBody, &bstrBody));
      m_cbBody = SysStringByteLen(bstrBody);
      pvBody = bstrBody;
      break;
    default:
      IfFailGo(hresult = E_INVALIDARG);
      break;
    } // switch
    hresult = UpdateBodyBuffer(m_cbBody, pvBody ? pvBody : L"", vt);
    // fall through...

Error:
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::PutBinBody
//=--------------------------------------------------------------------------=
// Sets message body
//
// Parameters:
//    psaBody - [in] binary message body
//
// Output:
//
// Notes:
//    Supports arrays of any type
//     and persistent ActiveX objects:
//     i.e. objects that support IPersistStream | IPersistStreamInit | IPersistStorage
//           and IDispatch.
//
HRESULT CMSMQMessage::PutBinBody(VARIANT varBody)
{
    SAFEARRAY *psa = NULL;
    UINT nDim, i, cbElem, cbBody;
    long lLBound, lUBound;
    VOID *pvData;
    VARTYPE vt = varBody.vt;
    IUnknown *pPersistIface = NULL;
    IUnknown *punkDisp = NULL;
    ULARGE_INTEGER ulibMax;
    MSGTYPE msgtype;
    IStorage *pstg = NULL;
    STATSTG statstg;
    HRESULT hresult = NOERROR;
    ILockBytes * pMyLockB = NULL;
    IStream * pMyStm = NULL;

    //
    // BUGBUG the settings clears the previous body even if the function fails later without
    // setting the body with a new value.
    //
    cbBody = 0;
    GLOBALFREE(m_hMem);
    m_pbBody = NULL;
    m_vtBody = VT_ARRAY | VT_UI1;
    m_cbBody = 0;

    switch (vt) {
    case VT_DISPATCH:
      if (varBody.pdispVal == NULL) {
        return E_INVALIDARG;
      }
      IfFailGo(varBody.pdispVal->QueryInterface(IID_IUnknown, (void **)&punkDisp));
      IfFailGo(GetPersistInfo(punkDisp, &msgtype, (void **)&pPersistIface));
      break;
    case VT_UNKNOWN:
      if (varBody.punkVal == NULL) {
        return E_INVALIDARG;
      }
      IfFailGo(GetPersistInfo(varBody.punkVal, &msgtype, (void **)&pPersistIface));
      break;
    default:
      msgtype = MSGTYPE_BINARY;
    } // switch

    switch (msgtype) {
    case MSGTYPE_STREAM:
    case MSGTYPE_STREAM_INIT:
      //
      // allocate lockbytes
      //
      IfFailGo(CMyLockBytes::CreateInstance(IID_ILockBytes, (void **)&pMyLockB));
      //
      // allocate stream on lockbytes
      //
      IfFailGo(CMyStream::CreateInstance(pMyLockB, IID_IStream, (void **)&pMyStm));

      //
      // save
      // pPersistIface is either IPersistStream or IPersistStreamInit
      // IPersistStreamInit is polymorphic to IPersistStream, so I can pass it to OleSaveToStream
      //
      IfFailGo(OleSaveToStream((IPersistStream *)pPersistIface, pMyStm));
      //
      // How big is our streamed data ?
      //
      IfFailGo(pMyLockB->Stat(&statstg, STATFLAG_NONAME));
      ulibMax = statstg.cbSize;
      if (ulibMax.HighPart != 0) {
        IfFailGo(hresult = E_INVALIDARG);
      }
      cbBody = ulibMax.LowPart;
      //
      // allocate new global handle of size of stream
      //
      IfNullFail(m_hMem = GLOBALALLOC_MOVEABLE_NONDISCARD(cbBody));
      //
      // set the hglobal memory with the streamed data
      //
      if (cbBody > 0) {
        BYTE * pbBody;
        //
        // GlobalLock should not return NULL since m_hMem is not
        // of size 0. If NULL is returned it is an error.
        //
        IfNullFail(pbBody = (BYTE *)GlobalLock(m_hMem));
        //
        // get the data from the lockbytes
        //
        ULARGE_INTEGER ullOffset;
        ullOffset.QuadPart = 0;
        ULONG cbRead;
        IfFailGo(pMyLockB->ReadAt(ullOffset, pbBody, cbBody, &cbRead));
        ASSERTMSG(cbRead == cbBody, "ReadAt(stream) failed");
        GlobalUnlock(m_hMem);
      }
      //
      // BUGBUG: There is no specific vt for StreamInit objects, but it is not critical
      // since it should be the same format, and anyway we always try, on both save and load,
      // to get IPersistStream first, then if that fails, we try to get IPersistStreamInit,
      // so the same interface that persisted it is loading it.
      //
      m_vtBody = VT_STREAMED_OBJECT;
      break;
    case MSGTYPE_BINARY:
      //
      // array: compute byte count
      //
      psa = varBody.parray;
      if (psa) {
        nDim = SafeArrayGetDim(psa);
        cbElem = SafeArrayGetElemsize(psa);
        for (i = 1; i <= nDim; i++) {
          IfFailGo(SafeArrayGetLBound(psa, i, &lLBound));
          IfFailGo(SafeArrayGetUBound(psa, i, &lUBound));
          cbBody += (lUBound - lLBound + 1) * cbElem;
        }
        IfFailGo(SafeArrayAccessData(psa, &pvData));
        IfFailGo(UpdateBodyBuffer(cbBody, pvData, VT_ARRAY | VT_UI1));
      }
      break;
    case MSGTYPE_STORAGE:
      //
      // allocate lockbytes
      //
      IfFailGo(CMyLockBytes::CreateInstance(IID_ILockBytes, (void **)&pMyLockB));
      //
      // Always create a new storage object.
      // REVIEW: Be nice if, as we do for streams, we could
      //  cache an in-memory storage and reuse --
      //  but I know of no way to reset a storage.
      //
      IfFailGo(StgCreateDocfileOnILockBytes(
                 pMyLockB,
                 STGM_CREATE |
                  STGM_READWRITE |
                  STGM_SHARE_EXCLUSIVE,
                 0,             //Reserved; must be zero
                 &pstg));
      //
      // pPersistIface is IPersistStorage
      //
      IfFailGo(OleSave((IPersistStorage *)pPersistIface, pstg, FALSE /* fSameAsLoad */));
      //
      // How big is our stored data ?
      //
      IfFailGo(pMyLockB->Stat(&statstg, STATFLAG_NONAME));
      ulibMax = statstg.cbSize;
      if (ulibMax.HighPart != 0) {
        IfFailGo(hresult = E_INVALIDARG);
      }
      cbBody = ulibMax.LowPart;
      //
      // allocate new global handle of size of storage
      //
      IfNullFail(m_hMem = GLOBALALLOC_MOVEABLE_NONDISCARD(cbBody));
      //
      // set the hglobal memory with the stored data
      //
      if (cbBody > 0) {
        BYTE * pbBody;
        //
        // GlobalLock should not return NULL since m_hMem is not
        // of size 0. If NULL is returned it is an error.
        //
        IfNullFail(pbBody = (BYTE *)GlobalLock(m_hMem));
        //
        // get the data from the lockbytes
        //
        ULARGE_INTEGER ullOffset;
        ullOffset.QuadPart = 0;
        ULONG cbRead;
        IfFailGo(pMyLockB->ReadAt(ullOffset, pbBody, cbBody, &cbRead));
        ASSERTMSG(cbRead == cbBody, "ReadAt(storage) failed");
        GlobalUnlock(m_hMem);
      }
      m_vtBody = VT_STORED_OBJECT;
      break;
    default:
      ASSERTMSG(0, "unreachable?");
      break;
    } // switch

    //
    // for MSGTYPE_BINARY we did the treatment below already in UpdateBodyBuffer if the array
    // contained something, otherwise (empty array) this treatment is not needed - body is 
    // initialized at the top to an empty array
    //
    if (msgtype != MSGTYPE_BINARY) {
      ASSERTMSG(((msgtype == MSGTYPE_STREAM) ||
              (msgtype == MSGTYPE_STREAM_INIT) ||
              (msgtype == MSGTYPE_STORAGE)), "invalid msgtype");
      m_cbBody = cbBody;
      m_pbBody = (BYTE *)GlobalLock(m_hMem);
      ASSERTMSG(m_pbBody, "should have valid pointer.");
      GLOBALUNLOCK(m_hMem);
    }

    // fall through...

Error:
    if (psa) {
      SafeArrayUnaccessData(psa);
    }
    RELEASE(punkDisp);
    RELEASE(pPersistIface);
    RELEASE(pstg);
    RELEASE(pMyLockB);
    RELEASE(pMyStm);
    return CreateErrorHelper(
               hresult,
               x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::GetStreamedObject
//=--------------------------------------------------------------------------=
// Produce streamed object from binary message body
//
// Parameters:
//    pvarBody - [out] pointer to object
//
// Output:
//
// Notes:
//  Object must implement IPersistStream | IPersistStreamInit
//
HRESULT CMSMQMessage::GetStreamedObject(VARIANT FAR* pvarBody)
{
    IUnknown *punk = NULL;
    IDispatch *pdisp = NULL;
    IStream *pstm = NULL;
    HRESULT hresult = NOERROR;

    ASSERTMSG(pvarBody, "bad variant.");
    VariantClear(pvarBody);

    // Attempt to load from an in-memory stream
    if (m_hMem) 
    {
      ASSERTMSG(m_hMem == GlobalHandle(m_pbBody), "bad handle.");
      IfFailGo(GetStreamOfBody(m_cbBody, m_pbBody, &pstm));

	  //
	  // The get stream may have reallocated the buffer (In the SetSize Command). 
	  // Set the buffer pointer accordingly
	  //
	  IfNullFail(m_pbBody = (BYTE *)GlobalLock(m_hMem));
	  GLOBALUNLOCK(m_hMem);


      // load
      IfFailGo(InternalOleLoadFromStream(pstm, IID_IUnknown, (void **)&punk));

      //
      // Supports IDispatch? if not, return IUnknown
      //
      hresult = punk->QueryInterface(IID_IDispatch,
                                     (LPVOID *)&pdisp);
      if (SUCCEEDED(hresult)) {
        //
        // Setup returned object
        //
        V_VT(pvarBody) = VT_DISPATCH;
        pvarBody->pdispVal = pdisp;
        ADDREF(pvarBody->pdispVal);   // ownership transfers
      }
      else {
        //
        // return IUnknown interface
        //
        V_VT(pvarBody) = VT_UNKNOWN;
        pvarBody->punkVal = punk;
        ADDREF(pvarBody->punkVal);   // ownership transfers
        hresult = NOERROR; //#3787
      }
    }
    else {
      V_VT(pvarBody) = VT_ERROR;
    }

    // fall through...

Error:
    RELEASE(punk);
    RELEASE(pstm);
    RELEASE(pdisp);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::GetStoredObject
//=--------------------------------------------------------------------------=
// Produce stored object from binary message body
//
// Parameters:
//    pvarBody - [out] pointer to object
//
// Output:
//
// Notes:
//  Object must implement IPersistStorage
//
HRESULT CMSMQMessage::GetStoredObject(VARIANT FAR* pvarBody)
{
    IUnknown *punk = NULL;
    IDispatch *pdisp = NULL;
    IStorage *pstg = NULL;
    IPersistStorage *ppersstg = NULL;
    HRESULT hresult = NOERROR;
#ifdef _DEBUG
    LPOLESTR pwszGuid;
#endif // _DEBUG
    ASSERTMSG(pvarBody, "bad variant.");
    VariantClear(pvarBody);

    // Attempt to load from an in-memory storage
    if (m_hMem) {
      ASSERTMSG(m_hMem == GlobalHandle(m_pbBody), "bad handle.");
      //
      // try to load as a storage
      //
      IfFailGo(GetStorageOfBody(m_cbBody, m_pbBody, &pstg));

	  //
	  // The get Storage may have reallocated the buffer (In the SetSize Command). 
	  // Set the buffer pointer accordingly
	  //
	  IfNullFail(m_pbBody = (BYTE *)GlobalLock(m_hMem));
	  GLOBALUNLOCK(m_hMem);
      
#if 0
      //
      // UNDONE: for some reason this doesn't work -- i.e. the returned
      //  object doesn't support IDispatch...
      //
      IfFailGo(OleLoad(pstg,
                       IID_IPersistStorage,
                       NULL,  //Points to the client site for the object
                       (void **)&ppersstg));
#else
      CLSID clsid;
      IfFailGo(ReadClassStg(pstg, &clsid))
      IfFailGo(CoCreateInstance(
                 clsid,
                 NULL,
                 CLSCTX_SERVER,
                 IID_IPersistStorage,
                 (LPVOID *)&ppersstg));
      IfFailGo(ppersstg->Load(pstg));
#endif // 0
#ifdef _DEBUG
      // get clsid
      STATSTG statstg;

      IfFailGo(pstg->Stat(&statstg, STATFLAG_NONAME));
      StringFromCLSID(statstg.clsid, &pwszGuid);
#endif // _DEBUG
#if 0
      //
      // Now setup returned object
      //
      V_VT(pvarBody) = VT_DISPATCH;
      pvarBody->pdispVal = pdisp;
      ADDREF(pvarBody->pdispVal);   // ownership transfers
#else
      //
      // Supports IDispatch? if not, return IUnknown
      //
      IfFailGo(ppersstg->QueryInterface(IID_IUnknown,
                                        (LPVOID *)&punk));
      hresult = punk->QueryInterface(IID_IDispatch,
                                     (LPVOID *)&pdisp);
      if (SUCCEEDED(hresult)) {
        //
        // Setup returned object
        //
        V_VT(pvarBody) = VT_DISPATCH;
        pvarBody->pdispVal = pdisp;
        ADDREF(pvarBody->pdispVal);   // ownership transfers
      }
      else {
        //
        // return IUnknown interface
        //
        V_VT(pvarBody) = VT_UNKNOWN;
        pvarBody->punkVal = punk;
        ADDREF(pvarBody->punkVal);   // ownership transfers
        hresult = NOERROR; //#3787
      }
#endif // 0
    }
    else {
      V_VT(pvarBody) = VT_ERROR;
    }

    // fall through...

Error:
    RELEASE(punk);
    RELEASE(pstg);
    RELEASE(ppersstg);
    RELEASE(pdisp);
    return CreateErrorHelper(hresult, x_ObjectType);
}



//=--------------------------------------------------------------------------=
// CMSMQMessage::get_SenderId
//=--------------------------------------------------------------------------=
// Gets binary sender id
//
// Parameters:
//    pvarSenderId - [out] pointer to binary sender id
//
// Output:
//
// Notes:
//  produces a 1D array of BYTEs in a variant.
//
HRESULT CMSMQMessage::get_SenderId(VARIANT FAR* pvarSenderId)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutSafeArrayOfBuffer(
						 m_cSenderId.GetBuffer(),
						 m_cSenderId.GetBufferUsedSize(),
						 pvarSenderId);
	return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_SenderId
//=--------------------------------------------------------------------------=
// Sets binary sender id
//
// Parameters:
//    varSenderId - [in] binary sender id
//
// Output:
//
// Notes:
//    Supports arrays of any type.
//
HRESULT CMSMQMessage::put_SenderId(VARIANT varSenderId)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult;
    BYTE *pbBuf;
    ULONG cbBuf;
    hresult = GetSafeArrayDataOfVariant(&varSenderId, &pbBuf, &cbBuf);
	if(FAILED(hresult))
    	return CreateErrorHelper(hresult, x_ObjectType);

    hresult = m_cSenderId.CopyBuffer(pbBuf, cbBuf);
	if(FAILED(hresult))
    	return CreateErrorHelper(hresult, x_ObjectType);

    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_SenderCertificate
//=--------------------------------------------------------------------------=
// Gets binary sender id
//
// Parameters:
//    pvarSenderCert - [out] pointer to binary sender certificate
//
// Output:
//
// Notes:
//  produces a 1D array of BYTEs in a variant.
//
HRESULT CMSMQMessage::get_SenderCertificate(VARIANT FAR* pvarSenderCert)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutSafeArrayOfBuffer(
						 m_cSenderCert.GetBuffer(),
						 m_cSenderCert.GetBufferUsedSize(),
						 pvarSenderCert);
	return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_SenderCertificate
//=--------------------------------------------------------------------------=
// Sets binary sender certificate
//
// Parameters:
//    psaSenderCert - [in] binary sender certificate
//
// Output:
//
// Notes:
//    Supports arrays of any type.
//
HRESULT CMSMQMessage::put_SenderCertificate(VARIANT varSenderCert)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult;
    BYTE *pbBuf;
    ULONG cbBuf;

    hresult = GetSafeArrayDataOfVariant(&varSenderCert, &pbBuf, &cbBuf);
	if(FAILED(hresult))
    	return CreateErrorHelper(hresult, x_ObjectType);

    hresult = m_cSenderCert.CopyBuffer(pbBuf, cbBuf);
	if(FAILED(hresult))
    	return CreateErrorHelper(hresult, x_ObjectType);

    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_AdminQueueInfo_v1 (for IMSMQMessage)
//=--------------------------------------------------------------------------=
// Gets admin queue for message
//
// Parameters:
//    ppqinfoAdmin - [out] message's admin queue
//
// Output:
//
// Notes:
//    caller must Release returned obj pointer.
//
HRESULT CMSMQMessage::get_AdminQueueInfo_v1(
    IMSMQQueueInfo FAR* FAR* ppqinfoAdmin)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = GetQueueInfoOfMessage(&m_idxPendingRcvAdminQueue,
                                            &m_msgprops_rcv,
                                            m_pwszAdminQueue.GetBuffer(),
                                            &m_pqinfoAdmin,
                                            &IID_IMSMQQueueInfo,
                                            (IUnknown **)ppqinfoAdmin);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_AdminQueueInfo_v2 (for IMSMQMessage2)
//=--------------------------------------------------------------------------=
// Gets admin queue for message
//
// Parameters:
//    ppqinfoAdmin - [out] message's admin queue
//
// Output:
//
// Notes:
//    caller must Release returned obj pointer.
//
HRESULT CMSMQMessage::get_AdminQueueInfo_v2(
    IMSMQQueueInfo2 FAR* FAR* ppqinfoAdmin)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = GetQueueInfoOfMessage(&m_idxPendingRcvAdminQueue,
                                            &m_msgprops_rcv,
                                            m_pwszAdminQueue.GetBuffer(),
                                            &m_pqinfoAdmin,
                                            &IID_IMSMQQueueInfo2,
                                            (IUnknown **)ppqinfoAdmin);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_AdminQueueInfo (for IMSMQMessage3)
//=--------------------------------------------------------------------------=
// Gets admin queue for message
//
// Parameters:
//    ppqinfoAdmin - [out] message's admin queue
//
// Output:
//
// Notes:
//    caller must Release returned obj pointer.
//
HRESULT CMSMQMessage::get_AdminQueueInfo(
    IMSMQQueueInfo3 FAR* FAR* ppqinfoAdmin)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = GetQueueInfoOfMessage(&m_idxPendingRcvAdminQueue,
                                            &m_msgprops_rcv,
                                            m_pwszAdminQueue.GetBuffer(),
                                            &m_pqinfoAdmin,
                                            &IID_IMSMQQueueInfo3,
                                            (IUnknown **)ppqinfoAdmin);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::putref_AdminQueueInfo_v1 (for IMSMQMessage)
//=--------------------------------------------------------------------------=
// Sets admin queue for message
//
// Parameters:
//    pqinfoAdmin - [in] message's admin queue
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::putref_AdminQueueInfo_v1(
    IMSMQQueueInfo FAR* pqinfoAdmin)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutrefQueueInfoOfMessage(pqinfoAdmin,
                                               &m_idxPendingRcvAdminQueue,
                                               &m_pwszAdminQueue,
                                               &m_cchAdminQueue,
                                               &m_pqinfoAdmin,

                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,

                                               NULL
											   );
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::putref_AdminQueueInfo_v2 (for IMSMQMessage2)
//=--------------------------------------------------------------------------=
// Sets admin queue for message
//
// Parameters:
//    pqinfoAdmin - [in] message's admin queue
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::putref_AdminQueueInfo_v2(
    IMSMQQueueInfo2 FAR* pqinfoAdmin)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutrefQueueInfoOfMessage(pqinfoAdmin,
                                               &m_idxPendingRcvAdminQueue,
                                               &m_pwszAdminQueue,
                                               &m_cchAdminQueue,
                                               &m_pqinfoAdmin,

                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,

                                               NULL
											   );
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::putref_AdminQueueInfo (for IMSMQMessage3)
//=--------------------------------------------------------------------------=
// Sets admin queue for message
//
// Parameters:
//    pqinfoAdmin - [in] message's admin queue
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::putref_AdminQueueInfo(
    IMSMQQueueInfo3 FAR* pqinfoAdmin)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutrefQueueInfoOfMessage(pqinfoAdmin,
                                               &m_idxPendingRcvAdminQueue,
                                               &m_pwszAdminQueue,
                                               &m_cchAdminQueue,
                                               &m_pqinfoAdmin,

                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,

                                               NULL
											   );
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_DestinationQueueInfo
//=--------------------------------------------------------------------------=
// Gets destination queue for message
//
// Parameters:
//    ppqinfoDest - [out] message's destination queue
//
// Output:
//
// Notes:
//    caller must Release returned obj pointer.
//
HRESULT CMSMQMessage::get_DestinationQueueInfo(
    IMSMQQueueInfo3 FAR* FAR* ppqinfoDest)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    //
    // We can also get here from old apps that want the old IMSMQQueueInfo/IMSMQQueueInfo2 back, but since
    // IMSMQQueueInfo3 is binary backwards compatible we can always return the new interface
    //
    HRESULT hresult = GetQueueInfoOfMessage(&m_idxPendingRcvDestQueue,
                                            &m_msgprops_rcv,
                                            m_pwszDestQueue.GetBuffer(),
                                            &m_pqinfoDest,
                                            &IID_IMSMQQueueInfo3,
                                            (IUnknown **)ppqinfoDest);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Id
//=--------------------------------------------------------------------------=
// Gets message id
//
// Parameters:
//    pvarId - [out] message's id
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_Id(VARIANT *pvarMsgId)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutSafeArrayOfBuffer(
						 m_rgbMsgId,
						 m_cbMsgId,
						 pvarMsgId);
	return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_CorrelationId
//=--------------------------------------------------------------------------=
// Gets message correlation id
//
// Parameters:
//    pvarCorrelationId - [out] message's correlation id
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_CorrelationId(VARIANT *pvarCorrelationId)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutSafeArrayOfBuffer(
						 m_rgbCorrelationId,
						 m_cbCorrelationId,
						 pvarCorrelationId);
	return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_CorrelationId
//=--------------------------------------------------------------------------=
// Sets message's correlation id
//
// Parameters:
//    varCorrelationId - [in] message's correlation id
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_CorrelationId(VARIANT varCorrelationId)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = NOERROR;
    BYTE * rgbCorrelationId = NULL;
    ULONG cbCorrelationId = 0;

    IfFailGo(GetSafeArrayOfVariant(
             &varCorrelationId,
             &rgbCorrelationId,
             &cbCorrelationId));
    //
    // correlation ID should be exactly 20 bytes
    //
    if ((rgbCorrelationId == NULL) || 
		(cbCorrelationId != PROPID_M_CORRELATIONID_SIZE))
	{
      IfFailGo(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    
	ASSERTMSG(sizeof(m_rgbCorrelationId) == PROPID_M_CORRELATIONID_SIZE, "m_rgbCorrelationId is of wrong size");
    memcpy(m_rgbCorrelationId, rgbCorrelationId, PROPID_M_CORRELATIONID_SIZE);
    m_cbCorrelationId = PROPID_M_CORRELATIONID_SIZE;
    //
    // Fall through
    //
Error:
    delete [] rgbCorrelationId;
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Ack
//=--------------------------------------------------------------------------=
// Gets message's acknowledgement
//
// Parameters:
//    pmsgack - [out] message's acknowledgement
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_Ack(long FAR* plAck)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plAck = m_lAck;
    return NOERROR;
}

#define MQMSG_ACK_MASK     (MQMSG_ACKNOWLEDGMENT_NONE | \
                            MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE | \
                            MQMSG_ACKNOWLEDGMENT_FULL_RECEIVE | \
                            MQMSG_ACKNOWLEDGMENT_NACK_REACH_QUEUE | \
                            MQMSG_ACKNOWLEDGMENT_NACK_RECEIVE)

//=--------------------------------------------------------------------------=
// CMSMQMessage::put_acknowledge
//=--------------------------------------------------------------------------=
// Sets message's acknowledgement
//
// Parameters:
//    msgack - [in] message's acknowledgement
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_Ack(long lAck)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    //
    // ensure that no bits are set in incoming lAck
    //  flags word other than our mask.
    //
    if (lAck & ~MQMSG_ACK_MASK) {
      return CreateErrorHelper(
               MQ_ERROR_ILLEGAL_PROPERTY_VALUE,
               x_ObjectType);
    }
    else {
      m_lAck = lAck;
      return NOERROR;
    }
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Label
//=--------------------------------------------------------------------------=
// Gets message label
//
// Parameters:
//    pbstrLabel - [out] pointer to message label
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_Label(BSTR FAR* pbstrLabel)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if (m_cchLabel) {
		*pbstrLabel = SysAllocStringLen(m_pwszLabel, m_cchLabel);
		if(*pbstrLabel == NULL)
			return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
    }
    else {
		*pbstrLabel = SysAllocString(L"");
		if(*pbstrLabel == NULL)
			return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
    }
#ifdef _DEBUG
    RemBstrNode(*pbstrLabel);
#endif // _DEBUG
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_Label
//=--------------------------------------------------------------------------=
// Sets message label
//
// Parameters:
//    bstrLabel - [in] message label
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_Label(BSTR bstrLabel)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    UINT cch = SysStringLen(bstrLabel);

    if (cch > MQ_MAX_MSG_LABEL_LEN - 1)
    {
      return CreateErrorHelper(MQ_ERROR_LABEL_TOO_LONG, x_ObjectType);
    }
    memcpy(m_pwszLabel, bstrLabel, SysStringByteLen(bstrLabel));
    m_cchLabel = cch;
    //
    // null terminate
    //
    memset(&m_pwszLabel[m_cchLabel], 0, sizeof(WCHAR));
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// HELPER - GetBstrFromGuidWithoutBraces
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pguid      [in]  guid pointer
//    pbstrGuid  [out] guid bstr
//
// Output:
//    HRESULT
//
// Notes:
//    Returns a guid string without the curly braces
//
HRESULT GetBstrFromGuidWithoutBraces(GUID * pguid, BSTR *pbstrGuid)
{
    int cbStr;
   WCHAR awcName[(LENSTRCLSID + 2) * 2];

    //
    // StringFromGUID2 returns GUID in the format '{xxxx-xxx ... }'
    // We want to return GUID without the curly braces, in the format 'xxxx-xxx ... '.
    //
    *pbstrGuid = SysAllocStringLen(NULL, LENSTRCLSID - 2);
    if (*pbstrGuid) {
      cbStr = StringFromGUID2(*pguid, awcName, LENSTRCLSID*2);
     wcsncpy( *pbstrGuid, &awcName[1], LENSTRCLSID - 2 );

      return cbStr == 0 ? E_OUTOFMEMORY : NOERROR;
    }
    else {
      return E_OUTOFMEMORY;
    }
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_SourceMachineGuid
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pbstrGuidSrcMachine  [out] message's source machine s guid
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQMessage::get_SourceMachineGuid(BSTR *pbstrGuidSrcMachine)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hr = GetBstrFromGuidWithoutBraces(&m_guidSrcMachine, pbstrGuidSrcMachine);
#ifdef _DEBUG
      RemBstrNode(*pbstrGuidSrcMachine);
#endif // _DEBUG
    return CreateErrorHelper(hr, x_ObjectType);
}


HRESULT CMSMQMessage::put_SoapHeader(BSTR bstrSoapHeader)
{
    CS lock(m_csObj);
    UINT length = SysStringLen(bstrSoapHeader); 
    LPWSTR pTemp  = new WCHAR[length+1];
    if(pTemp == NULL)
    {
        HRESULT hr = ResultFromScode(E_OUTOFMEMORY);
        return CreateErrorHelper(hr, x_ObjectType);
    }
    memcpy( pTemp, bstrSoapHeader, length*sizeof(WCHAR));
    pTemp[length] = L'\0';
    delete[] m_pSoapHeader;
    m_pSoapHeader = pTemp;
    return MQ_OK;
}


HRESULT CMSMQMessage::put_SoapBody(BSTR bstrSoapBody)
{
    CS lock(m_csObj);
    UINT length = SysStringLen(bstrSoapBody); 
    LPWSTR pTemp = new WCHAR[length+1];
    if(pTemp == NULL)
    {
        HRESULT hr = ResultFromScode(E_OUTOFMEMORY);
        return CreateErrorHelper(hr, x_ObjectType);
    }
    memcpy( pTemp, bstrSoapBody, length*sizeof(WCHAR));
    pTemp[length] = L'\0';
    delete[] m_pSoapBody;
    m_pSoapBody = pTemp;
    return MQ_OK;
}


    
//=--------------------------------------------------------------------------=
// static HELPER GetHandleOfDestination
//=--------------------------------------------------------------------------=
// Retrieves a queue handle from IDispatch that represents either
// an MSMQQueue object, an MSMQDestination object, or an IADs object
//
// Parameters:
//    pDest         - [in]  IDispatch*
//    phDest        - [out] MSMQ queue handle
//
// Output:
//
// Notes:
//
static HRESULT GetHandleOfDestination(IDispatch *pDest, QUEUEHANDLE *phDest, IUnknown **ppunkToRelease)
{
    R<IMSMQQueue> pQueue;
    R<IMSMQPrivateDestination> pPrivDest;
    R<IADs> pIADs;
    R<IUnknown> punkToRelease;
    QUEUEHANDLE hDest;
    //
    // pDest is an interface on MSMQQueue object, MSMQDestination object, or on IADs object
    // Check for an MSMQQueue object
    //
    HRESULT hresult = pDest->QueryInterface(IID_IMSMQQueue, (void**)&pQueue.ref());
    if (SUCCEEDED(hresult)) {
      //
      // an MSMQQueue object
      //
      long lHandle;
      //
      // no deadlock - we call q's get_Handle (therefore try
      // to lock q) but q never locks msgs (specifically not this one...)
      //
      hresult = pQueue->get_Handle(&lHandle); //MSMQ Queue handles are ALWAYS 32bit values (also on win64)
      if (FAILED(hresult)) {
        return hresult;
      }
      hDest = (QUEUEHANDLE) DWORD_TO_HANDLE(lHandle); //enlarge to HANDLE
    }
    else {
      //
      // Not an MSMQQueue object, check for an MSMQDestination object
      //
      hresult = pDest->QueryInterface(IID_IMSMQPrivateDestination, (void**)&pPrivDest.ref());
      if (SUCCEEDED(hresult)) {
        //
        // an MSMQDestination object, get handle
        //
        VARIANT varHandle;
        varHandle.vt = VT_EMPTY;
        //
        // no deadlock - we call dest's get_Handle (therefore try
        // to lock dest) but dest never locks msgs (specifically not this one...)
        //
        hresult = pPrivDest->get_Handle(&varHandle);
        if (FAILED(hresult)) {
          return hresult;
        }
        ASSERTMSG(varHandle.vt == VT_I8, "get_Handle failed");
        hDest = (QUEUEHANDLE) V_I8(&varHandle);
      }
      else {
        //
        // Not MSMQQueue/MSMQDestination object, check for an IADs object
        //
        hresult = pDest->QueryInterface(IID_IADs, (void**)&pIADs.ref());
        if (SUCCEEDED(hresult)) {
          //
          // an IADs object. create an MSMQ destination based on ADsPath
          //
          CComObject<CMSMQDestination> *pdestObj;
          hresult = CNewMsmqObj<CMSMQDestination>::NewObj(&pdestObj, &IID_IMSMQDestination, (IUnknown **)&punkToRelease.ref());
          if (FAILED(hresult)) {
            return hresult;
          }
          //
          // Init based on ADsPath.
          // No deadlock calling new destination obj since it doesn't have a lock on our object.
          //
          BSTR bstrADsPath;
          hresult = pIADs->get_ADsPath(&bstrADsPath);
          if (FAILED(hresult)) {
            return hresult;
          }
          hresult = pdestObj->put_ADsPath(bstrADsPath);
          SysFreeString(bstrADsPath);
          if (FAILED(hresult)) {
            return hresult;
          }
          //
          // get handle
          //
          VARIANT varHandle;
          varHandle.vt = VT_EMPTY;
          hresult = pdestObj->get_Handle(&varHandle);
          if (FAILED(hresult)) {
            return hresult;
          }
          ASSERTMSG(varHandle.vt == VT_I8, "get_Handle failed");
          hDest = (QUEUEHANDLE) V_I8(&varHandle);
        }
        else {
          //
          // Not MSMQQueue/MSMQDestination/IADs object, return no interface error
          // BUGBUG we may need to return a specific MSMQ error
          //
          return E_INVALIDARG;
        } // IADs
      } // MSMQDestination
    } //MSMQQueue
    //
    // return handle
    //    
    *phDest = hDest;
    *ppunkToRelease = punkToRelease.detach();
    return NOERROR;
}
    

//=--------------------------------------------------------------------------=
// CMSMQMessage::Send
//=--------------------------------------------------------------------------=
// Sends this message to a queue.
//
// Parameters:
//    pDest         - [in] destination, can be an MSMQQueue, an MSMQDestination or an IADs obj
//    varTransaction  [in, optional]
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::Send(
    IDispatch FAR* pDest,
    VARIANT *pvarTransaction)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);

    MQMSGPROPS msgprops;
    InitMessageProps(&msgprops);
    QUEUEHANDLE hHandleDest;
    ITransaction *ptransaction = NULL;
    BOOL isRealXact = FALSE;
    HRESULT hresult = NOERROR;
    IUnknown *punkToRelease = NULL;

    //
    // sanity check
    //
    if (pDest == NULL) {
      IfFailGo(E_INVALIDARG);
    }
    //
    // pDest can represent an MSMQQueue object, an MSMQDestination object or an IADs object
    // Get handle from target object - no need to free the handle - it is cached on
    // the target (MSMQQueue/MSMQDestination) object, but we might need to free the temp
    // MSMQDestination object that is created if an IADs object is passed
    //
    IfFailGo(GetHandleOfDestination(pDest, &hHandleDest, &punkToRelease));
    
    //
    // update msgprops with contents of data members
    //
    IfFailGo(CreateSendMessageProps(&msgprops));
    //
    // get optional transaction...
    //
    IfFailGo(GetOptionalTransaction(
               pvarTransaction,
               &ptransaction,
               &isRealXact));
    //
    // and finally send the message...
    //
    IfFailGo(MQSendMessage(hHandleDest,
                           (MQMSGPROPS *)&msgprops,
                           ptransaction));
    IfFailGo(UpdateMsgId(&msgprops));
    // fall through...

Error:
    if (punkToRelease) {
      punkToRelease->Release();
    }
    FreeMessageProps(&msgprops, TRUE/*fDeleteArrays*/);
    if (isRealXact) {
      RELEASE(ptransaction);
    }
    return CreateErrorHelper(hresult, x_ObjectType);
}


UINT 
CMSMQMessage::PreparePropIdArray(
    BOOL fCreate,
    PROPID* aPropId,
    MQPROPVARIANT* aPropVar
    )
{
    int aMustProps[] = {
        MSGPROP_DELIVERY,
        MSGPROP_PRIORITY,
        MSGPROP_JOURNAL,
        MSGPROP_ACKNOWLEDGE,
        MSGPROP_TRACE,
        MSGPROP_PRIV_LEVEL,
        MSGPROP_AUTH_LEVEL,
        MSGPROP_HASH_ALG,
        MSGPROP_ENCRYPTION_ALG,
        //
        // We add msgid to send props even though it is r/o so that we could get
        // back the msgid of the sent message
        //
        MSGPROP_MSGID,
        MSGPROP_APPSPECIFIC,
        MSGPROP_BODY_TYPE,
        MSGPROP_SENDERID_TYPE
    };

    const UINT xMustProps = sizeof(aMustProps)/sizeof(aMustProps[0]);

    UINT PropCounter = 0;
    for ( ; PropCounter < xMustProps; ++PropCounter) 
    {
        if(fCreate)
        {
            AddPropRec(aMustProps[PropCounter], aPropId, aPropVar, PropCounter);
        }
    }

    //
    // Optional proporties:
    //
    if (m_hMem)
    {
        if(fCreate)
        {
            AddPropRecOptional(OPTPROP_BODY, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }

    //
    // we can't send both PROPID_M_RESP_FORMAT_NAME and PROPID_M_RESP_QUEUE.
    //
    if (m_cchRespQueueEx)
    {
        ASSERT((m_cchRespQueue == 0) || ((m_cchRespQueue != 0) && m_fRespIsFromRcv));             
        ASSERT(!g_fDependentClient);
        if(fCreate)
        {
            AddPropRecOptional(OPTPROP_RESP_FORMAT_NAME, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }
    else if (m_cchRespQueue) 
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_RESP_QUEUE, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }

    if (m_cchAdminQueue)
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_ADMIN_QUEUE, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }

    if (m_cbCorrelationId)
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_CORRELATIONID, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }

    if (m_cchLabel)
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_LABEL, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }

    if (m_cSenderCert.GetBufferUsedSize() > 0) 
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_SENDER_CERT, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }
    
    if (m_lMaxTimeToReachQueue != -1)
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_TIME_TO_REACH_QUEUE, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }
    
    if (m_lMaxTimeToReceive != -1)
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_TIME_TO_BE_RECEIVED, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }
    
    if (m_hSecurityContext != NULL) 
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_SECURITY_CONTEXT, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }
    
    if (m_cExtension.GetBufferUsedSize() > 0) 
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_EXTENSION, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }

    if(m_pSoapHeader !=  NULL)
    {
        if(fCreate)
        {
            AddPropRecOptional(OPTPROP_SOAP_HEADER, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }

    if(m_pSoapBody !=  NULL)
    {
        if(fCreate)
        {
            AddPropRecOptional(OPTPROP_SOAP_BODY, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }



    //
    // the properties below are sent only if the user asked to send connector related
    // properties (m_guidConnectorType is not NULL).
    //

    if (m_guidConnectorType == GUID_NULL)
        return PropCounter ;

    if(fCreate)
    {
        AddPropRecOptional(OPTPROP_CONNECTOR_TYPE, aPropId, aPropVar, PropCounter);
    }
    ++PropCounter;

    if (m_cDestSymmKey.GetBufferUsedSize() > 0) 
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_DEST_SYMM_KEY, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }
    
    if (m_cSignature.GetBufferUsedSize() > 0) 
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_SIGNATURE, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }
    
    if (m_lAuthProvType != 0) 
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_PROV_TYPE, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }
    
    if (m_cAuthProvName.GetBufferUsedSize() > 1) 
    { 
        //
        //e.g. not an empty string with one null character
        //
        if(fCreate)
        {
            AddPropRec(MSGPROP_PROV_NAME, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }
    
    if (m_cSenderId.GetBufferUsedSize() > 0) 
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_SENDERID, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }
    
    if (m_lClass != -1)
    {
        if(fCreate)
        {
            AddPropRec(MSGPROP_CLASS, aPropId, aPropVar, PropCounter);
        }
        ++PropCounter;
    }


    return PropCounter;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::CreateReceiveMessageProps
//=--------------------------------------------------------------------------=
// Creates and updates an MQMSGPROPS struct before receiving
//  a message.
//  NOTE: only used in SYNCHRONOUS receive case.
//   Use CreateAsyncReceiveMessage props otherwise.
//
// Parameters:
//    rgproprec    [in]  array of propids
//    cPropRec     [in]  array size
//    pmsgprops    [out]
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//   Used only *before* Receive
//
HRESULT CMSMQMessage::CreateReceiveMessageProps(
    BOOL wantDestQueue,
    BOOL wantBody,
    BOOL wantConnectorType)
{
    MSGPROPID propid;
    UINT i;
    UINT cPropRec = 0;
    HRESULT hresult = NOERROR;
    MQMSGPROPS * pmsgprops = &m_msgprops_rcv;

    IfFailGo(AllocateReceiveMessageProps(
               wantDestQueue,
               wantBody,
               wantConnectorType,
               pmsgprops,
               g_rgmsgpropid,
               g_rgmsgpropvt,
               g_cPropRec,
               &cPropRec));
    //
    // Note: we reuse buffers for each dynalloced property.
    //
    for (i = 0; i < cPropRec; i++) {
      propid = pmsgprops->aPropID[i];
      switch (propid) {
      case PROPID_M_MSGID:
        pmsgprops->aPropVar[i].caub.pElems = m_rgbMsgId;
        pmsgprops->aPropVar[i].caub.cElems = sizeof(m_rgbMsgId);
        break;
      case PROPID_M_CORRELATIONID:
        pmsgprops->aPropVar[i].caub.pElems = m_rgbCorrelationId;
        pmsgprops->aPropVar[i].caub.cElems = sizeof(m_rgbCorrelationId);
        break;
      case PROPID_M_BODY:
        HGLOBAL hMem;
        pmsgprops->aPropVar[i].caub.pElems = NULL; //redundant - done in AllocateReceiveMessageProps
        //
        // REVIEW: unfortunately can't optimize by reusing current buffer
        //  if same size as the default buffer since this message object
        //  is always new since we're creating one prior to receiving a new
        //  message.
        //
        IfNullRet(hMem = AllocateReceiveBodyBuffer(
                           pmsgprops,
                           i,
                           BODY_INIT_SIZE));
        break;
      case PROPID_M_LABEL:
        pmsgprops->aPropVar[i].pwszVal = m_pwszLabel;
        break;
      case PROPID_M_LABEL_LEN:
        pmsgprops->aPropVar[i].lVal = MQ_MAX_MSG_LABEL_LEN + 1;
        break;
      case PROPID_M_SENDERID:
        pmsgprops->aPropVar[i].caub.pElems = m_cSenderId.GetBuffer();
        pmsgprops->aPropVar[i].caub.cElems = m_cSenderId.GetBufferMaxSize();
        break;
      case PROPID_M_SENDER_CERT:
        pmsgprops->aPropVar[i].caub.pElems = m_cSenderCert.GetBuffer();
        pmsgprops->aPropVar[i].caub.cElems = m_cSenderCert.GetBufferMaxSize();
        break;
      case PROPID_M_SRC_MACHINE_ID:
        //
        // per-instance buffer
        //
        pmsgprops->aPropVar[i].puuid = &m_guidSrcMachine;
        break;
      case PROPID_M_RESP_QUEUE_LEN:
        pmsgprops->aPropVar[i].lVal = m_pwszRespQueue.GetBufferMaxSize();
        break;
      case PROPID_M_ADMIN_QUEUE_LEN:
        pmsgprops->aPropVar[i].lVal = m_pwszAdminQueue.GetBufferMaxSize();
        break;
      case PROPID_M_DEST_QUEUE_LEN:
        pmsgprops->aPropVar[i].lVal = m_pwszDestQueue.GetBufferMaxSize();
        break;
      case PROPID_M_XACT_STATUS_QUEUE_LEN:
        pmsgprops->aPropVar[i].lVal = m_pwszXactStatusQueue.GetBufferMaxSize();
        break;
      case PROPID_M_RESP_FORMAT_NAME_LEN:
        pmsgprops->aPropVar[i].lVal = m_pwszRespQueueEx.GetBufferMaxSize();
        break;
      case PROPID_M_DEST_FORMAT_NAME_LEN:
        pmsgprops->aPropVar[i].lVal = m_pwszDestQueueEx.GetBufferMaxSize();
        break;
      case PROPID_M_RESP_QUEUE:
        pmsgprops->aPropVar[i].pwszVal = m_pwszRespQueue.GetBuffer();
        break;
      case PROPID_M_ADMIN_QUEUE:
        pmsgprops->aPropVar[i].pwszVal = m_pwszAdminQueue.GetBuffer();
        break;
      case PROPID_M_DEST_QUEUE:
        pmsgprops->aPropVar[i].pwszVal = m_pwszDestQueue.GetBuffer();
        break;
      case PROPID_M_XACT_STATUS_QUEUE:
        pmsgprops->aPropVar[i].pwszVal = m_pwszXactStatusQueue.GetBuffer();
        break;
      case PROPID_M_RESP_FORMAT_NAME:
        pmsgprops->aPropVar[i].pwszVal = m_pwszRespQueueEx.GetBuffer();
        break;
      case PROPID_M_DEST_FORMAT_NAME:
        pmsgprops->aPropVar[i].pwszVal = m_pwszDestQueueEx.GetBuffer();
        break;

      case PROPID_M_EXTENSION:
        pmsgprops->aPropVar[i].caub.pElems = m_cExtension.GetBuffer();
        pmsgprops->aPropVar[i].caub.cElems = m_cExtension.GetBufferMaxSize();
        break;
      case PROPID_M_DEST_SYMM_KEY:
        pmsgprops->aPropVar[i].caub.pElems = m_cDestSymmKey.GetBuffer();
        pmsgprops->aPropVar[i].caub.cElems = m_cDestSymmKey.GetBufferMaxSize();
        break;
      case PROPID_M_SIGNATURE:
        pmsgprops->aPropVar[i].caub.pElems = m_cSignature.GetBuffer();
        pmsgprops->aPropVar[i].caub.cElems = m_cSignature.GetBufferMaxSize();
        break;
      case PROPID_M_PROV_NAME:
        pmsgprops->aPropVar[i].pwszVal = m_cAuthProvName.GetBuffer();
        break;
      case PROPID_M_PROV_NAME_LEN:
        pmsgprops->aPropVar[i].lVal = m_cAuthProvName.GetBufferMaxSize();
        break;
      case PROPID_M_CONNECTOR_TYPE:
        pmsgprops->aPropVar[i].puuid = &m_guidConnectorType;
        break;

      case PROPID_M_XACTID:
        pmsgprops->aPropVar[i].caub.pElems = m_rgbXactId;
        pmsgprops->aPropVar[i].caub.cElems = sizeof(m_rgbXactId);
        break;

      case PROPID_M_SOAP_ENVELOPE:
        pmsgprops->aPropVar[i].pwszVal = m_cSoapEnvelope.GetBuffer();
        break;

      case PROPID_M_SOAP_ENVELOPE_LEN:
        pmsgprops->aPropVar[i].lVal = m_cSoapEnvelope.GetBufferMaxSize();
        break;

      case PROPID_M_COMPOUND_MESSAGE:
        pmsgprops->aPropVar[i].caub.pElems = m_cCompoundMessage.GetBuffer();
        pmsgprops->aPropVar[i].caub.cElems = m_cCompoundMessage.GetBufferMaxSize();
        break;
      } // switch
    } // for

Error:
    if (FAILED(hresult)) {
      FreeMessageProps(pmsgprops, FALSE/*fDeleteArrays*/);
      pmsgprops->cProp = 0;
    }
    return hresult;
}


//=--------------------------------------------------------------------------=
// HELPER: SetBinaryMessageProp
//=--------------------------------------------------------------------------=
// Sets data members from binary message props after a receive or send.
//
// Parameters:
//    pmsgprops - [in] pointer to message properties struct
//
// Output:
//
static HRESULT SetBinaryMessageProp(
    MQMSGPROPS *pmsgprops,
    UINT iProp,
    // ULONG *pcbBuffer,
    ULONG cbBuffer,
    BYTE **prgbBuffer)
{
    BYTE *rgbBuffer = *prgbBuffer;
    // ULONG cbBuffer;

    delete [] rgbBuffer;
    // cbBuffer = pmsgprops->aPropVar[iProp].caub.cElems;
    IfNullRet(rgbBuffer = new BYTE[cbBuffer]);
    memcpy(rgbBuffer,
           pmsgprops->aPropVar[iProp].caub.pElems,
           cbBuffer);
    *prgbBuffer= rgbBuffer;
    // *pcbBuffer = cbBuffer;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::UpdateMsgId
//=--------------------------------------------------------------------------=
// Sets message id after send
//
// Parameters:
//    pmsgprops - [in] pointer to message properties struct
//
// Output:
//
HRESULT 
CMSMQMessage::UpdateMsgId(
    MQMSGPROPS *pmsgprops
    )
{
    UINT i;
    UINT cProp = pmsgprops->cProp;
    MSGPROPID msgpropid;

    for (i = 0; i < cProp; i++) 
    {
        msgpropid = pmsgprops->aPropID[i];
        //
        // skip ignored props
        //
        if (pmsgprops->aStatus[i] == MQ_INFORMATION_PROPERTY_IGNORED) 
        {
            continue;
        }
        if (msgpropid == PROPID_M_MSGID)
        {
            m_cbMsgId = pmsgprops->aPropVar[i].caub.cElems;
            ASSERTMSG(
                m_rgbMsgId == pmsgprops->aPropVar[i].caub.pElems,
                "should reuse same buffer."
                );
            return NOERROR;
        }
    } // for
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::SetReceivedMessageProps
//=--------------------------------------------------------------------------=
// Sets data members from message props after a receive.
//
// Parameters:
//    pmsgprops - [in] pointer to message properties struct
//
// Output:
//
HRESULT CMSMQMessage::SetReceivedMessageProps()
{
    MQMSGPROPS *pmsgprops = &m_msgprops_rcv;
    UINT i, cch;
    UINT cProp = pmsgprops->cProp;
    MSGPROPID msgpropid;
    UCHAR *pucElemsBody = NULL;  // used to save pointer to body until we know its size
#ifdef _DEBUG
    BOOL fProcessedPrivLevel = FALSE;
    BOOL fProcessedAuthenticated = FALSE;
#endif //_DEBUG
    HRESULT hresult = NOERROR;

    for (i = 0; i < cProp; i++) {
      msgpropid = pmsgprops->aPropID[i];
      //
      // skip ignored props
      //
      if (pmsgprops->aStatus[i] == MQ_INFORMATION_PROPERTY_IGNORED) {
        continue;
      }
      switch (msgpropid) {
      case PROPID_M_CLASS:
        m_lClass = (MQMSGCLASS)pmsgprops->aPropVar[i].uiVal;
        break;
      case PROPID_M_MSGID:
        // already allocated buffer in ctor
        // m_rgbMsgId = pmsgprops->aPropVar[i].caub.pElems;
        ASSERTMSG(m_rgbMsgId == pmsgprops->aPropVar[i].caub.pElems,
              "should reuse same buffer.");
        m_cbMsgId = pmsgprops->aPropVar[i].caub.cElems;
        break;
      case PROPID_M_CORRELATIONID:
        // already allocated buffer in ctor
        // m_rgbCorrelationId = pmsgprops->aPropVar[i].caub.pElems;
        ASSERTMSG(m_rgbCorrelationId == pmsgprops->aPropVar[i].caub.pElems,
              "should reuse same buffer.");
        m_cbCorrelationId = pmsgprops->aPropVar[i].caub.cElems;
        break;
      case PROPID_M_PRIORITY:
        m_lPriority = (long)pmsgprops->aPropVar[i].bVal;
        break;
      case PROPID_M_DELIVERY:
        m_lDelivery = (MQMSGDELIVERY)pmsgprops->aPropVar[i].bVal;
        break;
      case PROPID_M_ACKNOWLEDGE:
        m_lAck = (MQMSGACKNOWLEDGEMENT)pmsgprops->aPropVar[i].bVal;
        break;
      case PROPID_M_JOURNAL:
        m_lJournal = (long)pmsgprops->aPropVar[i].bVal;
        break;
      case PROPID_M_APPSPECIFIC:
        m_lAppSpecific = (long)pmsgprops->aPropVar[i].lVal;
        break;
      case PROPID_M_BODY:
        //
        // We can't allocate the body yet because we might
        //  not know its size -- cElems is *not* the actual size
        //  rather it's obtained via the BODY_SIZE property which
        //  is processed separately, so we simply save away a
        //  pointer to the returned buffer.
        //
        pucElemsBody = pmsgprops->aPropVar[i].caub.pElems;
        ASSERTMSG(m_hMem == NULL, "m_hMem not empty in newly allocated msg");
        m_hMem = GlobalHandle(pucElemsBody);
        ASSERTMSG(m_hMem, "bad handle.");
        m_pbBody = (BYTE *)pucElemsBody;
        //
        // nullify body in receive props so we don't free it on destruction since
        // free resposibility was transfered  to m_hMem
        //
        pmsgprops->aPropVar[i].caub.pElems = NULL;
        pmsgprops->aPropVar[i].caub.cElems = 0;
        break;
      case PROPID_M_BODY_SIZE:
        m_cbBody = (UINT)pmsgprops->aPropVar[i].lVal;
        break;
      case PROPID_M_BODY_TYPE:
        //
        // 1645: if the sending app hasn't bothered
        //  to set this property (i.e. it's still 0)
        //  let's default it to a binary bytearray.
        //
        m_vtBody = (USHORT)pmsgprops->aPropVar[i].lVal;
        if (m_vtBody == 0) {
          m_vtBody = VT_ARRAY | VT_UI1;
        }
        break;
      case PROPID_M_LABEL_LEN:
        cch = pmsgprops->aPropVar[i].lVal;
        //
        // remove trailing null if necessary
        //
        m_cchLabel = cch ? cch - 1 : 0;
        break;
      case PROPID_M_TIME_TO_BE_RECEIVED:
        m_lMaxTimeToReceive = pmsgprops->aPropVar[i].lVal;
        break;
      case PROPID_M_TIME_TO_REACH_QUEUE:
        m_lMaxTimeToReachQueue = pmsgprops->aPropVar[i].lVal;
        break;
      case PROPID_M_TRACE:
        m_lTrace = (long)pmsgprops->aPropVar[i].bVal;
        break;
      case PROPID_M_SENDERID_LEN:
        m_cSenderId.SetBufferUsedSize(pmsgprops->aPropVar[i].lVal);
        break;
      case PROPID_M_SENDERID_TYPE:
        m_lSenderIdType = pmsgprops->aPropVar[i].lVal;
        break;
      case PROPID_M_SENDER_CERT_LEN:
        m_cSenderCert.SetBufferUsedSize(pmsgprops->aPropVar[i].lVal);
        break;
      case PROPID_M_PRIV_LEVEL:
        m_lPrivLevel = pmsgprops->aPropVar[i].lVal;
#ifdef _DEBUG
        fProcessedPrivLevel = TRUE;
#endif //_DEBUG
        break;
      case PROPID_M_AUTHENTICATED_EX:
        m_usAuthenticatedEx = pmsgprops->aPropVar[i].bVal;
#ifdef _DEBUG
        fProcessedAuthenticated = TRUE;
#endif //_DEBUG
        break;
      case PROPID_M_HASH_ALG:
        //
        // hashalg only valid after receive if message was
        //  authenticated
        //
        ASSERTMSG(fProcessedAuthenticated,
               "should have processed authenticated.");
        if (m_usAuthenticatedEx != MQMSG_AUTHENTICATION_NOT_REQUESTED) {
          m_lHashAlg = pmsgprops->aPropVar[i].lVal;
        }
        break;
      case PROPID_M_ENCRYPTION_ALG:
        //
        // encryptionalg only valid after receive is privlevel
        //  is body
        //
        ASSERTMSG(fProcessedPrivLevel,
               "should have processed privlevel.");
        if ((m_lPrivLevel == MQMSG_PRIV_LEVEL_BODY_BASE) ||
            (m_lPrivLevel == MQMSG_PRIV_LEVEL_BODY_ENHANCED)) {
          m_lEncryptAlg = pmsgprops->aPropVar[i].lVal;
        }
        break;
      case PROPID_M_SENTTIME:
        m_lSentTime = pmsgprops->aPropVar[i].lVal;
        break;
      case PROPID_M_ARRIVEDTIME:
        m_lArrivedTime = pmsgprops->aPropVar[i].lVal;
        break;
      case PROPID_M_DEST_QUEUE_LEN:
        cch = pmsgprops->aPropVar[i].lVal;
        //
        // remove trailing null if necessary
        //
        m_cchDestQueue = cch ? cch - 1 : 0;
        //
        // pending dest queue in receive props. qinfo will be created on demand
        //
        m_idxPendingRcvDestQueue = i;
        break;
      case PROPID_M_RESP_QUEUE_LEN:
        cch = pmsgprops->aPropVar[i].lVal;
        //
        // remove trailing null if necessary
        //
        m_cchRespQueue = cch ? cch - 1 : 0;
        //
        // pending resp queue in receive props. qinfo will be created on demand
        //
        m_idxPendingRcvRespQueue = i;
        break;
      case PROPID_M_ADMIN_QUEUE_LEN:
        cch = pmsgprops->aPropVar[i].lVal;
        //
        // remove trailing null if necessary
        //
        m_cchAdminQueue = cch ? cch - 1 : 0;
        //
        // pending admin queue in receive props. qinfo will be created on demand
        //
        m_idxPendingRcvAdminQueue = i;
        break;
      case PROPID_M_XACT_STATUS_QUEUE_LEN:
        cch = pmsgprops->aPropVar[i].lVal;
        //
        // remove trailing null if necessary
        //
        m_cchXactStatusQueue = cch ? cch - 1 : 0;
        //
        // pending xact status queue in receive props. qinfo will be created on demand
        //
        m_idxPendingRcvXactStatusQueue = i;
        break;
      case PROPID_M_DEST_FORMAT_NAME_LEN:
        cch = pmsgprops->aPropVar[i].lVal;
        //
        // remove trailing null if necessary
        //
        m_cchDestQueueEx = cch ? cch - 1 : 0;
        //
        // pending destination in receive props. destination will be created on demand
        //
        m_idxPendingRcvDestQueueEx = i;
        break;
      case PROPID_M_RESP_FORMAT_NAME_LEN:
        cch = pmsgprops->aPropVar[i].lVal;
        //
        // remove trailing null if necessary
        //
        m_cchRespQueueEx = cch ? cch - 1 : 0;
        //
        // pending resp destination in receive props. destination will be created on demand
        //
        m_idxPendingRcvRespQueueEx = i;
        break;
      case PROPID_M_VERSION:
        m_lSenderVersion = pmsgprops->aPropVar[i].lVal;
        break;
      case PROPID_M_EXTENSION_LEN:
        m_cExtension.SetBufferUsedSize(pmsgprops->aPropVar[i].lVal);
        break;
      case PROPID_M_DEST_SYMM_KEY_LEN:
        m_cDestSymmKey.SetBufferUsedSize(pmsgprops->aPropVar[i].lVal);
        break;
      case PROPID_M_SIGNATURE_LEN:
        m_cSignature.SetBufferUsedSize(pmsgprops->aPropVar[i].lVal);
        break;
      case PROPID_M_PROV_TYPE:
        //
        // authentication provider type only valid after receive if message was
        //  authenticated
        //
        ASSERTMSG(fProcessedAuthenticated,
               "should have processed authenticated.");
        if (m_usAuthenticatedEx != MQMSG_AUTHENTICATION_NOT_REQUESTED) {
          m_lAuthProvType = pmsgprops->aPropVar[i].lVal;
        }
        else {
          m_lAuthProvType = 0;
        }
        break;
      case PROPID_M_PROV_NAME_LEN:
        //
        // authentication provider name only valid after receive if message was
        //  authenticated
        //
        ASSERTMSG(fProcessedAuthenticated,
               "should have processed authenticated.");
        if (m_usAuthenticatedEx != MQMSG_AUTHENTICATION_NOT_REQUESTED) {
          cch = pmsgprops->aPropVar[i].lVal;
        }
        else {
          cch = 0;
        }
        m_cAuthProvName.SetBufferUsedSize(cch);
        break;
      case PROPID_M_XACTID:
        // already allocated buffer in ctor
        // m_rgbXactId = pmsgprops->aPropVar[i].caub.pElems;
        ASSERTMSG(m_rgbXactId == pmsgprops->aPropVar[i].caub.pElems,
              "should reuse same buffer.");
        m_cbXactId = pmsgprops->aPropVar[i].caub.cElems;
        break;
      case PROPID_M_FIRST_IN_XACT:
        m_fFirstInXact = (BOOL)pmsgprops->aPropVar[i].bVal;
        break;
      case PROPID_M_LAST_IN_XACT:
        m_fLastInXact = (BOOL)pmsgprops->aPropVar[i].bVal;
        break;

      case PROPID_M_LOOKUPID:
        ASSERTMSG(pmsgprops->aPropVar[i].vt == VT_UI8, "lookupid type not VT_UI8");
        m_ullLookupId = pmsgprops->aPropVar[i].uhVal.QuadPart;
        m_wszLookupId[0] = '\0'; // String representation not initialized yet
        break;

      case PROPID_M_SOAP_ENVELOPE_LEN:
        m_cSoapEnvelope.SetBufferUsedSize(pmsgprops->aPropVar[i].lVal);
        break;

      case PROPID_M_COMPOUND_MESSAGE_SIZE:
        m_cCompoundMessage.SetBufferUsedSize(pmsgprops->aPropVar[i].lVal);
        break;

#ifdef _DEBUG
      //
      // invalid props in receive, should return MQ_INFORMATION_PROPERTY_IGNORED
      //
      case PROPID_M_AUTH_LEVEL:
      case PROPID_M_SECURITY_CONTEXT:
        ASSERTMSG(0, "we shouldn't get here for this property");
        break;
      //
      // no process needed (reusing buffers), just so we don't get caught in the
      // default assert for unrecognized property
      //
      case PROPID_M_SRC_MACHINE_ID:
      case PROPID_M_LABEL:
      case PROPID_M_SENDERID:
      case PROPID_M_SENDER_CERT:
      case PROPID_M_DEST_QUEUE:
      case PROPID_M_RESP_QUEUE:
      case PROPID_M_ADMIN_QUEUE:
      case PROPID_M_XACT_STATUS_QUEUE:
      case PROPID_M_DEST_FORMAT_NAME:
      case PROPID_M_RESP_FORMAT_NAME:
      case PROPID_M_EXTENSION:
      case PROPID_M_CONNECTOR_TYPE:
      case PROPID_M_DEST_SYMM_KEY:
      case PROPID_M_SIGNATURE:
      case PROPID_M_PROV_NAME:
      case PROPID_M_SOAP_ENVELOPE:
      case PROPID_M_COMPOUND_MESSAGE:
        break;
#endif //_DEBUG

      default:
        ASSERTMSG(0, "unrecognized msgpropid.");
        break;
      } // switch
    } // for
#ifdef _DEBUG
    if (m_hMem) {
      ASSERTMSG(m_pbBody, "no body.");
      ASSERTMSG(m_cbBody <= GlobalSize(m_hMem), "bad size.");
    }
#endif // _DEBUG

    //
    // admin/resp property (xxxDestination and/or xxxQueueInfo) were set by receive (if any)
    //
    m_fRespIsFromRcv = TRUE;

//Error:
    return hresult;
}


//=--------------------------------------------------------------------------=
// static CMSMQMessage::FreeMessageProps
//=--------------------------------------------------------------------------=
// Frees dynamically allocated memory allocated on
//  behalf of a msgprops struct.
//
// Parameters:
//    pmsgprops     - [in] pointer to message properties struct
//    fDeleteArrays - [in] delete arrays as well
//
// Output:
//
// Notes:
//
void CMSMQMessage::FreeMessageProps(
    MQMSGPROPS *pmsgprops,
    BOOL fDeleteArrays)
{
    //
    // for allocated props we allocate a single per-instance buffer
    //  which is freed by the dtor
    //
    if (fDeleteArrays) {
      delete [] pmsgprops->aPropID;
      delete [] pmsgprops->aPropVar;
      delete [] pmsgprops->aStatus;
    }
    return;
}




//=--------------------------------------------------------------------------=
// CMSMQMessage::CreateSendMessageProps
//=--------------------------------------------------------------------------=
// Updates message props with contents of data members
//  before sending a message.
//
// Parameters:
//    pmsgprops - [in] pointer to message properties struct
//
// Output:
//
// Notes:
//    Only used before Send.
//
HRESULT CMSMQMessage::CreateSendMessageProps(MQMSGPROPS* pMsgProps)
{
    HRESULT hresult = NOERROR;

    UINT cPropRec = PreparePropIdArray(FALSE, NULL, NULL);
    
    IfFailGo( AllocateMessageProps(cPropRec, pMsgProps));
    
    PreparePropIdArray(TRUE, pMsgProps->aPropID, pMsgProps->aPropVar);
    
    SetSendMessageProps(pMsgProps);

Error:
    return hresult;
}


void CMSMQMessage::SetSendMessageProps(MQMSGPROPS* pMsgProps)
{
    for (UINT i = 0; i < pMsgProps->cProp; ++i)
    {
        MSGPROPID msgpropid = pMsgProps->aPropID[i];
        switch (msgpropid) 
        {
            case PROPID_M_CORRELATIONID:
                pMsgProps->aPropVar[i].caub.pElems = m_rgbCorrelationId;
                pMsgProps->aPropVar[i].caub.cElems = sizeof(m_rgbCorrelationId);
                break;

            case PROPID_M_MSGID:
                pMsgProps->aPropVar[i].caub.pElems = m_rgbMsgId;
                pMsgProps->aPropVar[i].caub.cElems = sizeof(m_rgbMsgId);
                break;

            case PROPID_M_PRIORITY:
                pMsgProps->aPropVar[i].bVal = (UCHAR)m_lPriority;
                break;

            case PROPID_M_DELIVERY:
                pMsgProps->aPropVar[i].bVal = (UCHAR)m_lDelivery;
                break;

            case PROPID_M_ACKNOWLEDGE:
                pMsgProps->aPropVar[i].bVal = (UCHAR)m_lAck;
                break;

            case PROPID_M_JOURNAL:
                pMsgProps->aPropVar[i].bVal = (UCHAR)m_lJournal;
                break;

            case PROPID_M_APPSPECIFIC:
                pMsgProps->aPropVar[i].lVal = m_lAppSpecific;
                break;

            case PROPID_M_BODY:
                ASSERTMSG(m_hMem, "should have buffer!");
                ASSERTMSG(m_hMem == GlobalHandle(m_pbBody), "bad handle.");
                ASSERTMSG(m_cbBody <= GlobalSize(m_hMem), "bad body size.");
                pMsgProps->aPropVar[i].caub.cElems = m_cbBody;
                pMsgProps->aPropVar[i].caub.pElems = m_pbBody;
                break;

            case PROPID_M_BODY_TYPE:
                pMsgProps->aPropVar[i].lVal = m_vtBody;
                break;

            case PROPID_M_LABEL:
                pMsgProps->aPropVar[i].pwszVal = m_pwszLabel;
                break;

            case PROPID_M_TIME_TO_BE_RECEIVED:
                pMsgProps->aPropVar[i].lVal = m_lMaxTimeToReceive;
                break;

            case PROPID_M_TIME_TO_REACH_QUEUE:
                pMsgProps->aPropVar[i].lVal = m_lMaxTimeToReachQueue;
                break;

            case PROPID_M_TRACE:
                pMsgProps->aPropVar[i].bVal = (UCHAR)m_lTrace;
                break;

            case PROPID_M_SENDERID:
                pMsgProps->aPropVar[i].caub.cElems = m_cSenderId.GetBufferUsedSize();
                pMsgProps->aPropVar[i].caub.pElems = m_cSenderId.GetBuffer();
                break;

            case PROPID_M_SENDER_CERT:
                pMsgProps->aPropVar[i].caub.cElems = m_cSenderCert.GetBufferUsedSize();
                pMsgProps->aPropVar[i].caub.pElems = m_cSenderCert.GetBuffer();
                break;

            case PROPID_M_SENDERID_TYPE:
                pMsgProps->aPropVar[i].lVal = m_lSenderIdType;
                break;

            case PROPID_M_PRIV_LEVEL:
                pMsgProps->aPropVar[i].lVal = m_lPrivLevel;
                break;

            case PROPID_M_AUTH_LEVEL:
                pMsgProps->aPropVar[i].lVal = m_lAuthLevel;
                break;

            case PROPID_M_HASH_ALG:
                pMsgProps->aPropVar[i].lVal = m_lHashAlg;
                break;

            case PROPID_M_ENCRYPTION_ALG:
                pMsgProps->aPropVar[i].lVal = m_lEncryptAlg;
                break;

            case PROPID_M_RESP_QUEUE:
                pMsgProps->aPropVar[i].pwszVal = m_pwszRespQueue.GetBuffer();
                break;

            case PROPID_M_ADMIN_QUEUE:
                pMsgProps->aPropVar[i].pwszVal = m_pwszAdminQueue.GetBuffer();
                break;

            case PROPID_M_RESP_FORMAT_NAME:
                pMsgProps->aPropVar[i].pwszVal = m_pwszRespQueueEx.GetBuffer();
                break;

            case PROPID_M_SECURITY_CONTEXT:
                pMsgProps->aPropVar[i].ulVal = (ULONG) DWORD_PTR_TO_DWORD(m_hSecurityContext); //safe cast, only lower 32 bits are significant
                break;
                
            case PROPID_M_EXTENSION:
                pMsgProps->aPropVar[i].caub.cElems = m_cExtension.GetBufferUsedSize();
                pMsgProps->aPropVar[i].caub.pElems = m_cExtension.GetBuffer();
                break;

            case PROPID_M_CONNECTOR_TYPE:
                pMsgProps->aPropVar[i].puuid = &m_guidConnectorType;
                break;

            case PROPID_M_DEST_SYMM_KEY:
                pMsgProps->aPropVar[i].caub.cElems = m_cDestSymmKey.GetBufferUsedSize();
                pMsgProps->aPropVar[i].caub.pElems = m_cDestSymmKey.GetBuffer();
                break;

            case PROPID_M_SIGNATURE:
                pMsgProps->aPropVar[i].caub.cElems = m_cSignature.GetBufferUsedSize();
                pMsgProps->aPropVar[i].caub.pElems = m_cSignature.GetBuffer();
                break;

            case PROPID_M_PROV_TYPE:
                pMsgProps->aPropVar[i].lVal = m_lAuthProvType;
                break;

            case PROPID_M_PROV_NAME:
                pMsgProps->aPropVar[i].pwszVal = m_cAuthProvName.GetBuffer();
                break;

            case PROPID_M_CLASS:
                pMsgProps->aPropVar[i].lVal = m_lClass;
                break;

            case PROPID_M_SOAP_HEADER:
                pMsgProps->aPropVar[i].pwszVal = m_pSoapHeader;
                break;

           case PROPID_M_SOAP_BODY:
                pMsgProps->aPropVar[i].pwszVal = m_pSoapBody;
                break;

 
            default:
                ASSERTMSG(0, "unrecognized msgpropid.");
                break;
        }
    }
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_SenderVersion
//=--------------------------------------------------------------------------=
// Gets MSMQ version of sender
//
// Parameters:
//    plSenderVersion - [out] version of sender
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_SenderVersion(long FAR* plSenderVersion)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plSenderVersion = m_lSenderVersion;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Extension
//=--------------------------------------------------------------------------=
// Gets binary extension property
//
// Parameters:
//    pvarExtension - [out] pointer to binary extension property
//
// Output:
//
// Notes:
//  produces a 1D array of BYTEs in a variant.
//
HRESULT CMSMQMessage::get_Extension(VARIANT FAR* pvarExtension)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutSafeArrayOfBuffer(
						 m_cExtension.GetBuffer(),
						 m_cExtension.GetBufferUsedSize(),
						 pvarExtension);
	return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_Extension
//=--------------------------------------------------------------------------=
// Sets binary extension property
//
// Parameters:
//    varExtension - [in] binary extension property
//
// Output:
//
// Notes:
//    Supports arrays of any type.
//
HRESULT CMSMQMessage::put_Extension(VARIANT varExtension)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult;
    BYTE *pbBuf;
    ULONG cbBuf;

    hresult = GetSafeArrayDataOfVariant(&varExtension, &pbBuf, &cbBuf);
	if(FAILED(hresult))
    	return CreateErrorHelper(hresult, x_ObjectType);

    hresult = m_cExtension.CopyBuffer(pbBuf, cbBuf);
	if(FAILED(hresult))
    	return CreateErrorHelper(hresult, x_ObjectType);

    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_ConnectorTypeGuid
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pbstrGuidConnectorType  [out] connector type guid
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQMessage::get_ConnectorTypeGuid(BSTR FAR* pbstrGuidConnectorType)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hr = GetBstrFromGuid(&m_guidConnectorType, pbstrGuidConnectorType);
#ifdef _DEBUG
      RemBstrNode(*pbstrGuidConnectorType);
#endif // _DEBUG
    return CreateErrorHelper(hr, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_ConnectorTypeGuid
//=--------------------------------------------------------------------------=
//
// Parameters:
//    bstrGuidConnectorType  [in] connector type guid
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQMessage::put_ConnectorTypeGuid(BSTR bstrGuidConnectorType)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hr = GetGuidFromBstr(bstrGuidConnectorType, &m_guidConnectorType);
    return CreateErrorHelper(hr, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_TransactionStatusQueueInfo (for IMSMQMessage3)
//=--------------------------------------------------------------------------=
// Gets transaction status queue for message
//
// Parameters:
//    ppqinfoXactStatus - [out] message's transaction status queue
//
// Output:
//
// Notes:
//    caller must Release returned obj pointer.
//
HRESULT CMSMQMessage::get_TransactionStatusQueueInfo(IMSMQQueueInfo3 FAR* FAR* ppqinfoXactStatus)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = GetQueueInfoOfMessage(&m_idxPendingRcvXactStatusQueue,
                                            &m_msgprops_rcv,
                                            m_pwszXactStatusQueue.GetBuffer(),
                                            &m_pqinfoXactStatus,
                                            &IID_IMSMQQueueInfo3,
                                            (IUnknown **)ppqinfoXactStatus);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_DestinationSymmetricKey
//=--------------------------------------------------------------------------=
// Gets binary Symmetric Key property
//
// Parameters:
//    pvarDestSymmKey - [out] pointer to binary Symmetric Key property
//
// Output:
//
// Notes:
//  produces a 1D array of BYTEs in a variant.
//
HRESULT CMSMQMessage::get_DestinationSymmetricKey(VARIANT FAR* pvarDestSymmKey)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutSafeArrayOfBuffer(
						 m_cDestSymmKey.GetBuffer(),
						 m_cDestSymmKey.GetBufferUsedSize(),
						 pvarDestSymmKey);
	return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_DestinationSymmetricKey
//=--------------------------------------------------------------------------=
// Sets binary Symmetric Key property
//
// Parameters:
//    varDestSymmKey - [in] binary Symmetric Key property
//
// Output:
//
// Notes:
//    Supports arrays of any type.
//
HRESULT CMSMQMessage::put_DestinationSymmetricKey(VARIANT varDestSymmKey)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult;
    BYTE *pbBuf;
    ULONG cbBuf;
    
    hresult = GetSafeArrayDataOfVariant(&varDestSymmKey, &pbBuf, &cbBuf);
	if(FAILED(hresult))
    	return CreateErrorHelper(hresult, x_ObjectType);

    hresult = m_cDestSymmKey.CopyBuffer(pbBuf, cbBuf);
	if(FAILED(hresult))
    	return CreateErrorHelper(hresult, x_ObjectType);

    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Signature
//=--------------------------------------------------------------------------=
// Gets binary Signature property
//
// Parameters:
//    pvarSignature - [out] pointer to binary Signatureproperty
//
// Output:
//
// Notes:
//  produces a 1D array of BYTEs in a variant.
//
HRESULT CMSMQMessage::get_Signature(VARIANT FAR* pvarSignature)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutSafeArrayOfBuffer(
						 m_cSignature.GetBuffer(),
						 m_cSignature.GetBufferUsedSize(),
						 pvarSignature);
	return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_Signature
//=--------------------------------------------------------------------------=
// Sets binary Signature property
//
// Parameters:
//    varSignature - [in] binary Signature property
//
// Output:
//
// Notes:
//    Supports arrays of any type.
//
HRESULT CMSMQMessage::put_Signature(VARIANT varSignature)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult;
    BYTE *pbBuf;
    ULONG cbBuf;
    
    hresult = GetSafeArrayDataOfVariant(&varSignature, &pbBuf, &cbBuf);
	if(FAILED(hresult))
    	return CreateErrorHelper(hresult, x_ObjectType);

    hresult = m_cSignature.CopyBuffer(pbBuf, cbBuf);
	if(FAILED(hresult))
    	return CreateErrorHelper(hresult, x_ObjectType);

    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_AuthenticationProviderType
//=--------------------------------------------------------------------------=
// Gets message's Authentication Provider Type
//
// Parameters:
//    plAuthProvType - [out] message's Authentication Provider Type
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_AuthenticationProviderType(long FAR* plAuthProvType)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *plAuthProvType = m_lAuthProvType;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_AuthenticationProviderType
//=--------------------------------------------------------------------------=
// Sets message's Authentication Provider Type
//
// Parameters:
//    lAuthProvType - [in] message's Authentication Provider Type
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_AuthenticationProviderType(long lAuthProvType)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    m_lAuthProvType = lAuthProvType;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_AuthenticationProviderName
//=--------------------------------------------------------------------------=
// Gets Authentication Provider Name
//
// Parameters:
//    pbstrAuthProvName - [out] pointer to message Authentication Provider Name
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_AuthenticationProviderName(BSTR FAR* pbstrAuthProvName)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if (m_cAuthProvName.GetBufferUsedSize() > 0) {
		*pbstrAuthProvName = SysAllocString(m_cAuthProvName.GetBuffer());
		if(*pbstrAuthProvName == NULL)
			return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
    }
    else {
		*pbstrAuthProvName = SysAllocString(L"");
		if(*pbstrAuthProvName == NULL)
			return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
    }
#ifdef _DEBUG
    RemBstrNode(*pbstrAuthProvName);
#endif // _DEBUG
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::put_AuthenticationProviderName
//=--------------------------------------------------------------------------=
// Sets Authentication Provider Name
//
// Parameters:
//    bstrAuthProvName - [in] message Authentication Provider Name
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::put_AuthenticationProviderName(BSTR bstrAuthProvName)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult;
    if (bstrAuthProvName != NULL) {
      //
      // set wchar buffer from bstr including NULL terminator
      //
		hresult = m_cAuthProvName.CopyBuffer(bstrAuthProvName, static_cast<DWORD>(wcslen(bstrAuthProvName)) + 1);
		if(FAILED(hresult))
    		return CreateErrorHelper(hresult, x_ObjectType);
    }
    else {
      //
      // empty wchar buffer
      //
      m_cAuthProvName.SetBufferUsedSize(0);
    }
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// HELPER ReallocRcvBinPropIfNeeded
//=--------------------------------------------------------------------------=
// Reallocate binary prop in receive buffer
//
static HRESULT ReallocRcvBinPropIfNeeded(MQPROPVARIANT * aPropVar,
                                  ULONG idxProp,
                                  ULONG idxPropLen,
                                  CBaseStaticBufferGrowing<BYTE> * pcBufferProp)
{
    HRESULT hresult;
    //
    // check if we need to realloc
    //
    ULONG cbNeeded = aPropVar[idxPropLen].lVal;
    if (cbNeeded > pcBufferProp->GetBufferMaxSize()) {
      //
      // realloc the property and update receive props with new buffer
      //
      IfFailRet(pcBufferProp->AllocateBuffer(cbNeeded));
      aPropVar[idxProp].caub.cElems = pcBufferProp->GetBufferMaxSize();
      aPropVar[idxProp].caub.pElems = pcBufferProp->GetBuffer();
    }
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// HELPER ReallocRcvStringPropIfNeeded
//=--------------------------------------------------------------------------=
// Reallocate string prop in receive buffer
//
static HRESULT ReallocRcvStringPropIfNeeded(MQPROPVARIANT * aPropVar,
                                     ULONG idxProp,
                                     ULONG idxPropLen,
                                     CBaseStaticBufferGrowing<WCHAR> * pcBufferProp)
{
    HRESULT hresult;
    //
    // check if we need to realloc
    //
    ULONG cbNeeded = aPropVar[idxPropLen].lVal;
    if (cbNeeded > pcBufferProp->GetBufferMaxSize()) {
      //
      // realloc the property and update receive props with new buffer
      //
      IfFailRet(pcBufferProp->AllocateBuffer(cbNeeded));
      aPropVar[idxPropLen].lVal = pcBufferProp->GetBufferMaxSize();
      aPropVar[idxProp].pwszVal = pcBufferProp->GetBuffer();
    }
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// HELPER ReallocRcvBodyPropIfNeeded
//=--------------------------------------------------------------------------=
// Reallocate Body prop in receive buffer
//
static 
HRESULT 
ReallocRcvBodyPropIfNeeded(
	MQMSGPROPS* pmsgprops,
	ULONG idxProp,
	ULONG idxPropLen
	)
{
    //
    // check if we need to realloc
    //
    ULONG cbNeeded = pmsgprops->aPropVar[idxPropLen].lVal;
    if (cbNeeded > pmsgprops->aPropVar[idxProp].caub.cElems) 
	{
      //
      // realloc the property and update receive props with new buffer
      //
	  IfNullRet(AllocateReceiveBodyBuffer(pmsgprops, idxProp, cbNeeded));
    }
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::ReallocReceiveMessageProps
//=--------------------------------------------------------------------------=
// Reallocate Receive message properties
//
// Parameters:
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::ReallocReceiveMessageProps()
{
    HRESULT hresult;
    MQMSGPROPS * pmsgprops = &m_msgprops_rcv;
    MQPROPVARIANT * aPropVar = pmsgprops->aPropVar;
#ifdef _DEBUG
    PROPID * aPropID = pmsgprops->aPropID;
#endif //_DEBUG
    //
    // label buffer is static but we need to return it's size to the default value
    //
    ASSERTMSG(aPropID[MSGPROP_LABEL_LEN] == PROPID_M_LABEL_LEN, "label len not in place");
    aPropVar[MSGPROP_LABEL_LEN].lVal = MQ_MAX_MSG_LABEL_LEN + 1;
    //
    // realloc senderid if necessary
    //
    ASSERTMSG(aPropID[MSGPROP_SENDERID] == PROPID_M_SENDERID, "senderId not in place");
    ASSERTMSG(aPropID[MSGPROP_SENDERID_LEN] == PROPID_M_SENDERID_LEN, "senderId len not in place");
    IfFailRet(ReallocRcvBinPropIfNeeded(
                aPropVar, MSGPROP_SENDERID, MSGPROP_SENDERID_LEN, &m_cSenderId));
    //
    // realloc sender cert if necessary
    //
    ASSERTMSG(aPropID[MSGPROP_SENDER_CERT] == PROPID_M_SENDER_CERT, "senderCert not in place");
    ASSERTMSG(aPropID[MSGPROP_SENDER_CERT_LEN] == PROPID_M_SENDER_CERT_LEN, "senderCert len not in place");
    IfFailRet(ReallocRcvBinPropIfNeeded(
                aPropVar, MSGPROP_SENDER_CERT, MSGPROP_SENDER_CERT_LEN, &m_cSenderCert));
    //
    // realloc extension if necessary
    //
    ASSERTMSG(aPropID[MSGPROP_EXTENSION] == PROPID_M_EXTENSION, "extension not in place");
    ASSERTMSG(aPropID[MSGPROP_EXTENSION_LEN] == PROPID_M_EXTENSION_LEN, "extension len not in place");
    IfFailRet(ReallocRcvBinPropIfNeeded(
                aPropVar, MSGPROP_EXTENSION, MSGPROP_EXTENSION_LEN, &m_cExtension));
    //
    // realloc dest symm key if necessary
    //
    ASSERTMSG(aPropID[MSGPROP_DEST_SYMM_KEY] == PROPID_M_DEST_SYMM_KEY, "destSymmKey not in place");
    ASSERTMSG(aPropID[MSGPROP_DEST_SYMM_KEY_LEN] == PROPID_M_DEST_SYMM_KEY_LEN, "destSymmKey len not in place");
    IfFailRet(ReallocRcvBinPropIfNeeded(
                aPropVar, MSGPROP_DEST_SYMM_KEY, MSGPROP_DEST_SYMM_KEY_LEN, &m_cDestSymmKey));
    //
    // realloc signature if necessary
    //
    ASSERTMSG(aPropID[MSGPROP_SIGNATURE] == PROPID_M_SIGNATURE, "signature not in place");
    ASSERTMSG(aPropID[MSGPROP_SIGNATURE_LEN] == PROPID_M_SIGNATURE_LEN, "signature len not in place");
    IfFailRet(ReallocRcvBinPropIfNeeded(
                aPropVar, MSGPROP_SIGNATURE, MSGPROP_SIGNATURE_LEN, &m_cSignature));
    //
    // realloc auth prov name if necessary
    //
    ASSERTMSG(aPropID[MSGPROP_PROV_NAME] == PROPID_M_PROV_NAME, "authProvName not in place");
    ASSERTMSG(aPropID[MSGPROP_PROV_NAME_LEN] == PROPID_M_PROV_NAME_LEN, "authProvName len not in place");
    IfFailRet(ReallocRcvStringPropIfNeeded(
                aPropVar, MSGPROP_PROV_NAME, MSGPROP_PROV_NAME_LEN, &m_cAuthProvName));
    //
    // realloc body if necessary
    //
    if (m_idxRcvBody != -1) {
      ASSERTMSG(m_idxRcvBodySize != -1, "body size index unknown");
      ASSERTMSG(aPropID[m_idxRcvBody] == PROPID_M_BODY, "body not in place");
      ASSERTMSG(aPropID[m_idxRcvBodySize] == PROPID_M_BODY_SIZE, "body size not in place");
      IfFailRet(ReallocRcvBodyPropIfNeeded(pmsgprops, m_idxRcvBody, m_idxRcvBodySize));
    }
    //
    // realloc dest queue formatname if necessary
    //
    if (m_idxRcvDest != -1) {
      ASSERTMSG(m_idxRcvDestLen != -1, "destQueue len index unknown");
      ASSERTMSG(aPropID[m_idxRcvDest] == PROPID_M_DEST_QUEUE, "destQueue not in place");
      ASSERTMSG(aPropID[m_idxRcvDestLen] == PROPID_M_DEST_QUEUE_LEN, "destQueue len not in place");
      IfFailRet(ReallocRcvStringPropIfNeeded(
                  aPropVar, m_idxRcvDest, m_idxRcvDestLen, &m_pwszDestQueue));
    }
    //
    // realloc admin queue formatname if necessary
    //
    ASSERTMSG(aPropID[MSGPROP_ADMIN_QUEUE] == PROPID_M_ADMIN_QUEUE, "adminQueue not in place");
    ASSERTMSG(aPropID[MSGPROP_ADMIN_QUEUE_LEN] == PROPID_M_ADMIN_QUEUE_LEN, "adminQueue len not in place");
    IfFailRet(ReallocRcvStringPropIfNeeded(
                aPropVar, MSGPROP_ADMIN_QUEUE, MSGPROP_ADMIN_QUEUE_LEN, &m_pwszAdminQueue));
    //
    // realloc resp queue formatname if necessary
    //
    ASSERTMSG(aPropID[MSGPROP_RESP_QUEUE] == PROPID_M_RESP_QUEUE, "respQueue not in place");
    ASSERTMSG(aPropID[MSGPROP_RESP_QUEUE_LEN] == PROPID_M_RESP_QUEUE_LEN, "respQueue len not in place");
    IfFailRet(ReallocRcvStringPropIfNeeded(
                aPropVar, MSGPROP_RESP_QUEUE, MSGPROP_RESP_QUEUE_LEN, &m_pwszRespQueue));
    //
    // realloc xact status queue formatname if necessary
    //
    ASSERTMSG(aPropID[MSGPROP_XACT_STATUS_QUEUE] == PROPID_M_XACT_STATUS_QUEUE, "xactStatusQueue not in place");
    ASSERTMSG(aPropID[MSGPROP_XACT_STATUS_QUEUE_LEN] == PROPID_M_XACT_STATUS_QUEUE_LEN, "xactStatusQueue len not in place");
    IfFailRet(ReallocRcvStringPropIfNeeded(
                aPropVar, MSGPROP_XACT_STATUS_QUEUE, MSGPROP_XACT_STATUS_QUEUE_LEN, &m_pwszXactStatusQueue));
    //
    // realloc dest queue Ex formatname if necessary
    //
    if (m_idxRcvDestEx != -1) {
      ASSERTMSG(m_idxRcvDestExLen != -1, "destQueueEx len index unknown");
      ASSERTMSG(aPropID[m_idxRcvDestEx] == PROPID_M_DEST_FORMAT_NAME, "destQueueEx not in place");
      ASSERTMSG(aPropID[m_idxRcvDestExLen] == PROPID_M_DEST_FORMAT_NAME_LEN, "destQueueEx len not in place");
      IfFailRet(ReallocRcvStringPropIfNeeded(
                  aPropVar, m_idxRcvDestEx, m_idxRcvDestExLen, &m_pwszDestQueueEx));
    }
    //
    // realloc resp queue Ex formatname if necessary
    //
    if (m_idxRcvRespEx != -1) {
      ASSERTMSG(m_idxRcvRespExLen != -1, "respQueueEx len index unknown");
      ASSERTMSG(aPropID[m_idxRcvRespEx] == PROPID_M_RESP_FORMAT_NAME, "respQueueEx not in place");
      ASSERTMSG(aPropID[m_idxRcvRespExLen] == PROPID_M_RESP_FORMAT_NAME_LEN, "respQueueEx len not in place");
      IfFailRet(ReallocRcvStringPropIfNeeded(
                  aPropVar, m_idxRcvRespEx, m_idxRcvRespExLen, &m_pwszRespQueueEx));
    }    
    //
    // realloc SOAP envelope if necessary
    //
    if (m_idxRcvSoapEnvelope != -1) {
      ASSERTMSG(m_idxRcvSoapEnvelopeSize != -1, "SoapEnvelope size index unknown");
      ASSERTMSG(aPropID[m_idxRcvSoapEnvelope] == PROPID_M_SOAP_ENVELOPE, "SoapEnvelope not in place");
      ASSERTMSG(aPropID[m_idxRcvSoapEnvelopeSize] == PROPID_M_SOAP_ENVELOPE_LEN, "SoapEnvelope size not in place");
      IfFailRet(ReallocRcvStringPropIfNeeded(
                aPropVar, m_idxRcvSoapEnvelope, m_idxRcvSoapEnvelopeSize, &m_cSoapEnvelope));
    }
    //
    // realloc CompoundMessage if necessary
    //
    if (m_idxRcvCompoundMessage != -1) {
      ASSERTMSG(m_idxRcvCompoundMessageSize != -1, "CompoundMessage size index unknown");
      ASSERTMSG(aPropID[m_idxRcvCompoundMessage] == PROPID_M_COMPOUND_MESSAGE, "CompoundMessage not in place");
      ASSERTMSG(aPropID[m_idxRcvCompoundMessageSize] == PROPID_M_COMPOUND_MESSAGE_SIZE, "CompoundMessage size not in place");
      IfFailRet(ReallocRcvBinPropIfNeeded(
                aPropVar, m_idxRcvCompoundMessage, m_idxRcvCompoundMessageSize, &m_cCompoundMessage));
    }

    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Properties
//=--------------------------------------------------------------------------=
// Gets message's properties collection
//
// Parameters:
//    ppcolProperties - [out] message's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQMessage::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}

//=--------------------------------------------------------------------------=
// CMSMQMessage::get_TransactionId
//=--------------------------------------------------------------------------=
// Gets message transaction id
//
// Parameters:
//    pvarXactId - [out] message's trasnaction id
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_TransactionId(VARIANT *pvarXactId)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutSafeArrayOfBuffer(
						 m_rgbXactId,
						 m_cbXactId,
						 pvarXactId);
	return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_IsFirstInTransaction
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pisFirstInXact  [out] - whether or not the message is the first message in a transaction
//
// Output:
//
// Notes:
//    returns 1 if true, 0 if false
//
HRESULT CMSMQMessage::get_IsFirstInTransaction(VARIANT_BOOL *pisFirstInXact)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *pisFirstInXact = (VARIANT_BOOL)CONVERT_TRUE_TO_1_FALSE_TO_0(m_fFirstInXact);
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_IsFirstInTransaction2
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pisFirstInXact  [out] - whether or not the message is the first message in a transaction
//
// Output:
//
// Notes:
//    same as get_IsFirstInTransaction, but returns VARIANT_TRUE (-1) if true, VARIANT_FALSE (0) if false
//
HRESULT CMSMQMessage::get_IsFirstInTransaction2(VARIANT_BOOL *pisFirstInXact)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *pisFirstInXact = CONVERT_BOOL_TO_VARIANT_BOOL(m_fFirstInXact);
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_IsLastInTransaction
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pisLastInXact  [out] - whether or not the message is the last message in a transaction
//
// Output:
//
// Notes:
//    returns 1 if true, 0 if false
//
HRESULT CMSMQMessage::get_IsLastInTransaction(VARIANT_BOOL *pisLastInXact)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *pisLastInXact = (VARIANT_BOOL)CONVERT_TRUE_TO_1_FALSE_TO_0(m_fLastInXact);
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_IsLastInTransaction2
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pisLastInXact  [out] - whether or not the message is the last message in a transaction
//
// Output:
//
// Notes:
//    same as get_IsLastInTransaction, but returns VARIANT_TRUE (-1) if true, VARIANT_FALSE (0) if false
//
HRESULT CMSMQMessage::get_IsLastInTransaction2(VARIANT_BOOL *pisLastInXact)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *pisLastInXact = CONVERT_BOOL_TO_VARIANT_BOOL(m_fLastInXact);
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_ReceivedAuthenticationLevel
//=--------------------------------------------------------------------------=
//
// Parameters:
//    psReceivedAuthenticationLevel  [out]
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_ReceivedAuthenticationLevel(short *psReceivedAuthenticationLevel)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    *psReceivedAuthenticationLevel = (short)m_usAuthenticatedEx;
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// HELPER: GetDestinationObjOfFormatNameProp
//=--------------------------------------------------------------------------=
// Converts formatname message prop to MSMQDestination object after receive.
//
// Parameters:
//    pmsgprops - [in] pointer to message properties struct
//    iProp     - [in] index of format name prop
//    pwsz      - [in] formatname string
//    piidRequested [in] - iid to return
//    ppdest      [out] - MSMQDestination object
//
// Output:
//
static HRESULT GetDestinationObjOfFormatNameProp(
    MQMSGPROPS *pmsgprops,
    UINT iProp,
    const WCHAR *pwsz,
    const IID * piidRequested,
    IUnknown **ppdest)
{
    CComObject<CMSMQDestination> *pdestObj;
    IUnknown * pdest = NULL;
    HRESULT hresult = NOERROR;
    BSTR bstrFormatName;

    ASSERTMSG(ppdest, "bad param.");
    if (pmsgprops->aPropVar[iProp].lVal) {
      IfFailGo(CNewMsmqObj<CMSMQDestination>::NewObj(&pdestObj, piidRequested, &pdest));
      bstrFormatName = SysAllocString(pwsz);
      if (bstrFormatName == NULL) {
        IfFailGoTo(E_OUTOFMEMORY, Error2);
      }
      hresult = pdestObj->put_FormatName(bstrFormatName);
      SysFreeString(bstrFormatName);
      IfFailGoTo(hresult, Error2);
      *ppdest = pdest;
      goto Error;         // 2657: fix memleak
    }
    return NOERROR;

Error2:
    RELEASE(pdest);
    // fall through...

Error:
    return hresult;
}

//=--------------------------------------------------------------------------=
// Helper - GetDestinationObjOfMessage
//=--------------------------------------------------------------------------=
// Gets ResponseEx/AdminEx/DestEx MSMQDestination of the message
//
// Parameters:
//    pidxPendingRcv       [in, out] - index of len property in rcv props (-1 if not pending)
//    pmsgpropsRcv         [in]      - msg props
//    pwszFormatNameBuffer [in]      - format name buffer
//    pGITDestination      [in]      - Base GIT member for the MSMQDestination interface (could be fake or real)
//    piidRequested        [in]      - IMSMQDestination
//    ppdest               [out]     - resulting MSMQDestination obj
//
// Output:
//
// Notes:
//    caller must Release returned obj pointer.
//
static HRESULT GetDestinationObjOfMessage(
    long * pidxPendingRcv,
    MQMSGPROPS * pmsgpropsRcv,
    LPCWSTR pwszFormatNameBuffer,
    CBaseGITInterface * pGITDestination,
    const IID *piidRequested,
    IUnknown ** ppdest)
{
    HRESULT hresult = NOERROR;
    //
    // if we have a destination pending in rcv props, create a destination obj for it,
    // register it in GIT object, and set returned destination obj with it
    //
    if (*pidxPendingRcv >= 0) {
      R<IUnknown> pdestPendingRcv;
      IfFailGo(GetDestinationObjOfFormatNameProp(pmsgpropsRcv,
                                                 *pidxPendingRcv,
                                                 pwszFormatNameBuffer,
                                                 piidRequested,
                                                 &pdestPendingRcv.ref()));
      //
      // Register destination obj in the GITInterface object
      //
      IfFailGo(pGITDestination->Register(pdestPendingRcv.get(), piidRequested));
      *pidxPendingRcv = -1; // destination not pending anymore
      //
      // We just created the destination obj, we can return it as is, no need for marshling.
      // Note it is already addref'ed, so we just detach it from the auto release variable
      // which held it
      //
      *ppdest = pdestPendingRcv.detach();
    }
    else
    {
      //
      // destination was not pending from receive
      // We need to get it from the GIT object (we request NULL as default if destination obj
      // was not registered yet.
      //
      IfFailGo(pGITDestination->GetWithDefault(piidRequested, ppdest, NULL));
    }

    //
    // Fall through
    //
Error:
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_ResponseDestination
//=--------------------------------------------------------------------------=
// Gets ResponseEx destination obj for message
//
// Parameters:
//    ppdestResponse - [out] message's ResponseEx destination obj
//
// Output:
//
// Notes:
//    caller must Release returned obj pointer.
//
HRESULT CMSMQMessage::get_ResponseDestination(
    IDispatch FAR* FAR* ppdestResponse)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    //
    // Dependent clients don't support this property
    //
    if (g_fDependentClient) {
      return CreateErrorHelper(MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS, x_ObjectType);
    }
    HRESULT hresult = GetDestinationObjOfMessage(&m_idxPendingRcvRespQueueEx,
                                                 &m_msgprops_rcv,
                                                 m_pwszRespQueueEx.GetBuffer(),
                                                 &m_pdestResponseEx,
                                                 &IID_IDispatch,
                                                 (IUnknown **)ppdestResponse);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// Helper - PutrefDestinationObjOfMessage
//=--------------------------------------------------------------------------=
// Putref's ResponseEx/AdminEx queue of the message
//
// Parameters:
//    punkDest             [in]      - dest obj to putref
//    pidxPendingRcv       [out]     - index of len property in rcv props (-1 if not pending)
//    pwszFormatNameBuffer [in]      - format name buffer
//    pcchFormatNameBuffer [out]     - size of string in format name buffer
//    pGITDestination      [in]      - Base GIT member for the dest obj interface (could be fake or real)
//    pidxPendingRcvQueueInfo       [out] - index of len property to clear (xxxQueueInfo) in rcv props (-1 if not pending)
//    pwszFormatNameBufferQueueInfo [in]  - format name buffer to clear (xxxQueueInfo)
//    pcchFormatNameBufferQueueInfo [out] - size of string in format name buffer to clear (xxxQueueInfo)
//    pGITQueueInfo                 [in]  - Base GIT member for the qinfo obj interface to clear (could be fake or real)
//    pfIsFromRcv                   [out] - whether xxxDestination and xxxQueueInfo were both set by receive
//
// Output:
//
static HRESULT PutrefDestinationObjOfMessage(
    IUnknown * punkDest,
    long * pidxPendingRcv,
    CBaseStaticBufferGrowing<WCHAR> * pwszFormatNameBuffer,
    UINT * pcchFormatNameBuffer,
    CBaseGITInterface * pGITDestination,

    long * pidxPendingRcvQueueInfo,
    CBaseStaticBufferGrowing<WCHAR> * pwszFormatNameBufferQueueInfo,
    UINT * pcchFormatNameBufferQueueInfo,
    CBaseGITInterface * pGITQueueInfo,

    BOOL * pfIsFromRcv
    )
{
    //
    // can't set xxxDestination if xxxQueueInfo is set and not by receive
    //
    if ((*pcchFormatNameBufferQueueInfo != 0) && !(*pfIsFromRcv)) {
      return MQ_ERROR_PROPERTIES_CONFLICT;
    }
    //
    // either both xxxQueueInfo and xxxDestination were set by receive, or xxxQueueInfo is empty
    //
    ASSERT((*pcchFormatNameBufferQueueInfo == 0) || (*pfIsFromRcv));
    HRESULT hresult;
    R<IUnknown> pdest;
    const IID * piid = &IID_NULL;
    //
    // Get best destination
    //
    if (punkDest) {
      IfFailRet(punkDest->QueryInterface(IID_IMSMQDestination, (void **)&pdest.ref()));
      piid = &IID_IMSMQDestination;
    }
    //
    // register interface in GIT object
    //
    IfFailRet(pGITDestination->Register(pdest.get(), piid));
    *pidxPendingRcv = -1; // this is more current than pending queue from receive (if any)
    *pfIsFromRcv = FALSE; // the property was set by the user, not by last receive
    //
    // Update our formatname buffer
    //
    if (pdest.get()) {
      //
      // no deadlock - we call dest obj's get_FormatName (therefore try
      // to lock dest obj) but dest obj never locks msgs (specifically not this one...)
      //
      // pdest has at least IMSMQDestination functionality (any newer interface for dest
      // object is binary compatible to the older)
      //
      BSTR bstrFormatName;
      IfFailRet(((IMSMQDestination*)pdest.get())->get_FormatName(&bstrFormatName));
      ASSERTMSG(bstrFormatName != NULL, "bstrFormatName is NULL");
      //
      // copy format name
      //
      ULONG cchFormatNameBuffer = static_cast<ULONG>(wcslen(bstrFormatName));
      IfFailRet(pwszFormatNameBuffer->CopyBuffer(bstrFormatName, cchFormatNameBuffer+1));
      *pcchFormatNameBuffer = cchFormatNameBuffer;
      SysFreeString(bstrFormatName);
    }
    else {
      //
      // we were passed NULL. we empty the formatname buffer.
      //
      memset(pwszFormatNameBuffer->GetBuffer(), 0, sizeof(WCHAR));
      *pcchFormatNameBuffer = 0;
    }
    //
    // Clear the xxxQueueInfo formatname buffer
    //
    *pidxPendingRcvQueueInfo = -1; // this is more current than pending queueinfo from receive (if any)
    memset(pwszFormatNameBufferQueueInfo->GetBuffer(), 0, sizeof(WCHAR));
    *pcchFormatNameBufferQueueInfo = 0;
    IfFailRet(pGITQueueInfo->Register(NULL, &IID_NULL));
    //
    // return
    //    
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::putref_ResponseDestination
//=--------------------------------------------------------------------------=
// Sets ResponseEx destination for message
//
// Parameters:
//    pdestResponse - [in] message's ResponseEx destination obj
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::putref_ResponseDestination(
    IDispatch FAR* pdestResponse)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    //
    // Dependent clients don't support this property
    //
    if (g_fDependentClient) {
      return CreateErrorHelper(MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS, x_ObjectType);
    }
    HRESULT hresult = PutrefDestinationObjOfMessage(pdestResponse,
                                                    &m_idxPendingRcvRespQueueEx,
                                                    &m_pwszRespQueueEx,
                                                    &m_cchRespQueueEx,
                                                    &m_pdestResponseEx,

                                                    &m_idxPendingRcvRespQueue,
                                                    &m_pwszRespQueue,
                                                    &m_cchRespQueue,
                                                    &m_pqinfoResponse,

                                                    &m_fRespIsFromRcv);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_Destination
//=--------------------------------------------------------------------------=
// Gets DestinationEx destination obj for message
//
// Parameters:
//    ppdestDestination - [out] message's DestinationEx destination obj
//
// Output:
//
// Notes:
//    caller must Release returned obj pointer.
//
HRESULT CMSMQMessage::get_Destination(
    IDispatch FAR* FAR* ppdestDestination)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    //
    // Dependent clients don't support this property
    //
    if (g_fDependentClient) {
      return CreateErrorHelper(MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS, x_ObjectType);
    }
    HRESULT hresult = GetDestinationObjOfMessage(&m_idxPendingRcvDestQueueEx,
                                                 &m_msgprops_rcv,
                                                 m_pwszDestQueueEx.GetBuffer(),
                                                 &m_pdestDestEx,
                                                 &IID_IDispatch,
                                                 (IUnknown **)ppdestDestination);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_LookupId
//=--------------------------------------------------------------------------=
// Gets LookupId for message
//
// Parameters:
//    pvarLookupId - [out] message's lookup ID
//
// Output:
//
// Notes:
//    we return VT_I8 because OLE automation doesn't know VT_UI8 (type of PROPID_M_LOOKUPID)...
//
HRESULT CMSMQMessage::get_LookupId(VARIANT FAR* pvarLookupId)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);

    HRESULT hresult;
    BSTR bstrLookupId = NULL;

    //
    // Dependent clients don't support this property
    //
    if (g_fDependentClient) {
      IfFailGo(MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS);
    }
    
    //
    // Get string representation of 64bit lookup id
    //
    if (m_wszLookupId[0] == '\0') {
      //
      // String representation not initialized yet
      // Initialize string representation
      //
      _ui64tow(m_ullLookupId, m_wszLookupId, 10);
      ASSERTMSG(m_wszLookupId[0] != '\0', "_ui64tow failed");
    }
    //
    // Alloc bstr to return
    //
    IfNullFail(bstrLookupId = SysAllocString(m_wszLookupId));
    //
    // Assign string to variant
    //
    pvarLookupId->vt = VT_BSTR;
    pvarLookupId->bstrVal = bstrLookupId;
#ifdef _DEBUG
    RemBstrNode(bstrLookupId);
#endif // _DEBUG
    bstrLookupId = NULL; //don't free on exit
    hresult = NOERROR;

    //
    // Fall through
    //
Error:
    SysFreeString(bstrLookupId);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_SoapEnvelope
//=--------------------------------------------------------------------------=
// Gets binary SOAP envelope property
//
// Parameters:
//    pbstrSoapEnvelope - [out] pointer to bstr SOAP envelope property
//
// Output:
//
// Notes:
//
HRESULT CMSMQMessage::get_SoapEnvelope(BSTR FAR* pbstrSoapEnvelope)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    //
    // Dependent clients don't support this property
    //
    if (g_fDependentClient) {
      return CreateErrorHelper(MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS, x_ObjectType);
    }

    if (m_cSoapEnvelope.GetBufferUsedSize() > 0) 
	{
		*pbstrSoapEnvelope = SysAllocString(m_cSoapEnvelope.GetBuffer());
		if(*pbstrSoapEnvelope == NULL)
			return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
    }
    else 
	{
		*pbstrSoapEnvelope = SysAllocString(L"");
		if(*pbstrSoapEnvelope == NULL)
			return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
    }

#ifdef  _DEBUG
    RemBstrNode(*pbstrSoapEnvelope);
#endif//_DEBUG

    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQMessage::get_CompoundMessage
//=--------------------------------------------------------------------------=
// Gets binary CompoundMessage property
//
// Parameters:
//    pvarCompoundMessage - [out] pointer to binary CompoundMessage property
//
// Output:
//
// Notes:
//  produces a 1D array of BYTEs in a variant.
//
HRESULT CMSMQMessage::get_CompoundMessage(VARIANT FAR* pvarCompoundMessage)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    //
    // Dependent clients don't support this property
    //
    if (g_fDependentClient) {
      return CreateErrorHelper(MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS, x_ObjectType);
    }
    HRESULT hresult = PutSafeArrayOfBuffer(
						 m_cCompoundMessage.GetBuffer(),
						 m_cCompoundMessage.GetBufferUsedSize(),
						 pvarCompoundMessage);
	return CreateErrorHelper(hresult, x_ObjectType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\qinfos.cpp ===
//=--------------------------------------------------------------------------=
// MSMQQueueInfosObj.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQQueueInfos object
//
//
#include "stdafx.h"
#include "oautil.h"
#include "qinfo.h"
#include "qinfos.H"
#include "query.h"
#include "mq.h"

const MsmqObjType x_ObjectType = eMSMQQueueInfos;

// debug...
#include "debug.h"
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#endif // _DEBUG



//=--------------------------------------------------------------------------=
// CMSMQQueueInfos::CMSMQQueueInfos
//=--------------------------------------------------------------------------=
// create the object
//
// Parameters:
//
// Notes:
//
CMSMQQueueInfos::CMSMQQueueInfos() :
	m_csObj(CCriticalSection::xAllocateSpinCount),
    m_fInitialized(FALSE)
{
    // TODO: initialize anything here
    m_pUnkMarshaler = NULL; // ATL's Free Threaded Marshaler
    m_hEnum = NULL;
    m_bstrContext = NULL;
    m_pRestriction = NULL;
    m_pColumns = NULL;
    m_pSort = NULL;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfos::~CMSMQQueueInfos
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//
CMSMQQueueInfos::~CMSMQQueueInfos ()
{
    // TODO: clean up anything here.
    SysFreeString(m_bstrContext);
    CMSMQQuery::FreeRestriction(m_pRestriction);
    delete m_pRestriction;
    CMSMQQuery::FreeColumnSet(m_pColumns);
    delete m_pColumns;
    delete m_pSort;
    if (m_hEnum != NULL)
    {
		MQLocateEnd(m_hEnum);
		m_hEnum = NULL;  
    }
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfos::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQQueueInfos::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQQueueInfos3,
		&IID_IMSMQQueueInfos2,
		&IID_IMSMQQueueInfos,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

// TODO: implement your interface methods and property exchange functions
//       here.


//=--------------------------------------------------------------------------=
// CMSMQQueueInfos::Reset
//=--------------------------------------------------------------------------=
// Resets collection to beginning.
//
// Parameters:
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CMSMQQueueInfos::Reset()
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    HRESULT hresult = NOERROR;
    //
    // 2006: close current open enum if any
    //
    if (m_hEnum != NULL) {
      hresult = MQLocateEnd(m_hEnum);
      m_hEnum = NULL;
      IfFailGo(hresult);
    }
    hresult = MQLocateBegin(NULL,     // context
                            m_pRestriction,
                            m_pColumns, 
                            0,        // sort not used yet
                            &m_hEnum);
Error:
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfos::Init
//=--------------------------------------------------------------------------=
// Inits collection
//
// Parameters:
//    bstrContext     [in]
//    pRestriction    [in]
//    pColumns        [in]
//    pSort           [in]
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CMSMQQueueInfos::Init(
    BSTR bstrContext,
    MQRESTRICTION *pRestriction,
    MQCOLUMNSET *pColumns,
    MQSORTSET *pSort)
{
    m_fInitialized = TRUE;
    m_bstrContext = bstrContext;
    m_pRestriction = pRestriction;
    m_pColumns = pColumns;
    m_pSort = pSort;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfos::Next
//=--------------------------------------------------------------------------=
// Returns next element in collection.
//
// Parameters:
//    ppqNext       - [out] where they want to put the resulting object ptr.
//                          NULL if end of list.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CMSMQQueueInfos::Next(IMSMQQueueInfo3 **ppqinfoNext)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    if(!m_fInitialized)
    {
        return CreateErrorHelper(OLE_E_BLANK, x_ObjectType);
    }

    ULONG cProps = m_pColumns->cCol;
    MQPROPVARIANT *rgPropVar = NULL;
    IMSMQQueueInfo3 *pqinfo = NULL;
    CComObject<CMSMQQueueInfo> * pqinfoObj;
    HRESULT hresult = NOERROR;
    CStaticBufferGrowing<WCHAR, FORMAT_NAME_INIT_BUFFER> wszFormatName;
    DWORD dwFormatNameLen;

    *ppqinfoNext = NULL;
    IfNullFail(rgPropVar = new MQPROPVARIANT[cProps]);
    ZeroMemory(rgPropVar, sizeof(MQPROPVARIANT)*cProps);
    if (m_hEnum == NULL) {
      IfFailGo(Reset());
    }
    IfFailGo(MQLocateNext(m_hEnum, &cProps, rgPropVar));
    if (cProps != m_pColumns->cCol) {
      ASSERTMSG(cProps == 0, "Illegal number of props returned from MQLocateNext");
      // EOL
      // 2006: do not close enum on EOL since this
      //  will cause the next Next to wraparound due
      //  to the rest of m_hEnum.
      //
      goto Error;
    }

    //
    // Get format name of queue instance
    //
    ASSERTMSG(m_pColumns->aCol[x_idxInstanceInRefreshProps] == PROPID_Q_INSTANCE, "QInstance not in its place");
    ASSERTMSG(rgPropVar[x_idxInstanceInRefreshProps].vt == VT_CLSID, "Illegal QInstance type");
    ASSERTMSG(rgPropVar[x_idxInstanceInRefreshProps].puuid != NULL, "NULL QInstance value");

    dwFormatNameLen = wszFormatName.GetBufferMaxSize();
    hresult = MQInstanceToFormatName(rgPropVar[x_idxInstanceInRefreshProps].puuid,
                                     wszFormatName.GetBuffer(),
                                     &dwFormatNameLen);
    while (hresult == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL) {
      //
      // format name buffer too small, realloc buffer and retry
      //
      ASSERTMSG(dwFormatNameLen > wszFormatName.GetBufferMaxSize(), "MQInstanceToFormatName error");
      IfFailGo(wszFormatName.AllocateBuffer(dwFormatNameLen));
      hresult = MQInstanceToFormatName(rgPropVar[x_idxInstanceInRefreshProps].puuid,
                                       wszFormatName.GetBuffer(),
                                       &dwFormatNameLen);
    }
    IfFailGoTo(hresult, Error2);
    //
    // We can also get here from old apps that want the old IMSMQQueueInfo/Info2 back, but since
    // IMSMQQueueInfo3 is binary backwards compatible we can always return the new interface
    //
    IfFailGoTo(CNewMsmqObj<CMSMQQueueInfo>::NewObj(&pqinfoObj, &IID_IMSMQQueueInfo3, (IUnknown **)&pqinfo), Error2);

    //
    // We don't need to lock the object to perform the unguarded calls below since it is a newly
    // created class and nobody else but us can use it now.
    //
    // Init qinfo object with format name
    //
    IfFailGoTo(pqinfoObj->Init(wszFormatName.GetBuffer()), Error4);
    //
    // Set queue properties from the propvars returned from MQLocateNext
    //
    IfFailGoTo(pqinfoObj->SetQueueProps(m_pColumns->cCol,
                                        m_pColumns->aCol,
                                        rgPropVar,
                                        TRUE /*fEmptyMSMQ2OrAboveProps*/), Error4);
    //
    // Mark the queue as refreshed, but mark MSMQ2 or above properties as pending
    // since we didn't get them in MQLocateNext.
    // Temporary until MQLocateBegin accepts MSMQ2 or above props(#3839)
    //
    pqinfoObj->SetRefreshed(TRUE /*fIsPendingMSMQ2OrAboveProps*/);
    // ownership transfers
    *ppqinfoNext = pqinfo;
    goto Error2;      // normal cleanup

Error4:
    RELEASE(pqinfo);
    //
    // fall through...
    //
Error2:
    FreeFalconQueuePropvars(m_pColumns->cCol, m_pColumns->aCol, rgPropVar);
    //
    // fall through...
    //
Error:
    delete [] rgPropVar;
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQQueueInfos::get_Properties
//=-------------------------------------------------------------------------=
// Gets object's properties collection
//
// Parameters:
//    ppcolProperties - [out] object's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQQueueInfos::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\qinfo.cpp ===
//=--------------------------------------------------------------------------=
// MSMQQueueInfoObj.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQQueueInfo object
//
//

#include "stdafx.h"
#include "oautil.h"
#include "q.h"
#include "qinfo.H"
#include "limits.h"
#include "time.h"
#include "autorel.h"
#include "mqsec.h"

#ifdef _DEBUG
extern VOID RemBstrNode(void *pv);
#endif // _DEBUG

// Falcon includes
// #include "rt.h"

const MsmqObjType x_ObjectType = eMSMQQueueInfo;

// debug...
#include "debug.h"
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#endif // _DEBUG


//
// Props needed for refreshing qinfo (includes MSMQ 2.0 or above props)
// IMPORTANT - if you change a position of a property, check the x_idx constants 
// below and update the position if necessary.
// IMPORTANT - note there are 13 props from MSMQ1. If this changes, change the
// x_cpropsRefreshMSMQ1 constant below
//
const ULONG x_cpropsRefreshMSMQ1 = 13;
const ULONG x_cpropsRefreshMSMQ2 = 1;
const ULONG x_cpropsRefreshMSMQ3 = 2;

const ULONG x_cpropsRefresh = x_cpropsRefreshMSMQ1 +
                              x_cpropsRefreshMSMQ2 +
                              x_cpropsRefreshMSMQ3;
                              ;
const PROPID g_rgpropidRefresh[x_cpropsRefresh] = {
                PROPID_Q_INSTANCE,  // pointed by x_idxInstanceInRefreshProps
                PROPID_Q_TYPE,
                PROPID_Q_LABEL,
                PROPID_Q_PATHNAME,
                PROPID_Q_JOURNAL,
                PROPID_Q_QUOTA,
                PROPID_Q_BASEPRIORITY,
                PROPID_Q_PRIV_LEVEL,
                PROPID_Q_AUTHENTICATE,
                PROPID_Q_TRANSACTION,
                PROPID_Q_CREATE_TIME,
                PROPID_Q_MODIFY_TIME,
                PROPID_Q_JOURNAL_QUOTA,
                //all MSMQ2.0-only properties should be after MSMQ 1.0
                PROPID_Q_PATHNAME_DNS,
                //all MSMQ3.0-only properties should be after MSMQ 2.0
                PROPID_Q_MULTICAST_ADDRESS,
                PROPID_Q_ADS_PATH
};
const ULONG x_idxInstanceInRefreshProps = 0;

//
// Props needed for creating a queue
//
const PROPID g_rgpropidCreate[] = {
                               PROPID_Q_TYPE, 
                               PROPID_Q_LABEL, 
                               PROPID_Q_PATHNAME,
                               PROPID_Q_JOURNAL,
                               PROPID_Q_QUOTA,
                               PROPID_Q_BASEPRIORITY,
                               PROPID_Q_PRIV_LEVEL,
                               PROPID_Q_AUTHENTICATE,
                               PROPID_Q_TRANSACTION,
                               PROPID_Q_JOURNAL_QUOTA,
                               PROPID_Q_MULTICAST_ADDRESS
};
const ULONG x_cpropsCreate = ARRAY_SIZE(g_rgpropidCreate);

//
// Props needed for updating a public queue
//
const PROPID g_rgpropidUpdatePublic[] = {
                  PROPID_Q_TYPE,
                  PROPID_Q_LABEL,
                  PROPID_Q_JOURNAL,
                  PROPID_Q_QUOTA,
                  PROPID_Q_BASEPRIORITY,
                  PROPID_Q_PRIV_LEVEL,
                  PROPID_Q_AUTHENTICATE,
                  PROPID_Q_JOURNAL_QUOTA,
                  PROPID_Q_MULTICAST_ADDRESS
};
const ULONG x_cpropsUpdatePublic = ARRAY_SIZE(g_rgpropidUpdatePublic);

//
// Props needed for updating a private queue
//
const PROPID g_rgpropidUpdatePrivate[] = {
                  PROPID_Q_TYPE,
                  PROPID_Q_LABEL,
                  PROPID_Q_JOURNAL,
                  PROPID_Q_QUOTA,
                  // PROPID_Q_BASEPRIORITY,
                  PROPID_Q_PRIV_LEVEL,
                  PROPID_Q_JOURNAL_QUOTA,
                  PROPID_Q_AUTHENTICATE,
                  PROPID_Q_MULTICAST_ADDRESS
};
const ULONG x_cpropsUpdatePrivate = ARRAY_SIZE(g_rgpropidUpdatePrivate);

//=--------------------------------------------------------------------------=
// HELPER::InitQueueProps
//=--------------------------------------------------------------------------=
// Inits MQQUEUEPROPS struct.  
//
// Parameters:
//
// Output:
//
// Notes:
//
static void InitQueueProps(MQQUEUEPROPS *pqueueprops)
{
    pqueueprops->aPropID = NULL;
    pqueueprops->aPropVar = NULL;
    pqueueprops->aStatus = NULL;
    pqueueprops->cProp = 0;
}

//
// defined in dest.cpp
//
HRESULT GetFormatNameFromPathName(LPCWSTR pwszPathName, BSTR *pbstrFormatName);

//=--------------------------------------------------------------------------=
// HELPER: GetFormatNameOfPathName
//=--------------------------------------------------------------------------=
// Gets formatname member if necessary from pathname
//
// Parameters:
//    pbstrFormatName [out] callee-allocated, caller-freed
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
static HRESULT GetFormatNameOfPathName(
    BSTR bstrPathName,
    BSTR *pbstrFormatName)
{
    // error if no pathname
    if (bstrPathName == NULL) {
      return E_INVALIDARG;
    }
    HRESULT hresult = GetFormatNameFromPathName(bstrPathName, pbstrFormatName);
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::CMSMQQueueInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
CMSMQQueueInfo::CMSMQQueueInfo() :
	m_csObj(CCriticalSection::xAllocateSpinCount)
{
    m_pUnkMarshaler = NULL; // ATL's Free Threaded Marshaler
    m_pguidQueue = new GUID(GUID_NULL);
    m_pguidServiceType = new GUID(GUID_NULL);
    m_bstrLabel = SysAllocString(L"");
    m_bstrPathNameDNS = SysAllocString(L"");
    m_bstrADsPath = SysAllocString(L"");
    m_bstrFormatName = NULL;
    m_isValidFormatName = FALSE;  // 2026
    m_bstrPathName = NULL;
    m_isTransactional = FALSE;
    m_lPrivLevel = (long)DEFAULT_Q_PRIV_LEVEL;
    m_lJournal = DEFAULT_Q_JOURNAL;                 
    m_lQuota = (long)DEFAULT_Q_QUOTA;                                          
    m_lBasePriority = DEFAULT_Q_BASEPRIORITY;                                   
    m_lCreateTime = 0;
    m_lModifyTime = 0;
    m_lAuthenticate = (long)DEFAULT_Q_AUTHENTICATE;  
    m_lJournalQuota = (long)DEFAULT_Q_JOURNAL_QUOTA ;
    m_isRefreshed = FALSE;    // 2536
    m_isPendingMSMQ2OrAboveProps = FALSE;    // Temporary until MQLocateBegin accepts MSMQ2 or above props(#3839)
    m_bstrMulticastAddress = SysAllocString(L"");
    m_fIsDirtyMulticastAddress = FALSE;
    m_fBasePriorityNotSet = TRUE;
}

//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::~CMSMQQueueInfo
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//
CMSMQQueueInfo::~CMSMQQueueInfo ()
{
    // TODO: clean up anything here.
    SysFreeString(m_bstrMulticastAddress);
    SysFreeString(m_bstrFormatName);
    SysFreeString(m_bstrPathName);
    SysFreeString(m_bstrLabel);
    SysFreeString(m_bstrPathNameDNS);
    SysFreeString(m_bstrADsPath);
    delete m_pguidQueue;
    delete m_pguidServiceType;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQQueueInfo::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQQueueInfo3,
		&IID_IMSMQQueueInfo2,
		&IID_IMSMQQueueInfo,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//=--------------------------------------------------------------------------=
// HELPER - GetBstrFromGuid
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pguid           [in]  guid property
//    pbstrGuid       [out] string guid property
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT GetBstrFromGuid(GUID *pguid, BSTR *pbstrGuid)
{ 
    int cbStr;

    *pbstrGuid = SysAllocStringLen(NULL, LENSTRCLSID);
    if (*pbstrGuid) {
      cbStr = StringFromGUID2(*pguid, *pbstrGuid, LENSTRCLSID*2);
      return cbStr == 0 ? E_OUTOFMEMORY : NOERROR;
    }
    else {
      return E_OUTOFMEMORY;
    }
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_QueueGuid
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pbstrGuidQueue  [out] this queue's guid
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_QueueGuid(BSTR *pbstrGuidQueue) 
{ 
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    HRESULT hr = GetBstrFromGuid(m_pguidQueue, pbstrGuidQueue);
#ifdef _DEBUG
      RemBstrNode(*pbstrGuidQueue);
#endif // _DEBUG
    return CreateErrorHelper(hr, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_ServiceTypeGuid
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pbstrGuidQueue  [out] this queue's service type guid
//
// Output:
//    HRESULT       - S_OK
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_ServiceTypeGuid(BSTR *pbstrGuidServiceType)
{ 
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    HRESULT hr = GetBstrFromGuid(m_pguidServiceType, pbstrGuidServiceType);
#ifdef _DEBUG
      RemBstrNode(*pbstrGuidServiceType);
#endif // _DEBUG
    return CreateErrorHelper(hr, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// HELPER - GetGuidFromBstr
//=--------------------------------------------------------------------------=
//
// Parameters:
//    bstrGuid  [in]  guid string
//    pguid     [out] guid property
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT GetGuidFromBstr(BSTR bstrGuid, GUID *pguid)
{
    BSTR bstrTemp;
    HRESULT hresult; 

    IfNullRet(bstrTemp = SYSALLOCSTRING(bstrGuid));
    hresult = CLSIDFromString(bstrTemp, pguid);
    if (FAILED(hresult)) {
      // 1194: map OLE error to Falcon
      hresult = MQ_ERROR_ILLEGAL_PROPERTY_VALUE;
    }

    // fall through...
    SysFreeString(bstrTemp);
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::PutServiceType
//=--------------------------------------------------------------------------=
//
// Parameters:
//    bstrGuidServiceType  [in]  this queue's guid
//    pguidServiceType     [out] where to put it
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::PutServiceType(
    BSTR bstrGuidServiceType,
    GUID *pguidServiceType) 
{
    HRESULT hresult = GetGuidFromBstr(bstrGuidServiceType, pguidServiceType);
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::put_ServiceTypeGuid
//=--------------------------------------------------------------------------=
//
// Parameters:
//    bstrGuidServiceType [in] this queue's guid
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::put_ServiceTypeGuid(BSTR bstrGuidServiceType) 
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutServiceType(bstrGuidServiceType, m_pguidServiceType);
    return CreateErrorHelper(hresult, x_ObjectType);

    // set queue prop
    // return SetProperty(PROPID_Q_TYPE);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_Label
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pbstrLabel  [in] this queue's label
//
// Output:
//    HRESULT       - S_OK
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_Label(BSTR *pbstrLabel)
{ 
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    //
    // Copy our member variable and return ownership of
    //  the copy to the caller.
    //
    *pbstrLabel = SYSALLOCSTRING(m_bstrLabel);
	if(*pbstrLabel == NULL)
		return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);

#ifdef _DEBUG
    RemBstrNode(*pbstrLabel);
#endif // _DEBUG
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::PutLabel
//=--------------------------------------------------------------------------=
//
// Parameters:
//    bstrLabel  [in] this queue's label
//    pbstrLabel [in] where to put it
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::PutLabel(
    BSTR bstrLabel,
    BSTR *pbstrLabel) 
{
    SysFreeString(*pbstrLabel);
    IfNullRet(*pbstrLabel = SYSALLOCSTRING(bstrLabel));
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::put_Label
//=--------------------------------------------------------------------------=
//
// Parameters:
//    bstrLabel   [in] this queue's label
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::put_Label(BSTR bstrLabel)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutLabel(bstrLabel, &m_bstrLabel);
    return CreateErrorHelper(hresult, x_ObjectType);
    // set queue prop
    // return SetProperty(PROPID_Q_LABEL);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_PathNameDNS
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pbstrPathNameDNS [in] this queue's pathname (machine part in DNS format)
//
// Output:
//    HRESULT       - S_OK
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_PathNameDNS(BSTR *pbstrPathNameDNS)
{ 
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ2_OR_ABOVE_PROP);
    //
    // Copy our member variable and return ownership of
    //  the copy to the caller.
    //
    *pbstrPathNameDNS = SYSALLOCSTRING(m_bstrPathNameDNS);
	if(*pbstrPathNameDNS == NULL)
		return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);

#ifdef _DEBUG
    RemBstrNode(*pbstrPathNameDNS);
#endif // _DEBUG
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_ADsPath
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pbstrADsPath [in] this queue's ADSI path
//
// Output:
//    HRESULT       - S_OK
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_ADsPath(BSTR *pbstrADsPath)
{ 
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ2_OR_ABOVE_PROP);
    //
    // Copy our member variable and return ownership of
    //  the copy to the caller.
    //
    *pbstrADsPath = SYSALLOCSTRING(m_bstrADsPath);
	if(*pbstrADsPath == NULL)
		return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
#ifdef _DEBUG
    RemBstrNode(*pbstrADsPath);
#endif // _DEBUG
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_PathName
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pbstrPathName [in] this queue's pathname
//
// Output:
//    HRESULT       - S_OK
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_PathName(BSTR *pbstrPathName)
{ 
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    *pbstrPathName = SYSALLOCSTRING(m_bstrPathName);
	if(*pbstrPathName == NULL)
		return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
#ifdef _DEBUG
    RemBstrNode(*pbstrPathName);
#endif // _DEBUG
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::PutPathName
//=--------------------------------------------------------------------------=
//
// Parameters:
//    bstrPathName  [in] this queue's PathName
//    pbstrPathName [in] where to put it
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::PutPathName(
    BSTR bstrPathName,
    BSTR *pbstrPathName) 
{
    SysFreeString(*pbstrPathName);
    IfNullRet(*pbstrPathName = SYSALLOCSTRING(bstrPathName));
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::put_PathName
//=--------------------------------------------------------------------------=
//
// Parameters:
//    bstrPathName  [in] this queue's pathname
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::put_PathName(BSTR bstrPathName)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = NOERROR;
    //
    // note: we don't update the Falcon property --
    //  the user must explicitly create/open to
    //  use this new pathname.
    //
    hresult = PutPathName(bstrPathName, &m_bstrPathName);
	if(FAILED(hresult))
		return CreateErrorHelper(hresult, x_ObjectType);
    //
    // formatname is no longer valid
    //
    m_isValidFormatName = FALSE;
    //
    // BUGBUG if we want to keep the semantics of AutoRefresh (like in the first time a property
    // is read) we need to set m_isRefreshed to FALSE here.
    // If we do so we may also want to change the pathname only if the new pathname is different
    // than what we have already. We should only consider this check if the current pathname is
    // refreshed though...
    //
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_FormatName
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pbstrFormatName [out] this queue's format name
//
// Output:
//    HRESULT       - S_OK
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_FormatName(BSTR *pbstrFormatName)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    //
    // #3092 RaananH - We need to return updated formatname (e.g. if pathname was set after
    // formatname). Like the other properties that return their old value instead of an error
    // if InitProps() failed to refresh them, this one also returns its old value if
    // UpdateFormatName() fails to refresh it.
    //
    UpdateFormatName();
    *pbstrFormatName = SYSALLOCSTRING(m_bstrFormatName);
	if(*pbstrFormatName == NULL)
	    return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
#ifdef _DEBUG
    RemBstrNode(*pbstrFormatName);
#endif // _DEBUG
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::PutFormatName
//=--------------------------------------------------------------------------=
//
// Parameters:
//    bstrFormatName  [in] this queue's FormatName
//    pbstrFormatName [in] where to put it
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::PutFormatName(
    LPCWSTR pwszFormatName)
{
    SysFreeString(m_bstrFormatName);
    IfNullRet(m_bstrFormatName = SYSALLOCSTRING(pwszFormatName));
    //
    // formatname is now valid
    //
    m_isValidFormatName = TRUE;
    //
    // BUGBUG if we want to keep the semantics of AutoRefresh (like in the first time a property
    // is read) we need to set m_isRefreshed to FALSE here.
    // If we do so we may also want to change the formatname only if the new formatname is different
    // than what we have already. We should only consider this check if the current formatname is
    // valid though...
    //
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::put_FormatName
//=--------------------------------------------------------------------------=
//
// Parameters:
//    bstrFormatName  [in] this queue's formatname
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::put_FormatName(BSTR bstrFormatName)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutFormatName(bstrFormatName);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_IsTransactional
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pisTransactional  [out]
//
// Output:
//
// Notes:
//    returns 1 if true, 0 if false
//
HRESULT CMSMQQueueInfo::get_IsTransactional(VARIANT_BOOL *pisTransactional) 
{ 
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    *pisTransactional = (VARIANT_BOOL)CONVERT_TRUE_TO_1_FALSE_TO_0(m_isTransactional);
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_IsTransactional2
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pisTransactional  [out]
//
// Output:
//
// Notes:
//    same as get_IsTransactional, but returns VARIANT_TRUE (-1) if true, VARIANT_FALSE (0) if false
//
HRESULT CMSMQQueueInfo::get_IsTransactional2(VARIANT_BOOL *pisTransactional) 
{ 
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    *pisTransactional = CONVERT_BOOL_TO_VARIANT_BOOL(m_isTransactional);
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::PutPrivLevel
//=--------------------------------------------------------------------------=
//
// Parameters:
//    plPrivLevel    [out]
//    lPrivLevel     [in]
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueueInfo::PutPrivLevel(
    long lPrivLevel,
    long *plPrivLevel)
{
    switch (lPrivLevel) {
    case MQ_PRIV_LEVEL_NONE:
    case MQ_PRIV_LEVEL_OPTIONAL:
    case MQ_PRIV_LEVEL_BODY:
      *plPrivLevel = lPrivLevel;
      return NOERROR;
    default:
		return MQ_ERROR_ILLEGAL_PROPERTY_VALUE;
    }
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get/put_PrivLevel
//=--------------------------------------------------------------------------=
//
// Parameters:
//    plPrivLevel    [out]
//    lPrivLevel     [in]
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_PrivLevel(long *plPrivLevel)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    *plPrivLevel = m_lPrivLevel;
    return NOERROR;
}


HRESULT CMSMQQueueInfo::put_PrivLevel(long lPrivLevel)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutPrivLevel(lPrivLevel, &m_lPrivLevel);
	return CreateErrorHelper(hresult, x_ObjectType);
    // return SetProperty(PROPID_Q_PRIV_LEVEL);
}

//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::PutJournal
//=--------------------------------------------------------------------------=
//
// Parameters:
//    plJournal [out]
//    lJournal  [in]
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueueInfo::PutJournal(
    long lJournal, 
    long *plJournal)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    switch (lJournal) {
    case MQ_JOURNAL_NONE:
    case MQ_JOURNAL:
      *plJournal = lJournal;
      return NOERROR;
    default:
		return MQ_ERROR_ILLEGAL_PROPERTY_VALUE;
    }
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get/put_Journal
//=--------------------------------------------------------------------------=
//
// Parameters:
//    plJournal      [out]
//    lJournal       [in]
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_Journal(long *plJournal)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    *plJournal = m_lJournal;
    return NOERROR;
}


HRESULT CMSMQQueueInfo::put_Journal(long lJournal)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutJournal(lJournal, &m_lJournal);
    return CreateErrorHelper(hresult, x_ObjectType);
    // return SetProperty(PROPID_Q_JOURNAL);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::PutQuota
//=--------------------------------------------------------------------------=
//
// Parameters:
//    plQuota [out]
//    lQuota  [in]
//
// Output:
//
// Notes:
//
inline HRESULT CMSMQQueueInfo::PutQuota(long lQuota, long *plQuota)
{
    // UNDONE: validate...
    *plQuota = lQuota;
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get/put_quota
//=--------------------------------------------------------------------------=
//
// Parameters:
//    plQuota       [out]
//    lQuota        [in]
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_Quota(long *plQuota)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    *plQuota = m_lQuota;
    return NOERROR;
}


HRESULT CMSMQQueueInfo::put_Quota(long lQuota)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return PutQuota(lQuota, &m_lQuota);
    // set queue prop
    // return SetProperty(PROPID_Q_QUOTA);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::PutBasePriority
//=--------------------------------------------------------------------------=
//
// Parameters:
//    plBasePriority [out]
//    lBasePriority  [in]
//
// Output:
//
// Notes:
//
inline HRESULT CMSMQQueueInfo::PutBasePriority(
    long lBasePriority, 
    long *plBasePriority)
{
    if ((lBasePriority >= (long)SHRT_MIN) &&
        (lBasePriority <= (long)SHRT_MAX)) {
      *plBasePriority = lBasePriority;
      return NOERROR;
    }
    else {
		return MQ_ERROR_ILLEGAL_PROPERTY_VALUE;
    }
}

//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get/put_BasePriority
//=--------------------------------------------------------------------------=
//
// Parameters:
//    plBasePriority       [out]
//    lBasePriority        [in]
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_BasePriority(long *plBasePriority)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    *plBasePriority = m_lBasePriority;
    return NOERROR;
}


HRESULT CMSMQQueueInfo::put_BasePriority(long lBasePriority)
{
   m_fBasePriorityNotSet = FALSE;
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutBasePriority(lBasePriority, &m_lBasePriority);	      
	return CreateErrorHelper(hresult, x_ObjectType);

    // set queue prop
    // return SetProperty(PROPID_Q_BASEPRIORITY);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_CreateTime/dateModifyTime
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pvarCreateTime          [out]
//    pvarModifyTime          [out]
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_CreateTime(VARIANT *pvarCreateTime)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    return GetVariantTimeOfTime(m_lCreateTime, pvarCreateTime);
}


HRESULT CMSMQQueueInfo::get_ModifyTime(VARIANT *pvarModifyTime)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    return GetVariantTimeOfTime(m_lModifyTime, pvarModifyTime);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::PutAuthenticate
//=--------------------------------------------------------------------------=
//
// Parameters:
//    plAuthenticate [out]
//    lAuthenticate  [in]
//
// Output:
//
// Notes:
//
inline HRESULT CMSMQQueueInfo::PutAuthenticate(
    long lAuthenticate, 
    long *plAuthenticate)
{
    switch (lAuthenticate) {
    case MQ_AUTHENTICATE_NONE:
    case MQ_AUTHENTICATE:
      *plAuthenticate = lAuthenticate;
      return NOERROR;
    default:
		return MQ_ERROR_ILLEGAL_PROPERTY_VALUE;
    }
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get/put_Authenticate
//=--------------------------------------------------------------------------=
//
// Parameters:
//    plAuthenticate         [out]
//    lAuthenticate          [in]
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_Authenticate(long *plAuthenticate)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    *plAuthenticate = m_lAuthenticate;
    return NOERROR;
}


HRESULT CMSMQQueueInfo::put_Authenticate(long lAuthenticate)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = PutAuthenticate(lAuthenticate, &m_lAuthenticate);
	return CreateErrorHelper(hresult, x_ObjectType);
    // return SetProperty(PROPID_Q_AUTHENTICATE);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get/put_JournalQuota
//=--------------------------------------------------------------------------=
//
// Parameters:
//    plJournalQuota         [out]
//    lJournalQuota          [in]
//
// Output:
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_JournalQuota(long *plJournalQuota)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ1_PROP);
    *plJournalQuota = m_lJournalQuota;
    return NOERROR;
}


HRESULT CMSMQQueueInfo::put_JournalQuota(long lJournalQuota)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    m_lJournalQuota = lJournalQuota;
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::CreateQueueProps
//=--------------------------------------------------------------------------=
// Creates and updates an MQQUEUEPROPS struct.  Fills in struct with
//  this queue's properties.  Specifically: label, pathname, guid, servicetype.
//
// Parameters:
//  fUpdate           TRUE if they want to update struct with
//                     current datamembers
//  cProp
//  pqueueprops
//  isTransactional   TRUE if they want a transacted queue.
//  rgpropid          array of PROPIDs.
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::CreateQueueProps(
    BOOL fUpdate,
    UINT cPropMax, 
    MQQUEUEPROPS *pqueueprops, 
    BOOL isTransactional,
    const PROPID rgpropid[])
{
    HRESULT hresult = NOERROR;
    UINT cProps = 0;

    InitQueueProps(pqueueprops);
    IfNullFail(pqueueprops->aPropID = new QUEUEPROPID[cPropMax]);
    IfNullFail(pqueueprops->aStatus = new HRESULT[cPropMax]);
    IfNullFail(pqueueprops->aPropVar = new MQPROPVARIANT[cPropMax]);

    // process array of PROPIDs    
    for (UINT uiTmp = 0; uiTmp < cPropMax; uiTmp++) {
      MQPROPVARIANT *pvar = &pqueueprops->aPropVar[cProps];
      QUEUEPROPID queuepropid = rgpropid[uiTmp];
      pqueueprops->aPropID[cProps] = queuepropid;
      switch (queuepropid) {

      case PROPID_Q_INSTANCE:
        // This is an OUT param so we just use the current member 
        //  as a buffer.
        //
        ASSERTMSG(m_pguidQueue, "should always be non-null");
        if (fUpdate) {
          pvar->vt = VT_CLSID;
          pvar->puuid = m_pguidQueue;
        }
        else {
          pvar->puuid = NULL;  
          pvar->vt = VT_NULL;  
        }
        cProps++;
        break;

      case PROPID_Q_TYPE:
        ASSERTMSG(m_pguidServiceType, "should always be non-null");
        if (fUpdate) {
          pvar->vt = VT_CLSID;
          pvar->puuid = m_pguidServiceType;
        }
        else {
          pvar->puuid = NULL;  
          pvar->vt = VT_NULL;
        }
        cProps++;
        break;

      case PROPID_Q_LABEL:
        ASSERTMSG(m_bstrLabel, "should always be non-null");
        if (fUpdate) {
          pvar->vt = VT_LPWSTR;
          pvar->pwszVal = m_bstrLabel;
        }
        else {
          pvar->pwszVal = NULL;  
          pvar->vt = VT_NULL;
        }
        cProps++;
        break;

      case PROPID_Q_PATHNAME_DNS:
        ASSERTMSG(m_bstrPathNameDNS, "should always be non-null");
        // we never get in here for update
        ASSERTMSG(!fUpdate, "PathNameDNS is read only");
        pvar->pwszVal = NULL;  
        pvar->vt = VT_NULL;
        cProps++;
        break;

      case PROPID_Q_ADS_PATH:
        ASSERTMSG(m_bstrADsPath, "should always be non-null");
        // we never get in here for update
        ASSERTMSG(!fUpdate, "ADsPath is read only");
        pvar->pwszVal = NULL;  
        pvar->vt = VT_NULL;
        cProps++;
        break;

      case PROPID_Q_PATHNAME:
        pvar->vt = VT_LPWSTR;
        if (fUpdate) {
          if (m_bstrPathName) {
            pvar->pwszVal = m_bstrPathName;
          }
          else {
            // no default: param is mandatory
            IfFailGo(ERROR_INVALID_PARAMETER);
          }
        }
        else {
          pvar->pwszVal = NULL;  
          pvar->vt = VT_NULL;
        }
        cProps++;
        break;
      
      case PROPID_Q_JOURNAL:
        pvar->vt = VT_UI1;
        if (fUpdate) pvar->bVal = (UCHAR)m_lJournal;
        cProps++;
        break;

      case PROPID_Q_QUOTA:
        pvar->vt = VT_UI4;
        if (fUpdate) pvar->lVal = (ULONG)m_lQuota;
        cProps++;
        break;

      case PROPID_Q_BASEPRIORITY:
        pvar->vt = VT_I2;
        if (fUpdate) pvar->iVal = (SHORT)m_lBasePriority;
        cProps++;
        break;

      case PROPID_Q_PRIV_LEVEL:
        pvar->vt = VT_UI4;
        if (fUpdate) pvar->lVal = m_lPrivLevel;
        cProps++;
        break;

      case PROPID_Q_AUTHENTICATE:
        pvar->vt = VT_UI1;
        if (fUpdate) pvar->bVal = (UCHAR)m_lAuthenticate;
        cProps++;
        break;

      case PROPID_Q_TRANSACTION:
        pvar->vt = VT_UI1;
        if (fUpdate) {
          pvar->bVal = 
            (UCHAR)isTransactional ? MQ_TRANSACTIONAL : MQ_TRANSACTIONAL_NONE;
        }
        cProps++;
        break;

      case PROPID_Q_CREATE_TIME:
        pvar->vt = VT_I4;
        if (fUpdate) {
          // R/O
          // hresult = ERROR_INVALID_PARAMETER;
        }
        cProps++;
        break;

      case PROPID_Q_MODIFY_TIME:
        pvar->vt = VT_I4;
        if (fUpdate) {
          // R/O
          // hresult = ERROR_INVALID_PARAMETER;
        }
        cProps++;
        break;

      case PROPID_Q_JOURNAL_QUOTA:
        pvar->vt = VT_UI4;
        if (fUpdate) pvar->lVal = m_lJournalQuota;
        cProps++;
        break;

      case PROPID_Q_MULTICAST_ADDRESS:
        if (fUpdate) {
          //
          // Specify MulticastAddress only if specifically set by the user
          // This is to ensure a deterministic behavior in mixed mode with MQDS servers
          // that don't recognize the property
          //
          if (m_fIsDirtyMulticastAddress) {
            //
            // Use VT_EMPTY for both NULL and empty string
            //
            if (m_bstrMulticastAddress == NULL) {
              ASSERTMSG(0, "MulticastAddress should always be non-null");
              pvar->vt = VT_EMPTY;
            }
            else if (wcslen(m_bstrMulticastAddress) == 0) {
              pvar->vt = VT_EMPTY;
            }
            else {
              pvar->vt = VT_LPWSTR;
              pvar->pwszVal = m_bstrMulticastAddress;
            }
            cProps++;
          } //m_fIsDirtyMulticastAddress
        } //fUpdate
        else {
          pvar->pwszVal = NULL;  
          pvar->vt = VT_NULL;
          cProps++;
        }
        break;

      default:
        ASSERTMSG(0, "unhandled queuepropid");
      } // switch
    } // for

    pqueueprops->cProp = cProps;
    return NOERROR;

Error:
    FreeQueueProps(pqueueprops);
    InitQueueProps(pqueueprops);
    return hresult;
}


//=--------------------------------------------------------------------------=
// Helper: FreeFalconQueuePropvars
//=--------------------------------------------------------------------------=
// Frees dynamic memory allocated by Falcon on behalf of the queue's properties
//
// Parameters:
//  pqueueprops
//
// Output:
//
// Notes:
//
void FreeFalconQueuePropvars(ULONG cProps, QUEUEPROPID * rgpropid, MQPROPVARIANT * rgpropvar)
{
    UINT i;
    QUEUEPROPID queuepropid;

    MQPROPVARIANT *pvar = rgpropvar;
    for (i = 0; i < cProps; i++, pvar++) {
      queuepropid = rgpropid[i];
      switch (queuepropid) {
      case PROPID_Q_INSTANCE:
        MQFreeMemory(pvar->puuid);
        break;
      case PROPID_Q_TYPE:
        MQFreeMemory(pvar->puuid);
        break;
      case PROPID_Q_LABEL:
        MQFreeMemory(pvar->pwszVal);
        break;
      case PROPID_Q_PATHNAME_DNS:
        //
        // the only property that can be have vt == VT_EMPTY after successful DS call
        // this means no value for prop
        //
        if (pvar->vt != VT_EMPTY) {
          MQFreeMemory(pvar->pwszVal);
        }
        break;
      case PROPID_Q_ADS_PATH:
        //
        // maybe not returned
        //
        if (pvar->vt == VT_LPWSTR) {
          MQFreeMemory(pvar->pwszVal);
        }
        break;
      case PROPID_Q_PATHNAME:
        MQFreeMemory(pvar->pwszVal);
        break;
      case PROPID_Q_MULTICAST_ADDRESS:
        //
        // maybe not returned
        //
        if (pvar->vt == VT_LPWSTR) {
          MQFreeMemory(pvar->pwszVal);
        }
        break;
      } // switch
    } // for
}


//=--------------------------------------------------------------------------=
// static CMSMQQueueInfo::FreeQueueProps
//=--------------------------------------------------------------------------=
// Frees dynamic memory allocated on behalf of an 
//  MQQUEUEPROPS struct.  
//
// Parameters:
//  pqueueprops
//
// Output:
//
// Notes:
//
void CMSMQQueueInfo::FreeQueueProps(MQQUEUEPROPS *pqueueprops)
{
    // Note: all properties are owned by the MSMQQueueInfo.
    delete [] pqueueprops->aPropID;
    delete [] pqueueprops->aPropVar;
    delete [] pqueueprops->aStatus;
    return;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::SetQueueProps
//=--------------------------------------------------------------------------=
// Sets queue's props from an MQQUEUEPROPS struct.  
//
// Parameters:
//  cProps             - number of props in array
//  rgpropid           - array of propids
//  rgpropvar          - array of propvars
//  fEmptyMSMQ2Props   - whether to empty MSMQ2 members ot not
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQQueueInfo::SetQueueProps(ULONG cProps,
                                      QUEUEPROPID *rgpropid,
                                      MQPROPVARIANT *rgpropvar,
                                      BOOL fEmptyMSMQ2OrABoveProps)
{
    UINT i;
    QUEUEPROPID queuepropid;
    HRESULT hresult = NOERROR;
    MQPROPVARIANT *pvar;

    //
    // If we couldn't get the msmq2 or above props , we set the respective class members
    // to empty values since we don't want to leave their old value (might be of a different queue).
    //
    if (fEmptyMSMQ2OrABoveProps) {
      IfNullFail(SysReAllocString(&m_bstrPathNameDNS, L""));
      IfNullFail(SysReAllocString(&m_bstrADsPath, L""));
    }

    pvar = rgpropvar;
    for (i = 0; i < cProps; i++, pvar++) {
      queuepropid = rgpropid[i];
      
      // outcoming VT_NULL indicates that property was ignored
      //  so skip setting it...
      //
      if (pvar->vt == VT_NULL) {
        continue;
      }
      switch (queuepropid) {
      case PROPID_Q_INSTANCE:
        *m_pguidQueue = *pvar->puuid;
        break;
      case PROPID_Q_TYPE:
        *m_pguidServiceType = *pvar->puuid;
        break;
      case PROPID_Q_LABEL:
        IfNullFail(SysReAllocString(&m_bstrLabel, 
                                    pvar->pwszVal));
        break;
      case PROPID_Q_PATHNAME_DNS:
        //
        // the only property that can be have vt == VT_EMPTY after successful DS call
        // this means no value for prop
        //
        if (pvar->vt != VT_EMPTY) {
          IfNullFail(SysReAllocString(&m_bstrPathNameDNS, 
                                      pvar->pwszVal));
        }
        else {
          IfNullFail(SysReAllocString(&m_bstrPathNameDNS, L""));
        }
        break;
      case PROPID_Q_ADS_PATH:
        //
        // maybe not returned
        //
        if (pvar->vt == VT_LPWSTR) {
          IfNullFail(SysReAllocString(&m_bstrADsPath, 
                                      pvar->pwszVal));
        }
        else {
          IfNullFail(SysReAllocString(&m_bstrADsPath, L""));
        }
        break;
      case PROPID_Q_PATHNAME:
        IfNullFail(SysReAllocString(&m_bstrPathName, 
                                    pvar->pwszVal));
        break;
      case PROPID_Q_JOURNAL:
        m_lJournal = (long)pvar->bVal;
        break;
      case PROPID_Q_QUOTA:
        m_lQuota = pvar->lVal;
        break;
      case PROPID_Q_BASEPRIORITY:
        m_lBasePriority = pvar->iVal;
        break;
      case PROPID_Q_PRIV_LEVEL:
        m_lPrivLevel = (long)pvar->lVal;
        break;
      case PROPID_Q_AUTHENTICATE:
        m_lAuthenticate = (long)pvar->bVal;
        break;
      case PROPID_Q_CREATE_TIME:
        m_lCreateTime = pvar->lVal;
        break;
      case PROPID_Q_MODIFY_TIME:
        m_lModifyTime = pvar->lVal;
        break;
      case PROPID_Q_TRANSACTION:
        m_isTransactional = (BOOL)pvar->bVal;
        break;
      case PROPID_Q_JOURNAL_QUOTA:
        m_lJournalQuota = pvar->lVal;
        break;
      case PROPID_Q_MULTICAST_ADDRESS:
        //
        // maybe not returned
        //
        if (pvar->vt == VT_LPWSTR) {
          IfNullFail(SysReAllocString(&m_bstrMulticastAddress, 
                                      pvar->pwszVal));
        }
        else {
          ASSERTMSG(pvar->vt == VT_EMPTY, "invalid vt for MulticastAddress");
          IfNullFail(SysReAllocString(&m_bstrMulticastAddress, L""));
        }
        m_fIsDirtyMulticastAddress = FALSE; //not explicitly set by the user
        break;
      default:
        ASSERTMSG(0, "unhandled queuepropid");
      } // switch
    } // for
    // fall through...

Error:
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::Init
//=--------------------------------------------------------------------------=
// Inits a new queue based on instance params (guidQueue etc.)
//
// Parameters:
//  bstrFormatName
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::Init(
    LPCWSTR pwszFormatName)
{
#ifdef _DEBUG
    if (m_bstrFormatName || pwszFormatName) {
      ASSERTMSG(m_bstrFormatName != pwszFormatName, "bad strings.");
    }
#endif // _DEBUG
    //
    // 2026: PutFormatName validates formatname
    //
    return PutFormatName(pwszFormatName);
}

//
// HELPER: GetCurrentUserSid
//
static BOOL GetCurrentUserSid(PSID psid)
{
    CStaticBufferGrowing<BYTE, 128> rgbTokenUserInfo;
    DWORD cbBuf;
    HANDLE hToken = NULL;

    if (!OpenThreadToken(
          GetCurrentThread(),
          TOKEN_QUERY,
          TRUE,   // OpenAsSelf
          &hToken)) {
      if (GetLastError() != ERROR_NO_TOKEN) {
        return FALSE;
      }
      else {
        if (!OpenProcessToken(
              GetCurrentProcess(),
              TOKEN_QUERY,
              &hToken)) {
          return FALSE;
        }
      }
    }
    ASSERTMSG(hToken, "no current token!");
    //
    // Make sure the token handle gets closed (#4314)
    //
    CAutoCloseHandle cCloseToken(hToken);
    if (!GetTokenInformation(
          hToken,
          TokenUser,
          rgbTokenUserInfo.GetBuffer(),
          rgbTokenUserInfo.GetBufferMaxSize(),
          &cbBuf)) {
      if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        return FALSE;
      }
      //
      // Realloc token buffer if not big enough...
      //
      if (FAILED(rgbTokenUserInfo.AllocateBuffer(cbBuf))) {
        return FALSE;
      }
      //
      // call again with the correct size buffer
      //
      if (!GetTokenInformation(
            hToken,
            TokenUser,
            rgbTokenUserInfo.GetBuffer(),
            rgbTokenUserInfo.GetBufferMaxSize(),
            &cbBuf)) {
        return FALSE;
      }
    }

    TOKEN_USER * ptokenuser = (TOKEN_USER *)rgbTokenUserInfo.GetBuffer();
    PSID psidUser = ptokenuser->User.Sid;

    if (!CopySid(GetLengthSid(psidUser), psid, psidUser)) {
      return FALSE;
    }
    return TRUE;
}


//
// HELPER: GetWorldReadableSecurityDescriptor
//
static 
BOOL 
GetWorldReadableSecurityDescriptor(
    SECURITY_DESCRIPTOR *psd,
    BYTE **ppbBufDacl
	)
{
    BYTE rgbBufSidUser[128];
	PSID psidUser = (PSID)rgbBufSidUser;
    PACL pDacl = NULL;
    DWORD dwAclSize;
    BOOL fRet = TRUE;   // optimism!

    ASSERTMSG(ppbBufDacl, "bad param!");
    *ppbBufDacl = NULL;

    IfNullGo(GetCurrentUserSid(psidUser));

	PSID pEveryoneSid = MQSec_GetWorldSid();
	PSID pAnonymousSid = MQSec_GetAnonymousSid();

    //
    // Calculate the required size for the new DACL and allocate it.
    //
    dwAclSize = sizeof(ACL) + 
					3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
					GetLengthSid(psidUser) + 
					GetLengthSid(pEveryoneSid) + 
					GetLengthSid(pAnonymousSid);

    IfNullGo(pDacl = (PACL)new BYTE[dwAclSize]);
    //
    // Initialize the ACL.
    //
    IfNullGo(InitializeAcl(pDacl, dwAclSize, ACL_REVISION));
    //
    // Add the ACEs to the DACL.
    //
    IfNullGo(AddAccessAllowedAce(
					pDacl, 
					ACL_REVISION, 
					MQSEC_QUEUE_GENERIC_ALL, 
					psidUser
					));

    IfNullGo(AddAccessAllowedAce(
					pDacl, 
					ACL_REVISION, 
					MQSEC_QUEUE_GENERIC_WRITE | MQSEC_QUEUE_GENERIC_READ, 
					pEveryoneSid
					));

    IfNullGo(AddAccessAllowedAce(
					pDacl, 
					ACL_REVISION, 
					MQSEC_WRITE_MESSAGE, 
					pAnonymousSid
					));

    //
    // Initialize the security descriptor.
    //
    IfNullGo(InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION));
    //
    // Set the security descriptor's DACL.
    //
    IfNullGo(SetSecurityDescriptorDacl(psd, TRUE, pDacl, FALSE));
    //
    // setup out DACL
    //
    *ppbBufDacl = (BYTE *)pDacl;
    goto Done;

Error:
    fRet = FALSE;
    delete [] (BYTE *)pDacl;
    //
    // All done...
    //
Done:
    return fRet;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::Create
//=--------------------------------------------------------------------------=
// Creates a new queue based on instance params (guidQueue etc.)
//
// Parameters:
//    pvarTransactional   [in, optional]
//    isWorldReadable     [in, optional]
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::Create(
    VARIANT *pvarTransactional,
    VARIANT *pvarWorldReadable)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    MQQUEUEPROPS queueprops;
    InitQueueProps(&queueprops);  
    //
    // we use the bigger formatname size since we cannot realloc the format name
    // buffer in this case if it is too small...
    //
    ULONG uiFormatNameLen = FORMAT_NAME_INIT_BUFFER_EX;
#ifdef _DEBUG
    ULONG uiFormatNameLenSave = uiFormatNameLen;
#endif // _DEBUG
    BSTR bstrFormatName = NULL;
    BOOL isTransactional, isWorldReadable;
    SECURITY_DESCRIPTOR sd;
    SECURITY_DESCRIPTOR *psd;
    BYTE *pbBufDacl = NULL;
    HRESULT hresult;

    isTransactional = GetBool(pvarTransactional);
    isWorldReadable = GetBool(pvarWorldReadable);
    IfFailGo(CreateQueueProps(TRUE,
                               x_cpropsCreate, 
                               &queueprops,
                               isTransactional,
                               g_rgpropidCreate));
    IfNullFail(bstrFormatName = 
      SysAllocStringLen(NULL, uiFormatNameLen));
    if (isWorldReadable) {
      //
      // construct a security descriptor for this queue
      //  that is world generic readable.
      //
      if (!GetWorldReadableSecurityDescriptor(&sd, &pbBufDacl)) {
        IfFailGo(hresult = MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR);
      }
      psd = &sd;
    }
    else {
      //
      // default Falcon security
      //
      psd = NULL;
    }
    IfFailGo(MQCreateQueue(
               psd,
               &queueprops,
               bstrFormatName,
               &uiFormatNameLen));
    if((hresult == MQ_INFORMATION_PROPERTY) && m_fBasePriorityNotSet)
    {
        hresult = MQ_OK;
    }
    // FormatName mucking...
    // Nothing we can do to fix the situation where the buffer supplied was too small other
    // than invalidate the format name - but this is just a queue, not MQF, so 1K should
    // be enough anyway.
    //
    ASSERTMSG(hresult != MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL,
           "Warning - insufficient format name buffer.");
    ASSERTMSG(uiFormatNameLen <= uiFormatNameLenSave,
           "insufficient buffer.");
    IfNullFail(SysReAllocString(&m_bstrFormatName, bstrFormatName));
    m_isValidFormatName = TRUE; // #3092 RaananH
    //
    // BUGBUG we may want to set m_isRefreshed to TRUE or FALSE explicitly now.
    //
    // Note: we don't SetQueueProps or Refresh since for now
    //  MQCreateQueue is IN-only.
    // bug 1454: need to update transactional field
    //
    m_isTransactional = isTransactional;

Error:
    delete [] pbBufDacl;
    FreeQueueProps(&queueprops);
    SysFreeString(bstrFormatName);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::Delete
//=--------------------------------------------------------------------------=
// Deletes this queue 
//
// Parameters:
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::Delete() 
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = NOERROR;
    //
    // 2026: ensure we have a format name...
    //
    hresult = UpdateFormatName();
    if (SUCCEEDED(hresult)) {
      hresult = MQDeleteQueue(m_bstrFormatName);
    }
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::Open
//=--------------------------------------------------------------------------=
// Opens this queue 
//
// Parameters:
//  lAccess       IN
//  lShareMode    IN
//  ppq           OUT
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::Open(long lAccess, long lShareMode, IMSMQQueue3 **ppq)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    QUEUEHANDLE lHandle;
    IMSMQQueue3 *pq = NULL;
    CComObject<CMSMQQueue> *pqObj;
    HRESULT hresult;

    // pessimism
    *ppq = NULL;

    if (lAccess != MQ_SEND_ACCESS && 
        lAccess != MQ_RECEIVE_ACCESS && 
        lAccess != MQ_PEEK_ACCESS &&
        lAccess != (MQ_PEEK_ACCESS|MQ_ADMIN_ACCESS) &&
        lAccess != (MQ_RECEIVE_ACCESS|MQ_ADMIN_ACCESS)) 
    {
        return CreateErrorHelper(E_INVALIDARG, x_ObjectType);
    }

    if (lShareMode != MQ_DENY_RECEIVE_SHARE &&
        lShareMode != 0 /* MQ_DENY_NONE */) 
    {
        return CreateErrorHelper(E_INVALIDARG, x_ObjectType);
    }

    // ensure we have a format name...
    IfFailGo(UpdateFormatName());
    IfFailGo(MQOpenQueue(
                m_bstrFormatName,
                lAccess, 
                lShareMode,
                (QUEUEHANDLE *)&lHandle)
                );
    //
    // 2536: only attempt to use the DS when
    //  the first prop is accessed... or Refresh
    //  is called explicitly.
    //

    // Create MSMQQueue object and init with handle
    //
    // We can also get here from old apps that want the old IMSMQQueue/Queue2 back, but since
    // IMSMQQueue3 is binary backwards compatible we can always return the new interface
    //
    IfFailGo(CNewMsmqObj<CMSMQQueue>::NewObj(&pqObj, &IID_IMSMQQueue3, (IUnknown **)&pq));
    IfFailGo(pqObj->Init(m_bstrFormatName, lHandle, lAccess, lShareMode));
    *ppq = pq;
    return NOERROR;

Error:
    RELEASE(pq);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::UpdateFormatName
//=--------------------------------------------------------------------------=
// Updates formatname member if necessary from pathname
//
// Parameters:
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//    sets m_bstrFormatName
//
HRESULT CMSMQQueueInfo::UpdateFormatName()
{
    HRESULT hresult = NOERROR;

    // error if no pathname nor formatname yet..
    if ((m_bstrPathName == NULL) && (m_bstrFormatName == NULL)) {
      return E_INVALIDARG;
    }
    //
    // if no format name yet, synthesize from pathname
    // 2026: check for formatname validity.
    //
    if (!m_isValidFormatName ||
        (m_bstrFormatName == NULL) || 
        SysStringLen(m_bstrFormatName) == 0) {
      IfFailRet(GetFormatNameOfPathName(
                  m_bstrPathName, 
                  &m_bstrFormatName));
      m_isValidFormatName = TRUE;
    };

    return hresult;
}



//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::GetQueueProperties
//=--------------------------------------------------------------------------=
// Gets queue properties from DS - allows for falling back on props
//
// Parameters:
//    pPropIDs          [in] - Array of propids
//    pulFallbackProps  [in] - Define a propids subset for each fallback retry
//                             The N'th retry uses the propids 0..pulFallbackProps[N-1]
//    cFallbacks        [in] - number of retries
//    pqueueprops       [out]- queue props array
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQQueueInfo::GetQueueProperties(const PROPID *pPropIDs,
                                           const ULONG * pulFallbackProps,
                                           ULONG cFallbacks,
                                           MQQUEUEPROPS * pqueueprops)
{
  HRESULT hresult = NOERROR;
  //
  // loop on number of fallbacks
  //
  InitQueueProps(pqueueprops);  
  for (ULONG ulTry = 0; ulTry < cFallbacks; ulTry++) {
    //
    //Fill queue props with the props for this fallback retry
    //
    IfFailGo(CreateQueueProps(
                FALSE,                    /*fUpdate*/
                pulFallbackProps[ulTry],  /*cProp*/
                pqueueprops,              /*pqueueprops*/
                FALSE,                    /*isTransactional*/
                pPropIDs));               /*rgpropid*/
    //
    //Try call to DS
    //
    hresult = MQGetQueueProperties(m_bstrFormatName, pqueueprops);
    if (SUCCEEDED(hresult)) {
      //
      // succeeded, return (props are in pqueueprops)
      //
      return NOERROR;
    }
    //
    // We failed MQGetQueueProperties
    // Even though MQGetQueueProperties returned an error, MSMQ may have filled some values in
    // the queue props so we free them now
    //
    FreeFalconQueuePropvars(pqueueprops->cProp, pqueueprops->aPropID, pqueueprops->aPropVar);
    FreeQueueProps(pqueueprops);
    InitQueueProps(pqueueprops);  
    //
    // we failed, it might be that we are talking to an older MSMQ DS server that doesn't understand
    // the new props (like MSMQ 1.0 DS doesn't understand PROPID_Q_PATHNAME_DNS).
    // Currently a generic error (MQ_ERROR) is returned in this case, however we can't rely on
    // this generic error to retry the operation since it might change in a future service pack
    // to something more specific. On the other side there are errors that when we get them we
    // know there is no point to retry the operation, like invalid format name, no ds, no security,
    // so we do not retry the operation in these cases. RaananH
    //
    // Now check if the error was severe, or we can retry with less properties incase it
    // is an older DS server
    //
    if ((hresult == MQ_ERROR_NO_DS) ||
        (hresult == MQ_ERROR_ACCESS_DENIED) ||
        (hresult == MQ_ERROR_ILLEGAL_FORMATNAME)) {
      //
      // Severe error, retry will not help, return the error
      //
      return hresult;
    }
    //
    // We retry the call - just fallback to less properties (number of new subset of
    // props is in pulFallbackProps[ulTry]) - this will be done next loop.
    // Continue loop for next retry
    //
  }
  //
  // If we got here past the loops - it means all retries failed, return the last failed hresult
  // No need to free anything, it is already freed after an error in MQGetQueueProperties
  //  
  return hresult;

Error:
    FreeQueueProps(pqueueprops);
    InitQueueProps(pqueueprops);  
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::Refresh
//=--------------------------------------------------------------------------=
// Refreshes all queue properties from DS.
//
// Parameters:
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::Refresh()
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    MQQUEUEPROPS queueprops;
    InitQueueProps(&queueprops);
    HRESULT hresult = NOERROR;
    BOOL fEmptyMSMQ2OrAboveProps = FALSE;
    //
    // MQGetQueueProperties retries
    //
    ULONG rgulRetries[] = {x_cpropsRefresh,        //First try all props
                           x_cpropsRefresh -
                             x_cpropsRefreshMSMQ3, //Then try w/o MSMQ3
                           x_cpropsRefresh -
                             x_cpropsRefreshMSMQ3 - //
                             x_cpropsRefreshMSMQ2}; //Then try w/o MSMQ3 and w/o MSMQ2

    IfFailGo(UpdateFormatName());
    //
    // Get Queue properties with retries
    // BUGBUG for whistler we may not need to worry about talking to MSMQ 2.0 DS, since
    // these clients will upgrade to access the DS directly, but just for now we leave the code
    // in here.
    //
    IfFailGo(GetQueueProperties(g_rgpropidRefresh,
                                rgulRetries,
                                ARRAY_SIZE(rgulRetries),
                                &queueprops));
    //
    // Check if we need to zero out the new props for SetQueueProps.
    //
    if (queueprops.cProp < x_cpropsRefresh) {
      fEmptyMSMQ2OrAboveProps = TRUE;
    }
    //
    // Set props
    //
    IfFailGoTo(SetQueueProps(queueprops.cProp,
                             queueprops.aPropID, 
                             queueprops.aPropVar,
                             fEmptyMSMQ2OrAboveProps), Error2);
    //
    // mark queue object as refreshed
    //
    // mark MSMQ2 or above props as not pending - e.g. we now tried to refresh them - either succeeded
    // or failed. If we succeeded, then no problem, if we failed, then if we let them stay pending
    // then for each future access to them we would do a DS call which is very expensive, and the
    // probablity that the DS has changed from NT4 to NT5 to suddenly make the call succeed is
    // very low. These MSMQ 2.0 props are not reliable anyway in mixed mode, so the app should
    // know they are not guaranteed. The app can always call Refresh to try to obtain them again.
    //
    m_isRefreshed = TRUE;
    m_isPendingMSMQ2OrAboveProps = FALSE;

    // fall through...

Error2:
    FreeFalconQueuePropvars(queueprops.cProp, queueprops.aPropID, queueprops.aPropVar);
    // fall through...

Error:
    FreeQueueProps(&queueprops);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::Update
//=--------------------------------------------------------------------------=
// Updates queue properties in DS from ActiveX object.
//
// Parameters:
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::Update()
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    MQQUEUEPROPS queueprops;
    HRESULT hresult;
    // 
    // CONSIDER: NOP if no props have changed since last Refresh.  
    //  Better yet do this on a per-prop basis.
    //
    InitQueueProps(&queueprops);  
    IfFailGo(UpdateFormatName());
    if (IsPrivateQueueOfFormatName(m_bstrFormatName)) {
      IfFailGo(CreateQueueProps(
                  TRUE,
                  x_cpropsUpdatePrivate,
                  &queueprops,
                  m_isTransactional,
                  g_rgpropidUpdatePrivate));
    }
    else {
      IfFailGo(CreateQueueProps(
                  TRUE,
                  x_cpropsUpdatePublic, 
                  &queueprops,
                  m_isTransactional,
                  g_rgpropidUpdatePublic));
    }
    IfFailGo(UpdateFormatName());
    
    // 1042: DIRECT queues aren't ds'able
      IfFailGo(MQSetQueueProperties(m_bstrFormatName, &queueprops));

    // fall through...

Error:
    FreeQueueProps(&queueprops);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_IsWorldReadable
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pisWorldReadable [out]
//
// Output:
//
// Notes:
//    Can't world readable state since other users can
//     change queue's state dynamically.
//
HRESULT CMSMQQueueInfo::GetIsWorldReadable(
    BOOL *pisWorldReadable)
{
    PSECURITY_DESCRIPTOR psd = NULL;
    BYTE rgbBufSecurityDescriptor[256];
    BYTE *rgbBufSecurityDescriptor2 = NULL;
    DWORD cbBuf, cbBuf2;
    BOOL bDaclExists;
    PACL pDacl;
    BOOL bDefDacl;
    BOOL isWorldReadable = FALSE;
    DWORD dwMaskGenericRead = MQSEC_QUEUE_GENERIC_READ;
    HRESULT hresult;

    // UNDONE: null format name? for now UpdateFormatName
    IfFailGo(UpdateFormatName());
    psd = (PSECURITY_DESCRIPTOR)rgbBufSecurityDescriptor;
    hresult = MQGetQueueSecurity(
                m_bstrFormatName,
                DACL_SECURITY_INFORMATION,
                psd,
                sizeof(rgbBufSecurityDescriptor),
                &cbBuf);
    if (FAILED(hresult)) {
      if (hresult != MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL) {
        goto Error;
      }
      IfNullFail(rgbBufSecurityDescriptor2 = new BYTE[cbBuf]);
      //
      // retry with large enough buffer
      //
      psd = (PSECURITY_DESCRIPTOR)rgbBufSecurityDescriptor2;
      IfFailGo(MQGetQueueSecurity(
                  m_bstrFormatName,
                  DACL_SECURITY_INFORMATION,
                  psd,
                  cbBuf,
                  &cbBuf2));
      ASSERTMSG(cbBuf >= cbBuf2, "bad buffer sizes!");
    }
    ASSERTMSG(psd, "should have security descriptor!");
    IfFalseFailLastError(GetSecurityDescriptorDacl(
              psd, 
              &bDaclExists, 
              &pDacl, 
              &bDefDacl));
    if (!bDaclExists || !pDacl) {
      isWorldReadable = TRUE;
    }
    else {
      //
      // Get the ACL's size information.
      //
      ACL_SIZE_INFORMATION DaclSizeInfo;
      IfFalseFailLastError(GetAclInformation(
                pDacl, 
                &DaclSizeInfo, 
                sizeof(ACL_SIZE_INFORMATION),
                AclSizeInformation));
      //
      // Traverse the ACEs looking for world ACEs
      //  

	  PSID pEveryoneSid = MQSec_GetWorldSid();
      
	  DWORD i;
      BOOL fDone;
      for (i = 0, fDone = FALSE; 
           i < DaclSizeInfo.AceCount && !fDone;
           i++) {
        LPVOID pAce;
        //
        // Retrieve the ACE
        //
        IfFalseFailLastError(GetAce(pDacl, i, &pAce));
        ACCESS_ALLOWED_ACE *pAceStruct = (ACCESS_ALLOWED_ACE *)pAce;
        if (!EqualSid((PSID)&pAceStruct->SidStart, pEveryoneSid)) {
          continue;
        }
        //
        // we've found another world
        //
        switch (pAceStruct->Header.AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
          dwMaskGenericRead &= ~pAceStruct->Mask;
          if (!dwMaskGenericRead) {
            isWorldReadable = TRUE;
            fDone = TRUE;
          }
          break;
        case ACCESS_DENIED_ACE_TYPE:
          if (pAceStruct->Mask & MQSEC_QUEUE_GENERIC_READ) {
            isWorldReadable = FALSE;
            fDone = TRUE;
          }
          break;
        default:
          continue;
        } // switch
      } // for
    }
    //
    // setup return
    //
    *pisWorldReadable = isWorldReadable;
    //
    // fall through...
    //
Error:
    delete [] rgbBufSecurityDescriptor2;
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_IsWorldReadable
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pisWorldReadable [out]
//
// Output:
//
// Notes:
//    Can't world readable state since other users can
//     change queue's state dynamically.
//    returns 1 if true, 0 if false
//
HRESULT CMSMQQueueInfo::get_IsWorldReadable(
    VARIANT_BOOL *pisWorldReadable)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    BOOL isWorldReadable;
    HRESULT hresult = GetIsWorldReadable(&isWorldReadable);
    if (SUCCEEDED(hresult)) {
      *pisWorldReadable = (VARIANT_BOOL)CONVERT_TRUE_TO_1_FALSE_TO_0(isWorldReadable);
    }
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_IsWorldReadable2
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pisWorldReadable [out]
//
// Output:
//
// Notes:
//    Can't world readable state since other users can
//     change queue's state dynamically.
//    same as get_IsWorldReadable, but returns VARIANT_TRUE (-1) if true, VARIANT_FALSE (0) if false
//
HRESULT CMSMQQueueInfo::get_IsWorldReadable2(
    VARIANT_BOOL *pisWorldReadable)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    BOOL isWorldReadable;
    HRESULT hresult = GetIsWorldReadable(&isWorldReadable);
    if (SUCCEEDED(hresult)) {
      *pisWorldReadable = CONVERT_BOOL_TO_VARIANT_BOOL(isWorldReadable);
    }
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::RefreshMSMQ2OrAboveProps
//=--------------------------------------------------------------------------=
// Refreshes MSMQ2 properties only from the DS.
//
// Parameters:
//
// Output:
//    HRESULT
//
// Notes:
//  Temporary until MQLocateBegin accepts MSMQ2 or above props(#3839)
//
HRESULT CMSMQQueueInfo::RefreshMSMQ2OrAboveProps()
{
    MQQUEUEPROPS queueprops;
    InitQueueProps(&queueprops);
    HRESULT hresult = NOERROR;
    BOOL fEmptyMSMQ2OrAboveProps = FALSE;
    //
    // Get MSMQ 2.0 or above Queue properties with retries
    // BUGBUG for whistler we may not need to worry about talking to MSMQ 2.0 DS, since
    // these clients will upgrade to access the DS directly, but just for now we leave the code
    // in here.
    //
    ULONG rgulRetries[] = {x_cpropsRefreshMSMQ2 +
                             x_cpropsRefreshMSMQ3, //First try MSMQ2.0 and MSMQ 3.0 props
                           x_cpropsRefreshMSMQ2};  //Then try only MSMQ2

    hresult = GetQueueProperties(g_rgpropidRefresh + x_cpropsRefreshMSMQ1, //start of MSMQ 2.0 or above props
                                 rgulRetries,
                                 ARRAY_SIZE(rgulRetries),
                                 &queueprops);
    if (FAILED(hresult)) {
      //
      // we ignore the error, and empty the MSMQ 2.0 or above props in this case
      //
      fEmptyMSMQ2OrAboveProps = TRUE;
      hresult = NOERROR;
      //
      // no props to set, and no props to free
      //
      InitQueueProps(&queueprops);
    }
    else {
      //
      // succeeded, Check if we need to zero out the new props for SetQueueProps.
      //
      if (queueprops.cProp < x_cpropsRefreshMSMQ2 + x_cpropsRefreshMSMQ3) {
        fEmptyMSMQ2OrAboveProps = TRUE;
      }
    }
    //
    // Set the props
    //
    IfFailGoTo(SetQueueProps(queueprops.cProp,
                             queueprops.aPropID, 
                             queueprops.aPropVar,
                             fEmptyMSMQ2OrAboveProps), Error2);
    //
    // mark MSMQ2 props as not pending - e.g. we now tried to refresh them - either succeeded
    // or failed. If we succeeded, then no problem, if we failed, then if we let them stay pending
    // then for each future access to them we would do a DS call which is very expensive, and the
    // probablity that the DS has changed from NT4 to NT5 to suddenly make the call succeed is
    // very low. These MSMQ 2.0 props are not reliable anyway in mixed mode, so the app should
    // know they are not guaranteed. The app can always call Refresh to try to obtain them again.
    //
    m_isPendingMSMQ2OrAboveProps = FALSE;

    // fall through...

Error2:
    FreeFalconQueuePropvars(queueprops.cProp, queueprops.aPropID, queueprops.aPropVar);
    // fall through...

//Error:
    FreeQueueProps(&queueprops);
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::SetRefreshed
//=--------------------------------------------------------------------------=
// Sets the queue as refreshed
//
// Parameters:
//    fIsPendingMSMQ2OrAboveProps - [in] whether we need another DS call to retrieve MSMQ2 or above props
//
// Output:
//
// Notes:
//    fIsPendingMSMQ2OrAboveProps is temporary until MQLocateBegin accepts MSMQ2 or above props(#3839)
//
void CMSMQQueueInfo::SetRefreshed(BOOL fIsPendingMSMQ2OrAboveProps)
{
    m_isRefreshed = TRUE;
    m_isPendingMSMQ2OrAboveProps = fIsPendingMSMQ2OrAboveProps;
}


//=--------------------------------------------------------------------------=
// InitProps
//=--------------------------------------------------------------------------=
// Init DS props if not already refreshed...
// ePropType is temporary until MQLocateBegin accepts MSMQ2 or above props(#3839)
//
HRESULT CMSMQQueueInfo::InitProps(enumPropVersion ePropVersion)
{
    HRESULT hresult = NOERROR;
    if (!m_isRefreshed) {
      //
      // the Refresh() call below will update m_isRefreshed
      //
      hresult = Refresh();    // ignore DS errors...
    }
    else
    {
      //
      // we are refreshed, but it might be that MSMQ2 or above props are pending and we need
      // to perform a DS call to get them. This happens if the qinfo was retrieved
      // from qinfos.Next.
      // Temporary until MQLocateBegin accepts MSMQ2 or above props(#3839)
      //
      if (m_isPendingMSMQ2OrAboveProps && (ePropVersion == e_MSMQ2_OR_ABOVE_PROP))
      {
        //
        // the RefreshMSMQ2OrAboveProps() call below will update m_isPendingMSMQ2OrAboveProps
        //
        hresult = RefreshMSMQ2OrAboveProps();    // ignore DS errors...
      }
    }

    return hresult;
}

//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_Properties
//=--------------------------------------------------------------------------=
// Gets qinfo's properties collection
//
// Parameters:
//    ppcolProperties - [out] qinfo's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQQueueInfo::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}

//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_Security
//=--------------------------------------------------------------------------=
// Gets security property
//
// Parameters:
//    pvarSecurity - [out] pointer to security property
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQQueueInfo::get_Security(VARIANT FAR* /*pvarSecurity*/ )
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}

//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::put_Security
//=--------------------------------------------------------------------------=
// Sets security property
//
// Parameters:
//    varSecurity - [in] security property
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQQueueInfo::put_Security(VARIANT /*varSecurity*/)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}

//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::get_MulticastAddress
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pbstrMulticastAddress  [in] this queue's multicast address
//
// Output:
//    HRESULT       - S_OK
//
// Notes:
//
HRESULT CMSMQQueueInfo::get_MulticastAddress(BSTR *pbstrMulticastAddress)
{ 
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    InitProps(e_MSMQ2_OR_ABOVE_PROP);
    //
    // Copy our member variable and return ownership of
    //  the copy to the caller.
    //
    *pbstrMulticastAddress = SYSALLOCSTRING(m_bstrMulticastAddress);
	if(*pbstrMulticastAddress == NULL)
		return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
#ifdef _DEBUG
    RemBstrNode(*pbstrMulticastAddress);
#endif // _DEBUG
    return NOERROR;
}

//=--------------------------------------------------------------------------=
// CMSMQQueueInfo::put_MulticastAddress
//=--------------------------------------------------------------------------=
//
// Parameters:
//    bstrMulticastAddress   [in] this queue's multicast address
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
HRESULT CMSMQQueueInfo::put_MulticastAddress(BSTR bstrMulticastAddress)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    BSTR bstrMulticastAddressTmp;
    bstrMulticastAddressTmp = SYSALLOCSTRING(bstrMulticastAddress);
	if(bstrMulticastAddressTmp == NULL)
		return CreateErrorHelper(ResultFromScode(E_OUTOFMEMORY), x_ObjectType);
    SysFreeString(m_bstrMulticastAddress);
    m_bstrMulticastAddress = bstrMulticastAddressTmp;
    m_fIsDirtyMulticastAddress = TRUE; //explicitly set by the user
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\qinfo.h ===
//=--------------------------------------------------------------------------=
// MSMQQueueInfoObj.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQQueueInfo object.
//
//
#ifndef _MSMQQueueInfo_H_

#include "resrc1.h"       // main symbols
#include "dispids.h"
#include "mq.h"

#include "oautil.h"
#include "cs.h"

//
// Version of a property (MSMQ1 or MSMQ2(or above))
// Temporary until MQLocateBegin accepts MSMQ2 or above props(#3839)
//
enum enumPropVersion
{
    e_MSMQ1_PROP,
    e_MSMQ2_OR_ABOVE_PROP
};

class ATL_NO_VTABLE CMSMQQueueInfo : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQQueueInfo, &CLSID_MSMQQueueInfo>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQQueueInfo3, &IID_IMSMQQueueInfo3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQQueueInfo();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQQUEUEINFO)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQQueueInfo)
	COM_INTERFACE_ENTRY(IMSMQQueueInfo3)
	COM_INTERFACE_ENTRY_IID(IID_IMSMQQueueInfo2, IMSMQQueueInfo3) //return IMSMQQueueInfo3 for IMSMQQueueInfo2
	COM_INTERFACE_ENTRY_IID(IID_IMSMQQueueInfo, IMSMQQueueInfo3) //return IMSMQQueueInfo3 for IMSMQQueueInfo
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQQueueInfo
public:

    virtual ~CMSMQQueueInfo();

    // IMSMQQueueInfo methods
    // TODO: copy over the interface methods for IMSMQQueueInfo from
    //       mqInterfaces.H here.
    STDMETHOD(get_QueueGuid)(THIS_ BSTR FAR* pbstrGuidQueue);
    STDMETHOD(get_ServiceTypeGuid)(THIS_ BSTR FAR* pbstrGuidServiceType);
    STDMETHOD(put_ServiceTypeGuid)(THIS_ BSTR bstrGuidServiceType);
    STDMETHOD(get_Label)(THIS_ BSTR FAR* pbstrLabel);
    STDMETHOD(put_Label)(THIS_ BSTR bstrLabel);
    STDMETHOD(get_PathName)(THIS_ BSTR FAR* pbstrPathName);
    STDMETHOD(put_PathName)(THIS_ BSTR bstrPathName);
    STDMETHOD(get_FormatName)(THIS_ BSTR FAR* pbstrFormatName);
    STDMETHOD(put_FormatName)(THIS_ BSTR bstrFormatName);
    STDMETHOD(get_IsTransactional)(THIS_ VARIANT_BOOL FAR* pisTransactional);
    STDMETHOD(get_PrivLevel)(THIS_ long FAR* plPrivLevel);
    STDMETHOD(put_PrivLevel)(THIS_ long lPrivLevel);
    STDMETHOD(get_Journal)(THIS_ long FAR* plJournal);
    STDMETHOD(put_Journal)(THIS_ long lJournal);
    STDMETHOD(get_Quota)(THIS_ long FAR* plQuota);
    STDMETHOD(put_Quota)(THIS_ long lQuota);
    STDMETHOD(get_BasePriority)(THIS_ long FAR* plBasePriority);
    STDMETHOD(put_BasePriority)(THIS_ long lBasePriority);
    STDMETHOD(get_CreateTime)(THIS_ VARIANT FAR* pvarCreateTime);
    STDMETHOD(get_ModifyTime)(THIS_ VARIANT FAR* pvarModifyTime);
    STDMETHOD(get_Authenticate)(THIS_ long FAR* plAuthenticate);
    STDMETHOD(put_Authenticate)(THIS_ long lAuthenticate);
    STDMETHOD(get_JournalQuota)(THIS_ long FAR* plJournalQuota);
    STDMETHOD(put_JournalQuota)(THIS_ long lJournalQuota);
    STDMETHOD(get_IsWorldReadable)(THIS_ VARIANT_BOOL FAR* pisWorldReadable);
    STDMETHOD(Create)(THIS_ VARIANT FAR* isTransactional, VARIANT FAR* IsWorldReadable);
    STDMETHOD(Delete)(THIS);
    STDMETHOD(Open)(THIS_ long lAccess, long lShareMode, IMSMQQueue3 FAR* FAR* ppq);
    STDMETHOD(Refresh)(THIS);
    STDMETHOD(Update)(THIS);
    //
    // IMSMQQueueInfo2 methods (in addition to IMSMQQueueInfo)
    //
    STDMETHOD(get_PathNameDNS)(THIS_ BSTR FAR* pbstrPathNameDNS);
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);
    STDMETHOD(get_Security)(THIS_ VARIANT FAR* pvarSecurity);
    STDMETHOD(put_Security)(THIS_ VARIANT varSecurity);
    //
    // IMSMQQueueInfo3 methods (in addition to IMSMQQueueInfo2)
    //
    STDMETHOD(get_ADsPath)(THIS_ BSTR FAR* pbstrADsPath);
    STDMETHOD(get_IsTransactional2)(THIS_ VARIANT_BOOL FAR* pisTransactional);
    STDMETHOD(get_IsWorldReadable2)(THIS_ VARIANT_BOOL FAR* pisWorldReadable);
    STDMETHOD(get_MulticastAddress)(THIS_ BSTR *pbstrMulticastAddress);
    STDMETHOD(put_MulticastAddress)(THIS_ BSTR bstrMulticastAddress);
    //
    // introduced methods
    //
    HRESULT Init(LPCWSTR pwszFormatName);
    HRESULT SetQueueProps(ULONG cProps,
                          QUEUEPROPID *rgpropid,
                          MQPROPVARIANT *rgpropvar,
                          BOOL fEmptyMSMQ2OrAboveProps);
    void SetRefreshed(BOOL fIsPendingMSMQ2OrAboveProps);
    //
    // Critical section to guard object's data and be thread safe
	// It is initialized to preallocate its resources 
	// with flag CCriticalSection::xAllocateSpinCount. This means it may throw bad_alloc() on 
	// construction but not during usage.
    //
    CCriticalSection m_csObj;

protected:
    HRESULT CreateQueueProps(
      BOOL fUpdate,
      UINT cPropMax, 
      MQQUEUEPROPS *pqueueprops, 
      BOOL isTransactional,
      const PROPID rgpropid[]);
    static void FreeQueueProps(MQQUEUEPROPS *pqueueprops);
    HRESULT UpdateFormatName();
    HRESULT PutServiceType(
        BSTR bstrGuidServiceType,
        GUID *pguidServiceType); 
    HRESULT PutLabel(
        BSTR bstrLabel,
        BSTR *pbstrLabel); 
    HRESULT PutPathName(
        BSTR bstrPathName,
        BSTR *pbstrPathName); 
    HRESULT PutFormatName(
        LPCWSTR pwszFormatName); 
    HRESULT PutPrivLevel(
        long lPrivLevel,
        long *plPrivLevel);
    HRESULT PutJournal(
        long lJournal, 
        long *plJournal);
    HRESULT PutQuota(long lQuota, long *plQuota);
    HRESULT PutBasePriority(
        long lBasePriority, 
        long *plBasePriority);
    HRESULT PutAuthenticate(
        long lAuthenticate, 
        long *plAuthenticate);
    HRESULT InitProps(enumPropVersion ePropVersion);
    HRESULT RefreshMSMQ2OrAboveProps();
    HRESULT GetQueueProperties(const PROPID *pPropIDs,
                               const ULONG * pulFallbackProps,
                               ULONG cFallbacks,
                               MQQUEUEPROPS * pqueueprops);
    HRESULT GetIsWorldReadable(BOOL *pisWorldReadable);

private:

    GUID *m_pguidQueue;
    GUID *m_pguidServiceType;
    BSTR m_bstrLabel;
    BSTR m_bstrPathNameDNS;     // 3703
    BSTR m_bstrADsPath;
    BSTR m_bstrFormatName;
    BOOL m_isValidFormatName;   // 2026
    BSTR m_bstrPathName;
    BOOL m_isTransactional;
    long m_lPrivLevel;
    long m_lJournal;
    long m_lQuota;
    long m_lBasePriority;
    long m_lCreateTime;
    long m_lModifyTime;
    long m_lAuthenticate;
    long m_lJournalQuota;
    BOOL m_isRefreshed;         // 2536
    //
    // We have a lazy update for MSMQ2 or above props.
    // Temporary until MQLocateBegin accepts MSMQ2 or above props(#3839)
    //
    BOOL m_isPendingMSMQ2OrAboveProps;
    BSTR m_bstrMulticastAddress;
    //
    // m_fIsDirtyMulticastAddress is TRUE iff MulticastAddress for a qinfo was explicitly set
    // by the user. It is FALSE for a new qinfo or after Refresh.
    // If TRUE it is used in Create/Update, otherwise not used.
    //
    BOOL m_fIsDirtyMulticastAddress;
    BOOL m_fBasePriorityNotSet;
};

extern const PROPID g_rgpropidRefresh[];
extern const ULONG x_cpropsRefreshMSMQ;
extern const ULONG x_cpropsRefreshMSMQ1;
extern const ULONG x_cpropsRefreshMSMQ2;
extern const ULONG x_cpropsRefreshMSMQ3;
extern const ULONG x_idxInstanceInRefreshProps;

#define _MSMQQueueInfo_H_
#endif // _MSMQQueueInfo_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\resrc1.h ===
#include "mqoares.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#pragma warning(disable:4786)
// warning C4786: identifier was truncated to '255' characters in the debug information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CFD4DCC9_8DB7_11D2_B0F2_00E02C074F6B__INCLUDED_)
#define AFX_STDAFX_H__CFD4DCC9_8DB7_11D2_B0F2_00E02C074F6B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//#define STRICT


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#define _ATL_APARTMENT_THREADED

//
// Redefine ATLASSERT
// Default ATLASSERT brings CrtDbgReport from msvcrtd.dll which is not distributable
//
#define _ATL_NO_DEBUG_CRT
#include "debug.h"
#define ATLASSERT(expr) ASSERT(expr)

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
#include <mqwin64a.h>

#endif // !defined(AFX_STDAFX_H__CFD4DCC9_8DB7_11D2_B0F2_00E02C074F6B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\query.h ===
//=--------------------------------------------------------------------------=
// MSMQQueryObj.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQQuery object.
//
//
#ifndef _MQQUERY_H_

#include "resrc1.h"       // main symbols

#include "oautil.h"
//#include "cs.h"
#include "qinfos.h"

class ATL_NO_VTABLE CMSMQQuery : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQQuery, &CLSID_MSMQQuery>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQQuery3, &IID_IMSMQQuery3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQQuery()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQQUERY)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQQuery)
	COM_INTERFACE_ENTRY(IMSMQQuery3)
	COM_INTERFACE_ENTRY_IID(IID_IMSMQQuery2, IMSMQQuery3) //return IMSMQQuery3 for IMSMQQuery2
	COM_INTERFACE_ENTRY_IID(IID_IMSMQQuery, IMSMQQuery3) //return IMSMQQuery3 for IMSMQQuery
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQQuery
public:
    virtual ~CMSMQQuery();

    // IMSMQQuery methods
    // TODO: copy over the interface methods for IMSMQQuery from
    //       mqInterfaces.H here.
    STDMETHOD(LookupQueue_v2)(THIS_ VARIANT *strGuidQueue, 
                           VARIANT *strGuidServiceType, 
                           VARIANT *strLabel, 
                           VARIANT *dateCreateTime, 
                           VARIANT *dateModifyTime, 
                           VARIANT *relServiceType, 
                           VARIANT *relLabel, 
                           VARIANT *relCreateTime, 
                           VARIANT *relModifyTime, 
                           IMSMQQueueInfos3 **pqinfos);
    // IMSMQQuery2 additional members
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);
    // IMSMQQuery3 additional members
    STDMETHOD(LookupQueue)(THIS_ VARIANT *strGuidQueue, 
                           VARIANT *strGuidServiceType, 
                           VARIANT *strLabel, 
                           VARIANT *dateCreateTime, 
                           VARIANT *dateModifyTime, 
                           VARIANT *relServiceType, 
                           VARIANT *relLabel, 
                           VARIANT *relCreateTime, 
                           VARIANT *relModifyTime, 
                           VARIANT *strMulticastAddress, 
                           VARIANT *relMulticastAddress, 
                           IMSMQQueueInfos3 **pqinfos);
    // introduced publics
    static void FreeColumnSet(MQCOLUMNSET *pColumnSet);
    static void FreeRestriction(MQRESTRICTION *pRestriction);
    //
    // Critical section to guard object's data and be thread safe
    //
    // Serialization not needed for this object, no per-instance members.
    // CCriticalSection m_csObj;
    //
protected:
    static HRESULT CreateRestriction(
      VARIANT *pstrGuidQueue, 
      VARIANT *pstrGuidServiceType, 
      VARIANT *pstrLabel, 
      VARIANT *pdateCreateTime,
      VARIANT *pdateModifyTime,
      VARIANT *prelServiceType, 
      VARIANT *prelLabel, 
      VARIANT *prelCreateTime,
      VARIANT *prelModifyTime,
      VARIANT *pstrMulticastAddress, 
      VARIANT *prelMulticastAddress, 
      MQRESTRICTION *prestriction,
      MQCOLUMNSET *pcolumnset);
    
    HRESULT InternalLookupQueue(
                           VARIANT *strGuidQueue, 
                           VARIANT *strGuidServiceType, 
                           VARIANT *strLabel, 
                           VARIANT *dateCreateTime, 
                           VARIANT *dateModifyTime, 
                           VARIANT *relServiceType, 
                           VARIANT *relLabel, 
                           VARIANT *relCreateTime, 
                           VARIANT *relModifyTime, 
                           VARIANT *strMulticastAddress, 
                           VARIANT *relMulticastAddress, 
                           IMSMQQueueInfos3 **pqinfos);

private:
    // member variables that nobody else gets to look at.
    // TODO: add your member variables and private functions here.
    //
};

#define _MQQUERY_H_
#endif // _MQQUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\qinfos.h ===
//=--------------------------------------------------------------------------=
// MSMQQueueInfosObj.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQQueueInfos object.
//
//
#ifndef _MSMQQueueInfoS_H_

#include "resrc1.h"       // main symbols

#include "oautil.h"
#include "cs.h"
#include "dispids.h"
#include "mq.h"
class ATL_NO_VTABLE CMSMQQueueInfos : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQQueueInfos, &CLSID_MSMQQueueInfos>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQQueueInfos3, &IID_IMSMQQueueInfos3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQQueueInfos();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQQUEUEINFOS)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQQueueInfos)
	COM_INTERFACE_ENTRY(IMSMQQueueInfos3)
	COM_INTERFACE_ENTRY_IID(IID_IMSMQQueueInfos2, IMSMQQueueInfos3) //return IMSMQQueueInfos3 for IMSMQQueueInfos2
	COM_INTERFACE_ENTRY_IID(IID_IMSMQQueueInfos, IMSMQQueueInfos3) //return IMSMQQueueInfos3 for IMSMQQueueInfos
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQQueueInfos
public:
    virtual ~CMSMQQueueInfos();

    // IMSMQQueueInfos methods
    // TODO: copy over the interface methods for IMSMQQueueInfos from
    //       mqInterfaces.H here.
    STDMETHOD(Reset)(THIS);
    STDMETHOD(Next)(THIS_ IMSMQQueueInfo3 **ppqinfoNext);
    // IMSMQQueueInfos2 additional members
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);

    // introduced methods...
    HRESULT Init(
      BSTR bstrContext,
      MQRESTRICTION *pRestriction,
      MQCOLUMNSET *pColumns,
      MQSORTSET *pSort);

    //
    // Critical section to guard object's data and be thread safe
	// It is initialized to preallocate its resources 
	// with flag CCriticalSection::xAllocateSpinCount. This means it may throw bad_alloc() on 
	// construction but not during usage.
    //
    CCriticalSection m_csObj;

  protected:

  private:
    // member variables that nobody else gets to look at.
    // TODO: add your member variables and private functions here.
    HANDLE m_hEnum;
    BSTR m_bstrContext;
    MQRESTRICTION *m_pRestriction;
    MQCOLUMNSET *m_pColumns;
    MQSORTSET *m_pSort;
    BOOL m_fInitialized;
};


#define _MSMQQueueInfoS_H_
#endif // _MSMQQueueInfoS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\query.cpp ===
//=--------------------------------------------------------------------------=
// MSMQQueryObj.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQQuery object
//
//
#include "stdafx.h"
#include "Query.H"

#include "limits.h"   // for UINT_MAX
#include "mq.h"
#include "oautil.h"
#include "qinfo.h"

const MsmqObjType x_ObjectType = eMSMQQuery;

// debug...
#include "debug.h"
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#endif // _DEBUG


// Helper: PrOfRel:
//  Map RELOPS enumerator to PR enumerator.
//
UINT PrOfRel(RELOPS rel)
{
    UINT uPr = UINT_MAX;

    // UNDONE: must as well be a hard-wired array...

    switch (rel) {
    case REL_NOP:
      // maps to default
      break;
    case REL_EQ:
      uPr = PREQ;
      break;
    case REL_NEQ:
      uPr = PRNE;
      break;
    case REL_LT:
      uPr = PRLT;
      break;
    case REL_GT:
      uPr = PRGT;
      break;
    case REL_LE:
      uPr = PRLE;
      break;
    case REL_GE:
      uPr = PRGE;
      break;
    default:
      ASSERTMSG(0, "bad enumerator.");
      break;
    } // switch
    return uPr;
}


// Helper: PrOfVariant
//  Maps VARIANT to PR enumerator.
//  Returns UINT_MAX if out of bounds or illegal.
//
UINT PrOfVar(VARIANT *pvarRel)
{
    UINT uPr = UINT_MAX;
    HRESULT hresult;

    // ensure we can coerce rel to UINT.
    hresult = VariantChangeType(pvarRel, 
                                pvarRel, 
                                0, 
                                VT_I4);
    if (SUCCEEDED(hresult)) {
      uPr = PrOfRel((RELOPS)pvarRel->lVal);
    }
    return uPr; // == UINT_MAX ? PREQ : uPr;
}


//=--------------------------------------------------------------------------=
// CMSMQQuery::~CMSMQQuery
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//
CMSMQQuery::~CMSMQQuery ()
{
    // TODO: clean up anything here.
    // delete m_pguidServiceType;
    // delete m_pguidQueue;
    // SysFreeString(m_bstrLabel);
} 

//=--------------------------------------------------------------------------=
// CMSMQQuery::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQQuery::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQQuery3,
		&IID_IMSMQQuery2,
		&IID_IMSMQQuery,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


// helper: If this a valid non-NOP implicit or explicit REL?
static BOOL IsValidRel(VARIANT *prel)
{
    // we return TRUE only if:
    //  a REL is supplied and it's not REL_NOP
    //   or a REL isn't supplied at all
    //  
    return ((prel->vt != VT_ERROR) && (PrOfVar(prel) != UINT_MAX)) ||
            (prel->vt == VT_ERROR);
}


//=--------------------------------------------------------------------------=
// static CMSMQQuery::CreateRestriction
//=--------------------------------------------------------------------------=
//  Creates a restriction for MQLocateBegin.
//  NOTE: the hungarian lies here -- all params are formally
//   VARIANTs but we use their real underlying typetag.
//
// Parameters:
// [IN] pstrGuidQueue 
// [IN] pstrGuidServiceType 
// [IN] pstrLabel 
// [IN] pdateCreateTime
// [IN] pdateModifyTime
// [IN] prelServiceType 
// [IN] prelLabel 
// [IN] prelCreateTime
// [IN] prelModifyTime
// [IN] pstrMulticastAddress
// [IN] prelMulticastAddress
// [OUT] prestriction
// [OUT] pcolumnset
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CMSMQQuery::CreateRestriction(
    VARIANT *pstrGuidQueue, 
    VARIANT *pstrGuidServiceType, 
    VARIANT *pstrLabel, 
    VARIANT *pdateCreateTime,
    VARIANT *pdateModifyTime,
    VARIANT *prelServiceType, 
    VARIANT *prelLabel, 
    VARIANT *prelCreateTime,
    VARIANT *prelModifyTime,
    VARIANT *pstrMulticastAddress, 
    VARIANT *prelMulticastAddress, 
    MQRESTRICTION *prestriction,
    MQCOLUMNSET *pcolumnset)
{
    UINT cRestriction = 0, iProp, cCol, uPr;
    MQPROPERTYRESTRICTION *rgPropertyRestriction = NULL;
    BSTR bstrTemp = NULL;
    time_t tTime;
    CLSID *pguidQueue = NULL;
    CLSID *pguidServiceType = NULL;
    HRESULT hresult = NOERROR;

    IfNullRet(pguidQueue = new GUID(GUID_NULL));
    IfNullFail(pguidServiceType = new GUID(GUID_NULL));

    // Count optional params
    if (pstrGuidQueue->vt != VT_ERROR) {
      cRestriction++;
    }
    if (pstrGuidServiceType->vt != VT_ERROR) {

      // ignore if rel is NOP:
      if (IsValidRel(prelServiceType)) {
        cRestriction++;
      }
    }
    if (pstrLabel->vt != VT_ERROR) {

      // ignore if rel is NOP:
      if (IsValidRel(prelLabel)) {
        cRestriction++;
      }
    }
    if (pdateCreateTime->vt != VT_ERROR) {

      // ignore if rel is NOP:
      if (IsValidRel(prelCreateTime)) {
        cRestriction++;
      }
    }
    if (pdateModifyTime->vt != VT_ERROR) {

      // ignore if rel is NOP:
      if (IsValidRel(prelModifyTime)) {
        cRestriction++;
      }
    }
    if (pstrMulticastAddress->vt != VT_ERROR) {

      // ignore if rel is NOP:
      if (IsValidRel(prelMulticastAddress)) {
        cRestriction++;
      }
    }
    
	IfNullFail(rgPropertyRestriction = new MQPROPERTYRESTRICTION[cRestriction]);
    //
    // zero out the restriction array incase we get an error while populating it
    //
    ZeroMemory(rgPropertyRestriction, cRestriction * sizeof(MQPROPERTYRESTRICTION));
    //
    // setup OUT param
    //
    prestriction->cRes = cRestriction;
    prestriction->paPropRes = rgPropertyRestriction;

    // populate...
    iProp = 0;
    if (pstrGuidQueue->vt != VT_ERROR) {
      rgPropertyRestriction[iProp].prval.vt = VT_ERROR;
      if ((bstrTemp = GetBstr(pstrGuidQueue)) == NULL) {
        IfFailRet(hresult = E_INVALIDARG);
      }
      IfFailGo(CLSIDFromString(bstrTemp, pguidQueue));
      IfNullFail(rgPropertyRestriction[iProp].prval.puuid = 
        new CLSID(*pguidQueue));
      rgPropertyRestriction[iProp].rel = PREQ;
      rgPropertyRestriction[iProp].prop = PROPID_Q_INSTANCE;
      rgPropertyRestriction[iProp].prval.vt = VT_CLSID;
      iProp++;
    }
    if (pstrGuidServiceType->vt != VT_ERROR) {
      rgPropertyRestriction[iProp].prval.vt = VT_ERROR;
      if ((bstrTemp = GetBstr(pstrGuidServiceType)) == NULL) {
        IfFailGo(hresult = E_INVALIDARG);
      }
      if (IsValidRel(prelServiceType)) {
        IfFailGo(CLSIDFromString(bstrTemp, pguidServiceType));
        IfNullFail(rgPropertyRestriction[iProp].prval.puuid = 
          new CLSID(*pguidServiceType));
        uPr = PrOfVar(prelServiceType);
        rgPropertyRestriction[iProp].rel = 
          uPr == UINT_MAX ? PREQ : uPr;
        rgPropertyRestriction[iProp].prop = PROPID_Q_TYPE;
        rgPropertyRestriction[iProp].prval.vt = VT_CLSID;
        iProp++;
      }
    }
    if (pstrLabel->vt != VT_ERROR) {
      rgPropertyRestriction[iProp].prval.vt = VT_ERROR;
      if (IsValidRel(prelLabel)) {
        if ((bstrTemp = GetBstr(pstrLabel)) == NULL) {
          // NULL label interpreted as empty string
          //  so don't do anything here... we'll convert
          //  it to an explicit empty string below...
          //
        }
        UINT cch;
        // SysFreeString(m_bstrLabel);
        // IfNullFail(m_bstrLabel = SYSALLOCSTRING(bstrTemp));
        IfNullFail(rgPropertyRestriction[iProp].prval.pwszVal =
          new WCHAR[(cch = SysStringLen(bstrTemp)) + 1]);
        wcsncpy(rgPropertyRestriction[iProp].prval.pwszVal, 
                bstrTemp,
                cch);
        // null terminate
        rgPropertyRestriction[iProp].prval.pwszVal[cch] = 0;
        uPr = PrOfVar(prelLabel);
        rgPropertyRestriction[iProp].prop = PROPID_Q_LABEL;
        rgPropertyRestriction[iProp].prval.vt = VT_LPWSTR;
        rgPropertyRestriction[iProp].rel = 
          uPr == UINT_MAX ? PREQ : uPr;
        iProp++;
      }
    }
    if (pdateCreateTime->vt != VT_ERROR) {
      rgPropertyRestriction[iProp].prval.vt = VT_ERROR;
      if (IsValidRel(prelCreateTime)) {
        if (!VariantTimeToTime(pdateCreateTime, &tTime)) {
          IfFailGo(hresult = E_INVALIDARG);
        }
        rgPropertyRestriction[iProp].prop = PROPID_Q_CREATE_TIME;
        rgPropertyRestriction[iProp].prval.vt = VT_I4;
        rgPropertyRestriction[iProp].prval.lVal = INT_PTR_TO_INT(tTime); //BUGBUG bug year 2038
        uPr = PrOfVar(prelCreateTime);
        rgPropertyRestriction[iProp].rel = 
          uPr == UINT_MAX ? PREQ : uPr;
        iProp++;
      }
    }
    if (pdateModifyTime->vt != VT_ERROR) {
      rgPropertyRestriction[iProp].prval.vt = VT_ERROR;
      if (IsValidRel(prelModifyTime)) {
        if (!VariantTimeToTime(pdateModifyTime, &tTime)) {
          IfFailGo(hresult = E_INVALIDARG);
        }
        rgPropertyRestriction[iProp].prop = PROPID_Q_MODIFY_TIME;
        rgPropertyRestriction[iProp].prval.vt = VT_I4;
        rgPropertyRestriction[iProp].prval.lVal = INT_PTR_TO_INT(tTime); //BUGBUG bug year 2038
        uPr = PrOfVar(prelModifyTime);
        rgPropertyRestriction[iProp].rel = 
          uPr == UINT_MAX ? PREQ : uPr;
        iProp++;
      }
    }
    if (pstrMulticastAddress->vt != VT_ERROR) {
      rgPropertyRestriction[iProp].prval.vt = VT_ERROR;
      if (IsValidRel(prelMulticastAddress)) {
        bstrTemp = GetBstr(pstrMulticastAddress);
        //
        // NULL MulticastAddress is interpreted as an empty string, and both use VT_EMPTY
        //
        BOOL fUseVtEmpty;
        fUseVtEmpty = TRUE;
        if (bstrTemp != NULL) {
          if (SysStringLen(bstrTemp) != 0) {
            //
            // we have a real multicast address
            //
            fUseVtEmpty = FALSE;
          }
        }
        if (fUseVtEmpty) {
          rgPropertyRestriction[iProp].prval.vt = VT_EMPTY;
        }
        else {
          UINT cch;
          IfNullFail(rgPropertyRestriction[iProp].prval.pwszVal =
            new WCHAR[(cch = SysStringLen(bstrTemp)) + 1]);
          wcsncpy(rgPropertyRestriction[iProp].prval.pwszVal, 
                  bstrTemp,
                  cch);
          // null terminate
          rgPropertyRestriction[iProp].prval.pwszVal[cch] = 0;
          rgPropertyRestriction[iProp].prval.vt = VT_LPWSTR;
        }
        uPr = PrOfVar(prelMulticastAddress);
        rgPropertyRestriction[iProp].prop = PROPID_Q_MULTICAST_ADDRESS;
        rgPropertyRestriction[iProp].rel = 
          uPr == UINT_MAX ? PREQ : uPr;
        iProp++;
      }
    }
    //    
    // Column set
    //
    // We request all the information we can get on the queue.
    //
    // However currently MQLocateBegin doesn't accept MSMQ 2.0 or above props so we only specify
    // MSMQ 1.0 props in LocateBegin.
    // Temporary until MQLocateBegin accepts MSMQ2 or above props(#3839)
    //
    // MSMQ 1.0 props are the first props in g_rgpropidRefresh array (which contains all props)
    //
    cCol = x_cpropsRefreshMSMQ1;
    IfNullFail(pcolumnset->aCol = new PROPID[cCol]);
    pcolumnset->cCol = cCol;
    memcpy(pcolumnset->aCol, g_rgpropidRefresh, sizeof(PROPID)*cCol);
    // fall through...

Error:
    delete pguidQueue;
    delete pguidServiceType;
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQQuery::InternalLookupQueue
//=--------------------------------------------------------------------------=
//
// Parameters:
// [IN] strGuidQueue 
// [IN] strGuidServiceType 
// [IN] strLabel 
// [IN] dateCreateTime
// [IN] dateModifyTime
// [IN] relServiceType 
// [IN] relLabel 
// [IN] relCreateTime
// [IN] relModifyTime
// [IN] strMulticastAddress
// [IN] relMulticastAddress
// [OUT] ppqinfos
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CMSMQQuery::InternalLookupQueue(
    VARIANT *strGuidQueue, 
    VARIANT *strGuidServiceType, 
    VARIANT *strLabel, 
    VARIANT *dateCreateTime, 
    VARIANT *dateModifyTime, 
    VARIANT *relServiceType, 
    VARIANT *relLabel, 
    VARIANT *relCreateTime, 
    VARIANT *relModifyTime, 
    VARIANT *strMulticastAddress, 
    VARIANT *relMulticastAddress, 
    IMSMQQueueInfos3 **ppqinfos)
{
    MQRESTRICTION *prestriction;
    MQCOLUMNSET *pcolumnset;
    IMSMQQueueInfos3 *pqinfos = NULL;
    CComObject<CMSMQQueueInfos> * pqinfosObj;
    HRESULT hresult = NOERROR;

    *ppqinfos = NULL;
    IfNullRet(prestriction = new MQRESTRICTION);
    IfNullFail(pcolumnset = new MQCOLUMNSET);
    //
    // We can also get here from old apps that want the old IMSMQQueueInfos/Infos2 back, but since
    // IMSMQQueueInfos3 is binary backwards compatible we can always return the new interface
    //
    IfFailGo(CNewMsmqObj<CMSMQQueueInfos>::NewObj(&pqinfosObj, &IID_IMSMQQueueInfos3, (IUnknown **)&pqinfos));
    //
    // important for cleanup to work
    //
    pcolumnset->aCol = NULL;
    prestriction->paPropRes = NULL;
    prestriction->cRes = 0;
    IfFailGoTo(CreateRestriction(strGuidQueue, 
                                 strGuidServiceType, 
                                 strLabel, 
                                 dateCreateTime,
                                 dateModifyTime,
                                 relServiceType, 
                                 relLabel, 
                                 relCreateTime,
                                 relModifyTime,
                                 strMulticastAddress, 
                                 relMulticastAddress, 
                                 prestriction,
                                 pcolumnset),
      Error2);
    //
    // prestriction, pcolumnset ownership transfers
    //
    IfFailGoTo(pqinfosObj->Init(NULL,    // context
                             prestriction,
                             pcolumnset,
                             NULL),   // sort
      Error2);
    *ppqinfos = pqinfos;
    //
    // fall through...
    //
Error2:
    if (FAILED(hresult)) {
      FreeRestriction(prestriction);
      FreeColumnSet(pcolumnset);
    }
    //
    // fall through...
    //
Error:
    if (FAILED(hresult)) {
      RELEASE(pqinfos);
      delete prestriction;
      delete pcolumnset;
    }
    return hresult;
}


//=--------------------------------------------------------------------------=
// CMSMQQuery::LookupQueue_v2
//=--------------------------------------------------------------------------=
//
// Parameters:
// [IN] strGuidQueue 
// [IN] strGuidServiceType 
// [IN] strLabel 
// [IN] dateCreateTime
// [IN] dateModifyTime
// [IN] relServiceType 
// [IN] relLabel 
// [IN] relCreateTime
// [IN] relModifyTime
// [OUT] ppqinfos
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CMSMQQuery::LookupQueue_v2(
    VARIANT *strGuidQueue, 
    VARIANT *strGuidServiceType, 
    VARIANT *strLabel, 
    VARIANT *dateCreateTime, 
    VARIANT *dateModifyTime, 
    VARIANT *relServiceType, 
    VARIANT *relLabel, 
    VARIANT *relCreateTime, 
    VARIANT *relModifyTime, 
    IMSMQQueueInfos3 **ppqinfos)
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    VARIANT varMissing;
    varMissing.vt = VT_ERROR;
    HRESULT hresult = InternalLookupQueue(
                          strGuidQueue, 
                          strGuidServiceType, 
                          strLabel,
                          dateCreateTime,
                          dateModifyTime,
                          relServiceType,
                          relLabel,
                          relCreateTime,
                          relModifyTime,
                          &varMissing, /*pstrMulticastAddress*/
                          &varMissing, /*prelMulticastAddress*/
                          ppqinfos);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQQuery::LookupQueue
//=--------------------------------------------------------------------------=
//
// Parameters:
// [IN] strGuidQueue 
// [IN] strGuidServiceType 
// [IN] strLabel 
// [IN] dateCreateTime
// [IN] dateModifyTime
// [IN] relServiceType 
// [IN] relLabel 
// [IN] relCreateTime
// [IN] relModifyTime
// [IN] strMulticastAddress
// [IN] relMulticastAddress
// [OUT] ppqinfos
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CMSMQQuery::LookupQueue(
    VARIANT *strGuidQueue, 
    VARIANT *strGuidServiceType, 
    VARIANT *strLabel, 
    VARIANT *dateCreateTime, 
    VARIANT *dateModifyTime, 
    VARIANT *relServiceType, 
    VARIANT *relLabel, 
    VARIANT *relCreateTime, 
    VARIANT *relModifyTime, 
    VARIANT *strMulticastAddress, 
    VARIANT *relMulticastAddress, 
    IMSMQQueueInfos3 **ppqinfos)
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    HRESULT hresult = InternalLookupQueue(
                          strGuidQueue, 
                          strGuidServiceType, 
                          strLabel,
                          dateCreateTime,
                          dateModifyTime,
                          relServiceType,
                          relLabel,
                          relCreateTime,
                          relModifyTime,
                          strMulticastAddress, 
                          relMulticastAddress, 
                          ppqinfos);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// static CMSMQQuery::FreeRestriction
//=--------------------------------------------------------------------------=
// Frees dynamic memory allocated on behalf of an 
//  MQRESTRICTION struct.  
//
// Parameters:
//  prestriction
//
// Output:
//
// Notes:
//
void CMSMQQuery::FreeRestriction(MQRESTRICTION *prestriction)
{
    MQPROPERTYRESTRICTION *rgPropertyRestriction;
    UINT cRestriction, iProp;
    PROPID prop;

    if (prestriction) {
      cRestriction = prestriction->cRes;
      rgPropertyRestriction = prestriction->paPropRes;
      for (iProp = 0; iProp < cRestriction; iProp++) {
        prop = rgPropertyRestriction[iProp].prop;
        switch (prop) {
        case PROPID_Q_INSTANCE:
        case PROPID_Q_TYPE:
          delete [] rgPropertyRestriction[iProp].prval.puuid;
          break;
        case PROPID_Q_LABEL:
          delete [] rgPropertyRestriction[iProp].prval.pwszVal;
          break;
        case PROPID_Q_MULTICAST_ADDRESS:
          //
          // can also be VT_EMPTY, so check for VT_LPWSTR
          //
          if (rgPropertyRestriction[iProp].prval.vt == VT_LPWSTR) {
            delete [] rgPropertyRestriction[iProp].prval.pwszVal;
          }
          break;
        } // switch
      } // for
      delete [] rgPropertyRestriction;
      prestriction->paPropRes = NULL;
    }
}


//=--------------------------------------------------------------------------=
// static CMSMQQuery::FreeColumnSet
//=--------------------------------------------------------------------------=
// Frees dynamic memory allocated on behalf of an 
//  MQCOLUMNSET struct.  
//
// Parameters:
//  pcolumnset
//
// Output:
//
// Notes:
//
void CMSMQQuery::FreeColumnSet(MQCOLUMNSET *pcolumnset)
{
    if (pcolumnset) {
      delete [] pcolumnset->aCol;
      pcolumnset->aCol = NULL;
    }
}


//=-------------------------------------------------------------------------=
// CMSMQQuery::get_Properties
//=-------------------------------------------------------------------------=
// Gets object's properties collection
//
// Parameters:
//    ppcolProperties - [out] object's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQQuery::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\xact.cpp ===
//=--------------------------------------------------------------------------=
// xact.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQTransaction object
//
//
#include "stdafx.h"
#include "dispids.h"

#include "txdtc.h"             // transaction support.
#include "oautil.h"
#include "xact.h"
#include <limits.h>
#include <autoptr.h>

// forwards
struct ITransaction;

const MsmqObjType x_ObjectType = eMSMQTransaction;

// debug...
#include "debug.h"
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#endif // _DEBUG



//=--------------------------------------------------------------------------=
// CMSMQTransaction::CMSMQTransaction
//=--------------------------------------------------------------------------=
// create the object
//
// Parameters:
//
// Notes:
//
CMSMQTransaction::CMSMQTransaction() :
	m_csObj(CCriticalSection::xAllocateSpinCount)
{

    // TODO: initialize anything here
    m_pUnkMarshaler = NULL; // ATL's Free Threaded Marshaler
    m_pptransaction = NULL;
}


//=--------------------------------------------------------------------------=
// CMSMQTransaction::~CMSMQTransaction
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//
CMSMQTransaction::~CMSMQTransaction ()
{
    // TODO: clean up anything here.
    if (m_pptransaction)
      delete m_pptransaction;
}


//=--------------------------------------------------------------------------=
// CMSMQTransaction::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQTransaction::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQTransaction3,
		&IID_IMSMQTransaction2,
		&IID_IMSMQTransaction,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//=--------------------------------------------------------------------------=
// CMSMQTransaction::Init
//=--------------------------------------------------------------------------=
//    initializer
//
// Parameters:
//    ptransaction  [in]  ownership transfers
//    fUseGIT       [in]  whether to use GIT marshaling or direct ptrs between apts
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQTransaction::Init(ITransaction *ptransaction, BOOL fUseGIT)
{
    HRESULT hresult;
    P< CBaseGITInterface > pGITInterface;
    //
    // allocate either CGITInterface for real GIT marshaling or CFakeGITInterface
    // for direct ptr (e.g. no marshalling between apts)
    //
    if (fUseGIT)
    {
      pGITInterface = new CGITInterface;
    }
    else
    {
      pGITInterface = new CFakeGITInterface;
    }
    //
    // return if allocation failed
    //
    IfNullRet((CBaseGITInterface *)pGITInterface);
    //
    // register the given interface
    //
    IfFailRet(pGITInterface->Register(ptransaction, &IID_ITransaction));
    //
    // ownership transfer of CBaseGITInterface to m_pptransaction
    //
    ASSERTMSG(m_pptransaction == NULL, "m_pptransaction not empty in Init");
    m_pptransaction = pGITInterface.detach();
    return NOERROR;
}


//=--------------------------------------------------------------------------=
// CMSMQTransaction::get_Transaction
//=--------------------------------------------------------------------------=
//    Returns underlying ITransaction* "magic cookie"
//
// Parameters:
//    plTranscation [out]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQTransaction::get_Transaction(
    long *plTransaction)
{
#ifdef _WIN64
    //
    // WIN64
    // we can't return a transaction ptr as long in win64
    //
    UNREFERENCED_PARAMETER(plTransaction);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);    
#else //!_WIN64
    //
    // WIN32
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = NOERROR;
    if (m_pptransaction != NULL)
    {
      ITransaction * pTransaction;
      hresult = m_pptransaction->GetWithDefault(&IID_ITransaction, (IUnknown **)&pTransaction, NULL);
      if (SUCCEEDED(hresult))
      {
        *plTransaction = (long)pTransaction;
        //
        // we didn't addref it previously, so we remove the AddRef from GetWithDefault
        //
        RELEASE(pTransaction);
      }
    }
    else
    {
      *plTransaction = 0;
    }
    return CreateErrorHelper(hresult, x_ObjectType);
#endif //_WIN64
}

//=--------------------------------------------------------------------------=
// CMSMQTransaction::Commit
//=--------------------------------------------------------------------------=
//    Commit a transaction
//
// Parameters:
//    fRetaining    [optional]
//    grfTC         [optional]
//    grfRM         [optional]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQTransaction::Commit(
    VARIANT *pvarFRetaining, 
    VARIANT *pvarGrfTC, 
    VARIANT *pvarGrfRM)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    BOOL fRetaining = FALSE;
    long grfTC = 0;
    long grfRM = 0;
    HRESULT hresult = NOERROR;

    if (m_pptransaction == NULL) {
      return E_INVALIDARG;
    }
    R<ITransaction> pTransaction;
    hresult = m_pptransaction->GetWithDefault(&IID_ITransaction, (IUnknown **)&pTransaction.ref(), NULL);
	if(FAILED(hresult))
		return CreateErrorHelper(hresult, x_ObjectType);
    if (pTransaction.get() == NULL)
    {
      return E_INVALIDARG;
    }
    
    //
    // process optional args
    //
    if (V_VT(pvarFRetaining) != VT_ERROR) {
      fRetaining = GetBool(pvarFRetaining);
    }
    if (V_VT(pvarGrfTC) != VT_ERROR) {
      grfTC = GetNumber(pvarGrfTC, UINT_MAX);
    }
    if (V_VT(pvarGrfRM) != VT_ERROR) {
      grfRM = GetNumber(pvarGrfRM, UINT_MAX);
    }
    hresult = pTransaction->Commit(fRetaining, grfTC, grfRM);
    
    // 1790: we don't want to lose the specific DTC error
    //  number.
    //
#if 0
    //
    // map all errors to generic xact error
    //
    if (FAILED(hresult)) {
      hresult = MQ_ERROR_TRANSACTION_USAGE;
    }
#endif // 0
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// CMSMQTransaction::Abort
//=--------------------------------------------------------------------------=
//    Commit a transaction
//
// Parameters:
//    fRetaining  [optional]
//    fAsync      [optional]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CMSMQTransaction::Abort(
    VARIANT *pvarFRetaining, 
    VARIANT *pvarFAsync)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    BOOL fRetaining = FALSE;
    BOOL fAsync = 0;
    HRESULT hresult = NOERROR;

    //
    // process optional args
    //
    if (V_VT(pvarFRetaining) != VT_ERROR) {
      fRetaining = GetBool(pvarFRetaining);
    }
    if (V_VT(pvarFAsync) != VT_ERROR) {
      fAsync = GetBool(pvarFAsync);
    }
    if (m_pptransaction == NULL) {
      return E_INVALIDARG;
    }
    R<ITransaction> pTransaction;
    hresult = m_pptransaction->GetWithDefault(&IID_ITransaction, (IUnknown **)&pTransaction.ref(), NULL);
	if(FAILED(hresult))
		return CreateErrorHelper(hresult, x_ObjectType);
    if (pTransaction.get() == NULL)
    {
      return E_INVALIDARG;
    }

    hresult = pTransaction->Abort(NULL, fRetaining, fAsync);

    // 1790: we don't want to lose the specific DTC error
    //  number.
    //
#if 0
    //
    // map all errors to generic xact error
    //
    if (FAILED(hresult)) {
      hresult = MQ_ERROR_TRANSACTION_USAGE;
    }
#endif // 0
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=--------------------------------------------------------------------------=
// HELPER: GetXactFromVar
//=--------------------------------------------------------------------------=
// Get ITransaction * from a variant
//
// Input:
//    varTransaction   [in]  ITransaction variant
//    ppTransaction    [out] Returned ITransaction interface
//
// Notes:
//
static HRESULT GetXactFromVar(
    const VARIANT * pvarTransaction,
    ITransaction ** ppTransaction)
{
    HRESULT hresult = NOERROR;
    ITransaction * pTransaction = NULL;
    //
    // Get ITransaction interface from variant (also validate variant in try-except)
    //
    IUnknown * punkTrans = NULL;
    __try {
      //
      // Get IUnknown interface
      //
      switch(pvarTransaction->vt) {
      case VT_UNKNOWN:
        punkTrans = pvarTransaction->punkVal;
        break;
      case VT_UNKNOWN | VT_BYREF:
        punkTrans = *pvarTransaction->ppunkVal;
        break;
      case VT_DISPATCH:
        punkTrans = pvarTransaction->pdispVal;
        break;
      case VT_DISPATCH | VT_BYREF:
        punkTrans = *pvarTransaction->ppdispVal;
        break;
      case VT_INTPTR:
        punkTrans = (IUnknown *) V_INTPTR(pvarTransaction);
        break;
      case VT_INTPTR | VT_BYREF:
        punkTrans = (IUnknown *) (*(V_INTPTR_REF(pvarTransaction)));
        break;
      default:
        hresult = E_INVALIDARG;
        break;
      }
      //
      // QI for ITransaction
      //
      if (SUCCEEDED(hresult)) {
        hresult = punkTrans->QueryInterface(IID_ITransaction, (void **)&pTransaction);
      }
    } //__try
    __except (EXCEPTION_EXECUTE_HANDLER) {
      hresult = E_INVALIDARG;      
    }
    //
    // return results
    //
    if (SUCCEEDED(hresult)) {
        *ppTransaction = pTransaction;
    }
    else {
        RELEASE(pTransaction);
    }
    return hresult;
}

//=--------------------------------------------------------------------------=
// CMSMQTransaction::InitNew
//=--------------------------------------------------------------------------=
// Attaches to an existing transaction
//
// Input:
//    varTransaction   [in]  ITransaction interface
//
// Notes:
// #3478 RaananH
//
HRESULT CMSMQTransaction::InitNew(
    VARIANT varTransaction)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    ITransaction * pTransaction = NULL;
    HRESULT hresult;

    //
    // we can't attach if this transaction is already inited
    // BUGBUG we might release the old transaction, but then we'd better
    // use put_Transaction (e.g. assigning to the Transaction property)
    // instead of Attach
    // BUGBUG ERRORCODE we may need a better error code here
    //
    if (m_pptransaction != NULL) {
      return CreateErrorHelper(MQ_ERROR_TRANSACTION_USAGE, x_ObjectType);
    }

    //
    // Get ITransaction interface from variant (also validate variant in try-except)
    //
    IfFailGo(GetXactFromVar(&varTransaction, &pTransaction));

    //
    // we have a valid ITransaction, lets init the transaction with it
    //
    // Since we don't know the origin of this transaction interface, we can't guarantee
    // that this transaction interface doesn't need marshaling between apartments,
    // and since we are not marshalled between apartments (FTM) we therefore force it to
    // use GIT marshaling (and not direct pointers)
    //
    IfFailGo(Init(pTransaction, TRUE /*fUseGIT*/));
    hresult = NOERROR;
    // fall through...
      
Error:
    RELEASE(pTransaction);
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQTransaction::get_Properties
//=-------------------------------------------------------------------------=
// Gets object's properties collection
//
// Parameters:
//    ppcolProperties - [out] object's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQTransaction::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQTransaction::get_ITransaction
//=-------------------------------------------------------------------------=
// Gets object's ITransaction interface as a variant (VT_UNKNOWN)
//
// Parameters:
//    pvarITransaction - [out] object's ITransaction interface
//
// Output:
//
// Notes:
// ITransaction replaces the Transaction property - on win64 Transaction doesn't work
// since it is defined as long, but the value returned should be a pointer.
// It is returned as a variant and not IUnknown so VBS could use it as well
//
HRESULT CMSMQTransaction::get_ITransaction(VARIANT *pvarITransaction)
{
    //
    // Serialize access to object from interface methods
    //
    CS lock(m_csObj);
    HRESULT hresult = NOERROR;
    if (m_pptransaction != NULL)
    {
      ITransaction * pTransaction;
      hresult = m_pptransaction->GetWithDefault(&IID_ITransaction, (IUnknown **)&pTransaction, NULL);
      if (SUCCEEDED(hresult))
      {
        if (pTransaction)
        {
          //
          // pTransaction is already ADDREF'ed
          //
          pvarITransaction->vt = VT_UNKNOWN;
          pvarITransaction->punkVal = pTransaction;
        }
        else //pTransaction == NULL
        {
          //
          // return empty variant
          //
          pvarITransaction->vt = VT_EMPTY;
        }
      } //SUCCEEDED(hresult)
    }
    else //m_pptransaction == NULL
    {
      //
      // return empty variant
      //
      pvarITransaction->vt = VT_EMPTY;
    }
    return CreateErrorHelper(hresult, x_ObjectType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\xact.h ===
//=--------------------------------------------------------------------------=
// xact.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// the MSMQTransaction object.
//
//
#ifndef _MSMQTransaction_H_

#include "resrc1.h"       // main symbols
#include "mq.h"

#include "oautil.h"
#include "cs.h"

// forwards
class CMSMQTransaction;
struct ITransaction;

class ATL_NO_VTABLE CMSMQTransaction : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQTransaction, &CLSID_MSMQTransaction>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQTransaction3, &IID_IMSMQTransaction3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQTransaction();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQTRANSACTION)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQTransaction)
	COM_INTERFACE_ENTRY(IMSMQTransaction3)
	COM_INTERFACE_ENTRY(IMSMQTransaction2)
	COM_INTERFACE_ENTRY(IMSMQTransaction)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQTransaction
public:
    virtual ~CMSMQTransaction();

    // IMSMQTransaction methods
    // TODO: copy over the interface methods for IMSMQTransaction from
    //       mqInterfaces.H here.
    STDMETHOD(get_Transaction)(THIS_ long FAR* plTransaction);
    STDMETHOD(Commit)(THIS_ VARIANT *fRetaining, VARIANT *grfTC, VARIANT *grfRM);
    STDMETHOD(Abort)(THIS_ VARIANT *fRetaining, VARIANT *fAsync);

    // IMSMQTransaction2 methods (in addition to IMSMQTransaction)
    //
    STDMETHOD(InitNew)(THIS_ VARIANT varTransaction);
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);

    // IMSMQTransaction3 methods (in addition to IMSMQTransaction2)
    //
    STDMETHOD(get_ITransaction)(THIS_ VARIANT FAR* pvarITransaction);

    // introduced methods
    HRESULT Init(ITransaction *ptransaction, BOOL fUseGIT);
    //
    // Critical section to guard object's data and be thread safe
	// It is initialized to preallocate its resources 
	// with flag CCriticalSection::xAllocateSpinCount. This means it may throw bad_alloc() on 
	// construction but not during usage.
    //
    CCriticalSection m_csObj;

protected:

private:
    // member variables that nobody else gets to look at.
    // TODO: add your member variables and private functions here.
    //
    // We are Both-threaded and aggregate the FTM, thererfore we must marshal any interface
    // pointer we store between method calls
    // m_pptransaction can either be our object (if dispensed by MSMQ) - for which we use the
    // Fake GIT wrapper, or it can be dispensed by DTC, or set by the user using InitNew - in this case
    // we store it in GIT        
    //
    CBaseGITInterface * m_pptransaction;
};


#define _MSMQTransaction_H_
#endif // _MSMQTransaction_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\xdisper.cpp ===
//=--------------------------------------------------------------------------=
// xdisper.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// MSMQTransactionDispenser object
//
//
#include "stdafx.h"
#include "dispids.h"
#include "oautil.h"
#include "xact.h"
#include "xdisper.h"

const MsmqObjType x_ObjectType = eMSMQTransactionDispenser;

// debug...
#include "debug.h"
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#endif // _DEBUG


//=--------------------------------------------------------------------------=
// CMSMQTransactionDispenser::~CMSMQTransactionDispenser
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//
CMSMQTransactionDispenser::~CMSMQTransactionDispenser ()
{
    // TODO: clean up anything here.

}


//=--------------------------------------------------------------------------=
// CMSMQTransactionDispenser::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQTransactionDispenser::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQTransactionDispenser3,
		&IID_IMSMQTransactionDispenser2,
		&IID_IMSMQTransactionDispenser,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//=--------------------------------------------------------------------------=
// CMSMQTransactionDispenser::BeginTransaction
//=--------------------------------------------------------------------------=
// Obtains and begins a transaction
//
// Output:
//    pptransaction  [out] where they want the transaction
//
// Notes:
//
HRESULT CMSMQTransactionDispenser::BeginTransaction(
    IMSMQTransaction3 **ppmqtransaction)
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    ITransaction *ptransaction = NULL;
    IMSMQTransaction3 *pmqtransaction = NULL;
    CComObject<CMSMQTransaction> * pmqtransactionObj;
    IUnknown *punkDtc = NULL;
    HRESULT hresult = NOERROR;

    if (ppmqtransaction == NULL) {
		return CreateErrorHelper(E_INVALIDARG, x_ObjectType);
    }
    *ppmqtransaction = NULL;                      // pessimism
    IfFailGo(MQBeginTransaction(&ptransaction));
    //
    // We can also get here from old apps that want the old IMSMQTransaction/IMSMQTransaction2 back, but since
    // IMSMQTransaction3 is binary backwards compatible we can always return the new interface
    //
    IfFailGo(CNewMsmqObj<CMSMQTransaction>::NewObj(&pmqtransactionObj, &IID_IMSMQTransaction3, (IUnknown **)&pmqtransaction));
    
    // ptransaction ownership transfers...
    //
    // This transaction is implemented by MSMQ, and we know that it doesn't need marshaling
    // between apartments. The culprit is that its implementation doesn't aggragate the FTM,
    // so GIT marshalling would be expensive. Since we can count on that it doesn't need
    // marshaling we allow it not to use GIT marshaling, and just use direct pointers
    //
    IfFailGo(pmqtransactionObj->Init(ptransaction, FALSE /*fUseGIT*/));
    *ppmqtransaction = pmqtransaction;
    ADDREF(*ppmqtransaction);
    // fall through...
      
Error:
    RELEASE(ptransaction);
    RELEASE(pmqtransaction);
    RELEASE(punkDtc);
    //
    // map all errors to generic xact error
    //
    if (FAILED(hresult)) {
      hresult = MQ_ERROR_TRANSACTION_USAGE;
    }
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQTransactionDispenser::get_Properties
//=-------------------------------------------------------------------------=
// Gets object's properties collection
//
// Parameters:
//    ppcolProperties - [out] objects's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQTransactionDispenser::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\xdisper.h ===
//=--------------------------------------------------------------------------=
// xdisper.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// MSMQTransactionDispenser object.
//
//
#ifndef _MSMQTransactionDispenser_H_

#include "resrc1.h"       // main symbols
#include "mq.h"

#include "oautil.h"
//#include "cs.h"

// forwards
class CMSMQTransactionDispenser;
class ATL_NO_VTABLE CMSMQTransactionDispenser : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQTransactionDispenser, &CLSID_MSMQTransactionDispenser>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQTransactionDispenser3, &IID_IMSMQTransactionDispenser3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQTransactionDispenser()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQTRANSACTIONDISPENSER)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQTransactionDispenser)
	COM_INTERFACE_ENTRY(IMSMQTransactionDispenser3)
	// return IMSMQTransactionDispenser3 for IMSMQTransactionDispenser2
	COM_INTERFACE_ENTRY_IID(IID_IMSMQTransactionDispenser2, IMSMQTransactionDispenser3)
	// return IMSMQTransactionDispenser3 for IMSMQTransactionDispenser
	COM_INTERFACE_ENTRY_IID(IID_IMSMQTransactionDispenser, IMSMQTransactionDispenser3)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQTransactionDispenser
public:
    virtual ~CMSMQTransactionDispenser();

    // IMSMQTransactionDispenser methods
    // TODO: copy over the interface methods for IMSMQTransactionDispenser from
    //       mqInterfaces.H here.
    STDMETHOD(BeginTransaction)(THIS_ IMSMQTransaction3 FAR* FAR* ptransaction);
    // IMSMQTransactionDispenser2 additional members
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);
    //
    // Critical section to guard object's data and be thread safe
    //
    // Serialization not needed for this object, no per-instance members.
    // CCriticalSection m_csObj;
    //
protected:

private:
    // member variables that nobody else gets to look at.
    // TODO: add your member variables and private functions here.
    //
};


#define _MSMQTransactionDispenser_H_
#endif // _MSMQTransactionDispenser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\xdispdtc.cpp ===
//=--------------------------------------------------------------------------=
// xdispdtc.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
//  MSMQCoordinatedTransactionDispenser
//
//
#include "stdafx.h"
#include "dispids.h"

#include "txdtc.h"             // transaction support.
#include "oautil.h"
#include "xact.h"
#include "xdispdtc.h"

// forwards
struct ITransactionDispenser;

const MsmqObjType x_ObjectType = eMSMQCoordinatedTransactionDispenser;

// debug...
#include "debug.h"
#define new DEBUG_NEW
#ifdef _DEBUG
#define SysAllocString DebSysAllocString
#define SysReAllocString DebSysReAllocString
#define SysFreeString DebSysFreeString
#endif // _DEBUG



// global: TransactionDispenser Dispenser DTC's interface
ITransactionDispenser *CMSMQCoordinatedTransactionDispenser::m_ptxdispenser = NULL;
// HINSTANCE CMSMQCoordinatedTransactionDispenser::m_hLibDtc = NULL;
// HINSTANCE CMSMQCoordinatedTransactionDispenser::m_hLibUtil = NULL;

//#2619 RaananH Multithread async receive
CCriticalSection g_csGetDtcDispenser(CCriticalSection::xAllocateSpinCount);

//
//  TransactionDispenser stuff
//

// UNDONE: copied from mqutil
//  Really should be able to link with mqutil.lib
//   but need to solve include file wars.
//
// Because we are compiling in UNICODE, here is a problem with DTC...
//#include	<xolehlp.h>
//
extern HRESULT DtcGetTransactionManager(
    LPSTR pszHost,
    LPSTR pszTmName,
    REFIID rid,
    DWORD dwReserved1,
    WORD wcbReserved2,
    void FAR * pvReserved2,
    void** ppvObject);

//
//  TransactionDispenser stuff
//  NOTE: we dynload this from core Falcon
//
// extern HRESULT XactGetDTC(IUnknown **ppunkDtc);


// 
// defer to mqrt
//
EXTERN_C
HRESULT
APIENTRY
RTXactGetDTC(
    IUnknown **ppunkDTC
    );


/*====================================================

GetDtc
    Gets the IUnknown pointer to the MS DTC
Arguments:
    OUT IUnknown *ppunkDtc
Returns:
    HR
=====================================================*/

static HRESULT GetDtc(IUnknown **ppunkDtc)
{
    return RTXactGetDTC(ppunkDtc);
}


//=--------------------------------------------------------------------------=
// CMSMQCoordinatedTransactionDispenser::~CMSMQCoordinatedTransactionDispenser
//=--------------------------------------------------------------------------=
// "We all labour against our own cure, for death is the cure of all diseases"
//    - Sir Thomas Browne (1605 - 82)
//
// Notes:
//
CMSMQCoordinatedTransactionDispenser::~CMSMQCoordinatedTransactionDispenser ()
{
    // TODO: clean up anything here.

}


//=--------------------------------------------------------------------------=
// CMSMQCoordinatedTransactionDispenser::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CMSMQCoordinatedTransactionDispenser::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQCoordinatedTransactionDispenser3,
		&IID_IMSMQCoordinatedTransactionDispenser2,
		&IID_IMSMQCoordinatedTransactionDispenser,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//=--------------------------------------------------------------------------=
// CMSMQCoordinatedTransactionDispenser::BeginTransaction
//=--------------------------------------------------------------------------=
// Obtains and begins a transaction
//
// Output:
//    pptransaction  [out] where they want the transaction
//
// Notes:
//#2619 RaananH Multithread async receive
//
HRESULT CMSMQCoordinatedTransactionDispenser::BeginTransaction(
    IMSMQTransaction3 **ppmqtransaction)
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    ITransaction *ptransaction = NULL;
    IMSMQTransaction3 *pmqtransaction = NULL;
    CComObject<CMSMQTransaction> * pmqtransactionObj;
    IUnknown *punkDtc = NULL;
    HRESULT hresult = NOERROR;

    if (ppmqtransaction == NULL) {
		return CreateErrorHelper(E_INVALIDARG, x_ObjectType);
    }
    *ppmqtransaction = NULL;                      // pessimism
    //
    // no deadlock - no one that locks g_csGetDtcDispenser tries to lock us from inside its lock
    //
    {
		CS lock(g_csGetDtcDispenser); //#2619

		if (m_ptxdispenser == NULL) {
		  IfFailGo(GetDtc(&punkDtc));           // dynload
		  IfFailGo(punkDtc->QueryInterface(
					IID_ITransactionDispenser, 
					(LPVOID *)&m_ptxdispenser));
		}
	}

    ASSERTMSG(m_ptxdispenser, "should have a transaction manager.");
    IfFailGo(m_ptxdispenser->BeginTransaction(
              NULL,                             // punkOuter,
              ISOLATIONLEVEL_ISOLATED,          // ISOLEVEL isoLevel,
              ISOFLAG_RETAIN_DONTCARE,          // ULONG isoFlags,
              NULL,                             // ITransactionOptions *pOptions
              &ptransaction));    
    //
    // We can also get here from old apps that want the old IMSMQTransaction/IMSMQTransaction2 back, but since
    // IMSMQTransaction3 is binary backwards compatible we can always return the new interface
    //
    IfFailGo(CNewMsmqObj<CMSMQTransaction>::NewObj(&pmqtransactionObj, &IID_IMSMQTransaction3, (IUnknown **)&pmqtransaction));
    
    // ptransaction ownership transfers...
    //
    // Since we can't guarantee that this transaction interface doesn't need marshaling
    // between apartments, and since we are not marshalled between apartments (FTM)
    // we therefore force it to use GIT marshaling (and not direct pointers)
    //
    IfFailGo(pmqtransactionObj->Init(ptransaction, TRUE /*fUseGIT*/));
    *ppmqtransaction = pmqtransaction;
    ADDREF(*ppmqtransaction);
    // fall through...
      
Error:
    RELEASE(ptransaction);
    RELEASE(pmqtransaction);
    RELEASE(punkDtc);
    //
    // map all errors to generic xact error
    //
    if (FAILED(hresult)) {
      hresult = MQ_ERROR_TRANSACTION_USAGE;
    }
    return CreateErrorHelper(hresult, x_ObjectType);
}


//=-------------------------------------------------------------------------=
// CMSMQCoordinatedTransactionDispenser::get_Properties
//=-------------------------------------------------------------------------=
// Gets object's properties collection
//
// Parameters:
//    ppcolProperties - [out] objects's properties collection
//
// Output:
//
// Notes:
// Stub - not implemented yet
//
HRESULT CMSMQCoordinatedTransactionDispenser::get_Properties(IDispatch ** /*ppcolProperties*/ )
{
    //
    // Serialize access to object from interface methods
    //
    // Serialization not needed for this object, no per-instance members.
    // CS lock(m_csObj);
    //
    return CreateErrorHelper(E_NOTIMPL, x_ObjectType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\activex\mqoa\xdispdtc.h ===
//=--------------------------------------------------------------------------=
// xdisper.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
//  MSMQCoordinatedTransactionDispenser
//
//
#ifndef _MSMQCoordinatedTransactionDispenser_H_

#include "resrc1.h"       // main symbols
#include "mq.h"

#include "oautil.h"
//#include "cs.h"

// forwards
class CMSMQCoordinatedTransactionDispenser;
struct ITransactionDispenser;

class ATL_NO_VTABLE CMSMQCoordinatedTransactionDispenser : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQCoordinatedTransactionDispenser, &CLSID_MSMQCoordinatedTransactionDispenser>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQCoordinatedTransactionDispenser3, &IID_IMSMQCoordinatedTransactionDispenser3,
                             &LIBID_MSMQ, MSMQ_LIB_VER_MAJOR, MSMQ_LIB_VER_MINOR>
{
public:
	CMSMQCoordinatedTransactionDispenser()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MSMQCOORDINATEDTRANSACTIONDISPENSER)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CMSMQCoordinatedTransactionDispenser)
	COM_INTERFACE_ENTRY(IMSMQCoordinatedTransactionDispenser3)
	// return IMSMQCoordinatedTransactionDispenser3 for IMSMQCoordinatedTransactionDispenser2
	COM_INTERFACE_ENTRY_IID(IID_IMSMQCoordinatedTransactionDispenser2, IMSMQCoordinatedTransactionDispenser3)
	// return IMSMQCoordinatedTransactionDispenser3 for IMSMQCoordinatedTransactionDispenser
	COM_INTERFACE_ENTRY_IID(IID_IMSMQCoordinatedTransactionDispenser, IMSMQCoordinatedTransactionDispenser3)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSMQCoordinatedTransactionDispenser
public:
    virtual ~CMSMQCoordinatedTransactionDispenser();

    // IMSMQCoordinatedTransactionDispenser methods
    // TODO: copy over the interface methods for IMSMQCoordinatedTransactionDispenser from
    //       mqInterfaces.H here.
    STDMETHOD(BeginTransaction)(THIS_ IMSMQTransaction3 FAR* FAR* ptransaction);
    // IMSMQCoordinatedTransactionDispenser2 additional members
    STDMETHOD(get_Properties)(THIS_ IDispatch FAR* FAR* ppcolProperties);

    static ITransactionDispenser *m_ptxdispenser;
    // static HINSTANCE m_hLibDtc;
    // static HINSTANCE m_hLibUtil;
    //
    // Critical section to guard object's data and be thread safe
    //
    // Serialization not needed for this object, no per-instance members.
    // CCriticalSection m_csObj;
    //
protected:

private:
    // member variables that nobody else gets to look at.
    // TODO: add your member variables and private functions here.
    //
};

#define _MSMQCoordinatedTransactionDispenser_H_
#endif // _MSMQCoordinatedTransactionDispenser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\admmsg.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

   admmsg.cpp

Abstract:

   Implementations of utilities used for Admin messages

Author:

    RaphiR


--*/
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "globals.h"
#include "resource.h"
#include "mqprops.h"
#include "mqutil.h"
#include "_mqdef.h"
#include "mqformat.h"
#include "privque.h"
#include "rt.h"
#include "admcomnd.h"
#include "admmsg.h"
#include "mqcast.h"

#include <strsafe.h>

#include "admmsg.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAX_WAIT_FOR_RESPONSE 45        //seconds

//////////////////////////////////////////////////////////////////////////////
/*++

SendMSMQMessage

--*/
//////////////////////////////////////////////////////////////////////////////
static HRESULT SendMSMQMessage(LPCTSTR pcszTargetQueue,
                        LPCTSTR pcszLabel,
                        LPCTSTR pcszBody,
                        DWORD   dwBodySize,
                        LPCWSTR lpwcsResponseQueue = 0,   
                        DWORD   dwTimeOut = MAX_WAIT_FOR_RESPONSE
                        )
{
    HRESULT       hr;
    PROPVARIANT   aPropVar[5];
    PROPID        aPropID[5];
    MQMSGPROPS    msgprops;
    QUEUEHANDLE   hQueue;
    UINT          iNextProperty = 0;

    BOOL fResponseExist = (0 != lpwcsResponseQueue);
    DWORD cProp = fResponseExist ? 5 : 4;

    //
    // Open the target queue with send permission
    //
    hr = MQOpenQueue(pcszTargetQueue, MQ_SEND_ACCESS, 0, &hQueue);

    if (FAILED(hr))
    {
        ATLTRACE(_T("SendMSMQMessage : Can't open queue for sending messages\n"));
        return hr;
    }

    //
    // Set Label Property
    //
    aPropID[iNextProperty] = PROPID_M_LABEL;
    aPropVar[iNextProperty].vt = VT_LPWSTR;
    aPropVar[iNextProperty++].pwszVal = (LPWSTR)pcszLabel;

    //
    // Set Body Property
    //
    aPropID[iNextProperty] = PROPID_M_BODY;
    aPropVar[iNextProperty].vt = VT_UI1|VT_VECTOR;
    aPropVar[iNextProperty].caub.cElems = dwBodySize;
    aPropVar[iNextProperty++].caub.pElems = (UCHAR*)(LPWSTR)pcszBody;

    //
    // Set Arrive time-out
    //
    aPropID[iNextProperty] = PROPID_M_TIME_TO_REACH_QUEUE;
    aPropVar[iNextProperty].vt = VT_UI4;
    aPropVar[iNextProperty++].ulVal = dwTimeOut;

    //
    // Set Receive time-out
    //
    aPropID[iNextProperty] = PROPID_M_TIME_TO_BE_RECEIVED;
    aPropVar[iNextProperty].vt = VT_UI4;
    aPropVar[iNextProperty++].ulVal = dwTimeOut;

    ASSERT(iNextProperty == 4);

    if (fResponseExist)
    {
        //
        // Set Response Queue Property
        //
        aPropID[iNextProperty] = PROPID_M_RESP_QUEUE;
        aPropVar[iNextProperty].vt = VT_LPWSTR;
        aPropVar[iNextProperty++].pwszVal = (LPWSTR)lpwcsResponseQueue;
    }

    //
    // prepare the message properties to send
    //
    msgprops.cProp = cProp;
    msgprops.aPropID = aPropID;
    msgprops.aPropVar = aPropVar;
    msgprops.aStatus  = NULL;


    //
    // Send the message and close the queue
    //
    hr = MQSendMessage(hQueue, &msgprops, NULL);

    MQCloseQueue(hQueue);

    return (hr);

}
//+-----------------------------
//
//   GetDacl()
//   Gets a security descriptor with "premissions to everyone"
//
//+-----------------------------
static HRESULT GetDacl(SECURITY_DESCRIPTOR **ppSecurityDescriptor)
{
    SECURITY_DESCRIPTOR sd;
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

	PSID pEveryoneSid = MQSec_GetWorldSid();
	PSID pAnonymousSid = MQSec_GetAnonymousSid();

    //
    // Calculate the required DACL size and allocate it.
    //
    DWORD dwAclSize = sizeof(ACL) +
						 2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
						 GetLengthSid(pEveryoneSid) + 
						 GetLengthSid(pAnonymousSid);

    P<ACL> pDacl = (PACL) new BYTE[dwAclSize];

    BOOL bRet = InitializeAcl(pDacl, dwAclSize, ACL_REVISION);
    if (!bRet)
    {
        DWORD gle = GetLastError();
        TRACE(_T("%s, line %d: InitializeAcl failed. Error %d\n"), THIS_FILE, __LINE__, gle);
        return HRESULT_FROM_WIN32(gle);
    }

    bRet = AddAccessAllowedAce(
				pDacl,
				ACL_REVISION,
				MQSEC_QUEUE_GENERIC_ALL,
				pEveryoneSid
				);

    if (!bRet)
    {
        DWORD gle = GetLastError();
        TRACE(_T("%s, line %d: AddAccessAllowedAce failed. Error %d\n"), THIS_FILE, __LINE__, gle);
        return HRESULT_FROM_WIN32(gle);
    }

    bRet = AddAccessAllowedAce(
					pDacl,
					ACL_REVISION,
					MQSEC_WRITE_MESSAGE,
					pAnonymousSid
					);

    if (!bRet)
    {
        DWORD gle = GetLastError();
        TRACE(_T("%s, line %d: AddAccessAllowedAce failed. Error %d\n"), THIS_FILE, __LINE__, gle);
        return HRESULT_FROM_WIN32(gle);
    }

    bRet =  SetSecurityDescriptorDacl(&sd, TRUE, pDacl, TRUE);
    if (!bRet)
    {
        DWORD gle = GetLastError();
        TRACE(_T("%s, line %d: SetSecurityDescriptorDacl failed. Error %d\n"), THIS_FILE, __LINE__, gle);
        return HRESULT_FROM_WIN32(gle);
    }

    DWORD dwLen = 0;
    bRet = MakeSelfRelativeSD(&sd, NULL, &dwLen);
    if (!bRet)
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            *ppSecurityDescriptor = (SECURITY_DESCRIPTOR*) new BYTE[dwLen];
            bRet = MakeSelfRelativeSD(&sd, *ppSecurityDescriptor, &dwLen);
        }

        if (!bRet)
        {
            DWORD gle = GetLastError();
            TRACE(_T("%s, line %d: MakeSelfRelativeSD failed. Error %d\n"), THIS_FILE, __LINE__, gle);
            return HRESULT_FROM_WIN32(gle);
        }
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CreatePrivateResponseQueue

--*/
//////////////////////////////////////////////////////////////////////////////
static HRESULT CreatePrivateResponseQueue(LPWSTR pFormatName)
{
    HRESULT hr;
    MQQUEUEPROPS QueueProps;
    PROPVARIANT Var;
    PROPID      Propid = PROPID_Q_PATHNAME;
    CString     strQueueName;
    DWORD dwFormatNameLen = MAX_QUEUE_FORMATNAME;

    //
    // Create a private queue
    //
    strQueueName = L".\\PRIVATE$\\";
    strQueueName += x_strAdminResponseQName;

    Var.vt = VT_LPWSTR;
    Var.pwszVal = (LPTSTR)(LPCTSTR)strQueueName;

    QueueProps.cProp = 1;
    QueueProps.aPropID = &Propid;
    QueueProps.aPropVar = &Var;
    QueueProps.aStatus = NULL;

    hr = MQCreateQueue(NULL, &QueueProps, pFormatName, &dwFormatNameLen);

    ASSERT( hr != MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL);

    if (hr == MQ_ERROR_QUEUE_EXISTS)
    {
       hr = MQPathNameToFormatName( strQueueName,
                                    pFormatName,
                                    &dwFormatNameLen ) ;
       if (FAILED(hr))
       {
          ATLTRACE(_T("CreatePrivateResponseQueue Open- Couldn't get FormatName\n"));
       }
       return hr;
    }

    if FAILED(hr)
    {
        return hr;
    }

    //
    // Sets full permission to everyone.
    // This is usefull in case the queue is somehow not deleted,
    // and another user is trying to run the admin (bug 3549, yoela, 12-Nov-98).
	// Set MQSEC_WRITE_MESSAGE for anonymous. otherwise the response messages
	// will be rejected.
    //
    P<SECURITY_DESCRIPTOR> pSecurityDescriptor;
    hr = GetDacl(&pSecurityDescriptor);
    if FAILED(hr)
    {
        MQDeleteQueue(pFormatName);
        ASSERT(0);
        return hr;
    }

    ASSERT(pSecurityDescriptor != 0);
    hr = MQSetQueueSecurity(pFormatName, DACL_SECURITY_INFORMATION, 
                            pSecurityDescriptor);

    if FAILED(hr)
    {
        MQDeleteQueue(pFormatName);
        ASSERT(0);
    }
    return(hr);
}

//////////////////////////////////////////////////////////////////////////////
/*++

WaitForAdminResponse

  Always allocate memory for the response buffer.
  Must be freed by the caller.

--*/
//////////////////////////////////////////////////////////////////////////////
static HRESULT WaitForAdminResponse(QUEUEHANDLE hQ, DWORD dwTimeout, UCHAR* *ppBodyBuffer, DWORD* pdwBufSize)
{

    UCHAR*  pBody;
    DWORD   dwNewSize, dwBodySize;
    HRESULT hr = MQ_OK;

    MQMSGPROPS msgprops;
    MSGPROPID amsgpid[2];
    PROPVARIANT apvar[2];

    msgprops.cProp = 2;
    msgprops.aPropID = amsgpid;
    msgprops.aPropVar = apvar;
    msgprops.aStatus = NULL;

    pBody = NULL;
    dwNewSize = 3000;

    do
    {
        delete[] pBody;

        dwBodySize = dwNewSize;
        pBody = new UCHAR[dwBodySize];

        msgprops.aPropID[0] = PROPID_M_BODY;
        msgprops.aPropVar[0].vt = VT_UI1 | VT_VECTOR;
        msgprops.aPropVar[0].caub.pElems = pBody;
        msgprops.aPropVar[0].caub.cElems = dwBodySize;

        msgprops.aPropID[1] = PROPID_M_BODY_SIZE;
        msgprops.aPropVar[1].vt = VT_UI4;
        msgprops.aPropVar[1].ulVal = VT_UI4;

        hr = MQReceiveMessage(hQ, dwTimeout, MQ_ACTION_RECEIVE, &msgprops,
                              0,NULL,0, NULL);

        dwNewSize = msgprops.aPropVar[1].ulVal;

    } while(MQ_ERROR_BUFFER_OVERFLOW == hr);

    if(FAILED(hr))
    {
        TrTRACE(GENERAL, "Error while reading admin resp message: 0x%x", hr);
		delete[] pBody;
        return(hr);
    }

    *pdwBufSize = dwNewSize;
    *ppBodyBuffer = pBody;
    return hr;

}

//////////////////////////////////////////////////////////////////////////////
/*++

GetAdminQueueFormatName

--*/
//////////////////////////////////////////////////////////////////////////////
static void GetAdminQueueFormatName(const GUID& gQMID, CString& strQueueFormatName)
{
    WCHAR wcsTemp[MAX_PATH];

   StringCchPrintf(
   		wcsTemp,
        TABLE_SIZE(wcsTemp),
        FN_PRIVATE_TOKEN            // "PRIVATE"
        FN_EQUAL_SIGN           // "="
        GUID_FORMAT             // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        FN_PRIVATE_SEPERATOR    // "\\"
        FN_PRIVATE_ID_FORMAT,     // "xxxxxxxx"
        GUID_ELEMENTS((&gQMID)),
        ADMINISTRATION_QUEUE_ID
        );

    strQueueFormatName = wcsTemp;
}


//////////////////////////////////////////////////////////////////////////////
/*++

SendAndReceiveAdminMsg
   
    Sends an admin message.
    Always allocate the response body buffer. Must be freed by the caller

--*/
//////////////////////////////////////////////////////////////////////////////
static HRESULT SendAndReceiveAdminMsg(
    const GUID& gMachineID,
    CString& strMsgBody,
    UCHAR** ppBuf,
    DWORD* pdwBufSize
    )
{
    HRESULT hr;
    CString strAdminQ;
    WCHAR wzPrivateFormatName[MAX_QUEUE_FORMATNAME];
    QUEUEHANDLE hQ;

    //
    // Create a private queue for response
    //
    hr = CreatePrivateResponseQueue(wzPrivateFormatName);
    if(FAILED(hr))
        return(hr);

    //
    // Send request message to Target machine
    //
    GetAdminQueueFormatName(gMachineID, strAdminQ);
    hr = SendMSMQMessage( strAdminQ, ADMIN_COMMANDS_TITLE,
                          strMsgBody, ((strMsgBody.GetLength() + 1)*sizeof(TCHAR)),
                          wzPrivateFormatName,MAX_WAIT_FOR_RESPONSE); 

    if(FAILED(hr))
        return(hr);

    //
    // Open the private queue
    //
    hr = MQOpenQueue(wzPrivateFormatName, MQ_RECEIVE_ACCESS, 0, &hQ);
    if(FAILED(hr))
    {
        ATLTRACE(_T("SendAndReceiveAdminMsg - Can not open response private queue\n"));
        return(hr);
    }
    
    //
    // Wait for the response
    //
    hr = WaitForAdminResponse(hQ,MAX_WAIT_FOR_RESPONSE * 1000, ppBuf, pdwBufSize);
    if(FAILED(hr))
        return(hr);

    //
    // Close the private response queue
    //
    MQCloseQueue(hQ);


    //
    // And delete it.
    //
    hr = MQDeleteQueue(wzPrivateFormatName);

    return(MQ_OK);
}


//////////////////////////////////////////////////////////////////////////////
/*++

RequestPrivateQueues

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT RequestPrivateQueues(const GUID& gMachineID, PUCHAR *ppListofPrivateQ, DWORD *pdwNoofQ)
{
    ASSERT(ppListofPrivateQ != NULL);
    ASSERT(pdwNoofQ != NULL);

    CArray<QMGetPrivateQResponse*, QMGetPrivateQResponse*> aResponse;
    QMGetPrivateQResponse* pResponse;

    PUCHAR  pPrivateQBuffer = 0;

    QMGetPrivateQResponse_POS32 pos = NULL;
    DWORD dwTotalSize = 0;
    HRESULT hr;

    *pdwNoofQ = 0;
    do
    {
        DWORD dwResponseSize = 0;
        CString strMsgBody;
        strMsgBody.Format(TEXT("%s=%d"), ADMIN_GET_PRIVATE_QUEUES, pos);

        PUCHAR pPrivateQueueBuffer;
        hr = SendAndReceiveAdminMsg(gMachineID,
                                  strMsgBody,
                                  &pPrivateQueueBuffer,
                                  &dwResponseSize);
        if (FAILED(hr))
        {
            for (int i = 0; i < aResponse.GetSize(); i++)
            {
                pResponse = aResponse[i];
                delete pResponse;
            }
            return hr;
        }

        pResponse = reinterpret_cast<QMGetPrivateQResponse*>(pPrivateQueueBuffer);
        
        aResponse.Add(pResponse);
        dwTotalSize += pResponse->dwResponseSize;
        *pdwNoofQ += pResponse->dwNoOfQueues;

        
        pos = pResponse->pos;

    } while (pResponse->hr == ERROR_MORE_DATA);

    pPrivateQBuffer = new UCHAR[dwTotalSize];
    PUCHAR pCurrentPos = pPrivateQBuffer;

    for (int i = 0; i < aResponse.GetSize(); i++)
    {
        pResponse = aResponse[i];
        memcpy(pCurrentPos, pResponse->uResponseBody, pResponse->dwResponseSize); 
        pCurrentPos += pResponse->dwResponseSize;
        delete pResponse;
    }

    *ppListofPrivateQ = pPrivateQBuffer;

    return(S_OK);

}

HRESULT 
RequestDependentClient(
    const GUID& gMachineID, 
    CList<LPWSTR, LPWSTR&>& DependentMachineList
    )
{
    HRESULT hr;
    CString strMsgBody = ADMIN_GET_DEPENDENTCLIENTS;
    DWORD   dwResponseSize = 0;
    AP<UCHAR> pch = NULL;

    hr = SendAndReceiveAdminMsg(
                gMachineID,
                strMsgBody,
                &pch,
                &dwResponseSize
                );

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Remove status byte to make the data aligned.
    //
    ASSERT(dwResponseSize >= 1);
    memmove(pch, pch + 1, dwResponseSize - 1);

    ClientNames* pClients = (ClientNames*)pch.get();
    LPWSTR pw = &pClients->rwName[0];

    for (ULONG i=0; i<pClients->cbClients; ++i)
    {
        DWORD size = numeric_cast<DWORD>(wcslen(pw)+1);
        LPWSTR clientName = new WCHAR[size];
        memcpy(clientName, pw, size*sizeof(WCHAR));
        DependentMachineList.AddTail(clientName);

        pw += size;
    }

    return(MQ_OK);
}
//////////////////////////////////////////////////////////////////////////////
/*++

MQPing

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT MQPingNoUI(const GUID& gMachineID)
{
    //
    // convert guid to string-guid repesentation
    //
    WCHAR strId[STRING_UUID_SIZE+1];
    INT iLen = StringFromGUID2(gMachineID, strId, TABLE_SIZE(strId));
    if (iLen != (STRING_UUID_SIZE + 1))
    {
        ASSERT(0);
        return MQ_ERROR;
    }

    CString strMsgBody;
    strMsgBody.Format(TEXT("%s=%s"), ADMIN_PING, strId);

    P<UCHAR> pBuffer;
    DWORD dwResponseSize;
    HRESULT hr = SendAndReceiveAdminMsg(gMachineID,
                              strMsgBody,
                              (UCHAR**)&pBuffer,
                              &dwResponseSize);
    if (FAILED(hr))
    {
        return hr;
    }

    GUID guid;
    //
    // first byte is the status
    //
    if (ADMIN_STAT_OK == pBuffer[0])
    {
        //
        // Body should look like "={<guid>}" - guid begins at second TCHAR
		// The string {<guid>} (starting from the third BYTE) is copied to a newly 
		// allocated buffer in order to avoid alignment faults on win64 in
		// IIDFromString(). <nelak, 03/2001>
        //
		P<TCHAR> strGuidAsString = new TCHAR[dwResponseSize / sizeof(TCHAR)];
		memcpy(strGuidAsString, &pBuffer[3], dwResponseSize - 3);

		if (SUCCEEDED(IIDFromString(strGuidAsString, &guid)))
        {
            if (guid == gMachineID)
            {
                return S_OK;
            }
        }
    }

    return(MQ_ERROR);
}

HRESULT MQPing(const GUID& gMachineID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    UINT nIdMessage= IDS_PING_FAILED, nType = MB_ICONEXCLAMATION;
    {
        CWaitCursor wc;

        if (SUCCEEDED(MQPingNoUI(gMachineID)))
        {
            nIdMessage= IDS_PING_SUCCEEDED;
            nType = MB_ICONINFORMATION;
        }
    }

    AfxMessageBox(nIdMessage, nType);
    return S_OK;
}


HRESULT
SendAdminGuidMessage(
    const GUID& gMachineID,
    const GUID& ReportQueueGuid,
    LPCWSTR pwcsCommand
    )
{
    //
    // Get the Target Admin Queue's format name
    //
    CString strAdminQueueFormatName;

    GetAdminQueueFormatName(gMachineID, strAdminQueueFormatName);


    CString strMsgBody;

    //
    // convert guid to string-guid repesentation
    //
    WCHAR wcsTemp[STRING_UUID_SIZE+1];
    INT iLen = StringFromGUID2(ReportQueueGuid, wcsTemp, TABLE_SIZE(wcsTemp));

    if (iLen != (STRING_UUID_SIZE + 1))
    {
        return MQ_ERROR;
    }

    //
    // prepare message body and send it along with the appropriate title of
    // admin commands
    //
    strMsgBody = pwcsCommand;
    strMsgBody += L"=";
    strMsgBody += wcsTemp;

    return (SendMSMQMessage(strAdminQueueFormatName,
                              ADMIN_COMMANDS_TITLE,
                              strMsgBody,
                              (strMsgBody.GetLength() + 1)*sizeof(TCHAR)
                             ));
}



//////////////////////////////////////////////////////////////////////////////
/*++

SendQMTestMessage

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT SendQMTestMessage(GUID &gMachineID, GUID &gQueueId)
{
    return SendAdminGuidMessage(gMachineID, gQueueId, ADMIN_SEND_TESTMSG);
}


/*====================================================

GetQPathnameFromGuid

  Queries the Targeted QM for the report-queue.
  This action is done through falcon-messages to the
  target QM. The action has a timeout limit

Arguments:

Return Value:

=====================================================*/
HRESULT 
GetQPathnameFromGuid(
	 const GUID *pguid, 
	 CString& strName,
	 BOOL fLocalMgmt,
	 const CString& strDomainController
	 )
{
	HRESULT hr;
    PROPID  pid = PROPID_Q_PATHNAME;
    PROPVARIANT pVar;

    pVar.vt = VT_NULL;
    
    hr = ADGetObjectPropertiesGuid(
                eQUEUE,
                fLocalMgmt ? MachineDomain() : GetDomainController(strDomainController),
				fLocalMgmt ? false : true,	// fServerName
                pguid,
                1,
                &pid,
                &pVar
                );

    if (SUCCEEDED(hr))
    {
        strName = pVar.pwszVal;
        MQFreeMemory(pVar.pwszVal);
    }

    return hr;
}

HRESULT
GetQMReportQueue(
    const GUID& gMachineID,
    CString& strRQPathname,
	BOOL fLocalMgmt,
	const CString& strDomainController
    )
{
    CString strMsgBody = ADMIN_GET_REPORTQUEUE;
    HRESULT hr;

    P<UCHAR> pBuffer;
    DWORD dwResponseSize = 0;

    hr = SendAndReceiveAdminMsg(gMachineID,
                              strMsgBody,
                              (UCHAR**)&pBuffer,
                              &dwResponseSize);
    if (FAILED(hr))
    {
        return(hr);
    }

    switch (pBuffer[0] /* status */)
    {
        case ADMIN_STAT_NOVALUE:
            //
            // no report queue found
            //
            strRQPathname.Empty();
            hr = MQ_OK;
            break;

        case ADMIN_STAT_OK:
			//
			// Avoid alignment faults
			//
			GUID machineGuid;
			memcpy(&machineGuid, &pBuffer[1], sizeof(GUID));

            //
            // query the DS for the queue's pathname
            //
            hr = GetQPathnameFromGuid(
					&machineGuid,
					strRQPathname,
					fLocalMgmt,
					strDomainController
					);
            break;

        default:
            hr = MQ_ERROR;

    }

    return hr;
}

/*====================================================

SetQMReportQueue

Arguments:

Return Value:

=====================================================*/

HRESULT
SetQMReportQueue(
    const GUID& gDesMachine,
    const GUID& gReportQueue    
    )
{
    return SendAdminGuidMessage(gDesMachine, gReportQueue, ADMIN_SET_REPORTQUEUE);
}




/*====================================================

GetQMReportState

  Queries the Targeted QM for the report-state .
  This action is done through falcon-messages to the
  target QM. The action has a timeout limit

  NOTE : Currently, the report-state is the propagation flag.

Arguments:

Return Value:

=====================================================*/

HRESULT
GetQMReportState(
    const GUID& gMachineID,
    BOOL& fReportState
    )
{
    CString strMsgBody = ADMIN_GET_PROPAGATEFLAG;

    HRESULT hr;
    fReportState = FALSE; // default value

    P<UCHAR> pBuffer;
    DWORD dwResponseSize = 0;

    hr = SendAndReceiveAdminMsg(gMachineID,
                              strMsgBody,
                              (UCHAR**)&pBuffer,
                              &dwResponseSize);
    if (FAILED(hr))
    {
        return(hr);
    }

    switch (pBuffer[0] /* Status */)
    {
        case ADMIN_STAT_OK:

            fReportState =
             (pBuffer[1] == PROPAGATE_FLAG_TRUE) ? TRUE : FALSE;

            hr = MQ_OK;
            break;

        default:
            hr = MQ_ERROR;

    }

    return hr;
}


/*====================================================

SetQMReportState

Arguments:

Return Value:

=====================================================*/

HRESULT
SetQMReportState(
    const GUID& gMachineID,
    BOOL fReportState
    )
{
    //
    // Get the Target Admin Queue's format name
    //
    CString strAdminQueueFormatName;

    GetAdminQueueFormatName(gMachineID, strAdminQueueFormatName);

    //
    // prepare message body and send it along with the appropriate title of
    // admin commands
    //
    CString strMsgBody;

    strMsgBody = ADMIN_SET_PROPAGATEFLAG;
    strMsgBody += L"=";
    strMsgBody += (fReportState) ? PROPAGATE_STRING_TRUE : PROPAGATE_STRING_FALSE;

    return (SendMSMQMessage(strAdminQueueFormatName,
                              ADMIN_COMMANDS_TITLE,
                              strMsgBody,
                              (strMsgBody.GetLength() + 1)*sizeof(TCHAR)
                              ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\aliasgen.h ===
#if !defined(AFX_ALIASGEN_H__57A77014_D858_11D1_9C86_006008764D0E__INCLUDED_)
#define AFX_ALIASGEN_H__57A77014_D858_11D1_9C86_006008764D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AliasGen.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CAliasGen dialog

class CAliasGen : public CMqPropertyPage
{
	DECLARE_DYNCREATE(CAliasGen)

// Construction
public:
    CAliasGen() ;
	~CAliasGen();
   
    HRESULT InitializeProperties(
                CString strLdapPath, 
                CString strAliasPathName
                );

// Dialog Data
	//{{AFX_DATA(CAliasGen)
	enum { IDD = IDD_ALIAS_GENERAL };	
	CString	m_strAliasPathName;
    CString	m_strAliasFormatName;
    CString	m_strDescription;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAliasGen)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAliasGen)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
    HRESULT SetChanges();

    CString m_strInitialAliasFormatName;
    CString m_strInitialDescription;

    CString m_strLdapPath;

    
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ALIASGEN_H__57A77014_D858_11D1_9C86_006008764D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\aliasq.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    aliasq.cpp

Abstract:

    Implementation of CAliasQObject

Author:

    Tatiana Shubin

--*/

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "mqPPage.h"
#include "dataobj.h"
#include "mqDsPage.h"
#include "aliasq.h"
#include "aliasgen.h"
#include "globals.h"
#include "newalias.h"
#include "ldaputl.h"
#include <adsiutl.h>

#include "aliasq.tmh"


/////////////////////////////////////////////////////////////////////////////
// CAliasQObject


//
// IShellPropSheetExt
//

HRESULT 
CAliasQObject::ExtractMsmqPathFromLdapPath(
    LPWSTR lpwstrLdapPath
    )
{                
    return ExtractAliasPathNameFromLdapName(m_strMsmqPath, lpwstrLdapPath);
}


STDMETHODIMP 
CAliasQObject::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
    HPROPSHEETPAGE hPage = CreateGeneralPage();
    if ((0 == hPage) || !(*lpfnAddPage)(hPage, lParam))
    {
        ASSERT(0);
        return E_UNEXPECTED;
    }       

    //
    // Add the "Member Of" page using the cached interface
    //    
    if (m_spMemberOfPage != 0)
    {
        VERIFY(SUCCEEDED(m_spMemberOfPage->AddPages(lpfnAddPage, lParam)));
    }
   
    //
    // Add the "Object" page using the cached interface
    //
    if (m_spObjectPage != 0)
    {
        VERIFY(SUCCEEDED(m_spObjectPage->AddPages(lpfnAddPage, lParam)));
    }    

    return S_OK;
}

HPROPSHEETPAGE 
CAliasQObject::CreateGeneralPage()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    

	CMqDsPropertyPage<CAliasGen> *pcpageGeneral = 
        new CMqDsPropertyPage<CAliasGen>(m_pDsNotifier);
    if (FAILED(pcpageGeneral->InitializeProperties(m_strLdapName, m_strMsmqPath)))
    {
        delete pcpageGeneral;

        return 0;
    }

	return pcpageGeneral->CreateThemedPropertySheetPage();  
}

//
// IContextMenu
//
STDMETHODIMP 
CAliasQObject::QueryContextMenu(
    HMENU /*hmenu*/, 
    UINT /*indexMenu*/, 
    UINT /*idCmdFirst*/, 
    UINT /*idCmdLast*/, 
    UINT /*uFlags*/
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return 0;
}

STDMETHODIMP 
CAliasQObject::InvokeCommand(
    LPCMINVOKECOMMANDINFO /*lpici*/
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    
    ASSERT(0);

    return S_OK;
}


STDMETHODIMP CAliasQObject::Initialize(IADsContainer* pADsContainerObj, 
                        IADs* pADsCopySource,
                        LPCWSTR lpszClassName)
{   
    if ((pADsContainerObj == NULL) || (lpszClassName == NULL))
    {
        return E_INVALIDARG;
    }
    //
    // We do not support copy at the moment
    //
    if (pADsCopySource != NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    R<IADs> pIADs;
    hr = pADsContainerObj->QueryInterface(IID_IADs, (void **)&pIADs);
    ASSERT(SUCCEEDED(hr));

    //
    // Get the container distinguish name
    //   
    VARIANT var;

    hr = pIADs->Get(const_cast<WCHAR*> (x_wstrDN), &var);
    ASSERT(SUCCEEDED(hr));
        
	if ( !GetContainerPathAsDisplayString(var.bstrVal, &m_strContainerNameDispFormat) )
	{
		m_strContainerNameDispFormat = L"";
	}
	m_strContainerName = var.bstrVal;

    VariantClear(&var);

    return S_OK;
}

HRESULT CAliasQObject::CreateModal(HWND /*hwndParent*/, IADs** ppADsObj)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
           
    R<CNewAlias> pNewAlias = new CNewAlias(m_strContainerName, m_strContainerNameDispFormat);       
	CGeneralPropertySheet propertySheet(pNewAlias.get());
	pNewAlias->SetParentPropertySheet(&propertySheet);

	//
	// We want to use pNewAlias data also after DoModal() exitst
	//
	pNewAlias->AddRef();
	INT_PTR iStatus = propertySheet.DoModal();

    if(iStatus == IDCANCEL || FAILED(pNewAlias->GetStatus()))
    {
        //
        // We should return S_FALSE here to instruct the framework to 
        // do nothing. If we return an error code, the framework will 
        // pop up an additional error dialog box.
        //
        return S_FALSE;
    }

    //
    // Check if creation succeeded
    //
    LPCWSTR wcsAliasFullPath = pNewAlias->GetAliasFullPath();
    if (wcsAliasFullPath == NULL)
    {
        return S_FALSE;
    }        

	AP<WCHAR> pEscapeAdsPathNameToFree;

    HRESULT rc = ADsOpenObject( 
		            UtlEscapeAdsPathName(wcsAliasFullPath, pEscapeAdsPathNameToFree),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) ppADsObj
					);

    if(FAILED(rc))
    {   
        AfxMessageBox(IDS_CREATED_WAIT_FOR_REPLICATION);
        return S_FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\aliasgen.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    aliasgen.cpp

Abstract:

    Alias Queue General property page implementation

Author:

    Tatiana Shubin (tatianas)

--*/

#include "stdafx.h"
#include "mqsnap.h"
#include "resource.h"
#include "mqPPage.h"
#include "AliasGen.h"
#include "globals.h"
#include "adsutil.h"

#include "aliasgen.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//#define ALIAS_PROP   2

/////////////////////////////////////////////////////////////////////////////
// CAliasGen property page

IMPLEMENT_DYNCREATE(CAliasGen, CMqPropertyPage)

CAliasGen::CAliasGen() : CMqPropertyPage(CAliasGen::IDD)    
{
	//{{AFX_DATA_INIT(CAliasGen)	
    m_strAliasPathName = _T("");
    m_strAliasFormatName = _T("");
    m_strDescription = _T("");
	//}}AFX_DATA_INIT
}

CAliasGen::~CAliasGen()
{
}

void CAliasGen::DoDataExchange(CDataExchange* pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CMqPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAliasGen)	
    DDX_Text(pDX, IDC_ALIAS_LABEL, m_strAliasPathName);
    DDX_Text(pDX, IDC_ALIAS_FORMATNAME, m_strAliasFormatName);
    DDX_Text(pDX, IDC_ALIAS_DESCRIPTION, m_strDescription);
    DDV_NotEmpty(pDX, m_strAliasFormatName, IDS_MISSING_ALIAS_FORMATNAME);
	DDV_ValidFormatName(pDX, m_strAliasFormatName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAliasGen, CMqPropertyPage)
	//{{AFX_MSG_MAP(CAliasGen)
	ON_EN_CHANGE(IDC_ALIAS_FORMATNAME, OnChangeRWField)
    ON_EN_CHANGE(IDC_ALIAS_DESCRIPTION, OnChangeRWField)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAliasGen message handlers

BOOL CAliasGen::OnInitDialog() 
{
    //
    // This closure is used to keep the DLL state. For UpdateData we need
    // the mmc.exe state.
    //

    UpdateData( FALSE );
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT
CAliasGen::InitializeProperties(CString strLdapPath, CString strAliasPathName)
{
    //
    // get alias properties using ADSI 
    //
    CAdsUtil AdsUtil(strLdapPath);
    
    HRESULT hr = AdsUtil.InitIAds();
    if (FAILED(hr))
    {     
        return hr;
    }

    hr = AdsUtil.GetObjectProperty(                             
                        x_wstrAliasFormatName, 
                        &m_strAliasFormatName);
    if (FAILED(hr))
    {
		m_strAliasFormatName.Empty();
    }

    hr = AdsUtil.GetObjectProperty(                             
                        x_wstrDescription, 
                        &m_strDescription);
    if (FAILED(hr))
    {
        m_strDescription.Empty();
    }
      
    m_strAliasPathName = strAliasPathName;    
    m_strInitialAliasFormatName = m_strAliasFormatName;
    m_strInitialDescription = m_strDescription;
    m_strLdapPath = strLdapPath;

    return MQ_OK;
}

HRESULT CAliasGen::SetChanges()
{    
    CAdsUtil AdsUtil(m_strLdapPath);

    HRESULT hr = AdsUtil.InitIAds();
    if (FAILED(hr))
    {       
        return hr;
    }

    //
    // if initial format name was changed so set it using ADSI API
    //
    if (m_strInitialAliasFormatName != m_strAliasFormatName)
    {        
        hr = AdsUtil.SetObjectProperty(
                        x_wstrAliasFormatName, 
                        m_strAliasFormatName);
        if (FAILED(hr))
        {       
            return hr;
        }
    }
    
    //
    // if initial description was changed so set it using ADSI API
    //
    if (m_strInitialDescription != m_strDescription)
    {
        hr = AdsUtil.SetObjectProperty(
                        x_wstrDescription, 
                        m_strDescription);
    }
    
    if (FAILED(hr))
    {       
        return hr;
    }

    hr = AdsUtil.CommitChanges();   

    return hr;
}


BOOL CAliasGen::OnApply() 
{
    if (!m_fModified)
    {
        return TRUE;
    }

    HRESULT hr = SetChanges();
    if (FAILED(hr))
    {       
        MessageDSError(hr, IDS_OP_SET_PROPERTIES_OF, m_strAliasPathName);
        return FALSE;        
    }
   
	return CMqPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\adsutil.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adsutil.cpp

Abstract:

    Implementation of CAdsUtil: auxiliary class to use ADSI API

Author:

    Tatiana Shubin

--*/

#include "stdafx.h"
#include "resource.h"
#include "mqsnap.h"
#include "globals.h"
#include "adsutil.h"
#include <adsiutl.h>

#include "adsutil.tmh"


CAdsUtil::CAdsUtil(CString strParentName, 
                   CString strObjectName,
                   CString strFormatName)
	:   m_strParentName(strParentName),
        m_strObjectName(strObjectName),
        m_strFormatName(strFormatName),
        m_pIAds (NULL)
{	
}

CAdsUtil::CAdsUtil(CString strLdapPath)
	:   m_strLdapPath(strLdapPath) ,
        m_pIAds (NULL)
{	
}

CAdsUtil::~CAdsUtil()
{    
    if (m_pIAds)
    {
        m_pIAds->Release();
    }
}

HRESULT CAdsUtil::CreateAliasObject(CString *pstrFullPathName)
{
    CString strTemp = x_wstrLdapPrefix;
    strTemp += m_strParentName;

	// First, we must bind to the parent container
	AP<WCHAR> pEscapeAdsPathNameToFree;
    R<IADsContainer>  pContainer  = NULL;
    
	HRESULT hr = ADsOpenObject( 
					UtlEscapeAdsPathName(strTemp, pEscapeAdsPathNameToFree),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADsContainer,
					(void**)&pContainer
					);


    if (FAILED(hr))
    {       
        return hr;
    }    

    CString strChildFullPathName = x_CnPrefix + m_strObjectName; 

    R<IDispatch> pDisp = NULL;
      
    hr = pContainer->Create(const_cast<WCHAR*> (x_wstrAliasClass),
                            strChildFullPathName.AllocSysString(),
                            (IDispatch **) &pDisp);
    if (FAILED(hr))
    {     
        return hr;
    }    

    R<IADs> pChild  = NULL;

    hr = pDisp->QueryInterface (IID_IADs,(LPVOID *) &pChild);
    if (FAILED(hr))
    {     
        return hr;
    }    
         
    VARIANT vProp;
    vProp.vt = VT_BSTR;
    vProp.bstrVal = SysAllocString(m_strFormatName);

    hr = pChild->Put(const_cast<WCHAR*> (x_wstrAliasFormatName), vProp);        
    if (FAILED(hr))
    {           
        return hr;
    }        
    VariantClear(&vProp);


    // Finalize creation - commit it 
    //
    hr = pChild->SetInfo();
    if (FAILED(hr))
    {
        return hr;
    }    
    
    BSTR bs;
    hr = pChild->get_ADsPath(&bs);
    if (FAILED(hr))
    {       
        return hr;
    }

    *pstrFullPathName = bs;    

    return MQ_OK;
}

HRESULT CAdsUtil::InitIAds ()
{
    ASSERT(!m_strLdapPath.IsEmpty());  

	AP<WCHAR> pEscapeAdsPathNameToFree;

    HRESULT hr = ADsOpenObject( 
					UtlEscapeAdsPathName(m_strLdapPath,pEscapeAdsPathNameToFree),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &m_pIAds
					);

    return hr;
}

HRESULT CAdsUtil::GetObjectProperty ( 
                        CString strPropName, 
                        CString *pstrPropValue)
{
    ASSERT(!m_strLdapPath.IsEmpty());
    ASSERT (m_pIAds);    

    VARIANT var;

    HRESULT hr = m_pIAds->Get(strPropName.AllocSysString(), &var);

	if ( SUCCEEDED(hr) )
	{
		*pstrPropValue = var.bstrVal;
	}

    VariantClear(&var);
    return hr;
}

HRESULT  CAdsUtil::SetObjectProperty (CString strPropName, 
                                      CString strPropValue)
{
    ASSERT(!m_strLdapPath.IsEmpty()); 
    ASSERT (m_pIAds); 

    VARIANT var;
    VariantInit(&var);
 
    // Setting the format name
    
    V_BSTR(&var) = SysAllocString(strPropValue);
    V_VT(&var) = VT_BSTR;
    HRESULT hr = m_pIAds->Put( strPropName.AllocSysString(), var );
    if (FAILED(hr))
    {
        return hr;
    }    
    VariantClear(&var);
       
    return hr;   
}

HRESULT CAdsUtil::CommitChanges()
{
    HRESULT hr = m_pIAds->SetInfo();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\adsutil.h ===
//adsutil.h

class CAdsUtil
{
public:
    CAdsUtil(CString strParentName, 
             CString strObjectName,
             CString strFormatName);
    CAdsUtil(CString strLdapPath);

    ~CAdsUtil ();

    HRESULT CreateAliasObject(CString *pstrFullPathName);
    
    HRESULT InitIAds ();    

    HRESULT GetObjectProperty (                 
                CString strPropName, 
                CString *pstrPropValue);
    HRESULT SetObjectProperty (               
                CString strPropName, 
                CString strPropValue);
    HRESULT CommitChanges();

private:
    CString m_strParentName;
    CString m_strObjectName;
    CString m_strFormatName;
    
    CString m_strLdapPath;

    IADs *m_pIAds;
 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\admin\mqsnap\aliasq.h ===
//aliasq.h : Declaration of the CAliasQObject

#ifndef __ALIASQ_H_
#define __ALIASQ_H_

#include "resource.h"       // main symbols
#include "dataobj.h"

/////////////////////////////////////////////////////////////////////////////
// CAliasQObject
class CAliasQObject : 
	public CDataObject,
    //public CMsmqDataObject,
	public CComCoClass<CAliasQObject, &CLSID_AliasQObject>,
    public IDsAdminCreateObj

{
public:
    DECLARE_NOT_AGGREGATABLE(CAliasQObject)
    DECLARE_REGISTRY_RESOURCEID(IDR_ALIASQOBJECT)

    BEGIN_COM_MAP(CAliasQObject)
	    COM_INTERFACE_ENTRY(IDsAdminCreateObj)
	    COM_INTERFACE_ENTRY_CHAIN(CDataObject)
    END_COM_MAP()

public:

    //
    // IDsAdminCreateObj methods
    //
    STDMETHOD(Initialize)(IADsContainer* pADsContainerObj, 
                          IADs* pADsCopySource,
                          LPCWSTR lpszClassName);
    STDMETHOD(CreateModal)(HWND hwndParent,
                           IADs** ppADsObj);

    //
    // IShellPropSheetExt
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    //
    // IContextMenu
    //
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

protected:
    HPROPSHEETPAGE CreateGeneralPage();
    
    virtual HRESULT ExtractMsmqPathFromLdapPath (LPWSTR lpwstrLdapPath);

    //
    // implementation for pure virtual function of CDataObject
    //
    virtual const DWORD GetObjectType() { return 0;}
    virtual const PROPID *GetPropidArray() {return NULL;}
    virtual const DWORD  GetPropertiesCount() {return 0;}
    
private:

    CString m_strContainerNameDispFormat; 
	CString m_strContainerName;
	
};


#endif //__ALIASQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\