[32];
    ULONG       size;

    //
    // Step 1: Grab the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Make sure that we still have some room to work with
    //
    if (localScope->CurrentByte > localScope->LastByte) {

        return STATUS_SUCCESS;

    }

    //
    // Step 3: This is the first byte in something that we will print out
    // And lets increment the count so that we have an idea of how many
    // items we have processed
    //
    localScope->TermByte = localScope->CurrentByte;
    localScope->Context1 += 1;

    //
    // Step 4: Action depends on current byte
    //
    if ( *(localScope->CurrentByte) == 0x01) {

        UCHAR   b1;
        UCHAR   b2;

        //
        // Step 4.1.1: Get the two bytes that we are going to use
        //
        localScope->CurrentByte++;
        b1 = *(localScope->CurrentByte++);
        b2 = *(localScope->CurrentByte++);

        //
        // Step 4.1.2: Make the string
        //
        STRING_PRINT( buffer,"AccessAs: (0x%2x,0x%2x)\n", b1, b2 );

        //
        // Step 4.1.3: Dump this to the string stack
        //
        StringStackPush(
            &(rootScope->StringStack),
            STRING_LENGTH( buffer ),
            buffer
            );

    } else {

        //
        // Step 4.2.1: Otherwise we have an encoded name
        //
        if ( *(localScope->CurrentByte) == 0x00 ) {

            StringStackPush(
                &(rootScope->StringStack),
                10,
                "(Reserved)"
                );
            localScope->CurrentByte++;

        } else {

            StringStackPush(
                &(rootScope->StringStack),
                sizeof(NAMESEG),
                localScope->CurrentByte
                );
            localScope->CurrentByte += sizeof(NAMESEG);

        }

        //
        // Step 4.2.2: Dump a seperator
        //
        StringStackPush(
            &(rootScope->StringStack),
            4,
            ": 0x"
            );

        //
        // Step 4.2.3: Calculate the size of the field
        //
        size = (ULONG) *(localScope->CurrentByte);
        localScope->CurrentByte++;
        followBits = (UCHAR) ( (size & 0xc0) >> 6);
        if (followBits) {

            size &= 0xf;
            for (i = 0; i < followBits; i++) {

                size |= (ULONG) *(localScope->CurrentByte) << (i * 8 + 4);
                localScope->CurrentByte++;

            }

        }

        //
        // Step 4.2.4: Dump a string that is correspondent to the size
        // of the number
        //
        STRING_PRINT( buffer,"%x", size );

        //
        // Step 4.2.5: Dump the length of the thing
        //
        StringStackPush(
            &(rootScope->StringStack),
            STRING_LENGTH( buffer ),
            buffer
            );

        //
        // Step 5.4: Print the string out
        //
        StringStackPush( &(rootScope->StringStack), 1, "\n" );

    }

    //
    // Step 5: Dump the string we generated
    //
    ScopePrint( Stack );

    //
    // Step 6: If there are still more thing to processe, we should
    // call this function again
    //
    if (localScope->CurrentByte <= localScope->LastByte) {

        action = SC_PARSE_FIELD;
        StringStackPush( &(rootScope->ParseStack), 1, &action );

    }

    //
    // Step 7: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseFunctionHandler(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This code is actually something that transfers control to the term
    specific handler

Arguments:

    The current thread's stack

Return Value:

    None

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;

    //
    // Step 1: Grab the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Check to see if we are at the end of the current nest
    //
    if (!(localScope->Flags & SC_FLAG_NESTED) ) {

        //
        // Step 2.1: Dump the string
        //
        StringStackPush( &(rootScope->StringStack), 2, "\n" );
        ScopePrint( Stack );

    }


    //
    // Step 4: Call the function handler if there is one
    //
    if ( localScope->AmlTerm->FunctionHandler != NULL) {

        status = (localScope->AmlTerm->FunctionHandler)( Stack );

    }

    //
    // Step 5: Done
    //
    return status;

}

NTSTATUS
ParseLocalObject(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles the LocalX instruction

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    CHAR            i;
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           buffer[7];

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and root scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Which local are we talking about
    //
    i = *(localScope->CurrentByte) - OP_LOCAL0;
    if ( i < 0 || i > 7) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Step 3: Display this to the user
    //
    STRING_PRINT( buffer, "Local%1d", i );
    StringStackPush( &(rootScope->StringStack), 6, buffer );

    //
    // Step 4: Setup for next state
    //
    localScope->CurrentByte++;

    //
    // Step 5: Done
    //
    return status;
}

NTSTATUS
ParseName(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles generating the argument name

Arguments:

    Stack   - The Stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    PSTRING_STACK   *stringStack;
    ULONG           nameSegmentCount = 1;

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and local scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Delimit the String
    //
    stringStack = &(rootScope->StringStack);
    StringStackPush( stringStack, 1, "\"");

    //
    // Step 3: Action depends on what the current byte value is:
    //
    switch ( *(localScope->CurrentByte) ) {
    case OP_ROOT_PREFIX:

        StringStackPush( stringStack, 1, "\\" );
        localScope->CurrentByte++;
        break;

    case OP_PARENT_PREFIX:

        while ( *(localScope->CurrentByte) == OP_PARENT_PREFIX ) {

            StringStackPush( stringStack, 1, "^" );
            localScope->CurrentByte++;

        }
        break;
    }

    //
    // Step 4: Determine the number of Name segments we are adding
    //
    switch ( *(localScope->CurrentByte) ) {
    case '\0':

        nameSegmentCount = 0;
        localScope->CurrentByte++;
        break;

    case OP_MULTI_NAME_PREFIX:

        //
        // The next byte contains the number of name segments
        //
        localScope->CurrentByte++;
        nameSegmentCount = (ULONG) *(localScope->CurrentByte);
        localScope->CurrentByte++;
        break;

    case OP_DUAL_NAME_PREFIX:

        //
        // There are two name segments
        //
        nameSegmentCount = 2;
        localScope->CurrentByte++;
        break;

    }

    //
    // Step 5: Push the name segments onto the stack
    //
    while (nameSegmentCount > 0) {

        //
        // Step 5.1 Add the segment onto the stack
        //
        StringStackPush(
            stringStack,
            sizeof( NAMESEG ),
            localScope->CurrentByte
            );

        //
        // Step 5.2: Decrement the number of remaining segments and
        // move the current byte pointer to point to the next
        // interesting thing
        //
        nameSegmentCount--;
        localScope->CurrentByte += sizeof(NAMESEG);

        //
        // Step 5.3: Check to see if we should add a seperator
        //
        if (nameSegmentCount) {

            StringStackPush( stringStack, 1, "." );

        }

    }

    //
    // Step 6: Push the closing delimiter
    //
    StringStackPush( stringStack, 1, "\"" );

    //
    // Step 7: done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseNameObject(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles name objects

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{

    //
    // Note: at this time, this function is just a wrapper for
    // ParseName(). If that was an assembler, it would have to execute
    // something here
    //
    return ParseName( Stack );

}

NTSTATUS
ParseOpcode(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine is the main parsing point for AML opcode

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_AMLTERM    amlTerm;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;
    UCHAR       action;
    ULONG       termGroup;

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Check to see if we are past the end byte?
    //
    if (localScope->CurrentByte > localScope->LastByte) {

        return STATUS_SUCCESS;

    }

    //
    // Step 3: Remember which byte demarked the start of the
    // instruction
    //
    localScope->TermByte = localScope->CurrentByte;

    //
    // Step 4: Check to see if this is an extended instruction
    //
    if ( *(localScope->CurrentByte) == OP_EXT_PREFIX) {

        //
        // Step 4.1.1: Extended opcode. Next instruction will let us find the
        // AML term to use for the evaluation
        //
        localScope->CurrentByte++;

        //
        // Step 4.1.2: Grab the AML term for the extended operation
        //
        amlTerm = localScope->AmlTerm = ScopeFindExtendedOpcode( Stack );

    } else {

        //
        // Step 4.2.1: Grab the AML term for the current operation
        //
        amlTerm = localScope->AmlTerm =
            OpcodeTable[ *(localScope->CurrentByte) ];

    }
    localScope->Context1 = localScope->Context2 = 0;

    //
    // Step 5: Check to see if we have a valid AML term
    //
    if (localScope->AmlTerm == NULL) {

        return STATUS_UNSUCCESSFUL;

    }

    //
    // Step 6: Farm out the real work to functions that are better capable
    // of handling the current AML term
    //
    termGroup = (amlTerm->OpCodeFlags & 0xFF);
    switch( termGroup ) {
    case OF_NORMAL_OBJECT:
    case OF_VARIABLE_LIST:
    case OF_REF_OBJECT:

        //
        // Step 6.1: If we are going to handle a variable length instruction
        // than we must also pop it from the stack
        //
        if (amlTerm->OpCodeFlags == OF_VARIABLE_LIST) {

            UCHAR   actionList[5] = {
                SC_PARSE_OPCODE,
                SC_PARSE_POP,
                SC_PARSE_OPCODE,
                SC_PARSE_CODE_OBJECT,
                SC_PARSE_VARIABLE_OBJECT
            };

            StringStackPush( &(rootScope->ParseStack), 5, actionList );

        } else {

            //
            // If we are already nested, we know that there is an ParseOpcode
            // just waiting for us...
            //
            if (!(localScope->Flags & SC_FLAG_NESTED)) {

                action = SC_PARSE_OPCODE;
                StringStackPush( &(rootScope->ParseStack), 1, &action);

            }

            action = SC_PARSE_CODE_OBJECT;
            StringStackPush( &(rootScope->ParseStack), 1, &action);

        }

        //
        // Step 6.2: This is a code byte. Ergo we eat it since we just
        // processed it
        //
        localScope->CurrentByte++;

        //
        // Step 6.3: Done
        //
        return STATUS_SUCCESS;

    case OF_NAME_OBJECT:

        action = SC_PARSE_NAME_OBJECT;
        break;

    case OF_DATA_OBJECT:

        action = SC_PARSE_DATA;
        break;

    case OF_CONST_OBJECT:

        action = SC_PARSE_CONST_OBJECT;
        break;

    case OF_ARG_OBJECT:

        action = SC_PARSE_ARGUMENT_OBJECT;
        break;

    case OF_LOCAL_OBJECT:

        action = SC_PARSE_LOCAL_OBJECT;
        break;

    default:

        return STATUS_NOT_SUPPORTED;

    }

    //
    // Step 7: Actually push the action to execute next on to the stack
    //
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 8: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParsePackage(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine parses the stages of a package

Arguments:

    The current thread's stack

    Note: Caller needs to push a stack location before calling this and they
    have to pop it when it finishes

Return Value:

    NTSTATUS:

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;
    UCHAR       action;

    //
    // Step 1: Grab the current scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Context1 is the current index in the package...
    //
    if (localScope->Context1 == 0) {

        UCHAR   actionList[2] = {
                    SC_PARSE_PACKAGE,
                    SC_PARSE_DELIMITER
                    };
        ULONG   i;

        //
        // Step 2.1.1: This is the first call to parse package...
        // What we need to do here is handle the first argument here,
        // and make sure that we get called again for the remaining
        // arguments
        //
        StringStackPush( &(rootScope->StringStack), 1, "[" );

        //
        // Step 2.1.2: This byte contains the number of arguments to handle
        //
        localScope->Context2 = *(localScope->CurrentByte);
        localScope->CurrentByte++;

        //
        // Step 2.1.3: Make sure that we close that bracket above
        //
        action = SC_PARSE_TRAILING_PACKAGE;
        StringStackPush( &(rootScope->ParseStack), 1, &action );

        //
        // Step 2.1.3: Setup all the remaining calls to this function
        //
        if (localScope->Context2 >= 2) {

            for (i=0; i < localScope->Context2 - 1; i++) {

                StringStackPush( &(rootScope->ParseStack), 2, actionList );

            }

        }

    } else if (localScope->Context1 >= localScope->Context2) {

        //
        // Step 2.2.1: We are at the end of the package
        //
        return STATUS_UNSUCCESSFUL;

    }

    //
    // Step 3: Farm out the work depending on what the current byte is
    // This looks a lot like ParseData, but note the new default case
    //
    switch ( *(localScope->CurrentByte) ) {
        case OP_BYTE:
        case OP_WORD:
        case OP_DWORD:
        case OP_BUFFER:
        case OP_STRING:
        case OP_PACKAGE:
            action = SC_PARSE_DATA;
            break;
        default:
            action = SC_PARSE_NAME;

    }

    //
    // Step 4: Push the next action onto the stack
    //
    StringStackPush( &(rootScope->ParseStack), 1, &action );
    localScope->Context1++;

    //
    // Step 5: done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParsePop(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine removes the top level of the stack and updates the
    current byte as appropriate

Arguments:

    The current thread's stack

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      topScope;
    PUNASM_SCOPE      prevScope;

    //
    // Step 1: Get the top scope
    //
    status = StackTop( Stack, &topScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Get the previous scope
    //
    status = StackParent( Stack, topScope, &prevScope );
    if (!NT_SUCCESS(status)) {

        //
        // Step 2.1: There is actually no parent to this function ...
        // Just pop the top and return
        //
        return StackPop( Stack );

    }

    //
    // Step 3: Make sure to update the prevScope's current byte
    //
    if (topScope->CurrentByte > prevScope->CurrentByte) {

        prevScope->CurrentByte = topScope->CurrentByte;

    }

    //
    // Step 4: Pop the top stack and return
    //
    return StackPop( Stack );
}

NTSTATUS
ParsePush(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles adding a level to the stack

Arguments:

    The thread's current stack

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      curScope;
    PUNASM_SCOPE      newScope;

    //
    // Step 1: Create a new scope on the stack
    //
    status = StackPush( Stack, &newScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Grab the parent from the stack
    //
    status = StackParent( Stack, newScope, &curScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 3: Copy the important values
    //
    newScope->CurrentByte = curScope->CurrentByte;
    newScope->TermByte = curScope->TermByte;
    newScope->LastByte = curScope->LastByte;
    newScope->StringStack = curScope->StringStack;
    newScope->IndentLevel = curScope->IndentLevel;
    newScope->AmlTerm = curScope->AmlTerm;
    newScope->Flags = curScope->Flags;

    //
    // Step 4: Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ParseScope(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles super names

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    PUNASM_SCOPE      rootScope;
    PUCHAR      action;
    UCHAR       defAction = SC_PARSE_OPCODE;

    ASSERT( Stack != NULL && *Stack != NULL);

    //
    // Step 1: Loop forever
    //
    while (1) {

        //
        // Step 2: Get the top of stack, and while it exits, process
        // the current operation
        //
        ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

        //
        // Step 3: We are done if we are in the root scope and the
        // current byte exceeds the last byte
        //
        if (localScope == rootScope &&
            localScope->CurrentByte > localScope->LastByte) {

            //
            // Step 3.1 Done!
            //
            return STATUS_SUCCESS;

        }

        //
        // Step 4: Fetch thing to execute
        //
        status = StringStackPop( &(rootScope->ParseStack), 1, &action );
        if (!NT_SUCCESS(status)) {

            //
            // Step 4.1.1: This is fixed in the look up table
            //
            status = (ScopeStates[ SC_PARSE_OPCODE ])( Stack );

        } else {

            //
            // Step 4.1.2: Determine what to execute
            //
            ASSERT( *action <= SC_MAX_TABLE );
            status = (ScopeStates[ *action ])( Stack );

        }

        if (!NT_SUCCESS(status)) {

            break;

        }

    }

    //
    // Step 5: Show the user the error
    //
    PRINTF("Error Code: %x\n", status );
    return status;
}

NTSTATUS
ParseSuperName(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles super names

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_AMLTERM        amlTerm;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           action;

    ASSERT( Stack != NULL && *Stack != NULL);

    //
    // Step 1: Get the scopes
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: What we do next depend on the current byte
    //
    if ( *(localScope->CurrentByte) == 0) {

        //
        // Unknown
        //
        localScope->CurrentByte++;
        return STATUS_SUCCESS;

    } else if ( *(localScope->CurrentByte) == OP_EXT_PREFIX &&
                *(localScope->CurrentByte + 1) == EXOP_DEBUG) {

        //
        // Debug Object
        //
        localScope->CurrentByte += 2;
        return STATUS_SUCCESS;

    } else if ( OpcodeTable[ *(localScope->CurrentByte) ] == NULL) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Step 3: Now, our action depends on the current AML Term
    //
    amlTerm = OpcodeTable[ *(localScope->CurrentByte) ];
    if ( amlTerm->OpCodeFlags == OF_NAME_OBJECT) {

        //
        // We have a name to parse
        //
        action = SC_PARSE_NAME;

    } else if ( amlTerm->OpCodeFlags == OF_ARG_OBJECT) {

        //
        // We have an argument to parse
        //
        action = SC_PARSE_ARGUMENT_OBJECT;

    } else if ( amlTerm->OpCodeFlags == OF_LOCAL_OBJECT) {

        //
        // We have a local object...
        //
        action = SC_PARSE_LOCAL_OBJECT;

    } else if ( amlTerm->OpCodeFlags == OF_REF_OBJECT) {

        UCHAR   actionList[3] = {
            SC_PARSE_OPCODE,
            SC_PARSE_POP,
            SC_PARSE_OPCODE
        };

        //
        // Step 3.1: Set up the initial task of the new scope
        //
        StringStackPush( &(rootScope->ParseStack), 3, actionList );

        //
        // Step 3.2: Push a new scope
        //
        status = ParsePush( Stack );
        if (!NT_SUCCESS(status) ) {

            return status;

        }

        //
        // Step 3.3: Done
        //
        return STATUS_SUCCESS;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Step 4: Push the action onto the stack
    //
    StringStackPush( &(rootScope->ParseStack), 1, &action );

    //
    // Step 5: Done
    //
    return STATUS_SUCCESS;

}

NTSTATUS
ParseTrailingArgument(
    IN  PSTACK  *Stack
    )
/*--

Routine Description:

    This routine is run at after all arguments are parsed. It is responsible
    for placing a trailing parentheses on the string stack

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      rootScope;

    //
    // Step 1: Get the scope
    //
    status = StackRoot( Stack, &rootScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Push the trailer
    //
    StringStackPush( &(rootScope->StringStack), 1, ")" );

    //
    // Step 3: Done
    //
    return status;
}

NTSTATUS
ParseTrailingBuffer(
    IN  PSTACK  *Stack
    )
/*--

Routine Description:

    This routine is run at after the buffer is parsed. It is responsible
    for placing a trailing curly brace on the string stack

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      rootScope;

    //
    // Step 1: Get the scope
    //
    status = StackRoot( Stack, &rootScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Push the trailer
    //
    StringStackPush( &(rootScope->StringStack), 1, "}" );

    //
    // Step 3: Done
    //
    return status;
}

NTSTATUS
ParseTrailingPackage(
    IN  PSTACK  *Stack
    )
/*--

Routine Description:

    This routine is run at after all elements are parsed. It is responsible
    for placing a trailing brace on the string stack

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      rootScope;

    //
    // Step 1: Get the scope
    //
    status = StackRoot( Stack, &rootScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Push the trailer
    //
    StringStackPush( &(rootScope->StringStack), 1, "]" );

    //
    // Step 3: Done
    //
    return status;
}

NTSTATUS
ParseVariableObject(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine creates another scope level on the stack to process the
    current variable length instruction. It modifies the current scope
    to (correctly) point to the next instruction

    Note:   Callers of this function are expected to pop off the stack
    when it is no longer required!!!

Arguments:

    Stack   - The current thread of execution

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      newScope;
    PUNASM_SCOPE      oldScope;
    PUCHAR      nextOpcode;
    UCHAR       i;
    UCHAR       lengthBytes;
    ULONG       packageLength;

    ASSERT( Stack != NULL && *Stack != NULL);

    //
    // Step 1: Create a new scope on the stack
    //
    status = ParsePush( Stack );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Get the new top scope and its parent
    //
    status = StackTop( Stack, &newScope );
    if (!NT_SUCCESS( status ) ) {

        return status;

    }
    status = StackParent( Stack, newScope, &oldScope );
    if (!NT_SUCCESS( status ) ) {

        return status;

    }

    //
    // Step 3: Determine how bytes the current instruction takes
    //
    packageLength = (ULONG) *(newScope->CurrentByte);
    newScope->CurrentByte++;

    //
    // Step 4: If the the high 2 bits are set, this indicates that some
    // follow on bits are also used in calculating the length
    //
    lengthBytes = (UCHAR) ( ( packageLength & 0xC0) >> 6);
    if (lengthBytes) {

        //
        // Step 4.1: Mask off the non-length bits in the packageLength
        //
        packageLength &= 0xF;

        //
        // Step 4.2: Add the follow-on lengths
        //
        for (i = 0; i < lengthBytes; i++) {

            packageLength |= ( (ULONG) *(newScope->CurrentByte) << (i*8 + 4) );
            newScope->CurrentByte++;

        }

    }

    //
    // Step 5: We can calculate the start of the next opcode as the
    // opcode in the old scope plus the calculated length. The end of
    // new scope is the byte previous to this one
    //
    oldScope->CurrentByte += packageLength;
    newScope->LastByte = oldScope->CurrentByte - 1;

    //
    // Step 6: Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
ParseWord(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This routine handles words

Arguments:

    Stack   - The stack for the current thread

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PUNASM_SCOPE          localScope;
    PUNASM_SCOPE          rootScope;
    UCHAR           localBuffer[8];

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1: Grab the current and root scope
    //
    ScopeFindLocalScope( Stack, &localScope, &rootScope, status );

    //
    // Step 2: Build the string
    //
    STRING_PRINT( localBuffer, "0x%04x", *((PUSHORT)localScope->CurrentByte));

    //
    // Step 3: Move the instruction pointer as appropriate, and setup
    // for the next instructions
    //
    localScope->CurrentByte += 2;

    //
    // Step 4: Now push the byte onto the string stack
    //
    StringStackPush(
        &(rootScope->StringStack),
        STRING_LENGTH( localBuffer ),
        localBuffer
        );

    //
    // Step 5: Done
    //
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This is the precompiled header for the ACPI Unassembler

Author:

    Stephane Plante

Environment:

    Kernel mode only.

Revision History:

--*/

//
// These are the global header files
//
#include <ntddk.h>
#include "aml.h"
#include "unasm.h"

//
// These form the primitives that are used by the local
// header files
//
#include "stack.h"
#include "ustring.h"

//
// These are the local include files
//
#include "parser.h"
#include "function.h"
#include "data.h"
#include "scope.h"

//
// This is to get around the fact that we don't want
// to compile in some routines
//
#include "external.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\stack.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stack.c

Abstract:

    This provides a generic stack handler to push/pop things onto it

Author:

    Stephane Plante (splante)

Environment:

    User, Kernel

--*/

#ifndef _STACK_H_
#define _STACK_H_

    NTSTATUS
    StackAllocate(
        OUT     PSTACK  *Stack,
        IN      ULONG   StackElementSize
        );

    NTSTATUS
    StackFree(
        IN  OUT PSTACK  *Stack
        );

    NTSTATUS
    StackParent(
        IN  OUT PSTACK  *Stack,
        IN      PVOID   Child,
            OUT PVOID   Parent
        );

    NTSTATUS
    StackPop(
        IN  OUT PSTACK  *Stack
        );

    NTSTATUS
    StackPush(
        IN  OUT PSTACK  *Stack,
            OUT PVOID   StackElement
        );

    NTSTATUS
    StackRoot(
        IN  OUT PSTACK  *Stack,
            OUT PVOID   RootElement
        );

    NTSTATUS
    StackTop(
        IN  OUT PSTACK  *Stack,
            OUT PVOID   TopElement
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\data.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This file contains all of the data required by the unassembler

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

//
// N: NameStr
// O: DataObj (num, string, buffer, package)
// K: Keyword (e.g. NoLock, ByteAcc etc.)
// D: DWord integer
// W: Word integer
// B: Byte integer
// U: Numeric (any size integer)
// S: SuperName (NameStr + Localx + Argx + Ret)
// C: Opcode
// Z: ASCIIZ string
//
#define AF      TF_ACTION_FLIST         //process after fixed list is parsed
#define AV      TF_ACTION_VLIST         //process after variable list is parsed
#define LN      TF_PACKAGE_LEN          //term requires package length
#define NE      TF_CHECKNAME_EXIST      //check if name exists
#define DL      TF_DATA_LIST            //term expects buffer data list
#define PL      TF_PACKAGE_LIST         //term expects package list
#define FL      TF_FIELD_LIST           //term expects FieldList
#define OL      TF_OBJECT_LIST          //term expects ObjectList
#define LL      TF_COMPILER_DIRECTIVE   //term expects compiler directives
#define CL      TF_CODE_LIST            //term expects CodeList
#define AL      TF_ALL_LISTS            //term expects anything
#define ML      TF_PNP_MACRO            //term expects PNPMacro
#define BL      TF_BYTE_LIST            //term expects ByteList
#define DD      TF_DWORD_LIST           //term expects DWordList

#define CD      TC_COMPILER_DIRECTIVE
#define FM      TC_FIELD_MACRO
#define CN      TC_CONST_NAME
#define SN      TC_SHORT_NAME
#define NS      TC_NAMESPACE_MODIFIER
#define DO      TC_DATA_OBJECT
#define KW      TC_KEYWORD
#define NO      TC_NAMED_OBJECT
#define C1      TC_OPCODE_TYPE1
#define C2      TC_OPCODE_TYPE2
#define RO      TC_REF_OBJECT
#define PM      TC_PNP_MACRO

#define UNK     OBJTYPE_UNKNOWN
#define INT     OBJTYPE_INTDATA
#define STR     OBJTYPE_STRDATA
#define BUF     OBJTYPE_BUFFDATA
#define PKG     OBJTYPE_PKGDATA
#define FDU     OBJTYPE_FIELDUNIT
#define DEV     OBJTYPE_DEVICE
#define EVT     OBJTYPE_EVENT
#define MET     OBJTYPE_METHOD
#define MUT     OBJTYPE_MUTEX
#define OPR     OBJTYPE_OPREGION
#define PWR     OBJTYPE_POWERRES
#define THM     OBJTYPE_THERMALZONE
#define BFD     OBJTYPE_BUFFFIELD
#define DDB     OBJTYPE_DDBHANDLE

//
// Field flags
//
#define AANY    (ACCTYPE_ANY | (ACCTYPE_MASK << 8))
#define AB      (ACCTYPE_BYTE | (ACCTYPE_MASK << 8))
#define AW      (ACCTYPE_WORD | (ACCTYPE_MASK << 8))
#define ADW     (ACCTYPE_DWORD | (ACCTYPE_MASK << 8))
#define ABLK    (ACCTYPE_BLOCK | (ACCTYPE_MASK << 8))
#define ASSR    (ACCTYPE_SMBSENDRECV | (ACCTYPE_MASK << 8))
#define ASQ     (ACCTYPE_SMBQUICK | (ACCTYPE_MASK << 8))
#define LK      (LOCKRULE_LOCK | (LOCKRULE_MASK << 8))
#define NOLK    (LOCKRULE_NOLOCK | (LOCKRULE_MASK << 8))
#define PSRV    (UPDATERULE_PRESERVE | (UPDATERULE_MASK << 8))
#define WA1S    (UPDATERULE_WRITEASONES | (UPDATERULE_MASK << 8))
#define WA0S    (UPDATERULE_WRITEASZEROS | (UPDATERULE_MASK << 8))

//
// Ids
//
// Identifier token values
#define ID_LANG                 0
#define ID_DEFBLK               (ID_LANG + 0)
#define ID_INCLUDE              (ID_LANG + 1)
#define ID_EXTERNAL             (ID_LANG + 2)

#define ID_ZERO                 (ID_LANG + 100)
#define ID_ONE                  (ID_LANG + 101)
#define ID_ONES                 (ID_LANG + 102)
#define ID_REVISION             (ID_LANG + 103)
#define ID_ARG0                 (ID_LANG + 104)
#define ID_ARG1                 (ID_LANG + 105)
#define ID_ARG2                 (ID_LANG + 106)
#define ID_ARG3                 (ID_LANG + 107)
#define ID_ARG4                 (ID_LANG + 108)
#define ID_ARG5                 (ID_LANG + 109)
#define ID_ARG6                 (ID_LANG + 110)
#define ID_LOCAL0               (ID_LANG + 111)
#define ID_LOCAL1               (ID_LANG + 112)
#define ID_LOCAL2               (ID_LANG + 113)
#define ID_LOCAL3               (ID_LANG + 114)
#define ID_LOCAL4               (ID_LANG + 115)
#define ID_LOCAL5               (ID_LANG + 116)
#define ID_LOCAL6               (ID_LANG + 117)
#define ID_LOCAL7               (ID_LANG + 118)
#define ID_DEBUG                (ID_LANG + 119)

#define ID_ALIAS                (ID_LANG + 200)
#define ID_NAME                 (ID_LANG + 201)
#define ID_SCOPE                (ID_LANG + 202)

#define ID_BUFFER               (ID_LANG + 300)
#define ID_PACKAGE              (ID_LANG + 301)
#define ID_EISAID               (ID_LANG + 302)

#define ID_ANYACC               (ID_LANG + 400)
#define ID_BYTEACC              (ID_LANG + 401)
#define ID_WORDACC              (ID_LANG + 402)
#define ID_DWORDACC             (ID_LANG + 403)
#define ID_BLOCKACC             (ID_LANG + 404)
#define ID_SMBSENDRCVACC        (ID_LANG + 405)
#define ID_SMBQUICKACC          (ID_LANG + 406)
#define ID_LOCK                 (ID_LANG + 407)
#define ID_NOLOCK               (ID_LANG + 408)
#define ID_PRESERVE             (ID_LANG + 409)
#define ID_WRONES               (ID_LANG + 410)
#define ID_WRZEROS              (ID_LANG + 411)
#define ID_SYSMEM               (ID_LANG + 412)
#define ID_SYSIO                (ID_LANG + 413)
#define ID_PCICFG               (ID_LANG + 414)
#define ID_EMBCTRL              (ID_LANG + 415)
#define ID_SMBUS                (ID_LANG + 416)
#define ID_SERIALIZED           (ID_LANG + 417)
#define ID_NOTSERIALIZED        (ID_LANG + 418)
#define ID_MTR                  (ID_LANG + 419)
#define ID_MEQ                  (ID_LANG + 420)
#define ID_MLE                  (ID_LANG + 421)
#define ID_MLT                  (ID_LANG + 422)
#define ID_MGE                  (ID_LANG + 423)
#define ID_MGT                  (ID_LANG + 424)
#define ID_EDGE                 (ID_LANG + 425)
#define ID_LEVEL                (ID_LANG + 426)
#define ID_ACTIVEHI             (ID_LANG + 427)
#define ID_ACTIVELO             (ID_LANG + 428)
#define ID_SHARED               (ID_LANG + 429)
#define ID_EXCLUSIVE            (ID_LANG + 430)
#define ID_COMPAT               (ID_LANG + 431)
#define ID_TYPEA                (ID_LANG + 432)
#define ID_TYPEB                (ID_LANG + 433)
#define ID_TYPEF                (ID_LANG + 434)
#define ID_BUSMASTER            (ID_LANG + 435)
#define ID_NOTBUSMASTER         (ID_LANG + 436)
#define ID_TRANSFER8            (ID_LANG + 437)
#define ID_TRANSFER8_16         (ID_LANG + 438)
#define ID_TRANSFER16           (ID_LANG + 439)
#define ID_DECODE16             (ID_LANG + 440)
#define ID_DECODE10             (ID_LANG + 441)
#define ID_READWRITE            (ID_LANG + 442)
#define ID_READONLY             (ID_LANG + 443)
#define ID_RESCONSUMER          (ID_LANG + 444)
#define ID_RESPRODUCER          (ID_LANG + 445)
#define ID_SUBDECODE            (ID_LANG + 446)
#define ID_POSDECODE            (ID_LANG + 447)
#define ID_MINFIXED             (ID_LANG + 448)
#define ID_MINNOTFIXED          (ID_LANG + 449)
#define ID_MAXFIXED             (ID_LANG + 450)
#define ID_MAXNOTFIXED          (ID_LANG + 451)
#define ID_CACHEABLE            (ID_LANG + 452)
#define ID_WRCOMBINING          (ID_LANG + 453)
#define ID_PREFETCHABLE         (ID_LANG + 454)
#define ID_NONCACHEABLE         (ID_LANG + 455)
#define ID_ISAONLYRNG           (ID_LANG + 456)
#define ID_NONISAONLYRNG        (ID_LANG + 457)
#define ID_ENTIRERNG            (ID_LANG + 458)
#define ID_EXT_EDGE             (ID_LANG + 459)
#define ID_EXT_LEVEL            (ID_LANG + 460)
#define ID_EXT_ACTIVEHI         (ID_LANG + 461)
#define ID_EXT_ACTIVELO         (ID_LANG + 462)
#define ID_EXT_SHARED           (ID_LANG + 463)
#define ID_EXT_EXCLUSIVE        (ID_LANG + 464)
#define ID_UNKNOWN_OBJ          (ID_LANG + 465)
#define ID_INT_OBJ              (ID_LANG + 466)
#define ID_STR_OBJ              (ID_LANG + 467)
#define ID_BUFF_OBJ             (ID_LANG + 468)
#define ID_PKG_OBJ              (ID_LANG + 469)
#define ID_FIELDUNIT_OBJ        (ID_LANG + 470)
#define ID_DEV_OBJ              (ID_LANG + 471)
#define ID_EVENT_OBJ            (ID_LANG + 472)
#define ID_METHOD_OBJ           (ID_LANG + 473)
#define ID_MUTEX_OBJ            (ID_LANG + 474)
#define ID_OPREGION_OBJ         (ID_LANG + 475)
#define ID_POWERRES_OBJ         (ID_LANG + 476)
#define ID_THERMAL_OBJ          (ID_LANG + 477)
#define ID_BUFFFIELD_OBJ        (ID_LANG + 478)
#define ID_DDBHANDLE_OBJ        (ID_LANG + 479)

#define ID_OFFSET               (ID_LANG + 500)
#define ID_ACCESSAS             (ID_LANG + 501)

#define ID_BANKFIELD            (ID_LANG + 600)
#define ID_DEVICE               (ID_LANG + 601)
#define ID_EVENT                (ID_LANG + 602)
#define ID_FIELD                (ID_LANG + 603)
#define ID_IDXFIELD             (ID_LANG + 604)
#define ID_METHOD               (ID_LANG + 605)
#define ID_MUTEX                (ID_LANG + 606)
#define ID_OPREGION             (ID_LANG + 607)
#define ID_POWERRES             (ID_LANG + 608)
#define ID_PROCESSOR            (ID_LANG + 609)
#define ID_THERMALZONE          (ID_LANG + 610)

#define ID_BREAK                (ID_LANG + 700)
#define ID_BREAKPOINT           (ID_LANG + 701)
#define ID_BITFIELD             (ID_LANG + 702)
#define ID_BYTEFIELD            (ID_LANG + 703)
#define ID_DWORDFIELD           (ID_LANG + 704)
#define ID_CREATEFIELD          (ID_LANG + 705)
#define ID_WORDFIELD            (ID_LANG + 706)
#define ID_ELSE                 (ID_LANG + 707)
#define ID_FATAL                (ID_LANG + 708)
#define ID_IF                   (ID_LANG + 709)
#define ID_LOAD                 (ID_LANG + 710)
#define ID_NOP                  (ID_LANG + 711)
#define ID_NOTIFY               (ID_LANG + 712)
#define ID_RELEASE              (ID_LANG + 713)
#define ID_RESET                (ID_LANG + 714)
#define ID_RETURN               (ID_LANG + 715)
#define ID_SIGNAL               (ID_LANG + 716)
#define ID_SLEEP                (ID_LANG + 717)
#define ID_STALL                (ID_LANG + 718)
#define ID_UNLOAD               (ID_LANG + 719)
#define ID_WHILE                (ID_LANG + 720)

#define ID_ACQUIRE              (ID_LANG + 800)
#define ID_ADD                  (ID_LANG + 801)
#define ID_AND                  (ID_LANG + 802)
#define ID_CONCAT               (ID_LANG + 803)
#define ID_CONDREFOF            (ID_LANG + 804)
#define ID_DECREMENT            (ID_LANG + 805)
#define ID_DEREFOF              (ID_LANG + 806)
#define ID_DIVIDE               (ID_LANG + 807)
#define ID_FINDSETLBIT          (ID_LANG + 808)
#define ID_FINDSETRBIT          (ID_LANG + 809)
#define ID_FROMBCD              (ID_LANG + 810)
#define ID_INCREMENT            (ID_LANG + 811)
#define ID_INDEX                (ID_LANG + 812)
#define ID_LAND                 (ID_LANG + 813)
#define ID_LEQ                  (ID_LANG + 814)
#define ID_LG                   (ID_LANG + 815)
#define ID_LGEQ                 (ID_LANG + 816)
#define ID_LL                   (ID_LANG + 817)
#define ID_LLEQ                 (ID_LANG + 818)
#define ID_LNOT                 (ID_LANG + 819)
#define ID_LNOTEQ               (ID_LANG + 820)
#define ID_LOR                  (ID_LANG + 821)
#define ID_MATCH                (ID_LANG + 822)
#define ID_MULTIPLY             (ID_LANG + 823)
#define ID_NAND                 (ID_LANG + 824)
#define ID_NOR                  (ID_LANG + 825)
#define ID_NOT                  (ID_LANG + 826)
#define ID_OBJTYPE              (ID_LANG + 827)
#define ID_OR                   (ID_LANG + 828)
#define ID_REFOF                (ID_LANG + 829)
#define ID_SHIFTL               (ID_LANG + 830)
#define ID_SHIFTR               (ID_LANG + 831)
#define ID_SIZEOF               (ID_LANG + 832)
#define ID_STORE                (ID_LANG + 833)
#define ID_SUBTRACT             (ID_LANG + 834)
#define ID_TOBCD                (ID_LANG + 835)
#define ID_WAIT                 (ID_LANG + 836)
#define ID_XOR                  (ID_LANG + 837)

#define ID_RESTEMP              (ID_LANG + 1000)
#define ID_STARTDEPFNNOPRI      (ID_LANG + 1001)
#define ID_STARTDEPFN           (ID_LANG + 1002)
#define ID_ENDDEPFN             (ID_LANG + 1003)
#define ID_IRQNOFLAGS           (ID_LANG + 1004)
#define ID_IRQ                  (ID_LANG + 1005)
#define ID_DMA                  (ID_LANG + 1006)
#define ID_IO                   (ID_LANG + 1007)
#define ID_FIXEDIO              (ID_LANG + 1008)
#define ID_VENDORSHORT          (ID_LANG + 1009)
#define ID_MEMORY24             (ID_LANG + 1010)
#define ID_VENDORLONG           (ID_LANG + 1011)
#define ID_MEMORY32             (ID_LANG + 1012)
#define ID_MEMORY32FIXED        (ID_LANG + 1013)
#define ID_DWORDMEMORY          (ID_LANG + 1014)
#define ID_DWORDIO              (ID_LANG + 1015)
#define ID_WORDIO               (ID_LANG + 1016)
#define ID_WORDBUSNUMBER        (ID_LANG + 1017)
#define ID_INTERRUPT            (ID_LANG + 1018)
#define ID_QWORDMEMORY          (ID_LANG + 1019)
#define ID_QWORDIO              (ID_LANG + 1020)

//
// Operation region space
//
#define MEM     (REGSPACE_MEM | 0xff00)
#define IO      (REGSPACE_IO | 0xff00)
#define CFG     (REGSPACE_PCICFG | 0xff00)
#define EC      (REGSPACE_EC | 0xff00)
#define SMB     (REGSPACE_SMB | 0xff00)

//
// Method flags
//
#define SER     (METHOD_SERIALIZED | (METHOD_SYNCMASK << 8))
#define NOSER   (METHOD_NOTSERIALIZED | (METHOD_SYNCMASK << 8))

//
// Match operation values
//
#define OMTR    (MTR | 0xff00)
#define OMEQ    (MEQ | 0xff00)
#define OMLE    (MLE | 0xff00)
#define OMLT    (MLT | 0xff00)
#define OMGE    (MGE | 0xff00)
#define OMGT    (MGT | 0xff00)

ASLTERM TermTable[] =
{
    "DefinitionBlock",  ID_DEFBLK,       CD, 0, OP_NONE,     NULL, "ZZBZZD", NULL, OL|CL|LL|AF|AV, NULL,
    "Include",          ID_INCLUDE,      CD, 0, OP_NONE,     NULL, "Z",      NULL, AF, NULL,
    "External",         ID_EXTERNAL,     CD, 0, OP_NONE,     NULL, "Nk",     "uX", AF, NULL,

    // Short Objects
    "Zero",             ID_ZERO,         CN, 0, OP_ZERO,     NULL, NULL, NULL, 0, NULL,
    "One",              ID_ONE,          CN, 0, OP_ONE,      NULL, NULL, NULL, 0, NULL,
    "Ones",             ID_ONES,         CN, 0, OP_ONES,     NULL, NULL, NULL, 0, NULL,
    "Revision",         ID_REVISION,     CN, 0, OP_REVISION, NULL, NULL, NULL, 0, NULL,
    "Arg0",             ID_ARG0,         SN, 0, OP_ARG0,     NULL, NULL, NULL, 0, NULL,
    "Arg1",             ID_ARG1,         SN, 0, OP_ARG1,     NULL, NULL, NULL, 0, NULL,
    "Arg2",             ID_ARG2,         SN, 0, OP_ARG2,     NULL, NULL, NULL, 0, NULL,
    "Arg3",             ID_ARG3,         SN, 0, OP_ARG3,     NULL, NULL, NULL, 0, NULL,
    "Arg4",             ID_ARG4,         SN, 0, OP_ARG4,     NULL, NULL, NULL, 0, NULL,
    "Arg5",             ID_ARG5,         SN, 0, OP_ARG5,     NULL, NULL, NULL, 0, NULL,
    "Arg6",             ID_ARG6,         SN, 0, OP_ARG6,     NULL, NULL, NULL, 0, NULL,
    "Local0",           ID_LOCAL0,       SN, 0, OP_LOCAL0,   NULL, NULL, NULL, 0, NULL,
    "Local1",           ID_LOCAL1,       SN, 0, OP_LOCAL1,   NULL, NULL, NULL, 0, NULL,
    "Local2",           ID_LOCAL2,       SN, 0, OP_LOCAL2,   NULL, NULL, NULL, 0, NULL,
    "Local3",           ID_LOCAL3,       SN, 0, OP_LOCAL3,   NULL, NULL, NULL, 0, NULL,
    "Local4",           ID_LOCAL4,       SN, 0, OP_LOCAL4,   NULL, NULL, NULL, 0, NULL,
    "Local5",           ID_LOCAL5,       SN, 0, OP_LOCAL5,   NULL, NULL, NULL, 0, NULL,
    "Local6",           ID_LOCAL6,       SN, 0, OP_LOCAL6,   NULL, NULL, NULL, 0, NULL,
    "Local7",           ID_LOCAL7,       SN, 0, OP_LOCAL7,   NULL, NULL, NULL, 0, NULL,
    "Debug",            ID_DEBUG,        SN, 0, OP_DEBUG,    NULL, NULL, NULL, 0, NULL,

    // Named Terms
    "Alias",            ID_ALIAS,        NS, 0, OP_ALIAS,    "NN", "NN", "Ua", 0, NULL,
    "Name",             ID_NAME,         NS, 0, OP_NAME,     "NO", "NO", "u",  0, NULL,
    "Scope",            ID_SCOPE,        NS, 0, OP_SCOPE,    "N",  "N",  "S",  OL|LN, NULL,

    // Data Objects
    "Buffer",           ID_BUFFER,       DO, 0, OP_BUFFER,   "C", "c",  "U",  DL|LN, NULL,
    "Package",          ID_PACKAGE,      DO, 0, OP_PACKAGE,  "B", "b",  NULL, PL|LN, NULL,
    "EISAID",           ID_EISAID,       DO, 0, OP_DWORD,    NULL,"Z",  NULL, AF, NULL,

    // Argument Keywords
    "AnyAcc",           ID_ANYACC,       KW, AANY, OP_NONE, NULL, NULL, "A", 0, NULL,
    "ByteAcc",          ID_BYTEACC,      KW, AB,   OP_NONE, NULL, NULL, "A", 0, NULL,
    "WordAcc",          ID_WORDACC,      KW, AW,   OP_NONE, NULL, NULL, "A", 0, NULL,
    "DWordAcc",         ID_DWORDACC,     KW, ADW,  OP_NONE, NULL, NULL, "A", 0, NULL,
    "BlockAcc",         ID_BLOCKACC,     KW, ABLK, OP_NONE, NULL, NULL, "A", 0, NULL,
    "SMBSendRecvAcc",   ID_SMBSENDRCVACC,KW, ASSR, OP_NONE, NULL, NULL, "A", 0, NULL,
    "SMBQuickAcc",      ID_SMBQUICKACC,  KW, ASQ,  OP_NONE, NULL, NULL, "A", 0, NULL,

    "Lock",             ID_LOCK,         KW, LK,   OP_NONE, NULL, NULL, "B", 0, NULL,
    "NoLock",           ID_NOLOCK,       KW, NOLK, OP_NONE, NULL, NULL, "B", 0, NULL,

    "Preserve",         ID_PRESERVE,     KW, PSRV, OP_NONE, NULL, NULL, "C", 0, NULL,
    "WriteAsOnes",      ID_WRONES,       KW, WA1S, OP_NONE, NULL, NULL, "C", 0, NULL,
    "WriteAsZeros",     ID_WRZEROS,      KW, WA0S, OP_NONE, NULL, NULL, "C", 0, NULL,

    "SystemMemory",     ID_SYSMEM,       KW, MEM,  OP_NONE, NULL, NULL, "D", 0, NULL,
    "SystemIO",         ID_SYSIO,        KW, IO,   OP_NONE, NULL, NULL, "D", 0, NULL,
    "PCI_Config",       ID_PCICFG,       KW, CFG,  OP_NONE, NULL, NULL, "D", 0, NULL,
    "EmbeddedControl",  ID_EMBCTRL,      KW, EC,   OP_NONE, NULL, NULL, "D", 0, NULL,
    "SMBus",            ID_SMBUS,        KW, SMB,  OP_NONE, NULL, NULL, "D", 0, NULL,

    "Serialized",       ID_SERIALIZED,   KW, SER,  OP_NONE, NULL, NULL, "E", 0, NULL,
    "NotSerialized",    ID_NOTSERIALIZED,KW, NOSER,OP_NONE, NULL, NULL, "E", 0, NULL,

    "MTR",              ID_MTR,          KW, OMTR, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MEQ",              ID_MEQ,          KW, OMEQ, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MLE",              ID_MLE,          KW, OMLE, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MLT",              ID_MLT,          KW, OMLT, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MGE",              ID_MGE,          KW, OMGE, OP_NONE, NULL, NULL, "F", 0, NULL,
    "MGT",              ID_MGT,          KW, OMGT, OP_NONE, NULL, NULL, "F", 0, NULL,

    "Edge",             ID_EDGE,         KW, _HE,  OP_NONE, NULL, NULL, "G", 0, NULL,
    "Level",            ID_LEVEL,        KW, _LL,  OP_NONE, NULL, NULL, "G", 0, NULL,

    "ActiveHigh",       ID_ACTIVEHI,     KW, _HE,  OP_NONE, NULL, NULL, "H", 0, NULL,
    "ActiveLow",        ID_ACTIVELO,     KW, _LL,  OP_NONE, NULL, NULL, "H", 0, NULL,

    "Shared",           ID_SHARED,       KW, _SHR, OP_NONE, NULL, NULL, "I", 0, NULL,
    "Exclusive",        ID_EXCLUSIVE,    KW, _EXC, OP_NONE, NULL, NULL, "I", 0, NULL,

    "Compatibility",    ID_COMPAT,       KW, COMP, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeA",            ID_TYPEA,        KW, TYPA, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeB",            ID_TYPEB,        KW, TYPB, OP_NONE, NULL, NULL, "J", 0, NULL,
    "TypeF",            ID_TYPEF,        KW, TYPF, OP_NONE, NULL, NULL, "J", 0, NULL,

    "BusMaster",        ID_BUSMASTER,    KW, BM,   OP_NONE, NULL, NULL, "K", 0, NULL,
    "NotBusMaster",     ID_NOTBUSMASTER, KW, NOBM, OP_NONE, NULL, NULL, "K", 0, NULL,

    "Transfer8",        ID_TRANSFER8,    KW, X8,   OP_NONE, NULL, NULL, "L", 0, NULL,
    "Transfer8_16",     ID_TRANSFER8_16, KW, X816, OP_NONE, NULL, NULL, "L", 0, NULL,
    "Transfer16",       ID_TRANSFER16,   KW, X16,  OP_NONE, NULL, NULL, "L", 0, NULL,

    "Decode16",         ID_DECODE16,     KW, DC16, OP_NONE, NULL, NULL, "M", 0, NULL,
    "Decode10",         ID_DECODE10,     KW, DC10, OP_NONE, NULL, NULL, "M", 0, NULL,

    "ReadWrite",        ID_READWRITE,    KW, _RW,  OP_NONE, NULL, NULL, "N", 0, NULL,
    "ReadOnly",         ID_READONLY,     KW, _ROM, OP_NONE, NULL, NULL, "N", 0, NULL,

    "ResourceConsumer", ID_RESCONSUMER,  KW, RCS,  OP_NONE, NULL, NULL, "O", 0, NULL,
    "ResourceProducer", ID_RESPRODUCER,  KW, RPD,  OP_NONE, NULL, NULL, "O", 0, NULL,

    "SubDecode",        ID_SUBDECODE,    KW, BSD,  OP_NONE, NULL, NULL, "P", 0, NULL,
    "PosDecode",        ID_POSDECODE,    KW, BPD,  OP_NONE, NULL, NULL, "P", 0, NULL,

    "MinFixed",         ID_MINFIXED,     KW, MIF,  OP_NONE, NULL, NULL, "Q", 0, NULL,
    "MinNotFixed",      ID_MINNOTFIXED,  KW, NMIF, OP_NONE, NULL, NULL, "Q", 0, NULL,

    "MaxFixed",         ID_MAXFIXED,     KW, MAF,  OP_NONE, NULL, NULL, "R", 0, NULL,
    "MaxNotFixed",      ID_MAXNOTFIXED,  KW, NMAF, OP_NONE, NULL, NULL, "R", 0, NULL,

    "Cacheable",        ID_CACHEABLE,    KW, CACH, OP_NONE, NULL, NULL, "S", 0, NULL,
    "WriteCombining",   ID_WRCOMBINING,  KW, WRCB, OP_NONE, NULL, NULL, "S", 0, NULL,
    "Prefetchable",     ID_PREFETCHABLE, KW, PREF, OP_NONE, NULL, NULL, "S", 0, NULL,
    "NonCacheable",     ID_NONCACHEABLE, KW, NCAC, OP_NONE, NULL, NULL, "S", 0, NULL,

    "ISAOnlyRanges",    ID_ISAONLYRNG,   KW, ISA,  OP_NONE, NULL, NULL, "T", 0, NULL,
    "NonISAOnlyRanges", ID_NONISAONLYRNG,KW, NISA, OP_NONE, NULL, NULL, "T", 0, NULL,
    "EntireRange",      ID_ENTIRERNG,    KW, ERNG, OP_NONE, NULL, NULL, "T", 0, NULL,

    "ExtEdge",          ID_EXT_EDGE,     KW, ($HGH | $EDG),  OP_NONE, NULL, NULL, "U", 0, NULL,
    "ExtLevel",         ID_EXT_LEVEL,    KW, ($LOW | $LVL),  OP_NONE, NULL, NULL, "U", 0, NULL,

    "ExtActiveHigh",    ID_EXT_ACTIVEHI, KW, ($HGH | $EDG),  OP_NONE, NULL, NULL, "V", 0, NULL,
    "ExtActiveLow",     ID_EXT_ACTIVELO, KW, ($LOW | $LVL),  OP_NONE, NULL, NULL, "V", 0, NULL,

    "ExtShared",        ID_EXT_SHARED,   KW, $SHR, OP_NONE, NULL, NULL, "W", 0, NULL,
    "ExtExclusive",     ID_EXT_EXCLUSIVE,KW, $EXC, OP_NONE, NULL, NULL, "W", 0, NULL,

    "UnknownObj",       ID_UNKNOWN_OBJ,  KW, UNK,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "IntObj",           ID_INT_OBJ,      KW, INT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "StrObj",           ID_STR_OBJ,      KW, STR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "BuffObj",          ID_BUFF_OBJ,     KW, BUF,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "PkgObj",           ID_PKG_OBJ,      KW, PKG,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "FieldUnitObj",     ID_FIELDUNIT_OBJ,KW, FDU,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "DeviceObj",        ID_DEV_OBJ,      KW, DEV,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "EventObj",         ID_EVENT_OBJ,    KW, EVT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "MethodObj",        ID_METHOD_OBJ,   KW, MET,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "MutexObj",         ID_MUTEX_OBJ,    KW, MUT,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "OpRegionObj",      ID_OPREGION_OBJ, KW, OPR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "PowerResObj",      ID_POWERRES_OBJ, KW, PWR,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "ThermalZoneObj",   ID_THERMAL_OBJ,  KW, THM,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "BuffFieldObj",     ID_BUFFFIELD_OBJ,KW, BFD,  OP_NONE, NULL, NULL, "X", 0, NULL,
    "DDBHandleObj",     ID_DDBHANDLE_OBJ,KW, DDB,  OP_NONE, NULL, NULL, "X", 0, NULL,

    // Field Macros
    "Offset",           ID_OFFSET,       FM, 0, OP_NONE, NULL, "B",  NULL, 0,  NULL,
    "AccessAs",         ID_ACCESSAS,     FM, 0, 0x01,    NULL, "Kb", "A", AF, NULL,

    // Named Object Creators
    "BankField",        ID_BANKFIELD,    NO, 0, OP_BANKFIELD,  "NNCKkk","NNCKKK","OFUABC", FL|FM|LN|AF, NULL,
    "Device",           ID_DEVICE,       NO, 0, OP_DEVICE,     "N",    "N",      "d",      OL|LN, NULL,
    "Event",            ID_EVENT,        NO, 0, OP_EVENT,      "N",    "N",      "e",      0, NULL,
    "Field",            ID_FIELD,        NO, 0, OP_FIELD,      "NKkk", "NKKK",   "OABC",   FL|FM|LN|AF, NULL,
    "IndexField",       ID_IDXFIELD,     NO, 0, OP_IDXFIELD,   "NNKkk","NNKKK",  "FFABC",  FL|FM|LN|AF, NULL,
    "Method",           ID_METHOD,       NO, 0, OP_METHOD,     "NKk",  "Nbk",    "m!E",    CL|OL|LN|AF, NULL,
    "Mutex",            ID_MUTEX,        NO, 0, OP_MUTEX,      "NB",   "NB",     "x",      0,  NULL,
    "OperationRegion",  ID_OPREGION,     NO, 0, OP_OPREGION,   "NKCC", "NKCC",   "oDUU",   AF, NULL,
    "PowerResource",    ID_POWERRES,     NO, 0, OP_POWERRES,   "NBW",  "NBW",    "p",      OL|LN, NULL,
    "Processor",        ID_PROCESSOR,    NO, 0, OP_PROCESSOR,  "NBDB", "NBDB",   "c",      OL|LN, NULL,
    "ThermalZone",      ID_THERMALZONE,  NO, 0, OP_THERMALZONE,"N",    "N",      "t",      OL|LN, NULL,

    // Type 1 Opcode Terms
    "Break",            ID_BREAK,        C1, 0, OP_BREAK,       NULL,  NULL,  NULL, 0, NULL,
    "BreakPoint",       ID_BREAKPOINT,   C1, 0, OP_BREAKPOINT,  NULL,  NULL,  NULL, 0, NULL,
    "CreateBitField",   ID_BITFIELD,     C1, 0, OP_BITFIELD,    "CCN", "CPN", "UUb",0, NULL,
    "CreateByteField",  ID_BYTEFIELD,    C1, 0, OP_BYTEFIELD,   "CCN", "CMN", "UUb",0, NULL,
    "CreateDWordField", ID_DWORDFIELD,   C1, 0, OP_DWORDFIELD,  "CCN", "CMN", "UUb",0, NULL,
    "CreateField",      ID_CREATEFIELD,  C1, 0, OP_CREATEFIELD, "CCCN","CPCN","UUUb",0,NULL,
    "CreateWordField",  ID_WORDFIELD,    C1, 0, OP_WORDFIELD,   "CCN", "CMN", "UUb",0, NULL,
    "Else",             ID_ELSE,         C1, 0, OP_ELSE,        NULL,  NULL,  NULL, AF|CL|LN, NULL,
    "Fatal",            ID_FATAL,        C1, 0, OP_FATAL,       "BDC", "BDC", "  U",0, NULL,
    "If",               ID_IF,           C1, 0, OP_IF,          "C",   "C",   "U",  CL|LN, NULL,
    "Load",             ID_LOAD,         C1, 0, OP_LOAD,        "NS",  "NS",  "UU", 0, NULL,
    "Noop",             ID_NOP,          C1, 0, OP_NOP,         NULL,  NULL,  NULL, 0, NULL,
    "Notify",           ID_NOTIFY,       C1, 0, OP_NOTIFY,      "SC",  "SC",  "UU", 0, NULL,
    "Release",          ID_RELEASE,      C1, 0, OP_RELEASE,     "S",   "S",   "X",  0, NULL,
    "Reset",            ID_RESET,        C1, 0, OP_RESET,       "S",   "S",   "E",  0, NULL,
    "Return",           ID_RETURN,       C1, 0, OP_RETURN,      "C",   "C",   "U",  0, NULL,
    "Signal",           ID_SIGNAL,       C1, 0, OP_SIGNAL,      "S",   "S",   "E",  0, NULL,
    "Sleep",            ID_SLEEP,        C1, 0, OP_SLEEP,       "C",   "C",   "U",  0, NULL,
    "Stall",            ID_STALL,        C1, 0, OP_STALL,       "C",   "C",   "U",  0, NULL,
    "Unload",           ID_UNLOAD,       C1, 0, OP_UNLOAD,      "S",   "S",   "U",  0, NULL,
    "While",            ID_WHILE,        C1, 0, OP_WHILE,       "C",   "C",   "U",  CL|LN, NULL,

    // Type 2 Opcode Terms
    "Acquire",          ID_ACQUIRE,      C2, 0, OP_ACQUIRE,     "SW",     "SW",     "X",  0, NULL,
    "Add",              ID_ADD,          C2, 0, OP_ADD,         "CCS",    "CCs",    "UUU",0, NULL,
    "And",              ID_AND,          C2, 0, OP_AND,         "CCS",    "CCs",    "UUU",0, NULL,
    "Concatenate",      ID_CONCAT,       C2, 0, OP_CONCAT,      "CCS",    "CCS",    "UUU",0, NULL,
    "CondRefOf",        ID_CONDREFOF,    C2, 0, OP_CONDREFOF,   "SS",     "SS",     "UU", 0, NULL,
    "Decrement",        ID_DECREMENT,    C2, 0, OP_DECREMENT,   "S",      "S",      "U",  0, NULL,
    "DerefOf",          ID_DEREFOF,      C2, 0, OP_DEREFOF,     "C",      "C",      "U",  0, NULL,
    "Divide",           ID_DIVIDE,       C2, 0, OP_DIVIDE,      "CCSS",   "CCss",   "UUUU",0,NULL,
    "FindSetLeftBit",   ID_FINDSETLBIT,  C2, 0, OP_FINDSETLBIT, "CS",     "Cs",     "UU", 0, NULL,
    "FindSetRightBit",  ID_FINDSETRBIT,  C2, 0, OP_FINDSETRBIT, "CS",     "Cs",     "UU", 0, NULL,
    "FromBCD",          ID_FROMBCD,      C2, 0, OP_FROMBCD,     "CS",     "Cs",     "UU", 0, NULL,
    "Increment",        ID_INCREMENT,    C2, 0, OP_INCREMENT,   "S",      "S",      "U",  0, NULL,
    "Index",            ID_INDEX,     RO|C2, 0, OP_INDEX,       "CCS",    "CMs",    "UUU",0, NULL,
    "LAnd",             ID_LAND,         C2, 0, OP_LAND,        "CC",     "CC",     "UU", 0, NULL,
    "LEqual",           ID_LEQ,          C2, 0, OP_LEQ,         "CC",     "CC",     "UU", 0, NULL,
    "LGreater",         ID_LG,           C2, 0, OP_LG,          "CC",     "CC",     "UU", 0, NULL,
    "LGreaterEqual",    ID_LGEQ,         C2, 0, OP_LGEQ,        "CC",     "CC",     "UU", 0, NULL,
    "LLess",            ID_LL,           C2, 0, OP_LL,          "CC",     "CC",     "UU", 0, NULL,
    "LLessEqual",       ID_LLEQ,         C2, 0, OP_LLEQ,        "CC",     "CC",     "UU", 0, NULL,
    "LNot",             ID_LNOT,         C2, 0, OP_LNOT,        "C",      "C",      "U",  0, NULL,
    "LNotEqual",        ID_LNOTEQ,       C2, 0, OP_LNOTEQ,      "CC",     "CC",     "UU", 0, NULL,
    "LOr",              ID_LOR,          C2, 0, OP_LOR,         "CC",     "CC",     "UU", 0, NULL,
    "Match",            ID_MATCH,        C2, 0, OP_MATCH,       "CKCKCC", "CKCKCC", "UFUFUU",AF,NULL,
    "Multiply",         ID_MULTIPLY,     C2, 0, OP_MULTIPLY,    "CCS",    "CCs",    "UUU",0, NULL,
    "NAnd",             ID_NAND,         C2, 0, OP_NAND,        "CCS",    "CCs",    "UUU",0, NULL,
    "NOr",              ID_NOR,          C2, 0, OP_NOR,         "CCS",    "CCs",    "UUU",0, NULL,
    "Not",              ID_NOT,          C2, 0, OP_NOT,         "CS",     "Cs",     "UU", 0, NULL,
    "ObjectType",       ID_OBJTYPE,      C2, 0, OP_OBJTYPE,     "S",      "S",      "U",  0, NULL,
    "Or",               ID_OR,           C2, 0, OP_OR,          "CCS",    "CCs",    "UUU",0, NULL,
    "RefOf",            ID_REFOF,        C2, 0, OP_REFOF,       "S",      "S",      "U",  0, NULL,
    "ShiftLeft",        ID_SHIFTL,       C2, 0, OP_SHIFTL,      "CCS",    "CCs",    "UUU",0, NULL,
    "ShiftRight",       ID_SHIFTR,       C2, 0, OP_SHIFTR,      "CCS",    "CCs",    "UUU",0, NULL,
    "SizeOf",           ID_SIZEOF,       C2, 0, OP_SIZEOF,      "S",      "S",      "U",  0, NULL,
    "Store",            ID_STORE,        C2, 0, OP_STORE,       "CS",     "CS",     "UU", 0, NULL,
    "Subtract",         ID_SUBTRACT,     C2, 0, OP_SUBTRACT,    "CCS",    "CCs",    "UUU",0, NULL,
    "ToBCD",            ID_TOBCD,        C2, 0, OP_TOBCD,       "CS",     "Cs",     "UU", 0, NULL,
    "Wait",             ID_WAIT,         C2, 0, OP_WAIT,        "SC",     "SC",     "E",  0, NULL,
    "XOr",              ID_XOR,          C2, 0, OP_XOR,         "CCS",    "CCs",    "UUU",0, NULL,

    // PNP Macros
    "ResourceTemplate", ID_RESTEMP,      DO, 0, OP_BUFFER, NULL, "",       NULL, ML|AF|AV|LN,NULL,
    "StartDependentFnNoPri",ID_STARTDEPFNNOPRI,PM,0,0x30,  NULL, "",       NULL, ML|AF,   NULL,
    "StartDependentFn", ID_STARTDEPFN,   PM, 0, 0x31,      NULL, "BB",     NULL, ML|AF,   NULL,
    "EndDependentFn",   ID_ENDDEPFN,     PM, 0, 0x38,      NULL, "",       NULL, AF,      NULL,
    "IRQNoFlags",       ID_IRQNOFLAGS,   PM, 0, 0x22,      NULL, "r",      NULL, BL|AV,   NULL,
    "IRQ",              ID_IRQ,          PM, 0, 0x23,      NULL, "KKkr",   "GHI",BL|AV,   NULL,
    "DMA",              ID_DMA,          PM, 0, 0x2a,      NULL, "KKKr",   "JKL",BL|AV,   NULL,
    "IO",               ID_IO,           PM, 0, 0x47,      NULL, "KWWBBr", "M",  AF,      NULL,
    "FixedIO",          ID_FIXEDIO,      PM, 0, 0x4b,      NULL, "WBr",    NULL, AF,      NULL,
    "VendorShort",      ID_VENDORSHORT,  PM, 0, OP_NONE,   NULL, "r",      NULL, BL|AV,   NULL,
    "Memory24",         ID_MEMORY24,     PM, 0, 0x81,      NULL, "KWWWWr", "N",  AF,      NULL,
    "VendorLong",       ID_VENDORLONG,   PM, 0, 0x84,      NULL, "r",      NULL, BL|AV,   NULL,
    "Memory32",         ID_MEMORY32,     PM, 0, 0x85,      NULL, "KDDDDr", "N",  AF,      NULL,
    "Memory32Fixed",    ID_MEMORY32FIXED,PM, 0, 0x86,      NULL, "KDDr",   "N",  AF,      NULL,
    "DWORDMemory",      ID_DWORDMEMORY,  PM, 0, 0x87,      NULL, "kkkkkKDDDDDbzr","OPQRSN",AF,  NULL,
    "DWORDIO",          ID_DWORDIO,      PM, 0, 0x87,      NULL, "kkkkkDDDDDbzr", "OQRPT", AF,  NULL,
    "WORDIO",           ID_WORDIO,       PM, 0, 0x88,      NULL, "kkkkkWWWWWbzr", "OQRPT", AF,  NULL,
    "WORDBusNumber",    ID_WORDBUSNUMBER,PM, 0, 0x88,      NULL, "kkkkWWWWWbzr",  "OQRP",  AF,  NULL,
    "Interrupt",        ID_INTERRUPT,    PM, 0, 0x89,      NULL, "kKKkbzr",       "OGHI",DD|AV, NULL,
    "QWORDMemory",      ID_QWORDMEMORY,  PM, 0, 0x8a,      NULL, "kkkkkKQQQQQbzr","OPQRSN",AF,  NULL,
    "QWORDIO",          ID_QWORDIO,      PM, 0, 0x8a,      NULL, "kkkkkQQQQQbzr", "OQRPT", AF,  NULL,

    NULL,               0,               0,  0, OP_NONE,   NULL, NULL, NULL, 0, NULL
};

#define INVALID  OPCLASS_INVALID
#define DATAOBJ  OPCLASS_DATA_OBJ
#define NAMEOBJ  OPCLASS_NAME_OBJ
#define CONSTOBJ OPCLASS_CONST_OBJ
#define CODEOBJ  OPCLASS_CODE_OBJ
#define ARGOBJ   OPCLASS_ARG_OBJ
#define LOCALOBJ OPCLASS_LOCAL_OBJ

UCHAR OpClassTable[256] =
{ //0x00                0x01                0x02                0x03
    CONSTOBJ,           CONSTOBJ,           INVALID,            INVALID,
  //0x04                0x05                0x06                0x07
    INVALID,            INVALID,            CODEOBJ,            INVALID,
  //0x08                0x09                0x0a                0x0b
    CODEOBJ,            INVALID,            DATAOBJ,            DATAOBJ,
  //0x0c                0x0d                0x0e                0x0f
    DATAOBJ,            DATAOBJ,            INVALID,            INVALID,
  //0x10                0x11                0x12                0x13
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x14                0x15                0x16                0x17
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0x18                0x19                0x1a                0x1b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x1c                0x1d                0x1e                0x1f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x20                0x21                0x22                0x23
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x24                0x25                0x26                0x27
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x28                0x29                0x2a                0x2b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x2c                0x2d                0x2e                0x2f
    INVALID,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x30                0x31                0x32                0x33
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x34                0x35                0x36                0x37
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x38                0x39                0x3a                0x3b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x3c                0x3d                0x3e                0x3f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x40                0x41                0x42                0x43
    INVALID,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x44                0x45                0x46                0x47
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x48                0x49                0x4a                0x4b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x4c                0x4d                0x4e                0x4f
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x50                0x51                0x52                0x53
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x54                0x55                0x56                0x57
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            NAMEOBJ,
  //0x58                0x59                0x5a                0x5b
    NAMEOBJ,            NAMEOBJ,            NAMEOBJ,            INVALID,
  //0x5c                0x5d                0x5e                0x5f
    NAMEOBJ,            INVALID,            NAMEOBJ,            NAMEOBJ,
  //0x60                0x61                0x62                0x63
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x64                0x65                0x66                0x67
    LOCALOBJ,           LOCALOBJ,           LOCALOBJ,           LOCALOBJ,
  //0x68                0x69                0x6a                0x6b
    ARGOBJ,             ARGOBJ,             ARGOBJ,             ARGOBJ,
  //0x6c                0x6d                0x6e                0x6f
    ARGOBJ,             ARGOBJ,             ARGOBJ,             INVALID,
  //0x70                0x71                0x72                0x73
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x74                0x75                0x76                0x77
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x78                0x79                0x7a                0x7b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x7c                0x7d                0x7e                0x7f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x80                0x81                0x82                0x83
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x84                0x85                0x86                0x87
    INVALID,            INVALID,            CODEOBJ,            CODEOBJ,
  //0x88                0x89                0x8a                0x8b
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x8c                0x8d                0x8e                0x8f
    CODEOBJ,            CODEOBJ,            CODEOBJ,            INVALID,
  //0x90                0x91                0x92                0x93
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0x94                0x95                0x96                0x97
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0x98                0x99                0x9a                0x9b
    INVALID,            INVALID,            INVALID,            INVALID,
  //0x9c                0x9d                0x9e                0x9f
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xa0                0xa1                0xa2                0xa3
    CODEOBJ,            CODEOBJ,            CODEOBJ,            CODEOBJ,
  //0xa4                0xa5                0xa6                0xa7
    CODEOBJ,            CODEOBJ,            INVALID,            INVALID,
  //0xa8                0xa9                0xaa                0xab
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xac                0xad                0xae                0xaf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb0                0xb1                0xb2                0xb3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb4                0xb5                0xb6                0xb7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xb8                0xb9                0xba                0xbb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xbc                0xbd                0xbe                0xbf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc0                0xc1                0xc2                0xc3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc4                0xc5                0xc6                0xc7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xc8                0xc9                0xca                0xcb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xcc                0xcd                0xce                0xcf
    CODEOBJ,            INVALID,            INVALID,            INVALID,
  //0xd0                0xd1                0xd2                0xd3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd4                0xd5                0xd6                0xd7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xd8                0xd9                0xda                0xdb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xdc                0xdd                0xde                0xdf
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe0                0xe1                0xe2                0xe3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe4                0xe5                0xe6                0xe7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xe8                0xe9                0xea                0xeb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xec                0xed                0xee                0xef
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf0                0xf1                0xf2                0xf3
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf4                0xf5                0xf6                0xf7
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xf8                0xf9                0xfa                0xfb
    INVALID,            INVALID,            INVALID,            INVALID,
  //0xfc                0xfd                0xfe                0xff
    INVALID,            INVALID,            INVALID,            CONSTOBJ
};

OPMAP ExOpClassTable[] =
{
    EXOP_MUTEX,         CODEOBJ,
    EXOP_EVENT,         CODEOBJ,
    EXOP_CONDREFOF,     CODEOBJ,
    EXOP_CREATEFIELD,   CODEOBJ,
    EXOP_LOAD,          CODEOBJ,
    EXOP_STALL,         CODEOBJ,
    EXOP_SLEEP,         CODEOBJ,
    EXOP_ACQUIRE,       CODEOBJ,
    EXOP_SIGNAL,        CODEOBJ,
    EXOP_WAIT,          CODEOBJ,
    EXOP_RESET,         CODEOBJ,
    EXOP_RELEASE,       CODEOBJ,
    EXOP_FROMBCD,       CODEOBJ,
    EXOP_TOBCD,         CODEOBJ,
    EXOP_UNLOAD,        CODEOBJ,
    EXOP_REVISION,      CODEOBJ,
    EXOP_DEBUG,         CODEOBJ,
    EXOP_FATAL,         CODEOBJ,
    EXOP_OPREGION,      CODEOBJ,
    EXOP_FIELD,         CODEOBJ,
    EXOP_DEVICE,        CODEOBJ,
    EXOP_PROCESSOR,     CODEOBJ,
    EXOP_POWERRES,      CODEOBJ,
    EXOP_THERMALZONE,   CODEOBJ,
    EXOP_IDXFIELD,      CODEOBJ,
    EXOP_BANKFIELD,     CODEOBJ,
    0,                  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\acpiuasm.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    apciuasm.c

Abstract:

    This unassembles an AML file

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <memory.h>
#include <crt\io.h>
#include <fcntl.h>
#include <windows.h>
#include <windef.h>

#define SPEC_VER    100
#include "acpitabl.h"
#include "unasmdll.h"
#include "parsearg.h"

ULONG   ParseOutput( PUCHAR *Argument, PARGTYPE TableEntry );
ULONG   PrintHelp(PUCHAR    *Argument, PARGTYPE TableEntry );
VOID    PrintOutput(PCCHAR  Format, ... );

ARGTYPE ArgTypes[] = {
    { "?",  AT_ACTION,  0,              PrintHelp,              0, NULL },
    { "Fo", AT_ACTION,  PF_SEPARATOR,   ParseOutput,            0, NULL },
    { "" ,  0,          0,              0,                      0, NULL }
};
#pragma warning(default: 4054)
PROGINFO    ProgInfo = { NULL, NULL, NULL, NULL };
FILE *outputHandle;

int
__cdecl
main(
    IN  int     argc,
    IN  char    *argv[]
    )
/*++

Routine Description:

    This routine unassembles and displays a file

Arguments:

    argc    - Number of Arguments
    argv    - Array of Arruments

Return Value:

    int

--*/
{
    int         rc;
    int         handle;
    NTSTATUS    result;
    PUCHAR      byte = NULL;
    ULONG       length;
    ULONG       readLength;

    outputHandle = stdout;

    //
    // Beging by initializing the program information
    //
    ParseProgramInfo( argv[0], &ProgInfo );
    argv++;
    argc--;

    //
    // Parse all the switches away
    //
    if (ParseSwitches( &argc, &argv, ArgTypes, &ProgInfo) != ARGERR_NONE ||
        argc != 1) {

        PrintHelp( NULL, NULL );
        return 0;

    }

    //
    // Open the remaining argument as our input file
    //
    handle = _open( argv[0], _O_BINARY | _O_RDONLY);
    if (handle == -1) {

        fprintf( stderr, "%s: Failed to open AML file - %s\n",
            ProgInfo.ProgName, argv[0] );
        return -1;

    }

    byte = malloc( sizeof(DESCRIPTION_HEADER) );
    if (byte == NULL) {

        fprintf( stderr, "%s: Failed to allocate description header block\n",
            ProgInfo.ProgName );
        return -2;

    }

    rc = _read( handle, byte, sizeof(DESCRIPTION_HEADER) );
    if (rc != sizeof(DESCRIPTION_HEADER) ) {

        fprintf( stderr, "%s: Failed to read description header block\n",
            ProgInfo.ProgName );
        return -3;

    }

    rc = _lseek( handle, 0, SEEK_SET);
    if (rc == -1) {

        fprintf( stderr, "%s: Failed seeking to beginning of file\n",
            ProgInfo.ProgName );
        return -4;

    }

    length = ( (PDESCRIPTION_HEADER) byte)->Length;
    free (byte);

    byte = malloc( length );
    if (byte == NULL) {

        fprintf( stderr, "%s: Failed to allocate AML file buffer\n",
            ProgInfo.ProgName );
        return -5;

    }

    readLength = (ULONG) _read( handle, byte, length );
    if (readLength != length) {

        fprintf( stderr, "%s: failed to read AML file\n",
            ProgInfo.ProgName );
        return - 6;

    }

    result = UnAsmLoadDSDT( byte );
    if (result == 0) {

        result = UnAsmDSDT( byte, PrintOutput, 0, 0 );

    }

    if (result != 0) {

        fprintf(stderr, "%s: result = 0x%08lx\n",
            ProgInfo.ProgName, result );

    }

    if (byte) {

        free(byte);

    }
    if (handle) {

        _close(handle);

    }

    return 0;
}

ULONG
ParseOutput(
    PUCHAR      *Argument,
    PARGTYPE    TableEntry
    )
/*++

Routine Description:

    This routine is called if the user specifies a different file to output
    things to

Arguments:

    Argument    - Pointer to the string
    TableEntry  - Which table entry was matched

Return Value:

    ULONG

--*/
{
    if (*Argument == '\0') {

        return ARGERR_INVALID_TAIL;

    }

    outputHandle = fopen( *Argument, "w" );
    if (outputHandle == NULL) {

        fprintf( stderr, "Failed to open AML file - %s\n", *Argument );
        return ARGERR_INVALID_TAIL;

    }
    return ARGERR_NONE;
}

ULONG
PrintHelp(
    PUCHAR      *Argument,
    PARGTYPE    TableEntry
    )
/*++

Routine Description:

    Print the help for the function

Arguments:

    Argument    - Pointer to the string
    TableEntry  - Which table entry was matched

Return Value:

    ULONG
--*/
{
    if (Argument != NULL) {

        printf("Error on Argument - \"%s\"\n", *Argument );

    }
    printf("Usage:\t%s /?\n", ProgInfo.ProgName );
    printf("\t%s [/Fo=<ASLFile>] <AMLFile>\n", ProgInfo.ProgName );
    printf("\t?             - Print this help message.\n");
    printf("\tFo=ASLFile    - Write output to ASLFile.\n");
    printf("\tAMLFile       - AML File to Unassemble\n");
    return ARGERR_NONE;
}

VOID
PrintOutput(
    PCCHAR  Format,
    ...
    )
/*++

Routine Description:

    This routine is called to display information to the user

Arguments:

    Format  - Character formating
    ...     - Arguments

Return Value:

    Null

--*/
{
    va_list marker;
    va_start( marker, Format );
    vfprintf( outputHandle, Format, marker );
    fflush( outputHandle );
    va_end( marker );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\ustring.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    string.c

Abstract:

    The string stack portion of the un-assembler

Author:

    Stephane Plante

Environment:

    Any

Revision History:

--*/

#include "pch.h"

NTSTATUS
StringStackAllocate(
    OUT     PSTRING_STACK  *StringStack
    )
/*++

Routine Description:

    This routine allocates memory and returns a string stack object

Arguments:

    String Stack    - Where to store a pointer to the stack

Return Value:

    NTSTATUS

--*/
{
    PSTRING_STACK   tempStack;
    NTSTATUS        status  = STATUS_SUCCESS;

    //
    // Make sure that we have some place to store the stack pointer
    //
    ASSERT( StringStack != NULL );

    //
    // Allocate a block of memory for the stack
    //
    tempStack = MEMORY_ALLOCATE(
        sizeof(STRING_STACK) + ( STRING_GROWTH_RATE - 1 )
        );
    if (tempStack == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto StringStackAllocateExit;
    }

    //
    // Setup the control block of the stack
    //
    tempStack->Signature        = (ULONG) STRING_SIGNATURE;
    tempStack->StackSize        = STRING_GROWTH_RATE;
    tempStack->TopOfStack       = 0;

    //
    // Zero out the current elements on the stack
    //
    MEMORY_ZERO( tempStack->Stack, STRING_GROWTH_RATE );

    //
    // Return the stack pointer
    //
StringStackAllocateExit:
    *StringStack = tempStack;
    return status;

}

NTSTATUS
StringStackClear(
    IN  OUT PSTRING_STACK   *StringStack
    )
/*++

Routine Description:

    This routine wipes out the contents of the stack and
    restarts it as if it was new allocated. Saves some from
    freeing and reallocating a stack

Arguments:

    StringStack - Where to find a pointer to the stack

Return Value:

    NTSTATUS

--*/
{
    PSTRING_STACK   localStack;

    //
    // Make sure that we point to something
    //
    ASSERT( StringStack != NULL && *StringStack != NULL );
    ASSERT( (*StringStack)->Signature == STRING_SIGNATURE );

    //
    // Zero out the stack
    //
    localStack = *StringStack;
    MEMORY_ZERO( localStack->Stack, localStack->StackSize );

    //
    // Reset the TOS to the root
    //
    localStack->TopOfStack = 0;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
StringStackFree(
    IN  OUT PSTRING_STACK   *StringStack
    )
/*++

Routine Description:

    This routine frees the string stack

Arguments:

    StringStack - Where to find a pointer to the stack

Return Value:

    NTSTATUS

--*/
{
    //
    // Make sure that we point to something
    //
    ASSERT( StringStack != NULL && *StringStack != NULL );
    ASSERT( (*StringStack)->Signature == STRING_SIGNATURE );

    //
    // Free the stack
    //
    MEMORY_FREE( *StringStack );

    //
    // Point the stack to nowhere
    //
    *StringStack = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
StringStackPop(
    IN  OUT PSTRING_STACK   *StringStack,
    IN      ULONG           NumBytes,
        OUT PUCHAR          *String
    )
/*++

Routine Description:

    This routine returns a pointer to the requested offset from the end
    of the stack

    Note: String points to memory that can be freed at any time. It is the
    caller's responsibility to make a copy

Arguments:

    StringStack - Where to find a pointer to the stack
    NumBytes    - Number of bytes to pop off
    String      - Pointer to the bytes.

Return Value:

    NTSTATUS

--*/
{
    PSTRING_STACK  localStack;

    //
    // Make sure that we point to something
    //
    ASSERT( StringStack != NULL );
    ASSERT( (*StringStack)->Signature == STRING_SIGNATURE );
    ASSERT( String != NULL );

    //
    // Is there an item that we can remove from the stack?
    //
    localStack = *StringStack;
    if ( localStack->TopOfStack == 0 ||
         localStack->TopOfStack < NumBytes) {

        return STATUS_FAIL_CHECK;

    }

    //
    // Return a pointer to the requested bytes
    //
    localStack->TopOfStack -= NumBytes;
    *String = &( localStack->Stack[ localStack->TopOfStack ] );
    return STATUS_SUCCESS;

}

NTSTATUS
StringStackPush(
    IN  OUT PSTRING_STACK   *StringStack,
    IN      ULONG           StringLength,
    IN      PUCHAR          String
    )
/*++

Routine Description:

    This routine obtains a pointer for an object on the top of the stack
    and increments the top to point to something that can be then be used
    again.

Arguments:

    StringStack     - Where to find a pointer to the stack
    String          - String to push onto stack
    StringLength    - How many bytes to push onto the stack

Return Value:

    NTSTATUS

--*/
{
    PSTRING_STACK   localStack;
    PSTRING_STACK   tempStack;
    ULONG           newSize;

    //
    // Make sure that we point to something
    //
    ASSERT( StringStack != NULL );
    ASSERT( String != NULL );

    //
    // Find the stack pointer and make sure that the signature is still
    // valid
    //
    localStack = *StringStack;
    ASSERT( localStack->Signature == STRING_SIGNATURE );

    //
    // Do we have enough space on the stack?
    //
    if ( localStack->TopOfStack + StringLength > localStack->StackSize ) {

        //
        // Figure out how many bytes by which to grow the stack and how
        // large the total stack should be
        //
        newSize = sizeof(STRING_STACK) + localStack->StackSize +
            STRING_GROWTH_RATE - 1;

        //
        // Grow the stack
        //
        tempStack = MEMORY_ALLOCATE( newSize );
        if (tempStack == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Empty the new stack and copy the old one to it
        //
        MEMORY_ZERO( tempStack->Stack, newSize - sizeof(STRING_STACK) + 1);
        MEMORY_COPY( tempStack, localStack , newSize - STRING_GROWTH_RATE);

        //
        // Make sure that the new stack has the correct size
        //
        tempStack->StackSize += STRING_GROWTH_RATE;

        //
        // Free the old stack
        //
        StringStackFree( StringStack );

        //
        // Set the stack to point to the new one
        //
        *StringStack = localStack = tempStack;

    }

    //
    // Grab a pointer to the part that we will return to the caller
    //
    MEMORY_COPY(
        &(localStack->Stack[ localStack->TopOfStack] ),
        String,
        StringLength
        );

    //
    // Find the new Top of Stack
    //
    localStack->TopOfStack += StringLength;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
StringStackRoot(
    IN  OUT PSTRING_STACK   *StringStack,
        OUT PUCHAR          *RootElement
    )
/*++

Routine Description:

    This routine returns the topmost stack location that is in current use

Arguments:

    Stack       - Where the stack is located
    RootElement - Where to store the pointer to the root stack element

Return Value:

    NTSTATUS

--*/
{
    ASSERT( StringStack != NULL && *StringStack != NULL );
    ASSERT( (*StringStack)->Signature == STRING_SIGNATURE );

    //
    // Grab the top stack location
    //
    *RootElement = (PUCHAR) (*StringStack)->Stack;

    //
    // Done
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\scope.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    scope.h

Abstract:

    Defines the structures used by the parser

Author:

    Michael Tsang
    Stephane Plante

Environment:

    Any

Revision History:

--*/

#ifndef _SCOPE_H_
#define _SCOPE_H_

    PUNASM_AMLTERM
    ScopeFindExtendedOpcode(
        IN  PSTACK  *Stack
        );

    #define ScopeFindLocalScope(Stack, LocalScope, RootScope, Status)   \
        Status = StackTop( Stack, LocalScope );                         \
        if (!NT_SUCCESS(Status)) {                                      \
                                                                        \
            return Status;                                              \
                                                                        \
        }                                                               \
        Status = StackRoot( Stack, RootScope );                         \
        if (!NT_SUCCESS(Status)) {                                      \
                                                                        \
            return Status;                                              \
                                                                        \
        }

    NTSTATUS
    ScopeParser(
        IN  PUCHAR  Start,
        IN  ULONG   Length,
        IN  ULONG   BaseAddress,
	IN  ULONG   IndentLevel
        );

    NTSTATUS
    ScopePrint(
        IN  PSTACK  *Stack
        );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\ustring.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ustring.h

Abstract:

    The stack string portion of the un-assembler

Author:

    Stephane Plante

Environment:

    Any

Revision History:

--*/

#ifndef _USTRING_H_
#define _USTRING_H_

    NTSTATUS
    StringStackAllocate(
        OUT     PSTRING_STACK   *StringStack
        );

    NTSTATUS
    StringStackClear(
        IN  OUT PSTRING_STACK   *StringStack
        );

    NTSTATUS
    StringStackFree(
        IN  OUT PSTRING_STACK   *StringStack
        );

    NTSTATUS
    StringStackPop(
        IN  OUT PSTRING_STACK   *StringStack,
        IN      ULONG           NumBytes,
            OUT PUCHAR          *String
        );

    NTSTATUS
    StringStackPush(
        IN  OUT PSTRING_STACK   *StringStack,
        IN      ULONG           StringLength,
        IN      PUCHAR          String
        );

    NTSTATUS
    StringStackRoot(
        IN  OUT PSTRING_STACK   *StringStack,
            OUT PUCHAR          *RootElement
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\scope.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    scope.c

Abstract:

    The scope portion of the parser

Author:

    Michael Tsang
    Stephane Plante

Environment:

    Any

Revision History:

--*/

#include "pch.h"
UCHAR   GlobalIndent[80];

PUNASM_AMLTERM
ScopeFindExtendedOpcode(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This function looks in the extended opcode table for the matching
    AML term

Arguments:

    Stack   - The current thread of execution

Return Value:

    None

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      localScope;
    ULONG       index = 0;
    PUNASM_OPCODEMAP  opcodeMap;

    ASSERT( Stack != NULL && *Stack != NULL );

    //
    // Step 1:  Find the top of the stack
    //
    status = StackTop( Stack, &localScope );
    if (!NT_SUCCESS(status)) {

        return NULL;

    }

    //
    // Step 2: Loop Forever
    //
    while (1) {

        //
        // Step 2.1: Get the entry out of the extended opcode table
        //
        opcodeMap = &(ExOpcodeTable[index]);

        //
        // Step 2.2: Make sure that we haven't crossed the end
        //
        if (opcodeMap->OpCode == 0) {

            break;

        }

        //
        // Step 2.3: Did we find what we where looking for?
        //
        if (opcodeMap->OpCode == *(localScope->CurrentByte) ) {

            return opcodeMap->AmlTerm;

        }

        //
        // Step 2.4: No?
        //
        index++;

    }

    //
    // Step 3: Failure
    //
    return NULL;
}

#if 0
NTSTATUS
ScopeFindLocalScope(
    IN  PSTACK  *Stack,
    OUT PUNASM_SCOPE  *LocalScope,
    OUT PUNASM_SCOPE  *RootScope
    )
/*++

Routine Description:

    This function is a helper function. It simply grabs the top and bottom
    of the stack and returns them.

    This is a macro

Arguments:

    Stack       - The top of the stack
    LocalScope  - Where we want the top of stack
    RootScope   - Where we want the bottom of stack

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;

    ASSERT( Stack != NULL && *Stack != NULL );
    ASSERT( LocalScope != NULL );
    ASSERT( RootScope != NULL );

    //
    // Step 1: Grab the local scope
    //
    status = StackTop( Stack, LocalScope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 2: Grab the root
    //
    status = StackRoot( Stack, RootScope );
    if (!(NT_SUCCESS(status)) {

        return status;

    }
}
#endif

NTSTATUS
ScopeParser(
    IN  PUCHAR  Start,
    IN  ULONG   Length,
    IN  ULONG   BaseAddress,
    IN  ULONG   IndentLevel
    )
/*++

Routine Description:

    This routine arranges things so that the supplied bytes can be parsed

Arguments:

    Start       - Pointer to the first byte to parse
    Length      - Number of Bytes to parse
    BaseAddress - Used for calculating memory location of instruction

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PSTACK      stack;
    PUNASM_SCOPE      scope;

    //
    // Setup the global indent
    //
    IndentLevel = (IndentLevel > 79 ? 79 : IndentLevel );
    MEMORY_SET( GlobalIndent, ' ', IndentLevel );
    GlobalIndent[IndentLevel] = '\0';

    //
    // Step 1: Obtain a stack
    //
    status = StackAllocate( &stack, sizeof(UNASM_SCOPE) );
    if (!NT_SUCCESS(status)) {

        return status;

    } else if (stack == NULL) {

        return STATUS_FAIL_CHECK;

    }

    //
    // Step 2: Setup the root scope
    //
    status = StackPush( &stack, &scope );
    if (!NT_SUCCESS(status)) {

        return status;

    }
    scope->CurrentByte = Start;
    scope->LastByte = Start + Length - 1;
    scope->IndentLevel = 0;
    scope->BaseAddress = BaseAddress;

    //
    // Step 3: Initialize the string stack
    //
    status = StringStackAllocate( &(scope->StringStack) );
    if (!NT_SUCCESS(status)) {

        return status;

    }
    status = StringStackAllocate( &(scope->ParseStack) );
    if (!NT_SUCCESS(status)) {

        return status;

    }
    //
    // Step 4: Parse the scope
    //
    status = ParseScope( &stack );
    if (NT_SUCCESS(status)) {

        status = StackRoot( &stack, &scope );
        if (!NT_SUCCESS(status)) {

            return status;

        }
        StringStackFree( &(scope->StringStack) );
        StringStackFree( &(scope->ParseStack) );
        StackPop( &stack );
        StackFree( &stack );

    }

    //
    // Step 5: Done
    //
    return status;
}

NTSTATUS
ScopePrint(
    IN  PSTACK  *Stack
    )
/*++

Routine Description:

    This prints and clears the string in the current scope

Arguments:

    The current thread's stack

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PUNASM_SCOPE      scope;
    PUNASM_SCOPE      root;
    PUCHAR      buffer;

    //
    // Step 1: Get the local scope
    //
    ScopeFindLocalScope( Stack, &scope, &root, status );

    //
    // Step 2: Allocate a buffer to print spaces to
    //
    buffer = MEMORY_ALLOCATE( scope->IndentLevel + 11 );
    if (buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Step 3: Check to see if there is an indent level
    //
    if (scope->IndentLevel) {

        //
        // Step 3.1.1: Print some spaces to that buffer
        //
        STRING_PRINT(
            buffer,
            "%s%08x  %*s",
            GlobalIndent,
            scope->TermByte + root->BaseAddress,
            scope->IndentLevel,
            ""
            );

    } else {

        //
        // Step 3.2.1: Print just the address
        //
        STRING_PRINT(
            buffer,
            "%s%08x  ",
            GlobalIndent,
            scope->TermByte + root->BaseAddress
            );

    }

    //
    // Step 4 Show it to the user
    //
    PRINTF( "%s", buffer );

    //
    // Step 5: Free the memory
    //
    MEMORY_FREE( buffer );

    //
    // Step 6: Grab the root stack
    //
    status = StackRoot( Stack, &scope );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Step 7: Show the user the buffer
    //
    StringStackPush( &(scope->StringStack), 1, "\0" );
    PRINTF( "%s", scope->StringStack->Stack );
    StringStackClear( &(scope->StringStack) );

    //
    // Step 8: Done
    //
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm\stack.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stack.c

Abstract:

    This provides a generic stack handler to push/pop things onto it

Author:

    Stephane Plante (splante)

Environment:

    User, Kernel

--*/

#include "pch.h"

NTSTATUS
StackAllocate(
    OUT     PSTACK  *Stack,
    IN      ULONG   StackElementSize
    )
/*++

Routine Description:

    This routine allocates memory and returns a stack object

Arguments:

    Stack               - Where to store a pointer to the stack
    StackElementSize    - How much space on the stack a single element takes
                          up

Return Value:

    NTSTATUS

--*/
{
    PSTACK      tempStack;
    NTSTATUS    status  = STATUS_SUCCESS;

    //
    // Make sure that we have some place to store the stack pointer
    //
    ASSERT( Stack != NULL );
    ASSERT( StackElementSize != 0 );

    //
    // Allocate a block of memory for the stack
    //
    tempStack = MEMORY_ALLOCATE(
        sizeof(STACK) + ( (STACK_GROWTH_RATE * StackElementSize) - 1)
        );
    if (tempStack == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto StackAllocateExit;
    }

    //
    // Setup the control block of the stack
    //
    tempStack->Signature        = (ULONG) STACK_SIGNATURE;
    tempStack->StackSize        = STACK_GROWTH_RATE * StackElementSize;
    tempStack->StackElementSize = StackElementSize;
    tempStack->TopOfStack       = 0;

    //
    // Zero out the current elements on the stack
    //
    MEMORY_ZERO(
        &(tempStack->Stack[0]),
        STACK_GROWTH_RATE * StackElementSize
        );

    //
    // Return the stack pointer
    //
StackAllocateExit:
    *Stack = tempStack;
    return status;

}

NTSTATUS
StackFree(
    IN  OUT PSTACK  *Stack
    )
/*++

Routine Description:

    This routine frees the stack

Arguments:

    Stack   - Where to find a pointer to the stack

Return Value:

    NTSTATUS

--*/
{
    //
    // Make sure that we point to something
    //
    ASSERT( Stack != NULL );
    ASSERT( (*Stack)->Signature == STACK_SIGNATURE );

    //
    // Free the stack
    //
    MEMORY_FREE( *Stack );

    //
    // Point the stack to nowhere
    //
    *Stack = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
StackParent(
    IN  OUT PSTACK  *Stack,
    IN      PVOID   Child,
        OUT PVOID   Parent
    )
/*++

Routine Description:

    This routine returns a pointer to the stack location that is before
    the given Child.

Arguments:

    Stack   - The stack to operate on
    Child   - This is the node whose parent we want
    Parent  - This is where we store a pointer to the parent stack loc

Return Value:

    NTSTATUS

--*/
{
    PSTACK  localStack;
    ULONG   Addr = (ULONG) Child;

    //
    // Make sure that we point to something
    //
    ASSERT( Stack != NULL );
    ASSERT( (*Stack)->Signature == STACK_SIGNATURE );
    ASSERT( Parent != NULL );

    //
    // make sure that the child node actually lies on the stack
    //
    localStack = *Stack;
    if ( Addr < (ULONG) localStack->Stack ||
         Addr > (ULONG) &(localStack->Stack[localStack->TopOfStack + 1]) -
           localStack->StackElementSize ) {

        *( (PULONG *)Parent) = NULL;
        return STATUS_FAIL_CHECK;

    }

    //
    // Make sure that the child node isn't the first element
    //
    if (Addr < (ULONG) &(localStack->Stack[localStack->StackElementSize]) ) {

        *( (PULONG *)Parent) = NULL;
        return STATUS_SUCCESS;

    }

    //
    // Set the parent to be one before the child
    //
    *( (PULONG *)Parent) = (PULONG) (Addr - localStack->StackElementSize);

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
StackPop(
    IN  OUT PSTACK  *Stack
    )
/*++

Routine Description:

    This routine reclaims the memory used for a stack location
    and wipes out whatever data existed in the reclaimed area

Arguments:

    Stack           - Where to find a pointer to the stack

Return Value:

    NTSTATUS

--*/
{
    PSTACK  localStack;

    //
    // Make sure that we point to something
    //
    ASSERT( Stack != NULL );
    ASSERT( (*Stack)->Signature == STACK_SIGNATURE );

    //
    // Is there an item that we can remove from the stack?
    //
    localStack = *Stack;
    if ( localStack->TopOfStack == 0) {

        return STATUS_FAIL_CHECK;

    }

    //
    // Wipe out the top-most element on the stack
    //
    localStack->TopOfStack -= localStack->StackElementSize;
    MEMORY_ZERO(
        &( localStack->Stack[ localStack->TopOfStack ] ),
        localStack->StackElementSize
        );

    return STATUS_SUCCESS;
}

NTSTATUS
StackPush(
    IN  OUT PSTACK  *Stack,
        OUT PVOID   StackElement
    )
/*++

Routine Description:

    This routine obtains a pointer for an object on the top of the stack
    and increments the top to point to something that can be then be used
    again.

Arguments:

    Stack           - Where to find a pointer to the stack
    StackElement    - Pointer to the element to be added to the stack

Return Value:

    NTSTATUS

--*/
{
    PSTACK  localStack;
    PSTACK  tempStack;
    ULONG   newSize;
    ULONG   deltaSize;

    //
    // Make sure that we point to something
    //
    ASSERT( Stack != NULL );
    ASSERT( StackElement != NULL );

    //
    // Find the stack pointer and make sure that the signature is still
    // valid
    //
    localStack = *Stack;
    ASSERT( localStack->Signature == STACK_SIGNATURE );

    //
    // Do we have enough space on the stack?
    //
    if ( localStack->TopOfStack >= localStack->StackSize ) {

        //
        // Figure out how many bytes by which to grow the stack and how
        // large the total stack should be
        //
        deltaSize = (STACK_GROWTH_RATE * localStack->StackElementSize);
        newSize = sizeof(STACK) + localStack->StackSize + deltaSize - 1;

        //
        // Grow the stack
        //
        tempStack = MEMORY_ALLOCATE( newSize );
        if (tempStack == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Empty the new stack and copy the old one to it
        //
        MEMORY_ZERO( &(tempStack->Stack[0]), newSize - sizeof(STACK) + 1);
        MEMORY_COPY( tempStack, localStack , newSize - deltaSize);

        //
        // Make sure that the new stack has the correct size
        //
        tempStack->StackSize += deltaSize;

        //
        // Free the old stack
        //
        StackFree( Stack );

        //
        // Set the stack to point to the new one
        //
        *Stack = localStack = tempStack;

    }

    //
    // Grab a pointer to the part that we will return to the caller
    //
    *( (PUCHAR *)StackElement) = &(localStack->Stack[ localStack->TopOfStack ]);

    //
    // Find the new Top of Stack
    //
    localStack->TopOfStack += localStack->StackElementSize;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
StackRoot(
    IN  OUT PSTACK  *Stack,
        OUT PVOID   RootElement
    )
/*++

Routine Description:

    This routine returns the first element on the stack

Arguments:

    Stack       - Where the stack is located
    RootElement - Where to store the pointer to the root stack element

Return Value:

    NTSTATUS

--*/
{
    PSTACK  localStack;

    ASSERT( Stack != NULL && *Stack != NULL );
    ASSERT( (*Stack)->Signature == STACK_SIGNATURE );

    localStack = *Stack;
    if (localStack->TopOfStack < localStack->StackElementSize) {

        //
        // There is no stack location we can use
        //
        *( (PUCHAR *)RootElement) = NULL;
        return STATUS_UNSUCCESSFUL;

    }

    //
    // Grab the root element
    //
    *( (PUCHAR *)RootElement) = localStack->Stack;

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
StackTop(
    IN  OUT PSTACK  *Stack,
        OUT PVOID   TopElement
    )
/*++

Routine Description:

    This routine returns the topmost stack location that is in current use

Arguments:

    Stack       - Where the stack is located
    TopElement  - Where to store the pointer to the top stack element

Return Value:

    NTSTATUS

--*/
{
    PSTACK  localStack;
    ULONG   offset;

    ASSERT( Stack != NULL );
    ASSERT( (*Stack)->Signature == STACK_SIGNATURE );

    localStack = *Stack;
    if (localStack->TopOfStack < localStack->StackElementSize) {

        //
        // No stack locations are in current use
        //
        *( (PUCHAR *)TopElement) = NULL;
        return STATUS_UNSUCCESSFUL;

    } else {

        offset = localStack->TopOfStack - localStack->StackElementSize;
    }

    //
    // Grab the top stack location
    //
    *( (PUCHAR *)TopElement) = &(localStack->Stack[ offset ]);

    //
    // Done
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\makefile.inc ===
$(O)\acpiuasm.res: acpiuasm.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\list.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    list.h

Abstract:

    List Entry Manipulation functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _LIST_H_
#define _LIST_H_

typedef struct _LIST {
    struct  _LIST   *ListPrev;
    struct  _LIST   *ListNext;
} LIST, *PLIST, **PPLIST;

VOID
LOCAL
ListRemoveEntry(
    PLIST   List,
    PPLIST  LIstHead
    );

PLIST
LOCAL
ListRemoveHead(
    PPLIST  ListHead
    );

PLIST
LOCAL
ListRemoveTail(
    PPLIST  ListHead
    );

VOID
LOCAL
ListInsertHead(
    PLIST   List,
    PPLIST  ListHead
    );

VOID
LOCAL
ListInsertTail(
    PLIST   List,
    PPLIST  ListHead
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\list.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    list.c

Abstract:

    List Entry manipulation functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

VOID
LOCAL
ListRemoveEntry(
    PLIST   List,
    PPLIST  ListHead
    )
/*++

Routine Description:

    Remove an Entry from the list

Arguments:

    List        - Entry to be removed
    ListHead    - List to be removed from

Return Value:

    None

--*/
{
    ASSERT(ListHead);

    ASSERT(List != NULL);
    if (List->ListNext == List) {

        //
        // This is the only object in the list, it must be the head too.
        //
        ASSERT(List == *ListHead);
        *ListHead = NULL;

    } else {

        if (List == *ListHead) {

            //
            // The entry is at the head, so the next one becomes the new
            // head.
            //
            *ListHead = (*ListHead)->ListNext;

        }
        List->ListNext->ListPrev = List->ListPrev;
        List->ListPrev->ListNext = List->ListNext;

    }

}

PLIST
LOCAL
ListRemoveHead(
    PPLIST  ListHead
    )
/*++

Routine Description:

    Remove the head entry of the list

Arguments:

    ListHead    - List to remove entry from

Return Value:

    PLIST   - Removed Item

--*/
{
    PLIST list;

    list = *ListHead;
    if ( list != NULL) {

        ListRemoveEntry(list, ListHead);

    }
    return list;

}

PLIST
LOCAL
ListRemoveTail(
    PPLIST  ListHead
    )
/*++

Routine Description:

    Remove the tail entry from the list

Arguments:

    ListHead    - List to remove entry from

Return Value:

    PLIST   - Removed Item

--*/
{
    PLIST list;

    if (*ListHead == NULL) {

        list = NULL;

    } else {

        //
        // List is not empty, so find the tail.
        //
        list = (*ListHead)->ListPrev;
        ListRemoveEntry(list, ListHead);

    }
    return list;

}

VOID
LOCAL
ListInsertHead(
    PLIST   List,
    PPLIST  ListHead
    )
/*++

Routine Description:

    Insert an Entry at the head of the list

Arguments:

    List        List object to be inserted
    ListHead    The list where to insert the object

Return Value:

    None

--*/
{
    ListInsertTail(List, ListHead);
    *ListHead = List;
}

VOID
LOCAL
ListInsertTail(
    PLIST   List,
    PPLIST  ListHead
    )
/*++

Routine Description:

    Insert an Entry at the tail of the list

Arguments:

    List        List object to be inserted
    ListHead    The list where to insert the object

Return Value:

    None

--*/
{
    if (*ListHead == NULL) {

        //
        // List is empty, so this becomes the head.
        //
        *ListHead = List;
        List->ListPrev = List->ListNext = List;

    } else {

        List->ListNext = *ListHead;
        List->ListPrev = (*ListHead)->ListPrev;
        (*ListHead)->ListPrev->ListNext = List;
        (*ListHead)->ListPrev = List;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\debug.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Various helpful debugging functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

ULONG   globalDebugIndentLevel = 0;
ULONG   globalVerbosityLevel = 0;

VOID
CDECL
DebugEnterProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    )
/*++

Routine Description:

    This routine handles displaying of information when a procedure is
    entered

Arguments:

    Verbosity   - We have to be at this verbosity level to display a string
    Format      - String to print
    ...         - Arguments

Return Value:

    None

--*/
{
    ULONG   i;
    va_list marker;

    if (VerbosityLevel <= globalVerbosityLevel) {

        for (i = 0 ; i < globalDebugIndentLevel ; i++) {

            fprintf( stderr, "| ");

        }
        va_start( marker, Format );
        vfprintf( stderr, Format, marker );
        fflush( stderr );
        va_end ( marker );

    }
    globalDebugIndentLevel++;
}

VOID
CDECL
DebugExitProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    )
/*++

Routine Description:

    This routine handles displaying of information when a procedure is
    exited

Arguments:

    Verbosity   - We have to be at this verbosity level to display a string
    Format      - String to print
    ...         - Arguments

Return Value:

    None

--*/
{
    ULONG   i;
    va_list marker;

    globalDebugIndentLevel--;
    if (VerbosityLevel <= globalVerbosityLevel) {

        for (i = 0 ; i < globalDebugIndentLevel ; i++) {

            fprintf( stderr, "| ");

        }
        va_start( marker, Format );
        vfprintf( stderr, Format, marker );
        fflush( stderr );
        va_end ( marker );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\debug.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Various helpful debugging functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _DEBUG_H_
#define _DEBUG_H_

#ifdef DBG
#define ENTER(x)    DebugEnterProcedure x
#define EXIT(x)     DebugExitProcedure x
#else
#define ENTER(x)
#define EXIT(x)
#endif

VOID
CDECL
DebugEnterProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    );

VOID
CDECL
DebugExitProcedure(
    ULONG   VerbosityLevel,
    PCCHAR  Format,
    ...
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\data.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This file contains all of the data required by the unassembler

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _DATA_H
#define _DATA_H

extern ASLTERM  TermTable[];
extern UCHAR    OpClassTable[];
extern OPMAP    ExOpClassTable[];

#endif  //ifndef _DATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\namespac.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    namespac.h

Abstract:

    This file contains all of the namespace handling functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _NAMESPAC_H_
#define _NAMESPAC_H_

extern PNSOBJ   RootNameSpaceObject;
extern PNSOBJ   CurrentScopeNameSpaceObject;
extern PNSOBJ   CurrentOwnerNameSpaceObject;

NTSTATUS
LOCAL
CreateNameSpaceObject(
    PUCHAR  ObjectName,
    PNSOBJ  ObjectScope,
    PNSOBJ  ObjectOwner,
    PNSOBJ  *Object,
    ULONG   Flags
    );


NTSTATUS
LOCAL
CreateObject(
    PUCHAR  ObjectName,
    UCHAR   ObjectType,
    PNSOBJ  *Object
    );

NTSTATUS
LOCAL
GetNameSpaceObject(
    PUCHAR  ObjectPath,
    PNSOBJ  ScopeObject,
    PNSOBJ  *NameObject,
    ULONG   Flags
    );

PUCHAR
LOCAL
GetObjectPath(
    PNSOBJ  NameObject
    );

PUCHAR
LOCAL
GetObjectTypeName(
    ULONG   ObjectType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\namespac.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    namespac.c

Abstract:

    This file contains all of the namespace handling functions

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

PNSOBJ  RootNameSpaceObject;
PNSOBJ  CurrentScopeNameSpaceObject;
PNSOBJ  CurrentOwnerNameSpaceObject;

NTSTATUS
LOCAL
CreateNameSpaceObject(
    PUCHAR  ObjectName,
    PNSOBJ  ObjectScope,
    PNSOBJ  ObjectOwner,
    PNSOBJ  *Object,
    ULONG   Flags
    )
/*++

Routine Description:

    This routine creates a name space object under the current scope

Arguments:

    ObjectName  - Name Path String
    ObjectScope - Scope to start the search from (NULL == Root)
    ObjectOwner - The object which owns this one
    Object      - Where to store the point to the object that we just created
    Flags       - Options

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PNSOBJ      localObject;

    ENTER( (
        1,
        "CreateNameSpaceObject(%s,Scope=%s,Owner=%p,Object=%p,"
        "Flag=%08lx)\n",
        ObjectName,
        (ObjectScope ? GetObjectPath( ObjectScope ) : "ROOT"),
        ObjectOwner,
        Object,
        Flags
        ) );

    if (ObjectScope == NULL) {

        ObjectScope = RootNameSpaceObject;

    }

    status = GetNameSpaceObject(
        ObjectName,
        ObjectScope,
        &localObject,
        NSF_LOCAL_SCOPE
        );
    if (NT_SUCCESS(status)) {

        if (!(Flags & NSF_EXIST_OK)) {

            status = STATUS_OBJECT_NAME_COLLISION;

        }

    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        status = STATUS_SUCCESS;

        //
        // Are we creating root?
        //
        if (strcmp(ObjectName,"\\") == 0) {

            ASSERT( RootNameSpaceObject == NULL );
            ASSERT( ObjectOwner == NULL );

            localObject = MEMALLOC( sizeof(NSOBJ) );
            if (localObject == NULL) {

                return STATUS_INSUFFICIENT_RESOURCES;

            } else {

                memset( localObject, 0, sizeof(NSOBJ) );
                localObject->Signature = SIG_NSOBJ;
                localObject->NameSeg = NAMESEG_ROOT;
                RootNameSpaceObject = localObject;

            }

        } else {

            PUCHAR  nameEnd;
            PNSOBJ  objectParent;

            nameEnd = strrchr(ObjectName, '.');
            if (nameEnd != NULL) {

                *nameEnd = '\0';
                nameEnd++;

                status = GetNameSpaceObject(
                    ObjectName,
                    ObjectScope,
                    &objectParent,
                    NSF_LOCAL_SCOPE
                    );

            } else if (*ObjectName == '\\') {

                nameEnd = &ObjectName[1];
                ASSERT( RootNameSpaceObject != NULL );
                objectParent = RootNameSpaceObject;

            } else if (*ObjectName == '^') {

                nameEnd = ObjectName;
                objectParent = ObjectScope;
                while ( (*nameEnd == '^') && (objectParent != NULL)) {

                    objectParent = objectParent->ParentObject;
                    nameEnd++;

                }

            } else {

                ASSERT( ObjectScope );
                nameEnd = ObjectName;
                objectParent = ObjectScope;

            }


            if (status == STATUS_SUCCESS) {

                ULONG   length = strlen(nameEnd);

                localObject = MEMALLOC( sizeof(NSOBJ) );

                if (localObject == NULL) {

                    status = STATUS_INSUFFICIENT_RESOURCES;

                } else if ( (*nameEnd != '\0') && (length > sizeof(NAMESEG))) {

                    status = STATUS_OBJECT_NAME_INVALID;
                    MEMFREE( localObject );

                } else {

                    memset( localObject, 0, sizeof(NSOBJ) );
                    localObject->Signature = SIG_NSOBJ;
                    localObject->NameSeg = NAMESEG_BLANK;
                    memcpy( &(localObject->NameSeg), nameEnd, length );
                    localObject->Owner = ObjectOwner;
                    localObject->ParentObject = objectParent;

                    ListInsertTail(
                        &(localObject->List),
                        (PPLIST) &(objectParent->FirstChild)
                        );

                }

            }

        }

    }


    if (NT_SUCCESS(status) && Object != NULL) {

        *Object = localObject;

    }

    EXIT( (
        1,
        "CreateNameSpaceObject=%08lx (*Object=%p)\n",
        status,
        localObject
        ) );

    return status;
}

NTSTATUS
LOCAL
CreateObject(
    PUCHAR  ObjectName,
    UCHAR   ObjectType,
    PNSOBJ  *Object
    )
/*++

Routine Description:

    Creates a NameSpace Object for the term

Arguments:

    ObjectName  - The name object object
    ObjectType  - The type of object to create
    Object      - Where to store a pointer to the created object

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PNSOBJ      localObject;

    ENTER( (
        1,
        "CreateObject(%s,Type=%02x,Object=%p)\n",
        ObjectName,
        ObjectType,
        Object
        ) );

    status = CreateNameSpaceObject(
        ObjectName,
        CurrentScopeNameSpaceObject,
        CurrentOwnerNameSpaceObject,
        &localObject,
        NSF_EXIST_ERR
        );
    if (NT_SUCCESS(status)) {

        switch (ObjectType) {
            case NSTYPE_UNKNOWN:
                break;

            case NSTYPE_FIELDUNIT:
                localObject->ObjectData.DataType = OBJTYPE_FIELDUNIT;
                break;

            case NSTYPE_DEVICE:
                localObject->ObjectData.DataType = OBJTYPE_DEVICE;
                break;

            case NSTYPE_EVENT:
                localObject->ObjectData.DataType = OBJTYPE_EVENT;
                break;

            case NSTYPE_METHOD:
                localObject->ObjectData.DataType = OBJTYPE_METHOD;
                break;

            case NSTYPE_MUTEX:
                localObject->ObjectData.DataType = OBJTYPE_MUTEX;
                break;

            case NSTYPE_OPREGION:
                localObject->ObjectData.DataType = OBJTYPE_OPREGION;
                break;

            case NSTYPE_POWERRES:
                localObject->ObjectData.DataType = OBJTYPE_POWERRES;
                break;

            case NSTYPE_PROCESSOR:
                localObject->ObjectData.DataType = OBJTYPE_PROCESSOR;
                break;

            case NSTYPE_THERMALZONE:
                localObject->ObjectData.DataType = OBJTYPE_THERMALZONE;
                break;

            case NSTYPE_OBJALIAS:
                localObject->ObjectData.DataType = OBJTYPE_OBJALIAS;
                break;

            case NSTYPE_BUFFFIELD:
                localObject->ObjectData.DataType = OBJTYPE_BUFFFIELD;
                break;

            default:
                status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        if (Object != NULL) {

            *Object = localObject;

        }


    }


    EXIT( (
        1,
        "CreateObject=%08lx (*Object=%p)\n",
        status,
        localObject
        ) );
    return status;
}       //CreateObject

NTSTATUS
LOCAL
GetNameSpaceObject(
    PUCHAR  ObjectPath,
    PNSOBJ  ScopeObject,
    PNSOBJ  *NameObject,
    ULONG   Flags
    )
/*++

Routine Description:

    This routine searches the namespace until it finds a matching object

Arguments:

    ObjectPath  - String with the Name to search for
    ScopeObject - Scope to start search at (NULL == ROOT)
    NameObject  - Where to store the object, if found
    Flags       - Options

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PUCHAR      subPath;

    ENTER( (
        1,
        "GetNameSpaceObject(%s,Scope=%s,Object=%p,Flags=%08lx\n",
        ObjectPath,
        (ScopeObject ? GetObjectPath( ScopeObject ) : "ROOT"),
        NameObject,
        Flags
        ) );

    if (ScopeObject == NULL) {

        ScopeObject = RootNameSpaceObject;

    }


    if (*ObjectPath == '\\') {

        subPath = &ObjectPath[1];
        ScopeObject = RootNameSpaceObject;

    } else {

        subPath = ObjectPath;
        while ( (*subPath == '^') && (ScopeObject != NULL)) {

            subPath++;
            ScopeObject = ScopeObject->ParentObject;

        }

    }


    *NameObject = ScopeObject;
    if (ScopeObject == NULL) {

        status = STATUS_OBJECT_NAME_NOT_FOUND;

    } else if (*subPath != '\0') {

        BOOL    searchUp;
        PNSOBJ  tempObject;

        searchUp = !(Flags & NSF_LOCAL_SCOPE) &&
            (ObjectPath[0] == '\\') &&
            (ObjectPath[0] == '^') &&
            (strlen(ObjectPath) <= sizeof(NAMESEG));

        while (1) {

            do {

                tempObject = ScopeObject->FirstChild;
                if (tempObject == NULL) {

                    status = STATUS_OBJECT_NAME_NOT_FOUND;

                } else {

                    BOOL    found;
                    PUCHAR  bufferEnd;
                    ULONG   length;
                    NAMESEG nameSeg;

                    bufferEnd = strchr( subPath, '.' );
                    if (bufferEnd != NULL) {

                        length = (ULONG)(bufferEnd - subPath);

                    } else {

                        length = strlen(subPath);

                    }


                    if (length > sizeof(NAMESEG)) {

                        status = STATUS_OBJECT_NAME_INVALID;
                        found = FALSE;

                    } else {

                        nameSeg = NAMESEG_BLANK;
                        memcpy( &nameSeg, subPath, length );

                        //
                        // search all sibling fors a matching nameSeg
                        //
                        found = FALSE;
                        do {

                            if (tempObject->NameSeg == nameSeg) {

                                ScopeObject = tempObject;
                                found = TRUE;
                                break;

                            }

                            tempObject = (PNSOBJ) tempObject->List.ListNext;

                        } while (tempObject != tempObject->ParentObject->FirstChild );

                    }


                    if (status == STATUS_SUCCESS) {

                        if (!found) {

                            status = STATUS_OBJECT_NAME_NOT_FOUND;

                        } else {

                            subPath += length;
                            if (*subPath == '.') {

                                subPath++;

                            } else if (*subPath == '\0') {

                                *NameObject = ScopeObject;
                                break;

                            }

                        }

                    }

                }

            } while ( status == STATUS_SUCCESS );

            if (status == STATUS_OBJECT_NAME_NOT_FOUND && searchUp &&
                ScopeObject != NULL && ScopeObject->ParentObject != NULL) {

                ScopeObject = ScopeObject->ParentObject;
                status = STATUS_SUCCESS;

            } else {

                break;

            }

        }

    }


    if (status != STATUS_SUCCESS) {

        *NameObject = NULL;

    }


    EXIT( (
        1,
        "GetNameSpaceObject=%08lx (*Object=%p)\n",
        status,
        *NameObject
        ) );
    return status;

}

PUCHAR
LOCAL
GetObjectPath(
    PNSOBJ  NameObject
    )
/*++

Routine Description:

    This routine takes a NameSpace Object and returns a string to represent
    its path

Arguments:

    NameObject  - The object whose path we want

Return Value:

    Pointer to the string which represents the path

--*/
{
    static UCHAR    namePath[MAX_NAME_LEN + 1] = {0};
    ULONG           i;

    ENTER( (4, "GetObjectPath(Object=%p)\n", NameObject ) );

    if (NameObject != NULL) {

        if (NameObject->ParentObject == NULL) {

            strcpy(namePath, "\\");

        } else {

            GetObjectPath(NameObject->ParentObject);
            if (NameObject->ParentObject->ParentObject != NULL) {

                strcat(namePath, ".");

            }
            strncat(namePath, (PUCHAR)&NameObject->NameSeg, sizeof(NAMESEG));

        }


        for (i = strlen(namePath) - 1; i >= 0; --i) {

            if (namePath[i] == '_') {

                namePath[i] = '\0';

            } else {

                break;

            }


        }

    } else {

        namePath[0] = '\0';

    }

    EXIT( (4, "GetObjectPath=%s\n", namePath ) );
    return namePath;
}

PUCHAR
LOCAL
GetObjectTypeName(
    ULONG   ObjectType
    )
/*++

Routine Description:

    Returns a string which corresponds to the type object the object

Arugment:

    ObjectType  - The type that we wish to know about

Return Value:

    Globally Available String

--*/
{
    PUCHAR  type = NULL;
    ULONG   i;
    static struct {
        ULONG   ObjectType;
        PUCHAR  ObjectTypeName;
    } ObjectTypeTable[] =
        {
            OBJTYPE_UNKNOWN,    "Unknown",
            OBJTYPE_INTDATA,    "Integer",
            OBJTYPE_STRDATA,    "String",
            OBJTYPE_BUFFDATA,   "Buffer",
            OBJTYPE_PKGDATA,    "Package",
            OBJTYPE_FIELDUNIT,  "FieldUnit",
            OBJTYPE_DEVICE,     "Device",
            OBJTYPE_EVENT,      "Event",
            OBJTYPE_METHOD,     "Method",
            OBJTYPE_MUTEX,      "Mutex",
            OBJTYPE_OPREGION,   "OpRegion",
            OBJTYPE_POWERRES,   "PowerResource",
            OBJTYPE_PROCESSOR,  "Processor",
            OBJTYPE_THERMALZONE,"ThermalZone",
            OBJTYPE_BUFFFIELD,  "BuffField",
            OBJTYPE_DDBHANDLE,  "DDBHandle",
            OBJTYPE_DEBUG,      "Debug",
            OBJTYPE_OBJALIAS,   "ObjAlias",
            OBJTYPE_DATAALIAS,  "DataAlias",
            OBJTYPE_BANKFIELD,  "BankField",
            OBJTYPE_FIELD,      "Field",
            OBJTYPE_INDEXFIELD, "IndexField",
            OBJTYPE_DATA,       "Data",
            OBJTYPE_DATAFIELD,  "DataField",
            OBJTYPE_DATAOBJ,    "DataObject",
            OBJTYPE_PNP_RES,    "PNPResource",
            OBJTYPE_RES_FIELD,  "ResField",
            0,                  NULL
        };

    ENTER( (4, "GetObjectTypeName(Type=%02x)\n", ObjectType ) );

    for (i = 0; ObjectTypeTable[i].ObjectTypeName != NULL; i++) {

        if (ObjectType == ObjectTypeTable[i].ObjectType) {

            type = ObjectTypeTable[i].ObjectTypeName;
            break;

        }

    }

    EXIT( (4, "GetObjectTypeName=%s\n", type ? type : "NULL" ) );
    return type;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\upsdemo\demoups.h ===
/* DEMOUPS - UPS Minidriver Sample
 * Copyright (C) Microsoft Corporation, 2001, All rights reserved.
 * Copyright (C) American Power Conversion, 2001, All rights reserved.
 *
 * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 * KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 * PURPOSE.
 * 
 * File:    demoups.h
 * 
 * Author:  Stephen Berard
 *
 * Description: 
 *   DLL entry points for the Demo UPS Minidriver.
 *
 * Revision History:
 *   26Jun2001   Created
 */
#ifndef _INC_DEMOUPSDLL_H_
#define _INC_DEMPUPSDLL_H_

#ifdef __cplusplus
extern "C" {
#endif

#define UPSMINIDRIVER_API /* .def file used instead; __declspec(dllexport) */


// UPS MiniDriver Interface
UPSMINIDRIVER_API DWORD UPSInit();
UPSMINIDRIVER_API void  UPSStop(void);
UPSMINIDRIVER_API void  UPSWaitForStateChange(DWORD, DWORD);
UPSMINIDRIVER_API DWORD UPSGetState(void);
UPSMINIDRIVER_API void  UPSCancelWait(void);
UPSMINIDRIVER_API void  UPSTurnOff(DWORD);

// UPSGetState values
#define UPS_ONLINE 1
#define UPS_ONBATTERY 2
#define UPS_LOWBATTERY 4
#define UPS_NOCOMM 8


// UPSInit error values
#define UPS_INITUNKNOWNERROR    0
#define UPS_INITOK              1
#define UPS_INITNOSUCHDRIVER    2
#define UPS_INITBADINTERFACE    3
#define UPS_INITREGISTRYERROR   4
#define UPS_INITCOMMOPENERROR   5
#define UPS_INITCOMMSETUPERROR  6

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\upsdemo\demoups.cpp ===
/* DEMOUPS - UPS Minidriver Sample
 * Copyright (C) Microsoft Corporation, 2001, All rights reserved.
 * Copyright (C) American Power Conversion, 2001, All rights reserved.
 *
 * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 * KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 * PURPOSE.
 * 
 * File:    demoups.cpp
 * 
 * Author:  Stephen Berard
 *
 * Description: 
 *   Demo UPS Minidriver implementation.  This minidriver provides
 *   a basic framework for a UPS Minidriver.
 *
 * Revision History:
 *   26Jun2001   Created
 */
#include <windows.h>
#include "demoups.h"

// Global value used to indicate that the UPS state has changed
HANDLE theStateChangedEvent;

// Global handle to DLL module
HINSTANCE theDLLModuleHandle;

/**
 * DllMain
 *
 * Description:
 *   This method is called when the DLL is loaded or unloaded.
 *
 * Parameters:   
 *   aHandle:   the DLL module handle
 *   aReason:   flag indicating the reason why the entry point was called
 *   aReserved: reserved
 *
 * Returns:
 *   TRUE
 *
 */
BOOL APIENTRY DllMain(HINSTANCE aHandle, DWORD  aReason, LPVOID aReserved) {

  switch (aReason) {
    // DLL initialization code goes here
    case DLL_PROCESS_ATTACH:
      theDLLModuleHandle = aHandle;
      DisableThreadLibraryCalls(theDLLModuleHandle);   
      break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
      break;
  }
   
  return TRUE;
}


/**
 * UPSInit
 *
 * Description:
 *   Must be the first method called in the interface.  This method should do
 *   any initialization required and obtain the initial UPS state.
 *
 * Parameters:
 *   None
 *
 * Returns:
 *   UPS_INITOK: successful initialization
 *   UPS_INITUNKNOWNERROR: failed initialization
 *   
 */
UPSMINIDRIVER_API DWORD UPSInit() {
  DWORD init_err = UPS_INITOK;
  
  theStateChangedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  if (!theStateChangedEvent) {
      init_err = UPS_INITUNKNOWNERROR;
  }

  return init_err;
}


/**
 * UPSStop
 *
 * Description:
 *   Stops monitoring of the UPS.  This method should perform any necessary 
 *   cleanup.
 *
 * Parameters:
 *   None
 *
 * Returns:
 *   None
 *   
 */
UPSMINIDRIVER_API void UPSStop(void) {
  UPSCancelWait();  

  if (theStateChangedEvent) {
      CloseHandle(theStateChangedEvent);
      theStateChangedEvent = NULL;
  }
}


/**
 * UPSWaitForStateChange
 *
 * Description:
 *   Blocks until the state of the UPS differs from the value passed in 
 *   via aState or anInterval milliseconds has expired.  If anInterval has 
 *   a value of INFINITE this function will never timeout
 *
 * Parameters:
 *   aState: defines the state to wait for a change from,
 *           possible values:
 *           UPS_ONLINE 
 *           UPS_ONBATTERY
 *           UPS_LOWBATTERY
 *           UPS_NOCOMM
 *
 *   anInterval: timeout in milliseconds, or INFINITE for
 *               no timeout interval
 *
 * Returns:
 *   None
 *   
 */
UPSMINIDRIVER_API void UPSWaitForStateChange(DWORD aState, DWORD anInterval) {

  // Wait for the UPS state to change.  Typically a separate thread would be 
  // used to monitor the UPS and then set theStateChangedEvent to indicate 
  // that the state has changed.  In this demo we only report UPS_ONLINE so
  // we don't have a monitoring thread.
  if (theStateChangedEvent) {
    WaitForSingleObject(theStateChangedEvent, anInterval);
  }
}


/**
 * UPSGetState
 *
 * Description:
 *   Returns the current state of the UPS.  This demo minidriver always returns
 *   UPS_ONLINE.
 *
 * Parameters:
 *   None
 *
 * Returns: 
 *   possible values:
 *           UPS_ONLINE 
 *           UPS_ONBATTERY
 *           UPS_LOWBATTERY
 *           UPS_NOCOMM
 *   
 */
UPSMINIDRIVER_API DWORD UPSGetState(void) {

  // Determine the UPS state and return it.
  // Demo UPS minidriver always returns Online
  return UPS_ONLINE;
}


/**
 * UPSCancelWait
 *
 * Description:
 *   Interrupts a pending calls to UPSWaitForStateChange without regard to 
 *   timout or state change
 * 
 * Parameters:
 *   None
 *
 * Returns:
 *   None
 *   
 */
UPSMINIDRIVER_API void UPSCancelWait(void) {
  // Send a signal to interupt anything waiting.
  if (theStateChangedEvent) {
      SetEvent(theStateChangedEvent);
  }
}


/**
 * UPSTurnOff
 *
 * Description:
 *   Attempts to turn off the outlets on the UPS after the specified delay.
 *   This demo minidriver ignores this call and simply returns.  
 *
 * Parameters:
 *   aTurnOffDelay: the minimum amount of time to wait before
 *                  turning off the outlets on the UPS
 *
 * Returns:
 *   None
 *   
 */
UPSMINIDRIVER_API void UPSTurnOff(DWORD aTurnOffDelay) {
  // Code to power off the UPS goes here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\parsearg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    parsearg.c

Abstract:

    Argument Handling

Author:

    MikeTs

Environment:

    Any

Revision History:

--*/

#include "pch.h"

//
// Local function prototypes
//
ULONG
LOCAL
ParseArgSwitch(
    PUCHAR      *Argument,
    PARGTYPE    ArgumentArray,
    PPROGINFO   ProgramInfo
    );

VOID
LOCAL
PrintError(
    ULONG       ErrorCode,
    PUCHAR      Argument,
    PPROGINFO   ProgramInfo
    );

VOID
EXPORT
ParseProgramInfo(
    PUCHAR      ProgramName,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    This routine parses program path and module name

Arguments:

    ProgramName - The Argv[0] from main()
    ProgramInfo - Program Information structure

Return Value:

    None

--*/
{
    PUCHAR   ptr;

    ProgramInfo->ProgPath = _strlwr(ProgramName);
    ptr = strrchr( ProgramName, '\\' );
    if (ptr != NULL) {

        *ptr = '\0';
        ProgramInfo->ProgName = ptr + 1;

    } else {

        ProgramInfo->ProgName = ProgramName;

    }

    ptr = strchr(ProgramInfo->ProgName, '.');
    if (ptr != NULL) {

        *ptr = '\0';

    }
}

ULONG
EXPORT
ParseSwitches(
    PULONG      ArgumentCount,
    PUCHAR      **ArgumentList,
    PARGTYPE    ArgumentArray,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    Parse command line switches

Arguments:

    ArgumentCount   - Pointer to the number of arguments
    ArgumentList    - Pointer to the pointer to the list of arguments
    ArgumentArray   - How to parse the arguments
    ProgramInfo     - Program Specific structure

Return Value:

    ULONG   - Success = ARGERR_NONE

--*/
{
    PUCHAR  argument;
    ULONG   status = ARGERR_NONE;

    if (ProgramInfo->SwitchChars == NULL) {

        ProgramInfo->SwitchChars = DEF_SWITCHCHARS;

    }
    if (ProgramInfo->Separators == NULL) {

        ProgramInfo->Separators = DEF_SEPARATORS;

    }

    for (; *ArgumentCount; (*ArgumentCount)--, (*ArgumentList)++)
    {
        argument = **ArgumentList;

        if (strchr(ProgramInfo->SwitchChars, *argument)) {

            argument++;
            status = ParseArgSwitch(
                &argument,
                ArgumentArray,
                ProgramInfo
                );
            if (status != ARGERR_NONE) {

                PrintError( status, argument, ProgramInfo );
                break;

            }

        } else {

            break;

        }

    }

    return status;
}

ULONG
LOCAL
ParseArgSwitch(
    PUCHAR      *Argument,
    PARGTYPE    ArgumentArray,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    Parse a command line switch

Arguments

    Argument        - Pointer to argument
    ArgumentArray   - How to handle the argument
    ProgramInfo     - Program Information Structure

Return Value:

    ULONG

--*/
{
    BOOL        found = FALSE;
    PARGTYPE    tableEntry;
    PUCHAR      argumentEnd;
    ULONG       length = 0;
    ULONG       status = ARGERR_NONE;

    tableEntry = ArgumentArray;
    while (tableEntry->ArgID[0]) {

        length = strlen(tableEntry->ArgID);
        if (tableEntry->ParseFlags & PF_NOI) {

            found = (strncmp(tableEntry->ArgID, *Argument, length) == 0);

        } else {

            found = (_strnicmp(tableEntry->ArgID, *Argument, length) == 0);

        }

        if (found) {

            break;
        }
        tableEntry++;

    }

    if (found) {

        *Argument += length;
        switch (tableEntry->ArgType) {
            case AT_STRING:
            case AT_NUM:
                if (tableEntry->ParseFlags & PF_SEPARATOR)
                {
                    if (**Argument &&
                        strchr(ProgramInfo->Separators, **Argument)) {

                        (*Argument)++;

                    } else {

                        status = ARGERR_NO_SEPARATOR;
                        break;

                    }

                }
                if (tableEntry->ArgType == AT_STRING) {

                    *(UCHAR **)tableEntry->ArgData = *Argument;

                } else {

                    *(ULONG *)tableEntry->ArgData = (ULONG)
                        strtoul(*Argument, &argumentEnd, tableEntry->ArgParam);
                    if (*Argument == argumentEnd) {

                        status = ARGERR_INVALID_NUM;
                        break;

                    }
                    *Argument = argumentEnd;

                }
                if (tableEntry->ArgVerify) {

                    status = (*tableEntry->ArgVerify)(Argument, tableEntry);

                }
                break;

            case AT_ENABLE:
            case AT_DISABLE:
                if (tableEntry->ArgType == AT_ENABLE) {

                    *(ULONG *)tableEntry->ArgData |= tableEntry->ArgParam;

                } else {

                    *(ULONG *)tableEntry->ArgData &= ~tableEntry->ArgParam;

                }

                if ( tableEntry->ArgVerify) {

                    status = (*tableEntry->ArgVerify)(Argument, tableEntry);
                    if (status == ARGERR_NONE) {

                        break;

                    }

                }

                if (**Argument) {

                    if (strchr(ProgramInfo->SwitchChars, **Argument)) {

                        (*Argument)++;

                    }
                    status = ParseArgSwitch(
                        Argument,
                        ArgumentArray,
                        ProgramInfo
                        );

                }
                break;

            case AT_ACTION:
                if (tableEntry->ParseFlags & PF_SEPARATOR)
                {
                    if (**Argument &&
                        strchr(ProgramInfo->Separators, **Argument)) {

                        (*Argument)++;

                    } else {

                        status = ARGERR_NO_SEPARATOR;
                        break;

                    }

                }

#pragma warning(disable: 4055)
                status = (*(PFNARG)tableEntry->ArgData)(Argument, tableEntry);
#pragma warning(default: 4055)

                break;

        }

    } else {

        status = ARGERR_UNKNOWN_SWITCH;

    }
    return status;
}

VOID
LOCAL
PrintError(
    ULONG       ErrorCode,
    PUCHAR      Argument,
    PPROGINFO   ProgramInfo
    )
/*++

Routine Description:

    Print Appropriate Error Message according to error code

Arguments:

    ErrorCode   - The error which occured
    Argument    - Argument in Error
    ProgramInfo - Program info structure

Return Value:

    VOID

--*/
{
    switch (ErrorCode) {
        case ARGERR_UNKNOWN_SWITCH:
            fprintf(
               stderr,
               "%s: unknown switch \"%s\"\n",
               ProgramInfo->ProgName,
               Argument
               );
            break;

        case ARGERR_NO_SEPARATOR:
            fprintf(
                stderr,
                "%s: separator missing after the switch char '%c'\n",
                ProgramInfo->ProgName,
                *(Argument-1)
                );
            break;

        case ARGERR_INVALID_NUM:
            fprintf(
                stderr,
                "%s: invalid numeric switch \"%s\"\n",
                ProgramInfo->ProgName,
                Argument
                );
            break;

        case ARGERR_INVALID_TAIL:
            fprintf(
                 stderr,
                 "%s: invalid argument tail \"%s\"\n",
                 ProgramInfo->ProgName,
                 Argument
                 );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\wmiacpi\wmimap.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wmimap.h

Abstract:

    ACPI to WMI mapping layer

Author:

    Alan Warwick

Environment:

    Kernel mode

Revision History:

--*/

#if DBG
    extern ULONG WmiAcpiDebug;
    #define WmiAcpiPrint(l,m)    if(l & WmiAcpiDebug) DbgPrint m
#else
    #define WmiAcpiPrint(l,m)
#endif

#define WmiAcpiError        0x00000001
#define WmiAcpiWarning      0x00000002
#define WmiAcpiBasicTrace   0x00000004

#define WmiAcpiQueryTrace   0x00000010
#define WmiAcpiSetTrace     0x00000020
#define WmiAcpiMethodTrace  0x00000040
#define WmiAcpiEventTrace   0x00000080
#define WmiAcpiFncCtlTrace  0x00000100
#define WmiAcpiRegInfoTrace 0x00000200

#define WmiAcpiEvalTrace    0x00001000

#define ACPI_EVAL_OUTPUT_FUDGE sizeof(ACPI_EVAL_OUTPUT_BUFFER)

#define WmiAcpiPoolTag 'AimW'

typedef struct
{
    GUID Guid;
    union
    {
        CHAR ObjectId[2];
        struct 
        {
            UCHAR NotificationValue;
            UCHAR Reserved;
        } NotifyId;
    };
    USHORT Flags;
} WMIACPIMAPINFO, *PWMIACPIMAPINFO;

#define WmiAcpiMethodToMethodAsUlong(c1, c2, c3, c4) \
    ((ULONG)( c1 | (c2 << 8) | (c3 << 16) | (c4 << 24)))
        
#define _WDGMethodAsULONG (WmiAcpiMethodToMethodAsUlong('_','W','D','G'))

#define _WEDMethodAsULONG (WmiAcpiMethodToMethodAsUlong('_','W','E','D'))

typedef struct
{
    GUID Guid;             // Guid that names data block
    union
    {
        CHAR ObjectId[2];  // 2 character ACPI id for Data Blocks and Methods
        struct 
        {
            UCHAR NotificationValue;  // Byte value passed by event handler control method
            UCHAR Reserved[1];
        } NotifyId;
    };
    UCHAR InstanceCount;
    UCHAR Flags;
} WMIACPIGUIDMAP, *PWMIACPIGUIDMAP;

// Set this flag if the WCxx control method should be run to whenever 
// the first data consumer is interested in collecting the data block 
// and whenever the last data consumer is no longer interested.
#define WMIACPI_REGFLAG_EXPENSIVE   0x1

// Set this flag if the guid represents a set of WMI method calls and 
// not a data block
#define WMIACPI_REGFLAG_METHOD      0x2

// Set this flag if the data block is wholly composed of a string 
// and should be translated from ASCIZ to UNICODE in returning queries 
// and from UNICODE to ASCIZ when
// passing sets
#define WMIACPI_REGFLAG_STRING      0x04

// Set this flag if the guid maps to an event rather than a data block 
// or method
#define WMIACPI_REGFLAG_EVENT       0x08

typedef struct
{
    WORK_QUEUE_ITEM WorkQueueItem;
    PVOID CallerContext;
    PWORKER_THREAD_ROUTINE CallerWorkItemRoutine;
    PDEVICE_OBJECT DeviceObject;
    ULONG Status;
    PUCHAR OutBuffer;
    ULONG OutBufferSize;
} IRP_CONTEXT_BLOCK, *PIRP_CONTEXT_BLOCK;

//
// This defines the maximum size for the data returned from the _WED method
// and thus the maximum size of the data associated with an event
#define _WEDBufferSize 512

//
// Device extension for WMI acpi mapping devices
typedef struct
{
    PDEVICE_OBJECT LowerDeviceObject;
    PDEVICE_OBJECT LowerPDO;
    ULONG GuidMapCount;
    PWMIACPIMAPINFO WmiAcpiMapInfo;
    ULONG Flags;
    WMILIB_CONTEXT WmilibContext;    
    
    ACPI_INTERFACE_STANDARD      WmiAcpiDirectInterface;

	KMUTEX Mutex;
	
    BOOLEAN AcpiNotificationEnabled;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// If this flag is set that means that the device has been removed from the
// system and any requests sent to it should be rejected. The only memory
// that can be relied upon is the DeviceExtension, but nothing that the
// device extension points to.
#define DEVFLAG_REMOVED                           0x00000001

//
// If this flag is set then the device has successfully registered with WMI
#define DEVFLAG_WMIREGED                          0x00000002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\pch.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Precompiled Header for UnAssembler DLL

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _PCH_H
#define _PCH_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>

#include <stdio.h>      //for FILE *
#include <string.h>     //for _stricmp
#include <stdlib.h>     //for malloc
#include <memory.h>     //for memset
#include <ctype.h>      //for isspace
#include <windef.h>
#include <windows.h>
#include <imagehlp.h>

#ifndef LOCAL
    #define LOCAL   __cdecl
#endif
#ifndef EXPORT
    #define EXPORT  __cdecl
#endif

//
// We are compliant with Spec Version 1.00
//
#define SPEC_VER    100

#include "acpitabl.h"
#include "list.h"
#include "aml.h"

//
// Constants
//

// String constants
#define STR_PROGDESC            "ACPI Source Language Assembler"
#define STR_COPYRIGHT           "Copyright (c) 1996,1997 Microsoft Corporation"
#define STR_MS                  "MSFT"

// Misc. constants
#define NAMESEG_BLANK           0x5f5f5f5f      // "____"
#define NAMESEG_ROOT            0x5f5f5f5c      // "\___"
#define NAMESEG                 ULONG
#define SUPERNAME               NAMESEG
#define NSF_LOCAL_SCOPE         0x00000001


// Implementation constants
#define MAX_STRING_LEN          199
#define MAX_NAME_LEN            1599    //approx. 255*4 + 254 + 255
#define MAX_NAMECODE_LEN        1300    //approx. 255*4 + 2 + 255
#define MAX_MSG_LEN             127
#define MAX_ARGS                7
#define MAX_PACKAGE_LEN         0x0fffffff

// Term classes
#define TC_PNP_MACRO            0x00100000
#define TC_REF_OBJECT           0x00200000
#define TC_FIELD_MACRO          0x00400000
#define TC_DATA_OBJECT          0x00800000
#define TC_NAMED_OBJECT         0x01000000
#define TC_NAMESPACE_MODIFIER   0x02000000
#define TC_OPCODE_TYPE1         0x04000000
#define TC_OPCODE_TYPE2         0x08000000
#define TC_CONST_NAME           0x10000000
#define TC_SHORT_NAME           0x20000000
#define TC_COMPILER_DIRECTIVE   0x40000000
#define TC_KEYWORD              0x80000000
#define TC_OPCODE               (TC_OPCODE_TYPE1 | TC_OPCODE_TYPE2 | \
                                 TC_SHORT_NAME | TC_CONST_NAME | TC_DATA_OBJECT)
#define TC_OPCODE_TERM          (TC_OPCODE_TYPE1 | TC_OPCODE_TYPE2 | \
                                 TC_SHORT_NAME | TC_CONST_NAME | \
                                 TC_DATA_OBJECT | TC_NAMED_OBJECT | \
                                 TC_NAMESPACE_MODIFIER)

// Term flags
#define TF_ACTION_FLIST         0x00000001
#define TF_ACTION_VLIST         0x00000002
#define TF_PACKAGE_LEN          0x00000004
#define TF_CHECKNAME_EXIST      0x00000008
#define TF_FIELD_MACRO          TC_FIELD_MACRO
#define TF_DATA_OBJECT          TC_DATA_OBJECT
#define TF_NAMED_OBJECT         TC_NAMED_OBJECT
#define TF_NAMESPACE_MODIFIER   TC_NAMESPACE_MODIFIER
#define TF_OPCODE_TYPE1         TC_OPCODE_TYPE1
#define TF_OPCODE_TYPE2         TC_OPCODE_TYPE2
#define TF_CONST_NAME           TC_CONST_NAME
#define TF_SHORT_NAME           TC_SHORT_NAME
#define TF_COMPILER_DIRECTIVE   TC_COMPILER_DIRECTIVE
#define TF_KEYWORD              TC_KEYWORD
#define TF_PNP_MACRO            TC_PNP_MACRO
#define TF_OBJECT_LIST          (TC_NAMED_OBJECT | TC_NAMESPACE_MODIFIER)
#define TF_CODE_LIST            (TC_OPCODE_TYPE1 | TC_OPCODE_TYPE2)
#define TF_DATA_LIST            0x00010000
#define TF_FIELD_LIST           0x00020000
#define TF_BYTE_LIST            0x00040000
#define TF_DWORD_LIST           0x00080000
#define TF_PACKAGE_LIST         (TC_DATA_OBJECT | TC_SHORT_NAME | \
                                 TC_CONST_NAME)
#define TF_ALL_LISTS            (TF_DATA_OBJECT | TF_NAMED_OBJECT | \
                                 TF_NAMESPACE_MODIFIER | TF_OPCODE_TYPE1 | \
                                 TF_OPCODE_TYPE2 | TF_SHORT_NAME | \
                                 TF_CONST_NAME | TF_COMPILER_DIRECTIVE | \
                                 TF_DATA_LIST | TF_PACKAGE_LIST | \
                                 TF_FIELD_LIST | TF_PNP_MACRO | TF_BYTE_LIST |\
                                 TF_DWORD_LIST)

// Code flags
#define CF_MISSING_ARG          0x00000001
#define CF_PARSING_FIXEDLIST    0x00000002
#define CF_PARSING_VARLIST      0x00000004

// NS flags
#define NSF_EXIST_OK            0x00010000
#define NSF_EXIST_ERR           0x00020000

// Data types
#define CODETYPE_UNKNOWN        0
#define CODETYPE_ASLTERM        1
#define CODETYPE_NAME           2
#define CODETYPE_DATAOBJ        3
#define CODETYPE_FIELDOBJ       4
#define CODETYPE_INTEGER        5
#define CODETYPE_STRING         6
#define CODETYPE_KEYWORD        7
#define CODETYPE_USERTERM       8
#define CODETYPE_QWORD          9

// NameSpace object types
#define NSTYPE_UNKNOWN          'U'
#define NSTYPE_SCOPE            'S'
#define NSTYPE_FIELDUNIT        'F'
#define NSTYPE_DEVICE           'D'
#define NSTYPE_EVENT            'E'
#define NSTYPE_METHOD           'M'
#define NSTYPE_MUTEX            'X'
#define NSTYPE_OPREGION         'O'
#define NSTYPE_POWERRES         'P'
#define NSTYPE_PROCESSOR        'C'
#define NSTYPE_THERMALZONE      'T'
#define NSTYPE_OBJALIAS         'A'
#define NSTYPE_BUFFFIELD        'B'

#define OBJTYPE_PRIVATE         0xf0
#define OBJTYPE_PNP_RES         (OBJTYPE_PRIVATE + 0x00)
#define OBJTYPE_RES_FIELD       (OBJTYPE_PRIVATE + 0x01)

// Opcode classes
#define OPCLASS_INVALID         0
#define OPCLASS_DATA_OBJ        1
#define OPCLASS_NAME_OBJ        2
#define OPCLASS_CONST_OBJ       3
#define OPCLASS_CODE_OBJ        4
#define OPCLASS_ARG_OBJ         5
#define OPCLASS_LOCAL_OBJ       6

//dwfData flags
#define DATAF_BUFF_ALIAS        0x00000001
#define DATAF_GLOBAL_LOCK       0x00000002

//dwDataType values
#define OBJTYPE_UNKNOWN         0x00
#define OBJTYPE_INTDATA         0x01
#define OBJTYPE_STRDATA         0x02
#define OBJTYPE_BUFFDATA        0x03
#define OBJTYPE_PKGDATA         0x04
#define OBJTYPE_FIELDUNIT       0x05
#define OBJTYPE_DEVICE          0x06
#define OBJTYPE_EVENT           0x07
#define OBJTYPE_METHOD          0x08
#define OBJTYPE_MUTEX           0x09
#define OBJTYPE_OPREGION        0x0a
#define OBJTYPE_POWERRES        0x0b
#define OBJTYPE_PROCESSOR       0x0c
#define OBJTYPE_THERMALZONE     0x0d
#define OBJTYPE_BUFFFIELD       0x0e
#define OBJTYPE_DDBHANDLE       0x0f

//These are internal object types (not to be exported to the ASL code)
#define OBJTYPE_INTERNAL        0x80
#define OBJTYPE_DEBUG           (OBJTYPE_INTERNAL + 0x00)
#define OBJTYPE_OBJALIAS        (OBJTYPE_INTERNAL + 0x01)
#define OBJTYPE_DATAALIAS       (OBJTYPE_INTERNAL + 0x02)
#define OBJTYPE_BANKFIELD       (OBJTYPE_INTERNAL + 0x03)
#define OBJTYPE_FIELD           (OBJTYPE_INTERNAL + 0x04)
#define OBJTYPE_INDEXFIELD      (OBJTYPE_INTERNAL + 0x05)
#define OBJTYPE_DATA            (OBJTYPE_INTERNAL + 0x06)
#define OBJTYPE_DATAFIELD       (OBJTYPE_INTERNAL + 0x07)
#define OBJTYPE_DATAOBJ         (OBJTYPE_INTERNAL + 0x08)

//Predefined data values (dwDataValue)
#define DATAVALUE_ZERO          0
#define DATAVALUE_ONE           1
#define DATAVALUE_ONES          0xffffffff

//
// Macros
//
#define MEMALLOC(n)           malloc(n)
#define MEMFREE(p)            free(p)

//
// Type definitions
//
typedef int (LOCAL *PFNTERM)(PUCHAR, BOOL);

typedef struct _ObjData
{
    ULONG  Flags;                       //flags
    ULONG  Alias;                       //ref count if base obj,
                                        //  points to base obj if alias obj
    ULONG  DataType;                    //object type
    ULONG  DataValue;                   //object value
    ULONG  DataLen;                     //object buffer length
    PUCHAR DataBuff;                    //object buffer
} OBJDATA, *POBJDATA, **PPOBJDATA;

typedef struct _NSObj
{
    LIST    List;                        //NOTE: list must be first in structure
    struct _NSObj *ParentObject;
    struct _NSObj *FirstChild;
    ULONG   Signature;
    ULONG   NameSeg;
    HANDLE  Owner;
    struct _NSObj *OwnedNext;
    OBJDATA ObjectData;
    ULONG   Context;
} NSOBJ, *PNSOBJ, **PPNSOBJ;

#define SIG_NSOBJ               'SNTM'

typedef struct _aslterm
{
    PUCHAR  ID;
    LONG    LongID;
    ULONG   TermClass;
    ULONG   TermData;
    ULONG   OpCode;
    PUCHAR  UnAsmArgTypes;
    PUCHAR  ArgTypes;
    PUCHAR  ArgActions;
    ULONG   Flags;
    PFNTERM Term;
} ASLTERM, *PASLTERM;

typedef struct _opmap
{
    UCHAR   ExtendedOpCode;
    UCHAR   OpCodeClass;
} OPMAP, *POPMAP;

#include "data.h"
#include "debug.h"
#include "namespac.h"
#include "parsearg.h"
#include "unasm.h"

#endif  //ifndef _ASLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\unasm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    unasm.h

Abstract:

    This unassembles an AML file

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#ifndef _UNASM_H_
#define _UNASM_H_

//
// Typedef for the print function
//
typedef VOID (*PUNASM_PRINT)(PCCHAR DebugMessage, ... );

//
// Global Variables
//
PUCHAR  TopOpcode;
PUCHAR  CurrentOpcode;
PUCHAR  StartOpcode;

//
// Functions
//
UCHAR
LOCAL
ComputeDataCheckSum(
    PUCHAR          OpCode,
    ULONG           Length
    );

VOID
LOCAL
DumpCode(
    PUCHAR          *Opcode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

PASLTERM
LOCAL
FindKeywordTerm(
    UCHAR   KeyWordGroup,
    UCHAR   Data
    );

UCHAR
LOCAL
FindOpClass(
    UCHAR       OpCode,
    POPMAP      OpCodeTable
    );

PASLTERM
LOCAL
FindOpTerm(
    ULONG   OpCode
    );

NTSTATUS
LOCAL
ParseNameTail(
    PUCHAR  *OpCode,
    PUCHAR  Buffer,
    ULONG   Length
    );

ULONG
LOCAL
ParsePackageLen(
    PUCHAR  *OpCode,
    PUCHAR  *OpCodeNext
    );

VOID
LOCAL
PrintIndent(
    PUNASM_PRINT    PrintFunction,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmArgs(
    PUCHAR          UnAsmArgTypes,
    PUCHAR          ArgActions,
    PUCHAR          *OpCode,
    PNSOBJ          *NameObject,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmDataList(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmDataObj(
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
EXPORT
UnAsmDSDT(
    PUCHAR          DSDT,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       DsdtLocation,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmField(
    PUCHAR          *OpCode,
    PULONG          BitPos,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmFieldList(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmHeader(
    PDESCRIPTION_HEADER DsdtHeader,
    PUNASM_PRINT        PrintFunction,
    ULONG_PTR           DsdtLocation,
    ULONG               IndentLevel
    );

NTSTATUS
EXPORT
UnAsmLoadDSDT(
    PUCHAR          DSDT
    );

NTSTATUS
LOCAL
UnAsmNameObj(
    PUCHAR          *OpCode,
    PNSOBJ          *NameObject,
    UCHAR           ObjectType,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmOpcode(
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmPkgList(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmScope(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmSuperName(
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

NTSTATUS
LOCAL
UnAsmTermObj(
    PASLTERM        Term,
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\wmiacpi\wmimap.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wmimap.c

Abstract:

    ACPI to WMI mapping layer

Author:

    Alan Warwick

Environment:

    Kernel mode

Revision History:

--*/

#define INITGUID

#include <wdm.h>

#ifdef MEMPHIS
//
// Lifted from ntrtl.h
NTSYSAPI
ULONG
NTAPI
RtlxUnicodeStringToAnsiSize(
    PUNICODE_STRING UnicodeString
    );

//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlUnicodeStringToAnsiSize(
//      PUNICODE_STRING UnicodeString
//      );
//

#define RtlUnicodeStringToAnsiSize(STRING) (                  \
    NLS_MB_CODE_PAGE_TAG ?                                    \
    RtlxUnicodeStringToAnsiSize(STRING) :                     \
    ((STRING)->Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR) \
)
#endif

#include <devioctl.h>
#include <acpiioct.h>
#include <wmistr.h>
#include <wmilib.h>
#include <wdmguid.h>

#include "wmimap.h"


#define WmiAcpiEnterCritSection(DeviceExtension) \
	KeWaitForMutexObject(&DeviceExtension->Mutex, \
                                       Executive, \
                                       KernelMode, \
                                       FALSE, \
                                       NULL)

#define WmiAcpiLeaveCritSection(DeviceExtension) \
    KeReleaseMutex(&DeviceExtension->Mutex, \
                   FALSE)


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
WmiAcpiPowerDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
WmiAcpiSystemControlDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
WmiAcpiPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );


NTSTATUS
WmiAcpiForwardIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
WmiAcpiUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
WmiAcpiAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
WmiAcpiSynchronousRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
WmiAcpiGetAcpiInterfaces(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PDEVICE_OBJECT   Pdo
    );

NTSTATUS
WmiAcpiCheckIncomingString(
    PUNICODE_STRING UnicodeString,
    ULONG BufferSize,
    PUCHAR Buffer,
    PWCHAR EmptyString
);

VOID
WmiAcpiNotificationWorkItem(
    IN PVOID Context
    );

VOID
WmiAcpiNotificationRoutine (
    IN PVOID            Context,
    IN ULONG            NotifyValue
    );

CHAR WmiAcpiXtoA(
    UCHAR HexDigit
    );

NTSTATUS
WmiAcpiAsyncEvalCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
WmiAcpiSendAsyncDownStreamIrp(
    IN  PDEVICE_OBJECT   DeviceObject,
    IN  PDEVICE_OBJECT   Pdo,
    IN  ULONG            Ioctl,
    IN  ULONG            InputBufferSize,
    IN  ULONG            OutputBufferSize,
    IN  PVOID            Buffer,
    IN  PWORKER_THREAD_ROUTINE CompletionRoutine,
    IN  PVOID CompletionContext,
    IN  PBOOLEAN IrpPassed
);

NTSTATUS
WmiAcpiSendDownStreamIrp(
    IN  PDEVICE_OBJECT   Pdo,
    IN  ULONG            Ioctl,
    IN  PVOID            InputBuffer,
    IN  ULONG            InputSize,
    IN  PVOID            OutputBuffer,
    IN  ULONG            *OutputBufferSize
);

ULONG WmiAcpiArgumentSize(
    IN PACPI_METHOD_ARGUMENT Argument
    );

NTSTATUS WmiAcpiCopyArgument(
    OUT PUCHAR Buffer,
    IN ULONG BufferSize,
    IN PACPI_METHOD_ARGUMENT Argument
    );

NTSTATUS WmiAcpiProcessResult(
    IN NTSTATUS Status,
    IN PACPI_EVAL_OUTPUT_BUFFER OutputBuffer,
    IN ULONG OutputBufferSize,
    OUT PUCHAR ResultBuffer,
    OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiSendMethodEvalIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethodInt(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethodIntBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN ULONG BufferArgumentSize,
    IN PUCHAR BufferArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethodIntIntBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN ULONG IntegerArgument2,
    IN ULONG BufferArgumentSize,
    IN PUCHAR BufferArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethodIntString(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN PUNICODE_STRING StringArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethodIntIntString(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN ULONG IntegerArgument2,
    IN PUNICODE_STRING StringArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    );

NTSTATUS WmiAcpiEvalMethodIntAsync(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    OUT PUCHAR ResultBuffer,
    IN ULONG ResultBufferSize,
    IN PWORKER_THREAD_ROUTINE CompletionRoutine,
    IN PVOID CompletionContext,
    IN PBOOLEAN IrpPassed
    );

NTSTATUS
WmiAcpiQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
WmiAcpiQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
WmiAcpiSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
WmiAcpiSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
WmiAcpiExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
WmiAcpiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)

#pragma alloc_text(PAGE,WmiAcpiSystemControlDispatch)
#pragma alloc_text(PAGE,WmiAcpiPnP)
#pragma alloc_text(PAGE,WmiAcpiUnload)
#pragma alloc_text(PAGE,WmiAcpiAddDevice)

#pragma alloc_text(PAGE,WmiAcpiSynchronousRequest)
#pragma alloc_text(PAGE,WmiAcpiGetAcpiInterfaces)

#pragma alloc_text(PAGE,WmiAcpiNotificationWorkItem)

#pragma alloc_text(PAGE,WmiAcpiCheckIncomingString)
#pragma alloc_text(PAGE,WmiAcpiXtoA)
#pragma alloc_text(PAGE,WmiAcpiArgumentSize)
#pragma alloc_text(PAGE,WmiAcpiCopyArgument)
#pragma alloc_text(PAGE,WmiAcpiProcessResult)

#pragma alloc_text(PAGE,WmiAcpiSendDownStreamIrp)
#pragma alloc_text(PAGE,WmiAcpiSendMethodEvalIrp)
#pragma alloc_text(PAGE,WmiAcpiEvalMethod)
#pragma alloc_text(PAGE,WmiAcpiEvalMethodInt)
#pragma alloc_text(PAGE,WmiAcpiEvalMethodIntBuffer)
#pragma alloc_text(PAGE,WmiAcpiEvalMethodIntIntBuffer)
#pragma alloc_text(PAGE,WmiAcpiEvalMethodIntString)
#pragma alloc_text(PAGE,WmiAcpiEvalMethodIntIntString)

#pragma alloc_text(PAGE,WmiAcpiQueryWmiRegInfo)
#pragma alloc_text(PAGE,WmiAcpiQueryWmiDataBlock)
#pragma alloc_text(PAGE,WmiAcpiSetWmiDataBlock)
#pragma alloc_text(PAGE,WmiAcpiSetWmiDataItem)
#pragma alloc_text(PAGE,WmiAcpiExecuteWmiMethod)
#pragma alloc_text(PAGE,WmiAcpiFunctionControl)
#endif

#if DBG
ULONG WmiAcpiDebug = 0;
#endif

UNICODE_STRING WmiAcpiRegistryPath;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    Installable driver initialization entry point.
    This is where the driver is called when the driver is being loaded
    by the I/O system.  This entry point is called directly by the I/O system.

Arguments:
    DriverObject - pointer to the driver object
    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiDriverEntry: %x Enter\n",
                  DriverObject
                     ));

    //
    // Save registry path for registering with WMI
    WmiAcpiRegistryPath.Length = 0;
    WmiAcpiRegistryPath.MaximumLength = RegistryPath->Length;
    WmiAcpiRegistryPath.Buffer = ExAllocatePoolWithTag(PagedPool,
                                           RegistryPath->Length+sizeof(WCHAR),
                            WmiAcpiPoolTag);
    if (WmiAcpiRegistryPath.Buffer != NULL)
    {
        RtlCopyUnicodeString(&WmiAcpiRegistryPath, RegistryPath);
    }

    //
    // Set up the device driver entry points.
    //
    DriverObject->DriverUnload                          = WmiAcpiUnload;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = WmiAcpiForwardIrp;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = WmiAcpiForwardIrp;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = WmiAcpiForwardIrp;

    DriverObject->MajorFunction[IRP_MJ_POWER]           = WmiAcpiPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = WmiAcpiPnP;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = WmiAcpiSystemControlDispatch;
    DriverObject->DriverExtension->AddDevice            = WmiAcpiAddDevice;


    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiDriverEntry: %x Return %x\n", DriverObject, ntStatus));

    return(ntStatus);
}

NTSTATUS
WmiAcpiPowerDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiPowerDispatch: %x Irp %x, Minor Function %x, Parameters %x %x %x %x\n",
                  DeviceObject,
                  Irp,
                  irpSp->MinorFunction,
                  irpSp->Parameters.WMI.ProviderId,
                  irpSp->Parameters.WMI.DataPath,
                  irpSp->Parameters.WMI.BufferSize,
                  irpSp->Parameters.WMI.Buffer));

    deviceExtension = DeviceObject->DeviceExtension;

    PoStartNextPowerIrp( Irp );
    if (deviceExtension->LowerDeviceObject != NULL) {

        //
        // Forward the request along
        //
        IoSkipCurrentIrpStackLocation( Irp );
        status = PoCallDriver( deviceExtension->LowerDeviceObject, Irp );

    } else {

        //
        // Complete the request with the current status
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return(status);
}

NTSTATUS
WmiAcpiSystemControlDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    PWMILIB_CONTEXT wmilibContext;
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    SYSCTL_IRP_DISPOSITION disposition;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiSystemControl: %x Irp %x, Minor Function %x, Provider Id %x, DataPath %x, BufferSize %x, Buffer %x\n",
                  DeviceObject,
                  Irp,
                  irpSp->MinorFunction,
                  irpSp->Parameters.WMI.ProviderId,
                  irpSp->Parameters.WMI.DataPath,
                  irpSp->Parameters.WMI.BufferSize,
                  irpSp->Parameters.WMI.Buffer));

    status = WmiSystemControl(wmilibContext,
                              DeviceObject,
                              Irp,
                              &disposition);

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiSystemControl: %x Irp %x returns %x, disposition %d\n",
                  DeviceObject,
                  Irp,
                  status,
                  disposition));

    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            status = WmiAcpiForwardIrp(DeviceObject, Irp);
            break;
        }

        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            status = WmiAcpiForwardIrp(DeviceObject,
                                       Irp);
            break;
        }
    }

    return(status);
}

NTSTATUS
WmiAcpiPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
Routine Description:
    Process the IRPs sent to this device.

Arguments:
    DeviceObject - pointer to a device object
    Irp          - pointer to an I/O Request Packet

Return Value:
    NTSTATUS
--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    PWMILIB_CONTEXT wmilibContext;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiPnp: %x Irp %x, Minor Function %x, Parameters %x %x %x %x\n",
                  DeviceObject,
                  Irp,
                  irpSp->MinorFunction,
                  irpSp->Parameters.WMI.ProviderId,
                  irpSp->Parameters.WMI.DataPath,
                  irpSp->Parameters.WMI.BufferSize,
                  irpSp->Parameters.WMI.Buffer));

    switch (irpSp->MinorFunction)
    {
        case IRP_MN_START_DEVICE:
        {
            status = IoWMIRegistrationControl(DeviceObject,
                                              WMIREG_ACTION_REGISTER);
            if (! NT_SUCCESS(status))
            {
                //
                // If registration with WMI fails then there is no point
                // in starting the device.
                WmiAcpiPrint(WmiAcpiError,
                             ("WmiAcpiPnP: %x IoWMIRegister failed %x\n",
                              DeviceObject,
                              status));
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return(status);
            } else {
                deviceExtension->Flags |= DEVFLAG_WMIREGED;
            }
            break;
        }

        case IRP_MN_REMOVE_DEVICE:
        {

            deviceExtension->Flags |= DEVFLAG_REMOVED;

            if (deviceExtension->AcpiNotificationEnabled)
            {
                deviceExtension->WmiAcpiDirectInterface.UnregisterForDeviceNotifications(
                                                deviceExtension->WmiAcpiDirectInterface.Context,
                                                WmiAcpiNotificationRoutine);
                deviceExtension->AcpiNotificationEnabled = FALSE;
            }

            if (deviceExtension->Flags & DEVFLAG_WMIREGED)
            {
                if (deviceExtension->WmiAcpiMapInfo != NULL)
                {
                    ExFreePool(deviceExtension->WmiAcpiMapInfo);
                    deviceExtension->WmiAcpiMapInfo = NULL;
                }

                if (wmilibContext->GuidList != NULL)
                {
                    ExFreePool(wmilibContext->GuidList);
                    wmilibContext->GuidList = NULL;
                }

                IoWMIRegistrationControl(DeviceObject,
                                         WMIREG_ACTION_DEREGISTER);
                deviceExtension->Flags &= ~DEVFLAG_WMIREGED;
            }

            IoDetachDevice(deviceExtension->LowerDeviceObject);
            IoDeleteDevice(DeviceObject);

            break;
        }
    }

    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

    return(status);
}


NTSTATUS
WmiAcpiForwardIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;

    deviceExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiForwardIrp: %x Irp %x, Major %x Minor %x, Parameters %x %x %x %x\n",
                  DeviceObject,
                  Irp,
                  irpSp->MajorFunction,
                  irpSp->MinorFunction,
                  irpSp->Parameters.WMI.ProviderId,
                  irpSp->Parameters.WMI.DataPath,
                  irpSp->Parameters.WMI.BufferSize,
                  irpSp->Parameters.WMI.Buffer));

    IoSkipCurrentIrpStackLocation(Irp);

    status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

    return(status);
}


VOID
WmiAcpiUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++
Routine Description:
    Free all the allocated resources, etc.

Arguments:
    DriverObject - pointer to a driver object

Return Value:
    None
--*/
{
    PAGED_CODE();

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiUnload: Driver %x is unloading\n",
                  DriverObject));
	if (WmiAcpiRegistryPath.Buffer != NULL)
	{
		ExFreePool(WmiAcpiRegistryPath.Buffer);
	}
}


NTSTATUS
WmiAcpiAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:
    This routine is called to create a new instance of the device

Arguments:
    DriverObject - pointer to the driver object for this instance of Sample
    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                status;
    PDEVICE_OBJECT          deviceObject = NULL;
    PWMILIB_CONTEXT         wmilibContext;
    PDEVICE_EXTENSION       deviceExtension;

    PAGED_CODE();

    WmiAcpiPrint(WmiAcpiBasicTrace,
                 ("WmiAcpiAddDevice: Driver %x, PDO %x\n",
                  DriverObject, PhysicalDeviceObject));

    status = IoCreateDevice (DriverObject,
                             sizeof(DEVICE_EXTENSION),
                             NULL,
                             FILE_DEVICE_UNKNOWN,
                             0,
                             FALSE,
                             &deviceObject);

    if (NT_SUCCESS(status))
    {

        deviceExtension = deviceObject->DeviceExtension;

		KeInitializeMutex(&deviceExtension->Mutex, 0);
		
        deviceExtension->LowerPDO = PhysicalDeviceObject;
        deviceExtension->LowerDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpiAddDevice: Created device %x to stack %x PDO %x\n",
                      deviceObject,
                      deviceExtension->LowerDeviceObject,
                      deviceExtension->LowerPDO));

        if (deviceExtension->LowerDeviceObject->Flags & DO_POWER_PAGABLE)
        {
            deviceObject->Flags |= DO_POWER_PAGABLE;
        }

        wmilibContext = &deviceExtension->WmilibContext;
        wmilibContext->GuidCount = 0;
        wmilibContext->GuidList = NULL;

        wmilibContext->QueryWmiRegInfo = WmiAcpiQueryWmiRegInfo;
        wmilibContext->QueryWmiDataBlock = WmiAcpiQueryWmiDataBlock;
        wmilibContext->SetWmiDataBlock = WmiAcpiSetWmiDataBlock;
        wmilibContext->SetWmiDataItem = WmiAcpiSetWmiDataItem;
        wmilibContext->ExecuteWmiMethod = WmiAcpiExecuteWmiMethod;
        wmilibContext->WmiFunctionControl = WmiAcpiFunctionControl;
		
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    } else {
        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpiAddDevice: Create device failed %x\n",
                      status));
    }
    return(status);
}

NTSTATUS
WmiAcpiSynchronousRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    Completion function for synchronous IRPs sent to this driver.
    No event.

--*/
{
    PAGED_CODE();
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
WmiAcpiGetAcpiInterfaces(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PDEVICE_OBJECT   Pdo
    )

/*++

Routine Description:

    Call ACPI driver to get the direct-call interfaces.  It does
    this the first time it is called, no more.

Arguments:

    None.

Return Value:

    Status

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    PDEVICE_OBJECT          LowerPdo;

    PAGED_CODE();

	WmiAcpiEnterCritSection(DeviceExtension);
	
    //
    // Only need to do this once
    //
    if (DeviceExtension->WmiAcpiDirectInterface.RegisterForDeviceNotifications == NULL) {

        LowerPdo = IoGetAttachedDeviceReference (Pdo);

        //
        // Allocate an IRP for below
        //
        Irp = IoAllocateIrp (LowerPdo->StackSize, FALSE);      // Get stack size from PDO

        if (!Irp) {
            WmiAcpiPrint(WmiAcpiError,
                ("WmiAcpiGetAcpiInterfaces: %x Failed to allocate Irp\n",
                 Pdo));

            ObDereferenceObject(LowerPdo);

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        IrpSp = IoGetNextIrpStackLocation(Irp);

        //
        // Use QUERY_INTERFACE to get the address of the direct-call ACPI interfaces.
        //
        IrpSp->MajorFunction = IRP_MJ_PNP;
        IrpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;

        IrpSp->Parameters.QueryInterface.InterfaceType          = (LPGUID) &GUID_ACPI_INTERFACE_STANDARD;
        IrpSp->Parameters.QueryInterface.Version                = 1;
        IrpSp->Parameters.QueryInterface.Size                   = sizeof (DeviceExtension->WmiAcpiDirectInterface);
        IrpSp->Parameters.QueryInterface.Interface              = (PINTERFACE) &DeviceExtension->WmiAcpiDirectInterface;
        IrpSp->Parameters.QueryInterface.InterfaceSpecificData  = NULL;

        IoSetCompletionRoutine (Irp, WmiAcpiSynchronousRequest, NULL, TRUE, TRUE, TRUE);
        Status = IoCallDriver (LowerPdo, Irp);

        IoFreeIrp (Irp);

        if (!NT_SUCCESS(Status)) {

            WmiAcpiPrint(WmiAcpiError,
               ("WmiAcpiGetAcpiInterfaces: Could not get ACPI driver interfaces, status = %x\n", Status));
        }

		ObDereferenceObject(LowerPdo);

    }

	WmiAcpiLeaveCritSection(DeviceExtension);
	
    return(Status);
}



NTSTATUS
WmiAcpiQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PWMILIB_CONTEXT wmilibContext;
    PDEVICE_EXTENSION deviceExtension;
    USHORT resultType;
    ULONG bufferSize;
    PUCHAR buffer;
    ULONG guidCount;
    NTSTATUS status;
    ULONG sizeNeeded;
    PWMIGUIDREGINFO guidList;
    PWMIACPIMAPINFO guidMapInfo;
    PWMIACPIGUIDMAP guidMap;
    ULONG i;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    //
    // Setup to use PDO instance names and our own registry path
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    if (WmiAcpiRegistryPath.Buffer != NULL)
    {
        *RegistryPath = &WmiAcpiRegistryPath;
    } else {
        *RegistryPath = NULL;
    }
    
    *Pdo = deviceExtension->LowerPDO;
    RtlInitUnicodeString(MofResourceName, L"MofResource");


    //
    // Build guid registration list from information obtained by calling
    // _WDG acpi method

    if (wmilibContext->GuidList == NULL)
    {
        bufferSize = 512;

        status = STATUS_BUFFER_TOO_SMALL;
        buffer = NULL;
        while (status == STATUS_BUFFER_TOO_SMALL)
        {
            if (buffer != NULL)
            {
                ExFreePool(buffer);
            }

            buffer = ExAllocatePoolWithTag(PagedPool,
                                           bufferSize,
                                           WmiAcpiPoolTag);

            if (buffer != NULL)
            {
                status = WmiAcpiEvalMethod(deviceExtension->LowerPDO,
                                       _WDGMethodAsULONG,
                                       buffer,
                                       &bufferSize,
                                       &resultType);
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (NT_SUCCESS(status))
        {
            guidCount = bufferSize / sizeof(WMIACPIGUIDMAP);

            sizeNeeded = guidCount * sizeof(WMIGUIDREGINFO);

            wmilibContext->GuidCount = guidCount;
            wmilibContext->GuidList = ExAllocatePoolWithTag(PagedPool,
                                                         sizeNeeded,
                                                         WmiAcpiPoolTag);
            if (wmilibContext->GuidList != NULL)
            {
                sizeNeeded = guidCount * sizeof(WMIACPIMAPINFO);
                deviceExtension->GuidMapCount = guidCount;
                deviceExtension->WmiAcpiMapInfo = ExAllocatePoolWithTag(
                                                             NonPagedPool,
                                                             sizeNeeded,
                                                             WmiAcpiPoolTag);
                if (deviceExtension->WmiAcpiMapInfo != NULL)
                {
                    guidMap = (PWMIACPIGUIDMAP)buffer;
                    guidList = wmilibContext->GuidList;
                    guidMapInfo = deviceExtension->WmiAcpiMapInfo;
                    for (i = 0; i < guidCount; i++, guidMap++, guidList++, guidMapInfo++)
                    {
                        //
                        // Cannot be both an event and a method or be both a
                        // method and data block.
                        ASSERT( ! ((guidMap->Flags & WMIACPI_REGFLAG_EVENT) &&
                               (guidMap->Flags & WMIACPI_REGFLAG_METHOD)));

                        guidMapInfo->ObjectId[0] = guidMap->ObjectId[0];
                        guidMapInfo->ObjectId[1] = guidMap->ObjectId[1];
                        guidMapInfo->Flags = guidMap->Flags;
                        guidMapInfo->Guid = guidMap->Guid;

                        guidList->Flags = 0;
                        guidList->Guid = &guidMapInfo->Guid;
                        guidList->InstanceCount = guidMap->InstanceCount;
                        if (guidMap->Flags & WMIACPI_REGFLAG_EXPENSIVE)
                        {
                            guidList->Flags |= WMIREG_FLAG_EXPENSIVE;
                        }

                        if (guidMap->Flags & WMIACPI_REGFLAG_EVENT)
                        {
                            guidList->Flags |= WMIREG_FLAG_EVENT_ONLY_GUID;
                        }

                    }
                } else {
                    ExFreePool(wmilibContext->GuidList);
                    wmilibContext->GuidList = NULL;
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (buffer != NULL)
        {
            ExFreePool(buffer);
        }

    } else {
        status = STATUS_SUCCESS;
    }

    return(status);
}

NTSTATUS
WmiAcpiQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call WmiCompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    ULONG sizeNeeded =0;
    ULONG padNeeded;
    ULONG i;
    ULONG methodAsUlong;
    PWMIACPIMAPINFO guidMapInfo;
    USHORT resultType;
    PUCHAR outBuffer;
    ULONG outBufferSize;
    ULONG currentInstanceIndex;
    BOOLEAN bufferTooSmall;
    PWMILIB_CONTEXT wmilibContext;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    if (GuidIndex < wmilibContext->GuidCount)
	{
		guidMapInfo = &((PWMIACPIMAPINFO)deviceExtension->WmiAcpiMapInfo)[GuidIndex];

		//
		// Query only valid for those datablocks registered as not events
		// or methods.
		bufferTooSmall = FALSE;
		if ((guidMapInfo->Flags &
				(WMIACPI_REGFLAG_METHOD | WMIACPI_REGFLAG_EVENT)) == 0)
		{
			methodAsUlong = WmiAcpiMethodToMethodAsUlong('W', 'Q',
													 guidMapInfo->ObjectId[0],
													 guidMapInfo->ObjectId[1]);

			status = STATUS_SUCCESS;
			sizeNeeded = 0;
			padNeeded = 0;
			for (i = 0; (i < InstanceCount) && NT_SUCCESS(status) ; i++)
			{
				currentInstanceIndex = i + InstanceIndex;

				sizeNeeded += padNeeded;
				if ((! bufferTooSmall) && (sizeNeeded < BufferAvail))
				{
					outBufferSize = BufferAvail - sizeNeeded;
					outBuffer = Buffer + sizeNeeded;
				} else {
					bufferTooSmall = TRUE;
					outBufferSize = 0;
					outBuffer = NULL;
				}

				status = WmiAcpiEvalMethodInt(deviceExtension->LowerPDO,
											  methodAsUlong,
											  currentInstanceIndex,
											  outBuffer,
											  &outBufferSize,
											  &resultType);

				sizeNeeded += outBufferSize;
				padNeeded = ((sizeNeeded + 7) & ~7) - sizeNeeded;

				if (NT_SUCCESS(status))
				{
					InstanceLengthArray[i] = outBufferSize;
				}

				if (status == STATUS_BUFFER_TOO_SMALL)
				{
					bufferTooSmall = TRUE;
					status = STATUS_SUCCESS;
				}
			}

		} else if (guidMapInfo->Flags & WMIACPI_REGFLAG_METHOD) {
			//
			// WBEM requires methods respond queries
			sizeNeeded = 0;
			if (InstanceLengthArray != NULL)
			{
				for (i = 0; i < InstanceCount; i++)
				{
					InstanceLengthArray[i] = 0;
				}
				status = STATUS_SUCCESS;
			} else {
				status = STATUS_BUFFER_TOO_SMALL;
			}
		} else {
			sizeNeeded = 0;
			status = STATUS_WMI_GUID_NOT_FOUND;
		}

		if (NT_SUCCESS(status) && bufferTooSmall)
		{
			status = STATUS_BUFFER_TOO_SMALL;
		}
	} else {
		status = STATUS_WMI_GUID_NOT_FOUND;
	}
    
    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
WmiAcpiCheckIncomingString(
    PUNICODE_STRING UnicodeString,
    ULONG BufferSize,
    PUCHAR Buffer,
    PWCHAR EmptyString
)
{
    ULONG status;
    USHORT stringLength;

    PAGED_CODE();

    if (BufferSize > sizeof(USHORT))
    {
        //
        // The length declared in the string must fit within the
        // passed in buffer
        stringLength = *((PUSHORT)Buffer);
        if ((stringLength + sizeof(USHORT)) <= BufferSize)
        {
            UnicodeString->Length = stringLength;
            UnicodeString->MaximumLength = stringLength;
            UnicodeString->Buffer = (PWCHAR)(Buffer + sizeof(USHORT));
            status = STATUS_SUCCESS;
        } else {
             status = STATUS_INVALID_PARAMETER;
        }
    } else if ((BufferSize == 0) ||
               ((BufferSize == sizeof(USHORT)) &&
                (*((PUSHORT)Buffer) == 0))) {
        //
        // An empty incoming buffer is translated into an empty string
        UnicodeString->Length = 0;
        UnicodeString->MaximumLength = 0;
        *EmptyString = UNICODE_NULL;
        UnicodeString->Buffer = EmptyString;
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INVALID_PARAMETER;
    }
    return(status);
}

NTSTATUS
WmiAcpiSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    ULONG methodAsUlong;
    PWMIACPIMAPINFO guidMapInfo;
    USHORT resultType;
    ULONG outBufferSize;
    PWMILIB_CONTEXT wmilibContext;
    UNICODE_STRING unicodeString;
    WCHAR emptyString;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    if (GuidIndex < wmilibContext->GuidCount)
	{
		guidMapInfo = &((PWMIACPIMAPINFO)deviceExtension->WmiAcpiMapInfo)[GuidIndex];

		//
		// Query only valid for those datablocks registered as not events
		// or methods.
		if ((guidMapInfo->Flags &
				(WMIACPI_REGFLAG_METHOD | WMIACPI_REGFLAG_EVENT)) == 0)
		{
			methodAsUlong = WmiAcpiMethodToMethodAsUlong('W', 'S',
													 guidMapInfo->ObjectId[0],
													 guidMapInfo->ObjectId[1]);

			outBufferSize = 0;

			if (guidMapInfo->Flags & WMIACPI_REGFLAG_STRING)
			{
				status = WmiAcpiCheckIncomingString(&unicodeString,
												   BufferSize,
												   Buffer,
												   &emptyString);
				if (NT_SUCCESS(status))
				{
					status = WmiAcpiEvalMethodIntString(deviceExtension->LowerPDO,
										  methodAsUlong,
										  InstanceIndex,
										  &unicodeString,
										  NULL,
										  &outBufferSize,
										  &resultType);

				}
			} else {
				status = WmiAcpiEvalMethodIntBuffer(deviceExtension->LowerPDO,
										  methodAsUlong,
										  InstanceIndex,
										  BufferSize,
										  Buffer,
										  NULL,
										  &outBufferSize,
										  &resultType);
			}

			if (status == STATUS_BUFFER_TOO_SMALL)
			{
				//
				// Since this operation is not supposed to return any results
				// then we need to ignore the fact that the return buffer
				// was too small.
				status = STATUS_SUCCESS;
			}

		} else {
			status = STATUS_WMI_GUID_NOT_FOUND;
		}
	} else {
		status = STATUS_WMI_GUID_NOT_FOUND;
	}

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
WmiAcpiSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data item. When the driver has finished setting the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    status = STATUS_INVALID_DEVICE_REQUEST;

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return(status);
}


NTSTATUS
WmiAcpiExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    ULONG methodAsUlong;
    PWMIACPIMAPINFO guidMapInfo;
    USHORT resultType;
    PWMILIB_CONTEXT wmilibContext;
    BOOLEAN voidResultExpected;
    UNICODE_STRING unicodeString;
    WCHAR emptyString;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    if (GuidIndex < wmilibContext->GuidCount)
	{
		guidMapInfo = &((PWMIACPIMAPINFO)deviceExtension->WmiAcpiMapInfo)[GuidIndex];

		//
		// Query only valid for those datablocks registered as not events
		// or methods.
		if (guidMapInfo->Flags & WMIACPI_REGFLAG_METHOD)
		{
			methodAsUlong = WmiAcpiMethodToMethodAsUlong('W', 'M',
													 guidMapInfo->ObjectId[0],
													 guidMapInfo->ObjectId[1]);

			voidResultExpected = (OutBufferSize == 0);

			if (guidMapInfo->Flags & WMIACPI_REGFLAG_STRING)
			{
				status = WmiAcpiCheckIncomingString(&unicodeString,
												   InBufferSize,
												   Buffer,
												   &emptyString);

				if (NT_SUCCESS(status))
				{
					status = WmiAcpiEvalMethodIntIntString(deviceExtension->LowerPDO,
										  methodAsUlong,
										  InstanceIndex,
										  MethodId,
										  &unicodeString,
										  Buffer,
										  &OutBufferSize,
										  &resultType);
				}

			} else {
				status = WmiAcpiEvalMethodIntIntBuffer(deviceExtension->LowerPDO,
										  methodAsUlong,
										  InstanceIndex,
										  MethodId,
										  InBufferSize,
										  Buffer,
										  Buffer,
										  &OutBufferSize,
										  &resultType);
			}

			if (voidResultExpected && (status == STATUS_BUFFER_TOO_SMALL))
			{
				//
				// Since this operation is not supposed to return any results
				// then we need to ignore the fact that the return buffer
				// was too small.
				status = STATUS_SUCCESS;
				OutBufferSize = 0;
			}
		} else {
			status = STATUS_WMI_GUID_NOT_FOUND;
		}
	} else {
		status = STATUS_WMI_GUID_NOT_FOUND;
	}

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     OutBufferSize,
                                     IO_NO_INCREMENT);

    return(status);
}

VOID
WmiAcpiNotificationWorkItem(
    IN PVOID Context
    )
/*++

Routine Description:


Arguments:


Return Value:

    None

--*/
{
    NTSTATUS status;
    PACPI_EVAL_OUTPUT_BUFFER buffer;
    ULONG bufferSize;
    PDEVICE_EXTENSION deviceExtension;
    ULONG processedBufferSize;
    PUCHAR processedBuffer;
    USHORT resultType;
    PIRP_CONTEXT_BLOCK irpContextBlock;
    LPGUID guid;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    irpContextBlock = (PIRP_CONTEXT_BLOCK)Context;

    deviceObject = irpContextBlock->DeviceObject;
    deviceExtension = deviceObject->DeviceExtension;

    status = irpContextBlock->Status;

    buffer = (PACPI_EVAL_OUTPUT_BUFFER)irpContextBlock->OutBuffer;
    bufferSize = irpContextBlock->OutBufferSize;

    guid = irpContextBlock->CallerContext;

    WmiAcpiPrint(WmiAcpiEvalTrace,
                 ("WmiAcpi: %x _WED --> %x, size = %d\n",
                      deviceObject,
                      status,
                      bufferSize));

    if (NT_SUCCESS(status) && (bufferSize > 0))
    {
        processedBufferSize = _WEDBufferSize * sizeof(WCHAR);

        processedBuffer = ExAllocatePoolWithTag(PagedPool,
                                            processedBufferSize,
                                            WmiAcpiPoolTag);

        if (processedBuffer != NULL)
        {
            status = WmiAcpiProcessResult(status,
                                          buffer,
                                          bufferSize,
                                          processedBuffer,
                                          &processedBufferSize,
                                          &resultType);
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (! NT_SUCCESS(status))
        {
            processedBufferSize = 0;
        }

    } else {
        processedBufferSize = 0;
        processedBuffer = NULL;
    }

	//
	// Processed buffer is freed by WmiFireEvent
	//
    status = WmiFireEvent(
                   deviceObject,
                   guid,
                   0,
                   processedBufferSize,
                   processedBuffer);

#if DBG
    if (! NT_SUCCESS(status))
    {
        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpi: %x WmiWriteEvent failed %x\n",
                      deviceObject,
                      status));
    }
#endif

    ExFreePool(buffer);
    ExFreePool(irpContextBlock);
}

VOID
WmiAcpiNotificationRoutine (
    IN PVOID            Context,
    IN ULONG            NotifyValue
    )
/*++

Routine Description:

    ACPI calls back this routine whenever the ACPI code fires a notification

Arguments:

    Context is the device object of the device whose ACPI code fired the event

    NotifyValue is the notify value fired by the ACPI code


Return Value:

    None

--*/
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PWMIACPIMAPINFO guidMapInfo;
    PUCHAR outBuffer;
    ULONG outBufferSize;
    ULONG i;
    NTSTATUS status;
    BOOLEAN irpPassed;

#if 0
    KIRQL oldIrql;
    oldIrql = KeRaiseIrqlToDpcLevel();
#endif

    deviceObject = (PDEVICE_OBJECT)Context;
    deviceExtension = deviceObject->DeviceExtension;

    guidMapInfo = (PWMIACPIMAPINFO)deviceExtension->WmiAcpiMapInfo;

    for (i = 0; i < deviceExtension->GuidMapCount; i++, guidMapInfo++)
    {
        if ((guidMapInfo->Flags & WMIACPI_REGFLAG_EVENT) &&
            (guidMapInfo->NotifyId.NotificationValue == NotifyValue))
        {
            outBufferSize = _WEDBufferSize;
            outBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                              outBufferSize,
                                              WmiAcpiPoolTag);

            irpPassed = FALSE;
            if (outBuffer != NULL)
            {
                status = WmiAcpiEvalMethodIntAsync(deviceObject,
                                              deviceExtension->LowerPDO,
                                              _WEDMethodAsULONG,
                                              NotifyValue,
                                              outBuffer,
                                              outBufferSize,
                                              WmiAcpiNotificationWorkItem,
                                              (PVOID)&guidMapInfo->Guid,
                                              &irpPassed);

            } else {
                WmiAcpiPrint(WmiAcpiError,
                             ("WmiAcpi: Event %d data lost due to insufficient resources\n",
                               NotifyValue));
            }

            if (! irpPassed)
            {
                //
                // If ACPI could not be called with an irp then fire an
                // empty event and cleanup.
                status = WmiFireEvent(
                               deviceObject,
                               &guidMapInfo[i].Guid,
                               0,
                               0,
                               NULL);

                if (outBuffer != NULL)
                {
                    ExFreePool(outBuffer);
                }
#if DBG
                if (! NT_SUCCESS(status))
                {
                    WmiAcpiPrint(WmiAcpiError,
                                 ("WmiAcpi: %x notification %x IoWMIFireEvent -> %x\n",
                              deviceObject, NotifyValue, status));
                }
#endif
            }

        }
    }
#if 0
    KeLowerIrql(oldIrql);
#endif
}

CHAR WmiAcpiXtoA(
    UCHAR HexDigit
    )
{
    CHAR c;

    PAGED_CODE();

    if ((HexDigit >= 0x0a) && (HexDigit <= 0x0f))
    {
        c = HexDigit + 'A' - 0x0a;
    } else {
        c = HexDigit + '0';
    }

    return(c);
}

NTSTATUS
WmiAcpiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    ULONG methodAsUlong;
    PWMIACPIMAPINFO guidMapInfo;
    USHORT resultType;
    ULONG outBufferSize;
    PWMILIB_CONTEXT wmilibContext;
    CHAR c1, c2;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    wmilibContext = &deviceExtension->WmilibContext;

    if (GuidIndex < wmilibContext->GuidCount)
	{
		guidMapInfo = &((PWMIACPIMAPINFO)deviceExtension->WmiAcpiMapInfo)[GuidIndex];


		if (Function == WmiDataBlockControl)

		{
			methodAsUlong = WmiAcpiMethodToMethodAsUlong('W', 'C',
													 guidMapInfo->ObjectId[0],
													 guidMapInfo->ObjectId[1]);
		} else {
			if (guidMapInfo->Flags & WMIACPI_REGFLAG_EVENT)
			{
				if (Enable)
				{
					status = WmiAcpiGetAcpiInterfaces(deviceExtension,
													  deviceExtension->LowerPDO);

					if (NT_SUCCESS(status))
					{
						if (! deviceExtension->AcpiNotificationEnabled)
						{
							status = deviceExtension->WmiAcpiDirectInterface.RegisterForDeviceNotifications(
													   deviceExtension->WmiAcpiDirectInterface.Context,
													   WmiAcpiNotificationRoutine,
													   DeviceObject);

							deviceExtension->AcpiNotificationEnabled = NT_SUCCESS(status);
						}
					}
				}

				c1 = WmiAcpiXtoA((UCHAR)(guidMapInfo->NotifyId.NotificationValue >> 4));
				c2 = WmiAcpiXtoA((UCHAR)(guidMapInfo->NotifyId.NotificationValue & 0x0f));
				methodAsUlong = WmiAcpiMethodToMethodAsUlong('W', 'E',
															 c1,
															 c2);
			} else {
				methodAsUlong = 0;
			}
		}


		//
		// Query only valid for those datablocks registered as not events
		// or methods.
		if (NT_SUCCESS(status))
		{
			if (methodAsUlong != 0)
			{
				outBufferSize = 0;
				status = WmiAcpiEvalMethodInt(deviceExtension->LowerPDO,
											  methodAsUlong,
											  Enable ? 1 : 0,
											  NULL,
											  &outBufferSize,
											  &resultType);

				if (status == STATUS_BUFFER_TOO_SMALL)
				{
					//
					// Since this operation is not supposed to return any results
					// then we need to ignore the fact that the return buffer
					// was too small.
					status = STATUS_SUCCESS;
				}
			} else {
				status = STATUS_SUCCESS;
			}
		} else {
			WmiAcpiPrint(WmiAcpiError,
						 ("WmiAcpi: RegisterForDeviceNotification(%x) -> %x\n",
						   DeviceObject, status));
		}
	}

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
WmiAcpiAsyncEvalCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIRP_CONTEXT_BLOCK irpContextBlock;

    irpContextBlock = (PIRP_CONTEXT_BLOCK)Context;

    irpContextBlock->Status = Irp->IoStatus.Status;
    irpContextBlock->OutBufferSize = (ULONG)Irp->IoStatus.Information;
    irpContextBlock->OutBuffer = Irp->AssociatedIrp.SystemBuffer;

    ExInitializeWorkItem( &irpContextBlock->WorkQueueItem,
                          irpContextBlock->CallerWorkItemRoutine,
                          irpContextBlock );
    ExQueueWorkItem( &irpContextBlock->WorkQueueItem, DelayedWorkQueue );

    IoFreeIrp(Irp);
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
WmiAcpiSendAsyncDownStreamIrp(
    IN  PDEVICE_OBJECT   DeviceObject,
    IN  PDEVICE_OBJECT   Pdo,
    IN  ULONG            Ioctl,
    IN  ULONG            InputBufferSize,
    IN  ULONG            OutputBufferSize,
    IN  PVOID            Buffer,
    IN  PWORKER_THREAD_ROUTINE CompletionRoutine,
    IN  PVOID CompletionContext,
    IN  PBOOLEAN IrpPassed
)
/*++

Routine Description:

    Sends asynchronously an IRP_MJ_DEVICE_CONTROL to a device object

Arguments:

    Pdo             - The request is sent to this device object
    Ioctl           - the request
    InputBuffer     - The incoming request
    InputSize       - The size of the incoming request
    OutputBuffer    - The answer
    OutputSize      - The size of the answer buffer

Return Value:

    NT Status of the operation

--*/
{
    PIRP_CONTEXT_BLOCK  irpContextBlock;
    NTSTATUS            status;
    PIRP                irp;
    PIO_STACK_LOCATION irpSp;


    irpContextBlock = ExAllocatePoolWithTag(NonPagedPool,
                                            sizeof(IRP_CONTEXT_BLOCK),
                                            WmiAcpiPoolTag);

    if (irpContextBlock == NULL)
    {
        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpiSendAsyncDownStreamIrp: %x Failed to allocate Irp Context Block\n",
                      DeviceObject));
        *IrpPassed = FALSE;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    irp = IoAllocateIrp(Pdo->StackSize, TRUE);

    if (!irp)
    {
        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpiSendAsyncDownStreamIrp: %x Failed to allocate Irp\n",
                      DeviceObject));
        *IrpPassed = FALSE;
        ExFreePool(irpContextBlock);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode = Ioctl;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferSize;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferSize;

    irp->AssociatedIrp.SystemBuffer = Buffer;
    irp->Flags = IRP_BUFFERED_IO;

    irpContextBlock->CallerContext = CompletionContext;
    irpContextBlock->CallerWorkItemRoutine = CompletionRoutine;
    irpContextBlock->DeviceObject = DeviceObject;

    IoSetCompletionRoutine(irp,
                           WmiAcpiAsyncEvalCompletionRoutine,
                           irpContextBlock,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Pass request to Pdo
    //
    status = IoCallDriver(Pdo, irp);

    WmiAcpiPrint(WmiAcpiEvalTrace,
        ("WmiAcpiSendAsyncDownStreamIrp: %x Irp %x completed %x! \n",
         DeviceObject, irp, status )
        );


    *IrpPassed = TRUE;
    return(status);
}



NTSTATUS
WmiAcpiSendDownStreamIrp(
    IN  PDEVICE_OBJECT   Pdo,
    IN  ULONG            Ioctl,
    IN  PVOID            InputBuffer,
    IN  ULONG            InputSize,
    IN  PVOID            OutputBuffer,
    IN  ULONG            *OutputBufferSize
)
/*++

Routine Description:

    Sends synchronously an IRP_MJ_DEVICE_CONTROL to a device object

Arguments:

    Pdo             - The request is sent to this device object
    Ioctl           - the request
    InputBuffer     - The incoming request
    InputSize       - The size of the incoming request
    OutputBuffer    - The answer
    OutputSize      - The size of the answer buffer

Return Value:

    NT Status of the operation

--*/
{
    IO_STATUS_BLOCK     ioBlock;
    KEVENT              event;
    NTSTATUS            status;
    PIRP                irp;
    ULONG               OutputSize = *OutputBufferSize;

    PAGED_CODE();

    //
    // Initialize an event to wait on
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Build the request
    //
    irp = IoBuildDeviceIoControlRequest(
        Ioctl,
        Pdo,
        InputBuffer,
        InputSize,
        OutputBuffer,
        OutputSize,
        FALSE,
        &event,
        &ioBlock
        );

    if (!irp)
    {
        WmiAcpiPrint(WmiAcpiError,
                     ("WmiAcpiSendDownStreamIrp: %x Failed to allocate Irp\n",
                       Pdo
                         ));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Pass request to Pdo, always wait for completion routine
    //
    status = IoCallDriver(Pdo, irp);
    if (status == STATUS_PENDING) {

        //
        // Wait for the irp to be completed, then grab the real status code
        //
        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
    }

    //
    // Always get the return status from the irp. We don't trust the return
    // value since acpienum.c smashes it to STATUS_SUCCESS on memphis for some
    // reason.
    status = ioBlock.Status;

    //
    // Sanity check the data
    //
    *OutputBufferSize = (ULONG)ioBlock.Information;

    WmiAcpiPrint(WmiAcpiEvalTrace,
        ("WmiAcpiSendDownStreamIrp: %x Irp %x completed %x! \n",
         Pdo, irp, status )
        );


    return(status);
}

ULONG WmiAcpiArgumentSize(
    IN PACPI_METHOD_ARGUMENT Argument
    )
/*++

Routine Description:

    Determine the size needed to write the argument data into the WMI callers
    output buffer. For integers and buffers this is done by getting the size
    specified in the header. For strings this is done by determining the
    size of the string in UNICODE and adding the size of the preceedeing
    USHORT that holds the stirng length

Arguments:

    Argument is the ACPI method argument whose for whose data the WMI size
        is to be determined

Return Value:

    WMI size for the argument data

--*/
{
    ULONG size;
    ANSI_STRING AnsiString;

    PAGED_CODE();

    if (Argument->Type == ACPI_METHOD_ARGUMENT_STRING)
    {
        AnsiString.Length = Argument->DataLength;
        AnsiString.MaximumLength = Argument->DataLength;
        AnsiString.Buffer = Argument->Data;
        size = RtlAnsiStringToUnicodeSize(&AnsiString) + sizeof(USHORT);
    } else {
        size = Argument->DataLength;
    }
    return(size);
}

NTSTATUS WmiAcpiCopyArgument(
    OUT PUCHAR Buffer,
    IN ULONG BufferSize,
    IN PACPI_METHOD_ARGUMENT Argument
    )
/*++

Routine Description:

    Copy the argument data from the ACPI method argument into the WMI output
    buffer. For integer and buffers this is a straight copy, but for strings
    the string is converted to UNICODE with a USHORT containing the length
    (in bytes) of the string prependedded.

Arguments:

    Buffer has output buffer to which to write the data

    Argument is the ACPI method argument whose for whose data the WMI size
        is to be determined

Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    PAGED_CODE();

    if (Argument->Type == ACPI_METHOD_ARGUMENT_STRING)
    {
        AnsiString.Length = Argument->DataLength;
        AnsiString.MaximumLength = Argument->DataLength;
        AnsiString.Buffer = Argument->Data;
        UnicodeString.MaximumLength = (USHORT)BufferSize;
        UnicodeString.Length = 0;
        UnicodeString.Buffer = (PWCHAR)(Buffer + sizeof(USHORT));

        status = RtlAnsiStringToUnicodeString(&UnicodeString,
                                              &AnsiString,
                                              FALSE);

        if (NT_SUCCESS(status))
        {
            *((PUSHORT)Buffer) = UnicodeString.Length + sizeof(WCHAR);
        }
    } else {
        RtlCopyMemory(Buffer, Argument->Data, Argument->DataLength);
        status = STATUS_SUCCESS;
    }
    return(status);
}

NTSTATUS WmiAcpiProcessResult(
    IN NTSTATUS Status,
    IN PACPI_EVAL_OUTPUT_BUFFER OutputBuffer,
    IN ULONG OutputBufferSize,
    OUT PUCHAR ResultBuffer,
    OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Validates the results from a method evaluation and returns a pointer to
    the result data and the result size

Arguments:

    Status has the return status from the method evaluation irp

    OutputBufferSize is the number of bytes available in OutputBuffer that
        ACPI can use to write the result data structure

    OutputBuffer is the buffer acpi uses to return the result data structure

    ResultBuffer is the buffer to return the result data.

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    PACPI_METHOD_ARGUMENT argument, nextArgument;
    ULONG count;
    ULONG i;
    ULONG sizeNeeded;
    ULONG maxSize;
    ULONG argumentSize;
    PUCHAR resultPtr;
    PCHAR stringPtr;

    PAGED_CODE();
    
    if (NT_SUCCESS(Status))
    {
        ASSERT((OutputBufferSize == 0) ||
               (OutputBufferSize >= sizeof(ACPI_EVAL_OUTPUT_BUFFER)));

        if (OutputBufferSize != 0)
        {
            if (OutputBuffer->Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE)
            {
                Status = STATUS_UNSUCCESSFUL;
            } else if (OutputBuffer->Count == 0) {
                //
                // Apparently no data is returned from the method
                *ResultSize = 0;
            } else {
                count = OutputBuffer->Count;
                argument = &OutputBuffer->Argument[0];

                if (count == 1)
                {
                    *ResultType = argument->Type;
                } else {
                    //
                    // Return buffer as the data type of a package
                    *ResultType = ACPI_METHOD_ARGUMENT_BUFFER;
                }

                maxSize = *ResultSize;
                sizeNeeded = 0;
                for (i = 0; (i < count) ; i++)
                {
                    nextArgument = ACPI_METHOD_NEXT_ARGUMENT(argument);

                    if ((argument->Type == ACPI_METHOD_ARGUMENT_STRING) &&
                        (argument->DataLength != 0))
                    {
                        //
                        // ACPI will return strings that are padded at the
                        // end with extra NULs. We want to strip out the
                        // padding.
                        stringPtr = argument->Data + argument->DataLength - 1;
                        while ((stringPtr >= argument->Data) &&
                               (*stringPtr == 0))
                        {
                            argument->DataLength--;
                            stringPtr--;
                        }
                    }

                    argumentSize = WmiAcpiArgumentSize(argument);

                    if (argument->Type == ACPI_METHOD_ARGUMENT_INTEGER)
                    {
                        //
                        // If the argument is an integer then we need to
                        // ensure that it is aligned properly on a 4 byte
                        // boundry.
                        sizeNeeded = (sizeNeeded + 3) & ~3;
                    } else if (argument->Type == ACPI_METHOD_ARGUMENT_STRING) {
                        //
                        // If the argument is an string then we need to
                        // ensure that it is aligned properly on a 2 byte
                        // boundry.
                        sizeNeeded = (sizeNeeded + 1) & ~1;
                    }

                    resultPtr = ResultBuffer + sizeNeeded;

                    sizeNeeded += argumentSize;

                    if (sizeNeeded <= maxSize)
                    {
                        //
                        // If there is enough room in the output buffer then
                        // copy the data to it.
                        Status = WmiAcpiCopyArgument(resultPtr,
                                            argumentSize,
                                            argument);
                    } else {
                        Status = STATUS_BUFFER_TOO_SMALL;
                    }

                    argument = nextArgument;
                }

                *ResultSize = sizeNeeded;
            }
        } else {
            //
            // Result is a void
            *ResultType = ACPI_METHOD_ARGUMENT_BUFFER;
            *ResultSize = 0;
        }
    } else if (Status == STATUS_BUFFER_OVERFLOW) {
        ASSERT((OutputBufferSize == 0) ||
               (OutputBufferSize >= sizeof(ACPI_EVAL_OUTPUT_BUFFER)));

        if (OutputBufferSize >= sizeof(ACPI_EVAL_OUTPUT_BUFFER))
        {
            //
            // If the result is a package, that is has multiple arguments
            // then we need to multiply the size needed by sizeof(WCHAR)
            // in case the returned arguments are strings. We also
            // include the size needed for the result data plus
            // extra space for the argument descriptors since the result
            // is a package.
            *ResultSize = (OutputBuffer->Length * sizeof(WCHAR)) +
                          (OutputBuffer->Count * sizeof(ACPI_METHOD_ARGUMENT));
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            Status = STATUS_UNSUCCESSFUL;

        }
    } else {
        //
        // We much all other ACPI status codes into this one since the ACPI
        // codes are not mapped to any user mode error codes.
        Status = STATUS_UNSUCCESSFUL;
    }

    return(Status);
}


NTSTATUS WmiAcpiSendMethodEvalIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take an integer and a buffer argument
    and returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method

    InputBuffer is a buffer containing an ACPI_EVAL_INPUT_BUFFER_* structure

    InputBufferSize is the size of InputBuffer in bytes

    ResultBuffer is the WMI buffer to return the result data

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    PACPI_EVAL_OUTPUT_BUFFER outputBuffer;
    ULONG outputBufferSize;

    PAGED_CODE();

    outputBufferSize =     *ResultSize + ACPI_EVAL_OUTPUT_FUDGE;
    outputBuffer = ExAllocatePoolWithTag(PagedPool,
                                         outputBufferSize,
                                         WmiAcpiPoolTag);

    if (outputBuffer != NULL)
    {
        WmiAcpiPrint(WmiAcpiEvalTrace,
             ("WmiAcpiSendMethodEvalIrp: %x Eval Method %c%c%c%c \n",
              DeviceObject,
              ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[0],
              ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[1],
              ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[2],
              ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[3]
                 )
             );

           status = WmiAcpiSendDownStreamIrp(
                             DeviceObject,
                             IOCTL_ACPI_EVAL_METHOD,
                             InputBuffer,
                             InputBufferSize,
                             outputBuffer,
                             &outputBufferSize);

         WmiAcpiPrint(WmiAcpiEvalTrace,
                ("WmiAcpiSendMethodEvalIrp: %x Evaluated Method %c%c%c%c -> %x \n",
                 DeviceObject,
                 ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[0],
                 ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[1],
                 ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[2],
                 ((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->MethodName[3],
                 status
                  )
                );


           status = WmiAcpiProcessResult(status,
                                      outputBuffer,
                                      outputBufferSize,
                                      ResultBuffer,
                                      ResultSize,
                                      ResultType);

            if (outputBuffer != NULL)
            {
                ExFreePool(outputBuffer);
            }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}


NTSTATUS WmiAcpiEvalMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take no input arguments and returns
    a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method

    MethodAsUlong is the name of the method packed in a ULONG

    ResultBuffer is the buffer to return the result data

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    ACPI_EVAL_INPUT_BUFFER inputBuffer;

    PAGED_CODE();

    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    inputBuffer.MethodNameAsUlong = MethodAsUlong;

    status = WmiAcpiSendMethodEvalIrp(DeviceObject,
                                (PUCHAR)&inputBuffer,
                                sizeof(ACPI_EVAL_INPUT_BUFFER),
                                ResultBuffer,
                                ResultSize,
                                ResultType);

    return(status);
}

NTSTATUS WmiAcpiEvalMethodInt(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take a single integer argument and
    returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method

    MethodAsUlong is the name of the method packed in a ULONG

    IntegerArgument is the integer argument to pass to the method

    ResultBuffer is the buffer to return the result data

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER inputBuffer;

    PAGED_CODE();

    inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE;
    inputBuffer.MethodNameAsUlong = MethodAsUlong;
    inputBuffer.IntegerArgument = IntegerArgument;

    status = WmiAcpiSendMethodEvalIrp(DeviceObject,
                                (PUCHAR)&inputBuffer,
                                sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER),
                                ResultBuffer,
                                ResultSize,
                                ResultType);

    return(status);
}

NTSTATUS WmiAcpiEvalMethodIntBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN ULONG BufferArgumentSize,
    IN PUCHAR BufferArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take an integer and a buffer argument
    and returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method

    MethodAsUlong is the name of the method packed in a ULONG

    IntegerArgument is the integer argument to pass to the method

    BufferArgumentSize is the number of bytes contained in the buffer argument

    BufferArgument is a pointer to the buffer argument

    ResultBuffer is the buffer to return the result data

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX inputBuffer;
    ULONG inputBufferSize;
    PACPI_METHOD_ARGUMENT argument;

    PAGED_CODE();

    inputBufferSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
                         sizeof(ACPI_METHOD_ARGUMENT) +
                      BufferArgumentSize;

    inputBuffer = ExAllocatePoolWithTag(PagedPool,
                                        inputBufferSize,
                                        WmiAcpiPoolTag);
    if (inputBuffer != NULL)
    {
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->MethodNameAsUlong = MethodAsUlong;
        inputBuffer->ArgumentCount = 2;
        inputBuffer->Size = inputBufferSize;

        argument = &inputBuffer->Argument[0];
        argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        argument->DataLength = sizeof(ULONG);
        argument->Argument = IntegerArgument;

        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        argument->Type = ACPI_METHOD_ARGUMENT_BUFFER;
        argument->DataLength = (USHORT)BufferArgumentSize;
        RtlCopyMemory(argument->Data,
                      BufferArgument,
                      argument->DataLength);

        status = WmiAcpiSendMethodEvalIrp(DeviceObject,
                                          (PUCHAR)inputBuffer,
                                          inputBufferSize,
                                          ResultBuffer,
                                          ResultSize,
                                          ResultType);

          ExFreePool(inputBuffer);

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}

NTSTATUS WmiAcpiEvalMethodIntIntBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN ULONG IntegerArgument2,
    IN ULONG BufferArgumentSize,
    IN PUCHAR BufferArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take an integer and a buffer argument 
    and returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method
        
    MethodAsUlong is the name of the method packed in a ULONG
       
    IntegerArgument is the integer argument to pass to the method

    IntegerArgument2 is the second integer argument to pass to the method
        
    BufferArgumentSize is the number of bytes contained in the buffer argument
        
    BufferArgument is a pointer to the buffer argument
        
    ResultBuffer is the buffer to return the result data
        
    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.
                        
    *ResultType returns with the data type for the method result
        
Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX inputBuffer;
    ULONG inputBufferSize;
    PACPI_METHOD_ARGUMENT argument;
     
    PAGED_CODE();
        
    inputBufferSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
                         2 * sizeof(ACPI_METHOD_ARGUMENT) + 
                      BufferArgumentSize;
    
    inputBuffer = ExAllocatePoolWithTag(PagedPool,
                                        inputBufferSize,
                                        WmiAcpiPoolTag);
    if (inputBuffer != NULL)
    {
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->MethodNameAsUlong = MethodAsUlong;
        inputBuffer->ArgumentCount = 3;
        inputBuffer->Size = inputBufferSize;
            
        argument = &inputBuffer->Argument[0];            
        argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        argument->DataLength = sizeof(ULONG);
        argument->Argument = IntegerArgument;

        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        argument->DataLength = sizeof(ULONG);
        argument->Argument = IntegerArgument2;    
    
        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        argument->Type = ACPI_METHOD_ARGUMENT_BUFFER;
        argument->DataLength = (USHORT)BufferArgumentSize;
        RtlCopyMemory(argument->Data,
                      BufferArgument,
                      argument->DataLength);                              
            
        status = WmiAcpiSendMethodEvalIrp(DeviceObject,
                                          (PUCHAR)inputBuffer,
                                          inputBufferSize,
                                          ResultBuffer,
                                          ResultSize,
                                          ResultType);
            
          ExFreePool(inputBuffer);
        
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return(status);
}

NTSTATUS WmiAcpiEvalMethodIntString(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN PUNICODE_STRING StringArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take an integer and a string argument
    and returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method

    MethodAsUlong is the name of the method packed in a ULONG

    IntegerArgument is the integer argument to pass to the method

    StringArgument is a pointer to the string argument. This will be
        converted from unicode to ansi

    ResultBuffer is the buffer to return the result data

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX inputBuffer;
    ULONG inputBufferSize;
    PACPI_METHOD_ARGUMENT argument;
    USHORT stringLength;
    ANSI_STRING ansiString;

    PAGED_CODE();

    stringLength = (USHORT)(RtlUnicodeStringToAnsiSize(StringArgument) + 1);
    inputBufferSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
                         sizeof(ACPI_METHOD_ARGUMENT) +
                      stringLength;

    inputBuffer = ExAllocatePoolWithTag(PagedPool,
                                        inputBufferSize,
                                        WmiAcpiPoolTag);
    if (inputBuffer != NULL)
    {
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->MethodNameAsUlong = MethodAsUlong;
        inputBuffer->ArgumentCount = 2;
        inputBuffer->Size = inputBufferSize;

        argument = &inputBuffer->Argument[0];
        argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        argument->DataLength = sizeof(ULONG);
        argument->Argument = IntegerArgument;

        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        argument->Type = ACPI_METHOD_ARGUMENT_STRING;
        
        ansiString.MaximumLength = stringLength;
        ansiString.Length = 0;
        ansiString.Buffer = (PCHAR)&argument->Data;
        status = RtlUnicodeStringToAnsiString(&ansiString, 
                                              StringArgument, 
                                              FALSE);
        if (NT_SUCCESS(status))
        {
            //
            // add one to the length of the string since acpi assumes
            // that the DataLength is the length of the string PLUS the
            // nul terminator
            //
            argument->DataLength = ansiString.Length + 1;
            status = WmiAcpiSendMethodEvalIrp(DeviceObject,
                                          (PUCHAR)inputBuffer,
                                          inputBufferSize,
                                          ResultBuffer,
                                          ResultSize,
                                          ResultType);
            
        } else {
            WmiAcpiPrint(WmiAcpiError,
                         ("WmiAcpi: %x unicode to ansi conversion failed %x\n",
                                   DeviceObject,
                                   status));
        }
            
        ExFreePool(inputBuffer);
        
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return(status);
}


NTSTATUS WmiAcpiEvalMethodIntIntString(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    IN ULONG IntegerArgument2,
    IN PUNICODE_STRING StringArgument,
    OUT PUCHAR ResultBuffer,
    IN OUT ULONG *ResultSize,
    OUT USHORT *ResultType
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take an integer and a string argument 
    and returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method
        
    MethodAsUlong is the name of the method packed in a ULONG
       
    IntegerArgument is the integer argument to pass to the method
        
    IntegerArgument2 is the second integer argument to pass to the method
        
    StringArgument is a pointer to the string argument. This will be
        converted from unicode to ansi
        
    ResultBuffer is the buffer to return the result data
        
    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.
                        
    *ResultType returns with the data type for the method result
        
Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX inputBuffer;
    ULONG inputBufferSize;
    PACPI_METHOD_ARGUMENT argument;
    USHORT stringLength;
    ANSI_STRING ansiString;
     
    PAGED_CODE();
        
    stringLength = (USHORT)(RtlUnicodeStringToAnsiSize(StringArgument) + 1);
    inputBufferSize = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
                         2 * sizeof(ACPI_METHOD_ARGUMENT) + 
                      stringLength;
    
    inputBuffer = ExAllocatePoolWithTag(PagedPool,
                                        inputBufferSize,
                                        WmiAcpiPoolTag);
    if (inputBuffer != NULL)
    {
        inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        inputBuffer->MethodNameAsUlong = MethodAsUlong;
        inputBuffer->ArgumentCount = 3;
        inputBuffer->Size = inputBufferSize;
            
        argument = &inputBuffer->Argument[0];            
        argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        argument->DataLength = sizeof(ULONG);
        argument->Argument = IntegerArgument;

        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        argument->Type = ACPI_METHOD_ARGUMENT_INTEGER;
        argument->DataLength = sizeof(ULONG);
        argument->Argument = IntegerArgument2;
        
        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
        argument->Type = ACPI_METHOD_ARGUMENT_STRING;

        ansiString.MaximumLength = stringLength;
        ansiString.Length = 0;
        ansiString.Buffer = (PCHAR)&argument->Data;
        status = RtlUnicodeStringToAnsiString(&ansiString,
                                              StringArgument,
                                              FALSE);
        if (NT_SUCCESS(status))
        {
            //
            // add one to the length of the string since acpi assumes
            // that the DataLength is the length of the string PLUS the
            // nul terminator
            //
            argument->DataLength = ansiString.Length +1;
            status = WmiAcpiSendMethodEvalIrp(DeviceObject,
                                          (PUCHAR)inputBuffer,
                                          inputBufferSize,
                                          ResultBuffer,
                                          ResultSize,
                                          ResultType);

        } else {
            WmiAcpiPrint(WmiAcpiError,
                         ("WmiAcpi: %x unicode to ansi conversion failed %x\n",
                                   DeviceObject,
                                   status));
        }

        ExFreePool(inputBuffer);

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}



NTSTATUS WmiAcpiEvalMethodIntAsync(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG MethodAsUlong,
    IN ULONG IntegerArgument,
    OUT PUCHAR ResultBuffer,
    IN ULONG ResultBufferSize,
    IN PWORKER_THREAD_ROUTINE CompletionRoutine,
    IN PVOID CompletionContext,
    IN PBOOLEAN IrpPassed
    )
/*++

Routine Description:

    Evaluates a simple ACPI method that take a single integer argument and
    returns a buffer.

Arguments:

    DeviceObject is device object that will evaluate the method

    MethodAsUlong is the name of the method packed in a ULONG

    IntegerArgument is the integer argument to pass to the method

    ResultBuffer is the buffer to return the result data

    *ResultSize on entry has the maximum number of bytes that can be
        written into ResultBuffer. On return it has the actual number of
        bytes written to result buffer if ResultBuffer is large enough. If
        ResultBuffer is not large enough STATUS_BUFFER_TOO_SMALL is returned
        and *ResultSize returns the actual number of bytes needed.

    *ResultType returns with the data type for the method result

Return Value:

    NT Status of the operation

--*/
{
    NTSTATUS status;
    PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER inputBuffer;

    ASSERT(ResultBuffer != NULL);
    ASSERT(ResultBufferSize >= sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER));

    inputBuffer = (PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER)ResultBuffer;
    inputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE;
    inputBuffer->MethodNameAsUlong = MethodAsUlong;
    inputBuffer->IntegerArgument = IntegerArgument;

    status = WmiAcpiSendAsyncDownStreamIrp(
                             DeviceObject,
                             Pdo,
                             IOCTL_ACPI_ASYNC_EVAL_METHOD,
                             sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER),
                             ResultBufferSize,
                             ResultBuffer,
                             CompletionRoutine,
                             CompletionContext,
                             IrpPassed);
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\tools\unasm2\unasm.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    unasm.c

Abstract:

    This unassembles an AML file

Author:

    Based on code by Mike Tsang (MikeTs)
    Stephane Plante (Splante)

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"

ULONG   DSDTLoaded = FALSE;

UCHAR
LOCAL
ComputeDataCheckSum(
    PUCHAR  OpCode,
    ULONG   Length
    )
/*++

Routine Description:

    This routine performs a data check sum on the supplied opcode pointer

Arguments:

    OpCode  - Data Buffer
    Length  - Number of bytes in buffer

Return Value:

    UCHAR

--*/
{
    UCHAR   checkSum = 0;

    while (Length > 0) {

        checkSum += *OpCode;
        OpCode++;
        Length--;

    }

    return checkSum;
}

DllInit(
    HANDLE  Module,
    ULONG   Reason,
    ULONG   Reserved
    )
/*++

Routine Description:

    This routine is called to initialize the DLL

Arguments:


Return Value:

--*/
{
    switch (Reason) {
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_ATTACH:
        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}

VOID
LOCAL
DumpCode(
    PUCHAR          *Opcode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    This routine doesn't do much right now, but it is the point where
    raw bytes should be displayed as well as the unassembly

Arguments:

    OpCode          - Pointer to the OpCode
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    if (PrintFunction != NULL) {

        PrintFunction("\n");

    }
}

PASLTERM
LOCAL
FindKeywordTerm(
    UCHAR   KeyWordGroup,
    UCHAR   Data
    )
/*++

Routine Description:

    Find a Keyword within the TermTable

Arguments:

    KeyWordGroup    - What to search for
    Data            - Data to match keyword

Return Value:

    PASLTERM

--*/
{
    PASLTERM    term = NULL;
    ULONG       i;

    for (i = 0; TermTable[i].ID != NULL; i++) {

        if ((TermTable[i].TermClass == TC_KEYWORD) &&
            (TermTable[i].ArgActions[0] == KeyWordGroup) &&
            ((Data & (UCHAR)(TermTable[i].TermData >> 8)) ==
             (UCHAR)(TermTable[i].TermData & 0xff))) {

            break;

        }

    }

    if (TermTable[i].ID != NULL) {

        term = &TermTable[i];

    }


    return term;
}

UCHAR
LOCAL
FindOpClass(
    UCHAR       OpCode,
    POPMAP      OpCodeTable
    )
/*++

Routine Description:

    Find opcode class of extended opcode

Arguments:

    OpCode      - The Opcode to look up
    OpCodeTable - The table to look in

Return Value:

    UCHAR

--*/
{
    UCHAR   opCodeClass = OPCLASS_INVALID;

    while (OpCodeTable->OpCodeClass != 0) {

        if (OpCode == OpCodeTable->ExtendedOpCode) {

            opCodeClass = OpCodeTable->OpCodeClass;
            break;

        }


        OpCodeTable++;

    }

    return opCodeClass;
}

PASLTERM
LOCAL
FindOpTerm(
    ULONG   OpCode
    )
/*++

Routine Description:

    Find an OpCode within the TermTable

Arguments:

    OpCode  - What to look for in the TermTable

Return Value:

    PASLTERM

--*/
{
    PASLTERM    term = NULL;
    ULONG       i;

    for (i = 0; TermTable[i].ID != NULL; i++) {

        if ( (TermTable[i].OpCode == OpCode) &&
             (TermTable[i].TermClass & TC_OPCODE_TERM) ) {

            break;

        }

    }

    if (TermTable[i].ID != NULL) {

        term = &TermTable[i];

    }


    return term;
}

ULONG
EXPORT
IsDSDTLoaded(
    VOID
    )
/*++

Routine Description:

    This routine returns wether or not we have loaded a DSDT image

Arguments:

    None

Return:

    ULONG

--*/
{
    return DSDTLoaded;
}

NTSTATUS
LOCAL
ParseNameTail(
    PUCHAR  *OpCode,
    PUCHAR  Buffer,
    ULONG   Length
    )
/*++

Routine Description:

    Parse AML name tail

Arguments:

    OpCode  - Pointer to the OpCode
    Buffer  - Where to hold the parsed named
    Length  - Index to the tail of Buffer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       numSegments = 0;

    //
    // We do not check for invalid NameSeg characters here and assume that
    // the compiler does its job not generating it.
    //
    if (**OpCode == '\0'){

        //
        // There is no NameTail (i.e. either NULL name or name with just
        // prefixes.
        //
        (*OpCode)++;

    } else if (**OpCode == OP_MULTI_NAME_PREFIX) {

        (*OpCode)++;
        numSegments = (ULONG)**OpCode;
        (*OpCode)++;

    } else if (**OpCode == OP_DUAL_NAME_PREFIX) {

        (*OpCode)++;
        numSegments = 2;

    } else {

        numSegments = 1;

    }

    while ((numSegments > 0) && (Length + sizeof(NAMESEG) < MAX_NAME_LEN)) {

        strncpy(&Buffer[Length], (PUCHAR)(*OpCode), sizeof(NAMESEG));
        Length += sizeof(NAMESEG);
        *OpCode += sizeof(NAMESEG);
        numSegments--;

        if ((numSegments > 0) && (Length + 1 < MAX_NAME_LEN)) {

            Buffer[Length] = '.';
            Length++;

        }

    }

    if (numSegments > 0) {

        status = STATUS_NAME_TOO_LONG;

    } else {

        Buffer[Length] = '\0';

    }

    return status;
}

ULONG
LOCAL
ParsePackageLen(
    PUCHAR  *OpCode,
    PUCHAR  *OpCodeNext
    )
/*++

Routine Description:

    Parses the packages length

Arguments:

    OpCode      - Pointer to the current instruction
    OpCodeNode  - Where to hold a pointer to the next instruction

Return Value:

    ULONG - Package Length

--*/
{
    UCHAR   noBytes;
    UCHAR   i;
    ULONG   length;

    if (OpCodeNext != NULL) {

        *OpCodeNext = *OpCode;

    }

    length = (ULONG)(**OpCode);
    (*OpCode)++;
    noBytes = (UCHAR)((length & 0xc0) >> 6);
    if (noBytes != 0) {

        length &= 0x0000000f;
        for (i = 0; i < noBytes; i++) {

            length |= (ULONG)(**OpCode) << (i*8 + 4);
            (*OpCode)++;

        }

    }

    if (OpCodeNext != NULL) {

        *OpCodeNext += length;

    }
    return length;
}

VOID
LOCAL
PrintIndent(
    PUNASM_PRINT    PrintFunction,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Does the indenting required

Arguments:

    PrintFunction   - Function to call to indent
    IndentLevel     - How many levels to indent

Return Value:

    VOID

--*/
{
    ULONG   i;

    for (i = 0; i < IndentLevel; i++) {

        PrintFunction("  ");

    }

}

NTSTATUS
LOCAL
UnAsmArgs(
    PUCHAR          UnAsmArgTypes,
    PUCHAR          ArgActions,
    PUCHAR          *OpCode,
    PNSOBJ          *NameObject,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble Arguments:

Arguments:

    UnAsmArgTypes   - UnAsm ArgTypes String
    ArgActions      - Arg Action Types
    OpCode          - Pointer to the OpCode
    NameObject      - To hold created object
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    PASLTERM        term;
    static UCHAR    argData = 0;
    ULONG           i;
    ULONG           numArgs;

    numArgs = strlen(UnAsmArgTypes);
    if (PrintFunction != NULL) {

        PrintFunction("(");

    }

    for (i = 0; i < numArgs; i++){

        if ((i != 0) && (PrintFunction != NULL)) {

            PrintFunction(", ");

        }

        switch (UnAsmArgTypes[i]) {
            case 'N':

                ASSERT(ArgActions != NULL);
                status = UnAsmNameObj(
                    OpCode,
                    (islower(ArgActions[i])? NameObject: NULL),
                    ArgActions[i],
                    PrintFunction,
                    BaseAddress,
                    IndentLevel
                    );
                break;

            case 'O':

                if ((**OpCode == OP_BUFFER) || (**OpCode == OP_PACKAGE) ||
                    (OpClassTable[**OpCode] == OPCLASS_CONST_OBJ)) {

                    term = FindOpTerm( (ULONG)(**OpCode) );
                    ASSERT(term != NULL);
                    (*OpCode)++;
                    status = UnAsmTermObj(
                        term,
                        OpCode,
                        PrintFunction,
                        BaseAddress,
                        IndentLevel
                        );

                } else {

                    status = UnAsmDataObj(
                        OpCode,
                        PrintFunction,
                        BaseAddress,
                        IndentLevel);

                }
                break;

            case 'C':

                status = UnAsmOpcode(
                    OpCode,
                    PrintFunction,
                    BaseAddress,
                    IndentLevel
                    );
                break;

            case 'B':

                if (PrintFunction != NULL) {

                    PrintFunction("0x%x", **OpCode);

                }
                *OpCode += sizeof(UCHAR);
                break;

            case 'K':
            case 'k':

                if (UnAsmArgTypes[i] == 'K') {

                    argData = **OpCode;
                }

                if ((ArgActions != NULL) && (ArgActions[i] == '!')) {

                    if (*NameObject != NULL) {

                        (*NameObject)->ObjectData.DataValue =
                            (ULONG)(**OpCode & 0x07);

                    }

                    if (PrintFunction != NULL) {

                        PrintFunction("0x%x", **OpCode & 0x07);

                    }

                } else if (PrintFunction != NULL) {

                    term = FindKeywordTerm(ArgActions[i], argData);
                    ASSERT(term != NULL);
                    PrintFunction("%s", term->ID);

                }

                if (UnAsmArgTypes[i] == 'K') {

                    *OpCode += sizeof(UCHAR);

                }
                break;

            case 'W':

                if (PrintFunction != NULL) {

                    PrintFunction("0x%x", *( (PUSHORT)*OpCode ) );

                }
                *OpCode += sizeof(USHORT);
                break;

            case 'D':

                if (PrintFunction != NULL) {

                    PrintFunction("0x%x", *( (PULONG)*OpCode ) );

                }
                *OpCode += sizeof(ULONG);
                break;

            case 'S':

                ASSERT(ArgActions != NULL);
                status = UnAsmSuperName(
                    OpCode,
                    PrintFunction,
                    BaseAddress,
                    IndentLevel
                    );
                break;

            default:

                status = STATUS_ACPI_INVALID_ARGTYPE;

        }

    }

    if (PrintFunction != NULL) {

        PrintFunction(")");

    }
    return status;

}

NTSTATUS
LOCAL
UnAsmDataList(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble Data List

Arguments:

    OpCode          - Pointer to the OpCode
    OpCodeEnd       - End of List
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       i;

    //
    // This is another place that DumpCode() was being called from
    //
    DumpCode(
        OpCode,
        PrintFunction,
        BaseAddress,
        IndentLevel
        );

    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("{\n");

    }

    while (*OpCode < OpCodeEnd) {

        if (PrintFunction != NULL) {

            PrintFunction("\t0x%02x", **OpCode);

        }

        (*OpCode)++;
        for (i = 1; (*OpCode < OpCodeEnd) && (i < 12); ++i) {

            if (PrintFunction != NULL) {

                PrintFunction(", 0x%02x", **OpCode);

            }
            (*OpCode)++;

        }

        if (PrintFunction != NULL) {

            if (*OpCode < OpCodeEnd) {

                PrintFunction(",");

            }
            PrintFunction("\n");

        }
    }

    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("}");

    }
    return status;
}

NTSTATUS
LOCAL
UnAsmDataObj(
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassembles a data object

Arguments:

    OpCode          - Pointer to the OpCode
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    UCHAR       localOpcode = **OpCode;

    (*OpCode)++;
    switch (localOpcode)
    {
        case OP_BYTE:
            if (PrintFunction != NULL)
            {
                PrintFunction("0x%x", **OpCode);
            }
            *OpCode += sizeof(UCHAR);
            break;

        case OP_WORD:
            if (PrintFunction != NULL)
            {
                PrintFunction("0x%x", *((PUSHORT)*OpCode));
            }
            *OpCode += sizeof(USHORT);
            break;

        case OP_DWORD:
            if (PrintFunction != NULL)
            {
                PrintFunction("0x%x", *((PULONG)*OpCode));
            }
            *OpCode += sizeof(ULONG);
            break;

        case OP_STRING:
            if (PrintFunction != NULL)
            {
                PrintFunction("\"%s\"", *OpCode);
            }
            *OpCode += strlen((PUCHAR)*OpCode) + 1;
            break;

        default:
            status = STATUS_ACPI_INVALID_OPCODE;

    }

    return status;
}

NTSTATUS
EXPORT
UnAsmDSDT(
    PUCHAR          DSDT,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       DsdtLocation,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    This routine unassembles an entire DSDT table

Arguments:

    DSDT            - Where the DSDT is located in memory
    PrintFunction   - What function to call to print to the user
    DsdtLocation    - Where the DSDT is located in memory
    IndentLevel     - How much space to indent from the left margin

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDESCRIPTION_HEADER header = (PDESCRIPTION_HEADER) DSDT;

    ASSERT(RootNameSpaceObject != NULL);
    CurrentOwnerNameSpaceObject = NULL;
    CurrentScopeNameSpaceObject = RootNameSpaceObject;
    TopOpcode = CurrentOpcode = DSDT;

    //
    // Dump the header
    //
    status = UnAsmHeader( header, PrintFunction, DsdtLocation, IndentLevel );
    if (NT_SUCCESS(status)) {

        DSDT += sizeof(DESCRIPTION_HEADER);
        status = UnAsmScope(
            &DSDT,
            (PUCHAR) (DSDT + header->Length - sizeof(DESCRIPTION_HEADER)),
            PrintFunction,
            DsdtLocation,
            IndentLevel
            );

    }

    return status;
}

NTSTATUS
LOCAL
UnAsmField(
    PUCHAR          *OpCode,
    PULONG          BitPos,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble field

Arguments:

    OpCode          - Pointer to the OpCode
    OpCodeEnd       - End of List
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;

    if (**OpCode == 0x01) {

        (*OpCode)++;
        if (PrintFunction != NULL) {

            PASLTERM term;

            term = FindKeywordTerm('A', **OpCode);
            PrintFunction(
                "AccessAs(%s, 0x%x)",
                term->ID,
                *(*OpCode + 1)
                );

        }
        *OpCode += 2;

    } else {

        UCHAR   nameSeg[sizeof(NAMESEG) + 1];
        ULONG   length;

        if (**OpCode == 0) {

            nameSeg[0] = '\0';
            (*OpCode)++;

        } else {

            strncpy(nameSeg, (PUCHAR)*OpCode, sizeof(NAMESEG));
            nameSeg[sizeof(NAMESEG)] = '\0';
            *OpCode += sizeof(NAMESEG);

        }

        length = ParsePackageLen(
            OpCode,
            NULL
            );
        if (nameSeg[0] == '\0') {

            if (PrintFunction != NULL) {

                if ((length > 32) && (((*BitPos + length) % 8) == 0)) {

                    PrintFunction(
                        "Offset(0x%x)",
                        (*BitPos + length)/8
                        );

                } else {

                    PrintFunction(
                        ", %d",
                        length
                        );

                }

            }

        } else {

            if (PrintFunction != NULL) {

                PrintFunction(
                    "%s, %d",
                    nameSeg,
                    length
                    );

            }

            if (PrintFunction == NULL) {

                status = CreateObject(
                    nameSeg,
                    NSTYPE_FIELDUNIT,
                    NULL
                    );

            }

        }
        *BitPos += length;

    }

    return status;
}

NTSTATUS
LOCAL
UnAsmFieldList(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble field list

Arguments:

    OpCode          - Pointer to the OpCode
    OpCodeEnd       - End of List
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       bitPos = 0;

    //
    // This is another place that DumpCode() was being called from
    //
    DumpCode(
        OpCode,
        PrintFunction,
        BaseAddress,
        IndentLevel
        );

    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("{\n");

    }
    IndentLevel++;

    while ((*OpCode < OpCodeEnd) && NT_SUCCESS(status)) {

        if (PrintFunction != NULL) {

            PrintIndent(PrintFunction, IndentLevel);

        }

        status = UnAsmField(
            OpCode,
            &bitPos,
            PrintFunction,
            BaseAddress,
            IndentLevel
            );

        if (NT_SUCCESS(status) && (*OpCode < OpCodeEnd) &&
            (PrintFunction != NULL) ) {

            PrintFunction(",");

        }

        //
        // This is another place that DumpCode() was being called from
        //
        DumpCode(
            OpCode,
            PrintFunction,
            BaseAddress,
            IndentLevel
            );

    }

    IndentLevel--;
    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("}");

    }

    return status;
}

NTSTATUS
LOCAL
UnAsmHeader(
    PDESCRIPTION_HEADER DsdtHeader,
    PUNASM_PRINT        PrintFunction,
    ULONG_PTR           DsdtLocation,
    ULONG               IndentLevel
    )
/*++

Routine Description:

    Unassembles the DSDT header

Arguments:

    DsdtHeader      - Header to unassemble
    PrintFunction   - Function to call to display information
    DsdtLocation    - Where in memory the DSDT Lives
    IndentLevel     - How much space to indent from the left margin

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    UCHAR       signature[sizeof(DsdtHeader->Signature) + 1] = {0};
    UCHAR       oemID[sizeof(DsdtHeader->OEMID) + 1] = {0};
    UCHAR       oemTableID[sizeof(DsdtHeader->OEMTableID) + 1] = {0};
    UCHAR       creatorID[sizeof(DsdtHeader->CreatorID) + 1] = {0};
    UCHAR       checkSum;

    //
    // Lets do a checksump on the entire table
    //
    checkSum = ComputeDataCheckSum(
        (PUCHAR) DsdtHeader,
        DsdtHeader->Length
        );
    if (checkSum != 0) {

        status = STATUS_ACPI_INVALID_TABLE;

    }

    strncpy(
        signature,
        (PUCHAR)&DsdtHeader->Signature,
        sizeof(DsdtHeader->Signature)
        );
    strncpy(
        oemID,
        (PUCHAR) DsdtHeader->OEMID,
        sizeof(DsdtHeader->OEMID)
        );
    strncpy(
        oemTableID,
        (PUCHAR) DsdtHeader->OEMTableID,
        sizeof(DsdtHeader->OEMTableID)
        );
    strncpy(
        creatorID,
        (PUCHAR) DsdtHeader->CreatorID,
        sizeof(DsdtHeader->CreatorID)
        );

    if (PrintFunction != NULL) {

        PrintIndent( PrintFunction, IndentLevel );
        PrintFunction(
            "// CreatorID = %s\tCreatorRevision =%x.%x.%d\n",
            creatorID,
            DsdtHeader->CreatorRev >> 24,
            ( (DsdtHeader->CreatorRev >> 16) & 0xFF),
            (DsdtHeader->CreatorRev & 0xFFFF)
            );

        PrintIndent( PrintFunction, IndentLevel );
        PrintFunction(
            "// TableLength = %d\tTableChkSum=0x%x\n\n",
            DsdtHeader->Length,
            DsdtHeader->Checksum
            );

        PrintIndent( PrintFunction, IndentLevel );
        PrintFunction(
            "DefinitionBlock(\"%s.AML\", \"%s\", 0x%02x, \"%s\", \"%s\", 0x%08x)",
            signature,
            signature,
            DsdtHeader->Revision,
            oemID,
            oemTableID,
            DsdtHeader->OEMRevision
            );

    }

    return status;
}

NTSTATUS
EXPORT
UnAsmLoadDSDT(
    PUCHAR          DSDT
    )
/*++

Routine Description:

    This routine causes the unassmebler to initialize itself with the
    given DSDT

Arguments:

    DSDT            - Where the DSDT is located in memory
    PrintFunction   - What function to call to print to the user
    DsdtLocation    - Where the DSDT is located in memory
    IndentLevel     - How much space to indent from the left margin

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDESCRIPTION_HEADER header = (PDESCRIPTION_HEADER) DSDT;
    PUCHAR              localDSDT;

    ENTER( (1, "UnAsmLoadDSDT(%08lx)\n", DSDT) );

    //
    // Step 1: Create the root namespace
    //
    status = CreateNameSpaceObject( "\\", NULL, NULL, NULL, NSF_EXIST_ERR );
    if (NT_SUCCESS(status)) {

        static struct _defobj {
            PUCHAR  Name;
            ULONG   ObjectType;
        } DefinedRootObjects[] = {
            "_GPE", OBJTYPE_UNKNOWN,
            "_PR", OBJTYPE_UNKNOWN,
            "_SB", OBJTYPE_UNKNOWN,
            "_SI", OBJTYPE_UNKNOWN,
            "_TZ", OBJTYPE_UNKNOWN,
            "_REV", OBJTYPE_INTDATA,
            "_OS", OBJTYPE_STRDATA,
            "_GL", OBJTYPE_MUTEX,
            NULL, 0
        };
        ULONG   i;
        PNSOBJ  nameObject;

        CurrentScopeNameSpaceObject = RootNameSpaceObject;
        for (i = 0; DefinedRootObjects[i].Name != NULL; i++) {

            //
            // Step 2: Create the fixed objects
            //
            status = CreateNameSpaceObject(
                DefinedRootObjects[i].Name,
                NULL,
                NULL,
                &nameObject,
                NSF_EXIST_ERR
                );
            if (NT_SUCCESS(status)) {

                nameObject->ObjectData.DataType =
                    DefinedRootObjects[i].ObjectType;

            } else {

                break;

            }

        }

        if (NT_SUCCESS(status)) {

            ASSERT(RootNameSpaceObject != NULL);
            CurrentOwnerNameSpaceObject = NULL;
            CurrentScopeNameSpaceObject = RootNameSpaceObject;
            TopOpcode = CurrentOpcode = DSDT;

            //
            // Step 3: Dump the header
            //
            status = UnAsmHeader( header, NULL, 0, 0 );
            if (NT_SUCCESS(status)) {

                //
                // Step 4: Dump the scope
                //
                localDSDT = DSDT + sizeof(DESCRIPTION_HEADER);
                status = UnAsmScope(
                    &localDSDT,
                    (PUCHAR) (DSDT + header->Length),
                    NULL,
                    0,
                    0
                    );

            }

        }

    }

    if (NT_SUCCESS(status)) {

        DSDTLoaded = 1;

    }

    EXIT( (1, "UnAsmLoadDSDT=%08lx\n", status ) );
    return status;
}

NTSTATUS
LOCAL
UnAsmNameObj(
    PUCHAR          *OpCode,
    PNSOBJ          *NameObject,
    UCHAR           ObjectType,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble name object

Arguments:

    OpCode          - Pointer to the OpCode
    NameObject      - Where to store the NS object if one is found/created
    ObjecType       - Type of NS object
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    UCHAR       name[MAX_NAME_LEN + 1];
    ULONG       length = 0;

    name[0] = '\0';
    if (**OpCode == OP_ROOT_PREFIX){

        name[length] = '\\';
        length++;
        (*OpCode)++;
        status = ParseNameTail(OpCode, name, length);

    } else if (**OpCode == OP_PARENT_PREFIX) {

        name[length] = '^';
        length++;
        (*OpCode)++;
        while ((**OpCode == OP_PARENT_PREFIX) && (length < MAX_NAME_LEN)) {

            name[length] = '^';
            length++;
            (*OpCode)++;

        }

        if (**OpCode == OP_PARENT_PREFIX) {

            status = STATUS_OBJECT_NAME_INVALID;

        } else {

            status = ParseNameTail(OpCode, name, length);

        }

    } else {

        status = ParseNameTail(OpCode, name, length);
    }

    if (NT_SUCCESS(status)) {

        PNSOBJ localObject = NULL;

        if (PrintFunction != NULL) {

            PrintFunction("%s", name);

        }

        if (isupper(ObjectType) || (PrintFunction != NULL)) {

            status = GetNameSpaceObject(
                name,
                CurrentScopeNameSpaceObject,
                &localObject,
                0
                );
            if (!NT_SUCCESS(status)) {

                status = STATUS_SUCCESS;

            }

        } else {

            status = CreateObject(
                name,
                (UCHAR) _toupper(ObjectType),
                &localObject
                );

        }

        if (NT_SUCCESS(status)) {

            if ((ObjectType == NSTYPE_SCOPE) && (localObject != NULL)) {

                CurrentScopeNameSpaceObject = localObject;

            }

            if (NameObject != NULL) {

                *NameObject = localObject;

            }

        }

    }

    return status;
}

NTSTATUS
LOCAL
UnAsmOpcode(
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble an Opcode

Arguments:

    OpCode          - Pointer to the OpCode
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PASLTERM    term;
    PNSOBJ      nameObject;
    UCHAR       opCodeClass;
    UCHAR       unAsmArgTypes[MAX_ARGS+1];
    ULONG       i;
    ULONG       localOpCode;

    if (**OpCode == OP_EXT_PREFIX) {

        (*OpCode)++;
        localOpCode = ( ( (ULONG) **OpCode) << 8) | OP_EXT_PREFIX;
        opCodeClass = FindOpClass(**OpCode, ExOpClassTable);

    } else {

        localOpCode = (ULONG)(**OpCode);
        opCodeClass = OpClassTable[**OpCode];

    }

    switch (opCodeClass) {
        case OPCLASS_DATA_OBJ:
            status = UnAsmDataObj(
                OpCode,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );
            break;

        case OPCLASS_NAME_OBJ:
            status = UnAsmNameObj(
                OpCode,
                &nameObject,
                NSTYPE_UNKNOWN,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );
            if (NT_SUCCESS(status) && nameObject != NULL &&
                nameObject->ObjectData.DataType == OBJTYPE_METHOD) {

                for (i = 0; i < nameObject->ObjectData.DataValue; i++) {

                    unAsmArgTypes[i] = 'C';

                }
                unAsmArgTypes[i] = '\0';

                status = UnAsmArgs(
                    unAsmArgTypes,
                    NULL,
                    OpCode,
                    NULL,
                    PrintFunction,
                    BaseAddress,
                    IndentLevel
                    );

            }
            break;

        case OPCLASS_ARG_OBJ:
        case OPCLASS_LOCAL_OBJ:
        case OPCLASS_CODE_OBJ:
        case OPCLASS_CONST_OBJ:

            term = FindOpTerm( localOpCode );
            if (term == NULL) {

                status = STATUS_ACPI_INVALID_OPCODE;

            } else {

                (*OpCode)++;
                status = UnAsmTermObj(
                    term,
                    OpCode,
                    PrintFunction,
                    BaseAddress,
                    IndentLevel
                    );

            }
            break;

        default:
            status = STATUS_ACPI_INVALID_OPCODE;
    }

    return status;
}

NTSTATUS
LOCAL
UnAsmPkgList(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble Package List

Arguments:

    OpCode          - Pointer to the OpCode
    OpCodeEnd       - End of List
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PASLTERM    term;

    //
    // This is another place that DumpCode() was being called from
    //
    DumpCode(
        OpCode,
        PrintFunction,
        BaseAddress,
        IndentLevel
        );

    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("{\n");

    }
    IndentLevel++;

    while ((*OpCode < OpCodeEnd) && NT_SUCCESS(status)) {

        if (PrintFunction != NULL) {

            PrintIndent(PrintFunction, IndentLevel);

        }

        if ((**OpCode == OP_BUFFER) ||
            (**OpCode == OP_PACKAGE) ||
            (OpClassTable[**OpCode] == OPCLASS_CONST_OBJ) ) {

            term = FindOpTerm( (ULONG)(**OpCode) );
            ASSERT(term != NULL);
            (*OpCode)++;
            status = UnAsmTermObj(
                term,
                OpCode,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        } else if (OpClassTable[**OpCode] == OPCLASS_NAME_OBJ) {

            status = UnAsmNameObj(
                OpCode,
                NULL,
                NSTYPE_UNKNOWN,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        } else {

            status = UnAsmDataObj(
                OpCode,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        }

        if ((*OpCode < OpCodeEnd) && NT_SUCCESS(status) &&
            (PrintFunction != NULL) ) {

            PrintFunction(",");

        }

        //
        // This is another place that DumpCode() was being called from
        //
        DumpCode(
            OpCode,
            PrintFunction,
            BaseAddress,
            IndentLevel
            );

    }

    IndentLevel--;
    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("}");

    }


    return status;
}

NTSTATUS
LOCAL
UnAsmScope(
    PUCHAR          *OpCode,
    PUCHAR          OpCodeEnd,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    OpCode          - Pointer to the current Opcode
    OpCodeEnd       - End of Scope
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;

    //
    // Note: This is where DumpCode used to be called, so if this code
    // is ever changed to dump the by bytes of the previous whatever, then
    // this is where it needs to be done from
    //
    DumpCode(
        OpCode,
        PrintFunction,
        BaseAddress,
        IndentLevel
        );

    //
    // Indent to the proper amount and dump opening brace
    //
    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("{\n");

    }

    //
    // Increase the indent level for future recursion
    //
    IndentLevel++;

    //
    // Loop while there are bytes in the scope
    //
    while ((NT_SUCCESS(status)) && (*OpCode < OpCodeEnd)) {

        //
        // Indent Again
        //
        if (PrintFunction != NULL) {

            PrintIndent(PrintFunction, IndentLevel);

        }

        //
        // Unassemble
        //
        status = UnAsmOpcode(
            OpCode,
            PrintFunction,
            BaseAddress,
            IndentLevel
            );

        //
        // This is another place where DumpCode was being called from
        //
        if ( StartOpcode != *OpCode) {

            DumpCode(
                OpCode,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        } else if (PrintFunction != NULL) {

            PrintFunction("\n");

        }

    }

    //
    // Return the IndentLevel to its proper value
    //
    IndentLevel--;

    //
    // Print the trailing brace
    //
    if (PrintFunction != NULL) {

        PrintIndent(PrintFunction, IndentLevel);
        PrintFunction("}");

    }

    //
    // Done
    //
    return status;
}

NTSTATUS
LOCAL
UnAsmSuperName(
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble supernames

Arguments:

    OpCode          - Pointer to the OpCode
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    if (**OpCode == 0) {

        (*OpCode)++;

    } else if ((**OpCode == OP_EXT_PREFIX) && (*(*OpCode + 1) == EXOP_DEBUG)) {

        if (PrintFunction != NULL) {

            PrintFunction("Debug");

        }
        *OpCode += 2;

    } else if (OpClassTable[**OpCode] == OPCLASS_NAME_OBJ) {

        status = UnAsmNameObj(
            OpCode,
            NULL,
            NSTYPE_UNKNOWN,
            PrintFunction,
            BaseAddress,
            IndentLevel
            );

    } else if ((**OpCode == OP_INDEX) ||
        (OpClassTable[**OpCode] == OPCLASS_ARG_OBJ) ||
        (OpClassTable[**OpCode] == OPCLASS_LOCAL_OBJ)) {

        status = UnAsmOpcode(
            OpCode,
            PrintFunction,
            BaseAddress,
            IndentLevel
            );

    } else {

        status = STATUS_ACPI_INVALID_SUPERNAME;

    }

    return status;
}

NTSTATUS
LOCAL
UnAsmTermObj(
    PASLTERM        Term,
    PUCHAR          *OpCode,
    PUNASM_PRINT    PrintFunction,
    ULONG_PTR       BaseAddress,
    ULONG           IndentLevel
    )
/*++

Routine Description:

    Unassemble term object

Arguments:

    Term            - Term Table Entry
    OpCode          - Pointer to the OpCode
    PrintFunction   - Function to call to print information
    BaseAddress     - Where the start of the scope lies, in memory
    IndentLevel     - How much white space to leave on the left

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PNSOBJ      scopeObject = CurrentScopeNameSpaceObject;
    PNSOBJ      nameObject = NULL;
    PUCHAR      opCodeEnd = NULL;

    if (PrintFunction != NULL) {

        PrintFunction("%s", Term->ID);

    }

    if (Term->Flags & TF_PACKAGE_LEN) {

        ParsePackageLen(OpCode, &opCodeEnd);

    }

    if (Term->UnAsmArgTypes != NULL) {

        status = UnAsmArgs(
           Term->UnAsmArgTypes,
           Term->ArgActions,
           OpCode,
           &nameObject,
           PrintFunction,
           BaseAddress,
           IndentLevel
           );

    }

    if (NT_SUCCESS(status)) {

        if (Term->Flags & TF_DATA_LIST) {

            status = UnAsmDataList(
                OpCode,
                opCodeEnd,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        } else if (Term->Flags & TF_PACKAGE_LIST) {

            status = UnAsmPkgList(
                OpCode,
                opCodeEnd,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        } else if (Term->Flags & TF_FIELD_LIST) {

            status = UnAsmFieldList(
                OpCode,
                opCodeEnd,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        } else if (Term->Flags & TF_PACKAGE_LEN) {

            if (nameObject != NULL) {

                CurrentScopeNameSpaceObject = nameObject;

            }
            status = UnAsmScope(
                OpCode,
                opCodeEnd,
                PrintFunction,
                BaseAddress,
                IndentLevel
                );

        }


    }


    CurrentScopeNameSpaceObject = scopeObject;
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agp440\agp440.h ===
#include "agp.h"

//
// Define the location of the GART aperture control registers
//

//
// The GART registers on the 440 live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//
#define AGP_440_GART_BUS_ID     0
#define AGP_440_GART_SLOT_ID    0

#define AGP_440LX_IDENTIFIER    0x71808086
#define AGP_440LX2_IDENTIFIER   0x71828086
#define AGP_440BX_IDENTIFIER    0x71908086
#define AGP_815_IDENTIFIER      0x11308086

#define APBASE_OFFSET  0x10             // Aperture Base Address
#define APSIZE_OFFSET  0xB4             // Aperture Size Register
#define PACCFG_OFFSET  0x50             // PAC Configuration Register
#define AGPCTRL_OFFSET 0xB0             // AGP Control Register
#define ATTBASE_OFFSET 0xB8             // Aperture Translation Table Base

#define READ_SYNC_ENABLE 0x2000

#define Read440Config(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_440_GART_BUS_ID,      \
                                  AGP_440_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define Write440Config(_buf_,_offset_,_size_)               \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_440_GART_BUS_ID,      \
                                  AGP_440_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

//
// Conversions from APSIZE encoding to MB
//
// 0x3F (b 11 1111) =   4MB
// 0x3E (b 11 1110) =   8MB
// 0x3C (b 11 1100) =  16MB
// 0x38 (b 11 1000) =  32MB
// 0x30 (b 11 0000) =  64MB
// 0x20 (b 10 0000) = 128MB
// 0x00 (b 00 0000) = 256MB

#define AP_SIZE_4MB     0x3F
#define AP_SIZE_8MB     0x3E
#define AP_SIZE_16MB    0x3C
#define AP_SIZE_32MB    0x38
#define AP_SIZE_64MB    0x30
#define AP_SIZE_128MB   0x20
#define AP_SIZE_256MB   0x00

#define AP_SIZE_COUNT 7
#define AP_MIN_SIZE (4 * 1024 * 1024)
#define AP_MAX_SIZE (256 * 1024 * 1024)

#define AP_815_SIZE_COUNT 2
#define AP_815_MAX_SIZE (64 * 1024 * 1024)

//
// Define the GART table entry.
//
typedef struct _GART_ENTRY_HW {
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;


//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)


typedef struct _GART_ENTRY_SW {
    ULONG State     : 3;
    ULONG Reserved  : 29;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the layout of the hardware registers
//
typedef struct _AGPCTRL {
    ULONG Reserved1     : 7;
    ULONG GTLB_Enable   : 1;
    ULONG Reserved2     : 24;
} AGPCTRL, *PAGPCTRL;

typedef struct _PACCFG {
    USHORT Reserved1    : 9;
    USHORT GlobalEnable : 1;
    USHORT PCIEnable    : 1;
    USHORT Reserved2    : 5;
} PACCFG, *PPACCFG;


//
// Define the 440-specific extension
//
typedef struct _AGP440_EXTENSION {
    BOOLEAN             GlobalEnable;
    BOOLEAN             PCIEnable;
    PHYSICAL_ADDRESS    ApertureStart;
    ULONG               ApertureLength;
    PGART_PTE           Gart;
    ULONG               GartLength;
    PHYSICAL_ADDRESS    GartPhysical;
    ULONGLONG           SpecialTarget;
} AGP440_EXTENSION, *PAGP440_EXTENSION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\acpi\wmiacpi\sample\makefile.inc ===
#
# generate auxilary files from the binary mof (bmf) file
#
# acpimof.vbs is a ready to run vbscript applet that will query all classes
#            in the mof. Once you add the ASL to the bios, 
#            update the registry, reboot, and ensure that the wmiacpi driver
#            has loaded run the script at the command line by typing: 
#            acpimof.vbs.

clean:
    del acpimof.vbs

$(O)\acpimof.bmf : $(O)\acpimof.mof

$(O)\acpimof.vbs: $(O)\acpimof.bmf
    wmimofck -t$(O)\acpimof.vbs $(O)\acpimof.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agp443\agp440.h ===
#include "agp.h"

//
// Define the location of the GART aperture control registers
//

//
// The GART registers on the 440 live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//
#define AGP_440_GART_BUS_ID     0
#define AGP_440_GART_SLOT_ID    0

#define AGP_440LX_IDENTIFIER    0x71808086
#define AGP_440LX2_IDENTIFIER   0x71828086
#define AGP_440BX_IDENTIFIER    0x71908086
#define AGP_815_IDENTIFIER      0x11308086

#define APBASE_OFFSET  0x10             // Aperture Base Address
#define APSIZE_OFFSET  0xB4             // Aperture Size Register
#define PACCFG_OFFSET  0x50             // PAC Configuration Register
#define AGPCTRL_OFFSET 0xB0             // AGP Control Register
#define ATTBASE_OFFSET 0xB8             // Aperture Translation Table Base

#define READ_SYNC_ENABLE 0x2000

//
// Conversions from APSIZE encoding to MB
//
// 0x3F (b 11 1111) =   4MB
// 0x3E (b 11 1110) =   8MB
// 0x3C (b 11 1100) =  16MB
// 0x38 (b 11 1000) =  32MB
// 0x30 (b 11 0000) =  64MB
// 0x20 (b 10 0000) = 128MB
// 0x00 (b 00 0000) = 256MB

#define AP_SIZE_4MB     0x3F
#define AP_SIZE_8MB     0x3E
#define AP_SIZE_16MB    0x3C
#define AP_SIZE_32MB    0x38
#define AP_SIZE_64MB    0x30
#define AP_SIZE_128MB   0x20
#define AP_SIZE_256MB   0x00

#define AP_SIZE_COUNT 7
#define AP_MIN_SIZE (4 * 1024 * 1024)
#define AP_MAX_SIZE (256 * 1024 * 1024)

#define AP_815_SIZE_COUNT 2
#define AP_815_MAX_SIZE (64 * 1024 * 1024)

//
// Define the GART table entry.
//
typedef struct _GART_ENTRY_HW {
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;


//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)


typedef struct _GART_ENTRY_SW {
    ULONG State     : 3;
    ULONG Reserved  : 29;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the layout of the hardware registers
//
typedef struct _AGPCTRL {
    ULONG Reserved1     : 7;
    ULONG GTLB_Enable   : 1;
    ULONG Reserved2     : 24;
} AGPCTRL, *PAGPCTRL;

typedef struct _PACCFG {
    USHORT Reserved1    : 9;
    USHORT GlobalEnable : 1;
    USHORT PCIEnable    : 1;
    USHORT Reserved2    : 5;
} PACCFG, *PPACCFG;


//
// Define the 440-specific extension
//
typedef struct _AGP440_EXTENSION {
    BOOLEAN             GlobalEnable;
    BOOLEAN             PCIEnable;
    PHYSICAL_ADDRESS    ApertureStart;
    ULONG               ApertureLength;
    PGART_PTE           Gart;
    ULONG               GartLength;
    PHYSICAL_ADDRESS    GartPhysical;
    ULONGLONG           SpecialTarget;
} AGP440_EXTENSION, *PAGP440_EXTENSION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agp440\init.c ===
/*++

Copyright (c) 1996, 1997 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code for AGP440.SYS.

Author:

    John Vert (jvert) 10/21/1997

Revision History:

--*/

#include "agp440.h"

ULONG AgpExtensionSize = sizeof(AGP440_EXTENSION);
PAGP_FLUSH_PAGES AgpFlushPages = NULL;  // not implemented


NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*++

Routine Description:

    Entrypoint for target initialization. This is called first.

Arguments:

    AgpExtension - Supplies the AGP extension

Return Value:

    NTSTATUS

--*/

{
    PAGP440_EXTENSION Extension = AgpExtension;

    //
    // Initialize our chipset-specific extension
    //
    Extension->ApertureStart.QuadPart = 0;
    Extension->ApertureLength = 0;
    Extension->Gart = NULL;
    Extension->GartLength = 0;
    Extension->GlobalEnable = FALSE;
    Extension->PCIEnable = FALSE;
    Extension->GartPhysical.QuadPart = 0;
    Extension->SpecialTarget = 0;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

    This is also called when the master transitions into the D0 state.

Arguments:

    AgpExtension - Supplies the AGP extension

    AgpCapabilities - Returns the capabilities of this AGP device.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    PAGP440_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable;
    ULONG DataRate;
    ULONG FastWrite;
    BOOLEAN ReverseInit;
    ULONG VendorId = 0;
    ULONG AgpCtrl = 0;
    
#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

    //
    // Intel says if all BIOS manufacturers perform RMW ops on this
    // register, then it will always be set, however two video OEMs
    // have complained of systems where this was not set, and was
    // causing the system to freeze, so we'll hard code it just in
    // case (only affects 440LX)
    //
    Read440Config(&VendorId, 0, sizeof(VendorId));
    if ((VendorId == AGP_440LX_IDENTIFIER) ||
        (VendorId == AGP_440LX2_IDENTIFIER)) {
        Read440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));
        AgpCtrl |= READ_SYNC_ENABLE;
        Write440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl)); 
    }

    //
    // Indicate that we can map memory through the GART aperture
    //
    *AgpCapabilities = AGP_CAPABILITIES_MAP_PHYSICAL;

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability returned no valid transfer rate\n"));
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = AgpLibGetPciDeviceCapability(0,0,&TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;

    AGP_ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);
    }

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing & MasterCap.AGPStatus.SideBandAddressing);

    //
    // Enable FastWrite if both master and target support it.
    //
    FastWrite = (TargetCap.AGPStatus.FastWrite & MasterCap.AGPStatus.FastWrite);

    //
    // Enable the Master first.
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.FourGBEnable = 0;  
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGP440InitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    //
    // Now enable the Target.
    //
    TargetCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    TargetCap.AGPCommand.FastWriteEnable = FastWrite;
    TargetCap.AGPCommand.FourGBEnable = 0;  
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.FourGBEnable = 0;  
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGP440InitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

#if DBG
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    AGP_ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    AGP_ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

    Status = AgpLibGetPciDeviceCapability(0,0,&CurrentCap);
    AGP_ASSERT(NT_SUCCESS(Status));
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agp440\gart.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    gart.c

Abstract:

    Routines for querying and setting the Intel 440xx GART aperture

Author:

    John Vert (jvert) 10/30/1997

Revision History:

--*/
#include "agp440.h"

//
// Local function prototypes
//
NTSTATUS
Agp440CreateGart(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

PGART_PTE
Agp440FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

NTSTATUS
Agp440SetRate(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

VOID
Agp440SetGTLB_Enable(
    IN PAGP440_EXTENSION AgpContext,
    IN BOOLEAN Enable
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpDisableAperture)
#pragma alloc_text(PAGE, AgpQueryAperture)
#pragma alloc_text(PAGE, AgpReserveMemory)
#pragma alloc_text(PAGE, AgpReleaseMemory)
#pragma alloc_text(PAGE, Agp440CreateGart)
#pragma alloc_text(PAGE, AgpMapMemory)
#pragma alloc_text(PAGE, AgpUnMapMemory)
#pragma alloc_text(PAGE, Agp440FindRangeInGart)
#pragma alloc_text(PAGE, AgpFindFreeRun)
#pragma alloc_text(PAGE, AgpGetMappedPages)
#endif

#define Agp440EnableTB(_x_) Agp440SetGTLB_Enable((_x_), TRUE)
#define Agp440DisableTB(_x_) Agp440SetGTLB_Enable((_x_), FALSE)


NTSTATUS
AgpQueryAperture(
    IN PAGP440_EXTENSION AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *pApertureRequirements
    )
/*++

Routine Description:

    Queries the current size of the GART aperture. Optionally returns
    the possible GART settings.

Arguments:

    AgpContext - Supplies the AGP context.

    CurrentBase - Returns the current physical address of the GART.

    CurrentSizeInPages - Returns the current GART size.

    ApertureRequirements - if present, returns the possible GART settings

Return Value:

    NTSTATUS

--*/

{
    ULONG ApBase;
    UCHAR ApSize;
    PIO_RESOURCE_LIST Requirements;
    ULONG i;
    ULONG Length;

    PAGED_CODE();
    //
    // Get the current APBASE and APSIZE settings
    //
    Read440Config(&ApBase, APBASE_OFFSET, sizeof(ApBase));
    Read440Config(&ApSize, APSIZE_OFFSET, sizeof(ApSize));

    ASSERT(ApBase != 0);
    CurrentBase->QuadPart = ApBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Convert APSIZE into the actual size of the aperture
    //
    switch (ApSize) {
        case AP_SIZE_4MB:
            *CurrentSizeInPages = 4 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_8MB:
            *CurrentSizeInPages = 8 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_16MB:
            *CurrentSizeInPages = 16 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_32MB:
            *CurrentSizeInPages = 32 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_64MB:
            *CurrentSizeInPages = 64 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_128MB:
            *CurrentSizeInPages = 128 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_256MB:
            *CurrentSizeInPages = 256 * (1024*1024 / PAGE_SIZE);
            break;

        default:
            AGPLOG(AGP_CRITICAL,
                   ("AGP440 - AgpQueryAperture - Unexpected value %x for ApSize!\n",
                    ApSize));
            ASSERT(FALSE);
            AgpContext->ApertureStart.QuadPart = 0;
            AgpContext->ApertureLength = 0;
            return(STATUS_UNSUCCESSFUL);
    }

    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    if (pApertureRequirements != NULL) {
        ULONG VendorId;

        //
        // 440 supports 7 different aperture sizes, all must be 
        // naturally aligned. Start with the largest aperture and 
        // work downwards so that we get the biggest possible aperture.
        //
        Requirements = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(IO_RESOURCE_LIST) + (AP_SIZE_COUNT-1)*sizeof(IO_RESOURCE_DESCRIPTOR),
                                             'RpgA');
        if (Requirements == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        Requirements->Version = Requirements->Revision = 1;
        
        //
        // 815 only supports 64MB and 32MB Aperture sizes
        //
        Read440Config(&VendorId, 0, sizeof(VendorId));
        if (VendorId == AGP_815_IDENTIFIER) {
            Requirements->Count = AP_815_SIZE_COUNT;
            Length = AP_815_MAX_SIZE;
        
        } else {
            Requirements->Count = AP_SIZE_COUNT;
            Length = AP_MAX_SIZE;
        }

        for (i=0; i<Requirements->Count; i++) {
            Requirements->Descriptors[i].Option = IO_RESOURCE_ALTERNATIVE;
            Requirements->Descriptors[i].Type = CmResourceTypeMemory;
            Requirements->Descriptors[i].ShareDisposition = CmResourceShareDeviceExclusive;
            Requirements->Descriptors[i].Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;

            Requirements->Descriptors[i].u.Memory.Length = Length;
            Requirements->Descriptors[i].u.Memory.Alignment = Length;
            Requirements->Descriptors[i].u.Memory.MinimumAddress.QuadPart = 0;
            Requirements->Descriptors[i].u.Memory.MaximumAddress.QuadPart = (ULONG)-1;

            Length = Length/2;
        }
        *pApertureRequirements = Requirements;


    }
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetAperture(
    IN PAGP440_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*++

Routine Description:

    Sets the GART aperture to the supplied settings

Arguments:

    AgpContext - Supplies the AGP context

    NewBase - Supplies the new physical memory base for the GART.

    NewSizeInPages - Supplies the new size for the GART

Return Value:

    NTSTATUS

--*/

{
    PACCFG PACConfig;
    UCHAR ApSize;
    ULONG ApBase;

    //
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) {
        case 4 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_4MB;
            break;
        case 8 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_8MB;
            break;
        case 16 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_16MB;
            break;
        case 32 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_32MB;
            break;
        case 64 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_64MB;
            break;
        case 128 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_128MB;
            break;
        case 256 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_256MB;
            break;
        default:
            AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
            ASSERT(FALSE);
            return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary.
    //
    ASSERT(NewBase.HighPart == 0);
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);
    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART aperture of %lx pages\n",
               NewBase.QuadPart,
               NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }
    
    //
    // Need to reset the hardware to match the supplied settings
    //
    // If the aperture is enabled, disable it, write the new settings, then reenable the aperture
    //
    Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    PACConfig.GlobalEnable = 0;
    Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));

    //
    // Write APSIZE first, as this will enable the correct bits in APBASE that need to
    // be written next.
    //
    Write440Config(&ApSize, APSIZE_OFFSET, sizeof(ApSize));

    //
    // Now we can update APBASE
    //
    ApBase = NewBase.LowPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    Write440Config(&ApBase, APBASE_OFFSET, sizeof(ApBase));

#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        ULONG DbgBase;
        UCHAR DbgSize;
        ULONG ApBaseMask;

        ApBaseMask = (ApSize << 22) | 0xF0000000;

        Read440Config(&DbgSize, APSIZE_OFFSET, sizeof(ApSize));
        Read440Config(&DbgBase, APBASE_OFFSET, sizeof(ApBase));
        ASSERT(DbgSize == ApSize);
        ASSERT((DbgBase & ApBaseMask) == ApBase);
    }
#endif

    //
    // Now enable the aperture if it was enabled before
    //
    if (AgpContext->GlobalEnable) {
        Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
        ASSERT(PACConfig.GlobalEnable == 0);
        PACConfig.GlobalEnable = 1;
        Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    }

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

    //
    // Enable the TB in case we are resuming from S3 or S4
    //
    Agp440EnableTB(AgpContext);

    //
    // If the GART has been allocated, rewrite the ATTBASE
    //
    if (AgpContext->Gart != NULL) {
        Write440Config(&AgpContext->GartPhysical.LowPart,
                       ATTBASE_OFFSET,
                       sizeof(AgpContext->GartPhysical.LowPart));
    }

    return(STATUS_SUCCESS);
}


VOID
AgpDisableAperture(
    IN PAGP440_EXTENSION AgpContext
    )
/*++

Routine Description:

    Disables the GART aperture so that this resource is available
    for other devices

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None - this routine must always succeed.

--*/

{
    PACCFG PACConfig;

    //
    // Disable the aperture
    //
    Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    if (PACConfig.GlobalEnable == 1) {
        PACConfig.GlobalEnable = 0;
        Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    }
    AgpContext->GlobalEnable = FALSE;

    //
    // Nuke the Gart!  (It's meaningless now...)
    //
    if (AgpContext->Gart != NULL) {
        MmFreeContiguousMemory(AgpContext->Gart);
        AgpContext->Gart = NULL;
        AgpContext->GartLength = 0;
    }
}


NTSTATUS
AgpReserveMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*++

Routine Description:

    Reserves a range of memory in the GART.

Arguments:

    AgpContext - Supplies the AGP Context

    Range - Supplies the AGP_RANGE structure. AGPLIB
        will have filled in NumberOfPages and Type. This
        routine will fill in MemoryBase and Context.

Return Value:

    NTSTATUS

--*/

{
    ULONG Index;
    ULONG NewState;
    NTSTATUS Status;
    PGART_PTE FoundRange;
    BOOLEAN Backwards;

    PAGED_CODE();

    ASSERT((Range->Type == MmNonCached) || (Range->Type == MmWriteCombined));

    if (Range->NumberOfPages > (AgpContext->ApertureLength / PAGE_SIZE)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);
        Status = Agp440CreateGart(AgpContext,Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("Agp440CreateGart failed %08lx to create GART of size %lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries to satisfy
    // the request. Requests for uncached memory will scan from high addresses to
    // low addresses. Requests for write-combined memory will scan from low addresses
    // to high addresses. We will use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
    FoundRange = Agp440FindRangeInGart(&AgpContext->Gart[0],
                                       &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
                                       Range->NumberOfPages,
                                       Backwards,
                                       GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
                Range->NumberOfPages,
                Range->Type,
                AgpContext->Gart));

        //
        //  This is where we could try and grow the GART
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    for (Index = 0;Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.LowPart));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*++

Routine Description:

    Releases memory previously reserved with AgpReserveMemory

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the range to be released.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Pte;
    ULONG Start;

    PAGED_CODE();

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point.
    //
    for (Pte = Range->Context;
         Pte < (PGART_PTE)Range->Context + Range->NumberOfPages;
         Pte++) {
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        }
        Pte->Soft.State = GART_ENTRY_FREE;
    }

    Range->MemoryBase.QuadPart = 0;
    return(STATUS_SUCCESS);
}


NTSTATUS
Agp440CreateGart(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*++

Routine Description:

    Allocates and initializes an empty GART. The current implementation
    attempts to allocate the entire GART on the first reserve.

Arguments:

    AgpContext - Supplies the AGP context

    MinimumPages - Supplies the minimum size (in pages) of the GART to be
        created.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Gart;
    ULONG GartLength;
    PHYSICAL_ADDRESS HighestAcceptable;
    PHYSICAL_ADDRESS LowestAcceptable;
    PHYSICAL_ADDRESS BoundaryMultiple;
    PHYSICAL_ADDRESS GartPhysical;
    ULONG i;

    PAGED_CODE();

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //
    LowestAcceptable.QuadPart = 0;
    BoundaryMultiple.QuadPart = 0;
    HighestAcceptable.QuadPart = 0xFFFFFFFF;
    GartLength = BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE);

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength,
                                                  LowestAcceptable,
                                                  HighestAcceptable,
                                                  BoundaryMultiple,
                                                  MmNonCached);

    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("Agp440CreateGart - MmAllocateContiguousMemorySpecifyCache %lx failed\n",
                GartLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

    //
    // Get the physical address.
    //
    GartPhysical = MmGetPhysicalAddress(Gart);
    AGPLOG(AGP_NOISE,
           ("Agp440CreateGart - GART of length %lx created at VA %08lx, PA %08lx\n",
            GartLength,
            Gart,
            GartPhysical.LowPart));
    ASSERT(GartPhysical.HighPart == 0);
    ASSERT((GartPhysical.LowPart & (PAGE_SIZE-1)) == 0);

    //
    // Initialize all the PTEs to free
    //
    for (i=0; i<GartLength/sizeof(GART_PTE); i++) {
        Gart[i].Soft.State = GART_ENTRY_FREE;
    }


    Write440Config(&GartPhysical.LowPart, ATTBASE_OFFSET, sizeof(GartPhysical.LowPart));

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
    AgpContext->GartPhysical = GartPhysical;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpMapMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Maps physical memory into the GART somewhere in the specified range.

Arguments:

    AgpContext - Supplies the AGP context

    Range - Supplies the AGP range that the memory should be mapped into

    Mdl - Supplies the MDL describing the physical pages to be mapped

    OffsetInPages - Supplies the offset into the reserved range where the 
        mapping should begin.

    MemoryBase - Returns the physical memory in the aperture where the pages
        were mapped.

Return Value:

    NTSTATUS

--*/

{
    ULONG PageCount;
    PGART_PTE Pte;
    PGART_PTE StartPte;
    ULONG Index;
    ULONG TargetState;
    PPFN_NUMBER Page;
    BOOLEAN Backwards;
    GART_PTE NewPte;
    PACCFG PACConfig;

    PAGED_CODE();

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    TargetState = (Range->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : GART_ENTRY_RESERVED_WC;

    Pte = StartPte + OffsetInPages;

    //
    // We have a suitable range, now fill it in with the supplied MDL.
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount <= StartPte + Range->NumberOfPages);
    NewPte.AsUlong = 0;
    NewPte.Soft.State = (Range->Type == MmNonCached) ? GART_ENTRY_VALID_UC :
                                                       GART_ENTRY_VALID_WC;
    Page = (PPFN_NUMBER)(Mdl + 1);

    //
    // Disable the TB as per the 440 spec. This is probably unnecessary
    // as there should be no valid entries in this range, and there should
    // be no invalid entries still in the TB. So flushing the TB seems
    // a little gratuitous but that's what the 440 spec says to do.
    //
    Agp440DisableTB(AgpContext);

    for (Index = 0; Index < PageCount; Index++) {
        ASSERT(Pte[Index].Soft.State == TargetState);

        NewPte.Hard.Page = (ULONG)(*Page++);
        Pte[Index].AsUlong = NewPte.AsUlong;
        ASSERT(Pte[Index].Hard.Valid == 1);
    }

    //
    // We have filled in all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    NewPte.AsUlong = *(volatile ULONG *)&Pte[PageCount-1].AsUlong;

    //
    // Re-enable the TB
    //
    Agp440EnableTB(AgpContext);

    //
    // If we have not yet gotten around to enabling the GART aperture, do it now.
    //
    if (!AgpContext->GlobalEnable) {
        AGPLOG(AGP_NOISE,
               ("AgpMapMemory - Enabling global aperture access\n"));

        Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
        PACConfig.GlobalEnable = 1;
        Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));

        AgpContext->GlobalEnable = TRUE;
    }

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Unmaps previously mapped memory in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range that the memory should be freed from

    NumberOfPages - Supplies the number of pages in the range to be freed.

    OffsetInPages - Supplies the offset into the range where the freeing should begin.

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    PGART_PTE Pte;
    PGART_PTE LastChanged=NULL;
    PGART_PTE StartPte;
    ULONG NewState;

    PAGED_CODE();

    ASSERT(OffsetInPages + NumberOfPages <= AgpRange->NumberOfPages);

    StartPte = AgpRange->Context;
    Pte = &StartPte[OffsetInPages];

    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    //
    // Disable the TB to flush it
    //
    Agp440DisableTB(AgpContext);
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid) {
            Pte[i].Soft.State = NewState;
            LastChanged = &Pte[i];
        } else {
            //
            // This page is not mapped, just skip it.
            //
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[i],
                    Pte[i].AsUlong,
                    i));
            ASSERT(Pte[i].Soft.State == NewState);
        }
    }

    //
    // We have invalidated all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    if (LastChanged != NULL) {
        ULONG Temp;
        Temp = *(volatile ULONG *)(&LastChanged->AsUlong);
    }

    //
    // Reenable the TB
    //
    Agp440EnableTB(AgpContext);

    return(STATUS_SUCCESS);
}


PGART_PTE
Agp440FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;
    PGART_PTE Candidate;

    PAGED_CODE();

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if (Current->Soft.State == SearchState) {
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
Agp440SetGTLB_Enable(
    IN PAGP440_EXTENSION AgpContext,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    Enables or disables the GTLB by setting or clearing the GTLB_Enable bit
    in the AGPCTRL register

Arguments:

    AgpContext - Supplies the AGP context

    Enable - TRUE, GTLB_Enable is set to 1
             FALSE, GTLB_Enable is set to 0

Return Value:

    None

--*/

{
    AGPCTRL AgpCtrl;

    Read440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));

    if (Enable) {
        AgpCtrl.GTLB_Enable = 1;
    } else {
        AgpCtrl.GTLB_Enable = 0;
    }
    Write440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));
}


VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;
    
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid == 0) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                ++i;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
    return;

}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified 
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region 

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONG Pages;
    
    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONG)(Mdl + 1);
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    for (i=0; i<NumberOfPages; i++) {
        ASSERT(Pte[i].Hard.Valid == 1);
        Pages[i] = Pte[i].Hard.Page;
    }
    return;
}


NTSTATUS
AgpSpecialTarget(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context
 
    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = Agp440SetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Add more tweaks here...
    //

    AgpContext->SpecialTarget |= DeviceFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
Agp440SetRate(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies the AGP context
 
    AgpRate - Rate to set

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetPciDeviceCapability(0, 0, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGP440SetRate: AgpLibGetPciDeviceCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGP440SetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP440SetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP440SetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGP440SetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    TargetCap.AGPCommand.Rate = AgpRate;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;
        
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP440SetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGP440SetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agp443\gart.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    gart.c

Abstract:

    Routines for querying and setting the Intel 440xx GART aperture

Author:

    John Vert (jvert) 10/30/1997

Revision History:

--*/
#include "agp440.h"

//
// Local function prototypes
//
NTSTATUS
Agp440CreateGart(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

PGART_PTE
Agp440FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

NTSTATUS
Agp440SetRate(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

VOID
Agp440SetGTLB_Enable(
    IN PAGP440_EXTENSION AgpContext,
    IN BOOLEAN Enable
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpDisableAperture)
#pragma alloc_text(PAGE, AgpQueryAperture)
#pragma alloc_text(PAGE, AgpReserveMemory)
#pragma alloc_text(PAGE, AgpReleaseMemory)
#pragma alloc_text(PAGE, Agp440CreateGart)
#pragma alloc_text(PAGE, AgpMapMemory)
#pragma alloc_text(PAGE, AgpUnMapMemory)
#pragma alloc_text(PAGE, Agp440FindRangeInGart)
#pragma alloc_text(PAGE, AgpFindFreeRun)
#pragma alloc_text(PAGE, AgpGetMappedPages)
#endif

#define Agp440EnableTB(_x_) Agp440SetGTLB_Enable((_x_), TRUE)
#define Agp440DisableTB(_x_) Agp440SetGTLB_Enable((_x_), FALSE)


NTSTATUS
AgpQueryAperture(
    IN PAGP440_EXTENSION AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *pApertureRequirements
    )
/*++

Routine Description:

    Queries the current size of the GART aperture. Optionally returns
    the possible GART settings.

Arguments:

    AgpContext - Supplies the AGP context.

    CurrentBase - Returns the current physical address of the GART.

    CurrentSizeInPages - Returns the current GART size.

    ApertureRequirements - if present, returns the possible GART settings

Return Value:

    NTSTATUS

--*/

{
    ULONG ApBase;
    UCHAR ApSize;
    PIO_RESOURCE_LIST Requirements;
    ULONG i;
    ULONG Length;

    PAGED_CODE();
    //
    // Get the current APBASE and APSIZE settings
    //
    AgpLibReadAgpTargetConfig(AgpContext, &ApBase, APBASE_OFFSET, sizeof(ApBase));
    AgpLibReadAgpTargetConfig(AgpContext, &ApSize, APSIZE_OFFSET, sizeof(ApSize));

    ASSERT(ApBase != 0);
    CurrentBase->QuadPart = ApBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Convert APSIZE into the actual size of the aperture
    //
    switch (ApSize) {
        case AP_SIZE_4MB:
            *CurrentSizeInPages = 4 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_8MB:
            *CurrentSizeInPages = 8 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_16MB:
            *CurrentSizeInPages = 16 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_32MB:
            *CurrentSizeInPages = 32 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_64MB:
            *CurrentSizeInPages = 64 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_128MB:
            *CurrentSizeInPages = 128 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_256MB:
            *CurrentSizeInPages = 256 * (1024*1024 / PAGE_SIZE);
            break;

        default:
            AGPLOG(AGP_CRITICAL,
                   ("AGP440 - AgpQueryAperture - Unexpected value %x for ApSize!\n",
                    ApSize));
            ASSERT(FALSE);
            AgpContext->ApertureStart.QuadPart = 0;
            AgpContext->ApertureLength = 0;
            return(STATUS_UNSUCCESSFUL);
    }

    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    if (pApertureRequirements != NULL) {
        ULONG VendorId;

        //
        // 440 supports 7 different aperture sizes, all must be 
        // naturally aligned. Start with the largest aperture and 
        // work downwards so that we get the biggest possible aperture.
        //
        Requirements = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(IO_RESOURCE_LIST) + (AP_SIZE_COUNT-1)*sizeof(IO_RESOURCE_DESCRIPTOR),
                                             'RpgA');
        if (Requirements == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        Requirements->Version = Requirements->Revision = 1;
        
        //
        // 815 only supports 64MB and 32MB Aperture sizes
        //
        AgpLibReadAgpTargetConfig(AgpContext, &VendorId, 0, sizeof(VendorId));
        if (VendorId == AGP_815_IDENTIFIER) {
            Requirements->Count = AP_815_SIZE_COUNT;
            Length = AP_815_MAX_SIZE;
        
        } else {
            Requirements->Count = AP_SIZE_COUNT;
            Length = AP_MAX_SIZE;
        }

        for (i=0; i<Requirements->Count; i++) {
            Requirements->Descriptors[i].Option = IO_RESOURCE_ALTERNATIVE;
            Requirements->Descriptors[i].Type = CmResourceTypeMemory;
            Requirements->Descriptors[i].ShareDisposition = CmResourceShareDeviceExclusive;
            Requirements->Descriptors[i].Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;

            Requirements->Descriptors[i].u.Memory.Length = Length;
            Requirements->Descriptors[i].u.Memory.Alignment = Length;
            Requirements->Descriptors[i].u.Memory.MinimumAddress.QuadPart = 0;
            Requirements->Descriptors[i].u.Memory.MaximumAddress.QuadPart = (ULONG)-1;

            Length = Length/2;
        }
        *pApertureRequirements = Requirements;


    }
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetAperture(
    IN PAGP440_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*++

Routine Description:

    Sets the GART aperture to the supplied settings

Arguments:

    AgpContext - Supplies the AGP context

    NewBase - Supplies the new physical memory base for the GART.

    NewSizeInPages - Supplies the new size for the GART

Return Value:

    NTSTATUS

--*/

{
    PACCFG PACConfig;
    UCHAR ApSize;
    ULONG ApBase;

    //
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) {
        case 4 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_4MB;
            break;
        case 8 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_8MB;
            break;
        case 16 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_16MB;
            break;
        case 32 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_32MB;
            break;
        case 64 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_64MB;
            break;
        case 128 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_128MB;
            break;
        case 256 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_256MB;
            break;
        default:
            AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
            ASSERT(FALSE);
            return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary.
    //
    ASSERT(NewBase.HighPart == 0);
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);
    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART aperture of %lx pages\n",
               NewBase.QuadPart,
               NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }
    
    //
    // Need to reset the hardware to match the supplied settings
    //
    // If the aperture is enabled, disable it, write the new settings, then reenable the aperture
    //
    AgpLibReadAgpTargetConfig(AgpContext, &PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    PACConfig.GlobalEnable = 0;
    AgpLibWriteAgpTargetConfig(AgpContext, &PACConfig, PACCFG_OFFSET, sizeof(PACConfig));

    //
    // Write APSIZE first, as this will enable the correct bits in APBASE that need to
    // be written next.
    //
    AgpLibWriteAgpTargetConfig(AgpContext, &ApSize, APSIZE_OFFSET, sizeof(ApSize));

    //
    // Now we can update APBASE
    //
    ApBase = NewBase.LowPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    AgpLibWriteAgpTargetConfig(AgpContext, &ApBase, APBASE_OFFSET, sizeof(ApBase));

#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        ULONG DbgBase;
        UCHAR DbgSize;
        ULONG ApBaseMask;

        ApBaseMask = (ApSize << 22) | 0xF0000000;

        AgpLibReadAgpTargetConfig(AgpContext, &DbgSize, APSIZE_OFFSET, sizeof(ApSize));
        AgpLibReadAgpTargetConfig(AgpContext, &DbgBase, APBASE_OFFSET, sizeof(ApBase));
        ASSERT(DbgSize == ApSize);
        ASSERT((DbgBase & ApBaseMask) == ApBase);
    }
#endif

    //
    // Now enable the aperture if it was enabled before
    //
    if (AgpContext->GlobalEnable) {
        AgpLibReadAgpTargetConfig(AgpContext, &PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
        ASSERT(PACConfig.GlobalEnable == 0);
        PACConfig.GlobalEnable = 1;
        AgpLibWriteAgpTargetConfig(AgpContext, &PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    }

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

    //
    // Enable the TB in case we are resuming from S3 or S4
    //
    Agp440EnableTB(AgpContext);

    //
    // If the GART has been allocated, rewrite the ATTBASE
    //
    if (AgpContext->Gart != NULL) {
        AgpLibWriteAgpTargetConfig(AgpContext, &AgpContext->GartPhysical.LowPart,
                       ATTBASE_OFFSET,
                       sizeof(AgpContext->GartPhysical.LowPart));
    }

    return(STATUS_SUCCESS);
}


VOID
AgpDisableAperture(
    IN PAGP440_EXTENSION AgpContext
    )
/*++

Routine Description:

    Disables the GART aperture so that this resource is available
    for other devices

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None - this routine must always succeed.

--*/

{
    PACCFG PACConfig;

    //
    // Disable the aperture
    //
    AgpLibReadAgpTargetConfig(AgpContext, &PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    if (PACConfig.GlobalEnable == 1) {
        PACConfig.GlobalEnable = 0;
        AgpLibWriteAgpTargetConfig(AgpContext, &PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    }
    AgpContext->GlobalEnable = FALSE;

    //
    // Nuke the Gart!  (It's meaningless now...)
    //
    if (AgpContext->Gart != NULL) {
        MmFreeContiguousMemory(AgpContext->Gart);
        AgpContext->Gart = NULL;
        AgpContext->GartLength = 0;
    }
}


NTSTATUS
AgpReserveMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*++

Routine Description:

    Reserves a range of memory in the GART.

Arguments:

    AgpContext - Supplies the AGP Context

    Range - Supplies the AGP_RANGE structure. AGPLIB
        will have filled in NumberOfPages and Type. This
        routine will fill in MemoryBase and Context.

Return Value:

    NTSTATUS

--*/

{
    ULONG Index;
    ULONG NewState;
    NTSTATUS Status;
    PGART_PTE FoundRange;
    BOOLEAN Backwards;

    PAGED_CODE();

    ASSERT((Range->Type == MmNonCached) || (Range->Type == MmWriteCombined));

    if (Range->NumberOfPages > (AgpContext->ApertureLength / PAGE_SIZE)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);
        Status = Agp440CreateGart(AgpContext,Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("Agp440CreateGart failed %08lx to create GART of size %lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries to satisfy
    // the request. Requests for uncached memory will scan from high addresses to
    // low addresses. Requests for write-combined memory will scan from low addresses
    // to high addresses. We will use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
    FoundRange = Agp440FindRangeInGart(&AgpContext->Gart[0],
                                       &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
                                       Range->NumberOfPages,
                                       Backwards,
                                       GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
                Range->NumberOfPages,
                Range->Type,
                AgpContext->Gart));

        //
        //  This is where we could try and grow the GART
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    for (Index = 0;Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.LowPart));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*++

Routine Description:

    Releases memory previously reserved with AgpReserveMemory

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the range to be released.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Pte;
    ULONG Start;

    PAGED_CODE();

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point.
    //
    for (Pte = Range->Context;
         Pte < (PGART_PTE)Range->Context + Range->NumberOfPages;
         Pte++) {
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        }
        Pte->Soft.State = GART_ENTRY_FREE;
    }

    Range->MemoryBase.QuadPart = 0;
    return(STATUS_SUCCESS);
}


NTSTATUS
Agp440CreateGart(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*++

Routine Description:

    Allocates and initializes an empty GART. The current implementation
    attempts to allocate the entire GART on the first reserve.

Arguments:

    AgpContext - Supplies the AGP context

    MinimumPages - Supplies the minimum size (in pages) of the GART to be
        created.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Gart;
    ULONG GartLength;
    PHYSICAL_ADDRESS HighestAcceptable;
    PHYSICAL_ADDRESS LowestAcceptable;
    PHYSICAL_ADDRESS BoundaryMultiple;
    PHYSICAL_ADDRESS GartPhysical;
    ULONG i;

    PAGED_CODE();

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //
    LowestAcceptable.QuadPart = 0;
    BoundaryMultiple.QuadPart = 0;
    HighestAcceptable.QuadPart = 0xFFFFFFFF;
    GartLength = BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE);

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength,
                                                  LowestAcceptable,
                                                  HighestAcceptable,
                                                  BoundaryMultiple,
                                                  MmNonCached);

    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("Agp440CreateGart - MmAllocateContiguousMemorySpecifyCache %lx failed\n",
                GartLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

    //
    // Get the physical address.
    //
    GartPhysical = MmGetPhysicalAddress(Gart);
    AGPLOG(AGP_NOISE,
           ("Agp440CreateGart - GART of length %lx created at VA %08lx, PA %08lx\n",
            GartLength,
            Gart,
            GartPhysical.LowPart));
    ASSERT(GartPhysical.HighPart == 0);
    ASSERT((GartPhysical.LowPart & (PAGE_SIZE-1)) == 0);

    //
    // Initialize all the PTEs to free
    //
    for (i=0; i<GartLength/sizeof(GART_PTE); i++) {
        Gart[i].Soft.State = GART_ENTRY_FREE;
    }


    AgpLibWriteAgpTargetConfig(AgpContext, &GartPhysical.LowPart, ATTBASE_OFFSET, sizeof(GartPhysical.LowPart));

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
    AgpContext->GartPhysical = GartPhysical;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpMapMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Maps physical memory into the GART somewhere in the specified range.

Arguments:

    AgpContext - Supplies the AGP context

    Range - Supplies the AGP range that the memory should be mapped into

    Mdl - Supplies the MDL describing the physical pages to be mapped

    OffsetInPages - Supplies the offset into the reserved range where the 
        mapping should begin.

    MemoryBase - Returns the physical memory in the aperture where the pages
        were mapped.

Return Value:

    NTSTATUS

--*/

{
    ULONG PageCount;
    PGART_PTE Pte;
    PGART_PTE StartPte;
    ULONG Index;
    ULONG TargetState;
    PPFN_NUMBER Page;
    BOOLEAN Backwards;
    GART_PTE NewPte;
    PACCFG PACConfig;

    PAGED_CODE();

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    TargetState = (Range->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : GART_ENTRY_RESERVED_WC;

    Pte = StartPte + OffsetInPages;

    //
    // We have a suitable range, now fill it in with the supplied MDL.
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount <= StartPte + Range->NumberOfPages);
    NewPte.AsUlong = 0;
    NewPte.Soft.State = (Range->Type == MmNonCached) ? GART_ENTRY_VALID_UC :
                                                       GART_ENTRY_VALID_WC;
    Page = (PPFN_NUMBER)(Mdl + 1);

    //
    // Disable the TB as per the 440 spec. This is probably unnecessary
    // as there should be no valid entries in this range, and there should
    // be no invalid entries still in the TB. So flushing the TB seems
    // a little gratuitous but that's what the 440 spec says to do.
    //
    Agp440DisableTB(AgpContext);

    for (Index = 0; Index < PageCount; Index++) {
        ASSERT(Pte[Index].Soft.State == TargetState);

        NewPte.Hard.Page = (ULONG)(*Page++);
        Pte[Index].AsUlong = NewPte.AsUlong;
        ASSERT(Pte[Index].Hard.Valid == 1);
    }

    //
    // We have filled in all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    NewPte.AsUlong = *(volatile ULONG *)&Pte[PageCount-1].AsUlong;

    //
    // Re-enable the TB
    //
    Agp440EnableTB(AgpContext);

    //
    // If we have not yet gotten around to enabling the GART aperture, do it now.
    //
    if (!AgpContext->GlobalEnable) {
        AGPLOG(AGP_NOISE,
               ("AgpMapMemory - Enabling global aperture access\n"));

        AgpLibReadAgpTargetConfig(AgpContext, &PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
        PACConfig.GlobalEnable = 1;
        AgpLibWriteAgpTargetConfig(AgpContext, &PACConfig, PACCFG_OFFSET, sizeof(PACConfig));

        AgpContext->GlobalEnable = TRUE;
    }

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Unmaps previously mapped memory in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range that the memory should be freed from

    NumberOfPages - Supplies the number of pages in the range to be freed.

    OffsetInPages - Supplies the offset into the range where the freeing should begin.

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    PGART_PTE Pte;
    PGART_PTE LastChanged=NULL;
    PGART_PTE StartPte;
    ULONG NewState;

    PAGED_CODE();

    ASSERT(OffsetInPages + NumberOfPages <= AgpRange->NumberOfPages);

    StartPte = AgpRange->Context;
    Pte = &StartPte[OffsetInPages];

    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    //
    // Disable the TB to flush it
    //
    Agp440DisableTB(AgpContext);
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid) {
            Pte[i].Soft.State = NewState;
            LastChanged = &Pte[i];
        } else {
            //
            // This page is not mapped, just skip it.
            //
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[i],
                    Pte[i].AsUlong,
                    i));
            ASSERT(Pte[i].Soft.State == NewState);
        }
    }

    //
    // We have invalidated all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    if (LastChanged != NULL) {
        ULONG Temp;
        Temp = *(volatile ULONG *)(&LastChanged->AsUlong);
    }

    //
    // Reenable the TB
    //
    Agp440EnableTB(AgpContext);

    return(STATUS_SUCCESS);
}


PGART_PTE
Agp440FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;
    PGART_PTE Candidate;

    PAGED_CODE();

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if (Current->Soft.State == SearchState) {
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
Agp440SetGTLB_Enable(
    IN PAGP440_EXTENSION AgpContext,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    Enables or disables the GTLB by setting or clearing the GTLB_Enable bit
    in the AGPCTRL register

Arguments:

    AgpContext - Supplies the AGP context

    Enable - TRUE, GTLB_Enable is set to 1
             FALSE, GTLB_Enable is set to 0

Return Value:

    None

--*/

{
    AGPCTRL AgpCtrl;

    AgpLibReadAgpTargetConfig(AgpContext, &AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));

    if (Enable) {
        AgpCtrl.GTLB_Enable = 1;
    } else {
        AgpCtrl.GTLB_Enable = 0;
    }
    AgpLibWriteAgpTargetConfig(AgpContext, &AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));
}


VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;
    
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid == 0) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                ++i;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
    return;

}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified 
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region 

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONG Pages;
    
    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONG)(Mdl + 1);
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    for (i=0; i<NumberOfPages; i++) {
        ASSERT(Pte[i].Hard.Valid == 1);
        Pages[i] = Pte[i].Hard.Page;
    }
    return;
}


NTSTATUS
AgpSpecialTarget(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context
 
    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = Agp440SetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Add more tweaks here...
    //

    AgpContext->SpecialTarget |= DeviceFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
Agp440SetRate(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies the AGP context
 
    AgpRate - Rate to set

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetTargetCapability(AgpContext, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGP440SetRate: AgpLibGetTargetCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGP440SetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Map AGP3 mode rates (4X/8X) into AGP2 rate bits, checking one should
    // be good enough, so we'll just ASSERT for busted video cards
    //
    if (TargetCap.AGPStatus.Agp3Mode == 1) {
        ASSERT(MasterCap.AGPStatus.Agp3Mode == 1);

        if ((AgpRate != PCI_AGP_RATE_4X) && (AgpRate != 8)) {
            return STATUS_INVALID_PARAMETER;
        }

        AgpRate >>= 2;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetTargetCapability(AgpContext, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP440SetRate: AgpLibSetTargetCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP440SetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGP440SetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    TargetCap.AGPCommand.Rate = AgpRate;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;
        
    Status = AgpLibSetTargetCapability(AgpContext, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP440SetRate: AgpLibSetTargetCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGP440SetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agp460\init.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code for AGP460.SYS.

Author:

    Naga Gurumoorthy  6/11/1999

Revision History:

--*/

#include "agp460.h"

ULONG AgpExtensionSize = sizeof(AGP460_EXTENSION);
PAGP_FLUSH_PAGES AgpFlushPages;  


NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*++

Routine Description:

    Entrypoint for target initialization. This is called first.

Arguments:

    AgpExtension - Supplies the AGP extension

Return Value:

    NTSTATUS

--*/

{
    ULONG               DeviceVendorID  = 0;
    PAGP460_EXTENSION	Extension		= AgpExtension;

	AGPLOG(AGP_NOISE, ("AGP460: AgpInitializeTarget entered.\n"));

	//
    // Initialize our Extension
    //
    RtlZeroMemory(Extension, sizeof(AGP460_EXTENSION));


	//
	// TO DO:  Check the Device & Vendor ID for 82460GX. - Naga G
	//

    //
    // Initialize our chipset-specific extension
    //
    Extension->ApertureStart.QuadPart	  = 0;
    Extension->ApertureLength			  = 0;
    Extension->Gart						  = NULL;
    Extension->GartLength				  = 0;
    Extension->GlobalEnable				  = FALSE;
	Extension->ChipsetPageSize            = PAGESIZE_460GX_CHIPSET;
    Extension->GartPhysical.QuadPart	  = 0;
	Extension->bSupportMultipleAGPDevices = FALSE;
	Extension->bSupportsCacheCoherency    = TRUE;
        Extension->SpecialTarget = 0;

	AgpFlushPages = Agp460FlushPages;
	
	AGPLOG(AGP_NOISE, ("AGP460: Leaving AgpInitializeTarget.\n"));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

    This is also called when the master transitions into the D0 state.

Arguments:

    AgpExtension - Supplies the AGP extension

    AgpCapabilities - Returns the capabilities of this AGP device.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    PAGP460_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable;
    ULONG DataRate;
    ULONG FastWrite;
    ULONG CBN;
    BOOLEAN ReverseInit;

#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

	AGPLOG(AGP_NOISE, ("AGP460: AgpInitializeMaster entered.\n"));

    //
    // VERY IMPORTANT:  In 82460GX, the GART is not part of the main memory (though it
	// occupies a range in the address space) and is instead hanging off the GXB. This 
	// will make accesses from the Graphics Card to the GART pretty fast. But, the price
	// we pay - processor can't access the GART.  Therefore, we tell the rest of the
	// world that is NOT OK to map the physical addresses given by GART. Instead processor
	// accesses should use the MDL. This is done by setting the capabilities to 0.
	// - Naga G
    //
    *AgpCapabilities = 0;

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP460InitializeDevice - AgpLibGetMasterCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AGP460InitializeDevice - AgpLibGetMasterCapability returned no valid transfer rate\n"));
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

	// We can't get the capability for bus 0, dev 0 in 460GX. it is the SAC & we want the
	// GXB (Target).
    //Status = AgpLibGetPciDeviceCapability(0,0,&TargetCap);

	Read460CBN((PVOID)&CBN);
    // CBN is of one byte width, so zero out the other bits from 32-bits - Sunil
    EXTRACT_LSBYTE(CBN); 

	Status = AgpLibGetPciDeviceCapability(CBN,AGP460_GXB_SLOT_ID,&TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP460InitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;

    AGP_ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);
    }

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing & MasterCap.AGPStatus.SideBandAddressing);

    //
    // Enable FastWrite if both master and target support it.
    //
    FastWrite = (TargetCap.AGPStatus.FastWrite & MasterCap.AGPStatus.FastWrite);

    //
    // Enable the Master first.
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate              = DataRate;
        MasterCap.AGPCommand.AGPEnable         = TRUE;
        MasterCap.AGPCommand.SBAEnable         = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable   = FastWrite;
        MasterCap.AGPCommand.FourGBEnable      = FALSE;  
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGP460InitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    //
    // Now enable the Target.
    //
    TargetCap.AGPCommand.Rate            = DataRate;
    TargetCap.AGPCommand.AGPEnable       = TRUE;
    TargetCap.AGPCommand.SBAEnable       = SBAEnable;
    TargetCap.AGPCommand.FastWriteEnable = FastWrite;
    TargetCap.AGPCommand.FourGBEnable    = FALSE;  

    Status = AgpLibSetPciDeviceCapability(CBN, AGP460_GXB_SLOT_ID, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP460InitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate              = DataRate;
        MasterCap.AGPCommand.AGPEnable         = TRUE;
        MasterCap.AGPCommand.SBAEnable         = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable   = FastWrite;
        MasterCap.AGPCommand.FourGBEnable      = FALSE;  
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGP460InitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

#if DBG
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    AGP_ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    AGP_ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

//    Status = AgpLibGetPciDeviceCapability(0,0,&CurrentCap);
	Status = AgpLibGetPciDeviceCapability(CBN,AGP460_GXB_SLOT_ID,&CurrentCap);	

    AGP_ASSERT(NT_SUCCESS(Status));
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AgpInitializeMaster.\n"));

    return(Status);
}


NTSTATUS
Agp460FlushPages(
    IN PAGP460_EXTENSION AgpContext,
    IN PMDL Mdl
    )

/*++

Routine Description:

    Flush entries in the GART. Currently a stub for 
	Win64 version of 460GX filter driver. This flushing  is done previously to 
	avoid any caching issues due to the same memory aliased with different caching
	attributes. Now that is taken care by the memory manager calls themselves (Win64 only).
	Therefore we just have a stub so that nothing gets executed in the AGPLIB code. (see
	AGPLIB code for details)

Arguments:

    AgpContext - Supplies the AGP context

    Mdl - Supplies the MDL describing the physical pages to be flushed

Return Value:

    STATUS_SUCCESS

--*/

{
    	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPFlushPages.\n"));
		AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPFlushPages.\n"));

                return STATUS_SUCCESS;   
}

void Read460CBN(PVOID _CBN_)					                
{                                                           
    ULONG _len_;                                            
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         
                                  AGP460_SAC_BUS_ID,			
                                  AGP460_SAC_CBN_SLOT_ID,	
                                  _CBN_,                  
                                  0x40,		                
                                  1);		                
    AGP_ASSERT(_len_ ==	1);	
	return;
}


void Read460Config(ULONG _CBN_,PVOID  _buf_,ULONG _offset_,ULONG _size_)          
{                                                           
    ULONG _len_;                                            
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         
                                  _CBN_,			        
                                  AGP460_GXB_SLOT_ID,		
                                  _buf_,                  
                                  _offset_,               
                                  _size_);                
    ASSERT(_len_ == (_size_));                             

	return;
}


void Write460Config(ULONG _CBN_,PVOID _buf_,ULONG _offset_,ULONG _size_)         
{                                                           
    ULONG _len_;                                            
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         
                                  (_CBN_),					
                                  AGP460_GXB_SLOT_ID,		
                                  (_buf_),                  
                                  (_offset_),               
                                  (_size_));                
    ASSERT(_len_ == (_size_));                              
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agp443\init.c ===
/*++

Copyright (c) 1996, 1997 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code for AGP440.SYS.

Author:

    John Vert (jvert) 10/21/1997

Revision History:

--*/

#include "agp440.h"

ULONG AgpExtensionSize = sizeof(AGP440_EXTENSION);
PAGP_FLUSH_PAGES AgpFlushPages = NULL;  // not implemented


NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*++

Routine Description:

    Entrypoint for target initialization. This is called first.

Arguments:

    AgpExtension - Supplies the AGP extension

Return Value:

    NTSTATUS

--*/

{
    PAGP440_EXTENSION Extension = AgpExtension;

    //
    // Initialize our chipset-specific extension
    //
    Extension->ApertureStart.QuadPart = 0;
    Extension->ApertureLength = 0;
    Extension->Gart = NULL;
    Extension->GartLength = 0;
    Extension->GlobalEnable = FALSE;
    Extension->PCIEnable = FALSE;
    Extension->GartPhysical.QuadPart = 0;
    Extension->SpecialTarget = 0;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

    This is also called when the master transitions into the D0 state.

Arguments:

    AgpExtension - Supplies the AGP extension

    AgpCapabilities - Returns the capabilities of this AGP device.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    PAGP440_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable;
    ULONG DataRate;
    ULONG FastWrite;
    BOOLEAN ReverseInit;
    ULONG VendorId = 0;
    ULONG AgpCtrl = 0;
    
#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

    //
    // Intel says if all BIOS manufacturers perform RMW ops on this
    // register, then it will always be set, however two video OEMs
    // have complained of systems where this was not set, and was
    // causing the system to freeze, so we'll hard code it just in
    // case (only affects 440LX)
    //
    AgpLibReadAgpTargetConfig(AgpExtension, &VendorId, 0, sizeof(VendorId));
    if ((VendorId == AGP_440LX_IDENTIFIER) ||
        (VendorId == AGP_440LX2_IDENTIFIER)) {
        AgpLibReadAgpTargetConfig(AgpExtension, &AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));
        AgpCtrl |= READ_SYNC_ENABLE;
        AgpLibWriteAgpTargetConfig(AgpExtension, &AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl)); 
    }

    //
    // Indicate that we can map memory through the GART aperture
    //
    *AgpCapabilities = AGP_CAPABILITIES_MAP_PHYSICAL;

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability returned no valid transfer rate\n"));
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = AgpLibGetTargetCapability(AgpExtension, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetTargetCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;

    AGP_ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);

        //
        // If we're in AGP3 mode, and our rate was successfully
        // programmed, then we must convert into AGP2 rate bits
        //
        if (TargetCap.AGPStatus.Agp3Mode == 1) {
            ASSERT(MasterCap.AGPStatus.Agp3Mode == 1);
            ASSERT((DataRate == 8) || (DataRate == PCI_AGP_RATE_4X));
            DataRate >>= 2;
        }
    }

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing & MasterCap.AGPStatus.SideBandAddressing);

    //
    // Enable FastWrite if both master and target support it.
    //
    FastWrite = (TargetCap.AGPStatus.FastWrite & MasterCap.AGPStatus.FastWrite);

    //
    // Enable the Master first.
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.FourGBEnable = 0;  
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGP440InitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    //
    // Now enable the Target.
    //
    TargetCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    TargetCap.AGPCommand.FastWriteEnable = FastWrite;
    TargetCap.AGPCommand.FourGBEnable = 0;  
    Status = AgpLibSetTargetCapability(AgpExtension, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibSetTargetCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.FourGBEnable = 0;  
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGP440InitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

#if DBG
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    AGP_ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    AGP_ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

    Status = AgpLibGetTargetCapability(AgpExtension, &CurrentCap);
    AGP_ASSERT(NT_SUCCESS(Status));
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agp460\agp460.h ===
#include "agp.h"

#define PCI_ADDRESS_MEMORY_ADDRESS_MASK_64 0xFFFFFFFFFFFFFFF0UI64

//
// Define the location of the GART aperture control registers
//

//
// The GART registers on the 440 live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//

//
// TBD: The GART registers on the 460 live in the GXB.  Though we are trying to use
// the code from 440 as much as possible. The HalGet calls may not be needed if
// all the GART registers live on the PCI-PCI bridge (GXB).  DOUBLE CHECK THIS 
// WITH THE EDS, VERIFY IT WITH JOHN VERT - NAGA G
//

// Compared to 440 there exists no equivalents for PAC configuration, 
// AGP Control & ATTBASE registers in 460GX. 

#define EXTRACT_LSBYTE(x)       x = (x & 0xFF)  // Sunil

#define ONE_KB                  1024
#define ONE_MB                  (ONE_KB * ONE_KB)
#define AP_256MB                (256 * ONE_MB)
#define AP_1GB                  (ONE_MB * ONE_KB)
#define AP_32GB                 (32 * AP_1GB)

#define ABOVE_TOM(x)             ( (x) & (0x08) )

#define AGP_460GX_IDENTIFIER	0x84E28086	// Device ID & Vendor ID 
											// for the 460GX SAC


 
#define APBASE_OFFSET  0x10		// Aperture Base Address:APBASE & BAPBASE are used to
#define BAPBASE_OFFSET 0x98		// store the base address of the Graphics Aperture(GA).
								// Only one of APBASE or BAPBASE is visible at a time.
								// APBASE is visible when AGPSIZ[3]=0 && AGPSIZ[2:0]!=0. 
								// BAPBASE is visible when AGPSIZ[3]=1 & AGPSIZ[2:0]!=0.
								// BAPBASE is used when the GA is mapped above 4GB and
								// APBASE when the GA is mapped below 4GB


#define APSIZE_OFFSET  0xA2     // Aperture Size Register - AGPSIZ    


      
#define ATTBASE 0xFE200000		// Aperture Translation Table Base - It is a 
								// 2MB region hard coded in 460GX to 0xFE200000h


#define AGPSTATUS_OFFSET  0xE4	// AGP Status Register - The CAP_PTR is
								// at 0xE0h in 460GX and the AGP Status
								// register is at CAP_PTR+4.


#define AGPCMD_OFFSET	  0xE8	// AGP Command Register - CAP_PTR + 8



//
// 82460GX specific definitions to get to the PCI configuration space of the
// SAC, GXB et al.
//
#define AGP460_SAC_BUS_ID		0	 // The bus number where the SAC resides in 82460GX

//
// The following two definitions should be interpreted as of type PCI_SLOT_NUMBER
// which combines the device & function number for a particular PCI device.  It is 
// a ULONG value which should be deciphered as follows:
// [xxxxxxxx xxxxxxxx xxxxxxxx YYYZZZZZ]
// where x = Reserved, Y = Function Number, Z = Device Number
//

#define AGP460_SAC_CBN_SLOT_ID 0x10 // The Chipset Bus Number resides at Bus 0,
							     // Device 10h & Function 0.

#define AGP460_GXB_SLOT_ID		0x34 // The GXB would be accessed at Bus CBN, Device 14h
								 // function BFN.  BFN is 1 by default.

#define AGP460_PAGE_SIZE_4KB	(4 * ONE_KB)
//
// Handy macros to read & write in the PCI Configuration space
//

//
// Read460CBN reads the CBN - Chipset Bus Number from the 82460GX SAC.
// CBN is a BYTE located at Bus 0, Device 10h, Function 0, Offset 40
// in the SAC Configuration space.  The CBN can be read once and reused
// subsequently.
// 

void Read460CBN(PVOID  CBN);


void Read460Config(ULONG  _CBN_,PVOID  _buf_,ULONG _offset_,ULONG _size_);

void Write460Config(ULONG _CBN_,PVOID  _buf_,ULONG _offset_,ULONG _size_);

//
// Conversions from AGPSIZ[2:0] encoding to Aperture Size in MB/GB
//
//  AGPSIZE[2:0]   Aperture Size
//          000         0MB (power on default; no GART SRAM present)
//			001       256MB 
//			010         1GB
//          100        32GB  (only with 4MB pages)
//
#define AP_SIZE_0MB     0x00
#define AP_SIZE_256MB   0x01
#define AP_SIZE_1GB     0x02
#define AP_SIZE_32GB    0x04


#define AP_SIZE_COUNT_4KB	2 //Only apertures of 256M & 1G are possible with 4KB pages
#define AP_SIZE_COUNT_4MB   3 //Apertures of 256M, 1G & 32G are possible with 4MB pages

#define AP_MIN_SIZE		    AP_256MB	// 0 is not counted as a possible 
									    // aperture size
#define AP_MAX_SIZE_4KB	    AP_1GB      // 1 GB is the maximum with 4KB pages
#define AP_MAX_SIZE_4MB     AP_1GB      // 32GB is the maximum with 4MB pages

#define PAGESIZE_460GX_CHIPSET  (4 * ONE_KB)

#define GART_PAGESHIFT_460GX	12


//
// Define the 82460GX GART table entry.  4KB pages are assumed.  To support 4MB pages new 
// structures have to be defined.
//
typedef struct _GART_ENTRY_HW {
    ULONG Page	     :  24;
	ULONG Valid		 :   1;
	ULONG Coherency  :   1;
	ULONG Parity     :   1;  // Parity bit is generated by Hardware. Software should
							 // mask it out and treat it as a reserved.
    ULONG Reserved   :   5;
} GART_ENTRY_HW, *PGART_ENTRY_HW;


//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1		    //  Bit 24 is the valid bit in 460GX GART
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100
#define GART_ENTRY_WB           6           //  110

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC
#define GART_ENTRY_RESERVED_WB  GART_ENTRY_WB



//
// Unlike 440, 82460GX GART driver doesn't have direct equivalent for GART PTE software
// states like GART_ENTRY_VALID_WC, GART_ENTRY_VALID_UC etc.  This is because of
// the organization of the GART PTEs - the valid bit is disjoint from any reserved bits
// and therefore have to be manipulated separately. - Naga G
//

typedef struct _GART_ENTRY_SW {
    ULONG Reserved0 : 24;
	ULONG Valid     :  1;
    ULONG Reserved1 :  2;
	ULONG State     :  3;
	ULONG Reserved2 :  2;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the 460-specific extension
//
typedef struct _AGP460_EXTENSION {
    BOOLEAN             GlobalEnable;				// Software only bit.  The GART will be 
													// initialized to a known invalid state (0s)
													// during initialization. Other than that
													// no hardware control is available in 460GX
													// to enable/disable GART accesses. Thus, this
													// is not of much use !
    PHYSICAL_ADDRESS    ApertureStart; 
    ULONG               ApertureLength;				// Aperture Length in Bytes
	ULONG               ChipsetPageSize;			// Can be 4KB or 4MB.
    PGART_PTE           Gart;
    ULONG               GartLength;					 // Maximum is 2MB
    PHYSICAL_ADDRESS    GartPhysical;				 // Physical address where GART starts
	BOOLEAN             bSupportMultipleAGPDevices;  // For future use.
	BOOLEAN             bSupportsCacheCoherency;     // For future use. 
    ULONGLONG SpecialTarget;
} AGP460_EXTENSION, *PAGP460_EXTENSION;

NTSTATUS Agp460FlushPages(
    IN PAGP460_EXTENSION AgpContext,
    IN PMDL Mdl
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agp460\gart.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    gart.c

Abstract:

    Routines for querying and setting the Intel 460xx GART aperture

Author:

    Sunil A Kulkarni -  3/08/2000

  Initial Version:
    Naga Gurumoorthy -  6/11/1999

Revision History:

--*/
#include "agp460.h"

//
// Local function prototypes
//
NTSTATUS
Agp460CreateGart(
    IN PAGP460_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

NTSTATUS
Agp460SetRate(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

PGART_PTE
Agp460FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

VOID
Agp460SetGTLB_Enable(
    IN PAGP460_EXTENSION AgpContext,
    IN BOOLEAN Enable
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpQueryAperture)
#pragma alloc_text(PAGE, AgpReserveMemory)
#pragma alloc_text(PAGE, AgpReleaseMemory)
#pragma alloc_text(PAGE, Agp460CreateGart)
#pragma alloc_text(PAGE, AgpMapMemory)
#pragma alloc_text(PAGE, AgpUnMapMemory)
#pragma alloc_text(PAGE, Agp460FindRangeInGart)
#pragma alloc_text(PAGE, AgpFindFreeRun)
#pragma alloc_text(PAGE, AgpGetMappedPages)
#endif


NTSTATUS
AgpQueryAperture(
    IN  PAGP460_EXTENSION	    AgpContext,
    OUT PHYSICAL_ADDRESS	    *CurrentBase,
    OUT ULONG			    *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST  *pApertureRequirements
    )
/*++

Routine Description:

    Queries the current size of the GART aperture. Optionally returns
    the possible GART settings.

Arguments:

    AgpContext - Supplies the AGP context.

    CurrentBase - Returns the current physical address of the GART.

    CurrentSizeInPages - Returns the current GART size.

    ApertureRequirements - if present, returns the possible GART settings

Return Value:

    NTSTATUS

--*/

{
    ULONGLONG ApBase;  //Aperture Base registers (APBASE & BAPBASE) are 64bit wide
    UCHAR     ApSize;  //AGPSIZ register is 8bits
    PIO_RESOURCE_LIST Requirements;
    ULONG i;
    ULONG Index;
    ULONG Length;
    ULONG CBN;
    ULONG uiAp_Size_Count;
    
    PAGED_CODE();

    
    AGPLOG(AGP_NOISE, ("AGP460: AgpQueryAperture entered.\n"));
    
    //
    // Get the current APBASE and APSIZE settings
    //
    Read460CBN((PVOID)&CBN);
    EXTRACT_LSBYTE(CBN); // Zero out bits (32-8) as CBN is 8-bit wide - Sunil
    
    // Read the Aperture Size (AGPSIZ) first.  
    Read460Config(CBN,(PVOID) &ApSize, APSIZE_OFFSET, sizeof(ApSize));
    EXTRACT_LSBYTE(ApSize);   // Zero out bits (32-8) as ApSize is 8-bit wide - Sunil
    
    // If AGPSIZ[3] is 1, then Aperture Base is stored in BAPBASE.
    // else (when AGPSIZE[3] = 0, APBASE has the Aperture base address.
    if (ABOVE_TOM(ApSize)){
        Read460Config(CBN, (PVOID)&ApBase, BAPBASE_OFFSET, sizeof(ApBase));
    }else{
        Read460Config(CBN, (PVOID)&ApBase, APBASE_OFFSET, sizeof(ApBase));
    }
    
    ASSERT(ApBase != 0);
    CurrentBase->QuadPart = ApBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK_64;
    
    //
    // Convert APSIZE into the actual size of the aperture.
    // TO DO: Should we return the Current Size in OS page size or chipset page
    // size ? - Naga G
    //
    *CurrentSizeInPages = 0;
    
    if (ApSize & AP_SIZE_256MB) {
        *CurrentSizeInPages = (AP_256MB / PAGE_SIZE);

    } else {
        if (ApSize & AP_SIZE_1GB) {
            *CurrentSizeInPages = (AP_1GB / PAGE_SIZE);
        }
        
        // BUGBUG !32GB Aperture size is possible only with 4MB page size.
        // Currently this is not handled. Once this case is included, the
        // size of CurrentSizeInPages must be changed to ULONGLONG and there 
        // should be corresponding changes in the structures where this value 
        // will be stored - Sunil 3/16/00
        //else{
        //	if (ApSize & AP_SIZE_32GB)
        //		*CurrentSizeInPages = (AP_32GB / PAGE_SIZE);
        //}
    }                  
    
    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength         = *CurrentSizeInPages * PAGE_SIZE;
    
    if (pApertureRequirements != NULL) {
        
        //
        // 460 supports only the boot config, or "preferred" descriptor
        //
        *pApertureRequirements = NULL;
    }
	
    AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPQueryAperture.\n"));

    return STATUS_SUCCESS;
}


NTSTATUS
AgpSetAperture(
    IN PAGP460_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*++

Routine Description:

    Sets the GART aperture to the supplied settings

Arguments:

    AgpContext - Supplies the AGP context

    NewBase - Supplies the new physical memory base for the GART.

    NewSizeInPages - Supplies the new size for the GART

Return Value:

    NTSTATUS

--*/

{
    UCHAR ApSize;
    ULONGLONG ApBase;
	ULONG CBN;
	UCHAR ulTemp;

	AGPLOG(AGP_NOISE, ("AGP460: AgpSetAperture entered.\n"));

    //
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) 
	{
        case AP_256MB / PAGE_SIZE:
				ApSize = AP_SIZE_256MB;
				break;
        case AP_1GB / PAGE_SIZE:
				ApSize = AP_SIZE_1GB;
				break;
        // TO DO: 4MB pages are not supported at this time. In the future,
		// we might have to support it. - Naga G
        default:
				AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
				ASSERT(FALSE);
				return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary.
    //
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);

    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART aperture of %lx pages\n",
               NewBase.QuadPart,
               NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }

    //
    // Having validated the arguments now we need to reset the hardware 
	// to match the supplied settings.
    //
    // Unlike 440, 460GX has no hardware support to disable the use of GART table when
	// we are writing the new settings. 
    //
     
	//
	// Read the CBN first
	//
	Read460CBN((PVOID)&CBN);
	EXTRACT_LSBYTE(CBN); // Sunil

    //
    // Write APSIZE first, as this will enable the correct bits in APBASE that need to
    // be written next.
    //

	Read460Config(CBN, &ulTemp, APSIZE_OFFSET, sizeof(ulTemp));
	
	ulTemp &= 0xff;
	
	ulTemp &= 0xF8;     // To mask everything but the last 3 bits which contain 
						// the aperture size.

	ulTemp |= ApSize;   // Now, incorporate the new aperture size into the AGPSIZ 
						// keeping the first 5 bits as the same.
    Write460Config(CBN, &ulTemp, APSIZE_OFFSET, sizeof(ulTemp));

	
    //
    // Now we can update APBASE
    //
	ApBase = NewBase.QuadPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK_64;

	if (ABOVE_TOM(ulTemp)){
       Write460Config(CBN, &ApBase, BAPBASE_OFFSET, sizeof(ApBase));
	}else{
       Write460Config(CBN, &ApBase, APBASE_OFFSET, sizeof(ApBase));
	}


#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        ULONGLONG DbgBase;
        UCHAR DbgSize;

        Read460Config(CBN,&DbgSize, APSIZE_OFFSET, sizeof(ApSize));
		
		if (ABOVE_TOM(DbgSize)){
			Read460Config(CBN, &DbgBase, BAPBASE_OFFSET, sizeof(ApBase));
		}else{
			Read460Config(CBN, &DbgBase, APBASE_OFFSET, sizeof(ApBase));
		}

		AGPLOG(AGP_NOISE, ("APBase %08lx, DbgBase %08lx\n",ApBase,DbgBase));

		DbgSize &= 0x7; //Check only against size bits - Sunil
        ASSERT(DbgSize == ApSize);
        ASSERT((DbgBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK_64) == ApBase);
    }
#endif

    
    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart  = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AgpSetAperture.\n"));    

    return(STATUS_SUCCESS);
}


VOID
AgpDisableAperture(
    IN PAGP460_EXTENSION AgpContext
    )
/*++

Routine Description:

    Disables the GART aperture so that this resource is available
    for other devices

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None - this routine must always succeed.

--*/

{

	AGPLOG(AGP_NOISE, ("AGP460: Entering AgpDisableAperture.\n"));    

    //
	// In 82460GX there exists no hardware means to enable/disable the Graphics
	// Aperture & GART Translation.  
	//    
    AgpContext->GlobalEnable = FALSE;

	//
	// TO DO: The only thing that could possibly be done is to set AGPSIZ[2:0] to 000
	// which would indicate that there exists no GART. Need to try it out. - Naga G
	//

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AgpDisableAperture.\n"));    

}


NTSTATUS
AgpReserveMemory(
    IN PAGP460_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*++

Routine Description:

    Reserves a range of memory in the GART.

Arguments:

    AgpContext - Supplies the AGP Context

    Range - Supplies the AGP_RANGE structure. AGPLIB
        will have filled in NumberOfPages and Type. This
        routine will fill in MemoryBase and Context.

Return Value:

    NTSTATUS

--*/

{
    ULONG Index;
    ULONG NewState;
    NTSTATUS Status;
    PGART_PTE FoundRange;
    BOOLEAN Backwards;
	ULONG OS_ChipsetPagesizeRatio;

    PAGED_CODE();

	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPReserveMemory.\n"));    

    ASSERT((Range->Type == MmNonCached) ||
           (Range->Type == MmWriteCombined) ||
           (Range->Type == MmCached));
    ASSERT(Range->NumberOfPages <= (AgpContext->ApertureLength / PAGE_SIZE));

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {

        ASSERT(AgpContext->GartLength == 0);
        Status = Agp460CreateGart(AgpContext,Range->NumberOfPages);

        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("Agp460CreateGart failed %08lx to create GART of size %lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

	// if OS page size is 8KB then, OS_ChipsetPagesizeRatio would be 2. To map x OS pages
    // into the GART, we need x * OS_ChipsetPagesizeRatio of GART entries.
	OS_ChipsetPagesizeRatio = PAGE_SIZE / PAGESIZE_460GX_CHIPSET;

    //
    // Now that we have a GART, try and find enough contiguous entries to satisfy
    // the request. Requests for uncached memory will scan from high addresses to
    // low addresses. Requests for write-combined memory will scan from low addresses
    // to high addresses. We will use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
    FoundRange = Agp460FindRangeInGart(&AgpContext->Gart[0],
                                       &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
                                       Range->NumberOfPages * OS_ChipsetPagesizeRatio,
                                       Backwards,
                                       GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
                Range->NumberOfPages * OS_ChipsetPagesizeRatio,
                Range->Type,
                AgpContext->Gart));

        //
        // BUGBUG John Vert (jvert) 11/4/1997
        //  This is the point where we should try and grow the GART
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %p\n",
            Range->NumberOfPages * OS_ChipsetPagesizeRatio,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else if (Range->Type == MmWriteCombined) {
        NewState = GART_ENTRY_RESERVED_WC;
    } else {
        NewState = GART_ENTRY_RESERVED_WB;
    }

    for (Index = 0;Index < (Range->NumberOfPages * OS_ChipsetPagesizeRatio); Index++) 
	{
        ASSERT( (FoundRange[Index].Soft.Valid == 0) && 
			    (FoundRange[Index].Soft.State == GART_ENTRY_FREE));
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + (FoundRange - &AgpContext->Gart[0]) * AGP460_PAGE_SIZE_4KB;
    Range->Context = FoundRange;

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.QuadPart));

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPReserveMemory.\n"));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGP460_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*++

Routine Description:

    Releases memory previously reserved with AgpReserveMemory

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the range to be released.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Pte;
    ULONG Start;
	ULONG OS_ChipsetPagesizeRatio;

    PAGED_CODE();

	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPReleaseMemory.\n"));

	// if OS page size is 8KB then, OS_ChipsetPagesizeRatio would be 2. To map x OS pages
    // into the GART, we need x * OS_ChipsetPagesizeRatio of GART entries.
	OS_ChipsetPagesizeRatio = PAGE_SIZE / PAGESIZE_460GX_CHIPSET;

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point.
    //
    for (Pte = Range->Context;
         Pte < ((PGART_PTE)Range->Context + Range->NumberOfPages * OS_ChipsetPagesizeRatio);
         Pte++) {
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else if (Range->Type == MmWriteCombined) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WB);
        }

        Pte->Soft.State = GART_ENTRY_FREE;
		Pte->Soft.Valid = GART_ENTRY_FREE;
    }

    Range->MemoryBase.QuadPart = 0;

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPReleaseMemory.\n"));

    return(STATUS_SUCCESS);
}


NTSTATUS
Agp460CreateGart(
    IN PAGP460_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*++

Routine Description:

    Allocates and initializes an empty GART. The 82460GX has a 2MB region for 
	GART.  This memory starts at 0xFE20 0000h.  In reality, this memory is a 
	SRAM that hangs off the GXB.  The minimum pages argument is ignored.

Arguments:

    AgpContext - Supplies the AGP context

    MinimumPages - Supplies the minimum size (in pages) of the GART to be
        created.

Return Value:

    NTSTATUS

--*/

{
   
    PGART_PTE Gart;
    ULONG GartLength;
    PHYSICAL_ADDRESS HighestAcceptable;
    ULONG i;
	PHYSICAL_ADDRESS GartStartingLocation;

    PAGED_CODE();

	AGPLOG(AGP_NOISE, ("AGP460: Entering AGP460CreateGART.\n"));
      
    // Set the GArtLength to actual SRAM size on the GXB and not fixed size - Sunil
	//GartLength =  1 * 1024 * 1024; 
	GartLength = AgpContext->ApertureLength / ONE_KB;
	GartStartingLocation.QuadPart = ATTBASE;
    
    Gart = MmMapIoSpace(GartStartingLocation,GartLength,MmNonCached);

    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("Agp460CreateGart - couldn't map GART \n"));
    } else {

        AGPLOG(AGP_NOISE,
               ("Agp460CreateGart - GART of length %lx created at "
                "VA %p, "
                "PA %I64x\n",
                GartLength,
                Gart,
                GartStartingLocation.QuadPart));
    }

    //
    // Initialize all the PTEs to free
    //
    for (i=0; i<GartLength/sizeof(GART_PTE); i++) {
        Gart[i].Soft.State = GART_ENTRY_FREE;
		Gart[i].Soft.Valid = GART_ENTRY_FREE;
    }


    //
    // Update our extension to reflect the current state.
    //

    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGP460CreateGART.\n"));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpMapMemory(
    IN PAGP460_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Maps physical memory into the GART somewhere in the specified range.

Arguments:

    AgpContext - Supplies the AGP context

    Range - Supplies the AGP range that the memory should be mapped into

    Mdl - Supplies the MDL describing the physical pages to be mapped

    OffsetInPages - Supplies the offset into the reserved range where the 
        mapping should begin.

    MemoryBase - Returns the physical memory in the aperture where the pages
        were mapped.

Return Value:

    NTSTATUS

--*/

{
    ULONG PageCount;
    PGART_PTE Pte;
    PGART_PTE StartPte;
    ULONG Index;
    ULONG TargetState;
    PULONGLONG Page;
    BOOLEAN Backwards;
    GART_PTE NewPte;
	ULONG OS_ChipsetPagesizeRatio;
	ULONG RunningCounter;

    PAGED_CODE();

	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPMapMemory.\n"));

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    if (Range->Type == MmNonCached)
        TargetState = GART_ENTRY_RESERVED_UC;
    else if (Range->Type == MmWriteCombined)
        TargetState = GART_ENTRY_RESERVED_WC;
    else
        TargetState = GART_ENTRY_RESERVED_WB;

	OS_ChipsetPagesizeRatio = PAGE_SIZE / PAGESIZE_460GX_CHIPSET;

    Pte = StartPte + (OffsetInPages * OS_ChipsetPagesizeRatio);

    //
    // We have a suitable range, now fill it in with the supplied MDL.
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount * OS_ChipsetPagesizeRatio <= StartPte + Range->NumberOfPages * OS_ChipsetPagesizeRatio);
    NewPte.AsUlong = 0;
    NewPte.Soft.Valid = TRUE;
    if (Range->Type == MmCached) {
        NewPte.Hard.Coherency = TRUE;
    }

    Page = (PULONGLONG)(Mdl + 1);

    RunningCounter = 0;
    //AGPLOG(AGP_NOISE, ("AGP460: Entering AGPMapMemory -- LOOP: Pte: %0x, newPte: %0x.\n",Pte,NewPte));

    for (Index = 0; Index < (PageCount * OS_ChipsetPagesizeRatio); Index++) 
	{
        ASSERT(Pte[Index].Soft.State == TargetState);

        //NewPte.Hard.Page = *Page++;
		NewPte.Hard.Page = (ULONG) (*Page << (PAGE_SHIFT - GART_PAGESHIFT_460GX)) + RunningCounter;		
        Pte[Index].AsUlong = NewPte.AsUlong;
        ASSERT(Pte[Index].Hard.Valid == 1);
		//AGPLOG(AGP_NOISE, ("AGP460: Page: %0x, newPte: %0x\n",Page,NewPte));
		RunningCounter++;

		if (RunningCounter == OS_ChipsetPagesizeRatio){
			RunningCounter = 0;
			Page++;
		}
    }

    //
    // We have filled in all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    NewPte.AsUlong = *(volatile ULONG *)&Pte[PageCount-1].AsUlong;

    

    AgpContext->GlobalEnable = TRUE;

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPMapMemory.\n"));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGP460_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Unmaps previously mapped memory in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range that the memory should be freed from

    NumberOfPages - Supplies the number of pages in the range to be freed.

    OffsetInPages - Supplies the offset into the range where the freeing should begin.

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    PGART_PTE Pte;
    PGART_PTE LastChanged=NULL;
    PGART_PTE StartPte;
    ULONG NewState;
	ULONG OS_ChipsetPagesizeRatio;

    PAGED_CODE();

	
	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPUnMapMemory.\n"));

    ASSERT(OffsetInPages + NumberOfPages <= AgpRange->NumberOfPages);

    OS_ChipsetPagesizeRatio = PAGE_SIZE / PAGESIZE_460GX_CHIPSET;

    StartPte = AgpRange->Context;
    Pte = &StartPte[OffsetInPages * OS_ChipsetPagesizeRatio];

    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else if (AgpRange->Type == MmWriteCombined) {
        NewState = GART_ENTRY_RESERVED_WC;
    } else {
        NewState = GART_ENTRY_RESERVED_WB;
    }


    for (i=0; i < NumberOfPages * OS_ChipsetPagesizeRatio; i++) {
        if (Pte[i].Hard.Valid) {
            Pte[i].Soft.State = NewState;
			Pte[i].Soft.Valid = FALSE;
            LastChanged = &Pte[i];
        } else {
            //
            // This page is not mapped, just skip it.
            //
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[i],
                    Pte[i].AsUlong,
                    i));
            ASSERT(Pte[i].Soft.State == NewState);
        }
    }

    //
    // We have invalidated all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    if (LastChanged != NULL) {
        ULONG Temp;
        Temp = *(volatile ULONG *)(&LastChanged->AsUlong);
    }

	
	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPUnMapMemory.\n"));

    return(STATUS_SUCCESS);
}


PGART_PTE
Agp460FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;
    PGART_PTE Candidate;

    PAGED_CODE();

	AGPLOG(AGP_NOISE, ("AGP460: Entering AGP460FindRangeInGART.\n"));

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if ((Current->Soft.State == SearchState) && (Current->Soft.Valid == 0)) 
		{
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
				
				AGPLOG(AGP_NOISE, ("AGP460: Leaving AGP460FindRangeInGart.\n"));
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

	
	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGP460FindRangeInGART.\n"));
    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;
	ULONG OS_ChipsetPagesizeRatio;
    
	
	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPFindFreeRun.\n"));

	OS_ChipsetPagesizeRatio = PAGE_SIZE / PAGESIZE_460GX_CHIPSET;

    Pte = (PGART_PTE)(AgpRange->Context) + (OffsetInPages * OS_ChipsetPagesizeRatio);

    //
    // Find the first free PTE
    //
    for (i=0; i< (NumberOfPages * OS_ChipsetPagesizeRatio); i++) {
        if (Pte[i].Hard.Valid == FALSE) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i/OS_ChipsetPagesizeRatio + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages * OS_ChipsetPagesizeRatio ) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                Pte[i].Hard.Valid = GART_ENTRY_VALID; // Sunil
                ++i;
            }
			*FreePages /= OS_ChipsetPagesizeRatio;
            AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPFindFreeRun - 1 Length: %0x, Offset: %0x\n",NumberOfPages,OffsetInPages));
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;

	
	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPFindFreeRun - 0 Length: %0x, Offset: %0x\n",NumberOfPages,OffsetInPages));
    return;

}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified 
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region 

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONGLONG Pages;
    ULONG OS_ChipsetPagesizeRatio;
	ULONGLONG AddressFromPFN;
	NTSTATUS ProbeStatus;

	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPGetMappedPages.\n"));

    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONGLONG)(Mdl + 1);

	OS_ChipsetPagesizeRatio = PAGE_SIZE / PAGESIZE_460GX_CHIPSET;
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages * OS_ChipsetPagesizeRatio;

    for (i=0; i< NumberOfPages ; i++) {
        ASSERT(Pte[i*OS_ChipsetPagesizeRatio].Hard.Valid == 1);
		AddressFromPFN = Pte[i*OS_ChipsetPagesizeRatio].Hard.Page << GART_PAGESHIFT_460GX;		
        Pages[i] = AddressFromPFN >> PAGE_SHIFT;
    }

    //Mdl->MdlFlags |= MDL_PAGES_LOCKED;  sunil - either you can set the bit here, or in ..../port/agp.c

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPGetMappedPages.\n"));
    return;
}


NTSTATUS
AgpSpecialTarget(
    IN PAGP460_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context

    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = Agp460SetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Add more tweaks here...
    //

    AgpContext->SpecialTarget |= DeviceFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
Agp460SetRate(
    IN PAGP460_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies the AGP context

    AgpRate - Rate to set

    note: this routine assumes that AGP has already been enabled, and that
          whatever rate we've been asked to set is supported by master

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetPciDeviceCapability(0, 0, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGP460SetRate: AgpLibGetPciDeviceCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGP460SetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP460SetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP460SetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGP460SetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    TargetCap.AGPCommand.Rate = AgpRate;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;
        
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP460SetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGP460SetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agpcpq\gart.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    gart.c

Abstract:


      This module contains the routines for setting and querying the AGP
      aperture, and for Reserving, Releasing, Mapping, and Unmapping.

   TODO:  
       1. Optimize for dual memory controllers (Done on 3/24/99 by elliots)
       2. Claim MMIO resources for the chipset
       3. Make sure the driver is generic for all RCC based systems (not just SP700).


Author:

    John Vert (jvert) 10/30/1997

Revision History:

    12/15/97    John Theisen    Modified to support Compaq Chipsets
    10/09/98    John Theisen    Modified to enable Shadowing in the SP700
                                prior to MMIO writes.
    01/15/99    John Theisen    Modified to disable the aperture, by
                                shrinking it to size = 0.
    3/24/99     Elliot Shmukler Added support for "favored" memory
                                ranges for AGP physical memory allocation,
                                fixed some bugs. These changes optimizine
                                the driver for dual memory controllers.
    3/16/00     Peter Johnston  Add support for ServerWorks HE chipset.
                                          
--*/
#include "AGPCPQ.H"

//
// Local routine prototypes
//
NTSTATUS
AgpCPQCreateGart(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

NTSTATUS
AgpCPQSetRate(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

PGART_PTE
AgpCPQFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

VOID
AgpCPQMaintainGARTCacheCoherency (
    IN PAGPCPQ_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS MemoryBase,
    IN ULONG NumberOfEntries,
    IN BOOLEAN InvalidateAll
    );

PIO_RESOURCE_LIST 
AgpCPQGetApSizeRequirements(
    ULONG   MaxSize,
    ULONG   Count
    );

NTSTATUS
AgpCPQSetApSizeInChipset
    (
    IN UCHAR               NewSetApSize,
    IN UCHAR               NewSetAgpValid
    );

NTSTATUS
AgpCPQSetApBaseInChipset
    (
    IN  PHYSICAL_ADDRESS    NewBase
    );


//
// IMPLEMENTATION
//

NTSTATUS
AgpQueryAperture(
    IN PAGPCPQ_EXTENSION AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *pApertureRequirements
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Returns the current base and size of the GART aperture. Optionally returns
*   the possible GART settings.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   CurrentBase -- Returns the current physical address of the aperture.
*
*   CurrentSizeInPages -- Returns the current size of the aperture, in pages.
*
*   pApertureRequirements -- If present, returns the possible aperture 
*       settings.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    ULONG BAR0, CodedApSize;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpQueryAperture entered.\n"));

    //
    // Get the current base physical address of the AGP Aperture.
    //
    ReadCPQConfig(&BAR0, OFFSET_BAR0, sizeof(BAR0));
    CurrentBase->QuadPart = BAR0 & PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Get the (current) size of the aperture.  This is done by writing all ones
    // to BAR0, and then reading back the value.  The Read/Write attributes
    // of bits 31:25 in BAR0 will indicate the size.  
    //
    CodedApSize = ALL_ONES;
    WriteCPQConfig(&CodedApSize, OFFSET_BAR0, sizeof(ULONG));
    ReadCPQConfig(&CodedApSize, OFFSET_BAR0, sizeof(CodedApSize));
    WriteCPQConfig(&BAR0, OFFSET_BAR0, sizeof(ULONG));

    CodedApSize &= MASK_LOW_TWENTYFIVE;
    switch(CodedApSize) {
        case BAR0_CODED_AP_SIZE_0MB:
            *CurrentSizeInPages = 0;
            break;
        case BAR0_CODED_AP_SIZE_32MB:
            *CurrentSizeInPages = (32 * 1024*1024) / PAGE_SIZE;
            break;
        case BAR0_CODED_AP_SIZE_64MB:
            *CurrentSizeInPages = (64 * 1024*1024) / PAGE_SIZE;
            break;
        case BAR0_CODED_AP_SIZE_128MB:
            *CurrentSizeInPages = (128* 1024*1024) / PAGE_SIZE;
            break;
        case BAR0_CODED_AP_SIZE_256MB:
            *CurrentSizeInPages = (256* 1024*1024) / PAGE_SIZE;
            break;
        case BAR0_CODED_AP_SIZE_512MB:
            *CurrentSizeInPages = (512* 1024*1024) / PAGE_SIZE;
            break;
        case BAR0_CODED_AP_SIZE_1GB:
            *CurrentSizeInPages = (1024*1024*1024) / PAGE_SIZE;
            break;
        case BAR0_CODED_AP_SIZE_2GB:
            *CurrentSizeInPages = (BYTES_2G) / PAGE_SIZE;
            break;
        default:
            AGPLOG(AGP_CRITICAL,
                ("AGPCPQ - AgpQueryAperture - Unexpected HW aperture size: %x.\n",
                *CurrentSizeInPages * PAGE_SIZE));
            ASSERT(FALSE);
            AgpContext->ApertureStart.QuadPart = 0;
            AgpContext->ApertureLength = 0;
            return(STATUS_UNSUCCESSFUL);
    }

    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    // 
    // The pApertureRequirements will be returned in an 
    // IO_RESOURCE_REQUIREMENTS_LIST structure
    // that describes the possible aperture sizes and bases that we support.
    // This will depend on which chipset we are running on, i.e. the 
    // Device-VendorID in the PCI config header.
    //
    if (pApertureRequirements != NULL) {
        switch (AgpContext->DeviceVendorID) {
            case AGP_CNB20_LE_IDENTIFIER:
                *pApertureRequirements = AgpCPQGetApSizeRequirements(
                    AP_MAX_SIZE_CNB20_LE, AP_SIZE_COUNT_CNB20_LE);
                break;
            case AGP_CNB20_HE_IDENTIFIER:
                *pApertureRequirements = AgpCPQGetApSizeRequirements(
                    AP_MAX_SIZE_CNB20_HE, AP_SIZE_COUNT_CNB20_HE);
                break;
            case AGP_DRACO_IDENTIFIER:
                *pApertureRequirements = AgpCPQGetApSizeRequirements(
                    AP_MAX_SIZE_DRACO, AP_SIZE_COUNT_DRACO);
                break;
            default:
                *pApertureRequirements = NULL;
                break;
        }
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetAperture(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Sets the AGP aperture to the requested settings.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   NewBase -- Supplies the new physical memroy base for the AGP aperture.
*
*   NewSizeInPages -- Supplies the new size for the AGP aperture.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    NTSTATUS        Status = STATUS_SUCCESS; // Assume successful completion.
    UCHAR           SetApSize;
    ULONG           ApBase;
    AGP_AP_SIZE_REG AgpApSizeRegister;
    BOOLEAN         ChangingBase = TRUE;
    BOOLEAN         ChangingSize = TRUE;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpSetAperture entered.\n"));

    //
    // If we are resuming from s3, or s4, we need to reprogram
    // the gart cache enable and base
    //
    if (AgpContext->Gart) {

        if (AgpContext->IsHPSA) DnbSetShadowBit(0);
        
        AgpContext->MMIO->GartBase.Page =
            (AgpContext->GartPointer >> PAGE_SHIFT);
        AgpContext->MMIO->FeatureControl.GARTCacheEnable = 1;
        
        //
        // If the chipset supports linking then enable linking.
        //
        if (AgpContext->MMIO->Capabilities.LinkingSupported==1) {
            AgpContext->MMIO->FeatureControl.LinkingEnable=1;
        }

        if (AgpContext->IsHPSA) DnbSetShadowBit(1);
    }

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }

    //
    // Determine which parameter(s) we are being asked to change.
    //
    if  (NewBase.QuadPart == AgpContext->ApertureStart.QuadPart) 
        {
        ChangingBase = FALSE;
        }

    if (NewSizeInPages == AgpContext->ApertureLength / PAGE_SIZE) 
        {
        ChangingSize = FALSE;
        }

    //
    // If the new settings match the current settings, leave everything alone.
    //
    if ( !ChangingBase && !ChangingSize )
        {
        return(STATUS_SUCCESS);
        }
    
    //
    // Make sure the supplied Base is aligned on the appropriate boundary for the size.
    //
    ASSERT(NewBase.HighPart == 0);
    ASSERT((NewBase.LowPart + (NewSizeInPages * PAGE_SIZE) - 1) <= ALL_ONES);
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);

    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) 
        {
        AGPLOG(AGP_CRITICAL,
            ("AgpSetAperture - invalid base: %I64X for aperture of %lx pages\n",
            NewBase.QuadPart,
            NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
        }

    //
    // Change the size first, since doing so will modify the Read/Write attributes 
    // of the appropriate bits in the Aperture Base register.
    //
    if (ChangingSize) {

        // 
        // Draco only supports the default 256MB h/w Aperture Size, and can't change it, so fail.
        //
        if (AgpContext->DeviceVendorID == AGP_DRACO_IDENTIFIER) 
            {
            ASSERT(NewSizeInPages != (256 * 1024*1024));
            AGPLOG(AGP_CRITICAL,
                ("AgpSetAperture - Chipset incapable of changing Aperture Size.\n"));
            return(STATUS_INVALID_PARAMETER);
            }

        // 
        // RCC HE and LE chipset both support from 32M to 2G h/w Aperture Size.
        // 
        ASSERT( (AgpContext->DeviceVendorID == AGP_CNB20_LE_IDENTIFIER) ||
                (AgpContext->DeviceVendorID == AGP_CNB20_HE_IDENTIFIER) );

        //
        // Determine the value to use to set the aperture size in the chipset's
        // Device Address Space Size register.
        //
        switch(NewSizeInPages) {
            case (32 * 1024*1024) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_32MB;
                break;
            case (64 * 1024*1024) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_64MB;
                break;
            case (128 * 1024*1024) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_128MB;
                break;
            case (256 * 1024*1024) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_256MB;
                break;
            case (512 * 1024*1024) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_512MB;
                break;
            case (1024 * 1024*1024) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_1GB;
                break;
            case (BYTES_2G) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_2GB;
                break;
           default:
                AGPLOG(AGP_CRITICAL,
                    ("AgpSetAperture - Invalid size: %lx pages.  Base: %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
                ASSERT(FALSE);
                return(STATUS_INVALID_PARAMETER);
        }

        //
        // Set the aperture size and set AgpValid bit.  This must be done before setting the Aperture Base.
        //
        Status = AgpCPQSetApSizeInChipset(SetApSize, 1);

        if (!NT_SUCCESS(Status)) 
            {
            return(Status);
            }

    } // End if ChangingSize

    if (ChangingBase) {
        
        //
        // Set the aperture base.
        //
        Status = AgpCPQSetApBaseInChipset(NewBase);

        if (!NT_SUCCESS(Status)) 
            {
            return(Status);
            }

    } // End if ChangingBase

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart   = NewBase;
    AgpContext->ApertureLength  = NewSizeInPages * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


VOID
AgpDisableAperture(
    IN PAGPCPQ_EXTENSION AgpContext
    )
/*++

Routine Description:

    Disables the GART aperture so that this resource is available
    for other devices

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None - this routine must always succeed.

--*/

{
    AGPLOG(AGP_NOISE, ("AgpCpq: AgpDisableAperture entered.\n"));

    //
    // Set the ApSize and AgpValid to 0, which causes BAR0 to be set back 
    // to zero and to be read only.
    //
    AgpCPQSetApSizeInChipset(0, 0);

    //
    // Nuke the Gart!  (It's meaningless now...)
    //
    if (AgpContext->Gart != NULL) {

        //
        // Two level translation...
        //
        if (AgpContext->MMIO->Capabilities.TwoLevelAddrTransSupported == 1) {
            
            AgpLibFreeMappedPhysicalMemory(AgpContext->Gart,
                                           AgpContext->GartLength);
            
            //
            // Free the directory base allocation
            //
            if (AgpContext->Dir != NULL) {
                MmFreeContiguousMemory(AgpContext->Dir);
                AgpContext->Dir = NULL;
            }

        } else {
            MmFreeContiguousMemory(AgpContext->Gart);
        }

        AgpContext->Gart = NULL;
        AgpContext->GartLength = 0;
    }
}

NTSTATUS
AgpReserveMemory(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Reserves a range of memory in the GART.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   Range -- Supplies the AGP_RANGE structure.  AGPLIB will have filled in 
*       NumberOfPages and Type.  This routine will fill in MemoryBase
*       and Context.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    ULONG       Index;
    ULONG       NewState;
    NTSTATUS    Status;
    PGART_PTE   FoundRange;
    BOOLEAN     Backwards;

    ASSERT((Range->Type == MmNonCached) || (Range->Type == MmWriteCombined));
    ASSERT(Range->NumberOfPages <= (AgpContext->ApertureLength / PAGE_SIZE));

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpReserveMemory entered.\n"));

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);
        Status = AgpCPQCreateGart(AgpContext, Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                ("AgpCPQCreateGart failed %08lx to create GART of size %lx\n",
                Status,
                AgpContext->ApertureLength/PAGE_SIZE));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries 
    // to satisfy the request. Requests for uncached memory will scan 
    // from high addresses to low addresses. Requests for write-combined 
    // memory will scan from low addresses to high addresses. We will 
    // use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
    FoundRange = AgpCPQFindRangeInGart(&AgpContext->Gart[0],
        &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
        Range->NumberOfPages, Backwards, GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
            ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
            Range->NumberOfPages,
            Range->Type,
            AgpContext->Gart));

        //
        //  This is where we could try and grow the GART
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    for (Index = 0; Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    //
    // Return the values.
    //
    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + 
        (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
        ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
        FoundRange,
        Range->MemoryBase.LowPart));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Releases memory previously reserved with AgpReserveMemory.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   Range -- Supplies the range to be released.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    PGART_PTE Pte, LastPteWritten;
    ULONG Start, ReadBack, PolledValue, Retry;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpReleaseMemory entered.\n"));

    

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point, nor should they be mapped.
    //
    LastPteWritten = NULL;
    for (Pte = Range->Context; 
        Pte < (PGART_PTE)Range->Context + Range->NumberOfPages;
        Pte++) 
        {
        ASSERT(Pte->Hard.Page == 0);
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        }

        Pte->Soft.State = GART_ENTRY_FREE;
        LastPteWritten = Pte;
        }

    //
    // Invalidate the GART Cache appropriately.
    // 
    AgpCPQMaintainGARTCacheCoherency(AgpContext, 
                                     Range->MemoryBase,
                                     Range->NumberOfPages, 
                                     FALSE );

    //
    // Flush the posted write buffers
    //
    if (AgpContext->IsHPSA) DnbSetShadowBit(0);
    AgpContext->MMIO->PostedWriteBufferControl.Flush = 1;
    if (AgpContext->IsHPSA) DnbSetShadowBit(1);

    if (LastPteWritten) {
        ReadBack = *(volatile ULONG *)&LastPteWritten->AsUlong;
    }

    for (Retry = 1000; Retry; Retry--) {
        PolledValue =
            AgpContext->MMIO->PostedWriteBufferControl.Flush;
        if (PolledValue == 0) {
            break;
        }
    }
    ASSERT(PolledValue == 0); // This bit should get reset by the chipset.

    Range->MemoryBase.QuadPart = 0;
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpMapMemory(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Maps physical memory into the AGP aperture, somewhere in the specified
*   range.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   Range -- Supplies the AGP range into which the memory should be mapped.
*
*   Mdl -- Supplies the MDL describing the physical pages to be mapped.
*
*   OffsetInPages - Supplies the offset into the reserved range where the 
*       mapping should begin.
*
*   MemoryBase -- Returns the 'physical' address in the aperture where the
*       pages were mapped.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    ULONG       PageCount;
    PGART_PTE   Pte;
    PGART_PTE   StartPte;
    ULONG       Index;
    ULONG       TargetState;
    PULONG      Page;
    BOOLEAN     Backwards;
    GART_PTE    NewPte;
    ULONG       PolledValue, Retry;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpMapMemory entered.\n"));

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    TargetState = (Range->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : 
                                                 GART_ENTRY_RESERVED_WC;

    Pte = StartPte + OffsetInPages;

    //
    // We have found a suitable spot to map the pages.  Now map them. 
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount <= StartPte + Range->NumberOfPages);
    NewPte.AsUlong = 0;
    NewPte.Soft.State = (Range->Type == MmNonCached) ? GART_ENTRY_VALID_UC :
                                                       GART_ENTRY_VALID_WC;
    Page = (PULONG)(Mdl + 1);

    for (Index = 0; Index < PageCount; Index++) 
        {
        ASSERT(Pte[Index].Soft.State == TargetState);
        NewPte.Hard.Page = *Page++;
        Pte[Index].AsUlong = NewPte.AsUlong;
        ASSERT(Pte[Index].Hard.Valid == 1);
        ASSERT(Pte[Index].Hard.Linked == 0);
        }

    // 
    // If Linking is supported, then link the entries by setting the link bit
    // in all entries, except the last entry, in the mapped set.
    //
    if (AgpContext->MMIO->Capabilities.LinkingSupported) {
        ASSERT(AgpContext->MMIO->FeatureControl.LinkingEnable);
        for (Index = 0; Index < PageCount-1; Index++) {
            ASSERT(Pte[Index].Hard.Page != 0);
            Pte[Index].Hard.Linked = 1;
        }
    }

    //
    // We have filled in all the PTEs. Now flush the write buffers.
    //
    if (AgpContext->IsHPSA) DnbSetShadowBit(0);
    AgpContext->MMIO->PostedWriteBufferControl.Flush = 1;
    if (AgpContext->IsHPSA) DnbSetShadowBit(1);
    NewPte.AsUlong = *(volatile ULONG *)&Pte[PageCount-1].AsUlong;

    for (Retry = 1000; Retry; Retry--) {
        PolledValue =
            AgpContext->MMIO->PostedWriteBufferControl.Flush;
        if (PolledValue == 0) {
            break;
        }
    }
    ASSERT(PolledValue == 0); // This bit should get reset by the chipset.

    //
    // Return where they are mapped
    //
    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   UnMaps all or part of the memory that was previously mapped by AgpMapMemory.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   AgpRange -- Supplies the AGP range out of which memory should be un-mapped.
*
*   NumberOfPages -- Supplies the number of pages in the range to be un-mapped.
*
*   OffsetInPages -- Supplies the offset into the Reserved Range where the un-mapping
*       should begin.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    ULONG       Index, TargetState, ReadBack, PolledValue, Retry;
    PGART_PTE   ReservedBasePte;
    PGART_PTE   Pte;
    PGART_PTE   LastChangedPte=NULL;
    PHYSICAL_ADDRESS pa;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpUnMapMemory entered.\n"));

    ASSERT(OffsetInPages + NumberOfPages <= AgpRange->NumberOfPages);

    ReservedBasePte = AgpRange->Context;
    Pte = &ReservedBasePte[OffsetInPages];

    TargetState = (AgpRange->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : GART_ENTRY_RESERVED_WC;
                                                 
    //
    // UnMap each entry by putting each Mapped Entry back into the 'Reserved State'
    //
    for (Index=0; Index < NumberOfPages; Index++) {

        if (Pte[Index].Hard.Valid) {
            ASSERT(Pte[Index].Hard.Page != 0);

            Pte[Index].Hard.Page = 0;
            Pte[Index].Soft.State = TargetState;
            LastChangedPte = &Pte[Index];

        } else {
            //
            // We are being asked to un-map a page that is not mapped.
            //
            ASSERT(Pte[Index].Hard.Page == 0);
            ASSERT(Pte[Index].Soft.State == TargetState);
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[Index],
                    Pte[Index].AsUlong,
                    Index));
        }
    }

    // 
    // Maintain link bit coherency within this reserved range.
    //
    if (OffsetInPages != 0) {
        ASSERT(OffsetInPages >= 1);
        if (ReservedBasePte[OffsetInPages-1].Hard.Linked == 1) {
            ASSERT(ReservedBasePte[OffsetInPages-1].Hard.Valid == 1);
            ReservedBasePte[OffsetInPages-1].Hard.Linked = 0;
        }
    }

    //
    // Invalidate the Cache appropriately.
    // 
    pa.HighPart = 0;
    pa.LowPart = AgpRange->MemoryBase.LowPart + OffsetInPages*PAGE_SIZE;
    AgpCPQMaintainGARTCacheCoherency(AgpContext, pa, NumberOfPages, FALSE);

    //
    // Flush the posted write buffers
    //
    if (LastChangedPte != NULL) 
        {
        if (AgpContext->IsHPSA) DnbSetShadowBit(0);
        AgpContext->MMIO->PostedWriteBufferControl.Flush = 1;
        if (AgpContext->IsHPSA) DnbSetShadowBit(1);
        
        ReadBack = *((volatile ULONG *)&(LastChangedPte[0].AsUlong));
        
        for (Retry = 2000; Retry; Retry--) {
            PolledValue =
                AgpContext->MMIO->PostedWriteBufferControl.Flush;
            if (PolledValue == 0) {
                break;
            }
        }
        ASSERT(PolledValue == 0); // This bit should get reset by the chipset.
        }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpCPQCreateGart(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Allocates and initializes an empty GART. The current implementation
*   attempts to allocate the entire GART on the first reserve.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   MinimumPages -- Supplies the minimum size (in pages) of the GART to be
*       created.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    PGART_PTE Gart;
    ULONG* Dir;
    PHYSICAL_ADDRESS LowestAcceptable;
    PHYSICAL_ADDRESS BoundaryMultiple;
    PHYSICAL_ADDRESS HighestAcceptable;
    PHYSICAL_ADDRESS GartPhysical, DirPhysical, GartPointer, GartPagePhysical;
    ULONG Index;
    ULONG GartLength = BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE);;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpCPQCreateGart entered.\n"));

    // 
    // If the chipset requires two-level address translation, then allocate a not-necessarily-
    // contiguous GART, and create a Directory.  Otherwise, allocate a contiguous GART.
    //

    if (AgpContext->MMIO->Capabilities.TwoLevelAddrTransSupported == 1){

        // 
        // The chipset uses 2-level GART address translation.
        // Allocate the (not-necessarily-contiguous) GART.
        //

        Gart = AgpLibAllocateMappedPhysicalMemory(AgpContext, GartLength);

        if (Gart == NULL) 
            {
            AGPLOG(AGP_CRITICAL,
                ("AgpCPQCreateGart - MmAllocateNonCachedMemory, for %lx bytes, failed\n",
                PAGE_SIZE));
            return(STATUS_INSUFFICIENT_RESOURCES);
            }
        ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

        // 
        // Now allocate a GART Directory.  The directory needs to be
        // below the 4GB boundary.
        //

        HighestAcceptable.QuadPart = 0xffffffff;
        LowestAcceptable.QuadPart = 0;
        BoundaryMultiple.QuadPart = 0;

        Dir = MmAllocateContiguousMemorySpecifyCache(PAGE_SIZE,
                                                     LowestAcceptable,
                                                     HighestAcceptable,
                                                     BoundaryMultiple,
                                                     MmNonCached);
        if (Dir == NULL) 
            {
            AGPLOG(AGP_CRITICAL,
                ("AgpCPQCreateGart - MmAllocateContiguousMemory %lx failed\n",
                PAGE_SIZE));
            return(STATUS_INSUFFICIENT_RESOURCES);
            }
        ASSERT(((ULONG_PTR)Dir & (PAGE_SIZE-1)) == 0);
        DirPhysical = MmGetPhysicalAddress(Dir);

        //
        // Walk the Directory, and assign to each Directory entry the value
        // of the physical address of the corresponding GART page.
        //
        ASSERT(GartLength/PAGE_SIZE <= PAGE_SIZE/sizeof(ULONG));
        for (Index=0; Index<(GartLength/PAGE_SIZE); Index++) 
            {
            ULONG HighPart;
            ULONG Temp;

            GartPagePhysical = MmGetPhysicalAddress( &(Gart[Index*PAGE_SIZE/sizeof(GART_PTE)]));

            //
            // Format of a directory entry is
            // 31      12   11     10     9     8     7    2  1   0   <- bits
            // ------------------------------------------------------
            // | [31:12] | [32] | [33] | [34] | [35] |      | L | V | <- Data
            // ------------------------------------------------------
            //
            // Where:-
            // 31-12 are bits 31 thru 12 of the physical address, ie
            //       the page number if the page is below 4GB.
            // 32, 33, 34 and 35 are the respective bits of the physical
            //       address if the address is above 4GB.
            // L     Link.
            // V     Valid.
            //

            ASSERT((GartPagePhysical.HighPart & ~0xf) == 0);

            HighPart = GartPagePhysical.HighPart & 0xf;
            Temp      = (HighPart & 1) << 11;// bit 32 -> bit 11
            Temp     |= (HighPart & 2) << 9 ;// bit 33 -> bit 10
            Temp     |= (HighPart & 4) << 7 ;// bit 34 -> bit  9
            Temp     |= (HighPart & 8) << 5 ;// bit 35 -> bit  8
            Dir[Index] = GartPagePhysical.LowPart | Temp;

            }

    } else { 

        // 
        // The chipset uses single level address translation.
        // Allocate the contiguous GART.
        // 

        //
        // Try and get a chunk of contiguous memory big enough to map the
        // entire aperture. 
        //
        HighestAcceptable.QuadPart = 0xFFFFFFFF;
        LowestAcceptable.QuadPart = 0;
        BoundaryMultiple.QuadPart = 0;

        Gart = MmAllocateContiguousMemorySpecifyCache(GartLength,
                                                      LowestAcceptable,
                                                      HighestAcceptable,
                                                      BoundaryMultiple,
                                                      MmNonCached);
        if (Gart == NULL) 
            {
            AGPLOG(AGP_CRITICAL,
                ("AgpCPQCreateGart - MmAllocateContiguousMemory %lx failed\n",
                GartLength));
            return(STATUS_INSUFFICIENT_RESOURCES);
            }

        //
        // We successfully allocated a contiguous chunk of memory.
        // It should be page aligned already.
        //
        ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

        //
        // Get the physical address.
        //
        GartPhysical = MmGetPhysicalAddress(Gart);
        AGPLOG(AGP_NOISE,
            ("AgpCPQCreateGart - GART of length %lx created at VA %08lx, PA %08lx\n",
            GartLength,
            Gart,
            GartPhysical.LowPart));
        ASSERT(GartPhysical.HighPart == 0);
        ASSERT((GartPhysical.LowPart & (PAGE_SIZE-1)) == 0);

    }

    //
    // Initialize all the GART PTEs to free
    //
    for (Index=0; Index<GartLength/sizeof(GART_PTE); Index++) 
        {
        Gart[Index].Soft.State = GART_ENTRY_FREE;
        }

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
    if (AgpContext->MMIO->Capabilities.TwoLevelAddrTransSupported == 1) {
        AgpContext->Dir = Dir;
        GartPointer=DirPhysical;
    } else {
        AgpContext->Dir = NULL;
        GartPointer=GartPhysical;
    }

    //
    // Stash GartPointer for resuming from s3 or s4
    //
    AgpContext->GartPointer = GartPointer.LowPart;

    //
    // Tell the chipset where the GART base is.
    //
    if (AgpContext->IsHPSA) DnbSetShadowBit(0);
    AgpContext->MMIO->GartBase.Page = (GartPointer.LowPart >> PAGE_SHIFT);
    if (AgpContext->IsHPSA) DnbSetShadowBit(1);

    return(STATUS_SUCCESS);
}


PGART_PTE
AgpCPQFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;
    PGART_PTE Candidate;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpCPQFindRangeInGart entered.\n"));

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if (Current->Soft.State == SearchState) {
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
AgpCPQMaintainGARTCacheCoherency(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS MemoryBase,
    IN ULONG NumberOfEntries,
    IN BOOLEAN InvalidateAll
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Invalidates the entire GART [&DIR] Cache, or  individual Entries in the GART
*   cache, depending on which would provide better overall performance.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   MemoryBase -- Supplies the 'physical' address, in the AGP aperture,
*       corresponding to the first GART Entry to flush
*       from the GART Entry Cache. 
*
*   NumberOfEntries -- Supplies the number of Cached Entries which need to be 
*       invalidated.
*
*   InvalidateAll -- Supplies a flag that, if TRUE, indicates that this routine
*       should invalidate the entire GART [&DIR] cache, rather than the individual
*       Cached Entries.  If FALSE, then this routine decides how best to do it.
*
* Return Value:
*
*   None
*                                                                       
*******************************************************************************/

{
    ULONG PolledValue, AperturePage, Index, Retry;
    GART_CACHE_ENTRY_CONTROL CacheEntryControlValue;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpCPQMaintainGARTCacheCoherency entered.\n"));

    if (InvalidateAll || (NumberOfEntries > MAX_CACHED_ENTRIES_TO_INVALIDATE)) {
        // 
        // Invalidate the entire GART [&DIR] Cache
        //
        if (AgpContext->IsHPSA) DnbSetShadowBit(0);
        AgpContext->MMIO->CacheControl.GartAndDirCacheInvalidate = 1;
        if (AgpContext->IsHPSA) DnbSetShadowBit(1);
        for (Retry = 2000; Retry; Retry--) {
            PolledValue =
                    AgpContext->MMIO->CacheControl.GartAndDirCacheInvalidate;
            if (PolledValue == 0) {
                break;
            }
        }
        ASSERT(PolledValue == 0); // This bit should get reset by the chipset.
    } else {
        //
        // Invalidate the individual cached GART enties
        //
        AperturePage = MemoryBase.LowPart >> PAGE_SHIFT;
        for (Index=0; Index<NumberOfEntries; Index++, AperturePage++) {
            CacheEntryControlValue.AsBits.GartEntryInvalidate = 1;
            CacheEntryControlValue.AsBits.GartEntryOffset = AperturePage;
            if (AgpContext->IsHPSA) DnbSetShadowBit(0);
            AgpContext->MMIO->CacheEntryControl.AsDword = 
                CacheEntryControlValue.AsDword;
            if (AgpContext->IsHPSA) DnbSetShadowBit(1);
            for (Retry = 1000; Retry; Retry--) {
                PolledValue = 
                AgpContext->MMIO->CacheEntryControl.AsBits.GartEntryInvalidate;
                if (PolledValue == 0) {
                    break;
                }
            }
            ASSERT(PolledValue == 0);
        }
    }

    return;
}


PIO_RESOURCE_LIST 
AgpCPQGetApSizeRequirements(
    ULONG   MaxSize,
    ULONG   Count
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Creates and fills in an IO_RESOURCE_LIST structure, which describes
*   the possible aperture sizes supported by the chipset.
*               
* Arguments:
*   
*   MaxSize -- The Maximum possible size, in Bytes, for the aperture
*
*   Count -- The number of different aperture sizes.  This routine assumes
*       that the aperture size is a multiple of two
*       times the smallest aperture size.  For example, 256MB, 128MB, 64MB
*       32MB.  MaxSize would be 256M, and count would be 4.
*
* Return Value:
*
*   Pointer to the newly created IO_RESOURCE_LIST.
*                                                                       
*******************************************************************************/

{
    PVOID RequirementsPointer;
    PIO_RESOURCE_LIST   Requirements;
    ULONG Length, Index;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpCPQGetApSizeRequirements entered.\n"));

    RequirementsPointer = ExAllocatePoolWithTag(PagedPool, sizeof(IO_RESOURCE_LIST) + 
        (Count-1)*sizeof(IO_RESOURCE_DESCRIPTOR), 'RpgA');

    if (RequirementsPointer == NULL) {
        AGPLOG(AGP_NOISE,
       ("AgpAgpCPQGetApSizeRequirements - Failed to Allocate memory for a Resource Descriptor.\n"));
        return(NULL);
    } else {
        Requirements = (PIO_RESOURCE_LIST)RequirementsPointer;
    }

    //
    // Compaq supports several different aperture sizes, all must be 
    // naturally aligned. Start with the largest aperture and 
    // work downwards so that we get the biggest possible aperture.
    //

    Requirements->Version = Requirements->Revision = 1;
    Requirements->Count = Count;
    Length = MaxSize;
    for (Index=0; Index < Count; Index++) 
        {
        Requirements->Descriptors[Index].Option = IO_RESOURCE_ALTERNATIVE;
        Requirements->Descriptors[Index].Type = CmResourceTypeMemory;
        Requirements->Descriptors[Index].ShareDisposition = CmResourceShareDeviceExclusive;
        Requirements->Descriptors[Index].Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;

        Requirements->Descriptors[Index].u.Memory.Length = Length;
        Requirements->Descriptors[Index].u.Memory.Alignment = Length;
        Requirements->Descriptors[Index].u.Memory.MinimumAddress.QuadPart = 0;
        Requirements->Descriptors[Index].u.Memory.MaximumAddress.QuadPart = (ULONG)-1;

        Length = Length/2;
        }

    return(Requirements);
}


NTSTATUS
AgpCPQSetApSizeInChipset
    (
    IN UCHAR               NewSetApSize,
    IN UCHAR               NewSetAgpValid
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Modifes the Device Address Space (Aperture) Size register in the chipset's
*   PCI-PCI bridge.
*               
* Arguments:
*   
*   NewSetApSize -- The value to set in bits 3:1 of the DAS_SIZE register.
*   NewSetAgpValid -- Value to set in bit 0 of the DAS_SIZE register.   
*
* Return Value:
*
*   NT Status value.
*                                                                       
*******************************************************************************/

{
    NTSTATUS                    Status = STATUS_SUCCESS;
    UCHAR                       ApSizeRegisterOffset;
    BUS_SLOT_ID                 CpqP2PBusSlotID;
    AGP_AP_SIZE_REG             ApSizeRegister;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpCPQSetApSizeInChipset entered.\n"));

    ApSizeRegisterOffset    =   OFFSET_AP_SIZE;
    CpqP2PBusSlotID.BusId   =   AGP_CPQ_BUS_ID;
    CpqP2PBusSlotID.SlotId  =   AGP_CPQ_PCIPCI_SLOT_ID;

    ApSizeRegister.AsBits.ApSize = NewSetApSize;
    ApSizeRegister.AsBits.AgpValid = NewSetAgpValid;

    Status = ApGetSetBusData(&CpqP2PBusSlotID, FALSE, &ApSizeRegister.AsByte, 
        ApSizeRegisterOffset, sizeof(UCHAR));

    return(Status);
}


NTSTATUS
AgpCPQSetApBaseInChipset
    (
    IN  PHYSICAL_ADDRESS    NewBase
    )
{
    ULONG   ApBase;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpCPQSetApBaseInChipset entered.\n"));

    //
    // Write the value of the aperture base in BAR0.
    //
    ApBase = NewBase.LowPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    WriteCPQConfig(&ApBase, OFFSET_BAR0, sizeof(ApBase));

#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        ULONG DbgBase;

        ReadCPQConfig(&DbgBase, OFFSET_BAR0, sizeof(ApBase));
        ASSERT((DbgBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK) == ApBase);
    }
#endif

    return(STATUS_SUCCESS);
}



VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;
    
    AGPLOG(AGP_NOISE, ("AgpCpq: AgpFindFreeRun entered.\n"));

    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid == 0) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                ++i;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
    return;
}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified 
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region 

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONG Pages;
    
    AGPLOG(AGP_NOISE, ("AgpCpq: AgpGetMappedPages entered.\n"));

    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONG)(Mdl + 1);
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    for (i=0; i<NumberOfPages; i++) {
        ASSERT(Pte[i].Hard.Valid == 1);
        Pages[i] = Pte[i].Hard.Page;
    }
    return;
    

}


NTSTATUS
AgpSpecialTarget(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context

    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = AgpCPQSetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Add more tweaks here...
    //

    AgpContext->SpecialTarget |=DeviceFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
AgpCPQSetRate(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies the AGP context

    AgpRate - Rate to set

    note: this routine assumes that AGP has already been enabled, and that
          whatever rate we've been asked to set is supported by master

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetPciDeviceCapability(0, 0, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AgpCpqSetRate: AgpLibGetPciDeviceCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AgpCpqSetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AgpCpqSetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AgpCpqSetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AgpCpqSetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    TargetCap.AGPCommand.Rate = AgpRate;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;
        
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AgpCpqSetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AgpCpqSetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agpcpq\init.c ===
/*++

Copyright (c) 1996, 1997 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code for the Compaq driver.

Author:

    John Vert (jvert) 10/21/1997

Revision History:

    12/15/97    John Theisen    Modified to support Compaq Chipsets
    10/09/98    John Theisen    Modified to workaround an RCC silicon bug.  
                                If RCC Silicon Rev <= 4, then limit DATA_RATE to 1X.
    10/09/98    John Theisen    Modified to enable Shadowing in the SP700 prior to MMIO writes.
    01/15/98    John Theisen    Modified to set RQ depth to be 0x0F for all REV_IDs
    03/14/00    Peter Johnston  Add support for HE chipset.

--*/

#include "AGPCPQ.H"

ULONG AgpExtensionSize = sizeof(AGPCPQ_EXTENSION);
PAGP_FLUSH_PAGES AgpFlushPages = NULL;  // not implemented


NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   This function is the entrypoint for initialization of the AGP Target.  It 
*   is called first, and performs initialization of the chipset and extension.
*               
* Assumptions:  Regardless of whether we are running on a dual north bridge platform, 
*               this driver will only be installed and invoked once (for the AGP bridge at B0D0F1).
*
* Arguments:
*   
*   AgpExtension -- Supplies the AGP Extension
*
* Return Value:
*
*   STATUS_SUCCESS if successfull
*                                                                       
*******************************************************************************/

{
    ULONG               DeviceVendorID  = 0;
    ULONG               BAR1            = 0;
    PAGPCPQ_EXTENSION   Extension       = AgpExtension;
    PHYSICAL_ADDRESS    pa;
    ULONG               BytesReturned   = 0;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpInitializeTarget entered.\n"));
    //
    // Initialize our Extension
    //
    RtlZeroMemory(Extension, sizeof(AGPCPQ_EXTENSION));

    //
    // Verify that the chipset is a supported RCC Chipset.
    //
    ReadCPQConfig(&DeviceVendorID,OFFSET_DEVICE_VENDOR_ID,sizeof(DeviceVendorID));

    if ((DeviceVendorID != AGP_CNB20_LE_IDENTIFIER)   &&
        (DeviceVendorID != AGP_CNB20_HE_IDENTIFIER)   &&
        (DeviceVendorID != AGP_CNB20_HE4X_IDENTIFIER) &&
        (DeviceVendorID != AGP_CMIC_GC_IDENTIFIER)) {
        AGPLOG(AGP_CRITICAL,
            ("AGPCPQ - AgpInitializeTarget was called for platform %08x, which is not a known RCC AGP chipset!\n",
             DeviceVendorID));
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Check for CNB_20_HE (function 1) -- 0x00091166 busted AGP3.5 rev >= 0xA0
    //
    if (DeviceVendorID == AGP_CNB20_HE_IDENTIFIER) {
        UCHAR Revision;

        BytesReturned = HalGetBusDataByOffset(PCIConfiguration,
                                              PRIMARY_HE_BUS_ID,
                                              PRIMARY_HE_PCIPCI_SLOT_ID, 
                                              &Revision,
                                               OFFSET_REV_ID,
                                              sizeof(Revision));

        if ((BytesReturned == sizeof(Revision)) && (Revision >= 0xA0)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGPCPQ - AgpInitializeTarget was called for HE "
                    "revision %08x, which is not a known good RCC AGP "
                    "chipset revision!\n",
                    Revision));
            return(STATUS_UNSUCCESSFUL);
        }
    }

    Extension->DeviceVendorID = DeviceVendorID;

    //
    // Read the chipset's BAR1 Register, and then map the chipset's 
    // Memory Mapped Control Registers into kernel mode address space.
    //
    ReadCPQConfig(&BAR1,OFFSET_BAR1,sizeof(BAR1));
    pa.HighPart = 0;
    pa.LowPart = BAR1;
    Extension->MMIO = (PMM_CONTROL_REGS)MmMapIoSpace(pa, sizeof(MM_CONTROL_REGS), FALSE);

    if (Extension->MMIO == NULL)
        {
        AGPLOG(AGP_CRITICAL,
            ("AgpInitializeTarget - Couldn't allocate %08x bytes for MMIO\n",
            sizeof(MM_CONTROL_REGS)));
        return(STATUS_UNSUCCESSFUL);
        }

    // 
    // Verify that the chipset's Revision ID is correct, but only complain, if it isn't.
    //
    if (Extension->MMIO->RevisionID < LOWEST_REVISION_ID_SUPPORTED)
        {
        AGPLOG(AGP_CRITICAL,
            ("AgpInitializeTarget - Revision ID = %08x, it should = 1.\n",
            Extension->MMIO->RevisionID));
        }

    //
    // Determine if there are two RCC North Bridges in this system.
    //
    DeviceVendorID = 0;
    BytesReturned = HalGetBusDataByOffset(PCIConfiguration, SECONDARY_LE_BUS_ID, SECONDARY_LE_HOSTPCI_SLOT_ID, 
        &DeviceVendorID, OFFSET_DEVICE_VENDOR_ID, sizeof(DeviceVendorID));

    if((DeviceVendorID != Extension->DeviceVendorID) || (BytesReturned != sizeof(DeviceVendorID)) ) {
        Extension->IsHPSA = FALSE;        
    } else {
        Extension->IsHPSA = TRUE;
    }  

    //
    // Enable the GART cache
    //
    if (Extension->IsHPSA) DnbSetShadowBit(0);

    Extension->MMIO->FeatureControl.GARTCacheEnable = 1;

    //
    // The extension is zero'd above, so we don't need to init any data
    // to zero/NULL
    //
    //Extension->GartPointer = 0;
    //Extension->SpecialTarget = 0;
    //Extension->Gart = NULL;
    //Extension->Gart = NULL;
    //Extension->GartLength = 0;
    //Extension->Dir = NULL;

    //
    // If the chipset supports linking then enable linking.
    //
    if (Extension->MMIO->Capabilities.LinkingSupported==1) {
        Extension->MMIO->FeatureControl.LinkingEnable=1;
    }

    if (Extension->IsHPSA) DnbSetShadowBit(1);
    
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   This function is the entrypoint for initialization of the AGP Master. It
*   is called after Target initialization, and is intended to be used to 
*   initialize the AGP capabilities of both master and target.
*
* Arguments:
*   
*   AgpExtension -- Supplies the AGP Extension
*   
*   AgpCapabilities -- Returns the "software-visible" capabilities of the device
*
* Return Value:
*
*   NTSTATUS       
*                                                                
*******************************************************************************/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    PAGPCPQ_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable;
    ULONG FastWrite;
    ULONG DataRate;
    UCHAR RevID = 0;
    BOOLEAN ReverseInit;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpInitializeMaster entered.\n"));

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) 
        {
        AGPLOG(AGP_CRITICAL,
            ("AGPCPQInitializeDevice - AgpLibGetMasterCapability failed %08lx\n",
            Status));
        return(Status);
        }

    Status = AgpLibGetPciDeviceCapability(AGP_CPQ_BUS_ID, 
                                          AGP_CPQ_PCIPCI_SLOT_ID,
                                          &TargetCap);
    if (!NT_SUCCESS(Status)) 
        {
        AGPLOG(AGP_CRITICAL,
               ("AGPCPQInitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n",
               Status));
        return(Status);
        }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;
    AGP_ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);
    }

    //
    // FIX RCC silicon bugs:  
    // If RevID <= 4, then the reported Data Rate is 2X but the chip only supports 1X.
    // Regardless of RevID the reported RQDepth should be 0x0F.
    //
    if (Extension->DeviceVendorID == AGP_CNB20_LE_IDENTIFIER) {
        ReadCPQConfig(&RevID, OFFSET_REV_ID, sizeof(RevID));

        AGP_ASSERT(TargetCap.AGPStatus.RequestQueueDepthMaximum == 0x10); 
        TargetCap.AGPStatus.RequestQueueDepthMaximum = 0x0F;

        if (RevID <= MAX_REV_ID_TO_LIMIT_1X) {
            DataRate = PCI_AGP_RATE_1X;
        }
    }

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing & 
                 MasterCap.AGPStatus.SideBandAddressing);

    //
    // Enable FastWrite if both master and target support it.
    //
    
    FastWrite = (TargetCap.AGPStatus.FastWrite &
                 MasterCap.AGPStatus.FastWrite);

    //
    // Enable the Master first.
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) 
        {
            AGPLOG(AGP_CRITICAL,
                   ("AGPCPQInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    //
    // Now enable the Target.
    //
    TargetCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    TargetCap.AGPCommand.FastWriteEnable = FastWrite;
    Status = AgpLibSetPciDeviceCapability(AGP_CPQ_BUS_ID, 
                                          AGP_CPQ_PCIPCI_SLOT_ID, 
                                          &TargetCap);
    if (!NT_SUCCESS(Status)) 
        {
        AGPLOG(AGP_CRITICAL,
               ("AGPCPQInitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
        }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) 
        {
            AGPLOG(AGP_CRITICAL,
                   ("AGPCPQInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

#if DBG
    {
        PCI_AGP_CAPABILITY CurrentCap;

        //
        // Read them back, see if it worked
        //
        Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
        AGP_ASSERT(NT_SUCCESS(Status));
        //
        // If the target request queue depth is greater than the master will
        // allow, it will be trimmed.   Loosen the assert to not require an
        // exact match.
        //
        AGP_ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
        CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
        AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));


        Status = AgpLibGetPciDeviceCapability(AGP_CPQ_BUS_ID, 
                                              AGP_CPQ_PCIPCI_SLOT_ID,
                                              &CurrentCap);
        AGP_ASSERT(NT_SUCCESS(Status));
        AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, 
            sizeof(CurrentCap.AGPCommand)));
    }
#endif

    //
    // Indicate that we can map memory through the GART aperture
    //
    *AgpCapabilities = AGP_CAPABILITIES_MAP_PHYSICAL;

    return(Status);
}


NTSTATUS 
DnbSetShadowBit(
    ULONG SetToOne
    )
//
// This routine is required, (because of a new requirement in the RCC chipset.).
// When there are two NorthBridge's, the shadow bit must be set to 0 prior
// to any MMIO writes, and then set back to 1 when done.
//
{
    NTSTATUS    Status = STATUS_SUCCESS;    // Assume Success
    UCHAR       ShadowByte = 0;
    ULONG       BytesReturned = 0;
    ULONG       length = 1;

    if (SetToOne == 1) {

        //
        // Set the shadow bit to a one. (This disables shadowing.)
        //
        BytesReturned = HalGetBusDataByOffset(PCIConfiguration, SECONDARY_LE_BUS_ID,
            SECONDARY_LE_HOSTPCI_SLOT_ID, &ShadowByte, OFFSET_SHADOW_BYTE, length);

        if(BytesReturned != length) {
            AGPLOG(AGP_CRITICAL,("ERROR: Failed to read shadow register!\n"));
            Status = STATUS_UNSUCCESSFUL;
            goto exit_routine;
        }

        ShadowByte |= FLAG_DISABLE_SHADOW;

        HalSetBusDataByOffset(PCIConfiguration, SECONDARY_LE_BUS_ID,
            SECONDARY_LE_HOSTPCI_SLOT_ID, &ShadowByte, OFFSET_SHADOW_BYTE, length);

        if(BytesReturned != length) {
            AGPLOG(AGP_CRITICAL,("ERROR: Failed to write shadow register!\n"));
            Status = STATUS_UNSUCCESSFUL;
            goto exit_routine;
        }

    } else {

        //
        // Set the shadow bit to a zero. (This enables shadowing.)
        //
        BytesReturned = HalGetBusDataByOffset(PCIConfiguration, SECONDARY_LE_BUS_ID,
            SECONDARY_LE_HOSTPCI_SLOT_ID, &ShadowByte, OFFSET_SHADOW_BYTE, length);

        if(BytesReturned != length) {
            AGPLOG(AGP_CRITICAL,("ERROR: Failed to read shadow register!"));
            Status = STATUS_UNSUCCESSFUL;
            goto exit_routine;
        }

        ShadowByte &= MASK_ENABLE_SHADOW;

        HalSetBusDataByOffset(PCIConfiguration, SECONDARY_LE_BUS_ID,
            SECONDARY_LE_HOSTPCI_SLOT_ID, &ShadowByte, OFFSET_SHADOW_BYTE, length);

        if(BytesReturned != length) {
            AGPLOG(AGP_CRITICAL,("ERROR: Failed to write shadow register!"));
            Status = STATUS_UNSUCCESSFUL;
            goto exit_routine;
        }
    }

exit_routine:

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agpcpq\agpcpq.h ===
/******************************************************************************\
*
*  FileName:    AGPCPQ.H       
*
*  Group:       AGP (Accelerated Graphics Port)
*                    
*  Level:       Driver
*
*  Date:        December 15, 1997
*
*  Author:      John Theisen
*
********************************************************************************
*
*  Module Functional Description:
*
*      This is the header file for Compaq's Accelerated Graphics Port (AGP) 
*      GART MiniPort driver.
*
********************************************************************************
*
*  History:
*
*    DATE   REV. DESCRIPTION                          DELEVOPER
*  -------- ---- ------------------------------------ -------------------------
*
*  12/15/97 1.00 Initial Revision.                    John Theisen
*
\******************************************************************************/
#define _NTDRIVER_

#include "stdarg.h"
#include "stdio.h"
#include "ntos.h"
#include "pci.h"
#include "wdmguid.h"
#include "zwapi.h"
#include "ntpoapi.h"

#include "agp.h"

//
// Device/Function/Bus numbers for the primary and secondary north bridges.
//
// "Primary" values are the same for RCC and Draco.
// "Secondary" values are only relevant on RCC HPSA machines.  
//      (By definition, if a northbridge exists at this location, then it is an HPSA machine.)
// 
#define PRIMARY_LE_BUS_ID              0
#define PRIMARY_HE_BUS_ID              0
#define SECONDARY_LE_BUS_ID            0

//
// PCI_SLOT_NUMBER type = ULONG == [XXXXXXXX XXXXXXXX XXXXXXXX YYYZZZZZ]
//
// Where X = reserved
//       Y = function number 0 - 7
//       Z = device number 0 - 255
//
#define MAKE_PCI_SLOT_NUMBER(dev, func) ((func << 5) + (dev))

#define PRIMARY_LE_HOST_DEVICE          0
#define PRIMARY_HE_HOST_DEVICE          0
#define PRIMARY_LE_HOST_FUNCTION        0
#define PRIMARY_LE_PCI_DEVICE           PRIMARY_LE_HOST_DEVICE
#define PRIMARY_LE_PCI_FUNCION          1
#define PRIMARY_HE_PCI_DEVICE           PRIMARY_HE_HOST_DEVICE
#define PRIMARY_HE_PCI_FUNCTION         1
#define SECONDARY_LE_HOST_DEVICE        17
#define SECONDARY_LE_HOST_FUNCTION      0
#define SECONDARY_LE_PCI_DEVICE         SECONDARY_LE_HOST_DEVICE      
#define SECONDARY_LE_PCI_FUNCION        1



#define PRIMARY_LE_HOSTPCI_SLOT_ID      MAKE_PCI_SLOT_NUMBER(PRIMARY_LE_HOST_DEVICE, PRIMARY_LE_HOST_FUNCTION)
#define PRIMARY_LE_PCIPCI_SLOT_ID       MAKE_PCI_SLOT_NUMBER(PRIMARY_LE_PCI_DEVICE, PRIMARY_LE_PCI_FUNCION)
#define PRIMARY_HE_PCIPCI_SLOT_ID       MAKE_PCI_SLOT_NUMBER(PRIMARY_HE_PCI_DEVICE, PRIMARY_HE_PCI_FUNCTION)
#define SECONDARY_LE_HOSTPCI_SLOT_ID    MAKE_PCI_SLOT_NUMBER(SECONDARY_LE_HOST_DEVICE, SECONDARY_LE_HOST_FUNCTION)
#define SECONDARY_LE_PCIPCI_SLOT_ID     MAKE_PCI_SLOT_NUMBER(SECONDARY_LE_PCI_DEVICE, SECONDARY_LE_PCI_FUNCION)


//
//
//
#define AGP_CPQ_BUS_ID          PRIMARY_LE_BUS_ID
#define AGP_CPQ_HOSTPCI_SLOT_ID PRIMARY_LE_HOSTPCI_SLOT_ID  
#define AGP_CPQ_PCIPCI_SLOT_ID  PRIMARY_LE_PCIPCI_SLOT_ID   

#define OFFSET_DEVICE_VENDOR_ID 0x00 
#define OFFSET_BAR0             0x10    // Base of AGP Device Address Space
#define OFFSET_BAR1             0x14    // Memory Mapped Control Registers Pointer
#define OFFSET_AP_SIZE          0x8C    // For the RCC chipsets.  Draco doesn't implement this.
#define OFFSET_REV_ID           0x08    // Silicon Revision ID (on RCC chipsets).
#define MAX_REV_ID_TO_LIMIT_1X  4       // Maximum Silicon Rev ID that has the 2X bug.
#define MAX_REV_ID_TO_FIX_RQ    5       // Macimum Silicon Rev ID that has the RQ bug.
#define OFFSET_SHADOW_BYTE      0x93    // Byte that contains the shaddow enable bit (bit 3).
#define FLAG_DISABLE_SHADOW     0x08
#define MASK_ENABLE_SHADOW      (~FLAG_DISABLE_SHADOW)

//
// RCC Vendor-Device IDs (as of August 1998):
//
// CNB_20_LE (function 0) -- 0x00071166
// CNB_20_LE (function 1) -- 0x00051166
// CNB_20_HE (function 0) -- 0x00081166 
// CNB_20_HE (function 1) -- 0x00091166
//
#define AGP_CNB20_LE_IDENTIFIER   0x00071166 // * function 0 ID.
#define AGP_CNB20_HE_IDENTIFIER   0x00081166 
#define AGP_CNB20_HE4X_IDENTIFIER 0x00131166
#define AGP_CMIC_GC_IDENTIFIER    0x00151166
#define AGP_DRACO_IDENTIFIER      0xAE6C0E11 // * Note, support for this chipset is no longer required.


#define AP_SIZE_DEFAULT         0x10000000 // all chipsets default to 256MB

#define AP_MAX_SIZE_CNB20_LE    0x80000000 // 2GB    
#define AP_MAX_SIZE_CNB20_HE    0x80000000 // 2GB  
 
#define AP_MAX_SIZE_DRACO       0x10000000 // 256MB

#define AP_SIZE_COUNT_CNB20_LE  7
#define AP_SIZE_COUNT_CNB20_HE  7
#define AP_SIZE_COUNT_DRACO     1

#define LOWEST_REVISION_ID_SUPPORTED        1

#define MAX_CACHED_ENTRIES_TO_INVALIDATE    3   

#define MASK_LOW_TWENTYFIVE             (~0x01FFFFFF)
#define ALL_ONES                        (~0x0)

//
// Conversions from BAR0 read/write-attribute-encoding to aperture sizes.
//
// 0x00000000 (b 0000 0000 ...) =    0MB
// 0xFE000000 (b 1111 1110 ...) =   32MB
// 0xFC000000 (b 1111 1100 ...) =   64MB
// 0xF8000000 (b 1111 1000 ...) =  128MB
// 0xF0000000 (b 1111 0000 ...) =  256MB
// 0xE0000000 (b 1110 0000 ...) =  512MB
// 0xC0000000 (b 1100 0000 ...) =    1GB
// 0x80000000 (b 1000 0000 ...) =    2GB

#define BAR0_CODED_AP_SIZE_0MB     0x00000000
#define BAR0_CODED_AP_SIZE_32MB    0xFE000000
#define BAR0_CODED_AP_SIZE_64MB    0xFC000000
#define BAR0_CODED_AP_SIZE_128MB   0xF8000000
#define BAR0_CODED_AP_SIZE_256MB   0xF0000000
#define BAR0_CODED_AP_SIZE_512MB   0xE0000000
#define BAR0_CODED_AP_SIZE_1GB     0xC0000000
#define BAR0_CODED_AP_SIZE_2GB     0x80000000

//
// Conversions from the values in bits 3:1 of the AGP Device 
// Address Space Size Register to aperture sizes.
//
// 0    (b 000)    =    32MB
// 1    (b 001)    =    64MB
// 2    (b 010)    =   128MB
// 3    (b 011)    =   256MB
// 4    (b 100)    =   512MB
// 5    (b 101)    =     1GB
// 6    (b 110)    =     2GB
// 7    (b 111)    ->   "Reserved"
//
#define SET_AP_SIZE_32MB     0
#define SET_AP_SIZE_64MB     1
#define SET_AP_SIZE_128MB    2
#define SET_AP_SIZE_256MB    3
#define SET_AP_SIZE_512MB    4
#define SET_AP_SIZE_1GB      5
#define SET_AP_SIZE_2GB      6

#define BYTES_2G    0x80000000UL  // 2G Value, to avoid integral const. overflow 

// 
// Taken from config.c
//
typedef struct _BUS_SLOT_ID {
    ULONG BusId;
    ULONG SlotId;
} BUS_SLOT_ID, *PBUS_SLOT_ID;

//
// Macros for reading and writing to the Host-PCI Bridge registers
//
#define ReadCPQConfig(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_CPQ_BUS_ID,           \
                                  AGP_CPQ_HOSTPCI_SLOT_ID,  \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define WriteCPQConfig(_buf_,_offset_,_size_)               \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_CPQ_BUS_ID,           \
                                  AGP_CPQ_HOSTPCI_SLOT_ID,  \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

//
// Macro to translate the APSIZE encoding into MB.
//
#define TranslateCodedValueIntoApSize(_apsize_, _value_)                         \
{                                                                              \
    _apsize_ = (((_value_ & MASK_LOW_TWENTYFIVE) ^ ALL_ONES) + 1);             \
}


//
// GART table entry.
//
typedef struct _GART_ENTRY_HW {
    ULONG Valid     :  1;
    ULONG Linked    :  1;
    ULONG Dirty     :  1;
    ULONG Rsrvd1    :  9;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;

typedef struct _GART_ENTRY_SW {
    ULONG State     : 5;
    ULONG Rsrvd1    : 27;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// GART Entry bits
//
#define GART_ENTRY_INVALID      0x00          // 00000
#define GART_ENTRY_VALID        0x01          // 00001
#define GART_ENTRY_LINKED       0x02          // 00010
#define GART_ENTRY_DIRTY        0x04          // 00100
#define GART_ENTRY_WC           0x08          // 01000
#define GART_ENTRY_UC           0x10          // 10000

//
// Defined GART Entry states. 
//
#define GART_ENTRY_FREE             GART_ENTRY_INVALID

#define GART_ENTRY_RESERVED_WC      GART_ENTRY_WC 
#define GART_ENTRY_RESERVED_UC      GART_ENTRY_UC 

#define GART_ENTRY_VALID_WC         (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC         (GART_ENTRY_VALID)

#define GART_ENTRY_VALID_WC_LINKED  (GART_ENTRY_VALID_WC | GART_ENTRY_LINKED)
#define GART_ENTRY_VALID_UC_LINKED  (GART_ENTRY_VALID_UC | GART_ENTRY_LINKED)

//
// Memory Mapped Control Registers.
//
typedef struct _GART_CACHE_ENTRY_CONTROL_REGISTER {
    ULONG   volatile GartEntryInvalidate:1;
    ULONG   volatile GartEntryUpdate:1;
    ULONG   Rsrvd1:10;
    ULONG   volatile GartEntryOffset:20;
} GART_CACHE_ENTRY_CONTROL_REGISTER, *PGART_CACHE_ENTRY_CONTROL_REGISTER;

typedef struct _GART_CACHE_ENTRY_CONTROL {
    union {
        GART_CACHE_ENTRY_CONTROL_REGISTER AsBits;
        ULONG   volatile AsDword;
    };
} GART_CACHE_ENTRY_CONTROL, *PGART_CACHE_ENTRY_CONTROL;

typedef struct _MM_CONTROL_REGS {
    UCHAR   RevisionID;
    struct  _GART_CAPABILITES {
        UCHAR   ValidBitErrorReportingSupported:1;
        UCHAR   LinkingSupported:1;
        UCHAR   TwoLevelAddrTransSupported:1;
        UCHAR   BusCountersSupported:1;
        UCHAR   Rsrvd1:4;
    } Capabilities;
    struct _GART_FEATURE_CONTROL {
        UCHAR   ValidBitErrorReportingEnable:1;
        UCHAR   LinkingEnable:1;
        UCHAR   Rsrvd1:1;
        UCHAR   GARTCacheEnable:1;
        UCHAR   Rsrvd2:4;
    } FeatureControl;
    struct _GART_FEATURE_STATUS {
        UCHAR   volatile ValidBitErrorDetected:1;
        UCHAR   Rsrvd1:7;
    } FeatureStatus;
    struct _GART_BASE_ADDRESS {
        ULONG   Rsrvd1:12;
        ULONG   Page:20;
    } GartBase;
    struct _GART_AND_DIR_CACHE_SIZES {
        ULONG   MaxTableEntries:16;
        ULONG   MaxDirEntries:16;
    } CacheSize;
    struct _GART_CACHE_CONTROL {
        ULONG   volatile GartAndDirCacheInvalidate:1;
        ULONG   Rsrvd1:31;
    } CacheControl;
    GART_CACHE_ENTRY_CONTROL CacheEntryControl;
    struct _POSTED_WRITE_BUFFER_CONTROL {
        UCHAR   volatile Flush:1;
        UCHAR   Rsrvd1:7;
    } PostedWriteBufferControl;
    struct _AGP_BUS_COUNTERS_COMMAND {
        UCHAR   volatile ClearCounters:1;
        UCHAR   EnableUtilization:1;
        UCHAR   EnableBandwidth:1;
        UCHAR   EnableLatency:1;
        UCHAR   Rsrvd1:4;
    } BusCounters;
    USHORT  Rsrvd1;
    ULONG   BusUtilizationCounter;
    ULONG   BusBandwidthCounter;
    ULONG   BusLatencyCounter;
} MM_CONTROL_REGS, *PMM_CONTROL_REGS;

typedef struct _AGP_DEVICE_ADDRESS_SPACE_SIZE_REG {
    UCHAR   Rsrvd1:4;
    UCHAR   ApSize:3;
    UCHAR   AgpValid:1;
} AGP_DAS_SIZE_REG, *PAGP_DAS_SIZE_REG;

typedef struct _AGP_AP_SIZE_REG {
    union {
        AGP_DAS_SIZE_REG    AsBits;
        UCHAR               AsByte;
    };
} AGP_AP_SIZE_REG, *PAGP_AP_SIZE_REG;

//
// Compaq-specific extension
//
typedef struct _AGPCPQ_EXTENSION {
    PMM_CONTROL_REGS    MMIO;
    PHYSICAL_ADDRESS    ApertureStart;
    ULONG               ApertureLength;
    PGART_PTE           Gart;
    PVOID               Dir;
    ULONG               GartLength;
    ULONG               MaxGartLength;
    ULONG               DeviceVendorID;
    ULONG               GartPointer;              
    BOOLEAN             IsHPSA;
    ULONGLONG           SpecialTarget;
} AGPCPQ_EXTENSION, *PAGPCPQ_EXTENSION;

//
// Taken from Config.c
//
extern
NTSTATUS
ApGetSetBusData(
    IN PBUS_SLOT_ID BusSlotId,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

extern
NTSTATUS 
DnbSetShadowBit(
    ULONG SetToOne
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib\agplib.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    agplib.h

Abstract:

    Private header file for the common AGP library

Author:

    John Vert (jvert) 10/22/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/
#include "agp.h"
#include "wdmguid.h"
#include "wmilib.h"
#include <devioctl.h>
#include <acpiioct.h>

//
// regstr.h uses things of type WORD, which isn't around in kernel mode.
//

#define _IN_KERNEL_

#include "regstr.h"

#define AGP_HACK_FLAG_SUBSYSTEM 0x01
#define AGP_HACK_FLAG_REVISION  0x02

typedef struct _AGP_HACK_TABLE_ENTRY {
    USHORT VendorID;
    USHORT DeviceID;
    USHORT SubVendorID;
    USHORT SubSystemID;
    ULONGLONG DeviceFlags;
    UCHAR   RevisionID;
    UCHAR   Flags;
} AGP_HACK_TABLE_ENTRY, *PAGP_HACK_TABLE_ENTRY;

extern PAGP_HACK_TABLE_ENTRY AgpDeviceHackTable;
extern PAGP_HACK_TABLE_ENTRY AgpGlobalHackTable;

typedef
ULONG_PTR
(*PCRITICALROUTINE)(
    IN PVOID Extension,
    IN PVOID Context
    );

typedef struct _AGP_CRITICAL_ROUTINE_CONTEXT {

    volatile LONG Gate;
    volatile LONG Barrier;

    PCRITICALROUTINE Routine;
    PVOID Extension;
    PVOID Context;

} AGP_CRITICAL_ROUTINE_CONTEXT, *PAGP_CRITICAL_ROUTINE_CONTEXT;

//
// Define common device extension
//
typedef enum _AGP_EXTENSION_TYPE {
    AgpTargetFilter,
    AgpMasterFilter
} AGP_EXTENSION_TYPE;

#define TARGET_SIG 'TpgA'
#define MASTER_SIG 'MpgA'

typedef struct _COMMON_EXTENSION {
    ULONG               Signature;
    BOOLEAN             Deleted;
    AGP_EXTENSION_TYPE  Type;
    PDEVICE_OBJECT      AttachedDevice;
    BUS_INTERFACE_STANDARD BusInterface;
} COMMON_EXTENSION, *PCOMMON_EXTENSION;

// Structures to maintain a list of "favored" memory ranges
// for AGP allocation.

typedef struct _AGP_MEMORY_RANGE
{
   PHYSICAL_ADDRESS Lower;
   PHYSICAL_ADDRESS Upper;
} AGP_MEMORY_RANGE, *PAGP_MEMORY_RANGE;

typedef struct _AGP_FAVORED_MEMORY
{
   ULONG NumRanges;
   PAGP_MEMORY_RANGE Ranges;
} AGP_FAVORED_MEMORY;

//
// WMI data types
//
#define AGP_WMI_STD_DATA_GUID \
    { 0x8c27fbed, 0x1c7b, 0x47e4, 0xa6, 0x49, 0x0e, 0x38, 0x9d, 0x3a, 0xda, 0x4f }

typedef struct _AGP_STD_DATA {
    PHYSICAL_ADDRESS   ApertureBase;
    ULONG              ApertureLength;
    ULONG              AgpStatus;
    ULONG              AgpCommand;
} AGP_STD_DATA, *PAGP_STD_DATA;

typedef struct _TARGET_EXTENSION {
    COMMON_EXTENSION            CommonExtension;
    PFAST_MUTEX                 Lock;
    struct _MASTER_EXTENSION    *ChildDevice;
    PCM_RESOURCE_LIST           Resources;
    PCM_RESOURCE_LIST           ResourcesTranslated;
    AGP_FAVORED_MEMORY          FavoredMemory;
    PHYSICAL_ADDRESS            GartBase;
    ULONG                       GartLengthInPages;
    PDEVICE_OBJECT              PDO;
    PDEVICE_OBJECT              Self;
    WMILIB_CONTEXT              WmiLibInfo;
    
    //
    // This must be last, d'oh!
    //
    ULONGLONG                   AgpContext;
} TARGET_EXTENSION, *PTARGET_EXTENSION;

typedef struct _MASTER_EXTENSION {
    COMMON_EXTENSION    CommonExtension;
    PTARGET_EXTENSION   Target;
    ULONG               Capabilities;
    ULONG               InterfaceCount;         // tracks the number of interfaces handed out
    ULONG               ReservedPages;          // tracks the number of pages reserved in the aperture
    BOOLEAN             StopPending;            // TRUE if we have seen a QUERY_STOP
    BOOLEAN             RemovePending;          // TRUE if we have seen a QUERY_REMOVE
    ULONG               DisableCount;           // non-zero if we are in a state where we cannot service requests
} MASTER_EXTENSION, *PMASTER_EXTENSION;

typedef struct _GLOBALS {
   
    // 
    // Path to the driver's Services Key in the registry
    //
    UNICODE_STRING RegistryPath;

    //
    // Cached target capability settings
    //
    ULONG AgpStatus;
    ULONG AgpCommand;

} GLOBALS;


extern GLOBALS Globals;

//
// The MBAT - used to retrieve "favored" memory ranges from
// the AGP northbridge via an ACPI BANK method
//

#include <pshpack1.h>

typedef struct _MBAT
{
   UCHAR TableVersion;
   UCHAR AgpBusNumber;
   UCHAR ValidEntryBitmap;
   AGP_MEMORY_RANGE DecodeRange[ANYSIZE_ARRAY];
} MBAT, *PMBAT;

#include <poppack.h>

#define MBAT_VERSION 1

#define MAX_MBAT_SIZE sizeof(MBAT) + ((sizeof(UCHAR) * 8) - ANYSIZE_ARRAY) \
                        * sizeof(AGP_MEMORY_RANGE)

#define CM_BANK_METHOD (ULONG)('KNAB')

//
// The highest memory address supported by AGP
//

#define MAX_MEM(_num_) _num_ = 1; \
                       _num_ = _num_*1024*1024*1024*4 - 1

#define RELEASE_BUS_INTERFACE(_ext_) (_ext_)->CommonExtension.BusInterface.InterfaceDereference((_ext_)->CommonExtension.BusInterface.Context)

//
// Macros for getting from the chipset-specific context to our structures
//
#define GET_TARGET_EXTENSION(_target_,_agp_context_)  (_target_) = (CONTAINING_RECORD((_agp_context_),    \
                                                                                      TARGET_EXTENSION,   \
                                                                                      AgpContext));       \
                                                      ASSERT_TARGET(_target_)
#define GET_MASTER_EXTENSION(_master_,_agp_context_)    {                                                       \
                                                            PTARGET_EXTENSION _targetext_;                      \
                                                            GET_TARGET_EXTENSION(_targetext_, (_agp_context_)); \
                                                            (_master_) = _targetext_->ChildDevice;              \
                                                            ASSERT_MASTER(_master_);                            \
                                                        }
#define GET_TARGET_PDO(_pdo_,_agp_context_) {                                                           \
                                                PTARGET_EXTENSION _targetext_;                          \
                                                GET_TARGET_EXTENSION(_targetext_,(_agp_context_));      \
                                                (_pdo_) = _targetext_->CommonExtension.AttachedDevice;  \
                                            }

#define GET_MASTER_PDO(_pdo_,_agp_context_) {                                                           \
                                                PMASTER_EXTENSION _masterext_;                          \
                                                GET_MASTER_EXTENSION(_masterext_, (_agp_context_));     \
                                                (_pdo_) = _masterext_->CommonExtension.AttachedDevice;  \
                                            }

#define GET_AGP_CONTEXT(_targetext_) ((PVOID)(&(_targetext_)->AgpContext))
#define GET_AGP_CONTEXT_FROM_MASTER(_masterext_) GET_AGP_CONTEXT((_masterext_)->Target)

//
// Some debugging macros
//
#define ASSERT_TARGET(_target_) ASSERT((_target_)->CommonExtension.Signature == TARGET_SIG); \
                                ASSERT((_target_)->ChildDevice->CommonExtension.Signature == MASTER_SIG)
#define ASSERT_MASTER(_master_) ASSERT((_master_)->CommonExtension.Signature == MASTER_SIG); \
                                ASSERT((_master_)->Target->CommonExtension.Signature == TARGET_SIG)

//
// Locking macros
//
#define LOCK_MUTEX(_fm_) ExAcquireFastMutex(_fm_); \
                         ASSERT((_fm_)->Count == 0)

#define UNLOCK_MUTEX(_fm_) ASSERT((_fm_)->Count == 0);  \
                           ExReleaseFastMutex(_fm_)

#define LOCK_TARGET(_targetext_) ASSERT_TARGET(_targetext_); \
                                 LOCK_MUTEX((_targetext_)->Lock)

#define LOCK_MASTER(_masterext_) ASSERT_MASTER(_masterext_); \
                                 LOCK_MUTEX((_masterext_)->Target->Lock)

#define UNLOCK_TARGET(_targetext_) ASSERT_TARGET(_targetext_); \
                                   UNLOCK_MUTEX((_targetext_)->Lock)

#define UNLOCK_MASTER(_masterext_) ASSERT_MASTER(_masterext_); \
                                   UNLOCK_MUTEX((_masterext_)->Target->Lock)

//
// Private resource type definition
//
typedef enum {
    AgpPrivateResource = '0PGA'
} AGP_PRIVATE_RESOURCE_TYPES;

//
// Define function prototypes
//

//
// Driver and device initialization - init.c
//
NTSTATUS
AgpAttachDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );


//
// IRP Dispatch routines - dispatch.c
//
NTSTATUS
AgpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
AgpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
AgpDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
AgpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
AgpSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

//
// Config space handling routines - config.c
//
NTSTATUS
ApQueryBusInterface(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PBUS_INTERFACE_STANDARD BusInterface
    );

//
// Resource handing routines - resource.c
//
NTSTATUS
AgpFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpQueryResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpStartTarget(
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

VOID
AgpStopTarget(
    IN PTARGET_EXTENSION Extension
    );

//
// AGP Interface functions
//
NTSTATUS
AgpInterfaceSetRate(
    IN PMASTER_EXTENSION Extension,
    IN ULONG AgpRate
    );

VOID
AgpInterfaceReference(
    IN PMASTER_EXTENSION Extension
    );

VOID
AgpInterfaceDereference(
    IN PMASTER_EXTENSION Extension
    );


NTSTATUS
AgpInterfaceReserveMemory(
    IN PMASTER_EXTENSION Extension,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    );

NTSTATUS
AgpInterfaceReleaseMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle
    );

NTSTATUS
AgpInterfaceCommitMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

NTSTATUS
AgpInterfaceFreeMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

NTSTATUS
AgpInterfaceGetMappedPages(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    );

//
// Misc utils.c
//
BOOLEAN
AgpOpenKey(
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    OUT PHANDLE Handle,
    OUT PNTSTATUS Status
    );

BOOLEAN
AgpStringToUSHORT(
    IN PWCHAR String,
    OUT PUSHORT Result
    );

ULONGLONG
AgpGetDeviceFlags(
    IN PAGP_HACK_TABLE_ENTRY AgpHackTable,
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN UCHAR  RevisionID
    );

ULONG_PTR
AgpExecuteCriticalSystemRoutine(
    IN ULONG_PTR Context
    );

//
// wmi.c
//
NTSTATUS
AgpSystemControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
AgpWmiRegistration(
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpWmiDeRegistration(
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
AgpSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
AgpQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    );

NTSTATUS
AgpQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    );

//
// AGP Physical Memory allocator
//
PMDL
AgpLibAllocatePhysicalMemory(
    IN PVOID AgpContext,
    IN ULONG TotalBytes);

//
// Handy structures for mucking about in PCI config space
//

//
// The PCI_COMMON_CONFIG includes the 192 bytes of device specific
// data.  The following structure is used to get only the first 64
// bytes which is all we care about most of the time anyway.  We cast
// to PCI_COMMON_CONFIG to get at the actual fields.
//

typedef struct {
    ULONG Reserved[PCI_COMMON_HDR_LENGTH/sizeof(ULONG)];
} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib\init.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Common initialization routine for the AGP filter driver

Author:

    John Vert (jvert) 10/22/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/
#include "agplib.h"

//
// Local function prototypes
//
NTSTATUS
AgpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
AgpBuildHackTable(
    IN OUT PAGP_HACK_TABLE_ENTRY *AgpHackTable,
    IN HANDLE HackTableKey
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
AgpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
AgpInitFavoredMemoryRanges(
   IN PTARGET_EXTENSION Extension);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpAddDevice)
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, AgpDriverUnload)
#pragma alloc_text(PAGE, AgpAttachDeviceRelations)
#pragma alloc_text(INIT, AgpBuildHackTable)
#pragma alloc_text(PAGE, AgpInitFavoredMemoryRanges)
#endif

ULONG AgpLogLevel = 0;
ULONG AgpStopLevel = 0;
PDRIVER_OBJECT AgpDriver;
GLOBALS Globals;

//
// Table of hacks for broken hardware read from the registry at init
//
PAGP_HACK_TABLE_ENTRY AgpDeviceHackTable = NULL;
PAGP_HACK_TABLE_ENTRY AgpGlobalHackTable = NULL;

#define HACKFMT_VENDORDEV         (sizeof(L"VVVVDDDD") - sizeof(UNICODE_NULL))
#define HACKFMT_VENDORDEVREVISION (sizeof(L"VVVVDDDDRR") - sizeof(UNICODE_NULL))
#define HACKFMT_SUBSYSTEM         (sizeof(L"VVVVDDDDSSSSssss") - sizeof(UNICODE_NULL))
#define HACKFMT_SUBSYSTEMREVISION (sizeof(L"VVVVDDDDSSSSssssRR") - sizeof(UNICODE_NULL))
#define HACKFMT_MAX_LENGTH        HACKFMT_SUBSYSTEMREVISION

#define HACKFMT_DEVICE_OFFSET     4
#define HACKFMT_SUBVENDOR_OFFSET  8
#define HACKFMT_SUBSYSTEM_OFFSET 12

NTSTATUS
AgpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
{
    NTSTATUS Status;
    PDEVICE_OBJECT Device;
    PTARGET_EXTENSION Extension;

    PAGED_CODE();

    //
    // Create our device
    //
    Status = IoCreateDevice(DriverObject,
                            sizeof(TARGET_EXTENSION)  + AgpExtensionSize - sizeof(ULONGLONG),
                            NULL,
                            FILE_DEVICE_BUS_EXTENDER,
                            FILE_DEVICE_SECURE_OPEN, // Not really necessary in our case as we don't support create
                            FALSE,
                            &Device);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,("AgpAddDevice: IoCreateDevice failed %08lx\n",Status));
        return(Status);
    }

    //
    // Initialize the device extension
    //
    Extension = Device->DeviceExtension;
    Extension->CommonExtension.Type = AgpTargetFilter;
    Extension->CommonExtension.Deleted = FALSE;
    Extension->CommonExtension.Signature = TARGET_SIG;
    Status = ApQueryBusInterface(PhysicalDeviceObject, &Extension->CommonExtension.BusInterface);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpAddDevice: query for bus interface failed %08lx\n", Status));
        IoDeleteDevice(Device);
        return(STATUS_NO_SUCH_DEVICE);
    }
    Extension->ChildDevice = NULL;
    Extension->Resources = NULL;
    Extension->ResourcesTranslated = NULL;
    Extension->FavoredMemory.NumRanges = 0;
    Extension->FavoredMemory.Ranges = NULL;
    Extension->GartBase.QuadPart = 0;
    Extension->GartLengthInPages = 0;
    Extension->Lock = ExAllocatePoolWithTag(NonPagedPool, sizeof(FAST_MUTEX), 'MFgA');
    if (Extension->Lock == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("AgpAddDevice: allocation of fast mutext failed\n"));
        RELEASE_BUS_INTERFACE(Extension);
        IoDeleteDevice(Device);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    ExInitializeFastMutex(Extension->Lock);

    //
    // Attach to the supplied PDO
    //
    Extension->CommonExtension.AttachedDevice = IoAttachDeviceToDeviceStack(Device, PhysicalDeviceObject);
    if (Extension->CommonExtension.AttachedDevice == NULL) {
        //
        // The attach failed.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpAddDevice: IoAttachDeviceToDeviceStack from %08lx to %08lx failed\n",
               Device,
               PhysicalDeviceObject));
        RELEASE_BUS_INTERFACE(Extension);
        IoDeleteDevice(Device);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Figure out our favored memory ranges
    //

    AgpInitFavoredMemoryRanges(Extension);

    //
    // Finally call the chipset-specific code for target initialization
    //
    Status = AgpInitializeTarget(GET_AGP_CONTEXT(Extension));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpAttachDeviceRelations: AgpInitializeTarget on device %08lx failed %08lx\n",
                Device,
                Status));
        IoDetachDevice(Extension->CommonExtension.AttachedDevice);
        RELEASE_BUS_INTERFACE(Extension);
        IoDeleteDevice(Device);
        return(Status);
    }

    Extension->PDO = PhysicalDeviceObject;
    Extension->Self = Device;

    Status = AgpWmiRegistration(Extension);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL, ("AgpWmiRegistration failed %08lx\n", Status));
        IoDetachDevice(Extension->CommonExtension.AttachedDevice);
        RELEASE_BUS_INTERFACE(Extension);
        IoDeleteDevice(Device);
        return Status;
    }

    Device->Flags &= ~DO_DEVICE_INITIALIZING;

    return(STATUS_SUCCESS);

}

NTSTATUS
AgpBuildHackTable(
    IN OUT PAGP_HACK_TABLE_ENTRY *AgpHackTable,
    IN HANDLE HackTableKey
    )
{

    NTSTATUS status;
    PKEY_FULL_INFORMATION keyInfo = NULL;
    ULONG hackCount, size, index;
    USHORT temp;
    PAGP_HACK_TABLE_ENTRY entry;
    ULONGLONG data;
    PKEY_VALUE_FULL_INFORMATION valueInfo = NULL;
    ULONG valueInfoSize = sizeof(KEY_VALUE_FULL_INFORMATION)
                          + HACKFMT_MAX_LENGTH +
                          + sizeof(ULONGLONG);

    //
    // Get the key info so we know how many hack values there are.
    // This does not change during system initialization.
    //

    status = ZwQueryKey(HackTableKey,
                        KeyFullInformation,
                        NULL,
                        0,
                        &size
                        );

    if (status != STATUS_BUFFER_TOO_SMALL) {
        ASSERT(!NT_SUCCESS(status));
        goto cleanup;
    }

    ASSERT(size > 0);

    keyInfo = ExAllocatePool(PagedPool, size);

    if (!keyInfo) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    status = ZwQueryKey(HackTableKey,
                        KeyFullInformation,
                        keyInfo,
                        size,
                        &size
                        );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    hackCount = keyInfo->Values;

    ExFreePool(keyInfo);
    keyInfo = NULL;

    //
    // Allocate and initialize the hack table
    //

    *AgpHackTable = ExAllocatePool(NonPagedPool,
                                  (hackCount + 1) * sizeof(AGP_HACK_TABLE_ENTRY)
                                  );

    if (!*AgpHackTable) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }


    //
    // Allocate a valueInfo buffer big enough for the biggest valid
    // format and a ULONGLONG worth of data.
    //

    valueInfo = ExAllocatePool(PagedPool, valueInfoSize);

    if (!valueInfo) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    entry = *AgpHackTable;

    for (index = 0; index < hackCount; index++) {

        status = ZwEnumerateValueKey(HackTableKey,
                                     index,
                                     KeyValueFullInformation,
                                     valueInfo,
                                     valueInfoSize,
                                     &size
                                     );

        if (!NT_SUCCESS(status)) {
            if (status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL) {
                //
                // All out data is of fixed length and the buffer is big enough
                // so this can't be for us.
                //

                continue;
            } else {
                goto cleanup;
            }
        }

        //
        // Get pointer to the data if its of the right type
        //

        if ((valueInfo->Type == REG_BINARY) &&
            (valueInfo->DataLength == sizeof(ULONGLONG))) {
            data = *(ULONGLONG UNALIGNED *)(((PUCHAR)valueInfo) + valueInfo->DataOffset);
        } else {
            //
            // We only deal in ULONGLONGs
            //

            continue;
        }

        //
        // Now see if the name is formatted like we expect it to be:
        // VVVVDDDD
        // VVVVDDDDRR
        // VVVVDDDDSSSSssss
        // VVVVDDDDSSSSssssRR

        if ((valueInfo->NameLength != HACKFMT_VENDORDEV) &&
            (valueInfo->NameLength != HACKFMT_VENDORDEVREVISION) &&
            (valueInfo->NameLength != HACKFMT_SUBSYSTEM) &&
            (valueInfo->NameLength != HACKFMT_SUBSYSTEMREVISION)) {

            //
            // This isn't ours
            //

            AGPLOG(
                AGP_CRITICAL,
                ("Skipping hack entry with invalid length name\n"
                 ));

            continue;
        }


        //
        // This looks plausable - try to parse it and fill in a hack table
        // entry
        //

        RtlZeroMemory(entry, sizeof(AGP_HACK_TABLE_ENTRY));

        //
        // Look for DeviceID and VendorID (VVVVDDDD)
        //

        if (!AgpStringToUSHORT(valueInfo->Name, &entry->VendorID)) {
            continue;
        }

        if (!AgpStringToUSHORT(valueInfo->Name + HACKFMT_DEVICE_OFFSET,
                               &entry->DeviceID)) {
            continue;
        }


        //
        // Look for SubsystemVendorID/SubSystemID (SSSSssss)
        //

        if ((valueInfo->NameLength == HACKFMT_SUBSYSTEM) ||
            (valueInfo->NameLength == HACKFMT_SUBSYSTEMREVISION)) {

            if (!AgpStringToUSHORT(valueInfo->Name + HACKFMT_SUBVENDOR_OFFSET,
                                   &entry->SubVendorID)) {
                continue;
            }

            if (!AgpStringToUSHORT(valueInfo->Name + HACKFMT_SUBSYSTEM_OFFSET,
                                   &entry->SubSystemID)) {
                continue;
            }

            entry->Flags |= AGP_HACK_FLAG_SUBSYSTEM;
        }

        //
        // Look for RevisionID (RR)
        //

        if ((valueInfo->NameLength == HACKFMT_VENDORDEVREVISION) ||
            (valueInfo->NameLength == HACKFMT_SUBSYSTEMREVISION)) {
            if (AgpStringToUSHORT(valueInfo->Name +
                                  (valueInfo->NameLength/sizeof(WCHAR) - 4), &temp)) {
                entry->RevisionID = temp & 0xFF;
                entry->Flags |= AGP_HACK_FLAG_REVISION;
            } else {
                continue;
            }
        }

        ASSERT(entry->VendorID != 0xFFFF);

        //
        // Fill in the entry
        //

        entry->DeviceFlags = data;

        AGPLOG(
            AGP_CRITICAL,
            ("Adding Hack entry for Vendor:0x%04x Device:0x%04x ",
            entry->VendorID, entry->DeviceID
            ));

        if (entry->Flags & AGP_HACK_FLAG_SUBSYSTEM) {
            AGPLOG(
                AGP_CRITICAL,
                ("SybSys:0x%04x SubVendor:0x%04x ",
                 entry->SubSystemID, entry->SubVendorID
                 ));
        }

        if (entry->Flags & AGP_HACK_FLAG_REVISION) {
            AGPLOG(
                AGP_CRITICAL,
                ("Revision:0x%02x",
                 (ULONG) entry->RevisionID
                 ));
        }

        AGPLOG(
            AGP_CRITICAL,
            (" = 0x%I64x\n",
             entry->DeviceFlags
             ));

        entry++;
    }

    ASSERT(entry < (*AgpHackTable + hackCount + 1));

    //
    // Terminate the table with an invalid VendorID
    //

    entry->VendorID = 0xFFFF;

    ExFreePool(valueInfo);

    return STATUS_SUCCESS;

cleanup:

    ASSERT(!NT_SUCCESS(status));

    if (keyInfo) {
        ExFreePool(keyInfo);
    }

    if (valueInfo) {
        ExFreePool(valueInfo);
    }

    if (*AgpHackTable) {
        ExFreePool(*AgpHackTable);
        *AgpHackTable = NULL;
    }

    return status;

}


VOID
AgpInitFavoredMemoryRanges(
   IN PTARGET_EXTENSION Extension)
/*++

Routine Description:

    Determines the optimum memory ranges for AGP physical memory
    allocation by calling the ACPI BANK method provided by the
    AGP northbridge in order to determine which physical memory
    ranges are decoded by that northbridge.

    Initializes the FavoredMemory sturcture in the target extension
    with the proper ranges.

    If this routine fails, then the FavoredMemory structure
    is left untouched in its initialized state (i.e. no favored memory
    ranges found).

Arguments:

    Extension - The target extension.


Return Value:

    NONE. Upon failure,

--*/

{
   PDEVICE_OBJECT LowerPdo;
   IO_STATUS_BLOCK IoStatus;
   PIRP Irp;
   KEVENT event;
   NTSTATUS Status;
   ACPI_EVAL_INPUT_BUFFER inputBuffer;
   UCHAR ResultBuffer[sizeof(ACPI_EVAL_OUTPUT_BUFFER) + MAX_MBAT_SIZE];
   PACPI_EVAL_OUTPUT_BUFFER outputBuffer;
   PACPI_METHOD_ARGUMENT MethodArg;
   PMBAT Mbat;
   UCHAR i;
   USHORT j;
   PHYSICAL_ADDRESS MaxMemory;

   //
   // Maximum memory address for limiting AGP memory to below 4GB
   //

   MAX_MEM(MaxMemory.QuadPart);

   //
   // Get an event to wait on
   //

   KeInitializeEvent(&event, NotificationEvent, FALSE);

   // Get a PDO where we will send the request IRP.

   LowerPdo = Extension->CommonExtension.AttachedDevice;

   //
   // Initialize the input parameters and the output buffer.
   //
   RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
   inputBuffer.MethodNameAsUlong = CM_BANK_METHOD;
   inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
   outputBuffer = (PACPI_EVAL_OUTPUT_BUFFER)ResultBuffer;

   //
   // Build the request to call the BANK method.
   //
   Irp = IoBuildDeviceIoControlRequest(
        IOCTL_ACPI_EVAL_METHOD,
        LowerPdo,
        &inputBuffer,
        sizeof(ACPI_EVAL_INPUT_BUFFER),
        outputBuffer,
        sizeof(ResultBuffer),
        FALSE,
        &event,
        &IoStatus
        );

   if (!Irp)
   {
      return;
   }

   //
   // Send to the ACPI driver
   //
   Status = IoCallDriver ( LowerPdo, Irp);
   if (Status == STATUS_PENDING)
   {
         KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL);
         Status = IoStatus.Status;
   }

   if (NT_SUCCESS(Status))
   {
      AGPLOG(AGP_NOISE, ("AGPLIB: ACPI BANK Method Executed.\n"));

      //
      // Sanity check method results
      //

      MethodArg = outputBuffer->Argument;
      if ((outputBuffer->Signature == ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE) &&
          (MethodArg->DataLength >= sizeof(MBAT)) &&
          (MethodArg->Type == ACPI_METHOD_ARGUMENT_BUFFER))
      {

         AGPLOG(AGP_NOISE, ("AGPLIB: MBAT appears valid.\n"));

         //
         // Grab the MBAT and see if we can parse it
         //

         Mbat = (PMBAT)MethodArg->Data;

         if (Mbat->TableVersion == MBAT_VERSION) {
            AGPLOG(AGP_NOISE, ("AGPLIB: Parsing MBAT.\n"));

             //
             // Calculate the number of favored ranges mentioned
             // in the MBAT
             //

             i=Mbat->ValidEntryBitmap;
             while(i)
             {
                Extension->FavoredMemory.NumRanges++;
                i = i & (i-1);
             }

             AGPLOG(AGP_NOISE, ("AGPLIB: %u favored ranges found.\n",
                      Extension->FavoredMemory.NumRanges));

             if(Extension->FavoredMemory.NumRanges == 0) return;

             //
             // Allocate the favored memory range structure in our device
             // extension
             //

             Extension->FavoredMemory.Ranges =
                ExAllocatePool(NonPagedPool, sizeof(AGP_MEMORY_RANGE) *
                               Extension->FavoredMemory.NumRanges);

             if (Extension->FavoredMemory.Ranges == NULL) {
                Extension->FavoredMemory.NumRanges = 0;
                return;
             }


             //
             // Initialize the favored memory ranges in our extension
             // based upon the MBAT
             //

             i=0;
             j=0;
             while(Mbat->ValidEntryBitmap)
             {
                if (Mbat->ValidEntryBitmap & 1)
                {
                   if (Mbat->DecodeRange[i].Lower.QuadPart > MaxMemory.QuadPart) {
                      // This range is invalid since its lower address is above
                      // the highest allowable address

                      AGPLOG(AGP_NOISE, ("AGPLIB: Invalid MBAT Range ==> %I64x - %I64x\n",
                               Mbat->DecodeRange[i].Lower.QuadPart,
                               Mbat->DecodeRange[i].Upper.QuadPart));

                      // Pretend like this range never existed ...
                      //

                      Extension->FavoredMemory.NumRanges--;

                   }
                   else
                   {

                     // This is a valid range.

                     Extension->FavoredMemory.Ranges[j].Lower.QuadPart =
                         Mbat->DecodeRange[i].Lower.QuadPart;
                     Extension->FavoredMemory.Ranges[j].Upper.QuadPart =
                         Mbat->DecodeRange[i].Upper.QuadPart;


                     AGPLOG(AGP_NOISE, ("AGPLIB: MBAT Range ==> %I64x - %I64x\n",
                              Mbat->DecodeRange[i].Lower.QuadPart,
                              Mbat->DecodeRange[i].Upper.QuadPart));

                     if(Extension->FavoredMemory.Ranges[j].Upper.QuadPart >
                        MaxMemory.QuadPart)
                     {
                        AGPLOG(AGP_NOISE, ("AGPLIB: Adjusting range to fit within maximum allowable address.\n"));
                        Extension->FavoredMemory.Ranges[j].Upper.QuadPart =
                           MaxMemory.QuadPart;
                     }

                     j++;
                   }
                }
                Mbat->ValidEntryBitmap >>= 1;
                i++;
             }

         } else {

            AGPLOG(AGP_WARNING, ("AGPLIB: Unknown MBAT version.\n"));

         }

}


    }
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Entrypoint needed to initialize the AGP filter.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - Pointer to the unicode registry service path.

Return Value:

    NT status.

--*/

{
    NTSTATUS Status;
    HANDLE serviceKey, paramsKey;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES attributes;

    PAGED_CODE();

    //
    // Save the RegistryPath for WMI
    //
    Globals.RegistryPath.MaximumLength =
        RegistryPath->Length + sizeof(UNICODE_NULL);

    Globals.RegistryPath.Length = RegistryPath->Length;

    Globals.RegistryPath.Buffer =
        ExAllocatePoolWithTag(PagedPool,
                              Globals.RegistryPath.MaximumLength,
                              'GpgA'
                              );    

    if (!Globals.RegistryPath.Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
   
    RtlCopyUnicodeString(&Globals.RegistryPath, RegistryPath);

    AgpDriver = DriverObject;

    DriverObject->DriverExtension->AddDevice = AgpAddDevice;
    DriverObject->DriverUnload               = AgpDriverUnload;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = AgpDispatchDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = AgpDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = AgpDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = AgpDispatchWmi;

    RtlInitUnicodeString(&UnicodeString,
                         L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\"
                         L"Control");

    //
    // Open the global hack key and retrieve the gloabl hack table
    //
    InitializeObjectAttributes(&attributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    Status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &attributes
                       );

    //
    // We must succeed here, there are devices that can freeze a system,
    // and something is really wrong if we can't access these values
    //
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    AgpOpenKey(L"AGP", serviceKey, &paramsKey, &Status);

    ZwClose(serviceKey);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = AgpBuildHackTable(&AgpGlobalHackTable, paramsKey);

    ZwClose(paramsKey);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Open our service key and retrieve any platform hack(s)
    //
    InitializeObjectAttributes(&attributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    Status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &attributes
                       );

    //
    // Maybe their chipset is so burly, it doesn't require any hacks!
    //
    if (!NT_SUCCESS(Status)) {
        return STATUS_SUCCESS;
    }

    AgpOpenKey(L"Parameters", serviceKey, &paramsKey, &Status);

    ZwClose(serviceKey);

    //
    // Don't care
    //
    if (!NT_SUCCESS(Status)) {
        return STATUS_SUCCESS;
    }

    //
    // Again, disregard status
    //
    AgpBuildHackTable(&AgpDeviceHackTable, paramsKey);

    ZwClose(paramsKey);

    return STATUS_SUCCESS;
}



VOID
AgpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Entrypoint used to unload the AGP driver

Arguments:

    DriverObject - Pointer to the driver object created by the system

Return Value:

    None

--*/
{
    if (AgpDeviceHackTable != NULL) {
        ExFreePool(AgpDeviceHackTable);
        AgpDeviceHackTable = NULL;
    }

    if (AgpGlobalHackTable != NULL) {
        ExFreePool(AgpGlobalHackTable);
        AgpGlobalHackTable = NULL;
    }

    if (Globals.RegistryPath.Buffer != NULL) {
        ExFreePool(Globals.RegistryPath.Buffer);
        Globals.RegistryPath.Buffer = NULL; 
    }
}



NTSTATUS
AgpAttachDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for BusRelations IRP_MN_QUERY_DEVICE_RELATIONS irps sent
    to the PCI-PCI bridge PDO.  In order to handle QUERY_INTERFACE irps sent
    from the AGP device, we must attach to its PDO.  That means we attach to
    all the child PDOs of the PCI-PCI bridge.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_DEVICE_RELATIONS irp

    Extension - Supplies the AGP device extension.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    PDEVICE_RELATIONS Relations;
    ULONG i;
    PDEVICE_OBJECT NewDevice;
    PMASTER_EXTENSION NewExtension;
    AGP_CRITICAL_ROUTINE_CONTEXT routineContext;
#if DBG
    ULONG MasterCount=0;
#endif

    PAGED_CODE();

    //
    // If we have already attached, don't do it again.
    //
    if (Extension->ChildDevice != NULL) {
        return(STATUS_SUCCESS);
    }

    Relations = (PDEVICE_RELATIONS)Irp->IoStatus.Information;
    //
    // If somebody completed the IRP with success, but never
    // filled in the Relations field, then assume there are
    // no children and we don't have to do anything.
    //
    if (Relations == NULL) {
        return(STATUS_SUCCESS);
    }

    for (i=0; i<Relations->Count; i++) {

        //
        // Create a device object to attach to this PDO.
        //
        Status = IoCreateDevice(AgpDriver,
                                sizeof(MASTER_EXTENSION),
                                NULL,
                                FILE_DEVICE_BUS_EXTENDER,
                                0,
                                FALSE,
                                &NewDevice);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,("AgpAttachDeviceRelations: IoCreateDevice failed %08lx\n",Status));
            continue;
        }

        //
        // Initialize the device extension
        //

        NewExtension = NewDevice->DeviceExtension;
        NewExtension->CommonExtension.Deleted = FALSE;
        NewExtension->CommonExtension.Type = AgpMasterFilter;
        NewExtension->CommonExtension.Signature = MASTER_SIG;
        Status = ApQueryBusInterface(Relations->Objects[i], &NewExtension->CommonExtension.BusInterface);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpAttachDeviceRelations: query for bus interface failed %08lx\n", Status));
            IoDeleteDevice(NewDevice);
            continue;
        }
        NewExtension->Target = Extension;
        NewExtension->InterfaceCount = 0;
        NewExtension->ReservedPages = 0;
        NewExtension->StopPending = FALSE;
        NewExtension->RemovePending = FALSE;
        NewExtension->DisableCount = 1;         // biased so that we don't give anything out
                                                // until we see the IRP_MN_START
        Extension->ChildDevice = NewExtension;

        //
        // Attach to the specified device
        //
        NewExtension->CommonExtension.AttachedDevice = IoAttachDeviceToDeviceStack(NewDevice, Relations->Objects[i]);
        if (NewExtension->CommonExtension.AttachedDevice == NULL) {
            //
            // The attach failed. Not really fatal, AGP just won't work for that device.
            //
            AGPLOG(AGP_CRITICAL,
                   ("AgpAttachDeviceRelations: IoAttachDeviceToDeviceStack from %08lx to %08lx failed\n",
                   NewDevice,
                   Relations->Objects[i]));
            RELEASE_BUS_INTERFACE(NewExtension);
            IoDeleteDevice(NewDevice);
            Extension->ChildDevice = NULL;
            continue;
        }

        //
        // Propagate the PDO's requirements
        //
        NewDevice->StackSize = NewExtension->CommonExtension.AttachedDevice->StackSize + 1;
        NewDevice->AlignmentRequirement = NewExtension->CommonExtension.AttachedDevice->AlignmentRequirement;
        if (NewExtension->CommonExtension.AttachedDevice->Flags & DO_POWER_PAGABLE) {
            NewDevice->Flags |= DO_POWER_PAGABLE;
        }

        //
        // Finally call the chipset-specific code for master initialization
        //
        routineContext.Gate = 1;
        routineContext.Barrier = 1;
        routineContext.Routine = (PCRITICALROUTINE)AgpInitializeMaster;
        routineContext.Extension = GET_AGP_CONTEXT(Extension);
        routineContext.Context = &NewExtension->Capabilities;
        Status = (NTSTATUS)KeIpiGenericCall(AgpExecuteCriticalSystemRoutine,
                                            (ULONG_PTR)&routineContext
                                            );
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpAttachDeviceRelations: AgpInitializeMaster on device %08lx failed %08lx\n",
                    NewDevice,
                    Status));
            IoDetachDevice(NewExtension->CommonExtension.AttachedDevice);
            RELEASE_BUS_INTERFACE(NewExtension);
            IoDeleteDevice(NewDevice);
            Extension->ChildDevice = NULL;
            continue;
        }
        NewDevice->Flags &= ~DO_DEVICE_INITIALIZING;

//
// We can't do this if DBG because looping through here to catch/ASSERT
// multiple AGP masters will *always* screw up our target context
//
#if 0
        //
        // Check to make sure there is only one AGP master on the bus. There can be more
        // than one device (multifunction device) but only one must have AGP capabilities
        //
        MasterCount++;
        ASSERT(MasterCount == 1);
#else
        break;
#endif

    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib\config.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    config.c

Abstract:

    Routines for accessing config space in the PCI-PCI bridge

Author:

    John Vert (jvert) 10/27/1997

Revision History:

--*/
#include "agplib.h"

typedef struct _BUS_SLOT_ID {
    ULONG BusId;
    ULONG SlotId;
} BUS_SLOT_ID, *PBUS_SLOT_ID;

//
// Local function prototypes
//
NTSTATUS
ApGetSetDeviceBusData(
    IN PCOMMON_EXTENSION Extension,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
ApGetSetBusData(
    IN PBUS_SLOT_ID BusSlotId,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
ApFindAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability,
    OUT UCHAR *pOffset,
    OUT PPCI_COMMON_CONFIG PciCommonConfig OPTIONAL
    );


NTSTATUS
ApQueryBusInterface(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PBUS_INTERFACE_STANDARD BusInterface
    )
/*++

Routine Description:

    Sends a query-interface IRP to the specified device object
    to obtain the BUS_INTERFACE_STANDARD interface.

Arguments:

    DeviceObject - Supplies the device object to send the BUS_INTERFACE_STANDARD to

    BusInterface - Returns the bus interface

Return Value:

    STATUS_SUCCESS if successful
    NTSTATUS if unsuccessful

--*/

{
    PIRP Irp;
    KEVENT Event;
    PIO_STACK_LOCATION IrpSp;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    ULONG ReturnLength;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    Irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        &Event,
                                        &IoStatusBlock );
    if (Irp == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IrpSp = IoGetNextIrpStackLocation( Irp );
    ASSERT(IrpSp != NULL);
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
    IrpSp->MajorFunction = IRP_MJ_PNP;
    IrpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
    IrpSp->Parameters.QueryInterface.InterfaceType = (LPGUID)&GUID_BUS_INTERFACE_STANDARD;
    IrpSp->Parameters.QueryInterface.Size = sizeof(BUS_INTERFACE_STANDARD);
    IrpSp->Parameters.QueryInterface.Version = 1;
    IrpSp->Parameters.QueryInterface.Interface = (PINTERFACE) BusInterface;
    IrpSp->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    Status = IoCallDriver(DeviceObject, Irp);
    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
        Status = Irp->IoStatus.Status;
    }

    return(Status);
}


NTSTATUS
ApGetSetDeviceBusData(
    IN PCOMMON_EXTENSION Extension,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Reads or writes PCI config space for the specified device.

Arguments:

    Extension - Supplies the common AGP extension

    Read - if TRUE, this is a READ IRP
           if FALSE, this is a WRITE IRP

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    ULONG ReturnLength;
    ULONG Transferred;

    //
    // First check our device extension. This must be either a master
    // or target extension, we don't care too much which.
    //
    ASSERT((Extension->Signature == TARGET_SIG) ||
           (Extension->Signature == MASTER_SIG));

    //
    // Now we simply use our bus interface to call directly to PCI.
    //

    if (Read) {
        Transferred = Extension->BusInterface.GetBusData(Extension->BusInterface.Context,
                                                         PCI_WHICHSPACE_CONFIG,
                                                         Buffer,
                                                         Offset,
                                                         Length);
    } else {
        Transferred = Extension->BusInterface.SetBusData(Extension->BusInterface.Context,
                                                         PCI_WHICHSPACE_CONFIG,
                                                         Buffer,
                                                         Offset,
                                                         Length);
    }
    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}

#ifdef AGP3

NTSTATUS
AgpLibReadAgpDeviceConfig(
    IN PVOID AgpExtension,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Size
    );
/*++

Routine Description:

    Read PCI config space for the specified device

Arguments:

    Extension - Supplies the common AGP extension

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read
             should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/
{
    return ApGetSetDeviceBusData(AgpExtension,
                                 TRUE,
                                 Buffer,
                                 Offset,
                                 Size
                                 );
}



NTSTATUS
AgpLibWriteAgpDeviceConfig(
    IN PVOID AgpExtension,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Size
    )
/*++

Routine Description:

    Write PCI config space for the specified AGP device

Arguments:

    Extension - Supplies the common AGP extension

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the write
             should begin

    Length - Supplies the number of bytes to be write

Return Value:

    NTSTATUS

--*/
{
    return ApGetSetDeviceBusData(AgpExtension,
                                 FALSE,
                                 Buffer,
                                 Offset,
                                 Size
                                 );
}

#else // AGP3


NTSTATUS
ApGetSetBusData(
    IN PBUS_SLOT_ID BusSlotId,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Calls HalGet/SetBusData for the specified PCI bus/slot ID.

Arguments:

    BusSlotId - Supplies the bus and slot ID.

    Read - if TRUE, this is a GetBusData
           if FALSE, this is a SetBusData

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    ULONG Transferred;

    if (Read) {
        Transferred = HalGetBusDataByOffset(PCIConfiguration,
                                            BusSlotId->BusId,
                                            BusSlotId->SlotId,
                                            Buffer,
                                            Offset,
                                            Length);
    } else {
        Transferred = HalSetBusDataByOffset(PCIConfiguration,
                                            BusSlotId->BusId,
                                            BusSlotId->SlotId,
                                            Buffer,
                                            Offset,
                                            Length);

    }
    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}
#endif // AGP3


NTSTATUS
ApFindAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability,
    OUT UCHAR *pOffset,
    OUT PPCI_COMMON_CONFIG PciCommonConfig OPTIONAL
    )
/*++

Routine Description:

    Finds the capability offset for the specified device and
    reads in the header.

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the AGP Capabilities common header

    pOffset - Returns the offset into config space.

    PciCommonConfig - NULL, or points to the PCI common configuration header

Return Value:

    NTSTATUS

--*/

{
    PCI_COMMON_HEADER Header;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    //
    // Read the PCI common header to get the capabilities pointer
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         PciConfig,
                         0,
                         sizeof(PCI_COMMON_HEADER));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - read PCI Config space for Context %08lx failed %08lx\n",
                Context,
                Status));
        return(Status);
    }

    //
    // Check the Status register to see if this device supports capability lists.
    // If not, it is not an AGP-compliant device.
    //
    if ((PciConfig->Status & PCI_STATUS_CAPABILITIES_LIST) == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - Context %08lx does not support Capabilities list, not an AGP device\n",
                Context));
        return(STATUS_NOT_IMPLEMENTED);
    }

    //
    // The device supports capability lists, find the AGP capabilities
    //
    if ((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_BRIDGE_TYPE) {
        CapabilityOffset = PciConfig->u.type1.CapabilitiesPtr;
    } else {
        ASSERT((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_DEVICE_TYPE);
        CapabilityOffset = PciConfig->u.type0.CapabilitiesPtr;
    }
    while (CapabilityOffset != 0) {

        //
        // Read the Capability at this offset
        //
        Status = (pConfigFn)(Context,
                             TRUE,
                             Capability,
                             CapabilityOffset,
                             sizeof(PCI_CAPABILITIES_HEADER));
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpLibGetAgpCapability - read PCI Capability at offset %x for Context %08lx failed %08lx\n",
                    CapabilityOffset,
                    Context,
                    Status));
            return(Status);
        }
        if (Capability->Header.CapabilityID == PCI_CAPABILITY_ID_AGP) {
            //
            // Found the AGP Capability
            //
            break;
        } else {
            //
            // This is some other Capability, keep looking for the AGP Capability
            //
            CapabilityOffset = Capability->Header.Next;
        }
    }
    if (CapabilityOffset == 0) {
        //
        // No AGP capability was found
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - Context %08lx does have an AGP Capability entry, not an AGP device\n",
                Context));
        return(STATUS_NOT_IMPLEMENTED);
    }

    AGPLOG(AGP_NOISE,
           ("AgpLibGetAgpCapability - Context %08lx has AGP Capability at offset %x\n",
            Context,
            CapabilityOffset));

    *pOffset = CapabilityOffset;

    if (PciCommonConfig) {
        RtlCopyMemory(PciCommonConfig, PciConfig, sizeof(PCI_COMMON_HEADER));
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN BOOLEAN DoSpecial,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    DoSpecial - Indicates whether we should apply any "pecial" tweaks

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    ULONGLONG DeviceFlags;
    UCHAR CapabilityOffset;
    PCI_COMMON_HEADER Header;
    USHORT SubVendorID, SubSystemID;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
 
    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset,
                                 PciConfig);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Read the rest of the AGP capability
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         &Capability->Header + 1,
                         CapabilityOffset + sizeof(PCI_CAPABILITIES_HEADER),
                         sizeof(PCI_AGP_CAPABILITY) - sizeof(PCI_CAPABILITIES_HEADER));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - read AGP Capability at offset %x for Context %08lx failed %08lx\n",
                CapabilityOffset,
                Context,
                Status));
        return(Status);
    }

    //
    // Check device flags for broken HW, we may need to tweak caps
    //
    if ((PCI_CONFIGURATION_TYPE(PciConfig) == PCI_DEVICE_TYPE) &&
        (PciConfig->BaseClass != PCI_CLASS_BRIDGE_DEV)) {
        SubVendorID = PciConfig->u.type0.SubVendorID;
        SubSystemID = PciConfig->u.type0.SubSystemID;
    } else {
        SubVendorID = 0;
        SubSystemID = 0;
    }
    
    DeviceFlags = AgpGetDeviceFlags(AgpGlobalHackTable,
                                    PciConfig->VendorID,
                                    PciConfig->DeviceID,
                                    SubVendorID,
                                    SubSystemID,
                                    PciConfig->RevisionID);

    DeviceFlags |= AgpGetDeviceFlags(AgpDeviceHackTable,
                                     PciConfig->VendorID,
                                     PciConfig->DeviceID,
                                     SubVendorID,
                                     SubSystemID,
                                     PciConfig->RevisionID);
    
    if (DeviceFlags & AGP_FLAG_NO_1X_RATE) {
        Capability->AGPStatus.Rate &= ~PCI_AGP_RATE_1X;
        
        AGPLOG(AGP_WARNING,
               ("AGP HAMMER CAPS: NO_1X_RATE Vendor %x, Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }
    
    if (DeviceFlags & AGP_FLAG_NO_2X_RATE) {
        Capability->AGPStatus.Rate &= ~PCI_AGP_RATE_2X;
        
        AGPLOG(AGP_WARNING,
               ("AGP HAMMER CAPS: NO_2X_RATE Vendor %x, Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }
    
    if (DeviceFlags & AGP_FLAG_NO_4X_RATE) {
        Capability->AGPStatus.Rate &= ~PCI_AGP_RATE_4X;
        
        AGPLOG(AGP_WARNING,
               ("AGP HAMMER CAPS: NO_4X_RATE Vendor %x, Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }
    
    if (DeviceFlags & AGP_FLAG_NO_8X_RATE) {
        Capability->AGPStatus.Rate &= ~8;
        
        AGPLOG(AGP_WARNING,
               ("AGP HAMMER CAPS: NO_8X_RATE Vendor %x, Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }
    
    if (DeviceFlags & AGP_FLAG_NO_SBA_ENABLE) {
        Capability->AGPStatus.SideBandAddressing = 0;
        
        AGPLOG(AGP_WARNING,
               ("AGP HAMMER CAPS: NO_SBA_ENABLE Vendor %x, Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }
    
    if (DeviceFlags & AGP_FLAG_REVERSE_INITIALIZATION) {
        
        AGPLOG(AGP_WARNING,
               ("AGP GLOBAL HACK: REVERSE_INITIALIZATION Vendor %x, "
                "Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }

    //
    // Test if this device requires any platform specific AGP tweaks
    //
    if (DoSpecial && (DeviceFlags > AGP_FLAG_SPECIAL_TARGET) ||
        (DeviceFlags & AGP_FLAG_REVERSE_INITIALIZATION)) {
        AgpSpecialTarget(GET_AGP_CONTEXT_FROM_MASTER((PMASTER_EXTENSION)Context), ((DeviceFlags & ~AGP_FLAG_SPECIAL_TARGET) | (DeviceFlags & AGP_FLAG_REVERSE_INITIALIZATION)));
    }
    
    AGPLOG(AGP_NOISE,
           ("AGP CAPABILITY: version %d.%d\n",Capability->Major, Capability->Minor));
    AGPLOG(AGP_NOISE,
           ("\tSTATUS  - Rate: %x  SBA: %x  RQ: %02x\n",
           Capability->AGPStatus.Rate,
           Capability->AGPStatus.SideBandAddressing,
           Capability->AGPStatus.RequestQueueDepthMaximum));
    AGPLOG(AGP_NOISE,
           ("\tCOMMAND - Rate: %x  SBA: %x  RQ: %02x  AGPEnable: %x\n",
           Capability->AGPCommand.Rate,
           Capability->AGPCommand.SBAEnable,
           Capability->AGPCommand.RequestQueueDepth,
           Capability->AGPCommand.AGPEnable));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetTargetCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the AGP target (AGP bridge)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    PTARGET_EXTENSION Extension;

    GET_TARGET_EXTENSION(Extension, AgpExtension);

    Status = AgpLibGetAgpCapability(ApGetSetDeviceBusData,
                                    Extension,
                                    FALSE,
                                    Capability);

    if (NT_SUCCESS(Status)) {
        Globals.AgpStatus = *(PULONG)&Capability->AGPStatus;
    }

    return Status;
}


NTSTATUS
AgpLibGetMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    PMASTER_EXTENSION Extension;

    GET_MASTER_EXTENSION(Extension, AgpExtension);

    return(AgpLibGetAgpCapability(ApGetSetDeviceBusData,
                                  Extension,
                                  TRUE,
                                  Capability));
}

#ifndef AGP3

NTSTATUS
AgpLibGetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the specified PCI slot.

    Caller is responsible for figuring out what the correct
    Bus/Slot ID is. These are just passed right to HalGetBusData.

Arguments:

    BusId - supplies the bus id

    SlotId - Supplies the slot id

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    BUS_SLOT_ID BusSlotId;

    BusSlotId.BusId = BusId;
    BusSlotId.SlotId = SlotId;

    Status = AgpLibGetAgpCapability(ApGetSetBusData,
                                    &BusSlotId,
                                    FALSE,
                                    Capability);

    if (NT_SUCCESS(Status)) {
        Globals.AgpStatus = *(PULONG)&Capability->AGPStatus;
    }

    return Status;
}
#endif // AGP3


NTSTATUS
AgpLibSetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset,
                                 NULL);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Now that we know the offset, write the supplied command register
    //
    Status = (pConfigFn)(Context,
                         FALSE,
                         &Capability->AGPCommand,
                         CapabilityOffset + FIELD_OFFSET(PCI_AGP_CAPABILITY, AGPCommand),
                         sizeof(Capability->AGPCommand));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibSetAgpCapability - Set AGP command at offset %x for Context %08lx failed %08lx\n",
                CapabilityOffset,
                Context,
                Status));
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibSetTargetCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the AGP target (AGP bridge)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    PTARGET_EXTENSION Extension;

    Globals.AgpCommand = *(PULONG)&Capability->AGPCommand;

    GET_TARGET_EXTENSION(Extension, AgpExtension);

    return(AgpLibSetAgpCapability(ApGetSetDeviceBusData,
                                  Extension,
                                  Capability));
}


NTSTATUS
AgpLibSetMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    PMASTER_EXTENSION Extension;

    GET_MASTER_EXTENSION(Extension, AgpExtension);

    return(AgpLibSetAgpCapability(ApGetSetDeviceBusData,
                                  Extension,
                                  Capability));
}

#ifndef AGP3

NTSTATUS
AgpLibSetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the specified PCI slot.

    Caller is responsible for figuring out what the correct
    Bus/Slot ID is. These are just passed right to HalSetBusData.

Arguments:

    BusId - supplies the bus id

    SlotId - Supplies the slot id

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    BUS_SLOT_ID BusSlotId;

    Globals.AgpCommand = *(PULONG)&Capability->AGPCommand;

    BusSlotId.BusId = BusId;
    BusSlotId.SlotId = SlotId;

    return(AgpLibSetAgpCapability(ApGetSetBusData,
                                  &BusSlotId,
                                  Capability));
}
#endif // AGP3


NTSTATUS
AgpLibGetMasterDeviceId(
    IN PVOID AgpExtension,
    OUT PULONG DeviceId
    )
/*++

Routine Description:

    This function returns the PCI DeviceId/Vendo58rId of the master AGP
    device

Arguments:

    DeviceId - Identifies PCI manufaturer and device of master

Return Value:

    STATUS_SUCCESS or an appropriate error status

--*/
{
    PCI_COMMON_HEADER Header;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
    NTSTATUS Status;
    PMASTER_EXTENSION Master = NULL;
    PTARGET_EXTENSION Target = NULL;

    //
    // Try to make this as idiot proof as possible for the case
    // where this is called from SetAperture on a system without
    // an AGP adapter, so we don't AV if some context hasn't been
    // initialized, or is missing...
    //

    Target = CONTAINING_RECORD(AgpExtension,
                               TARGET_EXTENSION,
                               AgpContext);
    
    if (Target) {
        if (Target->CommonExtension.Signature == TARGET_SIG) {
            if (Target->ChildDevice) {        
                if (Target->ChildDevice->CommonExtension.Signature ==
                    MASTER_SIG) {
                    Master = Target->ChildDevice;
                }
            }
        }
    }

    if (Master) {

        //
        // Read the PCI common header to get the capabilities pointer
        //
        Status = (ApGetSetDeviceBusData)((PCOMMON_EXTENSION)Master,
                                         TRUE,
                                         PciConfig,
                                         0,
                                         sizeof(PCI_COMMON_HEADER));
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpLibGetMasterDeviceId - read PCI Config space for Context %08lx failed %08lx\n",
                    Master,
                    Status));
            return Status;
        }
        
        *DeviceId = *(PULONG)PciConfig;
        
    } else {
        *DeviceId = (ULONG)-1;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib\dispatch.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    IRP dispatching routines for the common AGPLIB library

Author:

    John Vert (jvert) 10/25/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/
#include "agplib.h"

//
// Two flavors of each dispatch routine, one for the target (AGP bridge) filter and
// one for the master (video card) filter.
//

NTSTATUS
AgpTargetDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpMasterDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PMASTER_EXTENSION Extension
    );

NTSTATUS
AgpTargetDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpMasterDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PMASTER_EXTENSION Extension
    );

NTSTATUS
AgpCancelMasterRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMASTER_EXTENSION Extension
    );

NTSTATUS
AgpMasterPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMASTER_EXTENSION Extension
    );

NTSTATUS
AgpTargetPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpDispatchPnp)
#pragma alloc_text(PAGE, AgpDispatchDeviceControl)
#pragma alloc_text(PAGE, AgpDispatchWmi)
#pragma alloc_text(PAGE, AgpTargetDispatchPnp)
#pragma alloc_text(PAGE, AgpMasterDispatchPnp)
#pragma alloc_text(PAGE, AgpCancelMasterRemove)
#endif



NTSTATUS
AgpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Main dispatch routine for PNP irps sent to the AGP bus filter driver

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the PNP Irp.

Return Value:

    NTSTATUS

--*/
{
    PCOMMON_EXTENSION Extension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // We're deleted, fail the irp
    //
    if (Extension->Deleted == TRUE) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ASSERT(Extension->AttachedDevice != NULL);

    if (Extension->Type == AgpTargetFilter) {
        return(AgpTargetDispatchPnp(DeviceObject,
                                    Irp,
                                    DeviceObject->DeviceExtension));
    } else {
        ASSERT(Extension->Type == AgpMasterFilter);
        return(AgpMasterDispatchPnp(DeviceObject,
                                    Irp,
                                    DeviceObject->DeviceExtension));
    }
}


NTSTATUS
AgpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Main dispatch routine for power irps sent to the AGP bus filter driver

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the power Irp.

Return Value:

    NTSTATUS

--*/
{
    PCOMMON_EXTENSION Extension = DeviceObject->DeviceExtension;

    //
    // We're deleted, fail the irp
    //
    if (Extension->Deleted == TRUE) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ASSERT(Extension->AttachedDevice != NULL);

   if (Extension->Type == AgpTargetFilter) {
        return(AgpTargetDispatchPower(DeviceObject,
                                      Irp,
                                      DeviceObject->DeviceExtension));
    } else {
        ASSERT(Extension->Type == AgpMasterFilter);
        return(AgpMasterDispatchPower(DeviceObject,
                                      Irp,
                                      DeviceObject->DeviceExtension));
    }
}


NTSTATUS
AgpTargetDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Dispatch routine for PNP irps sent to the AGP bus filter driver
    attached to the target (AGP bridge) PDO.

Arguments:

    DeviceObject - Supplies the AGP target device object

    Irp - Supplies the PNP Irp.

    Extension - Supplies the AGP target device extension

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    AGPLOG(AGP_IRPTRACE,
           ("AgpTargetDispatchPnp: IRP 0x%x\n", irpStack->MinorFunction));

    switch (irpStack->MinorFunction) {
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            AGPLOG(AGP_NOISE,
                   ("AgpTargetDispatchPnp: IRP_MN_FILTER_RESOURCE_REQUIREMENTS to %08lx\n",
                    DeviceObject));

            Status = AgpFilterResourceRequirements(DeviceObject, Irp, Extension);
            break;

        case IRP_MN_QUERY_RESOURCES:
            AGPLOG(AGP_NOISE,
                   ("AgpTargetDispatchPnp: IRP_MN_QUERY_RESOURCES to %08lx\n",
                    DeviceObject));

            //
            // We must handle this IRP on the way back so we can add the AGP
            // resources on to it. Set a completion routine.
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   AgpQueryResources,
                                   Extension,
                                   TRUE,
                                   FALSE,
                                   FALSE);
            Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);
            return Status ;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            if (irpStack->Parameters.QueryDeviceRelations.Type == BusRelations) {
                KEVENT event;

                KeInitializeEvent(&event, NotificationEvent, FALSE);

                //
                // We must handle this IRP on the way back so that we can attach
                // a filter to any child PDOs of our PCI-PCI bridge.
                //
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       AgpSetEventCompletion,
                                       &event,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

                //
                // If we did things asynchronously then wait on our event
                //
                if (Status == STATUS_PENDING) {

                    //
                    // We do a KernelMode wait so that our stack where the
                    // event is doesn't get paged out!
                    //
                    KeWaitForSingleObject(&event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL);
                    Status = Irp->IoStatus.Status;
                }

                if (NT_SUCCESS(Status)) {
                    Status = AgpAttachDeviceRelations(DeviceObject,
                                                      Irp,
                                                      Extension);
                    Irp->IoStatus.Status = Status;
                }

                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return Status;

            } else {
                break;
            }

        case IRP_MN_START_DEVICE:
            //
            // We need to hook this in order to filter out any AGP
            // resources that have been added.
            //
            return(AgpStartTarget(Irp, Extension));

        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:

            //
            // We can always succeed this.
            //
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:
            AgpDisableAperture(GET_AGP_CONTEXT(Extension));

            //
            // Pass the irp down
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

            //
            // Clean up and delete ourselves
            //
            AgpWmiDeRegistration(Extension);
            Extension->CommonExtension.Deleted = TRUE;
            IoDetachDevice(Extension->CommonExtension.AttachedDevice);
            Extension->CommonExtension.AttachedDevice = NULL;
            RELEASE_BUS_INTERFACE(Extension);
            if (Extension->FavoredMemory.Ranges) {
               ExFreePool(Extension->FavoredMemory.Ranges);
            }
            if (Extension->Resources) {
                ExFreePool(Extension->Resources);
            }
            if (Extension->ResourcesTranslated) {
                ExFreePool(Extension->ResourcesTranslated);
            }
            ExFreePool(Extension->Lock);;
            IoDeleteDevice(DeviceObject);
            return(Status);

        case IRP_MN_STOP_DEVICE:
            AgpDisableAperture(GET_AGP_CONTEXT(Extension));
            Status = STATUS_SUCCESS;
            break;  // forward irp down the stack

    }

    ASSERT(Status != STATUS_PENDING);

    if (Status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = Status;
    }

    if (NT_SUCCESS(Status) || (Status == STATUS_NOT_SUPPORTED)) {

        //
        // Forward IRP to PCI driver
        //
        IoSkipCurrentIrpStackLocation(Irp);
        return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));

    } else {

        Status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT) ;
        return Status ;
    }
}


NTSTATUS
AgpDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Main dispatch routine for device control irps sent to the AGP bus filter driver

    AGP currently does not support any device controls. So we just pass everything
    down and hope the PDO knows what to do with it.

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the power Irp.

Return Value:

    NTSTATUS

--*/
{
    PCOMMON_EXTENSION Extension = DeviceObject->DeviceExtension;
    PAGED_CODE();

    //
    // We're deleted, fail the irp
    //
    if (Extension->Deleted == TRUE) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ASSERT(Extension->AttachedDevice != NULL);

    IoSkipCurrentIrpStackLocation(Irp);
    return(IoCallDriver(Extension->AttachedDevice, Irp));
}


NTSTATUS
AgpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Main dispatch routine for system control irps sent to the AGP bus filter
    driver.

    AGP currently does not support any WMI IRPs, so we just pass everything
    down and hope the PDO knows what to do with it.

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the power Irp.

Return Value:

    NTSTATUS

--*/
{
    PCOMMON_EXTENSION Extension = DeviceObject->DeviceExtension;
    PAGED_CODE();

    //
    // We're deleted, fail the irp
    //
    if (Extension->Deleted == TRUE) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ASSERT(Extension->AttachedDevice != NULL);

    //
    // Return AGP info for target device
    //
    if (Extension->Type == AgpTargetFilter) {
        return AgpSystemControl(DeviceObject, Irp);
    }

    IoSkipCurrentIrpStackLocation(Irp);
    return(IoCallDriver(Extension->AttachedDevice, Irp));
}


NTSTATUS
AgpTargetDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
{
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    AGPLOG(AGP_IRPTRACE,
           ("AgpTargetDispatchPower: IRP 0x%x\n", irpStack->MinorFunction));

    //
    // All we keep track of are Dx states. PCI is responsible for mapping
    // S-states into D states.
    //


    if ((irpStack->MinorFunction == IRP_MN_SET_POWER) &&
        (irpStack->Parameters.Power.Type == DevicePowerState) &&
        (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0)) {

        NTSTATUS Status;

        //
        // We need to reinitialize the target when this IRP has been completed
        // by the lower drivers. Set up our completion handler to finish this.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               AgpTargetPowerUpCompletion,
                               Extension,
                               TRUE,
                               FALSE,
                               FALSE);

        IoMarkIrpPending(Irp);
        PoStartNextPowerIrp(Irp);
        Status = PoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);
        return STATUS_PENDING;
    }
    //
    // Just forward to target device
    //
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return(PoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}


NTSTATUS
AgpMasterDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    Dispatch routine for PNP irps sent to the AGP bus filter driver
    attached to the device PDOs.

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the PNP Irp.

    Extension - Supplies the AGP bridge device extension

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PAGP_BUS_INTERFACE_STANDARD Interface;
    NTSTATUS Status;

    PAGED_CODE();

    AGPLOG(AGP_IRPTRACE,
           ("AgpMasterDispatchPnp: IRP 0x%x\n", irpStack->MinorFunction));

    switch (irpStack->MinorFunction) {
        case IRP_MN_QUERY_INTERFACE:

#if 0
            AGPLOG(AGP_IRPTRACE,
                   ("\tSize=0x%x, Version=%d\n"
                    "\tGUID=0x%08x-0x%04x-0x%04x-0x%02x-"
                    "0x%02x-0x%02x-0x%02x-0x%02x-0x%02x-0x%02x-0x%02x\n",
                    irpStack->Parameters.QueryInterface.Size,
                    irpStack->Parameters.QueryInterface.Version,
                    *(PULONG)irpStack->Parameters.QueryInterface.InterfaceType,
                    *((PUSHORT)irpStack->Parameters.QueryInterface.InterfaceType + 2),
                    *((PUSHORT)irpStack->Parameters.QueryInterface.InterfaceType + 3),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 8),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 9),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 10),

                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 11),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 12),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 13),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 14),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 15)));

#endif

            //
            // The only IRP we look for here is IRP_MN_QUERY_INTERFACE for
            // GUID_AGP_BUS_INTERFACE_STANDARD.
            //
            if ((RtlEqualMemory(
                irpStack->Parameters.QueryInterface.InterfaceType,
                &GUID_AGP_BUS_INTERFACE_STANDARD,
                sizeof(GUID))) &&
                (((irpStack->Parameters.QueryInterface.Size >=
                   sizeof(AGP_BUS_INTERFACE_STANDARD)) &&
                  (irpStack->Parameters.QueryInterface.Version ==
                   AGP_BUS_INTERFACE_V2)) ||
                 ((irpStack->Parameters.QueryInterface.Size >=
                   AGP_BUS_INTERFACE_V1_SIZE) &&
                  (irpStack->Parameters.QueryInterface.Version ==
                   AGP_BUS_INTERFACE_V1)))) {

                Interface = (PAGP_BUS_INTERFACE_STANDARD)irpStack->Parameters.QueryInterface.Interface;

                Interface->Version =
                    irpStack->Parameters.QueryInterface.Version;
                Interface->AgpContext = Extension;
                Interface->InterfaceReference = AgpInterfaceReference;
                Interface->InterfaceDereference = AgpInterfaceDereference;
                Interface->ReserveMemory = AgpInterfaceReserveMemory;
                Interface->ReleaseMemory = AgpInterfaceReleaseMemory;
                Interface->CommitMemory = AgpInterfaceCommitMemory;
                Interface->FreeMemory = AgpInterfaceFreeMemory;
                Interface->GetMappedPages = AgpInterfaceGetMappedPages;

                if (Interface->Version < AGP_BUS_INTERFACE_V2) {
                    Interface->Size = AGP_BUS_INTERFACE_V1_SIZE;
                } else {
                    Interface->Size = sizeof(AGP_BUS_INTERFACE_STANDARD);
                    Interface->SetRate = AgpInterfaceSetRate;
                }

                Interface->Capabilities = Extension->Capabilities;

                //
                // Complete the IRP successfully
                //
                Irp->IoStatus.Status = STATUS_SUCCESS;

                // AGPLOG(AGP_IRPTRACE, ("\tOK.\n"));
            } // else { AGPLOG(AGP_IRPTRACE, ("\tNO!\n")); }
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
            if (irpStack->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE) {
                Extension->RemovePending = TRUE;
            } else {
                Extension->StopPending = TRUE;
            }
            //
            // If we have given out any interfaces or there are some reserved
            // pages, we cannot stop.
            //
            if ((Extension->InterfaceCount > 0) ||
                (Extension->ReservedPages > 0)) {
                AGPLOG(AGP_NOISE,
                       ("AgpMasterDispatchPnp: failing %s due to outstanding interfaces\n",
                        (irpStack->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE)
                            ? "IRP_MN_QUERY_REMOVE_DEVICE"
                            : "IRP_MN_QUERY_STOP_DEVICE"
                       ));

                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return(STATUS_UNSUCCESSFUL);
            } else {
                //
                // We can succeed this, mark our extension as being in limbo so we do
                // not give out any interfaces or anything until we get removed or
                // get a cancel.
                //
                InterlockedIncrement(&Extension->DisableCount);
                break;  // forward irp down the stack
            }

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            //
            // This IRP must be handled on the way back up the stack.
            // Set a completion routine to reenable the device.
            //
            if (Extension->RemovePending) {
                Extension->RemovePending = FALSE;
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       AgpCancelMasterRemove,
                                       Extension,
                                       TRUE,
                                       FALSE,
                                       FALSE);
                return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
            } else {
                //
                // This is a cancel-remove for a query-remove IRP we never saw.
                // Ignore it.
                //
                break;
            }

        case IRP_MN_CANCEL_STOP_DEVICE:
            //
            // This IRP must be handled on the way back up the stack.
            // Set a completion routine to reenable the device.
            //
            if (Extension->StopPending) {
                Extension->StopPending = FALSE;
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       AgpCancelMasterRemove,
                                       Extension,
                                       TRUE,
                                       FALSE,
                                       FALSE);
                return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
            } else {
                //
                // This is a cancel-stop for a query-stop IRP we never saw.
                // Ignore it.
                //
                break;
            }

        case IRP_MN_REMOVE_DEVICE:
            AGPLOG(AGP_NOISE,
                   ("AgpMasterDispatchPnp: removing device due to IRP_MN_REMOVE_DEVICE\n"));

            //
            // PNP is supposed to send us a QUERY_REMOVE before any REMOVE. That is
            // when we check that we are actually in a state where we can be removed.
            // Like all PNP rules, there is an exception - if the START is failed
            // after we have succeeded it, then we get a REMOVE without a QUERY_REMOVE.
            // Obviously this is totally fatal if we have given out interfaces or
            // have pages mapped in the GART. Not much we can do about it then.
            //
            ASSERT(Extension->InterfaceCount == 0);
            ASSERT(Extension->ReservedPages == 0);

            //
            // Pass the IRP down.
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

            //
            // Clean up and delete ourselves
            //
            Extension->Target->ChildDevice = NULL;
            Extension->CommonExtension.Deleted = TRUE;
            IoDetachDevice(Extension->CommonExtension.AttachedDevice);
            Extension->CommonExtension.AttachedDevice = NULL;
            RELEASE_BUS_INTERFACE(Extension);
            IoDeleteDevice(DeviceObject);
            return(Status);

        case IRP_MN_STOP_DEVICE:
            AGPLOG(AGP_NOISE,
                   ("AgpMasterDispatchPnp: stopping device due to IRP_MN_STOP_DEVICE\n"));
            ASSERT(Extension->DisableCount);

            //
            // Just pass the IRP on down
            //
            break;

        case IRP_MN_START_DEVICE:
            AGPLOG(AGP_NOISE,
                   ("AgpMasterDispatchPnp: starting device due to IRP_MN_START_DEVICE\n"));
            ASSERT(Extension->DisableCount);
            InterlockedDecrement(&Extension->DisableCount);
            break;  // forward IRP down the stack
    }

    //
    // Just forward to target device
    //
    IoSkipCurrentIrpStackLocation(Irp);
    return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}

NTSTATUS
AgpMasterDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PMASTER_EXTENSION Extension
    )
{
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    AGPLOG(AGP_IRPTRACE,
           ("AgpMasterDispatchPower: IRP 0x%x\n", irpStack->MinorFunction));

    //
    // All we keep track of are Dx states. Videoport is responsible for mapping
    // S-states into D states.
    //
    if ((irpStack->MinorFunction == IRP_MN_SET_POWER) &&
        (irpStack->Parameters.Power.Type == DevicePowerState) &&
        (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0)) {

        NTSTATUS Status;

        //
        // We need to reinitialize the master when this IRP has been completed
        // by the lower drivers. Set up a completion routine.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               AgpMasterPowerUpCompletion,
                               Extension,
                               TRUE,
                               FALSE,
                               FALSE);

        IoMarkIrpPending(Irp);
        PoStartNextPowerIrp(Irp);
        Status = PoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);
        return STATUS_PENDING;
    }

    //
    // Just forward to target device
    //
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return(PoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}


NTSTATUS
AgpMasterPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    Powerup completion routine for the master device. It reinitializes the
    master registers.

Arguments:

    DeviceObject - supplies the master device object.

    Irp - Supplies the IRP_MN_SET_POWER irp.

    Extension - Supplies the master extension

Return Value:

    Status

--*/

{
    NTSTATUS Status;
    ULONG CurrentCapabilities;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    Status = AgpInitializeMaster(GET_AGP_CONTEXT_FROM_MASTER(Extension),
                                 &CurrentCapabilities);
    ASSERT(CurrentCapabilities == Extension->Capabilities);
    if (!NT_SUCCESS(Status)) {
        Irp->IoStatus.Status = Status;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
AgpTargetPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Powerup completion routine for the target device. It reinitializes the
    GART aperture

Arguments:

    DeviceObject - supplies the master device object.

    Irp - Supplies the IRP_MN_SET_POWER irp.

    Extension - Supplies the target extension

Return Value:

    Status

--*/

{
    NTSTATUS Status;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Now it is safe to reinitialize the target. All we do here
    // is reset the aperture
    //
    if (Extension->GartLengthInPages != 0) {
        Status = AgpSetAperture(GET_AGP_CONTEXT(Extension),
                                Extension->GartBase,
                                Extension->GartLengthInPages);
        if (!NT_SUCCESS(Status)) {
            Irp->IoStatus.Status = Status;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
AgpCancelMasterRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for IRP_MN_CANCEL_REMOVE_DEVICE. This is required
    since we cannot reenable AGP until the lower levels have completed their
    CANCEL_REMOVE processing.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP

    Extension - Supplies the master extension

Return Value:

    NTSTATUS

--*/

{
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    ASSERT(Extension->DisableCount > 0);
    InterlockedDecrement(&Extension->DisableCount);
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:

    This routine is used as a completion routine when an IRP is passed
    down the stack but more processing must be done on the way back up.
    The effect of using this as a completion routine is that the IRP
    will not be destroyed in IoCompleteRequest as called by the lower
    level object.  The event which is a KEVENT is signaled to allow
    processing to continue

Arguments:

    DeviceObject - Supplies the device object

    Irp - The IRP we are processing

    Event - Supplies the event to be signaled

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    ASSERT(Event);

    //
    // This can be called at DISPATCH_LEVEL so must not be paged
    //
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib\resource.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Common routines for handling resource requirements

Author:

    John Vert (jvert) 10/25/1997

Revision History:

--*/
#include "agplib.h"


PCM_RESOURCE_LIST
ApSplitResourceList(
    IN PCM_RESOURCE_LIST ResourceList,
    OUT PCM_RESOURCE_LIST *NewResourceList
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpFilterResourceRequirements)
#pragma alloc_text(PAGE, AgpStartTarget)
#pragma alloc_text(PAGE, ApSplitResourceList)
#endif

static BOOLEAN ResourceConflict = FALSE;


NTSTATUS
AgpFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for IRP_MN_QUERY_RESOURCE_REQUIREMENTS. This adds on the
    AGP resource requirements.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_RESOURCE_REQUIREMENTS Irp

    Extension - Supplies the device extension

Return Value:

    NTSTATUS

--*/

{
    BOOLEAN SwapDescriptor;
    ULONG SwapLength;
    ULONG ApertureSize;
    NTSTATUS Status;
    ULONG AddCount;
    PHYSICAL_ADDRESS CurrentBase;
    PHYSICAL_ADDRESS MaxAddr;
    ULONG CurrentSizeInPages;
    PIO_RESOURCE_REQUIREMENTS_LIST OldRequirements;
    PIO_RESOURCE_REQUIREMENTS_LIST NewRequirements;
    ULONG NewSize;
    ULONG Alternative;
    PIO_RESOURCE_LIST OldResourceList;
    PIO_RESOURCE_LIST NewResourceList;
    PIO_RESOURCE_DESCRIPTOR Descriptor;
    PIO_STACK_LOCATION IrpSp;
    PIO_RESOURCE_LIST ApertureRequirements = NULL;
    ULONG i;

    PAGED_CODE();

    AGPLOG(AGP_NOISE,
           ("AgpQueryResourceRequirements - IRP %08lx, resource %08lx\n",
            Irp,
            Irp->IoStatus.Information));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Create a new resource requirements list with our current aperture
    // settings tacked on the end.
    //
    OldRequirements = IrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;
    if (OldRequirements == NULL) {
        //STATUS_INVALID_DEVICE_REQUEST
        // PNP helpfully passes us a NULL pointer instead of an empty resource list
        // when the bridge is disabled. In this case we will ignore this irp and not
        // add on our requirements since they are not going to be used anyway.
        //
        return(STATUS_SUCCESS);
    }

    //
    // Get the current GART aperture.
    //
    Status = AgpQueryAperture(GET_AGP_CONTEXT(Extension),
                              &CurrentBase,
                              &CurrentSizeInPages,
                              &ApertureRequirements);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpQueryResourceRequirements - AgpQueryAperture %08lx failed %08lx\n",
                Extension,
                Status));
        return(Status);
    }

    ApertureSize = (CurrentSizeInPages * PAGE_SIZE);
    MaxAddr.QuadPart = CurrentBase.QuadPart + ApertureSize - 1;

    AGPLOG(AGP_NOISE,
           ("AgpQueryResourceRequirements - aperture at %I64x, length %08lx pages, Requirements %08lx\n",
            CurrentBase.QuadPart,
            CurrentSizeInPages,
            ApertureRequirements));

    //
    // We will add IO_RESOURCE_DESCRIPTORs to each alternative.
    //
    // The first one is a private data type marked with our signature. This is
    // a marker so that we know which descriptors are ours so we can remove
    // them later.
    //
    // The second is the actual descriptor for the current aperture settings.
    // This is marked as preferred.
    //
    // Following this is the requirements returned from AgpQueryAperture. These
    // get marked as alternatives.
    //
    AddCount = 2;

    //
    // Enumerate the old list looking for any preferred descriptor that
    // conflicts with our preferred settings; if we find one, then the BIOS
    // is whack, and we will throw out our preferred descriptor, and let PnP
    // choose from our alternates
    //
    ResourceConflict = FALSE;
    OldResourceList = &OldRequirements->List[0];

    for (Alternative = 0; Alternative < OldRequirements->AlternativeLists;
         Alternative++) {

        for (i = 0; i < OldResourceList->Count; i++) {
            Descriptor = &OldResourceList->Descriptors[i];

            if ((Descriptor->Option == IO_RESOURCE_PREFERRED) &&
                (Descriptor->Type == CmResourceTypeMemory)) {
                
                if (((Descriptor->u.Memory.MinimumAddress.QuadPart >=
                      CurrentBase.QuadPart) &&
                     (Descriptor->u.Memory.MinimumAddress.QuadPart <=
                      MaxAddr.QuadPart)) ||
                     ((Descriptor->u.Memory.MaximumAddress.QuadPart >=
                       CurrentBase.QuadPart) &&
                      (Descriptor->u.Memory.MaximumAddress.QuadPart <=
                       MaxAddr.QuadPart)) ||
                    ((Descriptor->u.Memory.MinimumAddress.QuadPart <
                      CurrentBase.QuadPart) &&
                     (Descriptor->u.Memory.MaximumAddress.QuadPart >
                      MaxAddr.QuadPart))) {

                    AGPLOG(AGP_CRITICAL,
                           ("AgpQueryResourceRequirements - Conflicted "
                            "resource detected: %I64X - %I64X\n",
                            Descriptor->u.Memory.MinimumAddress.QuadPart,
                            Descriptor->u.Memory.MaximumAddress.QuadPart));

                    //
                    // This preferred descriptor is in conflic with our AGP
                    // preferred setting
                    //
#if defined(_IA64_)
                    AGPLOG(AGP_CRITICAL, ("Please contact system manufacturer "
                                          "for a BIOS upgrade.\n"));
#else // _IA64_
                    AddCount = 1;
                    ResourceConflict = TRUE;
#endif // _IA64_
                    break;
                }
            }
        }
        OldResourceList = (PIO_RESOURCE_LIST)(OldResourceList->Descriptors +
                                              OldResourceList->Count);
    }

    //
    //
    // For IA64, PnP cannot reassign the aperture base, so we can only use
    // the "preferred" descriptor
    //
    if (ApertureRequirements) {
        AddCount += ApertureRequirements->Count;
    }

    NewSize = OldRequirements->ListSize;
    NewSize += sizeof(IO_RESOURCE_DESCRIPTOR) *
        (AddCount * OldRequirements->AlternativeLists);
    
    NewRequirements = ExAllocatePool(PagedPool, NewSize);
    if (NewRequirements == NULL) {
        if (ApertureRequirements) {
            ExFreePool(ApertureRequirements);
        }
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    NewRequirements->ListSize = NewSize;
    NewRequirements->InterfaceType = OldRequirements->InterfaceType;
    NewRequirements->BusNumber = OldRequirements->BusNumber;
    NewRequirements->SlotNumber = OldRequirements->SlotNumber;
    NewRequirements->AlternativeLists = OldRequirements->AlternativeLists;

    //
    // Append our requirement to each alternative resource list.
    //
    NewResourceList = &NewRequirements->List[0];
    OldResourceList = &OldRequirements->List[0];
    for (Alternative = 0; Alternative < OldRequirements->AlternativeLists; Alternative++) {

        //
        // Copy the old resource list into the new one.
        //
        NewResourceList->Version = OldResourceList->Version;
        NewResourceList->Revision = OldResourceList->Revision;
        NewResourceList->Count = OldResourceList->Count + AddCount;
        RtlCopyMemory(&NewResourceList->Descriptors[0],
                      &OldResourceList->Descriptors[0],
                      OldResourceList->Count * sizeof(IO_RESOURCE_DESCRIPTOR));

        Descriptor = &NewResourceList->Descriptors[OldResourceList->Count];

        //
        // Append the marker descriptor
        //
        Descriptor->Option = 0;
        Descriptor->Flags = 0;
        Descriptor->Type = CmResourceTypeDevicePrivate;
        Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
        Descriptor->u.DevicePrivate.Data[0] = AgpPrivateResource;
        Descriptor->u.DevicePrivate.Data[1] = 1;
        ++Descriptor;

        //
        // Append the new descriptor
        //
        if (!ResourceConflict) {
            Descriptor->Option = IO_RESOURCE_PREFERRED;
            Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE |
                CM_RESOURCE_MEMORY_PREFETCHABLE;
            Descriptor->Type = CmResourceTypeMemory;
            Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
            Descriptor->u.Memory.Length = CurrentSizeInPages * PAGE_SIZE;
            Descriptor->u.Memory.Alignment = CurrentSizeInPages * PAGE_SIZE;
            Descriptor->u.Memory.MinimumAddress = CurrentBase;
            Descriptor->u.Memory.MaximumAddress = MaxAddr;
            ++Descriptor;
        }

        //
        // Append the alternatives
        //
        if (ApertureRequirements) {

            SwapDescriptor = FALSE;
            for (i = 0; i < ApertureRequirements->Count; i++) {
                
                //
                // Make sure this descriptor makes sense
                //
                ASSERT(ApertureRequirements->Descriptors[i].Flags ==
                       (CM_RESOURCE_MEMORY_READ_WRITE |
                        CM_RESOURCE_MEMORY_PREFETCHABLE));
                ASSERT(ApertureRequirements->Descriptors[i].Type ==
                       CmResourceTypeMemory);
                ASSERT(ApertureRequirements->Descriptors[i].ShareDisposition ==
                       CmResourceShareDeviceExclusive);
                
                *Descriptor = ApertureRequirements->Descriptors[i];
                
                //
                // In this case we nuked our preferred descriptor so mark the
                // first alternate as preferred
                //
                if ((i == 0) && ResourceConflict) {
                    
                    Descriptor->Option = IO_RESOURCE_PREFERRED;
                    
                    if (Descriptor->u.Memory.Length != ApertureSize) {
                        SwapLength = Descriptor->u.Memory.Length;
                        Descriptor->u.Memory.Length = ApertureSize;
                        Descriptor->u.Memory.Alignment = ApertureSize;
                        SwapDescriptor = TRUE;
                    }
                    
                } else {
                    Descriptor->Option = IO_RESOURCE_ALTERNATIVE;
                    
                    if (SwapDescriptor) {
                        if (Descriptor->u.Memory.Length == ApertureSize) {
                            Descriptor->u.Memory.Length = SwapLength;
                            Descriptor->u.Memory.Alignment = SwapLength;
                            SwapDescriptor = FALSE;
                        }
                    }
                }
                
                ++Descriptor;
            }
        }

        //
        // Advance to next resource list
        //
        NewResourceList = (PIO_RESOURCE_LIST)(NewResourceList->Descriptors + NewResourceList->Count);
        OldResourceList = (PIO_RESOURCE_LIST)(OldResourceList->Descriptors + OldResourceList->Count);
    }

    AGPLOG(AGP_NOISE,
           ("AgpQueryResourceRequirements - IRP %p, old resources %p, new resources %p\n",
            Irp,
            OldRequirements,
            NewRequirements));
    IrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList = NewRequirements;
    Irp->IoStatus.Information = (ULONG_PTR)NewRequirements;
    ExFreePool(OldRequirements);
    if (ApertureRequirements) {
        ExFreePool(ApertureRequirements);
    }
    return(STATUS_SUCCESS);

}


NTSTATUS
AgpQueryResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for IRP_MN_QUERY_RESOURCES. This adds on the
    AGP resources

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_RESOURCES Irp

    Extension - Supplies the device extension

Return Value:

    NTSTATUS

--*/

{
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    AGPLOG(AGP_NOISE,
           ("AgpQueryResources - IRP %08lx, resource %08lx\n",
            Irp,
            Irp->IoStatus.Information));
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpStartTarget(
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Filters out the AGP-specific resource requirements on a
    IRP_MN_START_DEVICE Irp.

Arguments:

    Irp - supplies the IRP_MN_START_DEVICE Irp.

    Extension - Supplies the device extension.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpSp;
    PCM_RESOURCE_LIST NewResources;
    PCM_RESOURCE_LIST NewResourcesTranslated;
    PCM_RESOURCE_LIST AgpAllocatedResources;
    PCM_RESOURCE_LIST AgpAllocatedResourcesTranslated;
    NTSTATUS Status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    AGPLOG(AGP_NOISE,
           ("AgpStartTarget - IRP %08lx, resource %08lx\n",
            Irp,
            Irp->IoStatus.Information));

    if (irpSp->Parameters.StartDevice.AllocatedResources != NULL) {
        KEVENT event;

        //
        // Find our private descriptors and split them out into
        // our own resource list
        //
        Extension->Resources = ApSplitResourceList(irpSp->Parameters.StartDevice.AllocatedResources,
                                                   &NewResources);
        Extension->ResourcesTranslated = ApSplitResourceList(irpSp->Parameters.StartDevice.AllocatedResourcesTranslated,
                                                             &NewResourcesTranslated);
        
        //
        // Split resources will return two NULL lists when we run low
        // memory, so we only need to check one of its return values
        //
        if ((NewResources == NULL) || (NewResourcesTranslated == NULL)) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            
        } else {
            ASSERT(Extension->Resources->Count == 1);
            ASSERT(Extension->Resources->List[0].PartialResourceList.Count == 1);
            Descriptor = &Extension->Resources->List[0].PartialResourceList.PartialDescriptors[0];
            ASSERT(Descriptor->Type == CmResourceTypeMemory);
            Extension->GartBase = Descriptor->u.Memory.Start;
            Extension->GartLengthInPages = Descriptor->u.Memory.Length / PAGE_SIZE;
            
            //
            // Set the new GART aperture
            //
            Status = AgpSetAperture(GET_AGP_CONTEXT(Extension),
                                    Extension->GartBase,
                                    Extension->GartLengthInPages);
        }
        ASSERT(NT_SUCCESS(Status));

        Irp->IoStatus.Status = Status ;
        if (!NT_SUCCESS(Status) ) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpStartTarget - AgpSetAperture to %I64X, %08lx failed %08lx\n",
                    Extension->GartBase.QuadPart,
                    Extension->GartLengthInPages * PAGE_SIZE,
                    Status));
            Irp->IoStatus.Status = Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            if (NewResources != NULL) {
                ExFreePool(NewResources);
                ExFreePool(Extension->Resources);
                Extension->Resources = NULL;
            }

            if (NewResourcesTranslated != NULL) {
                ExFreePool(NewResourcesTranslated);
                ExFreePool(Extension->ResourcesTranslated);
                Extension->ResourcesTranslated = NULL;
            }

            return(Status);
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        //
        // Set up the new parameters for the PCI driver.
        //

        irpSp->Parameters.StartDevice.AllocatedResources = NewResources;
        irpSp->Parameters.StartDevice.AllocatedResourcesTranslated = NewResourcesTranslated;
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               AgpSetEventCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // Pass down the driver stack
        //
        Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

        //
        // If we did things asynchronously then wait on our event
        //
        if (Status == STATUS_PENDING) {
            
            //
            // We do a KernelMode wait so that our stack where the event is
            // doesn't get paged out!
            //
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            Status = Irp->IoStatus.Status;
        }

        ExFreePool(irpSp->Parameters.StartDevice.AllocatedResources);
        ExFreePool(irpSp->Parameters.StartDevice.AllocatedResourcesTranslated);

        IoCompleteRequest(Irp, IO_NO_INCREMENT) ;
        return Status;        
    }
    
    //
    // The bridge is disabled, we have been passed a NULL pointer
    // instead of an empty resource list.  There is nothing to do other
    // than pass down the irp
    //
    IoSkipCurrentIrpStackLocation(Irp);

    return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}


PCM_RESOURCE_LIST
ApSplitResourceList(
    IN PCM_RESOURCE_LIST ResourceList,
    OUT PCM_RESOURCE_LIST *NewResourceList
    )
/*++

Routine Description:

    Splits out the AGP-specific resources from a resource list.

Arguments:

    ResourceList - Supplies the resource list.

    NewResourceList - Returns the new resource list with the AGP-specific
        resources stripped out.

Return Value:

    Pointer to the AGP-specific resource list

--*/

{
    ULONG Size;
    ULONG FullCount;
    ULONG PartialCount;
    PCM_FULL_RESOURCE_DESCRIPTOR Full, NewFull, AgpFull;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Partial, NewPartial, AgpPartial;
    PCM_RESOURCE_LIST NewList;
    PCM_RESOURCE_LIST AgpList;
    ULONG NextAgp=0;

    PAGED_CODE();

    //
    // First walk through the source resource list and figure out how big it
    // is. The two resulting resource lists must be smaller than this, so we
    // will just allocate them to be that size and not worry about it.
    //
    Size = sizeof(CM_RESOURCE_LIST) - sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
    Full = &ResourceList->List[0];
    for (FullCount=0; FullCount<ResourceList->Count; FullCount++) {
        Size += sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
        PartialCount = Full->PartialResourceList.Count;
        Size += (PartialCount-1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

        Full = (PCM_FULL_RESOURCE_DESCRIPTOR)(&Full->PartialResourceList.PartialDescriptors[PartialCount]);
    }

    //
    // Allocate two additional lists
    //
    NewList = ExAllocatePool(PagedPool, Size);
    if (NewList == NULL) {
        *NewResourceList = NULL;
        return(NULL);
    }

    AgpList = ExAllocatePool(PagedPool, Size);
    if (AgpList == NULL) {
        ExFreePool(NewList);
        *NewResourceList = NULL;
        return(NULL);
    }

    //
    // Initialize both new resource lists to have the same number
    // of CM_FULL_RESOURCE_DESCRIPTORs. If any turn out to be empty,
    // we will adjust the count.
    //
    NewList->Count = AgpList->Count = ResourceList->Count;

    //
    // Walk through each CM_FULL_RESOURCE_DESCRIPTOR, copying as we go.
    //
    Full = &ResourceList->List[0];
    NewFull = &NewList->List[0];
    AgpFull = &AgpList->List[0];
    for (FullCount = 0;FullCount < ResourceList->Count; FullCount++) {
        NewFull->InterfaceType = AgpFull->InterfaceType = Full->InterfaceType;
        NewFull->BusNumber = AgpFull->BusNumber = Full->BusNumber;

        //
        // Initialize the partial resource list header
        //
        NewFull->PartialResourceList.Version = Full->PartialResourceList.Version;
        AgpFull->PartialResourceList.Version = Full->PartialResourceList.Version;
        NewFull->PartialResourceList.Revision = Full->PartialResourceList.Revision;
        AgpFull->PartialResourceList.Revision = Full->PartialResourceList.Revision;
        NewFull->PartialResourceList.Count = AgpFull->PartialResourceList.Count = 0;

        NewPartial = &NewFull->PartialResourceList.PartialDescriptors[0];
        AgpPartial = &AgpFull->PartialResourceList.PartialDescriptors[0];
        for (PartialCount = 0; PartialCount < Full->PartialResourceList.Count; PartialCount++) {
            Partial = &Full->PartialResourceList.PartialDescriptors[PartialCount];
            if ((Partial->Type == CmResourceTypeDevicePrivate) &&
                (Partial->u.DevicePrivate.Data[0] == AgpPrivateResource)) {
                //
                // Found one of our private marker descriptors
                //
                // For now, the only kind we should see indicates we skip one descriptor
                //
                ASSERT(NextAgp == 0);
                ASSERT(Partial->u.DevicePrivate.Data[1] == 1);
                NextAgp = Partial->u.DevicePrivate.Data[1];
                ASSERT(PartialCount+NextAgp < Full->PartialResourceList.Count);
            } else {
                //
                // if NextAgp is set, this descriptor goes in the AGP-specific list.
                // Otherwise, it goes in the new list.
                //
                if (NextAgp > 0) {
                    --NextAgp;
                    *AgpPartial++ = *Partial;
                    ++AgpFull->PartialResourceList.Count;
                } else {
                    *NewPartial++ = *Partial;
                    ++NewFull->PartialResourceList.Count;
                }
            }
        }

        //
        // Finished this CM_PARTIAL_RESOURCE_LIST, advance to the next CM_FULL_RESOURCE_DESCRIPTOR
        //
        if (NewFull->PartialResourceList.Count == 0) {
            //
            // we can just reuse this partial resource descriptor as it is empty
            //
            --NewList->Count;
        } else {
            NewFull = (PCM_FULL_RESOURCE_DESCRIPTOR)NewPartial;
        }
        if (AgpFull->PartialResourceList.Count == 0) {
            //
            // we can just reuse this partial resource descriptor as it is empty
            //
            --AgpList->Count;
        } else {
            AgpFull = (PCM_FULL_RESOURCE_DESCRIPTOR)NewPartial;
        }
    }

    *NewResourceList = NewList;

    return(AgpList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib\utils.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains assorted utility functions for PCI.SYS.

Author:

    Peter Johnston (peterj)  20-Nov-1996

Revision History:

    Eric Nelson (enelson)  20-Mar-2000 - kidnap registry function

--*/

#include "agplib.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpOpenKey)
#pragma alloc_text(PAGE, AgpStringToUSHORT)
#endif


ULONGLONG
AgpGetDeviceFlags(
    IN PAGP_HACK_TABLE_ENTRY AgpHackTable,
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN UCHAR  RevisionID
    )
/*++

Description:

    Look in the registry for any flags for this VendorId/DeviceId.

Arguments:

    VendorId      PCI Vendor ID (16 bits) of the manufacturer of the
                  device.

    DeviceId      PCI Device ID (16 bits) of the device.

    SubVendorID   PCI SubVendorID representing the manufacturer of the
                  subsystem

    SubSystemID   PCI SubSystemID representing subsystem

    RevisionID    PCI Revision denoting the revision of the device

Return Value:

    64 bit flags value or 0 if not found.

--*/
{
    PAGP_HACK_TABLE_ENTRY current;
    ULONGLONG hackFlags = 0;
    ULONG match, bestMatch = 0;

    if (AgpHackTable == NULL) {
        return hackFlags;
    }

    // 
    // We want to do a best-case match:
    // VVVVDDDDSSSSssssRR
    // VVVVDDDDSSSSssss
    // VVVVDDDDRR
    // VVVVDDDD
    //
    // List is currently unsorted, so keep updating current best match.
    //

    for (current = AgpHackTable; current->VendorID != 0xFFFF; current++) {
        match = 0;

        //
        // Must at least match vendor/dev
        //

        if ((current->DeviceID != DeviceID) ||
            (current->VendorID != VendorID)) {
            continue;
        }

        match = 1;

        //
        // If this entry specifies a revision, check that it is consistent.
        // 

        if (current->Flags & AGP_HACK_FLAG_REVISION) {
            if (current->RevisionID == RevisionID) {
                match += 2;
            } else {
                continue;
            }
        }

        //
        // If this entry specifies subsystems, check that they are consistent
        //

        if (current->Flags & AGP_HACK_FLAG_SUBSYSTEM) {
            if (current->SubVendorID == SubVendorID &&
                current->SubSystemID == SubSystemID) {
                match += 4;
            } else {
                continue;
            }
        }

        if (match > bestMatch) {
            bestMatch = match;
            hackFlags = current->DeviceFlags;
        }
    }

    return hackFlags;
}



BOOLEAN
AgpOpenKey(
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    OUT PHANDLE Handle,
    OUT PNTSTATUS Status
    )
/*++

Description:

    Open a registry key.

Arguments:

    KeyName      Name of the key to be opened.
    ParentHandle Pointer to the parent handle (OPTIONAL)
    Handle       Pointer to a handle to recieve the opened key.

Return Value:

    TRUE is key successfully opened, FALSE otherwise.

--*/
{
    UNICODE_STRING    nameString;
    OBJECT_ATTRIBUTES nameAttributes;
    NTSTATUS localStatus;

    PAGED_CODE();

    RtlInitUnicodeString(&nameString, KeyName);

    InitializeObjectAttributes(&nameAttributes,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               ParentHandle,
                               (PSECURITY_DESCRIPTOR)NULL
                               );
    localStatus = ZwOpenKey(Handle,
                            KEY_READ,
                            &nameAttributes
                            );

    if (Status != NULL) {

        //
        // Caller wants underlying status.
        //

        *Status = localStatus;
    }

    //
    // Return status converted to a boolean, TRUE if
    // successful.
    //

    return NT_SUCCESS(localStatus);
}



BOOLEAN
AgpStringToUSHORT(
    IN PWCHAR String,
    OUT PUSHORT Result
    )
/*++

Description:

    Takes a 4 character hexidecimal sting and converts it into a USHORT.

Arguments:

    String - the string

    Result - the USHORT

Return Value:

    TRUE is success, FASLE otherwise

--*/
{
    ULONG count;
    USHORT number = 0;
    PWCHAR current;

    current = String;

    for (count = 0; count < 4; count++) {

        number <<= 4;

        if (*current >= L'0' && *current <= L'9') {
            number |= *current - L'0';
        } else if (*current >= L'A' && *current <= L'F') {
            number |= *current + 10 - L'A';
        } else if (*current >= L'a' && *current <= L'f') {
            number |= *current + 10 - L'a';
        } else {
            return FALSE;
        }

        current++;
    }

    *Result = number;
    return TRUE;
}



ULONG_PTR
AgpExecuteCriticalSystemRoutine(
    IN ULONG_PTR Context
    )
/*++

Routine Description:

    This routine is called in the context of KeIpiGenericCall, which
    executes it on all processors.  It is used to execute
    a critical routine which needs all processors synchronized, such
    as probing the BARs of a device that could not otherwise be turned off.
    Only one context parameter is allowed in this routine, so it must
    contain both the routine to execute and any context that routine
    requires.

    When this routine is entered, it is guaranteed that all processors will
    already have been targeted with an IPI, and will be running at IPI_LEVEL.
    All processors will either be running this routine, or will be about to
    enter the routine.  No arbitrary threads can possibly be running.  No
    devices can interrupt the execution of this routine, since IPI_LEVEL is
    above all device IRQLs.

    Because this routine runs at IPI_LEVEL, no debug prints, asserts or other
    debugging can occur in this function without hanging MP machines.

Arguments:

    Context - the context passed into the call to KeIpiGenericCall.
        It contains the critical routine to execute, any context required
        in that routine and a gate and a barrier to ensure that the critical
        routine is executed on only one processor, even though this function
        is executed on all processors.

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;
    PAGP_CRITICAL_ROUTINE_CONTEXT routineContext =
        (PAGP_CRITICAL_ROUTINE_CONTEXT)Context;

    Status = STATUS_SUCCESS;

    //
    // The Gate parameter in the routineContext is preinitialized
    // to 1, meaning that the first processor to reach this point
    // in the routine will decrement it to 0, and succeed the if
    // statement.
    //
    if (InterlockedDecrement(&routineContext->Gate) == 0) {

        //
        // This is only executed on one processor.
        //
        Status = (NTSTATUS)routineContext->Routine(routineContext->Extension,
                                                   routineContext->Context
                                                   );

        //
        // Free other processors.
        //
        routineContext->Barrier = 0;

    } else {

        //
        // Wait for gated function to complete.
        //
        do {
        } while (routineContext->Barrier != 0);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib\wmi.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    AGP filter driver(s)

Author:

Environment:

    Kernel mode

Revision History :
--*/

#include "agplib.h"
#include <wmistr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpWmiRegistration)
#pragma alloc_text(PAGE, AgpWmiDeRegistration)
#pragma alloc_text(PAGE, AgpSystemControl)
#pragma alloc_text(PAGE, AgpSetWmiDataItem)
#pragma alloc_text(PAGE, AgpSetWmiDataBlock)
#pragma alloc_text(PAGE, AgpQueryWmiDataBlock)
#pragma alloc_text(PAGE, AgpQueryWmiRegInfo)
#endif

#define WMI_AGP_INFORMATION 0
#define NUMBER_OF_WMI_GUIDS 1

GUID AgpWmiGuid = AGP_WMI_STD_DATA_GUID;

WMIGUIDREGINFO WmiGuidList[1] =
{
    { &AgpWmiGuid, 1, 0 }   // Pointer Port driver information
};

NTSTATUS
AgpWmiRegistration(
    PTARGET_EXTENSION Extension
)
/*++

Routine Description:

    Registers with WMI as a data provider for this
    instance of the device

Arguments:

    Extension - Pointer to our taget extension

Return Value:

    STATUS_SUCCESS or an appropriate error status

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    Extension->WmiLibInfo.GuidCount = sizeof(WmiGuidList) /
        sizeof(WMIGUIDREGINFO);
    ASSERT (NUMBER_OF_WMI_GUIDS == Extension->WmiLibInfo.GuidCount);
    Extension->WmiLibInfo.GuidList = WmiGuidList;
    Extension->WmiLibInfo.QueryWmiRegInfo = AgpQueryWmiRegInfo;
    Extension->WmiLibInfo.QueryWmiDataBlock = AgpQueryWmiDataBlock;
    Extension->WmiLibInfo.SetWmiDataBlock = AgpSetWmiDataBlock;
    Extension->WmiLibInfo.SetWmiDataItem = AgpSetWmiDataItem;
    Extension->WmiLibInfo.ExecuteWmiMethod = NULL;
    Extension->WmiLibInfo.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //
    
    status = IoWMIRegistrationControl(Extension->Self,
                             WMIREG_ACTION_REGISTER
                             );

    //
    // Initialize the Std device data structure
    //
    Globals.AgpCommand = 0;
    Globals.AgpStatus = 0;

    return status;
    
}

NTSTATUS
AgpWmiDeRegistration(
    PTARGET_EXTENSION Extension
)
/*++

Routine Description:

     Inform WMI to remove this DeviceObject from its 
     list of providers. This function also 
     decrements the reference count of the deviceobject.

Arguments:

   Extension - Pointer to our target extension

Return Value:

   STATUS_SUCCESS or error

--*/
{
    PAGED_CODE();

    return IoWMIRegistrationControl(Extension->Self,
                                    WMIREG_ACTION_DEREGISTER
                                    );
}

NTSTATUS
AgpSystemControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )
/*++

Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and call into the WMI system library and let
    it handle this IRP for us.

Arguments:

    DeviceObject - Pointer to our device object

    Irp - Points to the corresponding I/O request packet

Return Value:

   STATUS_SUCCESS or an appropriate error status

--*/
{
    PTARGET_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    PAGED_CODE();
    
    deviceExtension = (PTARGET_EXTENSION) DeviceObject->DeviceExtension;

    status = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            IoSkipCurrentIrpStackLocation (Irp);
            status =
                IoCallDriver(deviceExtension->CommonExtension.AttachedDevice,
                             Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation (Irp);
            status =
                IoCallDriver(deviceExtension->CommonExtension.AttachedDevice,
                             Irp);
            break;
        }        
    }
    
    return(status);
}

NTSTATUS
AgpSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PTARGET_EXTENSION   deviceExtension;
    NTSTATUS            status;

    PAGED_CODE();

    deviceExtension = (PTARGET_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {

    case WMI_AGP_INFORMATION:
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT
                                  );

    return status;
}

NTSTATUS
AgpSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PTARGET_EXTENSION   deviceExtension;
    NTSTATUS            status;

    PAGED_CODE();

    deviceExtension = (PTARGET_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_AGP_INFORMATION:
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT
                                  );

    return status;
}

NTSTATUS
AgpQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PTARGET_EXTENSION   deviceExtension;
    NTSTATUS            status;
    ULONG               size = 0;

    PAGED_CODE();

    ASSERT((InstanceIndex == 0) && (InstanceCount == 1));
    
    deviceExtension = (PTARGET_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_AGP_INFORMATION: {

        AGP_STD_DATA AgpData;

        size = sizeof(AGP_STD_DATA);

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        AgpData.AgpStatus = Globals.AgpStatus;
        AgpData.AgpCommand = Globals.AgpCommand;
        AgpData.ApertureBase = deviceExtension->GartBase;
        AgpData.ApertureLength =
            deviceExtension->GartLengthInPages * PAGE_SIZE;

        *(PAGP_STD_DATA)Buffer = AgpData;

        *InstanceLengthArray = size;

        status = STATUS_SUCCESS;
        break;
    }

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT
                                  );

    return status;
}

NTSTATUS
AgpQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered. 
            
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.               

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is 
        required
                
    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
    PTARGET_EXTENSION deviceExtension;
    PUNICODE_STRING regPath;    
        
    PAGED_CODE();
    
    deviceExtension = DeviceObject->DeviceExtension;
    
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.RegistryPath;
    *Pdo = deviceExtension->PDO;
 
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib\intrface.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    Routines for implementing the AGP_BUS_INTERFACE_STANDARD interface

Author:

    John Vert (jvert) 10/26/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/
#define INITGUID 1
#include "agplib.h"


VOID
AgpLibFlushDcacheMdl(
    PMDL Mdl
    );

VOID
ApFlushDcache(
    IN PKDPC Dpc,
    IN PKEVENT Event,
    IN PMDL Mdl,
    IN PVOID SystemArgument2
    );

PMDL
AgpCombineMdlList(IN PMDL MdlList);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpInterfaceReference)
#pragma alloc_text(PAGE, AgpInterfaceDereference)
#pragma alloc_text(PAGE, AgpInterfaceReserveMemory)
#pragma alloc_text(PAGE, AgpInterfaceReleaseMemory)
#pragma alloc_text(PAGE, AgpInterfaceSetRate)
#pragma alloc_text(PAGE, AgpInterfaceCommitMemory)
#pragma alloc_text(PAGE, AgpInterfaceFreeMemory)
#pragma alloc_text(PAGE, AgpLibFlushDcacheMdl)
#pragma alloc_text(PAGE, AgpLibAllocatePhysicalMemory)
#pragma alloc_text(PAGE, AgpLibFreeMappedPhysicalMemory)
#pragma alloc_text(PAGE, AgpLibAllocateMappedPhysicalMemory)
#pragma alloc_text(PAGE, AgpCombineMdlList)
#endif


VOID
AgpInterfaceReference(
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    References an interface. Currently a NOP.

Arguments:

    Extension - Supplies the device extension

Return Value:

    None

--*/

{

    PAGED_CODE();

    InterlockedIncrement(&Extension->InterfaceCount);

}


VOID
AgpInterfaceDereference(
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    Dereferences an interface. Currently a NOP.

Arguments:

    Extension - Supplies the device extension

Return Value:

    None

--*/

{

    PAGED_CODE();

    InterlockedDecrement(&Extension->InterfaceCount);

}


NTSTATUS
AgpInterfaceReserveMemory(
    IN PMASTER_EXTENSION Extension,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    )
/*++

Routine Description:

    Reserves memory in the specified aperture

Arguments:

    Extension - Supplies the device extension where physical address space should be reserved.

    NumberOfPages - Supplies the number of pages to reserve.

    MemoryType - Supplies the memory caching type.

    MapHandle - Returns the mapping handle to be used on subsequent calls.

    PhysicalAddress - If present, returns the physical address in the aperture of the reserved 
            space

Return Value:

    NTSTATUS

--*/

{
    PVOID AgpContext;
    NTSTATUS Status;
    PHYSICAL_ADDRESS MemoryBase;
    PAGP_RANGE Range;

    PAGED_CODE();                              

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    Range = ExAllocatePoolWithTag(PagedPool,
                                  sizeof(AGP_RANGE),
                                  'RpgA');
    if (Range == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    Range->CommittedPages = 0;
    Range->NumberOfPages = NumberOfPages;
    Range->Type = MemoryType;

    LOCK_MASTER(Extension);
    Status = AgpReserveMemory(AgpContext,
                              Range);
    UNLOCK_MASTER(Extension);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReserveMemory - reservation of %x pages of type %d failed %08lx\n",
                NumberOfPages,
                MemoryType,
                Status));
    } else {
        AGPLOG(AGP_NOISE,
               ("AgpInterfaceReserveMemory - reserved %x pages of type %d at %I64X\n",
                NumberOfPages,
                MemoryType,
                Range->MemoryBase.QuadPart));
    }

    *MapHandle = Range;
    if (ARGUMENT_PRESENT(PhysicalAddress)) {
        *PhysicalAddress = Range->MemoryBase;
    }
    return(Status);
}


NTSTATUS
AgpInterfaceReleaseMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle
    )
/*++

Routine Description:

    Releases memory in the specified aperture that was previously reserved by
    AgpInterfaceReserveMemory

Arguments:

    Extension - Supplies the device extension where physical address space should be reserved.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range;
    PVOID AgpContext;
    NTSTATUS Status;
    PHYSICAL_ADDRESS MemoryBase;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);
    Range = (PAGP_RANGE)MapHandle;

    LOCK_MASTER(Extension);
    //
    // Make sure the range is empty
    //
    ASSERT(Range->CommittedPages == 0);
    if (Range->CommittedPages != 0) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReleaseMemory - Invalid attempt to release non-empty range %08lx\n",
                Range));
        UNLOCK_MASTER(Extension);
        return(STATUS_INVALID_PARAMETER);
    }

    AGPLOG(AGP_NOISE,
           ("AgpInterfaceReleaseMemory - releasing range %08lx, %lx pages at %08lx\n",
            Range,
            Range->NumberOfPages,
            Range->MemoryBase.QuadPart));
    Status = AgpReleaseMemory(AgpContext,
                              Range);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReleaseMemory - release failed %08lx\n",
                Status));
    }
    UNLOCK_MASTER(Extension);
    ExFreePool(Range);
    return(Status);
}


NTSTATUS
AgpInterfaceCommitMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Commits memory into the specified aperture that was previously reserved by
    AgpInterfaceReserveMemory

Arguments:

    Extension - Supplies the device extension where physical address space should
        be committed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be committed.

    OffsetInPages - Supplies the offset, in pages, into the aperture reserved by
        AgpInterfaceReserveMemory

    Mdl - Returns the MDL describing the pages of memory committed.

    MemoryBase - Returns the physical memory address of the committed memory.

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PMDL NewMdl;
    PVOID AgpContext;
    NTSTATUS Status=STATUS_SUCCESS;
    ULONG RunLength, RunOffset;
    ULONG CurrentLength, CurrentOffset;
    PMDL FirstMdl=NULL;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(NumberOfPages <= Range->NumberOfPages);
    ASSERT(NumberOfPages > 0);
    ASSERT((Mdl == NULL) || (Mdl->ByteCount == PAGE_SIZE * NumberOfPages));

    CurrentLength = NumberOfPages;
    CurrentOffset = OffsetInPages;

    LOCK_MASTER(Extension);
    do {

        //
        // Save ourselves the trouble...
        //
        if (!(CurrentLength > 0)) {
            break;
        }

        //
        // Find the first free run in the supplied range.
        //
        AgpFindFreeRun(AgpContext,
                       Range,
                       CurrentLength,
                       CurrentOffset,
                       &RunLength,
                       &RunOffset);

        if (RunLength > 0) {
            ASSERT(RunLength <= CurrentLength);
            ASSERT(RunOffset >= CurrentOffset);
            ASSERT(RunOffset < CurrentOffset + CurrentLength);
            ASSERT(RunOffset + RunLength <= CurrentOffset + CurrentLength);

            //
            // Compute the next offset and length
            //
            CurrentLength -= (RunOffset - CurrentOffset) + RunLength;
            CurrentOffset = RunOffset + RunLength;

            //
            // Get an MDL from memory management big enough to map the 
            // requested range.
            //

            NewMdl = AgpLibAllocatePhysicalMemory(AgpContext, RunLength * PAGE_SIZE);
            
            //
            // This can fail in two ways, either no memory is available at all (NewMdl == NULL)
            // or some pages were available, but not enough. (NewMdl->ByteCount < Length)
            //
            if (NewMdl == NULL) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceReserveMemory - Couldn't allocate pages for %lx bytes\n",
                        RunLength));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            } else if (BYTES_TO_PAGES(NewMdl->ByteCount) < RunLength) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceCommitMemory - Only allocated enough pages for %lx of %lx bytes\n",
                        NewMdl->ByteCount,
                        RunLength));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                MmFreePagesFromMdl(NewMdl);
                break;
            }

            //
            // Now that we have our MDL, we can map this into the specified
            // range.
            //
            if (AgpFlushPages != NULL) {
                if (!NT_SUCCESS((AgpFlushPages)(AgpContext, NewMdl))) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    MmFreePagesFromMdl(NewMdl);
                    break;
                }
            } else {
                AgpLibFlushDcacheMdl(NewMdl);
            }
            Status = AgpMapMemory(AgpContext,
                                  Range,
                                  NewMdl,
                                  RunOffset,
                                  MemoryBase);
            if (!NT_SUCCESS(Status)) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceCommitMemory - AgpMapMemory for Mdl %08lx in range %08lx failed %08lx\n",
                        NewMdl,
                        Range,
                        Status));
                MmFreePagesFromMdl(NewMdl);
                break;
            }
            Range->CommittedPages += RunLength;

            //
            // Add this MDL to our list of allocated MDLs for cleanup
            // If we need to cleanup, we will also need to know the page offset
            // so that we can unmap the memory. Stash that value in the ByteOffset
            // field of the MDL (ByteOffset is always 0 for our MDLs)
            //
            NewMdl->ByteOffset = RunOffset;
            NewMdl->Next = FirstMdl;
            FirstMdl = NewMdl;
        }

    } while (RunLength > 0);

    //
    // Cleanup the MDLs. If the allocation failed, we need to
    // unmap them and free the pages and the MDL itself. If the
    // operation completed successfully, we just need to free the
    // MDL.
    //
    while (FirstMdl) {
        NewMdl = FirstMdl;
        FirstMdl = NewMdl->Next;
        if (!NT_SUCCESS(Status)) {

            //
            // Unmap the memory that was mapped. The ByteOffset field
            // of the MDL is overloaded here to store the offset in pages
            // into the range.
            //
            AgpUnMapMemory(AgpContext,
                           Range,
                           NewMdl->ByteCount / PAGE_SIZE,
                           NewMdl->ByteOffset);
            NewMdl->ByteOffset = 0;
            Range->CommittedPages -= NewMdl->ByteCount / PAGE_SIZE;
            MmFreePagesFromMdl(NewMdl);
        }
        ExFreePool(NewMdl);
    }

    if (NT_SUCCESS(Status)) {

        if (Mdl) {
            //
            // Get the MDL that describes the entire mapped range.
            //
            AgpGetMappedPages(AgpContext,
                              Range,
                              NumberOfPages,
                              OffsetInPages,
                              Mdl);
        }

        MemoryBase->QuadPart = Range->MemoryBase.QuadPart + OffsetInPages * PAGE_SIZE;
    }

    UNLOCK_MASTER(Extension);
    return(Status);
}


NTSTATUS
AgpInterfaceFreeMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Frees memory previously committed by AgpInterfaceCommitMemory

Arguments:

    Extension - Supplies the device extension where physical address space should
        be freed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be freed.

    OffsetInPages - Supplies the start of the range to be freed.

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PVOID AgpContext;
    NTSTATUS Status;
    PMDL FreeMdl;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(OffsetInPages < Range->NumberOfPages);
    ASSERT(OffsetInPages + NumberOfPages <= Range->NumberOfPages);
    //
    // Make sure the supplied address is within the reserved range
    //
    if ((OffsetInPages >= Range->NumberOfPages) ||
        (OffsetInPages + NumberOfPages > Range->NumberOfPages)) {
        AGPLOG(AGP_WARNING,
               ("AgpInterfaceFreeMemory - Invalid free of %x pages at offset %x from range %I64X (%x pages)\n",
                NumberOfPages,
                OffsetInPages,
                Range->MemoryBase.QuadPart,
                Range->NumberOfPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Allocate an MDL big enough to contain the pages to be unmapped.
    //
    FreeMdl =
        IoAllocateMdl(NULL, NumberOfPages * PAGE_SIZE, FALSE, TRUE, NULL);
    
    if (FreeMdl == NULL) {

        //
        // This is kind of a sticky situation. We can't allocate the memory
        // that we need to free up some memory! I guess we could have a small
        // MDL on our stack and free things that way.
        //
        // John Vert (jvert) 11/11/1997
        // implement this
        //
        ASSERT(FreeMdl != NULL);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    LOCK_MASTER(Extension);

    //
    // Get the MDL that describes the entire mapped range
    //
    AgpGetMappedPages(AgpContext, 
                      Range,
                      NumberOfPages,
                      OffsetInPages,
                      FreeMdl);
    //
    // Unmap the memory
    //
    Status = AgpUnMapMemory(AgpContext,
                            Range,
                            NumberOfPages,
                            OffsetInPages);
    UNLOCK_MASTER(Extension);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceFreeMemory - UnMapMemory for %x pages at %I64X failed %08lx\n",
                NumberOfPages,
                Range->MemoryBase.QuadPart + OffsetInPages * PAGE_SIZE,
                Status));
    } else {
        //
        // Free the pages
        //
        MmFreePagesFromMdl(FreeMdl);
        ASSERT(Range->CommittedPages >= NumberOfPages);
        Range->CommittedPages -= NumberOfPages;
    }

    //
    // Free the MDL we allocated.
    //
    IoFreeMdl(FreeMdl);
    return(Status);
}

NTSTATUS
AgpInterfaceGetMappedPages(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped backing the specified range.

Arguments:

    Extension - Supplies the device extension where physical address space should
        be freed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the rangion

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PVOID AgpContext;
    NTSTATUS Status;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(NumberOfPages <= Range->NumberOfPages);
    ASSERT(NumberOfPages > 0);
    ASSERT(OffsetInPages < Range->NumberOfPages);
    ASSERT(OffsetInPages + NumberOfPages <= Range->NumberOfPages);
    ASSERT(Mdl->ByteCount == PAGE_SIZE * NumberOfPages);

    //
    // Make sure the supplied address is within the reserved range
    //
    if ((OffsetInPages >= Range->NumberOfPages) ||
        (OffsetInPages + NumberOfPages > Range->NumberOfPages)) {
        AGPLOG(AGP_WARNING,
               ("AgpInterfaceGetMappedPages - Invalid 'get' of %x pages at offset %x from range %I64X (%x pages)\n",
                NumberOfPages,
                OffsetInPages,
                Range->MemoryBase.QuadPart,
                Range->NumberOfPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Get the MDL that describes the entire mapped range
    //
    LOCK_MASTER(Extension);

    AgpGetMappedPages(AgpContext, 
                      Range,
                      NumberOfPages,
                      OffsetInPages,
                      Mdl);

    UNLOCK_MASTER(Extension);
    return(STATUS_SUCCESS);
}


PMDL
AgpLibAllocatePhysicalMemory(IN PVOID AgpContext, IN ULONG TotalBytes)
/*++

Routine Description:

    Allocates a set of physical memory pages for use by the AGP driver.
    
    This routine uses MmAllocatePagesForMdl to attempt to allocate
    as many of the pages as possible within favored AGP memory
    ranges (if any).

Arguments:

    AgpContext   - The AgpContext

    TotalBytes   - The total amount of bytes to allocate.

Return Value:

    An MDL that describes the allocated physical pages or NULL
    if this function is unsuccessful. 
    
    NOTE: Just like MmAllocatePagesForMdl, this function can return
    an MDL that describes an allocation smaller than TotalBytes in size.

--*/
{
   PHYSICAL_ADDRESS ZeroAddress, MaxAddress;
   PMDL MdlList = NULL, NewMdl = NULL;
   PTARGET_EXTENSION Extension;
   ULONG i, PagesNeeded;

   PAGED_CODE();

   AGPLOG(AGP_NOISE, ("AGPLIB: Attempting to allocate memory = %u pages.\n", 
            BYTES_TO_PAGES(TotalBytes)));

   // Initialize some stuff

   ZeroAddress.QuadPart = 0;
   MAX_MEM(MaxAddress.QuadPart);
   
   AGPLOG(AGP_NOISE, ("AGPLIB: Max memory set to %I64x.\n", MaxAddress.QuadPart));

   GET_TARGET_EXTENSION(Extension, AgpContext);

   // How many pages do we need?

   PagesNeeded = BYTES_TO_PAGES(TotalBytes);

   //
   // Loop through each favored range, attempting to allocate
   // as much as possible from that range within the bounds
   // of what we actually need.
   //

   for (i = 0; i < Extension->FavoredMemory.NumRanges; i++) {
      AGPLOG(AGP_NOISE, 
             ("AGPLIB: Trying to allocate %u pages from range %I64x - %I64x.\n",
               PagesNeeded, 
               Extension->FavoredMemory.Ranges[i].Lower,               
               Extension->FavoredMemory.Ranges[i].Upper));      

      NewMdl = MmAllocatePagesForMdl(Extension->FavoredMemory.Ranges[i].Lower,
                                     Extension->FavoredMemory.Ranges[i].Upper,
                                     ZeroAddress,                                     
                                     PagesNeeded << PAGE_SHIFT);
      if (NewMdl) {
         AGPLOG(AGP_NOISE, ("AGPLIB: %u pages allocated in range.\n",
                  NewMdl->ByteCount >> PAGE_SHIFT));
         
         PagesNeeded -= BYTES_TO_PAGES(NewMdl->ByteCount);
         
         //
         // Build a list of the MDls used
         // for each range-based allocation
         //

         NewMdl->Next = MdlList;
         MdlList = NewMdl;

         // Stop allocating if we are finished.

         if (PagesNeeded == 0) break;
         

      } else {
         AGPLOG(AGP_NOISE, ("AGPLIB: NO pages allocated in range.\n"));
      }
      
   }

   //
   // Attempt to allocate from ALL of physical memory
   // if we could not complete our allocation with only
   // the favored memory ranges.
   //

   if (PagesNeeded > 0) {

      AGPLOG(AGP_NOISE, ("AGPLIB: Global Memory allocation for %u pages.\n", 
               PagesNeeded));

      NewMdl = MmAllocatePagesForMdl(ZeroAddress,
                                     MaxAddress,
                                     ZeroAddress,
                                     PagesNeeded << PAGE_SHIFT);
      if (NewMdl) {

         AGPLOG(AGP_NOISE, ("AGPLIB: Good Global Memory Alloc for %u pages.\n",
                  NewMdl->ByteCount >> PAGE_SHIFT));

         //
         // Add this MDL to the list as well
         //

         NewMdl->Next = MdlList;
         MdlList = NewMdl;
      } else {

         AGPLOG(AGP_NOISE, ("AGPLIB: Failed Global Memory Alloc.\n"));

      }

   }

   // We now have a list of Mdls in MdlList that give us the best
   // possible memory allocation taking favored ranges into account.

   // What we now need to do is combine this Mdl list into one mdl.

   NewMdl = AgpCombineMdlList(MdlList);

   if (!NewMdl && MdlList) {
      AGPLOG(AGP_WARNING, ("AGPLIB: Could not combine MDL List!\n"));

      // This is bad. The mdl list could not be combined probably 
      // because a large enough mdl could not be allocated for 
      // the combination.

      // This is not the end of the world however, since the mdl list
      // is not modified until its combination has succeeded so we 
      // still have a valid list. But we need it in one Mdl, so 
      // we just fall back to the simplest allocation strategy
      // we have available:

      // 1. Destroy the list and all of its allocations.
      
      while(MdlList)
      {
         MmFreePagesFromMdl(MdlList);
         NewMdl = MdlList->Next;
         ExFreePool(MdlList);
         MdlList = NewMdl;
      }

      // 2. Allocate a single Mdl with our pages without regard
      // for favored memory ranges. 

      NewMdl = MmAllocatePagesForMdl(ZeroAddress, 
                                     MaxAddress,
                                     ZeroAddress,
                                     TotalBytes);

   }

   return NewMdl;

   
}

PMDL
AgpCombineMdlList(IN PMDL MdlList)
/*++

Routine Description:

    Combines a list of MDLs that describe some set of physical memory
    pages into a single MDL that describes the same set of pages.
    
    The MDLs in the list should be of the type produced by
    MmAllocatePagesForMdl (i.e. MDLs that are useful for nothing more
    than as an array of PFNs)

    This function is used by AgpLibAllocatePhysicalMemory in order
    to combine its multiple range-based allocations into 1 MDL.
    
Arguments:

    MdlList - A list of MDLs to be combines

Return Value:

    A single MDL that describes the same set of physical pages as
    the MDLs in MdlList or NULL if this function is unsuccessful.
    
    NOTE: This function will deallocate the Mdls in MdlList if it
    is successful. If it is unsuccessful, however, it will leave
    the MdlList intact.

--*/
{
   PMDL NewMdl = NULL, Mdl, MdlTemp;
   ULONG Pages = 0;
   PPFN_NUMBER NewPageArray, PageArray;

   ULONG i; // for debugging only

   PAGED_CODE();

   if ((MdlList == NULL) || (MdlList->Next == NULL)) {

      // List of 0 or 1 elements, no need for this 
      // function to do anything.

      return MdlList;
   }

   // Calculate the number of pages spanned by this MdlList.

   for(Mdl = MdlList; Mdl; Mdl = Mdl->Next)
      Pages += BYTES_TO_PAGES(Mdl->ByteCount);

   // Allocate a new Mdl of the proper size.

   NewMdl = IoAllocateMdl(NULL, Pages << PAGE_SHIFT, FALSE, TRUE, NULL);

   if (!NewMdl) {

      // Chances are that the system will bugcheck before
      // this actually happens ... but whatever.

      return NULL;
   }

   // Run through the mdl list, combining the mdls found
   // into a new mdl.

   //
   // First, get a pointer to the PFN array of the new Mdl
   //

   NewPageArray = MmGetMdlPfnArray(NewMdl);

   for(Mdl = MdlList; Mdl; Mdl = Mdl->Next)
   {
      // Get a pointer to the physical page number array in this Mdl.

      PageArray = MmGetMdlPfnArray(Mdl);
      Pages = BYTES_TO_PAGES(Mdl->ByteCount);

      // Copy this array into a proper slot in the array area of the new Mdl.

      RtlCopyMemory((PVOID)NewPageArray, 
                    (PVOID)PageArray,
                    sizeof(PFN_NUMBER) * Pages);

      // Adjust new array slot pointer appropriately for the next copy

      NewPageArray += Pages;
         
   }

   // The list has been combined, now we need to destroy the Mdls
   // in the list.

   Mdl = MdlList;
   while(Mdl)
   {
      MdlTemp = Mdl->Next;
      ExFreePool(Mdl);
      Mdl = MdlTemp;
   }

   // All done. Return the new combined Mdl.

   return NewMdl;
}

VOID
AgpLibFreeMappedPhysicalMemory(
    IN PVOID Addr,
    IN ULONG Length
    )
/*++

Routine Description:

Arguments:

    Addr - The virtual address of the allocation

    Length - Length of allocation in bytes

Return Value:

    None

--*/
{
    ULONG Index;
    PMDL FreeMdl;
    ULONG Pages;
    PPFN_NUMBER Page;

    PAGED_CODE();

    //
    // Allocate an MDL big enough to contain the pages to be unmapped
    //
    FreeMdl = IoAllocateMdl(Addr, Length, FALSE, TRUE, NULL);
    
    //
    // We could not allocate a MDL to free memory, we will free one page at
    // a time using a MDL on our stack
    //
    if (FreeMdl == NULL) {
        PCCHAR VAddr;
        MDL MdlBuf[2]; // NOTE: We use this second MDL to store a
                       //       single PFN_NUMBER

        ASSERT(sizeof(PFN_NUMBER) <= sizeof(MDL));

        FreeMdl = &MdlBuf[0];
        RtlZeroMemory(FreeMdl, 2 * sizeof(MDL));

        Pages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(Addr, Length);
        Page = (PPFN_NUMBER)(FreeMdl + 1);

        //
        // Take care not to create a MDL that spans more than a page
        //
        VAddr = PAGE_ALIGN(Addr);
        for (Index = 0; Index < Pages; Index++) {
            MmInitializeMdl(FreeMdl, VAddr, PAGE_SIZE);
            *Page = (PFN_NUMBER)(MmGetPhysicalAddress(VAddr).QuadPart >>
                                 PAGE_SHIFT);
            MmFreePagesFromMdl(FreeMdl);
            VAddr += PAGE_SIZE;
        }

        return;
    }

    Page = (PPFN_NUMBER)(FreeMdl + 1);
    Pages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(Addr, Length);
    
    //
    // Fill in the PFN array for the MDL
    //
    for (Index = 0; Index < Pages; Index++) {
        *Page++ = (PFN_NUMBER)(MmGetPhysicalAddress((PCCHAR)Addr + (Index * PAGE_SIZE)).QuadPart >> PAGE_SHIFT);
    }

    MmFreePagesFromMdl(FreeMdl);
    IoFreeMdl(FreeMdl);
}


PVOID
AgpLibAllocateMappedPhysicalMemory(IN PVOID AgpContext, IN ULONG TotalBytes)
/*++

Routine Description:

    Same as AgpLibAllocatePhysicalMemory, except this function will
    also map the allocated memory to a virtual address.

Arguments:

    Same as AgpLibAllocatePhysicalMemory.

Return Value:

    A virtual address of the allocated memory or NULL if unsuccessful.

--*/
{
   PMDL Mdl;
   PVOID Ret;

   PAGED_CODE();
   
   AGPLOG(AGP_NOISE, 
          ("AGPLIB: Attempting to allocate mapped memory = %u.\n", TotalBytes));

   //
   // Call the real memory allocator.
   //
   
   Mdl = AgpLibAllocatePhysicalMemory(AgpContext, TotalBytes);

   // Two possible failures 

   // 1. MDL is NULL. No memory could be allocated.

   if (Mdl == NULL) {

      AGPLOG(AGP_WARNING, ("AGPMAP: Could not allocate anything.\n"));

      return NULL;
   }

   // 2. MDL has some pages allocated but not enough.

   if (Mdl->ByteCount < TotalBytes) {

      AGPLOG(AGP_WARNING, ("AGPMAP: Could not allocate enough.\n"));

      MmFreePagesFromMdl(Mdl);
      ExFreePool(Mdl);
      return NULL;
   }

   // Ok. Our allocation succeeded. Map it to a virtual address.
   
   // Step 1: Map the locked Pages. (will return NULL if failed)

   Mdl->MdlFlags |= MDL_PAGES_LOCKED;
   Ret = MmMapLockedPagesSpecifyCache (Mdl,
                                         KernelMode,
                                         MmNonCached,
                                         NULL,
                                         FALSE,
                                         HighPagePriority);

   // Don't need the Mdl anymore, whether we succeeded or failed. 

   ExFreePool(Mdl);

   if (Ret == NULL) {
      AGPLOG(AGP_WARNING, ("AGPMAP: Could not map.\n"));
   } 

   return Ret;
}

#if defined (_X86_)
#define FLUSH_DCACHE(Mdl) __asm{ wbinvd }
#else
#define FLUSH_DCACHE(Mdl)   \
            AGPLOG(AGP_CRITICAL,    \
                   ("AgpLibFlushDcacheMdl - NEED TO IMPLEMENT DCACHE FLUSH FOR THIS ARCHITECTURE!!\n"))
#endif


VOID
AgpLibFlushDcacheMdl(
    PMDL Mdl
    )
/*++

Routine Description:

    Flushes the specified MDL from the D-caches of all processors
    in the system.

    Current algorithm is to set the current thread's affinity to each 
    processor in turn and flush the dcache. This could be made a lot
    more efficient if this turns out to be a hot codepath
    
Arguments:

    Mdl - Supplies the MDL to be flushed.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    KAFFINITY Processors;
    UCHAR Number;
    KEVENT Event;
    KDPC Dpc;

    PAGED_CODE();
    Processors = KeQueryActiveProcessors();
    //
    // Quick out for the UP case.
    //
    if (Processors == 1) {
        FLUSH_DCACHE(Mdl);
        return;
    }

    //
    // We will invoke a DPC on each processor. That DPC will flush the cache,
    // set the event and return. 
    //
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    Number = 0;
    while (Processors) {
        if (Processors & 1) {
            //
            // Initialize the DPC and set it to run on the specified
            // processor.
            //
            KeInitializeDpc(&Dpc,ApFlushDcache, &Event);
            KeSetTargetProcessorDpc(&Dpc, Number);

            //
            // Queue the DPC and wait for it to finish its work.
            //
            KeClearEvent(&Event);
            KeInsertQueueDpc(&Dpc, Mdl, NULL);
            KeWaitForSingleObject(&Event, 
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        Processors = Processors >> 1;
        ++Number;
    }
}



VOID
ApFlushDcache(
    IN PKDPC Dpc,
    IN PKEVENT Event,
    IN PMDL Mdl,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    DPC which executes on each processor in turn to flush the
    specified MDL out of the dcache on each.

Arguments:

    Dpc - supplies the DPC object

    Event - Supplies the event to signal when the DPC is complete

    Mdl - Supplies the MDL to be flushed from the dcache

Return Value:

    None

--*/

{
    FLUSH_DCACHE(Mdl);
    KeSetEvent(Event, 0, FALSE);
}


NTSTATUS
AgpInterfaceSetRate(
    IN PMASTER_EXTENSION Extension,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    Extension - Supplies the device extension

    AgpRate - Rate to set

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    ULONGLONG DeviceFlags = 0;

    PAGED_CODE();

    switch (AgpRate) {
        case PCI_AGP_RATE_1X:
            DeviceFlags = AGP_FLAG_SET_RATE_1X;
            break;
        case PCI_AGP_RATE_2X:
            DeviceFlags = AGP_FLAG_SET_RATE_2X;
            break;
        case PCI_AGP_RATE_4X:
            DeviceFlags = AGP_FLAG_SET_RATE_4X;
            break;
        case 8:
            DeviceFlags = AGP_FLAG_SET_RATE_8X;
            break;
    }

    if (DeviceFlags != 0) {
        return AgpSpecialTarget(GET_AGP_CONTEXT_FROM_MASTER(Extension),
                                DeviceFlags);
    }

    return STATUS_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib3\utils.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains assorted utility functions for PCI.SYS.

Author:

    Peter Johnston (peterj)  20-Nov-1996

Revision History:

    Eric Nelson (enelson)  20-Mar-2000 - kidnap registry function

--*/

#include "agplib.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpOpenKey)
#pragma alloc_text(PAGE, AgpStringToUSHORT)
#endif


ULONGLONG
AgpGetDeviceFlags(
    IN PAGP_HACK_TABLE_ENTRY AgpHackTable,
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN UCHAR  RevisionID
    )
/*++

Description:

    Look in the registry for any flags for this VendorId/DeviceId.

Arguments:

    VendorId      PCI Vendor ID (16 bits) of the manufacturer of the
                  device.

    DeviceId      PCI Device ID (16 bits) of the device.

    SubVendorID   PCI SubVendorID representing the manufacturer of the
                  subsystem

    SubSystemID   PCI SubSystemID representing subsystem

    RevisionID    PCI Revision denoting the revision of the device

Return Value:

    64 bit flags value or 0 if not found.

--*/
{
    PAGP_HACK_TABLE_ENTRY current;
    ULONGLONG hackFlags = 0;
    ULONG match, bestMatch = 0;

    if (AgpHackTable == NULL) {
        return hackFlags;
    }

    // 
    // We want to do a best-case match:
    // VVVVDDDDSSSSssssRR
    // VVVVDDDDSSSSssss
    // VVVVDDDDRR
    // VVVVDDDD
    //
    // List is currently unsorted, so keep updating current best match.
    //

    for (current = AgpHackTable; current->VendorID != 0xFFFF; current++) {
        match = 0;

        //
        // Must at least match vendor/dev
        //

        if ((current->DeviceID != DeviceID) ||
            (current->VendorID != VendorID)) {
            continue;
        }

        match = 1;

        //
        // If this entry specifies a revision, check that it is consistent.
        // 

        if (current->Flags & AGP_HACK_FLAG_REVISION) {
            if (current->RevisionID == RevisionID) {
                match += 2;
            } else {
                continue;
            }
        }

        //
        // If this entry specifies subsystems, check that they are consistent
        //

        if (current->Flags & AGP_HACK_FLAG_SUBSYSTEM) {
            if (current->SubVendorID == SubVendorID &&
                current->SubSystemID == SubSystemID) {
                match += 4;
            } else {
                continue;
            }
        }

        if (match > bestMatch) {
            bestMatch = match;
            hackFlags = current->DeviceFlags;
        }
    }

    return hackFlags;
}



BOOLEAN
AgpOpenKey(
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    OUT PHANDLE Handle,
    OUT PNTSTATUS Status
    )
/*++

Description:

    Open a registry key.

Arguments:

    KeyName      Name of the key to be opened.
    ParentHandle Pointer to the parent handle (OPTIONAL)
    Handle       Pointer to a handle to recieve the opened key.

Return Value:

    TRUE is key successfully opened, FALSE otherwise.

--*/
{
    UNICODE_STRING    nameString;
    OBJECT_ATTRIBUTES nameAttributes;
    NTSTATUS localStatus;

    PAGED_CODE();

    RtlInitUnicodeString(&nameString, KeyName);

    InitializeObjectAttributes(&nameAttributes,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               ParentHandle,
                               (PSECURITY_DESCRIPTOR)NULL
                               );
    localStatus = ZwOpenKey(Handle,
                            KEY_READ,
                            &nameAttributes
                            );

    if (Status != NULL) {

        //
        // Caller wants underlying status.
        //

        *Status = localStatus;
    }

    //
    // Return status converted to a boolean, TRUE if
    // successful.
    //

    return NT_SUCCESS(localStatus);
}



BOOLEAN
AgpStringToUSHORT(
    IN PWCHAR String,
    OUT PUSHORT Result
    )
/*++

Description:

    Takes a 4 character hexidecimal sting and converts it into a USHORT.

Arguments:

    String - the string

    Result - the USHORT

Return Value:

    TRUE is success, FASLE otherwise

--*/
{
    ULONG count;
    USHORT number = 0;
    PWCHAR current;

    current = String;

    for (count = 0; count < 4; count++) {

        number <<= 4;

        if (*current >= L'0' && *current <= L'9') {
            number |= *current - L'0';
        } else if (*current >= L'A' && *current <= L'F') {
            number |= *current + 10 - L'A';
        } else if (*current >= L'a' && *current <= L'f') {
            number |= *current + 10 - L'a';
        } else {
            return FALSE;
        }

        current++;
    }

    *Result = number;
    return TRUE;
}



ULONG_PTR
AgpExecuteCriticalSystemRoutine(
    IN ULONG_PTR Context
    )
/*++

Routine Description:

    This routine is called in the context of KeIpiGenericCall, which
    executes it on all processors.  It is used to execute
    a critical routine which needs all processors synchronized, such
    as probing the BARs of a device that could not otherwise be turned off.
    Only one context parameter is allowed in this routine, so it must
    contain both the routine to execute and any context that routine
    requires.

    When this routine is entered, it is guaranteed that all processors will
    already have been targeted with an IPI, and will be running at IPI_LEVEL.
    All processors will either be running this routine, or will be about to
    enter the routine.  No arbitrary threads can possibly be running.  No
    devices can interrupt the execution of this routine, since IPI_LEVEL is
    above all device IRQLs.

    Because this routine runs at IPI_LEVEL, no debug prints, asserts or other
    debugging can occur in this function without hanging MP machines.

Arguments:

    Context - the context passed into the call to KeIpiGenericCall.
        It contains the critical routine to execute, any context required
        in that routine and a gate and a barrier to ensure that the critical
        routine is executed on only one processor, even though this function
        is executed on all processors.

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;
    PAGP_CRITICAL_ROUTINE_CONTEXT routineContext =
        (PAGP_CRITICAL_ROUTINE_CONTEXT)Context;

    Status = STATUS_SUCCESS;

    //
    // The Gate parameter in the routineContext is preinitialized
    // to 1, meaning that the first processor to reach this point
    // in the routine will decrement it to 0, and succeed the if
    // statement.
    //
    if (InterlockedDecrement(&routineContext->Gate) == 0) {

        //
        // This is only executed on one processor.
        //
        Status = (NTSTATUS)routineContext->Routine(routineContext->Extension,
                                                   routineContext->Context
                                                   );

        //
        // Free other processors.
        //
        routineContext->Barrier = 0;

    } else {

        //
        // Wait for gated function to complete.
        //
        do {
        } while (routineContext->Barrier != 0);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib3\agplib.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    agplib.h

Abstract:

    Private header file for the common AGP library

Author:

    John Vert (jvert) 10/22/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/
#include "agp.h"
#include "wdmguid.h"
#include "wmilib.h"
#include <devioctl.h>
#include <acpiioct.h>

//
// regstr.h uses things of type WORD, which isn't around in kernel mode.
//

#define _IN_KERNEL_

#include "regstr.h"

#define AGP_HACK_FLAG_SUBSYSTEM 0x01
#define AGP_HACK_FLAG_REVISION  0x02

typedef struct _AGP_HACK_TABLE_ENTRY {
    USHORT VendorID;
    USHORT DeviceID;
    USHORT SubVendorID;
    USHORT SubSystemID;
    ULONGLONG DeviceFlags;
    UCHAR   RevisionID;
    UCHAR   Flags;
} AGP_HACK_TABLE_ENTRY, *PAGP_HACK_TABLE_ENTRY;

extern PAGP_HACK_TABLE_ENTRY AgpDeviceHackTable;
extern PAGP_HACK_TABLE_ENTRY AgpGlobalHackTable;

typedef
ULONG_PTR
(*PCRITICALROUTINE)(
    IN PVOID Extension,
    IN PVOID Context
    );

typedef struct _AGP_CRITICAL_ROUTINE_CONTEXT {

    volatile LONG Gate;
    volatile LONG Barrier;

    PCRITICALROUTINE Routine;
    PVOID Extension;
    PVOID Context;

} AGP_CRITICAL_ROUTINE_CONTEXT, *PAGP_CRITICAL_ROUTINE_CONTEXT;

//
// Define common device extension
//
typedef enum _AGP_EXTENSION_TYPE {
    AgpTargetFilter,
    AgpMasterFilter
} AGP_EXTENSION_TYPE;

#define TARGET_SIG 'TpgA'
#define MASTER_SIG 'MpgA'

typedef struct _COMMON_EXTENSION {
    ULONG               Signature;
    BOOLEAN             Deleted;
    AGP_EXTENSION_TYPE  Type;
    PDEVICE_OBJECT      AttachedDevice;
    BUS_INTERFACE_STANDARD BusInterface;
} COMMON_EXTENSION, *PCOMMON_EXTENSION;

// Structures to maintain a list of "favored" memory ranges
// for AGP allocation.

typedef struct _AGP_MEMORY_RANGE
{
   PHYSICAL_ADDRESS Lower;
   PHYSICAL_ADDRESS Upper;
} AGP_MEMORY_RANGE, *PAGP_MEMORY_RANGE;

typedef struct _AGP_FAVORED_MEMORY
{
   ULONG NumRanges;
   PAGP_MEMORY_RANGE Ranges;
} AGP_FAVORED_MEMORY;

//
// WMI data types
//
#define AGP_WMI_STD_DATA_GUID \
    { 0x8c27fbed, 0x1c7b, 0x47e4, 0xa6, 0x49, 0x0e, 0x38, 0x9d, 0x3a, 0xda, 0x4f }

typedef struct _AGP_STD_DATA {
    PHYSICAL_ADDRESS   ApertureBase;
    ULONG              ApertureLength;
    ULONG              AgpStatus;
    ULONG              AgpCommand;
} AGP_STD_DATA, *PAGP_STD_DATA;


//
// Redirected functions for different flavors of resource handling
//
typedef struct _TARGET_EXTENSION *PTARGET_EXTENSION;

typedef
NTSTATUS
(*PAGP_RESOURCE_FILTER_ROUTINE)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

typedef
NTSTATUS
(*PAGP_START_TARGET_ROUTINE)(
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

typedef struct _TARGET_EXTENSION {
    COMMON_EXTENSION            CommonExtension;
    PFAST_MUTEX                 Lock;
    struct _MASTER_EXTENSION    *ChildDevice;
    PCM_RESOURCE_LIST           Resources;
    PCM_RESOURCE_LIST           ResourcesTranslated;
    AGP_FAVORED_MEMORY          FavoredMemory;
    PHYSICAL_ADDRESS            GartBase;
    ULONG                       GartLengthInPages;
    ULONG                       Agp3BridgeResourceIndex;
    PAGP_START_TARGET_ROUTINE    StartTarget;
    PAGP_RESOURCE_FILTER_ROUTINE FilterResourceRquirements;
    PDEVICE_OBJECT              PDO;
    PDEVICE_OBJECT              Self;
    WMILIB_CONTEXT              WmiLibInfo;
    
    //
    // This must be last, d'oh!
    //
    ULONGLONG                   AgpContext;
} TARGET_EXTENSION, *PTARGET_EXTENSION;

typedef struct _MASTER_EXTENSION {
    COMMON_EXTENSION    CommonExtension;
    PTARGET_EXTENSION   Target;
    ULONG               Capabilities;
    ULONG               InterfaceCount;         // tracks the number of interfaces handed out
    ULONG               ReservedPages;          // tracks the number of pages reserved in the aperture
    BOOLEAN             StopPending;            // TRUE if we have seen a QUERY_STOP
    BOOLEAN             RemovePending;          // TRUE if we have seen a QUERY_REMOVE
    ULONG               DisableCount;           // non-zero if we are in a state where we cannot service requests
} MASTER_EXTENSION, *PMASTER_EXTENSION;

typedef struct _GLOBALS {
   
    // 
    // Path to the driver's Services Key in the registry
    //
    UNICODE_STRING RegistryPath;

    //
    // Cached target capability settings
    //
    ULONG AgpStatus;
    ULONG AgpCommand;

} GLOBALS;


extern GLOBALS Globals;

//
// The MBAT - used to retrieve "favored" memory ranges from
// the AGP northbridge via an ACPI BANK method
//

#include <pshpack1.h>

typedef struct _MBAT
{
   UCHAR TableVersion;
   UCHAR AgpBusNumber;
   UCHAR ValidEntryBitmap;
   AGP_MEMORY_RANGE DecodeRange[ANYSIZE_ARRAY];
} MBAT, *PMBAT;

#include <poppack.h>

#define MBAT_VERSION 1

#define MAX_MBAT_SIZE sizeof(MBAT) + ((sizeof(UCHAR) * 8) - ANYSIZE_ARRAY) \
                        * sizeof(AGP_MEMORY_RANGE)

#define CM_BANK_METHOD (ULONG)('KNAB')

//
// The highest memory address supported by AGP
//

#define MAX_MEM(_num_) _num_ = 1; \
                       _num_ = _num_*1024*1024*1024*4 - 1

#define RELEASE_BUS_INTERFACE(_ext_) (_ext_)->CommonExtension.BusInterface.InterfaceDereference((_ext_)->CommonExtension.BusInterface.Context)

//
// Macros for getting from the chipset-specific context to our structures
//
#define GET_TARGET_EXTENSION(_target_,_agp_context_)  (_target_) = (CONTAINING_RECORD((_agp_context_),    \
                                                                                      TARGET_EXTENSION,   \
                                                                                      AgpContext));       \
                                                      ASSERT_TARGET(_target_)
#define GET_MASTER_EXTENSION(_master_,_agp_context_)    {                                                       \
                                                            PTARGET_EXTENSION _targetext_;                      \
                                                            GET_TARGET_EXTENSION(_targetext_, (_agp_context_)); \
                                                            (_master_) = _targetext_->ChildDevice;              \
                                                            ASSERT_MASTER(_master_);                            \
                                                        }
#define GET_TARGET_PDO(_pdo_,_agp_context_) {                                                           \
                                                PTARGET_EXTENSION _targetext_;                          \
                                                GET_TARGET_EXTENSION(_targetext_,(_agp_context_));      \
                                                (_pdo_) = _targetext_->CommonExtension.AttachedDevice;  \
                                            }

#define GET_MASTER_PDO(_pdo_,_agp_context_) {                                                           \
                                                PMASTER_EXTENSION _masterext_;                          \
                                                GET_MASTER_EXTENSION(_masterext_, (_agp_context_));     \
                                                (_pdo_) = _masterext_->CommonExtension.AttachedDevice;  \
                                            }

#define GET_AGP_CONTEXT(_targetext_) ((PVOID)(&(_targetext_)->AgpContext))
#define GET_AGP_CONTEXT_FROM_MASTER(_masterext_) GET_AGP_CONTEXT((_masterext_)->Target)

//
// Some debugging macros
//
#define ASSERT_TARGET(_target_) ASSERT((_target_)->CommonExtension.Signature == TARGET_SIG);
//
// We may not have all our context filled out to this point yet...
//
//                                ASSERT((_target_)->ChildDevice->CommonExtension.Signature == MASTER_SIG)
#define ASSERT_MASTER(_master_) ASSERT((_master_)->CommonExtension.Signature == MASTER_SIG); \
                                ASSERT((_master_)->Target->CommonExtension.Signature == TARGET_SIG)

//
// Locking macros
//
#define LOCK_MUTEX(_fm_) ExAcquireFastMutex(_fm_); \
                         ASSERT((_fm_)->Count == 0)

#define UNLOCK_MUTEX(_fm_) ASSERT((_fm_)->Count == 0);  \
                           ExReleaseFastMutex(_fm_)

#define LOCK_TARGET(_targetext_) ASSERT_TARGET(_targetext_); \
                                 LOCK_MUTEX((_targetext_)->Lock)

#define LOCK_MASTER(_masterext_) ASSERT_MASTER(_masterext_); \
                                 LOCK_MUTEX((_masterext_)->Target->Lock)

#define UNLOCK_TARGET(_targetext_) ASSERT_TARGET(_targetext_); \
                                   UNLOCK_MUTEX((_targetext_)->Lock)

#define UNLOCK_MASTER(_masterext_) ASSERT_MASTER(_masterext_); \
                                   UNLOCK_MUTEX((_masterext_)->Target->Lock)

//
// Private resource type definition
//
typedef enum {
    AgpPrivateResource = '0PGA'
} AGP_PRIVATE_RESOURCE_TYPES;

#define JUNK_INDEX 0xBADCEEDE

//
// Define function prototypes
//

//
// Driver and device initialization - init.c
//
NTSTATUS
AgpAttachDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );


//
// IRP Dispatch routines - dispatch.c
//
NTSTATUS
AgpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
AgpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
AgpDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
AgpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
AgpSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

//
// Config space handling routines - config.c
//

#if (WINVER < 0x502)

ULONG
ApLegacyGetBusData(
    IN PVOID Context,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
ApLegacySetBusData(
    IN PVOID Context,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

#endif


NTSTATUS
ApGetExtendedAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN EXTENDED_AGP_REGISTER RegSelect,
    OUT PVOID ExtCapReg
    );

NTSTATUS
ApSetExtendedAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN EXTENDED_AGP_REGISTER RegSelect,
    IN PVOID ExtCapReg
    );

NTSTATUS
ApQueryBusInterface(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PBUS_INTERFACE_STANDARD BusInterface
    );

NTSTATUS
ApQueryAgpTargetBusInterface(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PBUS_INTERFACE_STANDARD BusInterface,
    OUT PUCHAR CapabilityID
    );

//
// Resource handing routines - resource.c
//
NTSTATUS
AgpFilterResourceRequirementsHost(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
Agp3FilterResourceRequirementsBridge(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpQueryResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpStartTarget(
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
Agp3StartTargetBridge(
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpStartTargetHost(
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

VOID
AgpStopTarget(
    IN PTARGET_EXTENSION Extension
    );

//
// AGP Interface functions
//
NTSTATUS
AgpInterfaceSetRate(
    IN PMASTER_EXTENSION Extension,
    IN ULONG AgpRate
    );

VOID
AgpInterfaceReference(
    IN PMASTER_EXTENSION Extension
    );

VOID
AgpInterfaceDereference(
    IN PMASTER_EXTENSION Extension
    );


NTSTATUS
AgpInterfaceReserveMemory(
    IN PMASTER_EXTENSION Extension,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    );

NTSTATUS
AgpInterfaceReleaseMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle
    );

NTSTATUS
AgpInterfaceCommitMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

NTSTATUS
AgpInterfaceFreeMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

NTSTATUS
AgpInterfaceGetMappedPages(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    );

//
// Misc utils.c
//
BOOLEAN
AgpOpenKey(
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    OUT PHANDLE Handle,
    OUT PNTSTATUS Status
    );

BOOLEAN
AgpStringToUSHORT(
    IN PWCHAR String,
    OUT PUSHORT Result
    );

ULONGLONG
AgpGetDeviceFlags(
    IN PAGP_HACK_TABLE_ENTRY AgpHackTable,
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN UCHAR  RevisionID
    );

ULONG_PTR
AgpExecuteCriticalSystemRoutine(
    IN ULONG_PTR Context
    );

//
// wmi.c
//
NTSTATUS
AgpSystemControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
AgpWmiRegistration(
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpWmiDeRegistration(
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
AgpSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
AgpQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    );

NTSTATUS
AgpQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    );

//
// AGP Physical Memory allocator
//
PMDL
AgpLibAllocatePhysicalMemory(
    IN PVOID AgpContext,
    IN ULONG TotalBytes);

//
// Handy structures for mucking about in PCI config space
//

//
// The PCI_COMMON_CONFIG includes the 192 bytes of device specific
// data.  The following structure is used to get only the first 64
// bytes which is all we care about most of the time anyway.  We cast
// to PCI_COMMON_CONFIG to get at the actual fields.
//

typedef struct {
    ULONG Reserved[PCI_COMMON_HDR_LENGTH/sizeof(ULONG)];
} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib3\resource.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Common routines for handling resource requirements

Author:

    John Vert (jvert) 10/25/1997

Revision History:

--*/
#include "agplib.h"

PCM_RESOURCE_LIST
ApSplitResourceList(
    IN PCM_RESOURCE_LIST ResourceList,
    OUT PCM_RESOURCE_LIST *NewResourceList
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpFilterResourceRequirements)
#pragma alloc_text(PAGE, AgpFilterResourceRequirementsHost)
#pragma alloc_text(PAGE, Agp3FilterResourceRequirementsBridge)
#pragma alloc_text(PAGE, AgpStartTarget)
#pragma alloc_text(PAGE, AgpStartTargetHost)
#pragma alloc_text(PAGE, Agp3StartTargetBridge)
#pragma alloc_text(PAGE, ApSplitResourceList)
#endif

static BOOLEAN ResourceConflict = FALSE;


NTSTATUS
AgpFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Dexscription:

    One level of indirection through fuinction pointer for non-performance
    critical filtering of AGP resources during init

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_RESOURCE_REQUIREMENTS Irp

    Extension - Supplies the device extension

Return Value:

   NTASTATUS

--*/
{
    PAGED_CODE();

    return (Extension->FilterResourceRquirements)(DeviceObject,
                                                  Irp,
                                                  Extension);
}


NTSTATUS
Agp3FilterResourceRequirementsBridge(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for IRP_MN_QUERY_RESOURCE_REQUIREMENTS, we filter in the
    alternate AGP bridge resource requirements

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_RESOURCE_REQUIREMENTS Irp

    Extension - Supplies the device extension

Return Value:

    NTSTATUS

--*/
{
    ULONG ApertureSize;
    NTSTATUS Status;
    ULONG AddCount;
    PHYSICAL_ADDRESS CurrentBase;
    ULONG CurrentSizeInPages;
    PIO_RESOURCE_REQUIREMENTS_LIST OldRequirements;
    PIO_RESOURCE_REQUIREMENTS_LIST NewRequirements;
    ULONG NewSize;
    ULONG Alternative;
    PIO_RESOURCE_LIST OldResourceList;
    PIO_RESOURCE_LIST NewResourceList;
    PIO_RESOURCE_DESCRIPTOR Descriptor;
    PIO_STACK_LOCATION IrpSp;
    PIO_RESOURCE_LIST ApertureRequirements = NULL;
    BOOLEAN ResourceFound;
    BOOLEAN NukeAlternative;
    ULONG Index;
    ULONG NewIndex;

    PAGED_CODE();

    AGPLOG(AGP_NOISE,
           ("Agp3QueryResourceRequirementsBridge: IRP %08lx, resource %08lx\n",
            Irp,
            Irp->IoStatus.Information));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Create a new resource requirements list with our alternate aperture
    // settings tacked onto the bridge's BAR
    //
    OldRequirements =
        IrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;
    if (OldRequirements == NULL) {
        //STATUS_INVALID_DEVICE_REQUEST
        // PNP helpfully passes us a NULL pointer instead of an empty
        // resource list when the bridge is disabled. In this case we will
        // ignore this irp and not add on our requirements since they are
        // not going to be used anyway.
        //
        return(STATUS_SUCCESS);
    }

    //
    // Get the current GART aperture.
    //
    Status = AgpQueryAperture(GET_AGP_CONTEXT(Extension),
                              &CurrentBase,
                              &CurrentSizeInPages,
                              &ApertureRequirements);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("Agp3QueryResourceRequirementsBridge: AgpQueryAperture %08lx "
                "failed %08lx\n",
                Extension,
                Status));
        return(Status);
    }

    AGPLOG(AGP_NOISE,
           ("Agp3QueryResourceRequirementsBridge: aperture at %I64x, length "
            "%08lx pages, Requirements %08lx\n",
            CurrentBase.QuadPart,
            CurrentSizeInPages,
            ApertureRequirements));

    //
    // We will add IO_RESOURCE_DESCRIPTORs to each alternative, after the
    // current bridge's BAR
    //

    //
    // Find the AGP bridge BAR's position in the list(s)
    //
    NukeAlternative = FALSE;
    ResourceFound = FALSE;
    OldResourceList = &OldRequirements->List[0];

    for (Alternative = 0; Alternative < OldRequirements->AlternativeLists;
         Alternative++) {

        for (Index = 0; Index < OldResourceList->Count; Index++) {
            Descriptor = &OldResourceList->Descriptors[Index];

            if ((Descriptor->Option == IO_RESOURCE_PREFERRED) &&
                (Descriptor->Type == CmResourceTypeMemory)) {
                
                if (Descriptor->u.Memory.MinimumAddress.QuadPart ==
                    CurrentBase.QuadPart) {

                    Extension->Agp3BridgeResourceIndex = Index;
                    ResourceFound = TRUE;

                    //
                    // Check if PCI already crufted up an alternative
                    // descriptor that we should nuke
                    //
                    if ((Index + 1) < OldResourceList->Count) {
                        Descriptor++;
                        if (Descriptor->Option == IO_RESOURCE_ALTERNATIVE) {
                            NukeAlternative = TRUE;
                        }
                    }
                    break;
                }
            }
        }
        OldResourceList = (PIO_RESOURCE_LIST)(OldResourceList->Descriptors +
                                              OldResourceList->Count);
    }

    //
    // No resource in the list matches our current setting!
    //
    if (!ResourceFound) {
        AGPLOG(AGP_CRITICAL, ("AGP3 bridge misconfigured, please contact "
                              "system manufacturer for a BIOS upgrade.\n"));
        AGP_ASSERT(FALSE);
        return STATUS_INVALID_PARAMETER; // This should be interesting!
    }

    //
    // Again, this should never happen, but if it ever did, then we'd have
    // to exit now...
    //
    if (ApertureRequirements == NULL) {
        return STATUS_SUCCESS;
    }

    NewSize = (NukeAlternative) ?
        OldRequirements->ListSize -
        (OldRequirements->AlternativeLists * sizeof(IO_RESOURCE_DESCRIPTOR)):
        OldRequirements->ListSize;
    NewSize += sizeof(IO_RESOURCE_DESCRIPTOR) *
        (ApertureRequirements->Count * OldRequirements->AlternativeLists);
    
    NewRequirements = ExAllocatePool(PagedPool, NewSize);
    if (NewRequirements == NULL) {
        ExFreePool(ApertureRequirements);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    NewRequirements->ListSize = NewSize;
    NewRequirements->InterfaceType = OldRequirements->InterfaceType;
    NewRequirements->BusNumber = OldRequirements->BusNumber;
    NewRequirements->SlotNumber = OldRequirements->SlotNumber;
    NewRequirements->AlternativeLists = OldRequirements->AlternativeLists;

    //
    // Append our requirement to each alternative resource list.
    //
    NewResourceList = &NewRequirements->List[0];
    OldResourceList = &OldRequirements->List[0];
    for (Alternative = 0; Alternative < OldRequirements->AlternativeLists;
         Alternative++) {

        //
        // Copy the old resource list into the new one.
        //
        NewResourceList->Version = OldResourceList->Version;
        NewResourceList->Revision = OldResourceList->Revision;
        NewResourceList->Count =
            OldResourceList->Count + ApertureRequirements->Count;

        if (NukeAlternative) {
            NewResourceList->Count--;
        }

        Index = 0;
        NewIndex = 0;
        while (Index < OldResourceList->Count) {
            NewResourceList->Descriptors[NewIndex] =
                OldResourceList->Descriptors[Index];

            //
            // This is the AGP bridge BAR, tack on alternatives here
            //
            if (Index == Extension->Agp3BridgeResourceIndex) {
                AGP_ASSERT((NewIndex + ApertureRequirements->Count) <
                           NewResourceList->Count);
                RtlCopyMemory(&NewResourceList->Descriptors[NewIndex + 1],
                              &ApertureRequirements->Descriptors[0],
                              ApertureRequirements->Count *
                              sizeof(IO_RESOURCE_DESCRIPTOR));
                NewIndex += ApertureRequirements->Count;
                
                if (NukeAlternative) {
                    Index++;
                }
            }
            
            Index++;
            NewIndex++;
        }

        //
        // Advance to next resource list
        //
        NewResourceList = (PIO_RESOURCE_LIST)(NewResourceList->Descriptors +
                                              NewResourceList->Count);
        OldResourceList = (PIO_RESOURCE_LIST)(OldResourceList->Descriptors +
                                              OldResourceList->Count);
    }

    AGPLOG(AGP_NOISE,
           ("Agp3QueryResourceRequirementsBridge: IRP %p, old resources %p, "
            "new resources %p\n",
            Irp,
            OldRequirements,
            NewRequirements));

    IrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList =
        NewRequirements;
    Irp->IoStatus.Information = (ULONG_PTR)NewRequirements;
    ExFreePool(OldRequirements);
    ExFreePool(ApertureRequirements);

    return STATUS_SUCCESS;
}



NTSTATUS
AgpFilterResourceRequirementsHost(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for IRP_MN_QUERY_RESOURCE_REQUIREMENTS. This adds on the
    AGP resource requirements.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_RESOURCE_REQUIREMENTS Irp

    Extension - Supplies the device extension

Return Value:

    NTSTATUS

--*/

{
    BOOLEAN SwapDescriptor;
    ULONG SwapLength;
    ULONG ApertureSize;
    NTSTATUS Status;
    ULONG AddCount;
    PHYSICAL_ADDRESS CurrentBase;
    PHYSICAL_ADDRESS MaxAddr;
    ULONG CurrentSizeInPages;
    PIO_RESOURCE_REQUIREMENTS_LIST OldRequirements;
    PIO_RESOURCE_REQUIREMENTS_LIST NewRequirements;
    ULONG NewSize;
    ULONG Alternative;
    PIO_RESOURCE_LIST OldResourceList;
    PIO_RESOURCE_LIST NewResourceList;
    PIO_RESOURCE_DESCRIPTOR Descriptor;
    PIO_STACK_LOCATION IrpSp;
    PIO_RESOURCE_LIST ApertureRequirements = NULL;
    ULONG i;

    PAGED_CODE();

    AGPLOG(AGP_NOISE,
           ("AgpQueryResourceRequirements - IRP %08lx, resource %08lx\n",
            Irp,
            Irp->IoStatus.Information));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Create a new resource requirements list with our current aperture
    // settings tacked on the end.
    //
    OldRequirements = IrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;
    if (OldRequirements == NULL) {
        //STATUS_INVALID_DEVICE_REQUEST
        // PNP helpfully passes us a NULL pointer instead of an empty resource list
        // when the bridge is disabled. In this case we will ignore this irp and not
        // add on our requirements since they are not going to be used anyway.
        //
        return(STATUS_SUCCESS);
    }

    //
    // Get the current GART aperture.
    //
    Status = AgpQueryAperture(GET_AGP_CONTEXT(Extension),
                              &CurrentBase,
                              &CurrentSizeInPages,
                              &ApertureRequirements);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpQueryResourceRequirements - AgpQueryAperture %08lx failed %08lx\n",
                Extension,
                Status));
        return(Status);
    }

    ApertureSize = (CurrentSizeInPages * PAGE_SIZE);
    MaxAddr.QuadPart = CurrentBase.QuadPart + ApertureSize - 1;

    AGPLOG(AGP_NOISE,
           ("AgpQueryResourceRequirements - aperture at %I64x, length %08lx pages, Requirements %08lx\n",
            CurrentBase.QuadPart,
            CurrentSizeInPages,
            ApertureRequirements));

    //
    // We will add IO_RESOURCE_DESCRIPTORs to each alternative.
    //
    // The first one is a private data type marked with our signature. This is
    // a marker so that we know which descriptors are ours so we can remove
    // them later.
    //
    // The second is the actual descriptor for the current aperture settings.
    // This is marked as preferred.
    //
    // Following this is the requirements returned from AgpQueryAperture. These
    // get marked as alternatives.
    //
    AddCount = 2;

    //
    // Enumerate the old list looking for any preferred descriptor that
    // conflicts with our preferred settings; if we find one, then the BIOS
    // is whack, and we will throw out our preferred descriptor, and let PnP
    // choose from our alternates
    //
    ResourceConflict = FALSE;
    OldResourceList = &OldRequirements->List[0];

    for (Alternative = 0; Alternative < OldRequirements->AlternativeLists;
         Alternative++) {

        for (i = 0; i < OldResourceList->Count; i++) {
            Descriptor = &OldResourceList->Descriptors[i];

            if ((Descriptor->Option == IO_RESOURCE_PREFERRED) &&
                (Descriptor->Type == CmResourceTypeMemory)) {
                
                if (((Descriptor->u.Memory.MinimumAddress.QuadPart >=
                      CurrentBase.QuadPart) &&
                     (Descriptor->u.Memory.MinimumAddress.QuadPart <=
                      MaxAddr.QuadPart)) ||
                     ((Descriptor->u.Memory.MaximumAddress.QuadPart >=
                       CurrentBase.QuadPart) &&
                      (Descriptor->u.Memory.MaximumAddress.QuadPart <=
                       MaxAddr.QuadPart)) ||
                    ((Descriptor->u.Memory.MinimumAddress.QuadPart <
                      CurrentBase.QuadPart) &&
                     (Descriptor->u.Memory.MaximumAddress.QuadPart >
                      MaxAddr.QuadPart))) {

                    AGPLOG(AGP_CRITICAL,
                           ("AgpQueryResourceRequirements - Conflicted "
                            "resource detected: %I64X - %I64X\n",
                            Descriptor->u.Memory.MinimumAddress.QuadPart,
                            Descriptor->u.Memory.MaximumAddress.QuadPart));

                    //
                    // This preferred descriptor is in conflic with our AGP
                    // preferred setting
                    //
#if defined(_IA64_)
                    AGPLOG(AGP_CRITICAL, ("Please contact system manufacturer "
                                          "for a BIOS upgrade.\n"));
#else // _IA64_
                    AddCount = 1;
                    ResourceConflict = TRUE;
#endif // _IA64_
                    break;
                }
            }
        }
        OldResourceList = (PIO_RESOURCE_LIST)(OldResourceList->Descriptors +
                                              OldResourceList->Count);
    }

    //
    //
    // For IA64, PnP cannot reassign the aperture base, so we can only use
    // the "preferred" descriptor
    //
    if (ApertureRequirements) {
        AddCount += ApertureRequirements->Count;
    }

    NewSize = OldRequirements->ListSize;
    NewSize += sizeof(IO_RESOURCE_DESCRIPTOR) *
        (AddCount * OldRequirements->AlternativeLists);
    
    NewRequirements = ExAllocatePool(PagedPool, NewSize);
    if (NewRequirements == NULL) {
        if (ApertureRequirements) {
            ExFreePool(ApertureRequirements);
        }
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    NewRequirements->ListSize = NewSize;
    NewRequirements->InterfaceType = OldRequirements->InterfaceType;
    NewRequirements->BusNumber = OldRequirements->BusNumber;
    NewRequirements->SlotNumber = OldRequirements->SlotNumber;
    NewRequirements->AlternativeLists = OldRequirements->AlternativeLists;

    //
    // Append our requirement to each alternative resource list.
    //
    NewResourceList = &NewRequirements->List[0];
    OldResourceList = &OldRequirements->List[0];
    for (Alternative = 0; Alternative < OldRequirements->AlternativeLists; Alternative++) {

        //
        // Copy the old resource list into the new one.
        //
        NewResourceList->Version = OldResourceList->Version;
        NewResourceList->Revision = OldResourceList->Revision;
        NewResourceList->Count = OldResourceList->Count + AddCount;
        RtlCopyMemory(&NewResourceList->Descriptors[0],
                      &OldResourceList->Descriptors[0],
                      OldResourceList->Count * sizeof(IO_RESOURCE_DESCRIPTOR));

        Descriptor = &NewResourceList->Descriptors[OldResourceList->Count];

        //
        // Append the marker descriptor
        //
        Descriptor->Option = 0;
        Descriptor->Flags = 0;
        Descriptor->Type = CmResourceTypeDevicePrivate;
        Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
        Descriptor->u.DevicePrivate.Data[0] = AgpPrivateResource;
        Descriptor->u.DevicePrivate.Data[1] = 1;
        ++Descriptor;

        //
        // Append the new descriptor
        //
        if (!ResourceConflict) {
            Descriptor->Option = IO_RESOURCE_PREFERRED;
            Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE |
                CM_RESOURCE_MEMORY_PREFETCHABLE;
            Descriptor->Type = CmResourceTypeMemory;
            Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
            Descriptor->u.Memory.Length = CurrentSizeInPages * PAGE_SIZE;
            Descriptor->u.Memory.Alignment = CurrentSizeInPages * PAGE_SIZE;
            Descriptor->u.Memory.MinimumAddress = CurrentBase;
            Descriptor->u.Memory.MaximumAddress = MaxAddr;
            ++Descriptor;
        }

        //
        // Append the alternatives
        //
        if (ApertureRequirements) {

            SwapDescriptor = FALSE;
            for (i = 0; i < ApertureRequirements->Count; i++) {
                
                //
                // Make sure this descriptor makes sense
                //
                ASSERT(ApertureRequirements->Descriptors[i].Flags ==
                       (CM_RESOURCE_MEMORY_READ_WRITE |
                        CM_RESOURCE_MEMORY_PREFETCHABLE));
                ASSERT(ApertureRequirements->Descriptors[i].Type ==
                       CmResourceTypeMemory);
                ASSERT(ApertureRequirements->Descriptors[i].ShareDisposition ==
                       CmResourceShareDeviceExclusive);
                
                *Descriptor = ApertureRequirements->Descriptors[i];
                
                //
                // In this case we nuked our preferred descriptor so mark the
                // first alternate as preferred
                //
                if ((i == 0) && ResourceConflict) {
                    
                    Descriptor->Option = IO_RESOURCE_PREFERRED;
                    
                    if (Descriptor->u.Memory.Length != ApertureSize) {
                        SwapLength = Descriptor->u.Memory.Length;
                        Descriptor->u.Memory.Length = ApertureSize;
                        Descriptor->u.Memory.Alignment = ApertureSize;
                        SwapDescriptor = TRUE;
                    }
                    
                } else {
                    Descriptor->Option = IO_RESOURCE_ALTERNATIVE;
                    
                    if (SwapDescriptor) {
                        if (Descriptor->u.Memory.Length == ApertureSize) {
                            Descriptor->u.Memory.Length = SwapLength;
                            Descriptor->u.Memory.Alignment = SwapLength;
                            SwapDescriptor = FALSE;
                        }
                    }
                }
                
                ++Descriptor;
            }
        }

        //
        // Advance to next resource list
        //
        NewResourceList = (PIO_RESOURCE_LIST)(NewResourceList->Descriptors + NewResourceList->Count);
        OldResourceList = (PIO_RESOURCE_LIST)(OldResourceList->Descriptors + OldResourceList->Count);
    }

    AGPLOG(AGP_NOISE,
           ("AgpQueryResourceRequirements - IRP %p, old resources %p, new resources %p\n",
            Irp,
            OldRequirements,
            NewRequirements));
    IrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList = NewRequirements;
    Irp->IoStatus.Information = (ULONG_PTR)NewRequirements;
    ExFreePool(OldRequirements);
    if (ApertureRequirements) {
        ExFreePool(ApertureRequirements);
    }
    return(STATUS_SUCCESS);

}


NTSTATUS
AgpQueryResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for IRP_MN_QUERY_RESOURCES. This adds on the
    AGP resources

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_RESOURCES Irp

    Extension - Supplies the device extension

Return Value:

    NTSTATUS

--*/

{
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    AGPLOG(AGP_NOISE,
           ("AgpQueryResources - IRP %08lx, resource %08lx\n",
            Irp,
            Irp->IoStatus.Information));
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpStartTarget(
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    One level of indirection through fuinction pointer for non-performance
    critical initialization of AGP3 target bridge

Arguments:

    Irp - supplies the IRP_MN_START_DEVICE Irp.

    Extension - Supplies the device extension.

Return Value:

    NTSTATUS

--*/

{
    PAGED_CODE();

    return (Extension->StartTarget)(Irp, Extension);
}


NTSTATUS
AgpStartTargetHost(
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Filters out the AGP-specific resource requirements on a
    IRP_MN_START_DEVICE Irp.

Arguments:

    Irp - supplies the IRP_MN_START_DEVICE Irp.

    Extension - Supplies the device extension.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpSp;
    PCM_RESOURCE_LIST NewResources;
    PCM_RESOURCE_LIST NewResourcesTranslated;
    PCM_RESOURCE_LIST AgpAllocatedResources;
    PCM_RESOURCE_LIST AgpAllocatedResourcesTranslated;
    NTSTATUS Status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    AGPLOG(AGP_NOISE,
           ("AgpStartTargetHost: IRP %08lx, resource %08lx\n",
            Irp,
            Irp->IoStatus.Information));

    if (irpSp->Parameters.StartDevice.AllocatedResources != NULL) {
        KEVENT event;

        //
        // Find our private descriptors and split them out into
        // our own resource list
        //
        Extension->Resources = ApSplitResourceList(irpSp->Parameters.StartDevice.AllocatedResources,
                                                   &NewResources);
        Extension->ResourcesTranslated = ApSplitResourceList(irpSp->Parameters.StartDevice.AllocatedResourcesTranslated,
                                                             &NewResourcesTranslated);

        //
        // Split resources will return two NULL lists when we run low
        // memory, so we only need to check one of its return values
        //
        if ((NewResources == NULL) || (NewResourcesTranslated == NULL)) {
            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {
            ASSERT(Extension->Resources->Count == 1);
            ASSERT(Extension->Resources->List[0].PartialResourceList.Count == 1);
            Descriptor = &Extension->Resources->List[0].PartialResourceList.PartialDescriptors[0];
            ASSERT(Descriptor->Type == CmResourceTypeMemory);
            Extension->GartBase = Descriptor->u.Memory.Start;
            Extension->GartLengthInPages = Descriptor->u.Memory.Length / PAGE_SIZE;
            
            //
            // Set the new GART aperture
            //
            Status = AgpSetAperture(GET_AGP_CONTEXT(Extension),
                                    Extension->GartBase,
                                    Extension->GartLengthInPages);
        }

        ASSERT(NT_SUCCESS(Status));

        Irp->IoStatus.Status = Status ;
        if (!NT_SUCCESS(Status) ) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpStartTargetHost: AgpSetAperture to %I64X, %08lx "
                    "failed %08lx\n",
                    Extension->GartBase.QuadPart,
                    Extension->GartLengthInPages * PAGE_SIZE,
                    Status));
            Irp->IoStatus.Status = Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            if (NewResources != NULL) {
                ExFreePool(NewResources);
                ExFreePool(Extension->Resources);
                Extension->Resources = NULL;
            }

            if (NewResourcesTranslated != NULL) {
                ExFreePool(NewResourcesTranslated);
                ExFreePool(Extension->ResourcesTranslated);
                Extension->ResourcesTranslated = NULL;
            }

            return(Status);
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        //
        // Set up the new parameters for the PCI driver.
        //

        irpSp->Parameters.StartDevice.AllocatedResources = NewResources;
        irpSp->Parameters.StartDevice.AllocatedResourcesTranslated = NewResourcesTranslated;
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               AgpSetEventCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // Pass down the driver stack
        //
        Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

        //
        // If we did things asynchronously then wait on our event
        //
        if (Status == STATUS_PENDING) {
            
            //
            // We do a KernelMode wait so that our stack where the event is
            // doesn't get paged out!
            //
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            Status = Irp->IoStatus.Status;
        }

        ExFreePool(irpSp->Parameters.StartDevice.AllocatedResources);
        ExFreePool(irpSp->Parameters.StartDevice.AllocatedResourcesTranslated);

        IoCompleteRequest(Irp, IO_NO_INCREMENT) ;
        return Status;        
    }
    
    //
    // The bridge is disabled, we have been passed a NULL pointer
    // instead of an empty resource list.  There is nothing to do other
    // than pass down the irp
    //
    IoSkipCurrentIrpStackLocation(Irp);

    return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}

NTSTATUS
Agp3StartTargetBridge(
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Filters out the AGP-specific resource requirements on a
    IRP_MN_START_DEVICE Irp.

Arguments:

    Irp - supplies the IRP_MN_START_DEVICE Irp.

    Extension - Supplies the device extension.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpSp;
    PCM_RESOURCE_LIST NewResources;
    PCM_RESOURCE_LIST NewResourcesTranslated;
    PCM_RESOURCE_LIST AgpAllocatedResources;
    PCM_RESOURCE_LIST AgpAllocatedResourcesTranslated;
    NTSTATUS Status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    AGPLOG(AGP_NOISE,
           ("Agp3StartTargetBridge: IRP %08lx, resource %08lx\n",
            Irp,
            Irp->IoStatus.Information));

    if (irpSp->Parameters.StartDevice.AllocatedResources != NULL) {
        KEVENT event;

        ASSERT(irpSp->Parameters.StartDevice.AllocatedResources->Count == 1);

        //
        // We better have located our aperture resource, or we're
        // in trouble
        //
        if (Extension->Agp3BridgeResourceIndex == JUNK_INDEX) {
            Status = STATUS_INVALID_PARAMETER;
        } else {

            ASSERT(irpSp->Parameters.StartDevice.AllocatedResources->List[0].PartialResourceList.Count >= Extension->Agp3BridgeResourceIndex);
            Descriptor = &irpSp->Parameters.StartDevice.AllocatedResources->List[0].PartialResourceList.PartialDescriptors[Extension->Agp3BridgeResourceIndex];
            ASSERT(Descriptor->Type == CmResourceTypeMemory);
            Extension->GartBase = Descriptor->u.Memory.Start;
            Extension->GartLengthInPages =
                Descriptor->u.Memory.Length / PAGE_SIZE;
            
            //
            // Set the new GART aperture
            //
            Status = AgpSetAperture(GET_AGP_CONTEXT(Extension),
                                    Extension->GartBase,
                                    Extension->GartLengthInPages);
        }
        ASSERT(NT_SUCCESS(Status));

        Irp->IoStatus.Status = Status;
        if (!NT_SUCCESS(Status) ) {
            AGPLOG(AGP_CRITICAL,
                   ("Agp3StartTargetbridge: AgpSetAperture to %I64X, %08lx "
                    "failed %08lx\n",
                    Extension->GartBase.QuadPart,
                    Extension->GartLengthInPages * PAGE_SIZE,
                    Status));
            Irp->IoStatus.Status = Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(Status);
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        //
        // Set up the new parameters for the PCI driver.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               AgpSetEventCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // Pass down the driver stack
        //
        Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

        //
        // If we did things asynchronously then wait on our event
        //
        if (Status == STATUS_PENDING) {
            
            //
            // We do a KernelMode wait so that our stack where the event is
            // doesn't get paged out!
            //
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            Status = Irp->IoStatus.Status;
        }

        IoCompleteRequest(Irp, IO_NO_INCREMENT) ;
        return Status;        
    }
    
    //
    // The bridge is disabled, we have been passed a NULL pointer
    // instead of an empty resource list.  There is nothing to do other
    // than pass down the irp
    //
    IoSkipCurrentIrpStackLocation(Irp);

    return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}


PCM_RESOURCE_LIST
ApSplitResourceList(
    IN PCM_RESOURCE_LIST ResourceList,
    OUT PCM_RESOURCE_LIST *NewResourceList
    )
/*++

Routine Description:

    Splits out the AGP-specific resources from a resource list.

Arguments:

    ResourceList - Supplies the resource list.

    NewResourceList - Returns the new resource list with the AGP-specific
        resources stripped out.

Return Value:

    Pointer to the AGP-specific resource list

--*/

{
    ULONG Size;
    ULONG FullCount;
    ULONG PartialCount;
    PCM_FULL_RESOURCE_DESCRIPTOR Full, NewFull, AgpFull;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Partial, NewPartial, AgpPartial;
    PCM_RESOURCE_LIST NewList;
    PCM_RESOURCE_LIST AgpList;
    ULONG NextAgp=0;

    PAGED_CODE();

    //
    // First walk through the source resource list and figure out how big it
    // is. The two resulting resource lists must be smaller than this, so we
    // will just allocate them to be that size and not worry about it.
    //
    Size = sizeof(CM_RESOURCE_LIST) - sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
    Full = &ResourceList->List[0];
    for (FullCount=0; FullCount<ResourceList->Count; FullCount++) {
        Size += sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
        PartialCount = Full->PartialResourceList.Count;
        Size += (PartialCount-1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

        Full = (PCM_FULL_RESOURCE_DESCRIPTOR)(&Full->PartialResourceList.PartialDescriptors[PartialCount]);
    }

    //
    // Allocate two additional lists
    //
    NewList = ExAllocatePool(PagedPool, Size);
    if (NewList == NULL) {
        *NewResourceList = NULL;
        return(NULL);
    }

    AgpList = ExAllocatePool(PagedPool, Size);
    if (AgpList == NULL) {
        ExFreePool(NewList);
        *NewResourceList = NULL;
        return(NULL);
    }

    //
    // Initialize both new resource lists to have the same number
    // of CM_FULL_RESOURCE_DESCRIPTORs. If any turn out to be empty,
    // we will adjust the count.
    //
    NewList->Count = AgpList->Count = ResourceList->Count;

    //
    // Walk through each CM_FULL_RESOURCE_DESCRIPTOR, copying as we go.
    //
    Full = &ResourceList->List[0];
    NewFull = &NewList->List[0];
    AgpFull = &AgpList->List[0];
    for (FullCount = 0;FullCount < ResourceList->Count; FullCount++) {
        NewFull->InterfaceType = AgpFull->InterfaceType = Full->InterfaceType;
        NewFull->BusNumber = AgpFull->BusNumber = Full->BusNumber;

        //
        // Initialize the partial resource list header
        //
        NewFull->PartialResourceList.Version = Full->PartialResourceList.Version;
        AgpFull->PartialResourceList.Version = Full->PartialResourceList.Version;
        NewFull->PartialResourceList.Revision = Full->PartialResourceList.Revision;
        AgpFull->PartialResourceList.Revision = Full->PartialResourceList.Revision;
        NewFull->PartialResourceList.Count = AgpFull->PartialResourceList.Count = 0;

        NewPartial = &NewFull->PartialResourceList.PartialDescriptors[0];
        AgpPartial = &AgpFull->PartialResourceList.PartialDescriptors[0];
        for (PartialCount = 0; PartialCount < Full->PartialResourceList.Count; PartialCount++) {
            Partial = &Full->PartialResourceList.PartialDescriptors[PartialCount];
            if ((Partial->Type == CmResourceTypeDevicePrivate) &&
                (Partial->u.DevicePrivate.Data[0] == AgpPrivateResource)) {
                //
                // Found one of our private marker descriptors
                //
                // For now, the only kind we should see indicates we skip one descriptor
                //
                ASSERT(NextAgp == 0);
                ASSERT(Partial->u.DevicePrivate.Data[1] == 1);
                NextAgp = Partial->u.DevicePrivate.Data[1];
                ASSERT(PartialCount+NextAgp < Full->PartialResourceList.Count);
            } else {
                //
                // if NextAgp is set, this descriptor goes in the AGP-specific list.
                // Otherwise, it goes in the new list.
                //
                if (NextAgp > 0) {
                    --NextAgp;
                    *AgpPartial++ = *Partial;
                    ++AgpFull->PartialResourceList.Count;
                } else {
                    *NewPartial++ = *Partial;
                    ++NewFull->PartialResourceList.Count;
                }
            }
        }

        //
        // Finished this CM_PARTIAL_RESOURCE_LIST, advance to the next CM_FULL_RESOURCE_DESCRIPTOR
        //
        if (NewFull->PartialResourceList.Count == 0) {
            //
            // we can just reuse this partial resource descriptor as it is empty
            //
            --NewList->Count;
        } else {
            NewFull = (PCM_FULL_RESOURCE_DESCRIPTOR)NewPartial;
        }
        if (AgpFull->PartialResourceList.Count == 0) {
            //
            // we can just reuse this partial resource descriptor as it is empty
            //
            --AgpList->Count;
        } else {
            AgpFull = (PCM_FULL_RESOURCE_DESCRIPTOR)NewPartial;
        }
    }

    *NewResourceList = NewList;

    return(AgpList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib3\intrface.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    Routines for implementing the AGP_BUS_INTERFACE_STANDARD interface

Author:

    John Vert (jvert) 10/26/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/
#define INITGUID 1
#include "agplib.h"


VOID
AgpLibFlushDcacheMdl(
    PMDL Mdl
    );

VOID
ApFlushDcache(
    IN PKDPC Dpc,
    IN PKEVENT Event,
    IN PMDL Mdl,
    IN PVOID SystemArgument2
    );

PMDL
AgpCombineMdlList(IN PMDL MdlList);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpInterfaceReference)
#pragma alloc_text(PAGE, AgpInterfaceDereference)
#pragma alloc_text(PAGE, AgpInterfaceReserveMemory)
#pragma alloc_text(PAGE, AgpInterfaceReleaseMemory)
#pragma alloc_text(PAGE, AgpInterfaceSetRate)
#pragma alloc_text(PAGE, AgpInterfaceCommitMemory)
#pragma alloc_text(PAGE, AgpInterfaceFreeMemory)
#pragma alloc_text(PAGE, AgpLibFlushDcacheMdl)
#pragma alloc_text(PAGE, AgpLibAllocatePhysicalMemory)
#pragma alloc_text(PAGE, AgpLibFreeMappedPhysicalMemory)
#pragma alloc_text(PAGE, AgpLibAllocateMappedPhysicalMemory)
#pragma alloc_text(PAGE, AgpCombineMdlList)
#endif


VOID
AgpInterfaceReference(
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    References an interface. Currently a NOP.

Arguments:

    Extension - Supplies the device extension

Return Value:

    None

--*/

{

    PAGED_CODE();

    InterlockedIncrement(&Extension->InterfaceCount);

}


VOID
AgpInterfaceDereference(
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    Dereferences an interface. Currently a NOP.

Arguments:

    Extension - Supplies the device extension

Return Value:

    None

--*/

{

    PAGED_CODE();

    InterlockedDecrement(&Extension->InterfaceCount);

}


NTSTATUS
AgpInterfaceReserveMemory(
    IN PMASTER_EXTENSION Extension,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    )
/*++

Routine Description:

    Reserves memory in the specified aperture

Arguments:

    Extension - Supplies the device extension where physical address space should be reserved.

    NumberOfPages - Supplies the number of pages to reserve.

    MemoryType - Supplies the memory caching type.

    MapHandle - Returns the mapping handle to be used on subsequent calls.

    PhysicalAddress - If present, returns the physical address in the aperture of the reserved 
            space

Return Value:

    NTSTATUS

--*/

{
    PVOID AgpContext;
    NTSTATUS Status;
    PHYSICAL_ADDRESS MemoryBase;
    PAGP_RANGE Range;

    PAGED_CODE();                              

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    Range = ExAllocatePoolWithTag(PagedPool,
                                  sizeof(AGP_RANGE),
                                  'RpgA');
    if (Range == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    Range->CommittedPages = 0;
    Range->NumberOfPages = NumberOfPages;
    Range->Type = MemoryType;

    LOCK_MASTER(Extension);
    Status = AgpReserveMemory(AgpContext,
                              Range);
    UNLOCK_MASTER(Extension);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReserveMemory - reservation of %x pages of type %d failed %08lx\n",
                NumberOfPages,
                MemoryType,
                Status));
    } else {
        AGPLOG(AGP_NOISE,
               ("AgpInterfaceReserveMemory - reserved %x pages of type %d at %I64X\n",
                NumberOfPages,
                MemoryType,
                Range->MemoryBase.QuadPart));
    }

    *MapHandle = Range;
    if (ARGUMENT_PRESENT(PhysicalAddress)) {
        *PhysicalAddress = Range->MemoryBase;
    }
    return(Status);
}


NTSTATUS
AgpInterfaceReleaseMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle
    )
/*++

Routine Description:

    Releases memory in the specified aperture that was previously reserved by
    AgpInterfaceReserveMemory

Arguments:

    Extension - Supplies the device extension where physical address space should be reserved.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range;
    PVOID AgpContext;
    NTSTATUS Status;
    PHYSICAL_ADDRESS MemoryBase;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);
    Range = (PAGP_RANGE)MapHandle;

    LOCK_MASTER(Extension);
    //
    // Make sure the range is empty
    //
    ASSERT(Range->CommittedPages == 0);
    if (Range->CommittedPages != 0) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReleaseMemory - Invalid attempt to release non-empty range %08lx\n",
                Range));
        UNLOCK_MASTER(Extension);
        return(STATUS_INVALID_PARAMETER);
    }

    AGPLOG(AGP_NOISE,
           ("AgpInterfaceReleaseMemory - releasing range %08lx, %lx pages at %08lx\n",
            Range,
            Range->NumberOfPages,
            Range->MemoryBase.QuadPart));
    Status = AgpReleaseMemory(AgpContext,
                              Range);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReleaseMemory - release failed %08lx\n",
                Status));
    }
    UNLOCK_MASTER(Extension);
    ExFreePool(Range);
    return(Status);
}


NTSTATUS
AgpInterfaceCommitMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Commits memory into the specified aperture that was previously reserved by
    AgpInterfaceReserveMemory

Arguments:

    Extension - Supplies the device extension where physical address space should
        be committed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be committed.

    OffsetInPages - Supplies the offset, in pages, into the aperture reserved by
        AgpInterfaceReserveMemory

    Mdl - Returns the MDL describing the pages of memory committed.

    MemoryBase - Returns the physical memory address of the committed memory.

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PMDL NewMdl;
    PVOID AgpContext;
    NTSTATUS Status=STATUS_SUCCESS;
    ULONG RunLength, RunOffset;
    ULONG CurrentLength, CurrentOffset;
    PMDL FirstMdl=NULL;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(NumberOfPages <= Range->NumberOfPages);
    ASSERT(NumberOfPages > 0);
    ASSERT((Mdl == NULL) || (Mdl->ByteCount == PAGE_SIZE * NumberOfPages));

    CurrentLength = NumberOfPages;
    CurrentOffset = OffsetInPages;

    LOCK_MASTER(Extension);
    do {

        //
        // Save ourselves the trouble...
        //
        if (!(CurrentLength > 0)) {
            break;
        }

        //
        // Find the first free run in the supplied range.
        //
        AgpFindFreeRun(AgpContext,
                       Range,
                       CurrentLength,
                       CurrentOffset,
                       &RunLength,
                       &RunOffset);

        if (RunLength > 0) {
            ASSERT(RunLength <= CurrentLength);
            ASSERT(RunOffset >= CurrentOffset);
            ASSERT(RunOffset < CurrentOffset + CurrentLength);
            ASSERT(RunOffset + RunLength <= CurrentOffset + CurrentLength);

            //
            // Compute the next offset and length
            //
            CurrentLength -= (RunOffset - CurrentOffset) + RunLength;
            CurrentOffset = RunOffset + RunLength;

            //
            // Get an MDL from memory management big enough to map the 
            // requested range.
            //

            NewMdl = AgpLibAllocatePhysicalMemory(AgpContext, RunLength * PAGE_SIZE);
            
            //
            // This can fail in two ways, either no memory is available at all (NewMdl == NULL)
            // or some pages were available, but not enough. (NewMdl->ByteCount < Length)
            //
            if (NewMdl == NULL) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceReserveMemory - Couldn't allocate pages for %lx bytes\n",
                        RunLength));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            } else if (BYTES_TO_PAGES(NewMdl->ByteCount) < RunLength) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceCommitMemory - Only allocated enough pages for %lx of %lx bytes\n",
                        NewMdl->ByteCount,
                        RunLength));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                MmFreePagesFromMdl(NewMdl);
                break;
            }

            //
            // Now that we have our MDL, we can map this into the specified
            // range.
            //
            if (AgpFlushPages != NULL) {
                if (!NT_SUCCESS((AgpFlushPages)(AgpContext, NewMdl))) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    MmFreePagesFromMdl(NewMdl);
                    break;
                }
            } else {
                AgpLibFlushDcacheMdl(NewMdl);
            }
            Status = AgpMapMemory(AgpContext,
                                  Range,
                                  NewMdl,
                                  RunOffset,
                                  MemoryBase);
            if (!NT_SUCCESS(Status)) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceCommitMemory - AgpMapMemory for Mdl %08lx in range %08lx failed %08lx\n",
                        NewMdl,
                        Range,
                        Status));
                MmFreePagesFromMdl(NewMdl);
                break;
            }
            Range->CommittedPages += RunLength;

            //
            // Add this MDL to our list of allocated MDLs for cleanup
            // If we need to cleanup, we will also need to know the page offset
            // so that we can unmap the memory. Stash that value in the ByteOffset
            // field of the MDL (ByteOffset is always 0 for our MDLs)
            //
            NewMdl->ByteOffset = RunOffset;
            NewMdl->Next = FirstMdl;
            FirstMdl = NewMdl;
        }

    } while (RunLength > 0);

    //
    // Cleanup the MDLs. If the allocation failed, we need to
    // unmap them and free the pages and the MDL itself. If the
    // operation completed successfully, we just need to free the
    // MDL.
    //
    while (FirstMdl) {
        NewMdl = FirstMdl;
        FirstMdl = NewMdl->Next;
        if (!NT_SUCCESS(Status)) {

            //
            // Unmap the memory that was mapped. The ByteOffset field
            // of the MDL is overloaded here to store the offset in pages
            // into the range.
            //
            AgpUnMapMemory(AgpContext,
                           Range,
                           NewMdl->ByteCount / PAGE_SIZE,
                           NewMdl->ByteOffset);
            NewMdl->ByteOffset = 0;
            Range->CommittedPages -= NewMdl->ByteCount / PAGE_SIZE;
            MmFreePagesFromMdl(NewMdl);
        }
        ExFreePool(NewMdl);
    }

    if (NT_SUCCESS(Status)) {

        if (Mdl) {
            //
            // Get the MDL that describes the entire mapped range.
            //
            AgpGetMappedPages(AgpContext,
                              Range,
                              NumberOfPages,
                              OffsetInPages,
                              Mdl);
        }

        MemoryBase->QuadPart = Range->MemoryBase.QuadPart + OffsetInPages * PAGE_SIZE;
    }

    UNLOCK_MASTER(Extension);
    return(Status);
}


NTSTATUS
AgpInterfaceFreeMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Frees memory previously committed by AgpInterfaceCommitMemory

Arguments:

    Extension - Supplies the device extension where physical address space should
        be freed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be freed.

    OffsetInPages - Supplies the start of the range to be freed.

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PVOID AgpContext;
    NTSTATUS Status;
    PMDL FreeMdl;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(OffsetInPages < Range->NumberOfPages);
    ASSERT(OffsetInPages + NumberOfPages <= Range->NumberOfPages);
    //
    // Make sure the supplied address is within the reserved range
    //
    if ((OffsetInPages >= Range->NumberOfPages) ||
        (OffsetInPages + NumberOfPages > Range->NumberOfPages)) {
        AGPLOG(AGP_WARNING,
               ("AgpInterfaceFreeMemory - Invalid free of %x pages at offset %x from range %I64X (%x pages)\n",
                NumberOfPages,
                OffsetInPages,
                Range->MemoryBase.QuadPart,
                Range->NumberOfPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Allocate an MDL big enough to contain the pages to be unmapped.
    //
    FreeMdl =
        IoAllocateMdl(NULL, NumberOfPages * PAGE_SIZE, FALSE, TRUE, NULL);
    
    if (FreeMdl == NULL) {

        //
        // This is kind of a sticky situation. We can't allocate the memory
        // that we need to free up some memory! I guess we could have a small
        // MDL on our stack and free things that way.
        //
        // John Vert (jvert) 11/11/1997
        // implement this
        //
        ASSERT(FreeMdl != NULL);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    LOCK_MASTER(Extension);

    //
    // Get the MDL that describes the entire mapped range
    //
    AgpGetMappedPages(AgpContext, 
                      Range,
                      NumberOfPages,
                      OffsetInPages,
                      FreeMdl);
    //
    // Unmap the memory
    //
    Status = AgpUnMapMemory(AgpContext,
                            Range,
                            NumberOfPages,
                            OffsetInPages);
    UNLOCK_MASTER(Extension);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceFreeMemory - UnMapMemory for %x pages at %I64X failed %08lx\n",
                NumberOfPages,
                Range->MemoryBase.QuadPart + OffsetInPages * PAGE_SIZE,
                Status));
    } else {
        //
        // Free the pages
        //
        MmFreePagesFromMdl(FreeMdl);
        ASSERT(Range->CommittedPages >= NumberOfPages);
        Range->CommittedPages -= NumberOfPages;
    }

    //
    // Free the MDL we allocated.
    //
    IoFreeMdl(FreeMdl);
    return(Status);
}

NTSTATUS
AgpInterfaceGetMappedPages(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped backing the specified range.

Arguments:

    Extension - Supplies the device extension where physical address space should
        be freed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the rangion

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PVOID AgpContext;
    NTSTATUS Status;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(NumberOfPages <= Range->NumberOfPages);
    ASSERT(NumberOfPages > 0);
    ASSERT(OffsetInPages < Range->NumberOfPages);
    ASSERT(OffsetInPages + NumberOfPages <= Range->NumberOfPages);
    ASSERT(Mdl->ByteCount == PAGE_SIZE * NumberOfPages);

    //
    // Make sure the supplied address is within the reserved range
    //
    if ((OffsetInPages >= Range->NumberOfPages) ||
        (OffsetInPages + NumberOfPages > Range->NumberOfPages)) {
        AGPLOG(AGP_WARNING,
               ("AgpInterfaceGetMappedPages - Invalid 'get' of %x pages at offset %x from range %I64X (%x pages)\n",
                NumberOfPages,
                OffsetInPages,
                Range->MemoryBase.QuadPart,
                Range->NumberOfPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Get the MDL that describes the entire mapped range
    //
    LOCK_MASTER(Extension);

    AgpGetMappedPages(AgpContext, 
                      Range,
                      NumberOfPages,
                      OffsetInPages,
                      Mdl);

    UNLOCK_MASTER(Extension);
    return(STATUS_SUCCESS);
}


PMDL
AgpLibAllocatePhysicalMemory(IN PVOID AgpContext, IN ULONG TotalBytes)
/*++

Routine Description:

    Allocates a set of physical memory pages for use by the AGP driver.
    
    This routine uses MmAllocatePagesForMdl to attempt to allocate
    as many of the pages as possible within favored AGP memory
    ranges (if any).

Arguments:

    AgpContext   - The AgpContext

    TotalBytes   - The total amount of bytes to allocate.

Return Value:

    An MDL that describes the allocated physical pages or NULL
    if this function is unsuccessful. 
    
    NOTE: Just like MmAllocatePagesForMdl, this function can return
    an MDL that describes an allocation smaller than TotalBytes in size.

--*/
{
   PHYSICAL_ADDRESS ZeroAddress, MaxAddress;
   PMDL MdlList = NULL, NewMdl = NULL;
   PTARGET_EXTENSION Extension;
   ULONG i, PagesNeeded;

   PAGED_CODE();

   AGPLOG(AGP_NOISE, ("AGPLIB: Attempting to allocate memory = %u pages.\n", 
            BYTES_TO_PAGES(TotalBytes)));

   // Initialize some stuff

   ZeroAddress.QuadPart = 0;
   MAX_MEM(MaxAddress.QuadPart);
   
   AGPLOG(AGP_NOISE, ("AGPLIB: Max memory set to %I64x.\n", MaxAddress.QuadPart));

   GET_TARGET_EXTENSION(Extension, AgpContext);

   // How many pages do we need?

   PagesNeeded = BYTES_TO_PAGES(TotalBytes);

   //
   // Loop through each favored range, attempting to allocate
   // as much as possible from that range within the bounds
   // of what we actually need.
   //

   for (i = 0; i < Extension->FavoredMemory.NumRanges; i++) {
      AGPLOG(AGP_NOISE, 
             ("AGPLIB: Trying to allocate %u pages from range %I64x - %I64x.\n",
               PagesNeeded, 
               Extension->FavoredMemory.Ranges[i].Lower,               
               Extension->FavoredMemory.Ranges[i].Upper));      

      NewMdl = MmAllocatePagesForMdl(Extension->FavoredMemory.Ranges[i].Lower,
                                     Extension->FavoredMemory.Ranges[i].Upper,
                                     ZeroAddress,                                     
                                     PagesNeeded << PAGE_SHIFT);
      if (NewMdl) {
         AGPLOG(AGP_NOISE, ("AGPLIB: %u pages allocated in range.\n",
                  NewMdl->ByteCount >> PAGE_SHIFT));
         
         PagesNeeded -= BYTES_TO_PAGES(NewMdl->ByteCount);
         
         //
         // Build a list of the MDls used
         // for each range-based allocation
         //

         NewMdl->Next = MdlList;
         MdlList = NewMdl;

         // Stop allocating if we are finished.

         if (PagesNeeded == 0) break;
         

      } else {
         AGPLOG(AGP_NOISE, ("AGPLIB: NO pages allocated in range.\n"));
      }
      
   }

   //
   // Attempt to allocate from ALL of physical memory
   // if we could not complete our allocation with only
   // the favored memory ranges.
   //

   if (PagesNeeded > 0) {

      AGPLOG(AGP_NOISE, ("AGPLIB: Global Memory allocation for %u pages.\n", 
               PagesNeeded));

      NewMdl = MmAllocatePagesForMdl(ZeroAddress,
                                     MaxAddress,
                                     ZeroAddress,
                                     PagesNeeded << PAGE_SHIFT);
      if (NewMdl) {

         AGPLOG(AGP_NOISE, ("AGPLIB: Good Global Memory Alloc for %u pages.\n",
                  NewMdl->ByteCount >> PAGE_SHIFT));

         //
         // Add this MDL to the list as well
         //

         NewMdl->Next = MdlList;
         MdlList = NewMdl;
      } else {

         AGPLOG(AGP_NOISE, ("AGPLIB: Failed Global Memory Alloc.\n"));

      }

   }

   // We now have a list of Mdls in MdlList that give us the best
   // possible memory allocation taking favored ranges into account.

   // What we now need to do is combine this Mdl list into one mdl.

   NewMdl = AgpCombineMdlList(MdlList);

   if (!NewMdl && MdlList) {
      AGPLOG(AGP_WARNING, ("AGPLIB: Could not combine MDL List!\n"));

      // This is bad. The mdl list could not be combined probably 
      // because a large enough mdl could not be allocated for 
      // the combination.

      // This is not the end of the world however, since the mdl list
      // is not modified until its combination has succeeded so we 
      // still have a valid list. But we need it in one Mdl, so 
      // we just fall back to the simplest allocation strategy
      // we have available:

      // 1. Destroy the list and all of its allocations.
      
      while(MdlList)
      {
         MmFreePagesFromMdl(MdlList);
         NewMdl = MdlList->Next;
         ExFreePool(MdlList);
         MdlList = NewMdl;
      }

      // 2. Allocate a single Mdl with our pages without regard
      // for favored memory ranges. 

      NewMdl = MmAllocatePagesForMdl(ZeroAddress, 
                                     MaxAddress,
                                     ZeroAddress,
                                     TotalBytes);

   }

   return NewMdl;

   
}

PMDL
AgpCombineMdlList(IN PMDL MdlList)
/*++

Routine Description:

    Combines a list of MDLs that describe some set of physical memory
    pages into a single MDL that describes the same set of pages.
    
    The MDLs in the list should be of the type produced by
    MmAllocatePagesForMdl (i.e. MDLs that are useful for nothing more
    than as an array of PFNs)

    This function is used by AgpLibAllocatePhysicalMemory in order
    to combine its multiple range-based allocations into 1 MDL.
    
Arguments:

    MdlList - A list of MDLs to be combines

Return Value:

    A single MDL that describes the same set of physical pages as
    the MDLs in MdlList or NULL if this function is unsuccessful.
    
    NOTE: This function will deallocate the Mdls in MdlList if it
    is successful. If it is unsuccessful, however, it will leave
    the MdlList intact.

--*/
{
   PMDL NewMdl = NULL, Mdl, MdlTemp;
   ULONG Pages = 0;
   PPFN_NUMBER NewPageArray, PageArray;

   ULONG i; // for debugging only

   PAGED_CODE();

   if ((MdlList == NULL) || (MdlList->Next == NULL)) {

      // List of 0 or 1 elements, no need for this 
      // function to do anything.

      return MdlList;
   }

   // Calculate the number of pages spanned by this MdlList.

   for(Mdl = MdlList; Mdl; Mdl = Mdl->Next)
      Pages += BYTES_TO_PAGES(Mdl->ByteCount);

   // Allocate a new Mdl of the proper size.

   NewMdl = IoAllocateMdl(NULL, Pages << PAGE_SHIFT, FALSE, TRUE, NULL);

   if (!NewMdl) {

      // Chances are that the system will bugcheck before
      // this actually happens ... but whatever.

      return NULL;
   }

   // Run through the mdl list, combining the mdls found
   // into a new mdl.

   //
   // First, get a pointer to the PFN array of the new Mdl
   //

   NewPageArray = MmGetMdlPfnArray(NewMdl);

   for(Mdl = MdlList; Mdl; Mdl = Mdl->Next)
   {
      // Get a pointer to the physical page number array in this Mdl.

      PageArray = MmGetMdlPfnArray(Mdl);
      Pages = BYTES_TO_PAGES(Mdl->ByteCount);

      // Copy this array into a proper slot in the array area of the new Mdl.

      RtlCopyMemory((PVOID)NewPageArray, 
                    (PVOID)PageArray,
                    sizeof(PFN_NUMBER) * Pages);

      // Adjust new array slot pointer appropriately for the next copy

      NewPageArray += Pages;
         
   }

   // The list has been combined, now we need to destroy the Mdls
   // in the list.

   Mdl = MdlList;
   while(Mdl)
   {
      MdlTemp = Mdl->Next;
      ExFreePool(Mdl);
      Mdl = MdlTemp;
   }

   // All done. Return the new combined Mdl.

   return NewMdl;
}

VOID
AgpLibFreeMappedPhysicalMemory(
    IN PVOID Addr,
    IN ULONG Length
    )
/*++

Routine Description:

Arguments:

    Addr - The virtual address of the allocation

    Length - Length of allocation in bytes

Return Value:

    None

--*/
{
    ULONG Index;
    PMDL FreeMdl;
    ULONG Pages;
    PPFN_NUMBER Page;

    PAGED_CODE();

    //
    // Allocate an MDL big enough to contain the pages to be unmapped
    //
    FreeMdl = IoAllocateMdl(Addr, Length, FALSE, TRUE, NULL);
    
    //
    // We could not allocate a MDL to free memory, we will free one page at
    // a time using a MDL on our stack
    //
    if (FreeMdl == NULL) {
        PCCHAR VAddr;
        MDL MdlBuf[2]; // NOTE: We use this second MDL to store a
                       //       single PFN_NUMBER

        ASSERT(sizeof(PFN_NUMBER) <= sizeof(MDL));

        FreeMdl = &MdlBuf[0];
        RtlZeroMemory(FreeMdl, 2 * sizeof(MDL));

        Pages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(Addr, Length);
        Page = (PPFN_NUMBER)(FreeMdl + 1);

        //
        // Take care not to create a MDL that spans more than a page
        //
        VAddr = PAGE_ALIGN(Addr);
        for (Index = 0; Index < Pages; Index++) {
            MmInitializeMdl(FreeMdl, VAddr, PAGE_SIZE);
            *Page = (PFN_NUMBER)(MmGetPhysicalAddress(VAddr).QuadPart >>
                                 PAGE_SHIFT);
            MmFreePagesFromMdl(FreeMdl);
            VAddr += PAGE_SIZE;
        }

        return;
    }

    Page = (PPFN_NUMBER)(FreeMdl + 1);
    Pages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(Addr, Length);
    
    //
    // Fill in the PFN array for the MDL
    //
    for (Index = 0; Index < Pages; Index++) {
        *Page++ = (PFN_NUMBER)(MmGetPhysicalAddress((PCCHAR)Addr + (Index * PAGE_SIZE)).QuadPart >> PAGE_SHIFT);
    }

    MmFreePagesFromMdl(FreeMdl);
    IoFreeMdl(FreeMdl);
}


PVOID
AgpLibAllocateMappedPhysicalMemory(IN PVOID AgpContext, IN ULONG TotalBytes)
/*++

Routine Description:

    Same as AgpLibAllocatePhysicalMemory, except this function will
    also map the allocated memory to a virtual address.

Arguments:

    Same as AgpLibAllocatePhysicalMemory.

Return Value:

    A virtual address of the allocated memory or NULL if unsuccessful.

--*/
{
   PMDL Mdl;
   PVOID Ret;

   PAGED_CODE();
   
   AGPLOG(AGP_NOISE, 
          ("AGPLIB: Attempting to allocate mapped memory = %u.\n", TotalBytes));

   //
   // Call the real memory allocator.
   //
   
   Mdl = AgpLibAllocatePhysicalMemory(AgpContext, TotalBytes);

   // Two possible failures 

   // 1. MDL is NULL. No memory could be allocated.

   if (Mdl == NULL) {

      AGPLOG(AGP_WARNING, ("AGPMAP: Could not allocate anything.\n"));

      return NULL;
   }

   // 2. MDL has some pages allocated but not enough.

   if (Mdl->ByteCount < TotalBytes) {

      AGPLOG(AGP_WARNING, ("AGPMAP: Could not allocate enough.\n"));

      MmFreePagesFromMdl(Mdl);
      ExFreePool(Mdl);
      return NULL;
   }

   // Ok. Our allocation succeeded. Map it to a virtual address.
   
   // Step 1: Map the locked Pages. (will return NULL if failed)

   Mdl->MdlFlags |= MDL_PAGES_LOCKED;
   Ret = MmMapLockedPagesSpecifyCache (Mdl,
                                         KernelMode,
                                         MmNonCached,
                                         NULL,
                                         FALSE,
                                         HighPagePriority);

   // Don't need the Mdl anymore, whether we succeeded or failed. 

   ExFreePool(Mdl);

   if (Ret == NULL) {
      AGPLOG(AGP_WARNING, ("AGPMAP: Could not map.\n"));
   } 

   return Ret;
}

#if defined (_X86_)
#define FLUSH_DCACHE(Mdl) __asm{ wbinvd }
#else
#define FLUSH_DCACHE(Mdl)   \
            AGPLOG(AGP_CRITICAL,    \
                   ("AgpLibFlushDcacheMdl - NEED TO IMPLEMENT DCACHE FLUSH FOR THIS ARCHITECTURE!!\n"))
#endif


VOID
AgpLibFlushDcacheMdl(
    PMDL Mdl
    )
/*++

Routine Description:

    Flushes the specified MDL from the D-caches of all processors
    in the system.

    Current algorithm is to set the current thread's affinity to each 
    processor in turn and flush the dcache. This could be made a lot
    more efficient if this turns out to be a hot codepath
    
Arguments:

    Mdl - Supplies the MDL to be flushed.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    KAFFINITY Processors;
    UCHAR Number;
    KEVENT Event;
    KDPC Dpc;

    PAGED_CODE();
    Processors = KeQueryActiveProcessors();
    //
    // Quick out for the UP case.
    //
    if (Processors == 1) {
        FLUSH_DCACHE(Mdl);
        return;
    }

    //
    // We will invoke a DPC on each processor. That DPC will flush the cache,
    // set the event and return. 
    //
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    Number = 0;
    while (Processors) {
        if (Processors & 1) {
            //
            // Initialize the DPC and set it to run on the specified
            // processor.
            //
            KeInitializeDpc(&Dpc,ApFlushDcache, &Event);
            KeSetTargetProcessorDpc(&Dpc, Number);

            //
            // Queue the DPC and wait for it to finish its work.
            //
            KeClearEvent(&Event);
            KeInsertQueueDpc(&Dpc, Mdl, NULL);
            KeWaitForSingleObject(&Event, 
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        Processors = Processors >> 1;
        ++Number;
    }
}



VOID
ApFlushDcache(
    IN PKDPC Dpc,
    IN PKEVENT Event,
    IN PMDL Mdl,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    DPC which executes on each processor in turn to flush the
    specified MDL out of the dcache on each.

Arguments:

    Dpc - supplies the DPC object

    Event - Supplies the event to signal when the DPC is complete

    Mdl - Supplies the MDL to be flushed from the dcache

Return Value:

    None

--*/

{
    FLUSH_DCACHE(Mdl);
    KeSetEvent(Event, 0, FALSE);
}


NTSTATUS
AgpInterfaceSetRate(
    IN PMASTER_EXTENSION Extension,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    Extension - Supplies the device extension

    AgpRate - Rate to set

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    ULONGLONG DeviceFlags = 0;

    PAGED_CODE();

    switch (AgpRate) {
        case PCI_AGP_RATE_1X:
            DeviceFlags = AGP_FLAG_SET_RATE_1X;
            break;
        case PCI_AGP_RATE_2X:
            DeviceFlags = AGP_FLAG_SET_RATE_2X;
            break;
        case PCI_AGP_RATE_4X:
            DeviceFlags = AGP_FLAG_SET_RATE_4X;
            break;
        case 8:
            DeviceFlags = AGP_FLAG_SET_RATE_8X;
            break;
    }

    if (DeviceFlags != 0) {
        return AgpSpecialTarget(GET_AGP_CONTEXT_FROM_MASTER(Extension),
                                DeviceFlags);
    }

    return STATUS_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\alim1541\alim1541.h ===
//
// agpALi.sys is a driver, make sure we get the appropriate linkage.
//

#define _NTDRIVER_

#include "stdarg.h"
#include "stdio.h"
#include "ntddk.h"
#include "agp.h"

//
// Define the location of the GART aperture control registers
//

//
// The GART registers on the ALi M1541 live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//
#define AGP_ALi_GART_BUS_ID     0
#define AGP_ALi_GART_SLOT_ID    0
#define AGP_ALi_P2P_SLOT_ID     1
#define AGP_VGA_BUS_ID          1
#define AGP_VGA_SLOT_ID         0

#define AGP_ALi_1541_IDENTIFIER      0x154110b9
#define AGP_ALi_1621_IDENTIFIER      0x162110b9
#define AGP_ALi_1631_IDENTIFIER      0x163110b9
#define AGP_ALi_1632_IDENTIFIER      0x163210b9
#define AGP_ALi_1641_IDENTIFIER      0x164110b9
#define AGP_ALi_1644_IDENTIFIER      0x164410b9
#define AGP_ALi_1646_IDENTIFIER      0x164610b9
#define AGP_ALi_1647_IDENTIFIER      0x164710b9
#define AGP_ALi_1651_IDENTIFIER      0x165110b9
#define AGP_ALi_1671_IDENTIFIER      0x167110b9
#define AGP_ALi_1672_IDENTIFIER      0x167210b9

#define APBASE_OFFSET  0x10             // Aperture Base Address
#define AGP_STATUS_OFFSET 0xB4          // AGP Status Register
#define CHIP_REVISION_OFFSET 0x08       // NorthBridge revision ID
#define APCTRL_OFFSET 0xBC              // Aperture Translation Table Base
#define GTLBCTRL_OFFSET 0xC0            // GTLB Control Register
#define GTLBTAGCLR_OFFSET 0xC4          // GTLB TAG Clear Register
#define L1_2_CACHE_FLUSH_CTRL 0xD0      // L1/L2 Cache Flush Control
#define M1541_Lock_WR 0x90              // M1541 AGP Status Lock Read/Write Control
#define M1621_Lock_WR 0xC8              // M1621 AGP Status Lock Read/Write Control
#define PCI_STATUS_REG 0x4              // PCI Status Register
#define CAP_PTR 0x34                    // PCI Capability Pointer
#define AGP_ID 0x2                      // AGP Capability ID
#define M1621_HIDDEN_REV_ID 0xFB        // M1621 series Hidden Revision ID 

#define ReadConfigUlong(_bus_,_slot_,_buf_,_offset_)        \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  (_bus_),                  \
                                  (_slot_),                 \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  4);                \
    ASSERT(_len_ == 4);                              \
}

#define ReadConfigUlongSafe(_bus_,_slot_,_buf_,_offset_)    \
{                                                           \
    HalGetBusDataByOffset(PCIConfiguration,         \
                                  (_bus_),                  \
                                  (_slot_),                 \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  4);                \
}

#define ReadConfigUchar(_bus_,_slot_,_buf_,_offset_)        \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  (_bus_),                  \
                                  (_slot_),                 \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  1);                \
    ASSERT(_len_ == 1);                              \
}

#define WriteConfigUlong(_bus_,_slot_,_buf_,_offset_)       \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  (_bus_),                  \
                                  (_slot_),                 \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  4);                \
    ASSERT(_len_ == 4);                              \
}

#define WriteConfigUchar(_bus_,_slot_,_buf_,_offset_)       \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  (_bus_),                  \
                                  (_slot_),                 \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  1);                \
    ASSERT(_len_ == 1);                              \
}

#define AP_SIZE_4MB     0x03
#define AP_SIZE_8MB     0x04
#define AP_SIZE_16MB    0x06
#define AP_SIZE_32MB    0x07
#define AP_SIZE_64MB    0x08
#define AP_SIZE_128MB   0x09
#define AP_SIZE_256MB   0x0A

#define AP_SIZE_COUNT 7
#define AP_MIN_SIZE (4 * 1024 * 1024)
#define AP_MAX_SIZE (256 * 1024 * 1024)

//
// Define the GART table entry.
//
typedef struct _GART_ENTRY_HW {
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;


//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)


typedef struct _GART_ENTRY_SW {
    ULONG State     : 3;
    ULONG Reserved  : 29;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the layout of the hardware registers
//
typedef struct _APCTRL {
    ULONG ApSize        : 4;
    ULONG Reserved1     : 8;
    ULONG ATTBase       : 20;
} APCTRL, *PAPCTRL;

typedef struct _GTLBCTRL {
    ULONG GartLevelSelect   : 1;
    ULONG Reserved1         : 3;
    ULONG GTLBSize          : 2;
    ULONG Reserved2         : 1;
    ULONG GTLB_ENJ          : 1;  // 0:Enable  1:Desable
    ULONG NLVM_Base         : 12;
    ULONG NLVM_Top          : 12;
} GTLBCTRL, *PGTLBCTRL;

typedef struct _GTLBTAGCLR {
    ULONG GTLBTagClear      : 1;
    ULONG ClearAllTag       : 1;
    ULONG ClearGDir         : 1;
    ULONG Reserved2         : 12;
    ULONG Page              : 17;
} GTLBTAGCLR, *PGTLBTAGCLR;

typedef struct _CACHECTRL {
    ULONG Reserved1         : 8;
    ULONG Flush_Enable      : 1;
    ULONG Reserved2         : 3;
    ULONG Address           : 20;
} CACHECTRL, *PCACHECTRL;

//
// Define the different chipsets supported by this driver.
//
typedef enum _ALI_CHIPSET_TYPE {
    ALi1541,
    ALi1621,
    ALi1631,
    ALi1632,
    ALi1641,
    ALi1644,
    ALi1646,
    ALi1647,
    ALi1651,
    ALi1671,
    ALi1672
} ALI_CHIPSET_TYPE;

//
// Define the ALi-specific extension
//
typedef struct _AGPALi_EXTENSION {
    PHYSICAL_ADDRESS    ApertureStart;
    ULONG               ApertureLength;
    PGART_PTE           Gart;
    ULONG               GartLength;
    PHYSICAL_ADDRESS    GartPhysical;
    ALI_CHIPSET_TYPE    ChipsetType;
    ULONGLONG           SpecialTarget;
} AGPALi_EXTENSION, *PAGPALi_EXTENSION;


NTSTATUS
Agp1541FlushPages(
    IN PAGPALi_EXTENSION AgpContext,
    IN PMDL Mdl
    );

VOID
AgpWorkaround(
    IN PVOID AgpExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib3\wmi.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    AGP filter driver(s)

Author:

Environment:

    Kernel mode

Revision History :
--*/

#include "agplib.h"
#include <wmistr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpWmiRegistration)
#pragma alloc_text(PAGE, AgpWmiDeRegistration)
#pragma alloc_text(PAGE, AgpSystemControl)
#pragma alloc_text(PAGE, AgpSetWmiDataItem)
#pragma alloc_text(PAGE, AgpSetWmiDataBlock)
#pragma alloc_text(PAGE, AgpQueryWmiDataBlock)
#pragma alloc_text(PAGE, AgpQueryWmiRegInfo)
#endif

#define WMI_AGP_INFORMATION 0
#define NUMBER_OF_WMI_GUIDS 1

GUID AgpWmiGuid = AGP_WMI_STD_DATA_GUID;

WMIGUIDREGINFO WmiGuidList[1] =
{
    { &AgpWmiGuid, 1, 0 }   // Pointer Port driver information
};

NTSTATUS
AgpWmiRegistration(
    PTARGET_EXTENSION Extension
)
/*++

Routine Description:

    Registers with WMI as a data provider for this
    instance of the device

Arguments:

    Extension - Pointer to our taget extension

Return Value:

    STATUS_SUCCESS or an appropriate error status

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    Extension->WmiLibInfo.GuidCount = sizeof(WmiGuidList) /
        sizeof(WMIGUIDREGINFO);
    ASSERT (NUMBER_OF_WMI_GUIDS == Extension->WmiLibInfo.GuidCount);
    Extension->WmiLibInfo.GuidList = WmiGuidList;
    Extension->WmiLibInfo.QueryWmiRegInfo = AgpQueryWmiRegInfo;
    Extension->WmiLibInfo.QueryWmiDataBlock = AgpQueryWmiDataBlock;
    Extension->WmiLibInfo.SetWmiDataBlock = AgpSetWmiDataBlock;
    Extension->WmiLibInfo.SetWmiDataItem = AgpSetWmiDataItem;
    Extension->WmiLibInfo.ExecuteWmiMethod = NULL;
    Extension->WmiLibInfo.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //
    
    status = IoWMIRegistrationControl(Extension->Self,
                             WMIREG_ACTION_REGISTER
                             );

    //
    // Initialize the Std device data structure
    //
    Globals.AgpCommand = 0;
    Globals.AgpStatus = 0;

    return status;
    
}

NTSTATUS
AgpWmiDeRegistration(
    PTARGET_EXTENSION Extension
)
/*++

Routine Description:

     Inform WMI to remove this DeviceObject from its 
     list of providers. This function also 
     decrements the reference count of the deviceobject.

Arguments:

   Extension - Pointer to our target extension

Return Value:

   STATUS_SUCCESS or error

--*/
{
    PAGED_CODE();

    return IoWMIRegistrationControl(Extension->Self,
                                    WMIREG_ACTION_DEREGISTER
                                    );
}

NTSTATUS
AgpSystemControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )
/*++

Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and call into the WMI system library and let
    it handle this IRP for us.

Arguments:

    DeviceObject - Pointer to our device object

    Irp - Points to the corresponding I/O request packet

Return Value:

   STATUS_SUCCESS or an appropriate error status

--*/
{
    PTARGET_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    PAGED_CODE();
    
    deviceExtension = (PTARGET_EXTENSION) DeviceObject->DeviceExtension;

    status = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            IoSkipCurrentIrpStackLocation (Irp);
            status =
                IoCallDriver(deviceExtension->CommonExtension.AttachedDevice,
                             Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation (Irp);
            status =
                IoCallDriver(deviceExtension->CommonExtension.AttachedDevice,
                             Irp);
            break;
        }        
    }
    
    return(status);
}

NTSTATUS
AgpSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PTARGET_EXTENSION   deviceExtension;
    NTSTATUS            status;

    PAGED_CODE();

    deviceExtension = (PTARGET_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {

    case WMI_AGP_INFORMATION:
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT
                                  );

    return status;
}

NTSTATUS
AgpSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PTARGET_EXTENSION   deviceExtension;
    NTSTATUS            status;

    PAGED_CODE();

    deviceExtension = (PTARGET_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_AGP_INFORMATION:
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT
                                  );

    return status;
}

NTSTATUS
AgpQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PTARGET_EXTENSION   deviceExtension;
    NTSTATUS            status;
    ULONG               size = 0;

    PAGED_CODE();

    ASSERT((InstanceIndex == 0) && (InstanceCount == 1));
    
    deviceExtension = (PTARGET_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_AGP_INFORMATION: {

        AGP_STD_DATA AgpData;

        size = sizeof(AGP_STD_DATA);

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        AgpData.AgpStatus = Globals.AgpStatus;
        AgpData.AgpCommand = Globals.AgpCommand;
        AgpData.ApertureBase = deviceExtension->GartBase;
        AgpData.ApertureLength =
            deviceExtension->GartLengthInPages * PAGE_SIZE;

        *(PAGP_STD_DATA)Buffer = AgpData;

        *InstanceLengthArray = size;

        status = STATUS_SUCCESS;
        break;
    }

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT
                                  );

    return status;
}

NTSTATUS
AgpQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered. 
            
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.               

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is 
        required
                
    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
    PTARGET_EXTENSION deviceExtension;
    PUNICODE_STRING regPath;    
        
    PAGED_CODE();
    
    deviceExtension = DeviceObject->DeviceExtension;
    
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.RegistryPath;
    *Pdo = deviceExtension->PDO;
 
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib3\config.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    config.c

Abstract:

    Routines for accessing config space in the PCI-PCI bridge

Author:

    John Vert (jvert) 10/27/1997

Revision History:

--*/
#include "agplib.h"

typedef struct _BUS_SLOT_ID {
    ULONG BusId;
    ULONG SlotId;
} BUS_SLOT_ID, *PBUS_SLOT_ID;

//
// Local function prototypes
//
NTSTATUS
ApGetSetDeviceBusData(
    IN PCOMMON_EXTENSION Extension,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
ApGetSetBusData(
    IN PBUS_SLOT_ID BusSlotId,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
ApFindAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability,
    OUT UCHAR *pOffset,
    OUT PPCI_COMMON_CONFIG PciCommonConfig OPTIONAL
    );


NTSTATUS
ApQueryBusInterface(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PBUS_INTERFACE_STANDARD BusInterface
    )
/*++

Routine Description:

    Sends a query-interface IRP to the specified device object
    to obtain the BUS_INTERFACE_STANDARD interface.

Arguments:

    DeviceObject - Supplies the device object to send the BUS_INTERFACE_STANDARD to

    BusInterface - Returns the bus interface

Return Value:

    STATUS_SUCCESS if successful
    NTSTATUS if unsuccessful

--*/

{
    PIRP Irp;
    KEVENT Event;
    PIO_STACK_LOCATION IrpSp;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    ULONG ReturnLength;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    Irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        &Event,
                                        &IoStatusBlock );
    if (Irp == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IrpSp = IoGetNextIrpStackLocation( Irp );
    ASSERT(IrpSp != NULL);
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
    IrpSp->MajorFunction = IRP_MJ_PNP;
    IrpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
    IrpSp->Parameters.QueryInterface.InterfaceType = (LPGUID)&GUID_BUS_INTERFACE_STANDARD;
    IrpSp->Parameters.QueryInterface.Size = sizeof(BUS_INTERFACE_STANDARD);
    IrpSp->Parameters.QueryInterface.Version = 1;
    IrpSp->Parameters.QueryInterface.Interface = (PINTERFACE)BusInterface;
    IrpSp->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    Status = IoCallDriver(DeviceObject, Irp);
    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
        Status = Irp->IoStatus.Status;
    }

    return(Status);
}

#if (WINVER > 0x501)

NTSTATUS
ApQueryAgpTargetBusInterface(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PBUS_INTERFACE_STANDARD BusInterface,
    OUT PUCHAR CapabilityID
    )
/*++

Routine Description:

    Sends a query-interface IRP to the specified device object
    to obtain the BUS_INTERFACE_STANDARD interface.

Arguments:

    DeviceObject - Supplies the device object to send the
                   BUS_INTERFACE_STANDARD to

    BusInterface - Returns the bus interface

    CapabilityID - Capability ID of AGP

Return Value:

    STATUS_SUCCESS if successful
    NTSTATUS if unsuccessful

--*/

{
    PIRP Irp;
    KEVENT Event;
    PIO_STACK_LOCATION IrpSp;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    ULONG ReturnLength;
    AGP_TARGET_BUS_INTERFACE_STANDARD AgpTargetBusInterface;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    Irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        &Event,
                                        &IoStatusBlock );
    if (Irp == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IrpSp = IoGetNextIrpStackLocation( Irp );
    ASSERT(IrpSp != NULL);
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
    IrpSp->MajorFunction = IRP_MJ_PNP;
    IrpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
    IrpSp->Parameters.QueryInterface.InterfaceType =
        (LPGUID)&GUID_AGP_TARGET_BUS_INTERFACE_STANDARD;
    IrpSp->Parameters.QueryInterface.Size =
        sizeof(AGP_TARGET_BUS_INTERFACE_STANDARD);
    IrpSp->Parameters.QueryInterface.Version = 1;
    IrpSp->Parameters.QueryInterface.Interface =
        (PINTERFACE)&AgpTargetBusInterface;
    IrpSp->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    Status = IoCallDriver(DeviceObject, Irp);
    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
        Status = Irp->IoStatus.Status;
    }

    //
    // Rather than change all the AGP library config functions to deal with
    // the different interfaces, and since all we are interested in are the
    // config space functions, we will simply copy the AGP target bus
    // interface into a BUS_INTERFACE_STANDARD
    //
    if (NT_SUCCESS(Status)) {
        BusInterface->Size = AgpTargetBusInterface.Size;
        BusInterface->Version = AgpTargetBusInterface.Version;
        BusInterface->Context = AgpTargetBusInterface.Context;
        BusInterface->InterfaceReference =
            AgpTargetBusInterface.InterfaceReference;
        BusInterface->InterfaceDereference =
            AgpTargetBusInterface.InterfaceDereference;
        BusInterface->SetBusData = AgpTargetBusInterface.SetBusData;
        BusInterface->GetBusData = AgpTargetBusInterface.GetBusData;
        *CapabilityID =  AgpTargetBusInterface.CapabilityID;
    }
    
    return(Status);
}
#endif


NTSTATUS
ApGetSetDeviceBusData(
    IN PCOMMON_EXTENSION Extension,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Reads or writes PCI config space for the specified device.

Arguments:

    Extension - Supplies the common AGP extension

    Read - if TRUE, this is a READ IRP
           if FALSE, this is a WRITE IRP

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    ULONG ReturnLength;
    ULONG Transferred;

    //
    // First check our device extension. This must be either a master
    // or target extension, we don't care too much which.
    //
    ASSERT((Extension->Signature == TARGET_SIG) ||
           (Extension->Signature == MASTER_SIG));

    //
    // Now we simply use our bus interface to call directly to PCI.
    //

    if (Read) {
        Transferred = Extension->BusInterface.GetBusData(Extension->BusInterface.Context,
                                                         PCI_WHICHSPACE_CONFIG,
                                                         Buffer,
                                                         Offset,
                                                         Length);
    } else {
        Transferred = Extension->BusInterface.SetBusData(Extension->BusInterface.Context,
                                                         PCI_WHICHSPACE_CONFIG,
                                                         Buffer,
                                                         Offset,
                                                         Length);
    }
    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}


VOID
AgpLibReadAgpTargetConfig(
    IN PVOID AgpExtension,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Size
    )
/*++

Routine Description:

    Read PCI config space for the specified device

Arguments:

    Extension - Supplies the common AGP extension

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read
             should begin

    Length - Supplies the number of bytes to be read

Return Value:

    None

--*/
{
    NTSTATUS Status;
    PTARGET_EXTENSION Extension;
    
    GET_TARGET_EXTENSION(Extension, AgpExtension);

    Status = ApGetSetDeviceBusData((PCOMMON_EXTENSION)Extension,
                                   TRUE,
                                   Buffer,
                                   Offset,
                                   Size
                                   );

    AGP_ASSERT(NT_SUCCESS(Status));
}



VOID
AgpLibWriteAgpTargetConfig(
    IN PVOID AgpExtension,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Size
    )
/*++

Routine Description:

    Write PCI config space for the specified AGP device

Arguments:

    Extension - Supplies the common AGP extension

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the write
             should begin

    Length - Supplies the number of bytes to be write

Return Value:

    None

--*/
{
    NTSTATUS Status;
    PTARGET_EXTENSION Extension;
    
    GET_TARGET_EXTENSION(Extension, AgpExtension);
    
    Status = ApGetSetDeviceBusData((PCOMMON_EXTENSION)Extension,
                                   FALSE,
                                   Buffer,
                                   Offset,
                                   Size
                                   );

    AGP_ASSERT(NT_SUCCESS(Status));
}


NTSTATUS
ApFindAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability,
    OUT UCHAR *pOffset,
    OUT PPCI_COMMON_CONFIG PciCommonConfig OPTIONAL
    )
/*++

Routine Description:

    Finds the capability offset for the specified device and
    reads in the header.

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the AGP Capabilities common header

    pOffset - Returns the offset into config space.

    PciCommonConfig - NULL, or points to the PCI common configuration header

Return Value:

    NTSTATUS

--*/

{
    PCI_COMMON_HEADER Header;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    //
    // Read the PCI common header to get the capabilities pointer
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         PciConfig,
                         0,
                         sizeof(PCI_COMMON_HEADER));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - read PCI Config space for Context %08lx failed %08lx\n",
                Context,
                Status));
        return(Status);
    }

    //
    // Check the Status register to see if this device supports capability lists.
    // If not, it is not an AGP-compliant device.
    //
    if ((PciConfig->Status & PCI_STATUS_CAPABILITIES_LIST) == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - Context %08lx does not support Capabilities list, not an AGP device\n",
                Context));
        return(STATUS_NOT_IMPLEMENTED);
    }

    //
    // The device supports capability lists, find the AGP capabilities
    //
    if ((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_BRIDGE_TYPE) {
        CapabilityOffset = PciConfig->u.type1.CapabilitiesPtr;
    } else {
        ASSERT((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_DEVICE_TYPE);
        CapabilityOffset = PciConfig->u.type0.CapabilitiesPtr;
    }
    while (CapabilityOffset != 0) {

        //
        // Read the Capability at this offset
        //
        Status = (pConfigFn)(Context,
                             TRUE,
                             Capability,
                             CapabilityOffset,
                             sizeof(PCI_CAPABILITIES_HEADER));
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpLibGetAgpCapability - read PCI Capability at offset %x for Context %08lx failed %08lx\n",
                    CapabilityOffset,
                    Context,
                    Status));
            return(Status);
        }
        if ((Capability->Header.CapabilityID == PCI_CAPABILITY_ID_AGP) ||
            (Capability->Header.CapabilityID == PCI_CAPABILITY_ID_AGP_TARGET)){
            //
            // Found the AGP Capability
            //
            break;
        } else {
            //
            // This is some other Capability, keep looking for the AGP Capability
            //
            CapabilityOffset = Capability->Header.Next;
        }
    }
    if (CapabilityOffset == 0) {
        //
        // No AGP capability was found
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - Context %08lx does have an AGP Capability entry, not an AGP device\n",
                Context));
        return(STATUS_NOT_IMPLEMENTED);
    }

    AGPLOG(AGP_NOISE,
           ("AgpLibGetAgpCapability - Context %08lx has AGP Capability at offset %x\n",
            Context,
            CapabilityOffset));

    *pOffset = CapabilityOffset;

    if (PciCommonConfig) {
        RtlCopyMemory(PciCommonConfig, PciConfig, sizeof(PCI_COMMON_HEADER));
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN BOOLEAN DoSpecial,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    DoSpecial - Indicates whether we should apply any "special" tweaks

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    ULONGLONG DeviceFlags;
    UCHAR CapabilityOffset;
    PCI_COMMON_HEADER Header;
    USHORT SubVendorID, SubSystemID;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
 
    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset,
                                 PciConfig);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Read the rest of the AGP capability
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         &Capability->Header,
                         CapabilityOffset,
                         sizeof(PCI_AGP_CAPABILITY));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - read AGP Capability at offset %x for Context %08lx failed %08lx\n",
                CapabilityOffset,
                Context,
                Status));
        return(Status);
    }

    //
    // Check device flags for broken HW, we may need to tweak caps
    //
    if ((PCI_CONFIGURATION_TYPE(PciConfig) == PCI_DEVICE_TYPE) &&
        (PciConfig->BaseClass != PCI_CLASS_BRIDGE_DEV)) {
        SubVendorID = PciConfig->u.type0.SubVendorID;
        SubSystemID = PciConfig->u.type0.SubSystemID;
    } else {
        SubVendorID = 0;
        SubSystemID = 0;
    }
    
    DeviceFlags = AgpGetDeviceFlags(AgpGlobalHackTable,
                                    PciConfig->VendorID,
                                    PciConfig->DeviceID,
                                    SubVendorID,
                                    SubSystemID,
                                    PciConfig->RevisionID);

    DeviceFlags |= AgpGetDeviceFlags(AgpDeviceHackTable,
                                     PciConfig->VendorID,
                                     PciConfig->DeviceID,
                                     SubVendorID,
                                     SubSystemID,
                                     PciConfig->RevisionID);
    
    if (DeviceFlags & AGP_FLAG_NO_1X_RATE) {
        if (Capability->AGPStatus.Agp3Mode == 0) {
            Capability->AGPStatus.Rate &= ~PCI_AGP_RATE_1X;
            
            AGPLOG(AGP_WARNING,
                   ("AGP HAMMER CAPS: NO_1X_RATE Vendor %x, Device %x.\n",
                    PciConfig->VendorID,
                    PciConfig->DeviceID));
        }
    }
    
    if (DeviceFlags & AGP_FLAG_NO_2X_RATE) {
        if (Capability->AGPStatus.Agp3Mode == 0) {
            Capability->AGPStatus.Rate &= ~PCI_AGP_RATE_2X;
        
            AGPLOG(AGP_WARNING,
                   ("AGP HAMMER CAPS: NO_2X_RATE Vendor %x, Device %x.\n",
                    PciConfig->VendorID,
                    PciConfig->DeviceID));
        }
    }
    
    if (DeviceFlags & AGP_FLAG_NO_4X_RATE) {
        if (Capability->AGPStatus.Agp3Mode == 0) {
            Capability->AGPStatus.Rate &= ~PCI_AGP_RATE_4X;
        } else {
            Capability->AGPStatus.Rate &= ~PCI_AGP_RATE_1X;
        }

        AGPLOG(AGP_WARNING,
               ("AGP HAMMER CAPS: NO_4X_RATE Vendor %x, Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }
    
    if (DeviceFlags & AGP_FLAG_NO_8X_RATE) {
        if (Capability->AGPStatus.Agp3Mode == 1) {
            Capability->AGPStatus.Rate &= ~PCI_AGP_RATE_2X;
            
            AGPLOG(AGP_WARNING,
                   ("AGP HAMMER CAPS: NO_8X_RATE Vendor %x, Device %x.\n",
                    PciConfig->VendorID,
                    PciConfig->DeviceID));
        }
    }
    
    if (DeviceFlags & AGP_FLAG_NO_SBA_ENABLE) {
        Capability->AGPStatus.SideBandAddressing = 0;
        
        AGPLOG(AGP_WARNING,
               ("AGP HAMMER CAPS: NO_SBA_ENABLE Vendor %x, Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }
    
    if (DeviceFlags & AGP_FLAG_REVERSE_INITIALIZATION) {
        
        AGPLOG(AGP_WARNING,
               ("AGP GLOBAL HACK: REVERSE_INITIALIZATION Vendor %x, "
                "Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }

    //
    // Test if this device requires any platform specific AGP tweaks
    //
    if (DoSpecial && (DeviceFlags > AGP_FLAG_SPECIAL_TARGET) ||
        (DeviceFlags & AGP_FLAG_REVERSE_INITIALIZATION)) {
        AgpSpecialTarget(
            ((((PCOMMON_EXTENSION)Context)->Signature == MASTER_SIG) ?
             GET_AGP_CONTEXT_FROM_MASTER((PMASTER_EXTENSION)Context):
             GET_AGP_CONTEXT((PTARGET_EXTENSION)Context)),
            ((DeviceFlags & ~AGP_FLAG_SPECIAL_TARGET) |
             (DeviceFlags & AGP_FLAG_REVERSE_INITIALIZATION)));
    }
    
    AGPLOG(AGP_NOISE,
           ("AGP CAPABILITY: version %d.%d\n",Capability->Major, Capability->Minor));
    AGPLOG(AGP_NOISE,
           ("\tSTATUS  - Rate: %x  SBA: %x  RQ: %02x\n",
           Capability->AGPStatus.Rate,
           Capability->AGPStatus.SideBandAddressing,
           Capability->AGPStatus.RequestQueueDepthMaximum));
    AGPLOG(AGP_NOISE,
           ("\tCOMMAND - Rate: %x  SBA: %x  RQ: %02x  AGPEnable: %x\n",
           Capability->AGPCommand.Rate,
           Capability->AGPCommand.SBAEnable,
           Capability->AGPCommand.RequestQueueDepth,
           Capability->AGPCommand.AGPEnable));

    return(STATUS_SUCCESS);
}


NTSTATUS
ApGetExtendedAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN EXTENDED_AGP_REGISTER RegSelect,
    OUT PVOID ExtCapReg
    )
/*++

Routine Description:

    This routine finds and retrieves the extended AGP capabilities in the
    PCI config space of the AGP device

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
                on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    RegSelect - Selects the extended capability register

    ExtCapReg - Returns the current value of the extended AGP
                capability register

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;
    ULONGLONG DeviceFlags;
    UCHAR CapabilityOffset;
    PCI_COMMON_HEADER Header;
    PCI_AGP_CAPABILITY Capability;
    USHORT SubVendorID, SubSystemID;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
    ULONG CopySize;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 &Capability,
                                 &CapabilityOffset,
                                 PciConfig);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    CapabilityOffset += sizeof(PCI_AGP_CAPABILITY);

    switch (RegSelect) {

        case IsochStatus:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, IsochStatus);
            CopySize = sizeof(PCI_AGP_ISOCH_STATUS);
            break;
            
        case AgpControl:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, AgpControl);
            CopySize = sizeof(PCI_AGP_CONTROL);
            break;
            
        case ApertureSize:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, ApertureSize);
            CopySize = sizeof(USHORT);
            break;
            
        case AperturePageSize:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, AperturePageSize);
            CopySize = sizeof(PCI_AGP_APERTURE_PAGE_SIZE);
            break;
            

        case GartLow:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, GartLow);
            CopySize = sizeof(ULONG);
            break;

        case GartHigh:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, GartHigh);
            CopySize = sizeof(ULONG);
            break;

        case IsochCommand:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, IsochCommand);
            CopySize = sizeof(PCI_AGP_ISOCH_COMMAND);
            break;
            
        default:
            Status = STATUS_NOT_IMPLEMENTED;
    }

    //
    // Read the extended AGP capability
    //
    if (NT_SUCCESS(Status)) {
        Status = (pConfigFn)(Context,
                             TRUE,
                             ExtCapReg,
                             CapabilityOffset,
                             CopySize);
    }
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetExtendedAgpCapability - read extended AGP "
                "Capability at offset %x for Context %08lx failed %08lx\n",
                CapabilityOffset,
                Context,
                Status));
        return Status;
    }
    
#if DBG
    switch (RegSelect) {

        case IsochStatus:
            AGPLOG(AGP_NOISE,
                   ("\tISOCH_STATUS  - Err: %x  L: %x  Y: %x  N: %02x\n",
                    ((PPCI_AGP_ISOCH_STATUS)ExtCapReg)->ErrorCode,
                    ((PPCI_AGP_ISOCH_STATUS)ExtCapReg)->Isoch_L,
                    ((PPCI_AGP_ISOCH_STATUS)ExtCapReg)->Isoch_Y,
                    ((PPCI_AGP_ISOCH_STATUS)ExtCapReg)->Isoch_N));
            break;

        case AgpControl:
            AGPLOG(AGP_NOISE,
                   ("\tAGP_CONTROL   - GTLB_Enable: %x  AP_Enable: %x  "
                    "CAL_Disable: %x\n",
                    ((PPCI_AGP_CONTROL)ExtCapReg)->GTLB_Enable,
                    ((PPCI_AGP_CONTROL)ExtCapReg)->AP_Enable,
                    ((PPCI_AGP_CONTROL)ExtCapReg)->CAL_Disable));
            break;

        case ApertureSize:
            AGPLOG(AGP_NOISE,
                   ("\tAP_SIZES      - AP_Size: %x\n",
                    *(PUSHORT)ExtCapReg));
            break;
                   
        case AperturePageSize:
            AGPLOG(AGP_NOISE,
                   ("\tAP_PAGE_SIZE  - AP_PageSizeMask: %x  "
                    "AP_PageSizeSelect %x\n",
                    ((PPCI_AGP_APERTURE_PAGE_SIZE)ExtCapReg)->PageSizeMask,
                    ((PPCI_AGP_APERTURE_PAGE_SIZE)ExtCapReg)->PageSizeSelect));
            break;
     
        case GartLow:
            AGPLOG(AGP_NOISE,
                   ("\tGART_ADDR     - Low: %08x\n",
                    *(PULONG)ExtCapReg));
            break;

        case GartHigh:
            AGPLOG(AGP_NOISE,
                   ("\tGART_ADDR     - High: %08x\n",
                    *(PULONG)ExtCapReg));
            break;
           
        case IsochCommand:
            AGPLOG(AGP_NOISE,
                   ("\tISOCH_COMMAND -                 Y: %x  N: %02x\n",
                    ((PPCI_AGP_ISOCH_COMMAND)ExtCapReg)->Isoch_Y,
                    ((PPCI_AGP_ISOCH_COMMAND)ExtCapReg)->Isoch_N));
            break;

    }
#endif // DBG

    return Status;
}


NTSTATUS
AgpLibGetTargetCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the AGP target (AGP bridge)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

    CapabilityOffset - Optional parameter returns the capabiltiy offset

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    PTARGET_EXTENSION Extension;

    GET_TARGET_EXTENSION(Extension, AgpExtension);

    Status = AgpLibGetAgpCapability(ApGetSetDeviceBusData,
                                    Extension,
                                    TRUE,
                                    Capability);

    if (NT_SUCCESS(Status)) {
        Globals.AgpStatus = *(PULONG)&Capability->AGPStatus;
    }

    return Status;
}


NTSTATUS
AgpLibGetExtendedTargetCapability(
    IN PVOID AgpExtension,
    IN EXTENDED_AGP_REGISTER RegSelect,
    OUT PVOID ExtCapReg
    )
/*++

Routine Description:

    Retrieves the AGP capability for the AGP target (AGP bridge)

Arguments:

    AgpExtension - Supplies the AGP extension

    RegSelect - Selects the extended capability register

    ExtCapReg - Returns the current value of the extended AGP
                capability register

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;
    PTARGET_EXTENSION Extension;

    GET_TARGET_EXTENSION(Extension, AgpExtension);

    Status = ApGetExtendedAgpCapability(ApGetSetDeviceBusData,
                                        Extension,
                                        RegSelect,
                                        ExtCapReg);

    //
    // Add WMI goop for extended...
    //

    return Status;
}


NTSTATUS
AgpLibGetExtendedMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_ISOCH_STATUS IsochStat
    )
/*++

Routine Description:

    Retrieves the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    IsochStat - Returns the current value of the isochronous status
                extended AGP capability register

Return Value:

    NTSTATUS

--*/

{
    PMASTER_EXTENSION Extension;

    GET_MASTER_EXTENSION(Extension, AgpExtension);

    return(ApGetExtendedAgpCapability(ApGetSetDeviceBusData,
                                      Extension,
                                      IsochStatus,
                                      IsochStat));
}


NTSTATUS
AgpLibGetMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    PMASTER_EXTENSION Extension;

    GET_MASTER_EXTENSION(Extension, AgpExtension);

    return(AgpLibGetAgpCapability(ApGetSetDeviceBusData,
                                  Extension,
                                  TRUE,
                                  Capability));
}


NTSTATUS
AgpLibSetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset,
                                 NULL);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Now that we know the offset, write the supplied command register
    //
    Status = (pConfigFn)(Context,
                         FALSE,
                         &Capability->AGPCommand,
                         CapabilityOffset + FIELD_OFFSET(PCI_AGP_CAPABILITY, AGPCommand),
                         sizeof(Capability->AGPCommand));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibSetAgpCapability - Set AGP command at offset %x for Context %08lx failed %08lx\n",
                CapabilityOffset,
                Context,
                Status));
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
ApSetExtendedAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN EXTENDED_AGP_REGISTER RegSelect,
    IN PVOID ExtCapReg
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    RegSelect - Selects the extended register to update

    ExtCapReg - Supplies the extended AGP capability register value
                to write

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;
    UCHAR CapabilityOffset;
    PCI_AGP_CAPABILITY Capability;
    ULONG CopySize;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 &Capability,
                                 &CapabilityOffset,
                                 NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    CapabilityOffset += sizeof(PCI_AGP_CAPABILITY);

    switch (RegSelect) {

        case AgpControl:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, AgpControl);
            CopySize = sizeof(PCI_AGP_CONTROL);
            break;
            
        case ApertureSize:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, ApertureSize);
            CopySize = sizeof(USHORT);
            break;
            
        case AperturePageSize:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, AperturePageSize);
            CopySize = sizeof(PCI_AGP_APERTURE_PAGE_SIZE);
            break;
            
        case GartLow:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, GartLow);
            CopySize = sizeof(ULONG);
            break;

        case GartHigh:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, GartHigh);
            CopySize = sizeof(ULONG);
            break;

        case IsochCommand:
            CapabilityOffset +=
                FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, IsochCommand);
            CopySize = sizeof(PCI_AGP_ISOCH_COMMAND);
            break;
            
        default:
            Status = STATUS_NOT_IMPLEMENTED;
    }
    
    if (NT_SUCCESS(Status)) {
        Status = (pConfigFn)(Context,
                             FALSE,
                             ExtCapReg,
                             CapabilityOffset,
                             CopySize);
    }

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibSetExtendedAgpCapability - Set extended capability "
                "at offset %x for Context %08lx failed %08lx\n",
                CapabilityOffset,
                Context,
                Status));
    }
    
    return Status;
}


NTSTATUS
AgpLibSetTargetCapability(
    IN PVOID AgpExtension,
    IN PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the AGP target (AGP bridge)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    PTARGET_EXTENSION Extension;

    Globals.AgpCommand = *(PULONG)&Capability->AGPCommand;

    GET_TARGET_EXTENSION(Extension, AgpExtension);

    return(AgpLibSetAgpCapability(ApGetSetDeviceBusData,
                                  Extension,
                                  Capability));
}


NTSTATUS
AgpLibSetExtendedTargetCapability(
    IN PVOID AgpExtension,
    IN EXTENDED_AGP_REGISTER RegSelect,
    IN PVOID ExtCapReg
    )
/*++

Routine Description:

    Sets the extended AGP capability for the AGP target (AGP bridge)

Arguments:

    AgpExtension - Supplies the AGP extension

    RegSelect - Selects the extended register to update

    ExtCapReg - Supplies the extended AGP capability register value
                to write

Return Value:

    NTSTATUS

--*/
{
    PTARGET_EXTENSION Extension;

    //
    // Add extended WMI goop here...
    //

    GET_TARGET_EXTENSION(Extension, AgpExtension);

    return(ApSetExtendedAgpCapability(ApGetSetDeviceBusData,
                                      Extension,
                                      RegSelect,
                                      ExtCapReg));
}


NTSTATUS
AgpLibSetMasterCapability(
    IN PVOID AgpExtension,
    IN PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    PMASTER_EXTENSION Extension;

    GET_MASTER_EXTENSION(Extension, AgpExtension);

    return(AgpLibSetAgpCapability(ApGetSetDeviceBusData,
                                  Extension,
                                  Capability));
}


NTSTATUS
AgpLibSetExtendedMasterCapability(
    IN PVOID AgpExtension,
    IN PPCI_AGP_ISOCH_COMMAND IsochCmd
    )
/*++

Routine Description:

    Sets the extended AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    IsochCmd - Supplies the value to write to the isochronous
               command extended AGP capability register

Return Value:

    NTSTATUS

--*/
{
    PMASTER_EXTENSION Extension;

    GET_MASTER_EXTENSION(Extension, AgpExtension);

    return(ApSetExtendedAgpCapability(ApGetSetDeviceBusData,
                                      Extension,
                                      IsochCommand,
                                      IsochCmd));
}


NTSTATUS
AgpLibGetMasterDeviceId(
    IN PVOID AgpExtension,
    OUT PULONG DeviceId
    )
/*++

Routine Description:

    This function returns the PCI DeviceId/Vendo58rId of the master AGP
    device

Arguments:

    DeviceId - Identifies PCI manufaturer and device of master

Return Value:

    STATUS_SUCCESS or an appropriate error status

--*/
{
    PCI_COMMON_HEADER Header;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
    NTSTATUS Status;
    PMASTER_EXTENSION Master = NULL;
    PTARGET_EXTENSION Target = NULL;

    //
    // Try to make this as idiot proof as possible for the case
    // where this is called from SetAperture on a system without
    // an AGP adapter, so we don't AV if some context hasn't been
    // initialized, or is missing...
    //

    Target = CONTAINING_RECORD(AgpExtension,
                               TARGET_EXTENSION,
                               AgpContext);
    
    if (Target) {
        if (Target->CommonExtension.Signature == TARGET_SIG) {
            if (Target->ChildDevice) {        
                if (Target->ChildDevice->CommonExtension.Signature ==
                    MASTER_SIG) {
                    Master = Target->ChildDevice;
                }
            }
        }
    }

    if (Master) {

        //
        // Read the PCI common header to get the capabilities pointer
        //
        Status = (ApGetSetDeviceBusData)((PCOMMON_EXTENSION)Master,
                                         TRUE,
                                         PciConfig,
                                         0,
                                         sizeof(PCI_COMMON_HEADER));
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpLibGetMasterDeviceId - read PCI Config space for Context %08lx failed %08lx\n",
                    Master,
                    Status));
            return Status;
        }
        
        *DeviceId = *(PULONG)PciConfig;
        
    } else {
        *DeviceId = (ULONG)-1;
    }

    return STATUS_SUCCESS;
}

#if (WINVER < 0x502)


ULONG
ApLegacyGetBusData(
    IN PVOID Context,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Used to read AGP2 capabilities and registers in absence of agp target
    bus interface standard (W2K/XP), calls obsolete HAL API to do the dirty
    work, this is included so DDK samples can run on old OS

Arguments:

    Context - Not used

    DataType - PCIConfiguration

    Buffer - Bytes read get copied into this buffer

    Offset - Offset into device config space to begin read

    Length - Bytes

Return Value:

    Returns the number of bytes read

--*/
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(DataType);

    return HalGetBusDataByOffset(PCIConfiguration,
                                 0,
                                 0,
                                 Buffer,
                                 Offset,
                                 Length);
}



ULONG
ApLegacySetBusData(
    IN PVOID Context,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Used to write AGP2 capabilities and registers in absence of agp target
    bus interface standard (W2K/XP), calls obsolete HAL API to do the dirty
    work, this is included so DDK samples can run on old OS

Arguments:

    Context - Not used

    DataType - PCIConfiguration

    Buffer - Contains info to write to device

    Offset - Offset into config space to begin write

    Length - Bytes

Return Value:

    Returns the number of bytes written

--*/
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(DataType);

    return HalSetBusDataByOffset(PCIConfiguration,
                                 0,
                                 0,
                                 Buffer,
                                 Offset,
                                 Length);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib3\dispatch.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    IRP dispatching routines for the common AGPLIB library

Author:

    John Vert (jvert) 10/25/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/
#include "agplib.h"

//
// Two flavors of each dispatch routine, one for the target (AGP bridge) filter and
// one for the master (video card) filter.
//

NTSTATUS
AgpTargetDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpMasterDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PMASTER_EXTENSION Extension
    );

NTSTATUS
AgpTargetDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpMasterDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PMASTER_EXTENSION Extension
    );

NTSTATUS
AgpCancelMasterRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMASTER_EXTENSION Extension
    );

NTSTATUS
AgpMasterPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMASTER_EXTENSION Extension
    );

NTSTATUS
AgpTargetPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpDispatchPnp)
#pragma alloc_text(PAGE, AgpDispatchDeviceControl)
#pragma alloc_text(PAGE, AgpDispatchWmi)
#pragma alloc_text(PAGE, AgpTargetDispatchPnp)
#pragma alloc_text(PAGE, AgpMasterDispatchPnp)
#pragma alloc_text(PAGE, AgpCancelMasterRemove)
#endif



NTSTATUS
AgpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Main dispatch routine for PNP irps sent to the AGP bus filter driver

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the PNP Irp.

Return Value:

    NTSTATUS

--*/
{
    PCOMMON_EXTENSION Extension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // We're deleted, fail the irp
    //
    if (Extension->Deleted == TRUE) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ASSERT(Extension->AttachedDevice != NULL);

    if (Extension->Type == AgpTargetFilter) {
        return(AgpTargetDispatchPnp(DeviceObject,
                                    Irp,
                                    DeviceObject->DeviceExtension));
    } else {
        ASSERT(Extension->Type == AgpMasterFilter);
        return(AgpMasterDispatchPnp(DeviceObject,
                                    Irp,
                                    DeviceObject->DeviceExtension));
    }
}


NTSTATUS
AgpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Main dispatch routine for power irps sent to the AGP bus filter driver

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the power Irp.

Return Value:

    NTSTATUS

--*/
{
    PCOMMON_EXTENSION Extension = DeviceObject->DeviceExtension;

    //
    // We're deleted, fail the irp
    //
    if (Extension->Deleted == TRUE) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ASSERT(Extension->AttachedDevice != NULL);

   if (Extension->Type == AgpTargetFilter) {
        return(AgpTargetDispatchPower(DeviceObject,
                                      Irp,
                                      DeviceObject->DeviceExtension));
    } else {
        ASSERT(Extension->Type == AgpMasterFilter);
        return(AgpMasterDispatchPower(DeviceObject,
                                      Irp,
                                      DeviceObject->DeviceExtension));
    }
}


NTSTATUS
AgpTargetDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Dispatch routine for PNP irps sent to the AGP bus filter driver
    attached to the target (AGP bridge) PDO.

Arguments:

    DeviceObject - Supplies the AGP target device object

    Irp - Supplies the PNP Irp.

    Extension - Supplies the AGP target device extension

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    AGPLOG(AGP_IRPTRACE,
           ("AgpTargetDispatchPnp: IRP 0x%x\n", irpStack->MinorFunction));

    switch (irpStack->MinorFunction) {
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            AGPLOG(AGP_NOISE,
                   ("AgpTargetDispatchPnp: IRP_MN_FILTER_RESOURCE_REQUIREMENTS to %08lx\n",
                    DeviceObject));

            Status = AgpFilterResourceRequirements(DeviceObject, Irp, Extension);
            break;

        case IRP_MN_QUERY_RESOURCES:
            AGPLOG(AGP_NOISE,
                   ("AgpTargetDispatchPnp: IRP_MN_QUERY_RESOURCES to %08lx\n",
                    DeviceObject));

            //
            // We must handle this IRP on the way back so we can add the AGP
            // resources on to it. Set a completion routine.
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   AgpQueryResources,
                                   Extension,
                                   TRUE,
                                   FALSE,
                                   FALSE);
            Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);
            return Status ;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            if (irpStack->Parameters.QueryDeviceRelations.Type == BusRelations) {
                KEVENT event;

                KeInitializeEvent(&event, NotificationEvent, FALSE);

                //
                // We must handle this IRP on the way back so that we can attach
                // a filter to any child PDOs of our PCI-PCI bridge.
                //
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       AgpSetEventCompletion,
                                       &event,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

                //
                // If we did things asynchronously then wait on our event
                //
                if (Status == STATUS_PENDING) {

                    //
                    // We do a KernelMode wait so that our stack where the
                    // event is doesn't get paged out!
                    //
                    KeWaitForSingleObject(&event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL);
                    Status = Irp->IoStatus.Status;
                }

                if (NT_SUCCESS(Status)) {
                    Status = AgpAttachDeviceRelations(DeviceObject,
                                                      Irp,
                                                      Extension);
                    Irp->IoStatus.Status = Status;
                }

                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return Status;

            } else {
                break;
            }

        case IRP_MN_START_DEVICE:
            //
            // We need to hook this in order to filter out any AGP
            // resources that have been added.
            //
            return(AgpStartTarget(Irp, Extension));

        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:

            //
            // We can always succeed this.
            //
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:
            AgpDisableAperture(GET_AGP_CONTEXT(Extension));

            //
            // Pass the irp down
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

            //
            // Clean up and delete ourselves
            //
            AgpWmiDeRegistration(Extension);
            Extension->CommonExtension.Deleted = TRUE;
            IoDetachDevice(Extension->CommonExtension.AttachedDevice);
            Extension->CommonExtension.AttachedDevice = NULL;
            RELEASE_BUS_INTERFACE(Extension);
            if (Extension->FavoredMemory.Ranges) {
               ExFreePool(Extension->FavoredMemory.Ranges);
            }
            if (Extension->Resources) {
                ExFreePool(Extension->Resources);
            }
            if (Extension->ResourcesTranslated) {
                ExFreePool(Extension->ResourcesTranslated);
            }
            ExFreePool(Extension->Lock);;
            IoDeleteDevice(DeviceObject);
            return(Status);

        case IRP_MN_STOP_DEVICE:
            AgpDisableAperture(GET_AGP_CONTEXT(Extension));
            Status = STATUS_SUCCESS;
            break;  // forward irp down the stack

    }

    ASSERT(Status != STATUS_PENDING);

    if (Status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = Status;
    }

    if (NT_SUCCESS(Status) || (Status == STATUS_NOT_SUPPORTED)) {

        //
        // Forward IRP to PCI driver
        //
        IoSkipCurrentIrpStackLocation(Irp);
        return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));

    } else {

        Status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT) ;
        return Status ;
    }
}


NTSTATUS
AgpDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Main dispatch routine for device control irps sent to the AGP bus filter driver

    AGP currently does not support any device controls. So we just pass everything
    down and hope the PDO knows what to do with it.

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the power Irp.

Return Value:

    NTSTATUS

--*/
{
    PCOMMON_EXTENSION Extension = DeviceObject->DeviceExtension;
    PAGED_CODE();

    //
    // We're deleted, fail the irp
    //
    if (Extension->Deleted == TRUE) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ASSERT(Extension->AttachedDevice != NULL);

    IoSkipCurrentIrpStackLocation(Irp);
    return(IoCallDriver(Extension->AttachedDevice, Irp));
}


NTSTATUS
AgpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Main dispatch routine for system control irps sent to the AGP bus filter
    driver.

    AGP currently does not support any WMI IRPs, so we just pass everything
    down and hope the PDO knows what to do with it.

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the power Irp.

Return Value:

    NTSTATUS

--*/
{
    PCOMMON_EXTENSION Extension = DeviceObject->DeviceExtension;
    PAGED_CODE();

    //
    // We're deleted, fail the irp
    //
    if (Extension->Deleted == TRUE) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ASSERT(Extension->AttachedDevice != NULL);

    //
    // Return AGP info for target device
    //
    if (Extension->Type == AgpTargetFilter) {
        return AgpSystemControl(DeviceObject, Irp);
    }

    IoSkipCurrentIrpStackLocation(Irp);
    return(IoCallDriver(Extension->AttachedDevice, Irp));
}


NTSTATUS
AgpTargetDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
{
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    AGPLOG(AGP_IRPTRACE,
           ("AgpTargetDispatchPower: IRP 0x%x\n", irpStack->MinorFunction));

    //
    // All we keep track of are Dx states. PCI is responsible for mapping
    // S-states into D states.
    //


    if ((irpStack->MinorFunction == IRP_MN_SET_POWER) &&
        (irpStack->Parameters.Power.Type == DevicePowerState) &&
        (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0)) {

        NTSTATUS Status;

        //
        // We need to reinitialize the target when this IRP has been completed
        // by the lower drivers. Set up our completion handler to finish this.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               AgpTargetPowerUpCompletion,
                               Extension,
                               TRUE,
                               FALSE,
                               FALSE);

        IoMarkIrpPending(Irp);
        PoStartNextPowerIrp(Irp);
        Status = PoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);
        return STATUS_PENDING;
    }
    //
    // Just forward to target device
    //
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return(PoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}


NTSTATUS
AgpMasterDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    Dispatch routine for PNP irps sent to the AGP bus filter driver
    attached to the device PDOs.

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the PNP Irp.

    Extension - Supplies the AGP bridge device extension

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PAGP_BUS_INTERFACE_STANDARD Interface;
    NTSTATUS Status;

    PAGED_CODE();

    AGPLOG(AGP_IRPTRACE,
           ("AgpMasterDispatchPnp: IRP 0x%x\n", irpStack->MinorFunction));

    switch (irpStack->MinorFunction) {
        case IRP_MN_QUERY_INTERFACE:

#if 0
            AGPLOG(AGP_IRPTRACE,
                   ("\tSize=0x%x, Version=%d\n"
                    "\tGUID=0x%08x-0x%04x-0x%04x-0x%02x-"
                    "0x%02x-0x%02x-0x%02x-0x%02x-0x%02x-0x%02x-0x%02x\n",
                    irpStack->Parameters.QueryInterface.Size,
                    irpStack->Parameters.QueryInterface.Version,
                    *(PULONG)irpStack->Parameters.QueryInterface.InterfaceType,
                    *((PUSHORT)irpStack->Parameters.QueryInterface.InterfaceType + 2),
                    *((PUSHORT)irpStack->Parameters.QueryInterface.InterfaceType + 3),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 8),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 9),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 10),

                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 11),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 12),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 13),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 14),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 15)));

#endif

            //
            // The only IRP we look for here is IRP_MN_QUERY_INTERFACE for
            // GUID_AGP_BUS_INTERFACE_STANDARD.
            //
            if ((RtlEqualMemory(
                irpStack->Parameters.QueryInterface.InterfaceType,
                &GUID_AGP_BUS_INTERFACE_STANDARD,
                sizeof(GUID))) &&
                (((irpStack->Parameters.QueryInterface.Size >=
                   sizeof(AGP_BUS_INTERFACE_STANDARD)) &&
                  (irpStack->Parameters.QueryInterface.Version ==
                   AGP_BUS_INTERFACE_V2)) ||
                 ((irpStack->Parameters.QueryInterface.Size >=
                   AGP_BUS_INTERFACE_V1_SIZE) &&
                  (irpStack->Parameters.QueryInterface.Version ==
                   AGP_BUS_INTERFACE_V1)))) {

                Interface = (PAGP_BUS_INTERFACE_STANDARD)irpStack->Parameters.QueryInterface.Interface;

                Interface->Version =
                    irpStack->Parameters.QueryInterface.Version;
                Interface->AgpContext = Extension;
                Interface->InterfaceReference = AgpInterfaceReference;
                Interface->InterfaceDereference = AgpInterfaceDereference;
                Interface->ReserveMemory = AgpInterfaceReserveMemory;
                Interface->ReleaseMemory = AgpInterfaceReleaseMemory;
                Interface->CommitMemory = AgpInterfaceCommitMemory;
                Interface->FreeMemory = AgpInterfaceFreeMemory;
                Interface->GetMappedPages = AgpInterfaceGetMappedPages;

                if (Interface->Version < AGP_BUS_INTERFACE_V2) {
                    Interface->Size = AGP_BUS_INTERFACE_V1_SIZE;
                } else {
                    Interface->Size = sizeof(AGP_BUS_INTERFACE_STANDARD);
                    Interface->SetRate = AgpInterfaceSetRate;
                }

                Interface->Capabilities = Extension->Capabilities;

                //
                // Complete the IRP successfully
                //
                Irp->IoStatus.Status = STATUS_SUCCESS;

                // AGPLOG(AGP_IRPTRACE, ("\tOK.\n"));
            } // else { AGPLOG(AGP_IRPTRACE, ("\tNO!\n")); }
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
            if (irpStack->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE) {
                Extension->RemovePending = TRUE;
            } else {
                Extension->StopPending = TRUE;
            }
            //
            // If we have given out any interfaces or there are some reserved
            // pages, we cannot stop.
            //
            if ((Extension->InterfaceCount > 0) ||
                (Extension->ReservedPages > 0)) {
                AGPLOG(AGP_NOISE,
                       ("AgpMasterDispatchPnp: failing %s due to outstanding interfaces\n",
                        (irpStack->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE)
                            ? "IRP_MN_QUERY_REMOVE_DEVICE"
                            : "IRP_MN_QUERY_STOP_DEVICE"
                       ));

                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return(STATUS_UNSUCCESSFUL);
            } else {
                //
                // We can succeed this, mark our extension as being in limbo so we do
                // not give out any interfaces or anything until we get removed or
                // get a cancel.
                //
                InterlockedIncrement(&Extension->DisableCount);
                break;  // forward irp down the stack
            }

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            //
            // This IRP must be handled on the way back up the stack.
            // Set a completion routine to reenable the device.
            //
            if (Extension->RemovePending) {
                Extension->RemovePending = FALSE;
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       AgpCancelMasterRemove,
                                       Extension,
                                       TRUE,
                                       FALSE,
                                       FALSE);
                return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
            } else {
                //
                // This is a cancel-remove for a query-remove IRP we never saw.
                // Ignore it.
                //
                break;
            }

        case IRP_MN_CANCEL_STOP_DEVICE:
            //
            // This IRP must be handled on the way back up the stack.
            // Set a completion routine to reenable the device.
            //
            if (Extension->StopPending) {
                Extension->StopPending = FALSE;
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       AgpCancelMasterRemove,
                                       Extension,
                                       TRUE,
                                       FALSE,
                                       FALSE);
                return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
            } else {
                //
                // This is a cancel-stop for a query-stop IRP we never saw.
                // Ignore it.
                //
                break;
            }

        case IRP_MN_REMOVE_DEVICE:
            AGPLOG(AGP_NOISE,
                   ("AgpMasterDispatchPnp: removing device due to IRP_MN_REMOVE_DEVICE\n"));

            //
            // PNP is supposed to send us a QUERY_REMOVE before any REMOVE. That is
            // when we check that we are actually in a state where we can be removed.
            // Like all PNP rules, there is an exception - if the START is failed
            // after we have succeeded it, then we get a REMOVE without a QUERY_REMOVE.
            // Obviously this is totally fatal if we have given out interfaces or
            // have pages mapped in the GART. Not much we can do about it then.
            //
            ASSERT(Extension->InterfaceCount == 0);
            ASSERT(Extension->ReservedPages == 0);

            //
            // Pass the IRP down.
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

            //
            // Clean up and delete ourselves
            //
            Extension->Target->ChildDevice = NULL;
            Extension->CommonExtension.Deleted = TRUE;
            IoDetachDevice(Extension->CommonExtension.AttachedDevice);
            Extension->CommonExtension.AttachedDevice = NULL;
            RELEASE_BUS_INTERFACE(Extension);
            IoDeleteDevice(DeviceObject);
            return(Status);

        case IRP_MN_STOP_DEVICE:
            AGPLOG(AGP_NOISE,
                   ("AgpMasterDispatchPnp: stopping device due to IRP_MN_STOP_DEVICE\n"));
            ASSERT(Extension->DisableCount);

            //
            // Just pass the IRP on down
            //
            break;

        case IRP_MN_START_DEVICE:
            AGPLOG(AGP_NOISE,
                   ("AgpMasterDispatchPnp: starting device due to IRP_MN_START_DEVICE\n"));
            ASSERT(Extension->DisableCount);
            InterlockedDecrement(&Extension->DisableCount);
            break;  // forward IRP down the stack
    }

    //
    // Just forward to target device
    //
    IoSkipCurrentIrpStackLocation(Irp);
    return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}

NTSTATUS
AgpMasterDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PMASTER_EXTENSION Extension
    )
{
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    AGPLOG(AGP_IRPTRACE,
           ("AgpMasterDispatchPower: IRP 0x%x\n", irpStack->MinorFunction));

    //
    // All we keep track of are Dx states. Videoport is responsible for mapping
    // S-states into D states.
    //
    if ((irpStack->MinorFunction == IRP_MN_SET_POWER) &&
        (irpStack->Parameters.Power.Type == DevicePowerState) &&
        (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0)) {

        NTSTATUS Status;

        //
        // We need to reinitialize the master when this IRP has been completed
        // by the lower drivers. Set up a completion routine.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               AgpMasterPowerUpCompletion,
                               Extension,
                               TRUE,
                               FALSE,
                               FALSE);

        IoMarkIrpPending(Irp);
        PoStartNextPowerIrp(Irp);
        Status = PoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);
        return STATUS_PENDING;
    }

    //
    // Just forward to target device
    //
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return(PoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}


NTSTATUS
AgpMasterPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    Powerup completion routine for the master device. It reinitializes the
    master registers.

Arguments:

    DeviceObject - supplies the master device object.

    Irp - Supplies the IRP_MN_SET_POWER irp.

    Extension - Supplies the master extension

Return Value:

    Status

--*/

{
    NTSTATUS Status;
    ULONG CurrentCapabilities;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    Status = AgpInitializeMaster(GET_AGP_CONTEXT_FROM_MASTER(Extension),
                                 &CurrentCapabilities);
    ASSERT(CurrentCapabilities == Extension->Capabilities);
    if (!NT_SUCCESS(Status)) {
        Irp->IoStatus.Status = Status;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
AgpTargetPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Powerup completion routine for the target device. It reinitializes the
    GART aperture

Arguments:

    DeviceObject - supplies the master device object.

    Irp - Supplies the IRP_MN_SET_POWER irp.

    Extension - Supplies the target extension

Return Value:

    Status

--*/

{
    NTSTATUS Status;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Now it is safe to reinitialize the target. All we do here
    // is reset the aperture
    //
    if (Extension->GartLengthInPages != 0) {
        Status = AgpSetAperture(GET_AGP_CONTEXT(Extension),
                                Extension->GartBase,
                                Extension->GartLengthInPages);
        if (!NT_SUCCESS(Status)) {
            Irp->IoStatus.Status = Status;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
AgpCancelMasterRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for IRP_MN_CANCEL_REMOVE_DEVICE. This is required
    since we cannot reenable AGP until the lower levels have completed their
    CANCEL_REMOVE processing.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP

    Extension - Supplies the master extension

Return Value:

    NTSTATUS

--*/

{
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    ASSERT(Extension->DisableCount > 0);
    InterlockedDecrement(&Extension->DisableCount);
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:

    This routine is used as a completion routine when an IRP is passed
    down the stack but more processing must be done on the way back up.
    The effect of using this as a completion routine is that the IRP
    will not be destroyed in IoCompleteRequest as called by the lower
    level object.  The event which is a KEVENT is signaled to allow
    processing to continue

Arguments:

    DeviceObject - Supplies the device object

    Irp - The IRP we are processing

    Event - Supplies the event to be signaled

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    ASSERT(Event);

    //
    // This can be called at DISPATCH_LEVEL so must not be paged
    //
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\agplib3\init.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Common initialization routine for the AGP filter driver

Author:

    John Vert (jvert) 10/22/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/
#include "agplib.h"

//
// Local function prototypes
//
NTSTATUS
AgpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
AgpBuildHackTable(
    IN OUT PAGP_HACK_TABLE_ENTRY *AgpHackTable,
    IN HANDLE HackTableKey
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
AgpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
AgpInitFavoredMemoryRanges(
   IN PTARGET_EXTENSION Extension);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpAddDevice)
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, AgpDriverUnload)
#pragma alloc_text(PAGE, AgpAttachDeviceRelations)
#pragma alloc_text(INIT, AgpBuildHackTable)
#pragma alloc_text(PAGE, AgpInitFavoredMemoryRanges)
#endif

ULONG AgpLogLevel = 0;
ULONG AgpStopLevel = 0;
PDRIVER_OBJECT AgpDriver;
GLOBALS Globals;

//
// Table of hacks for broken hardware read from the registry at init
//
PAGP_HACK_TABLE_ENTRY AgpDeviceHackTable = NULL;
PAGP_HACK_TABLE_ENTRY AgpGlobalHackTable = NULL;

#define HACKFMT_VENDORDEV         (sizeof(L"VVVVDDDD") - sizeof(UNICODE_NULL))
#define HACKFMT_VENDORDEVREVISION (sizeof(L"VVVVDDDDRR") - sizeof(UNICODE_NULL))
#define HACKFMT_SUBSYSTEM         (sizeof(L"VVVVDDDDSSSSssss") - sizeof(UNICODE_NULL))
#define HACKFMT_SUBSYSTEMREVISION (sizeof(L"VVVVDDDDSSSSssssRR") - sizeof(UNICODE_NULL))
#define HACKFMT_MAX_LENGTH        HACKFMT_SUBSYSTEMREVISION

#define HACKFMT_DEVICE_OFFSET     4
#define HACKFMT_SUBVENDOR_OFFSET  8
#define HACKFMT_SUBSYSTEM_OFFSET 12

NTSTATUS
AgpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
{
    NTSTATUS Status;
    PDEVICE_OBJECT Device;
    PTARGET_EXTENSION Extension;
    UCHAR CapabilityID;

    PAGED_CODE();

    //
    // Create our device
    //
    Status = IoCreateDevice(DriverObject,
                            sizeof(TARGET_EXTENSION)  + AgpExtensionSize - sizeof(ULONGLONG),
                            NULL,
                            FILE_DEVICE_BUS_EXTENDER,
                            FILE_DEVICE_SECURE_OPEN, // Not really necessary in our case as we don't support create
                            FALSE,
                            &Device);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,("AgpAddDevice: IoCreateDevice failed %08lx\n",Status));
        return(Status);
    }

    //
    // Initialize the device extension
    //
    Extension = Device->DeviceExtension;
    Extension->CommonExtension.Type = AgpTargetFilter;
    Extension->CommonExtension.Deleted = FALSE;
    Extension->CommonExtension.Signature = TARGET_SIG;

#if (WINVER > 0x501)
    Status =
        ApQueryAgpTargetBusInterface(PhysicalDeviceObject,
                                     &Extension->CommonExtension.BusInterface, 
                                     &CapabilityID);
#else
    Status = STATUS_NOT_IMPLEMENTED;
#endif // (WINVER > 0x501)

    //
    // Perhaps this OS doesn't support the new AGP_TARGET_BUS_INTERFACE, then
    // we can still support the target bridge without using HalGet/SetBusData
    // we just have to do a bit more work, and probe to see if there is an AGP
    // target capability on this bridge device
    //
#ifndef AGP_INTERFACE_TEST 
    if (!NT_SUCCESS(Status)) {
        Status = ApQueryBusInterface(PhysicalDeviceObject,
                                     &Extension->CommonExtension.BusInterface);
        if (NT_SUCCESS(Status)) {
            PCI_AGP_CAPABILITY TargetCap;
            
            //
            // Look for the target bride capability
            //
            Status = AgpLibGetTargetCapability(GET_AGP_CONTEXT(Extension),
                                               &TargetCap);
            if (NT_SUCCESS(Status)) {
                CapabilityID = TargetCap.Header.CapabilityID;
                
                //
                // For our UAGP35 driver to work on older OS, we will
                // attempt to override the bus interface with
                // HalGet/SetBusData functions that access the host, if
                // we can find an AGP capability there, otherwise we
                // will leave well enough alone so other drivers will
                // continue to get the same behavior they've always had,
                // namely bus interface still munges whatever, and lib
                // behavior defaults to traditional/non-bridge w/respect
                // to resource handling
                //
            } else {
                BUS_INTERFACE_STANDARD BusInterfaceSave;

                CapabilityID = PCI_CAPABILITY_ID_AGP;

#if (WINVER < 0x502)
                //
                // Save the bus interface
                // 
                BusInterfaceSave.SetBusData =
                    Extension->CommonExtension.BusInterface.SetBusData;
                BusInterfaceSave.GetBusData =
                    Extension->CommonExtension.BusInterface.GetBusData;
                Extension->CommonExtension.BusInterface.SetBusData =
                    ApLegacySetBusData;
                Extension->CommonExtension.BusInterface.GetBusData =
                    ApLegacyGetBusData;
                
                Status = AgpLibGetTargetCapability(GET_AGP_CONTEXT(Extension),
                                                   &TargetCap);

                if (!NT_SUCCESS(Status)) {
                    Extension->CommonExtension.BusInterface.SetBusData =
                        BusInterfaceSave.SetBusData;
                    Extension->CommonExtension.BusInterface.GetBusData =
                        BusInterfaceSave.GetBusData;                    
                }
#endif // (WINVER < 0x502)

                Status = STATUS_SUCCESS; // We do have a bus interface
            }
        }
    }
#endif // AGP_INTERFACE_TEST

    if (!NT_SUCCESS(Status)) {
            
        AGPLOG(AGP_CRITICAL,
               ("AgpAddDevice: query for bus interface failed %08lx\n", Status));
        IoDeleteDevice(Device);
        return(STATUS_NO_SUCH_DEVICE);
    }
    Extension->ChildDevice = NULL;
    Extension->Resources = NULL;
    Extension->ResourcesTranslated = NULL;
    Extension->FavoredMemory.NumRanges = 0;
    Extension->FavoredMemory.Ranges = NULL;
    Extension->GartBase.QuadPart = 0;
    Extension->GartLengthInPages = 0;
    Extension->Agp3BridgeResourceIndex = JUNK_INDEX;

    if (CapabilityID == PCI_CAPABILITY_ID_AGP_TARGET) {
            Extension->StartTarget = Agp3StartTargetBridge;
            Extension->FilterResourceRquirements =
                Agp3FilterResourceRequirementsBridge;
    } else {
        ASSERT(CapabilityID == PCI_CAPABILITY_ID_AGP);
            Extension->StartTarget = AgpStartTargetHost;
            Extension->FilterResourceRquirements =
                AgpFilterResourceRequirementsHost;
    }

    Extension->Lock = ExAllocatePoolWithTag(NonPagedPool, sizeof(FAST_MUTEX), 'MFgA');
    if (Extension->Lock == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("AgpAddDevice: allocation of fast mutext failed\n"));
        RELEASE_BUS_INTERFACE(Extension);
        IoDeleteDevice(Device);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    ExInitializeFastMutex(Extension->Lock);

    //
    // Attach to the supplied PDO
    //
    Extension->CommonExtension.AttachedDevice = IoAttachDeviceToDeviceStack(Device, PhysicalDeviceObject);
    if (Extension->CommonExtension.AttachedDevice == NULL) {
        //
        // The attach failed.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpAddDevice: IoAttachDeviceToDeviceStack from %08lx to %08lx failed\n",
               Device,
               PhysicalDeviceObject));
        RELEASE_BUS_INTERFACE(Extension);
        IoDeleteDevice(Device);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Figure out our favored memory ranges
    //

    AgpInitFavoredMemoryRanges(Extension);

    //
    // Finally call the chipset-specific code for target initialization
    //
    Status = AgpInitializeTarget(GET_AGP_CONTEXT(Extension));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpAttachDeviceRelations: AgpInitializeTarget on device %08lx failed %08lx\n",
                Device,
                Status));
        IoDetachDevice(Extension->CommonExtension.AttachedDevice);
        RELEASE_BUS_INTERFACE(Extension);
        IoDeleteDevice(Device);
        return(Status);
    }

    Extension->PDO = PhysicalDeviceObject;
    Extension->Self = Device;

    Status = AgpWmiRegistration(Extension);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL, ("AgpWmiRegistration failed %08lx\n", Status));
        IoDetachDevice(Extension->CommonExtension.AttachedDevice);
        RELEASE_BUS_INTERFACE(Extension);
        IoDeleteDevice(Device);
        return Status;
    }

    Device->Flags &= ~DO_DEVICE_INITIALIZING;

    return(STATUS_SUCCESS);

}

NTSTATUS
AgpBuildHackTable(
    IN OUT PAGP_HACK_TABLE_ENTRY *AgpHackTable,
    IN HANDLE HackTableKey
    )
{

    NTSTATUS status;
    PKEY_FULL_INFORMATION keyInfo = NULL;
    ULONG hackCount, size, index;
    USHORT temp;
    PAGP_HACK_TABLE_ENTRY entry;
    ULONGLONG data;
    PKEY_VALUE_FULL_INFORMATION valueInfo = NULL;
    ULONG valueInfoSize = sizeof(KEY_VALUE_FULL_INFORMATION)
                          + HACKFMT_MAX_LENGTH +
                          + sizeof(ULONGLONG);

    //
    // Get the key info so we know how many hack values there are.
    // This does not change during system initialization.
    //

    status = ZwQueryKey(HackTableKey,
                        KeyFullInformation,
                        NULL,
                        0,
                        &size
                        );

    if (status != STATUS_BUFFER_TOO_SMALL) {
        ASSERT(!NT_SUCCESS(status));
        goto cleanup;
    }

    ASSERT(size > 0);

    keyInfo = ExAllocatePool(PagedPool, size);

    if (!keyInfo) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    status = ZwQueryKey(HackTableKey,
                        KeyFullInformation,
                        keyInfo,
                        size,
                        &size
                        );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    hackCount = keyInfo->Values;

    ExFreePool(keyInfo);
    keyInfo = NULL;

    //
    // Allocate and initialize the hack table
    //

    *AgpHackTable = ExAllocatePool(NonPagedPool,
                                  (hackCount + 1) * sizeof(AGP_HACK_TABLE_ENTRY)
                                  );

    if (!*AgpHackTable) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }


    //
    // Allocate a valueInfo buffer big enough for the biggest valid
    // format and a ULONGLONG worth of data.
    //

    valueInfo = ExAllocatePool(PagedPool, valueInfoSize);

    if (!valueInfo) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    entry = *AgpHackTable;

    for (index = 0; index < hackCount; index++) {

        status = ZwEnumerateValueKey(HackTableKey,
                                     index,
                                     KeyValueFullInformation,
                                     valueInfo,
                                     valueInfoSize,
                                     &size
                                     );

        if (!NT_SUCCESS(status)) {
            if (status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL) {
                //
                // All out data is of fixed length and the buffer is big enough
                // so this can't be for us.
                //

                continue;
            } else {
                goto cleanup;
            }
        }

        //
        // Get pointer to the data if its of the right type
        //

        if ((valueInfo->Type == REG_BINARY) &&
            (valueInfo->DataLength == sizeof(ULONGLONG))) {
            data = *(ULONGLONG UNALIGNED *)(((PUCHAR)valueInfo) + valueInfo->DataOffset);
        } else {
            //
            // We only deal in ULONGLONGs
            //

            continue;
        }

        //
        // Now see if the name is formatted like we expect it to be:
        // VVVVDDDD
        // VVVVDDDDRR
        // VVVVDDDDSSSSssss
        // VVVVDDDDSSSSssssRR

        if ((valueInfo->NameLength != HACKFMT_VENDORDEV) &&
            (valueInfo->NameLength != HACKFMT_VENDORDEVREVISION) &&
            (valueInfo->NameLength != HACKFMT_SUBSYSTEM) &&
            (valueInfo->NameLength != HACKFMT_SUBSYSTEMREVISION)) {

            //
            // This isn't ours
            //

            AGPLOG(
                AGP_CRITICAL,
                ("Skipping hack entry with invalid length name\n"
                 ));

            continue;
        }


        //
        // This looks plausable - try to parse it and fill in a hack table
        // entry
        //

        RtlZeroMemory(entry, sizeof(AGP_HACK_TABLE_ENTRY));

        //
        // Look for DeviceID and VendorID (VVVVDDDD)
        //

        if (!AgpStringToUSHORT(valueInfo->Name, &entry->VendorID)) {
            continue;
        }

        if (!AgpStringToUSHORT(valueInfo->Name + HACKFMT_DEVICE_OFFSET,
                               &entry->DeviceID)) {
            continue;
        }


        //
        // Look for SubsystemVendorID/SubSystemID (SSSSssss)
        //

        if ((valueInfo->NameLength == HACKFMT_SUBSYSTEM) ||
            (valueInfo->NameLength == HACKFMT_SUBSYSTEMREVISION)) {

            if (!AgpStringToUSHORT(valueInfo->Name + HACKFMT_SUBVENDOR_OFFSET,
                                   &entry->SubVendorID)) {
                continue;
            }

            if (!AgpStringToUSHORT(valueInfo->Name + HACKFMT_SUBSYSTEM_OFFSET,
                                   &entry->SubSystemID)) {
                continue;
            }

            entry->Flags |= AGP_HACK_FLAG_SUBSYSTEM;
        }

        //
        // Look for RevisionID (RR)
        //

        if ((valueInfo->NameLength == HACKFMT_VENDORDEVREVISION) ||
            (valueInfo->NameLength == HACKFMT_SUBSYSTEMREVISION)) {
            if (AgpStringToUSHORT(valueInfo->Name +
                                  (valueInfo->NameLength/sizeof(WCHAR) - 4), &temp)) {
                entry->RevisionID = temp & 0xFF;
                entry->Flags |= AGP_HACK_FLAG_REVISION;
            } else {
                continue;
            }
        }

        ASSERT(entry->VendorID != 0xFFFF);

        //
        // Fill in the entry
        //

        entry->DeviceFlags = data;

        AGPLOG(
            AGP_CRITICAL,
            ("Adding Hack entry for Vendor:0x%04x Device:0x%04x ",
            entry->VendorID, entry->DeviceID
            ));

        if (entry->Flags & AGP_HACK_FLAG_SUBSYSTEM) {
            AGPLOG(
                AGP_CRITICAL,
                ("SybSys:0x%04x SubVendor:0x%04x ",
                 entry->SubSystemID, entry->SubVendorID
                 ));
        }

        if (entry->Flags & AGP_HACK_FLAG_REVISION) {
            AGPLOG(
                AGP_CRITICAL,
                ("Revision:0x%02x",
                 (ULONG) entry->RevisionID
                 ));
        }

        AGPLOG(
            AGP_CRITICAL,
            (" = 0x%I64x\n",
             entry->DeviceFlags
             ));

        entry++;
    }

    ASSERT(entry < (*AgpHackTable + hackCount + 1));

    //
    // Terminate the table with an invalid VendorID
    //

    entry->VendorID = 0xFFFF;

    ExFreePool(valueInfo);

    return STATUS_SUCCESS;

cleanup:

    ASSERT(!NT_SUCCESS(status));

    if (keyInfo) {
        ExFreePool(keyInfo);
    }

    if (valueInfo) {
        ExFreePool(valueInfo);
    }

    if (*AgpHackTable) {
        ExFreePool(*AgpHackTable);
        *AgpHackTable = NULL;
    }

    return status;

}


VOID
AgpInitFavoredMemoryRanges(
   IN PTARGET_EXTENSION Extension)
/*++

Routine Description:

    Determines the optimum memory ranges for AGP physical memory
    allocation by calling the ACPI BANK method provided by the
    AGP northbridge in order to determine which physical memory
    ranges are decoded by that northbridge.

    Initializes the FavoredMemory sturcture in the target extension
    with the proper ranges.

    If this routine fails, then the FavoredMemory structure
    is left untouched in its initialized state (i.e. no favored memory
    ranges found).

Arguments:

    Extension - The target extension.


Return Value:

    NONE. Upon failure,

--*/

{
   PDEVICE_OBJECT LowerPdo;
   IO_STATUS_BLOCK IoStatus;
   PIRP Irp;
   KEVENT event;
   NTSTATUS Status;
   ACPI_EVAL_INPUT_BUFFER inputBuffer;
   UCHAR ResultBuffer[sizeof(ACPI_EVAL_OUTPUT_BUFFER) + MAX_MBAT_SIZE];
   PACPI_EVAL_OUTPUT_BUFFER outputBuffer;
   PACPI_METHOD_ARGUMENT MethodArg;
   PMBAT Mbat;
   UCHAR i;
   USHORT j;
   PHYSICAL_ADDRESS MaxMemory;

   //
   // Maximum memory address for limiting AGP memory to below 4GB
   //

   MAX_MEM(MaxMemory.QuadPart);

   //
   // Get an event to wait on
   //

   KeInitializeEvent(&event, NotificationEvent, FALSE);

   // Get a PDO where we will send the request IRP.

   LowerPdo = Extension->CommonExtension.AttachedDevice;

   //
   // Initialize the input parameters and the output buffer.
   //
   RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
   inputBuffer.MethodNameAsUlong = CM_BANK_METHOD;
   inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
   outputBuffer = (PACPI_EVAL_OUTPUT_BUFFER)ResultBuffer;

   //
   // Build the request to call the BANK method.
   //
   Irp = IoBuildDeviceIoControlRequest(
        IOCTL_ACPI_EVAL_METHOD,
        LowerPdo,
        &inputBuffer,
        sizeof(ACPI_EVAL_INPUT_BUFFER),
        outputBuffer,
        sizeof(ResultBuffer),
        FALSE,
        &event,
        &IoStatus
        );

   if (!Irp)
   {
      return;
   }

   //
   // Send to the ACPI driver
   //
   Status = IoCallDriver ( LowerPdo, Irp);
   if (Status == STATUS_PENDING)
   {
         KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL);
         Status = IoStatus.Status;
   }

   if (NT_SUCCESS(Status))
   {
      AGPLOG(AGP_NOISE, ("AGPLIB: ACPI BANK Method Executed.\n"));

      //
      // Sanity check method results
      //

      MethodArg = outputBuffer->Argument;
      if ((outputBuffer->Signature == ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE) &&
          (MethodArg->DataLength >= sizeof(MBAT)) &&
          (MethodArg->Type == ACPI_METHOD_ARGUMENT_BUFFER))
      {

         AGPLOG(AGP_NOISE, ("AGPLIB: MBAT appears valid.\n"));

         //
         // Grab the MBAT and see if we can parse it
         //

         Mbat = (PMBAT)MethodArg->Data;

         if (Mbat->TableVersion == MBAT_VERSION) {
            AGPLOG(AGP_NOISE, ("AGPLIB: Parsing MBAT.\n"));

             //
             // Calculate the number of favored ranges mentioned
             // in the MBAT
             //

             i=Mbat->ValidEntryBitmap;
             while(i)
             {
                Extension->FavoredMemory.NumRanges++;
                i = i & (i-1);
             }

             AGPLOG(AGP_NOISE, ("AGPLIB: %u favored ranges found.\n",
                      Extension->FavoredMemory.NumRanges));

             if(Extension->FavoredMemory.NumRanges == 0) return;

             //
             // Allocate the favored memory range structure in our device
             // extension
             //

             Extension->FavoredMemory.Ranges =
                ExAllocatePool(NonPagedPool, sizeof(AGP_MEMORY_RANGE) *
                               Extension->FavoredMemory.NumRanges);

             if (Extension->FavoredMemory.Ranges == NULL) {
                Extension->FavoredMemory.NumRanges = 0;
                return;
             }


             //
             // Initialize the favored memory ranges in our extension
             // based upon the MBAT
             //

             i=0;
             j=0;
             while(Mbat->ValidEntryBitmap)
             {
                if (Mbat->ValidEntryBitmap & 1)
                {
                   if (Mbat->DecodeRange[i].Lower.QuadPart > MaxMemory.QuadPart) {
                      // This range is invalid since its lower address is above
                      // the highest allowable address

                      AGPLOG(AGP_NOISE, ("AGPLIB: Invalid MBAT Range ==> %I64x - %I64x\n",
                               Mbat->DecodeRange[i].Lower.QuadPart,
                               Mbat->DecodeRange[i].Upper.QuadPart));

                      // Pretend like this range never existed ...
                      //

                      Extension->FavoredMemory.NumRanges--;

                   }
                   else
                   {

                     // This is a valid range.

                     Extension->FavoredMemory.Ranges[j].Lower.QuadPart =
                         Mbat->DecodeRange[i].Lower.QuadPart;
                     Extension->FavoredMemory.Ranges[j].Upper.QuadPart =
                         Mbat->DecodeRange[i].Upper.QuadPart;


                     AGPLOG(AGP_NOISE, ("AGPLIB: MBAT Range ==> %I64x - %I64x\n",
                              Mbat->DecodeRange[i].Lower.QuadPart,
                              Mbat->DecodeRange[i].Upper.QuadPart));

                     if(Extension->FavoredMemory.Ranges[j].Upper.QuadPart >
                        MaxMemory.QuadPart)
                     {
                        AGPLOG(AGP_NOISE, ("AGPLIB: Adjusting range to fit within maximum allowable address.\n"));
                        Extension->FavoredMemory.Ranges[j].Upper.QuadPart =
                           MaxMemory.QuadPart;
                     }

                     j++;
                   }
                }
                Mbat->ValidEntryBitmap >>= 1;
                i++;
             }

         } else {

            AGPLOG(AGP_WARNING, ("AGPLIB: Unknown MBAT version.\n"));

         }

}


    }
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Entrypoint needed to initialize the AGP filter.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - Pointer to the unicode registry service path.

Return Value:

    NT status.

--*/

{
    NTSTATUS Status;
    HANDLE serviceKey, paramsKey;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES attributes;

    PAGED_CODE();

    //
    // Save the RegistryPath for WMI
    //
    Globals.RegistryPath.MaximumLength =
        RegistryPath->Length + sizeof(UNICODE_NULL);

    Globals.RegistryPath.Length = RegistryPath->Length;

    Globals.RegistryPath.Buffer =
        ExAllocatePoolWithTag(PagedPool,
                              Globals.RegistryPath.MaximumLength,
                              'GpgA'
                              );    

    if (!Globals.RegistryPath.Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
   
    RtlCopyUnicodeString(&Globals.RegistryPath, RegistryPath);

    AgpDriver = DriverObject;

    DriverObject->DriverExtension->AddDevice = AgpAddDevice;
    DriverObject->DriverUnload               = AgpDriverUnload;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = AgpDispatchDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = AgpDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = AgpDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = AgpDispatchWmi;

    RtlInitUnicodeString(&UnicodeString,
                         L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\"
                         L"Control");

    //
    // Open the global hack key and retrieve the gloabl hack table
    //
    InitializeObjectAttributes(&attributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    Status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &attributes
                       );

    //
    // We must succeed here, there are devices that can freeze a system,
    // and something is really wrong if we can't access these values
    //
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    AgpOpenKey(L"AGP", serviceKey, &paramsKey, &Status);

    ZwClose(serviceKey);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = AgpBuildHackTable(&AgpGlobalHackTable, paramsKey);

    ZwClose(paramsKey);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Open our service key and retrieve any platform hack(s)
    //
    InitializeObjectAttributes(&attributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    Status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &attributes
                       );

    //
    // Maybe their chipset is so burly, it doesn't require any hacks!
    //
    if (!NT_SUCCESS(Status)) {
        return STATUS_SUCCESS;
    }

    AgpOpenKey(L"Parameters", serviceKey, &paramsKey, &Status);

    ZwClose(serviceKey);

    //
    // Don't care
    //
    if (!NT_SUCCESS(Status)) {
        return STATUS_SUCCESS;
    }

    //
    // Again, disregard status
    //
    AgpBuildHackTable(&AgpDeviceHackTable, paramsKey);

    ZwClose(paramsKey);

    return STATUS_SUCCESS;
}



VOID
AgpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Entrypoint used to unload the AGP driver

Arguments:

    DriverObject - Pointer to the driver object created by the system

Return Value:

    None

--*/
{
    if (AgpDeviceHackTable != NULL) {
        ExFreePool(AgpDeviceHackTable);
        AgpDeviceHackTable = NULL;
    }

    if (AgpGlobalHackTable != NULL) {
        ExFreePool(AgpGlobalHackTable);
        AgpGlobalHackTable = NULL;
    }

    if (Globals.RegistryPath.Buffer != NULL) {
        ExFreePool(Globals.RegistryPath.Buffer);
        Globals.RegistryPath.Buffer = NULL; 
    }
}



NTSTATUS
AgpAttachDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for BusRelations IRP_MN_QUERY_DEVICE_RELATIONS irps sent
    to the PCI-PCI bridge PDO.  In order to handle QUERY_INTERFACE irps sent
    from the AGP device, we must attach to its PDO.  That means we attach to
    all the child PDOs of the PCI-PCI bridge.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_DEVICE_RELATIONS irp

    Extension - Supplies the AGP device extension.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    PDEVICE_RELATIONS Relations;
    ULONG i;
    PDEVICE_OBJECT NewDevice;
    PMASTER_EXTENSION NewExtension;
    AGP_CRITICAL_ROUTINE_CONTEXT routineContext;
#if DBG
    ULONG MasterCount=0;
#endif

    PAGED_CODE();

    //
    // If we have already attached, don't do it again.
    //
    if (Extension->ChildDevice != NULL) {
        return(STATUS_SUCCESS);
    }

    Relations = (PDEVICE_RELATIONS)Irp->IoStatus.Information;
    //
    // If somebody completed the IRP with success, but never
    // filled in the Relations field, then assume there are
    // no children and we don't have to do anything.
    //
    if (Relations == NULL) {
        return(STATUS_SUCCESS);
    }

    for (i=0; i<Relations->Count; i++) {

        //
        // Create a device object to attach to this PDO.
        //
        Status = IoCreateDevice(AgpDriver,
                                sizeof(MASTER_EXTENSION),
                                NULL,
                                FILE_DEVICE_BUS_EXTENDER,
                                0,
                                FALSE,
                                &NewDevice);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,("AgpAttachDeviceRelations: IoCreateDevice failed %08lx\n",Status));
            continue;
        }

        //
        // Initialize the device extension
        //

        NewExtension = NewDevice->DeviceExtension;
        NewExtension->CommonExtension.Deleted = FALSE;
        NewExtension->CommonExtension.Type = AgpMasterFilter;
        NewExtension->CommonExtension.Signature = MASTER_SIG;
        Status = ApQueryBusInterface(Relations->Objects[i], &NewExtension->CommonExtension.BusInterface);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpAttachDeviceRelations: query for bus interface failed %08lx\n", Status));
            IoDeleteDevice(NewDevice);
            continue;
        }
        NewExtension->Target = Extension;
        NewExtension->InterfaceCount = 0;
        NewExtension->ReservedPages = 0;
        NewExtension->StopPending = FALSE;
        NewExtension->RemovePending = FALSE;
        NewExtension->DisableCount = 1;         // biased so that we don't give anything out
                                                // until we see the IRP_MN_START
        Extension->ChildDevice = NewExtension;

        //
        // Attach to the specified device
        //
        NewExtension->CommonExtension.AttachedDevice = IoAttachDeviceToDeviceStack(NewDevice, Relations->Objects[i]);
        if (NewExtension->CommonExtension.AttachedDevice == NULL) {
            //
            // The attach failed. Not really fatal, AGP just won't work for that device.
            //
            AGPLOG(AGP_CRITICAL,
                   ("AgpAttachDeviceRelations: IoAttachDeviceToDeviceStack from %08lx to %08lx failed\n",
                   NewDevice,
                   Relations->Objects[i]));
            RELEASE_BUS_INTERFACE(NewExtension);
            IoDeleteDevice(NewDevice);
            Extension->ChildDevice = NULL;
            continue;
        }

        //
        // Propagate the PDO's requirements
        //
        NewDevice->StackSize = NewExtension->CommonExtension.AttachedDevice->StackSize + 1;
        NewDevice->AlignmentRequirement = NewExtension->CommonExtension.AttachedDevice->AlignmentRequirement;
        if (NewExtension->CommonExtension.AttachedDevice->Flags & DO_POWER_PAGABLE) {
            NewDevice->Flags |= DO_POWER_PAGABLE;
        }

        //
        // Finally call the chipset-specific code for master initialization
        //
        routineContext.Gate = 1;
        routineContext.Barrier = 1;
        routineContext.Routine = (PCRITICALROUTINE)AgpInitializeMaster;
        routineContext.Extension = GET_AGP_CONTEXT(Extension);
        routineContext.Context = &NewExtension->Capabilities;
#if (WINVER < 0x502) || defined(AGP_DEBUG_MASTER_INIT)
        Status = AgpInitializeMaster(GET_AGP_CONTEXT(Extension),
                                     &NewExtension->Capabilities);
#else
        Status = (NTSTATUS)KeIpiGenericCall(AgpExecuteCriticalSystemRoutine,
                                            (ULONG_PTR)&routineContext
                                            );
#endif
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpAttachDeviceRelations: AgpInitializeMaster on device %08lx failed %08lx\n",
                    NewDevice,
                    Status));
            IoDetachDevice(NewExtension->CommonExtension.AttachedDevice);
            RELEASE_BUS_INTERFACE(NewExtension);
            IoDeleteDevice(NewDevice);
            Extension->ChildDevice = NULL;
            continue;
        }
        NewDevice->Flags &= ~DO_DEVICE_INITIALIZING;

//
// We can't do this if DBG because looping through here to catch/ASSERT
// multiple AGP masters will *always* screw up our target context
//
#if 0
        //
        // Check to make sure there is only one AGP master on the bus. There can be more
        // than one device (multifunction device) but only one must have AGP capabilities
        //
        MasterCount++;
        ASSERT(MasterCount == 1);
#else
        break;
#endif

    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\amdagp8x\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Amdagp.rc
//
#define VER_DEBUG                       0
#define VER_PRERELEASE                  0

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\alim1541\init.c ===
/*++

Copyright (c) 1996, 1997 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code for AGPALi.SYS.

Author:

    John Vert (jvert) 10/21/1997

Modified by:
   
        Chi-Ming Cheng 06/24/1998 Acer Labs, Inc.
        Wang-Kai Tsai  08/29/2000 Acer Labs, Inc.

Revision History:

--*/

#include "ALiM1541.h"

ULONG AgpExtensionSize = sizeof(AGPALi_EXTENSION);
PAGP_FLUSH_PAGES AgpFlushPages;

NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*++

Routine Description:

    Entrypoint for target initialization. This is called first.

Arguments:

    AgpExtension - Supplies the AGP extension

Return Value:

    NTSTATUS

--*/

{
    ULONG VendorId = 0;
    PAGPALi_EXTENSION Extension = AgpExtension;
    UCHAR  HidId;

    //
    // Make sure we are really loaded only on a ALi chipset
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &VendorId, 0);
    ASSERT((VendorId == AGP_ALi_1541_IDENTIFIER) ||
           (VendorId == AGP_ALi_1621_IDENTIFIER) ||
           (VendorId == AGP_ALi_1631_IDENTIFIER) ||
           (VendorId == AGP_ALi_1632_IDENTIFIER) ||
           (VendorId == AGP_ALi_1641_IDENTIFIER) ||
           (VendorId == AGP_ALi_1644_IDENTIFIER) ||
           (VendorId == AGP_ALi_1646_IDENTIFIER) ||
           (VendorId == AGP_ALi_1647_IDENTIFIER) ||
           (VendorId == AGP_ALi_1651_IDENTIFIER) ||
           (VendorId == AGP_ALi_1671_IDENTIFIER) ||
           (VendorId == AGP_ALi_1672_IDENTIFIER));

    //
    // Determine which particular chipset we are running on.
    //
    if (VendorId == AGP_ALi_1541_IDENTIFIER) {
        Extension->ChipsetType = ALi1541;
        AgpFlushPages = Agp1541FlushPages;
    } else if (VendorId == AGP_ALi_1621_IDENTIFIER) {
        Extension->ChipsetType = ALi1621;
        ReadConfigUchar(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &HidId, M1621_HIDDEN_REV_ID);
        switch (HidId)
        {
            case 0x31:
                    Extension->ChipsetType = ALi1631;
                    break;
            case 0x32:
                    Extension->ChipsetType = ALi1632;
                    break;
            case 0x41:
                    Extension->ChipsetType = ALi1641;
                    break;
            case 0x43:
                    Extension->ChipsetType = ALi1621;
                    break;        
            default:
                    Extension->ChipsetType = ALi1621;
                    break;
        }
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1631_IDENTIFIER) {
        Extension->ChipsetType = ALi1631;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1632_IDENTIFIER) {
        Extension->ChipsetType = ALi1632;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1641_IDENTIFIER) {
        Extension->ChipsetType = ALi1641;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1644_IDENTIFIER) {
        Extension->ChipsetType = ALi1644;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1646_IDENTIFIER) {
        Extension->ChipsetType = ALi1646;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1647_IDENTIFIER) {
        Extension->ChipsetType = ALi1647;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1651_IDENTIFIER) {
        Extension->ChipsetType = ALi1651;
        AgpFlushPages = NULL;    
    } else if (VendorId == AGP_ALi_1671_IDENTIFIER) {
        Extension->ChipsetType = ALi1671;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1672_IDENTIFIER) {
        Extension->ChipsetType = ALi1672;
        AgpFlushPages = NULL;
    } else {
        AGPLOG(AGP_CRITICAL,
               ("AGPALi - AgpInitializeTarget called for platform %08lx which is not a ALi chipset!\n",
                VendorId));
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Initialize our chipset-specific extension
    //
    Extension->ApertureStart.QuadPart = 0;
    Extension->ApertureLength = 0;
    Extension->Gart = NULL;
    Extension->GartLength = 0;
    Extension->GartPhysical.QuadPart = 0;
    Extension->SpecialTarget = 0;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

Arguments:

    AgpExtension - Supplies the AGP extension

    AgpCapabilities - Returns the capabilities of this AGP device.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    PAGPALi_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable;
    ULONG DataRate;
    BOOLEAN ReverseInit;

#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

    //
    // Indicate that we can map memory through the GART aperture
    //
    *AgpCapabilities = AGP_CAPABILITIES_MAP_PHYSICAL;

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPALiInitializeDevice - AgpLibGetMasterCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability returned no valid transfer rate\n"));
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = AgpLibGetPciDeviceCapability(0,0,&TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPALiInitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;
    AGP_ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);
    }

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing & MasterCap.AGPStatus.SideBandAddressing);

    //
    // Before we enable AGP, apply any workarounds
    //
    AgpWorkaround(Extension);

    //
    // Enable the Master first.
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGPALiInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    //
    // Now enable the Target.
    //
    TargetCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPALiInitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGPALiInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

#if DBG
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    AGP_ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    AGP_ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

    Status = AgpLibGetPciDeviceCapability(0,0,&CurrentCap);
    AGP_ASSERT(NT_SUCCESS(Status));
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\inc\agp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    agp.h

Abstract:

    Header file for common AGP library

Author:

    John Vert (jvert) 10/22/1997

Revision History:

--*/
//
// AGP is a driver, make sure we get the appropriate linkage.
//

#define _NTDRIVER_

#include "ntddk.h"
#include "ntagp.h"

//
// regstr.h uses things of type WORD, which isn't around in kernel mode.
//
#define _IN_KERNEL_
#include "regstr.h"

//
// Handy debugging and logging macros
//

//
// Always turned on for now
//
#if DEVL

#define AGP_ALWAYS   0
#define AGP_CRITICAL 1
#define AGP_WARNING  2
#define AGP_IRPTRACE 3
#define AGP_NOISE    4

#define AGP_DEBUGGING_OKAY()    \
    (KeGetCurrentIrql() < IPI_LEVEL)

#define AGP_ASSERT  \
    if (AGP_DEBUGGING_OKAY()) ASSERT

extern ULONG AgpLogLevel;
extern ULONG AgpStopLevel;
#define AGPLOG(_level_,_x_) if (((_level_) <= AgpLogLevel) && \
                                AGP_DEBUGGING_OKAY()) DbgPrint _x_; \
                            if (((_level_) <= AgpStopLevel) && \
                                AGP_DEBUGGING_OKAY()) { DbgBreakPoint(); }

#else

#define AGPLOG(_level_,_x_)

#endif

//
// Functions provided by AGPLIB for use by chipset-specific code
//

//
// Helper routines for manipulating AGP Capabilities registers
//
typedef
NTSTATUS
(*PAGP_GETSET_CONFIG_SPACE)(
    IN PVOID Context,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
AgpLibGetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN BOOLEAN DoSpecial,
    OUT PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibGetTargetCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibGetMasterDeviceId(
    IN PVOID AgpExtension,
    OUT PULONG DeviceId
    );

NTSTATUS
AgpLibGetMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibReadAgpDeviceConfig(
    IN PVOID AgpExtension,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Size
    );

NTSTATUS
AgpLibWriteAgpDeviceConfig(
    IN PVOID AgpExtension,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Size
    );

NTSTATUS
AgpLibGetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibSetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibSetTargetCapability(
    IN PVOID AgpExtension,
    IN PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibSetMasterCapability(
    IN PVOID AgpExtension,
    IN PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibSetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    IN PPCI_AGP_CAPABILITY Capability
    );

PVOID
AgpLibAllocateMappedPhysicalMemory(
   IN PVOID AgpContext, 
   IN ULONG TotalBytes);

VOID
AgpLibFreeMappedPhysicalMemory(
    IN PVOID Addr,
    IN ULONG Length
    );

//
// Functions implemented by the chipset-specific code
//
typedef struct _AGP_RANGE {
    PHYSICAL_ADDRESS MemoryBase;
    ULONG NumberOfPages;
    MEMORY_CACHING_TYPE Type;
    PVOID Context;
    ULONG CommittedPages;
} AGP_RANGE, *PAGP_RANGE;

//
// These flags have been reserved under AGP_FLAG_SPECIAL_RESERVE
// defined in regstr.h
//
//      AGP_FLAG_SPECIAL_RESERVE 0x000F0000
//
#define AGP_FLAG_SET_RATE_1X     0x00010000
#define AGP_FLAG_SET_RATE_2X     0x00020000
#define AGP_FLAG_SET_RATE_4X     0x00040000
#define AGP_FLAG_SET_RATE_8X     0x00080000

#define AGP_FLAG_SET_RATE_SHIFT  0x00000010

NTSTATUS
AgpSpecialTarget(
    IN PVOID AgpContext,
    IN ULONGLONG DeviceFlags
    );

NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    );

NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    );

NTSTATUS
AgpQueryAperture(
    IN PVOID AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *ApertureRequirements
    );

NTSTATUS
AgpSetAperture(
    IN PVOID AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    OUT ULONG NewSizeInPages
    );

VOID
AgpDisableAperture(
    IN PVOID AgpContext
    );

NTSTATUS
AgpReserveMemory(
    IN PVOID AgpContext,
    IN OUT AGP_RANGE *AgpRange
    );

NTSTATUS
AgpReleaseMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange
    );

VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    );

VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    );

NTSTATUS
AgpMapMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

NTSTATUS
AgpUnMapMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

typedef
NTSTATUS
(*PAGP_FLUSH_PAGES)(
    IN PVOID AgpContext,
    IN PMDL Mdl
    );

//
// Globals defined by the chipset-specific code
//
extern ULONG AgpExtensionSize;
extern PAGP_FLUSH_PAGES AgpFlushPages;

//
// AGP Pool tag definitions
//
#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(_type_,_size_) ExAllocatePoolWithTag(_type_,_size_,' PGA')
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\amdagp8x\amdagp8x.h ===
//
// AMDAGP8X.sys is a driver, make sure we get the appropriate linkage.
//

/*
******************************************************************************
 * Archive File : $Archive: /Drivers/OS/Hammer/AGP/XP/amdagp/Amdagp8x.h $
 *
 * $History: Amdagp8x.h $
 * 
 *  
******************************************************************************
*/

//#define _NTDRIVER_


#include <agp.h>

//
// Define the location of the GART aperture control registers
//

#define AGP_GART_BUS_ID     0

#define VENDOR_AMD				0x1022
#define DEVICE_LOKAR			0x7454
#define DEVICE_HAMMER			0x1103

#define VENDORID_MASK			0x0000FFFF
#define DEVICEID_MASK			0xFFFF0000

#define CHIPSET_ID_OFFSET	0x00	// Vendor/Device ID Register
#define STATUS_CMD_OFFSET	0x04	// Status/Command Register
#define CLASS_REV_OFFSET	0x08	// Class Code/Revision ID Register
#define APBASE_OFFSET		0x10	// Aperture Base Address

#define AMD_AGP_CONTROL_OFFSET			0xB0
#define AMD_APERTURE_SIZE_OFFSET		0xB4
#define AMD_GART_POINTER_LOW_OFFSET		0xB8
#define AMD_GART_POINTER_HIGH_OFFSET	0xBC

#define CAPPTR_OFFSET		0x34
#define AGP_STATUS_OFFSET	0x04
#define AGP_COMMAND_OFFSET	0x08
#define AGP_SIZE_OFFSET		0x0C

#define PAGE_VALID_BIT			1
#define CACHE_INVALIDATE_BIT	1
#define PTE_ERROR_BIT			2
#define GART_ENABLE_BIT			1

#define APBASE_64BIT_MASK	0x04
#define APBASE_ADDRESS_MASK 0xFE000000

#define APH_SIZE_MASK    0x0E
#define APH_SIZE_32MB    0x00
#define APH_SIZE_64MB    0x02
#define APH_SIZE_128MB   0x04
#define APH_SIZE_256MB   0x06
#define APH_SIZE_512MB   0x08
#define APH_SIZE_1024MB	 0x0A
#define APH_SIZE_2048MB	 0x0C

#define APL_SIZE_MASK    0x0738
#define APL_SIZE_32MB    0x0738
#define APL_SIZE_64MB    0x0730
#define APL_SIZE_128MB   0x0720
#define APL_SIZE_256MB   0x0700
#define APL_SIZE_512MB   0x0600
#define APL_SIZE_1024MB	 0x0400
#define APL_SIZE_2048MB	 0x0000

#define AP_SIZE_COUNT 7
#define AP_MIN_SIZE (32 * 1024 * 1024)
#define AP_MAX_SIZE (1024 * 1024 * 1024)


// Hammer Configuration Registers
#define GART_APSIZE_OFFSET	0x90
#define GART_APBASE_OFFSET	0x94
#define GART_TABLE_OFFSET	0x98
#define GART_CONTROL_OFFSET	0x9C

#define GART_APBASE_SHIFT	25

//
// Define macros to read/write PCI configuration space
//

#define ReadAMDConfig(_slot_,_buf_,_offset_,_size_)     \
{                                                       \
    ULONG _len_;                                        \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,     \
                                  AGP_GART_BUS_ID,      \
                                  (_slot_),             \
                                  (_buf_),              \
                                  (_offset_),           \
                                  (_size_));            \
}

#define WriteAMDConfig(_slot_,_buf_,_offset_,_size_)    \
{                                                       \
    ULONG _len_;                                        \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,     \
                                  AGP_GART_BUS_ID,      \
                                  (_slot_),             \
                                  (_buf_),              \
                                  (_offset_),           \
                                  (_size_));            \
}


//
// Define the GART table entry.
//
typedef struct _GART_ENTRY_HW {
    ULONG Valid     :  1;
    ULONG Coherent  :  1;
    ULONG Reserved  :  2;
    ULONG PageHigh  :  8;
	ULONG PageLow   : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;


//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000
#define GART_ENTRY_COHERENT		2			//  010

#define GART_ENTRY_WC           4           //  00100
#define GART_ENTRY_UC           8           //  01000
#define GART_ENTRY_CC          16           //  10000

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC
#define GART_ENTRY_RESERVED_CC  GART_ENTRY_CC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_CC     (GART_ENTRY_VALID | GART_ENTRY_COHERENT)


typedef struct _GART_ENTRY_SW {
    ULONG State     : 5;
    ULONG Reserved  : 27;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

#define TABLE_ENTRY_SIZE			sizeof(GART_PTE)
#define NUM_PAGE_ENTRIES_PER_PAGE	(PAGE_SIZE/TABLE_ENTRY_SIZE)

//
// Define the AMD-specific extension
//
typedef struct _AGP_AMD_EXTENSION {
    PHYSICAL_ADDRESS    ApertureStart;
    ULONG               ApertureLength;
    PGART_PTE           Gart;
    ULONG               GartLength;
    PHYSICAL_ADDRESS    GartPhysical;
    ULONGLONG           SpecialTarget;
} AGP_AMD_EXTENSION, *PAGP_AMD_EXTENSION;


extern void DisplayStatus(UCHAR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\alim1541\gart.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    gart.c

Abstract:

    Routines for querying and setting the Intel 440xx GART aperture

Author:

    John Vert (jvert) 10/30/1997

Modified by:

        Chi-Ming Cheng 06/24/1998 Acer Labs, Inc.
        Wang-Kai Tsai  08/28/2000 Acer Labs, Inc. - ACPI power up GART reinitialization

Revision History:

--*/
#include "ALiM1541.h"

//
// Local function prototypes
//
NTSTATUS
AgpALiSetRate(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

NTSTATUS
AgpALiCreateGart(
    IN PAGPALi_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

PGART_PTE
AgpALiFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

NTSTATUS
AgpQueryAperture(
    IN PAGPALi_EXTENSION AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *ApertureRequirements
    )
/*++

Routine Description:

    Queries the current size of the GART aperture. Optionally returns
    the possible GART settings.

Arguments:

    AgpContext - Supplies the AGP context.

    CurrentBase - Returns the current physical address of the GART.

    CurrentSizeInPages - Returns the current GART size.

    ApertureRequirements - if present, returns the possible GART settings

Return Value:

    NTSTATUS

--*/

{
    ULONG ApBase;
    APCTRL ApCtrl;
    PIO_RESOURCE_LIST Requirements;
    ULONG i;
    ULONG Length;

    //
    // Get the current APBASE and APSIZE settings
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApBase, APBASE_OFFSET);
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);

    ASSERT(ApBase != 0);
    CurrentBase->QuadPart = ApBase & 0xFFFFFFF0; //PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Convert APSIZE into the actual size of the aperture
    //
    switch (ApCtrl.ApSize) {
        case AP_SIZE_4MB:
            *CurrentSizeInPages = (4 * 1024*1024) / PAGE_SIZE;
            break;
        case AP_SIZE_8MB:
            *CurrentSizeInPages = 8 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_16MB:
            *CurrentSizeInPages = 16 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_32MB:
            *CurrentSizeInPages = 32 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_64MB:
            *CurrentSizeInPages = 64 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_128MB:
            *CurrentSizeInPages = 128 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_256MB:
            *CurrentSizeInPages = 256 * (1024*1024 / PAGE_SIZE);
            break;

        default:
            AGPLOG(AGP_CRITICAL,
                   ("AGPALi - AgpQueryAperture - Unexpected value %x for ApSize!\n",
                    ApCtrl.ApSize));
            ASSERT(FALSE);
            AgpContext->ApertureStart.QuadPart = 0;
            AgpContext->ApertureLength = 0;
            return(STATUS_UNSUCCESSFUL);
    }

    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    if (ApertureRequirements != NULL) {
        //
        // 1541 supports 7 different aperture sizes, all must be
        // naturally aligned. Start with the largest aperture and
        // work downwards so that we get the biggest possible aperture.
        //
        Requirements = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(IO_RESOURCE_LIST) + (AP_SIZE_COUNT-1)*sizeof(IO_RESOURCE_DESCRIPTOR),
                                             'RpgA');
        if (Requirements == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        Requirements->Version = Requirements->Revision = 1;
        Requirements->Count = AP_SIZE_COUNT;
        Length = AP_MAX_SIZE;
        for (i=0; i<AP_SIZE_COUNT; i++) {
            Requirements->Descriptors[i].Option = IO_RESOURCE_ALTERNATIVE;
            Requirements->Descriptors[i].Type = CmResourceTypeMemory;
            Requirements->Descriptors[i].ShareDisposition = CmResourceShareDeviceExclusive;
            Requirements->Descriptors[i].Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;

            Requirements->Descriptors[i].u.Memory.Length = Length;
            Requirements->Descriptors[i].u.Memory.Alignment = Length;
            Requirements->Descriptors[i].u.Memory.MinimumAddress.QuadPart = 0;
            Requirements->Descriptors[i].u.Memory.MaximumAddress.QuadPart = (ULONG)-1;

            Length = Length/2;
        }
        *ApertureRequirements = Requirements;
    }
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetAperture(
    IN PAGPALi_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*++

Routine Description:

    Sets the GART aperture to the supplied settings

Arguments:

    AgpContext - Supplies the AGP context

    NewBase - Supplies the new physical memory base for the GART.

    NewSizeInPages - Supplies the new size for the GART

Return Value:

    NTSTATUS

--*/

{
    ULONG ApBase;
    ULONG ApSize;
    APCTRL ApCtrl;
    GTLBCTRL GTLBCtrl;
    ULONG GTLBDisable;
    PHYSICAL_ADDRESS GartPhysical;

    GartPhysical = AgpContext->GartPhysical;

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }
    
    //
    // Set GART base
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);
    ApCtrl.ATTBase = GartPhysical.LowPart / PAGE_SIZE;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);

    //
    // If the new settings match the current settings, leave everything
    // alone.
    //
    if ((NewBase.QuadPart == AgpContext->ApertureStart.QuadPart) &&
        (NewSizeInPages == AgpContext->ApertureLength / PAGE_SIZE)) {
        //
        // Enable GART table
        //
        if ((AgpContext->ChipsetType != ALi1647) && (AgpContext->ChipsetType != ALi1651) &&
            (AgpContext->ChipsetType != ALi1644) && (AgpContext->ChipsetType != ALi1646) &&
            (AgpContext->ChipsetType != ALi1671) && (AgpContext->ChipsetType != ALi1672))
        {
            if (AgpContext->Gart) {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
                GTLBCtrl.GTLB_ENJ = 0;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
            }
        }       

        AgpWorkaround(AgpContext);

        return(STATUS_SUCCESS);
    }

    //
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) {
        case 4 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_4MB;
            break;
        case 8 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_8MB;
            break;
        case 16 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_16MB;
            break;
        case 32 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_32MB;
            break;
        case 64 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_64MB;
            break;
        case 128 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_128MB;
            break;
        case 256 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_256MB;
            break;
        default:
            AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
            ASSERT(FALSE);
            return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary.
    //
    ASSERT(NewBase.HighPart == 0);
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);
    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART aperture of %lx pages\n",
               NewBase.QuadPart,
               NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Need to reset the hardware to match the supplied settings
    //
    // If the GTLB is enabled, disable it, write the new settings, then reenable the GTLB
    //
    GTLBDisable = 1; 
    if ((AgpContext->ChipsetType != ALi1647) && (AgpContext->ChipsetType != ALi1651) &&
        (AgpContext->ChipsetType != ALi1644) && (AgpContext->ChipsetType != ALi1646) &&
        (AgpContext->ChipsetType != ALi1671) && (AgpContext->ChipsetType != ALi1672))
    {
        ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        GTLBDisable = GTLBCtrl.GTLB_ENJ;
        if (!GTLBDisable)
        {
                GTLBCtrl.GTLB_ENJ = 1;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        }
    }

    //
    // update APBASE
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApBase, APBASE_OFFSET);
    ApBase = (ApBase & 0x0000000F) | NewBase.LowPart;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApBase, APBASE_OFFSET);

    //
    // update APSIZE
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);
    ApCtrl.ApSize = ApSize;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);

    //
    // Only 1541 chipset supports NLVM_BASE and NLVM_TOP
    //
    if (AgpContext->ChipsetType == ALi1541) {
        //
        // update NLVM_BASE and NLVM_TOP
        //
        ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        GTLBCtrl.NLVM_Base = NewBase.LowPart >> 20;
        GTLBCtrl.NLVM_Top = (NewBase.LowPart + NewSizeInPages * PAGE_SIZE - 0x100000) >> 20;
        WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
    }

#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        APCTRL DbgSize;
        ULONG DbgBase;

        ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &DbgSize, APCTRL_OFFSET);
        ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &DbgBase, APBASE_OFFSET);
        ASSERT(DbgSize.ApSize == ApSize);
        ASSERT(DbgBase == ApBase);
    }
#endif

    //
    // Now enable the GTLB if it was enabled before
    //
    if ((AgpContext->ChipsetType != ALi1647) && (AgpContext->ChipsetType != ALi1651) &&
        (AgpContext->ChipsetType != ALi1644) && (AgpContext->ChipsetType != ALi1646) &&
        (AgpContext->ChipsetType != ALi1671) && (AgpContext->ChipsetType != ALi1672))
    {
        if (!GTLBDisable)
        {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
                GTLBCtrl.GTLB_ENJ = 0;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        }
    }

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

    return(STATUS_SUCCESS);
}



VOID
AgpDisableAperture(
    IN PAGPALi_EXTENSION AgpContext
    )
/*++

Routine Description:

    Disables the GART aperture so that this resource is available
    for other devices

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None - this routine must always succeed.

--*/

{
    GTLBCTRL GTLBCtrl;
    ULONG GTLBDisable;

    //
    // Disable the aperture
    //
    if ((AgpContext->ChipsetType != ALi1647) && (AgpContext->ChipsetType != ALi1651) &&
        (AgpContext->ChipsetType != ALi1644) && (AgpContext->ChipsetType != ALi1646) &&
        (AgpContext->ChipsetType != ALi1671) && (AgpContext->ChipsetType != ALi1672))
    {
        ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        GTLBDisable = GTLBCtrl.GTLB_ENJ;
        if (!GTLBDisable)
        {
                GTLBCtrl.GTLB_ENJ = 1;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        }
    }

    //
    // Nuke the Gart!  (It's meaningless now...)
    //
    if (AgpContext->Gart != NULL) {
        MmFreeContiguousMemory(AgpContext->Gart);
        AgpContext->Gart = NULL;
        AgpContext->GartLength = 0;
    }
}

NTSTATUS
AgpReserveMemory(
    IN PAGPALi_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*++

Routine Description:

    Reserves a range of memory in the GART.

Arguments:

    AgpContext - Supplies the AGP Context

    Range - Supplies the AGP_RANGE structure. AGPLIB
        will have filled in NumberOfPages and Type. This
        routine will fill in MemoryBase and Context.

Return Value:

    NTSTATUS

--*/

{
    ULONG Index;
    ULONG NewState;
    NTSTATUS Status;
    PGART_PTE FoundRange;
    BOOLEAN Backwards;

    ASSERT((Range->Type == MmNonCached) || (Range->Type == MmWriteCombined));
    ASSERT(Range->NumberOfPages <= (AgpContext->ApertureLength / PAGE_SIZE));

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);
        Status = AgpALiCreateGart(AgpContext,Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpALiCreateGart failed %08lx to create GART of size %lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries to satisfy
    // the request. Requests for uncached memory will scan from high addresses to
    // low addresses. Requests for write-combined memory will scan from low addresses
    // to high addresses. We will use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
    FoundRange = AgpALiFindRangeInGart(&AgpContext->Gart[0],
                                       &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
                                       Range->NumberOfPages,
                                       Backwards,
                                       GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
                Range->NumberOfPages,
                Range->Type,
                AgpContext->Gart));

        //
        //  This is where we could try and grow the GART
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    for (Index = 0;Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.LowPart));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGPALi_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*++

Routine Description:

    Releases memory previously reserved with AgpReserveMemory

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the range to be released.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Pte;
    ULONG Start;
    GTLBTAGCLR ClearTag;

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point.
    //
    for (Pte = Range->Context;
         Pte < (PGART_PTE)Range->Context + Range->NumberOfPages;
         Pte++) {
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        }
        Pte->Soft.State = GART_ENTRY_FREE;
    }

    //
    // Clear All Tag
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ClearTag, GTLBTAGCLR_OFFSET);
    ClearTag.GTLBTagClear = 1;
    ClearTag.ClearAllTag = 1;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ClearTag, GTLBTAGCLR_OFFSET);

    Range->MemoryBase.QuadPart = 0;
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpALiCreateGart(
    IN PAGPALi_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*++

Routine Description:

    Allocates and initializes an empty GART. The current implementation
    attempts to allocate the entire GART on the first reserve.

Arguments:

    AgpContext - Supplies the AGP context

    MinimumPages - Supplies the minimum size (in pages) of the GART to be
        created.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Gart;
    ULONG GartLength;
    PHYSICAL_ADDRESS LowestAcceptable;
    PHYSICAL_ADDRESS BoundaryMultiple;
    PHYSICAL_ADDRESS HighestAcceptable;
    PHYSICAL_ADDRESS GartPhysical;
    ULONG i;
    CACHECTRL FlushCache;
    APCTRL ApCtrl;
    GTLBCTRL    GTLBCtrl;

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //
    HighestAcceptable.QuadPart = 0xFFFFFFFF;
    LowestAcceptable.QuadPart = 0;
    BoundaryMultiple.QuadPart = 0;
    GartLength = BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE);

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength,
                                                  LowestAcceptable,
                                                  HighestAcceptable,
                                                  BoundaryMultiple,
                                                  MmNonCached);
    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("AgpALiCreateGart - MmAllocateContiguousMemory %lx failed\n",
                GartLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

    //
    // Get the physical address.
    //
    GartPhysical = MmGetPhysicalAddress(Gart);
    AGPLOG(AGP_NOISE,
           ("AgpALiCreateGart - GART of length %lx created at VA %08lx, PA %08lx\n",
            GartLength,
            Gart,
            GartPhysical.LowPart));
    ASSERT(GartPhysical.HighPart == 0);
    ASSERT((GartPhysical.LowPart & (PAGE_SIZE-1)) == 0);

    //
    // Initialize all the PTEs to free
    //
    for (i=0; i<GartLength/sizeof(GART_PTE); i++) {
        Gart[i].AsUlong = 0;
    }

    //
    // Only 1541 chipset has L1_2_CACHE_FLUSH_CTRL
    //
    if (AgpContext->ChipsetType == ALi1541) {
        
        //
        // Flush GART table region
        //
        FlushCache.Flush_Enable = 1;
        for (i=0; i < GartLength/PAGE_SIZE; i++)
        {
            FlushCache.Address = (GartPhysical.LowPart / PAGE_SIZE) + i;
            WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &FlushCache, L1_2_CACHE_FLUSH_CTRL);
        }
    }

    //
    // Set GART base
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);
    ApCtrl.ATTBase = GartPhysical.LowPart / PAGE_SIZE;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);

    //
    // Enable GART table
    //
    if ((AgpContext->ChipsetType != ALi1647) && (AgpContext->ChipsetType != ALi1651) &&
        (AgpContext->ChipsetType != ALi1644) && (AgpContext->ChipsetType != ALi1646) &&
        (AgpContext->ChipsetType != ALi1671) && (AgpContext->ChipsetType != ALi1672))
    {
        ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        GTLBCtrl.GTLB_ENJ = 0;
        WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
    }   

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
    AgpContext->GartPhysical = GartPhysical;

    return(STATUS_SUCCESS);
}

NTSTATUS
Agp1541FlushPages(
    IN PAGPALi_EXTENSION AgpContext,
    IN PMDL Mdl
    )

/*++

Routine Description:

    Flush entries in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    Mdl - Supplies the MDL describing the physical pages to be flushed

Return Value:

    VOID

--*/

{
    ULONG PageCount;
    CACHECTRL FlushCache;
    ULONG Index;
    PULONG Page;

    ASSERT(Mdl->Next == NULL);
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);

    Page = (PULONG)(Mdl + 1);

    //
    // Flush GART table entry
    //
    FlushCache.Flush_Enable = 1;
    for (Index = 0; Index < PageCount; Index++) {
        FlushCache.Address = Page[Index];
        WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &FlushCache, L1_2_CACHE_FLUSH_CTRL);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
AgpMapMemory(
    IN PAGPALi_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Maps physical memory into the GART somewhere in the specified range.

Arguments:

    AgpContext - Supplies the AGP context

    Range - Supplies the AGP range that the memory should be mapped into

    Mdl - Supplies the MDL describing the physical pages to be mapped

    OffsetInPages - Supplies the offset into the reserved range where the
        mapping should begin.

    MemoryBase - Returns the physical memory in the aperture where the pages
        were mapped.

Return Value:

    NTSTATUS

--*/

{
    ULONG PageCount;
    PGART_PTE Pte;
    PGART_PTE StartPte;
    ULONG Index;
    ULONG TargetState;
    PULONG Page;
    BOOLEAN Backwards;
    GART_PTE NewPte;
    GTLBTAGCLR ClearTag;

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    TargetState = (Range->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : GART_ENTRY_RESERVED_WC;

    Pte = StartPte + OffsetInPages;

    //
    // We have a suitable range, now fill it in with the supplied MDL.
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount <= StartPte + Range->NumberOfPages);
    NewPte.AsUlong = 0;
    NewPte.Soft.State = (Range->Type == MmNonCached) ? GART_ENTRY_VALID_UC :
                                                       GART_ENTRY_VALID_WC;
    Page = (PULONG)(Mdl + 1);

    // Fill the physical memory address into GART
    for (Index = 0; Index < PageCount; Index++) {
        AGPLOG(AGP_NOISE,
               ("AgpMapMemory: Pte=%p, Page=%x\n", &Pte[Index], *Page));
        NewPte.Hard.Page = *Page++;
        Pte[Index].AsUlong = NewPte.AsUlong;
    }

    //
    // Clear All Tag
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ClearTag, GTLBTAGCLR_OFFSET);
    ClearTag.GTLBTagClear = 1;
    ClearTag.ClearAllTag = 1;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ClearTag, GTLBTAGCLR_OFFSET);

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGPALi_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG PageOffset
    )
/*++

Routine Description:

    Unmaps previously mapped memory in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range that the memory should be mapped into

    NumberOfPages - Supplies the number of pages in the range to be freed.

    PageOffset - Supplies the offset into the range where the freeing should begin.

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    PGART_PTE Pte;
    PGART_PTE StartPte;
    GTLBTAGCLR ClearTag;
    ULONG NewState;

    ASSERT(PageOffset + NumberOfPages <= AgpRange->NumberOfPages);

    StartPte = AgpRange->Context;
    Pte = &StartPte[PageOffset];
    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    //
    // Clear the GART entry.
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid) {
            Pte[i].Soft.State = NewState;
        } else {
            //
            // This page is not mapped, just skip it.
            //
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[i],
                    Pte[i].AsUlong,
                    i));
        }
    }

    //
    // Clear All Tag
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ClearTag, GTLBTAGCLR_OFFSET);
    ClearTag.GTLBTagClear = 1;
    ClearTag.ClearAllTag = 1;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ClearTag, GTLBTAGCLR_OFFSET);

    return(STATUS_SUCCESS);
}


PGART_PTE
AgpALiFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;
    PGART_PTE Candidate;

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if (Current->Soft.State == SearchState) {
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;

    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid == 0) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                ++i;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
    return;

}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONG Pages;

    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONG)(Mdl + 1);
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    for (i=0; i<NumberOfPages; i++) {
        ASSERT(Pte[i].Hard.Valid == 1);
        Pages[i] = Pte[i].Hard.Page;
    }
    return;
}

VOID
AgpWorkaround(
    IN PVOID AgpExtension
    )
{
    PAGPALi_EXTENSION Extension = AgpExtension;
    ULONG ulTemp, ulTemp1, ulLockRW, i, j, k, ulQD;
    ULONG ulType, ulSize, ulTmp0, ulTmp1, ulChipVersion;
    BOOLEAN blPrefetchFound, blSupportAGP, blnVidia=FALSE, blMatrox=FALSE, blAtiRage128=FALSE;
    UCHAR ID, Address, Data;
    NTSTATUS                 Status;

    ReadConfigUchar(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, CHIP_REVISION_OFFSET);
    ulChipVersion = ulTemp & 0xFF;
    
    ulTemp = (ULONG)-1;
    ReadConfigUlongSafe(AGP_VGA_BUS_ID, AGP_VGA_SLOT_ID, &ulTemp, 0);

    //
    // Come back after you splurge for an AGP card!!!
    //
    if (ulTemp == (ULONG)-1) {
        return;
    }

    if ((ulTemp & 0xFFFF) == 0x10DE)                            // nVidia chip detected
        blnVidia=TRUE;
    else if ((ulTemp & 0xFFFF) == 0x102B)
        blMatrox=TRUE;
    else if ((ulTemp & 0xFFFF) == 0x1002)
    {    
        if ((ulTemp == 0x52451002) || (ulTemp == 0x52461002) || (ulTemp == 0x524B1002) || (ulTemp == 0x524C1002) ||
            (ulTemp == 0x53451002) || (ulTemp == 0x53461002) || (ulTemp == 0x53471002) || (ulTemp == 0x534B1002) || 
            (ulTemp == 0x534C1002) || (ulTemp == 0x534D1002))
            blAtiRage128=TRUE;    
    }    

    switch (Extension->ChipsetType)
    {
        case ALi1541:
            ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, AGP_STATUS_OFFSET);     // adjust queue depth to avoid ambiguous
            if (((ulTemp & 0xFF000000) >= 0x1C000000) && ((ulTemp & 0xFF000000) <= 0x20000000))
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulLockRW, M1541_Lock_WR);
                ulTemp1 = ulLockRW | 0x40;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp1, M1541_Lock_WR);
                ulTemp = (ulTemp & 0x00FFFFFF) | 0x1B000000;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, AGP_STATUS_OFFSET);
                ulLockRW = ulLockRW & 0xFFFFFFBF;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulLockRW, M1541_Lock_WR);
            }

            ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x40);      // 0x43 bit 7 -> 1
            ulTemp = ulTemp | 0x80000000;
            WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x40);

            ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_P2P_SLOT_ID, &ulTemp, 0x88);       // P2P 0x88 bit 7,5,3 -> 1
            ulTemp = ulTemp | 0x000000A8;
            WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_P2P_SLOT_ID, &ulTemp, 0x88);

            // fix frame buffer here
            i=0;
            blPrefetchFound=FALSE;
            while ((i<6) && (!blPrefetchFound))      // Jump out loop when first prefetch found
            {                                       // Two or more prefetch case should be considered in the future
                ReadConfigUlong(AGP_VGA_BUS_ID, AGP_VGA_SLOT_ID, &ulTemp1, 0x10+i*0x4);     // read VGA base address
                if ((ulTemp1 & 0x0000000F) == 0x8) blPrefetchFound=TRUE;
                i++;
            }

            if (blPrefetchFound)             // AGP VGA prefetchable address is found. Modify M1541 write buffer
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_P2P_SLOT_ID, &ulTemp, 0x84);
                if ((ulTemp & 0x00010000) == 0x00010000)       // Write buffer is enabled
                {
                    ulTemp = (ulTemp & 0xFFFF0000) | ((ulTemp1 & 0xFFF00000) >> 16) | 0x4;
                    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_P2P_SLOT_ID, &ulTemp, 0x84);
                }
            }
            else                            // AGP VGA prefetchable address is not found. Disable M1541 write buffer
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_P2P_SLOT_ID, &ulTemp, 0x84);
                ulTemp = ulTemp & 0xFFFE0000;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_P2P_SLOT_ID, &ulTemp, 0x84);
            }

            if (blnVidia)    // Set aperture size to 4M as a temporatory solution
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, APCTRL_OFFSET);
                ulTemp = (ulTemp & 0xFFFFFFF0) | AP_SIZE_4MB;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, APCTRL_OFFSET);

            }

            break;

        case ALi1621:
            // Check AGP VGA is a pipeline(SBA disabled) device. If yes, adjust queue depth to 0x2(3 queues)
            ReadConfigUlong(AGP_VGA_BUS_ID, AGP_VGA_SLOT_ID, &ulTemp1, PCI_STATUS_REG);
            ulQD = 0;
            blSupportAGP = FALSE;
            if ((ulTemp1 & 0x00100000) != 0)
            {
                ReadConfigUlong(AGP_VGA_BUS_ID, AGP_VGA_SLOT_ID, &ulTemp1, CAP_PTR);
                ulTemp = ulTemp1 & 0xFF;

                while (!blSupportAGP)
                {
                    if ((ulTemp < 0x40) || (ulTemp > 0xF4)) break;
                    ReadConfigUlong(AGP_VGA_BUS_ID, AGP_VGA_SLOT_ID, &ulTemp1, ulTemp);
                    if ((ulTemp1 & 0xFF) == AGP_ID)
                        blSupportAGP = TRUE;
                    else
                        ulTemp = (ulTemp1 & 0xFF00) >> 8;
                }

                if (blSupportAGP)
                {
                    ReadConfigUlong(AGP_VGA_BUS_ID, AGP_VGA_SLOT_ID, &ulTemp1, ulTemp+4);   // Read AGP status register
                    if ((ulTemp1 & 0x00000200) == 0x0) ulQD = 0x2;                      // AGP VGA supports pipeline only
                }
            }

            ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, AGP_STATUS_OFFSET);     // adjust queue depth to avoid ambiguous
            if ((((ulTemp & 0xFF000000) >= 0x1C000000) && ((ulTemp & 0xFF000000) <= 0x20000000)) || (ulQD != 0))
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulLockRW, M1621_Lock_WR);
                ulTemp1 = ulLockRW | 0x1000;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp1, M1621_Lock_WR);

                if (ulQD != 0)
                    ulTemp = (ulTemp & 0x00FFFFFF) | (ulQD << 24);
                else
                    ulTemp = (ulTemp & 0x00FFFFFF) | 0x1B000000;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, AGP_STATUS_OFFSET);
                ulLockRW = ulLockRW & 0xFFFFEFFF;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulLockRW, M1621_Lock_WR);
            }

            ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x80);
            ulTemp = ulTemp & 0xFFFFF3FF;                               // set offset 0x81 bit 2~3 to 0
            WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x80);

            if (blnVidia)
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x50);
                ulTemp = ulTemp | 0x40;                                 // set M1621 index 0x50 bit 6 to 1
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x50);

                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x60);
                ulTemp = ulTemp | 0x40;                                 // set M1621 index 0x60 bit 6 to 1
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x60);

                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x7C);
                ulTemp = ulTemp & 0xCFFFFFFF;                           // set M1621 index 0x7F bit 4~5 to 0
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x7C);
            }

            if (blMatrox)
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x50);
                ulTemp = ulTemp | 0xFF000000;                           // set M1621 index 0x53 to 0xFF
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x50);
            }

            break;
        case ALi1631:
        case ALi1632:
            break;
        case ALi1641:
            if (blMatrox)
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x50);
                ulTemp = ulTemp | 0xFF000000;                           // set M1621 index 0x53 to 0xFF
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x50);
            }

            break;
        case ALi1644:
        case ALi1646:
        case ALi1647:
        case ALi1651:            
            if (blAtiRage128 && (ulChipVersion < 0xB0))    
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, APCTRL_OFFSET);
                ulTemp = (ulTemp & 0xFFFFFFF0) | AP_SIZE_4MB;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, APCTRL_OFFSET);
            } 
            if ( ulChipVersion < 0xB2)
            {
                for (k=0; k<32; k++) {
    	             ReadConfigUlongSafe(0, k, &ulTmp0, 0x08);
    	             ulTmp0 = ulTmp0 & 0xFFFF0000;
    	             if ( ulTmp0 == 0x04000000 )
    	             {
    		           ReadConfigUlong(0, k, &ulTmp0, 0x0C);
    		           ulTmp1 = ulTmp0 & 0xFFFF00FF;
    		           ulTmp1 = ulTmp1 | 0x0A00;
    		           WriteConfigUlong(0, k, &ulTmp1, 0x0C);
    		           ReadConfigUlong(0, k, &ulTmp0, 0x0);
    		           if ((ulTmp0 & 0xFFFF) == 0x109E)
    		           {
    		                 ReadConfigUlong(0, k, &ulTmp0, 0x40);
    		                 ulTmp1 = ulTmp0 & 0xFFFFFFFD;
    		                 ulTmp1 = ulTmp1 | 0x02;
    		                 WriteConfigUlong(0, k, &ulTmp1, 0x40); 
    		           }      
    	             }         
                }
            }	
            break;
        case ALi1671:
            break;
        case ALi1672:
            break;
        default:
            break;
    }
}


NTSTATUS
AgpSpecialTarget(
    IN PAGPALi_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context

    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = AgpALiSetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Add more tweaks here...
    //

    AgpContext->SpecialTarget |= DeviceFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
AgpALiSetRate(
    IN PAGPALi_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies the AGP context

    AgpRate - Rate to set

    note: this routine assumes that AGP has already been enabled, and that
          whatever rate we've been asked to set is supported by master

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetPciDeviceCapability(0, 0, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGPALiSetRate: AgpLibGetPciDeviceCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGPALiSetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPALiSetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPALiSetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGPALiSetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    TargetCap.AGPCommand.Rate = AgpRate;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;
        
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPALiSetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGPALiSetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\amdagp8x\gart8x.c ===
/*++

Copyright (c) 1997-2002  Microsoft Corporation

Module Name:

    gart8x.c

Abstract:

    Routines for querying and setting the AMD GART aperture

Author:

    John Vert (jvert) 10/30/1997

Revision History:

--*/

/*
******************************************************************************
 * Archive File : $Archive: /Drivers/OS/Hammer/AGP/XP/amdagp/Gart8x.c $
 *
 * $History: Gart8x.c $
 * 
 * 
******************************************************************************
*/


#include "amdagp8x.h"

//
// Local function prototypes
//
NTSTATUS
AgpAMDCreateGart(
    IN PAGP_AMD_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

NTSTATUS
AgpAMDSetRate(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

NTSTATUS
AgpAMDFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState,
	OUT PGART_PTE *GartPte
    );

NTSTATUS
AgpAMDFlushPages(
    IN PAGP_AMD_EXTENSION AgpContext,
    IN PMDL Mdl
	);

void
AgpInitializeChipset(
    IN PAGP_AMD_EXTENSION AgpContext
	);

PAGP_FLUSH_PAGES AgpFlushPages = AgpAMDFlushPages;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpDisableAperture)
#pragma alloc_text(PAGE, AgpQueryAperture)
#pragma alloc_text(PAGE, AgpReserveMemory)
#pragma alloc_text(PAGE, AgpReleaseMemory)
#pragma alloc_text(PAGE, AgpAMDCreateGart)
#pragma alloc_text(PAGE, AgpMapMemory)
#pragma alloc_text(PAGE, AgpUnMapMemory)
#pragma alloc_text(PAGE, AgpAMDFindRangeInGart)
#pragma alloc_text(PAGE, AgpFindFreeRun)
#pragma alloc_text(PAGE, AgpGetMappedPages)
#endif

extern ULONG DeviceID;
extern ULONG AgpLokarSlotID;
extern ULONG AgpHammerSlotID;

//
// Function Name:  AgpQueryAperture()
//
// Description:
//		Queries the current size of the GART aperture.
//		Optionally returns the possible GART settings.
//
// Parameters:
//		AgpContext - Supplies the AGP context.
//		CurrentBase - Returns the current physical address of the GART.
//		CurrentSizeInPages - Returns the current GART size.
//		ApertureRequirements - if present, returns the possible GART settings.
//
// Return:
//		STATUS_SUCCESS on success, otherwise STATUS_UNSUCCESSFUL.
//
NTSTATUS
AgpQueryAperture( IN PAGP_AMD_EXTENSION AgpContext,
				  OUT PHYSICAL_ADDRESS *CurrentBase,
				  OUT ULONG *CurrentSizeInPages,
				  OUT OPTIONAL PIO_RESOURCE_LIST *pApertureRequirements )
{
    ULONG ApBase;
    ULONG ApSize;
	ULONG AgpSizeIndex;
    PIO_RESOURCE_LIST Requirements;
    ULONG i;
    ULONG Length;

    PAGED_CODE();
    //
    // Get the current APBASE and APSIZE settings
    //
    ReadAMDConfig(AgpLokarSlotID, &ApBase, APBASE_OFFSET, sizeof(ApBase));
    ReadAMDConfig(AgpHammerSlotID, &ApSize, GART_APSIZE_OFFSET, sizeof(ApSize));

    ASSERT(ApBase != 0);
    CurrentBase->QuadPart = ApBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Convert APSIZE into the actual size of the aperture
    //
    AgpSizeIndex = (ULONG)(ApSize & APH_SIZE_MASK) >> 1;
	*CurrentSizeInPages = (0x0001 << (AgpSizeIndex + 25)) / PAGE_SIZE;


    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    if (pApertureRequirements != NULL) {
        //
        // Lokar supports 6 different aperture sizes, all must be 
        // naturally aligned. Start with the largest aperture and 
        // work downwards so that we get the biggest possible aperture.
        //
        Requirements = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(IO_RESOURCE_LIST) + (AP_SIZE_COUNT-1)*sizeof(IO_RESOURCE_DESCRIPTOR),
                                             'RpgA');
        if (Requirements == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        Requirements->Version = Requirements->Revision = 1;
        Requirements->Count = AP_SIZE_COUNT;
        Length = AP_MAX_SIZE;
        for (i=0; i<AP_SIZE_COUNT; i++) {
            Requirements->Descriptors[i].Option = IO_RESOURCE_ALTERNATIVE;
            Requirements->Descriptors[i].Type = CmResourceTypeMemory;
            Requirements->Descriptors[i].ShareDisposition = CmResourceShareDeviceExclusive;
            Requirements->Descriptors[i].Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;

            Requirements->Descriptors[i].u.Memory.Length = Length;
            Requirements->Descriptors[i].u.Memory.Alignment = Length;
            Requirements->Descriptors[i].u.Memory.MinimumAddress.QuadPart = 0;
            Requirements->Descriptors[i].u.Memory.MaximumAddress.QuadPart = (ULONG)-1;

            Length = Length/2;
        }
        *pApertureRequirements = Requirements;

    }
    return(STATUS_SUCCESS);
}


//
// Function Name:  AgpSetAperture()
//
// Description:
//		Sets the GART aperture to the supplied settings.
//
// Parameters:
//		AgpContext - Supplies the AGP context.
//		NewBase - Supplies the new physical memory base for the GART.
//		NewSizeInPages - Supplies the new size for the GART.
//
// Return:
//		STATUS_SUCCESS on success, otherwise STATUS_INVALID_PARAMETER.
//
NTSTATUS
AgpSetAperture( IN PAGP_AMD_EXTENSION AgpContext,
				IN PHYSICAL_ADDRESS NewBase,
				IN ULONG NewSizeInPages )
{
    ULONG AphSizeNew, AplSizeNew, ApSizeOld;
    ULONG ApBase;

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }

    //
    // If the new settings match the current settings, leave everything
    // alone.
    //
    if ((NewBase.QuadPart == AgpContext->ApertureStart.QuadPart) &&
        (NewSizeInPages == AgpContext->ApertureLength / PAGE_SIZE)) {
        // Re-initialize when the chip is powered off
        if (AgpContext->Gart != NULL) {
            AgpInitializeChipset(AgpContext);
        }
        
        return(STATUS_SUCCESS);
    }

    //                                        
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) {
        case 32 * 1024 * 1024 / PAGE_SIZE:
            AphSizeNew = APH_SIZE_32MB;
            AplSizeNew = APL_SIZE_32MB;
            break;
        case 64 * 1024 * 1024 / PAGE_SIZE:
            AphSizeNew = APH_SIZE_64MB;
            AplSizeNew = APL_SIZE_64MB;
           break;
        case 128 * 1024 * 1024 / PAGE_SIZE:
            AphSizeNew = APH_SIZE_128MB;
            AplSizeNew = APL_SIZE_128MB;
            break;
        case 256 * 1024 * 1024 / PAGE_SIZE:
            AphSizeNew = APH_SIZE_256MB;
            AplSizeNew = APL_SIZE_256MB;
            break;
        case 512 * 1024 * 1024 / PAGE_SIZE:
            AphSizeNew = APH_SIZE_512MB;
            AplSizeNew = APL_SIZE_512MB;
            break;
        case 1024 * 1024 * 1024 / PAGE_SIZE:
            AphSizeNew = APH_SIZE_1024MB;
            AplSizeNew = APL_SIZE_1024MB;
            break;
       default:
            AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
            ASSERT(FALSE);
            return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary.
    //
    ASSERT(NewBase.HighPart == 0);
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);
    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART aperture of %lx pages\n",
               NewBase.QuadPart,
               NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Need to reset the hardware to match the supplied settings
    //
    // Write APSIZE first, as this will enable the correct bits in APBASE that need to
    // be written next.
    //
    ReadAMDConfig(AgpHammerSlotID, &ApSizeOld, GART_APSIZE_OFFSET, sizeof(ApSizeOld));
	ApSizeOld &= (~APH_SIZE_MASK);
    AphSizeNew |= ApSizeOld;
	WriteAMDConfig(AgpHammerSlotID, &AphSizeNew, GART_APSIZE_OFFSET, sizeof(AphSizeNew));

    ReadAMDConfig(AgpLokarSlotID, &ApSizeOld, AMD_APERTURE_SIZE_OFFSET, sizeof(ApSizeOld));
	ApSizeOld &= (~APL_SIZE_MASK);
    AplSizeNew |= ApSizeOld;
	WriteAMDConfig(AgpLokarSlotID, &AplSizeNew, AMD_APERTURE_SIZE_OFFSET, sizeof(AplSizeNew));

    //
    // Now we can update APBASE
    //
    ApBase = NewBase.LowPart & APBASE_ADDRESS_MASK;
    WriteAMDConfig(AgpLokarSlotID, &ApBase, APBASE_OFFSET, sizeof(ApBase));
	ApBase >>= GART_APBASE_SHIFT;
	WriteAMDConfig(AgpHammerSlotID, &ApBase, GART_APBASE_OFFSET, sizeof(ApBase));

#ifdef DEBUG2
    //
    // Read back what we wrote, make sure it worked
    //
    {
        ULONG DbgBase;
        UCHAR DbgSize;

        ReadAMDConfig(AgpHammerSlotID, &DbgSize, GART_APSIZE_OFFSET, sizeof(DbgSize));
        ReadAMDConfig(AgpHammerSlotID, &DbgBase, GART_APBASE_OFFSET, sizeof(DbgBase));
        ASSERT(DbgSize == AphSizeNew);
        ASSERT(DbgBase == ApBase);
    }
#endif

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

    //
    // If the GART has been allocated, rewrite the GART Directory Base Address
    //
    if (AgpContext->Gart != NULL) {
        AgpInitializeChipset(AgpContext);
    }

    return(STATUS_SUCCESS);
}


//
// Function Name:  AgpDisableAperture()
//
// Description:
//		Disables the GART aperture so that this resource is available
//		for other devices.
//
// Parameters:
//		AgpContext - Supplies the AGP context.
//
// Return:
//		None.
//
VOID
AgpDisableAperture( IN PAGP_AMD_EXTENSION AgpContext )
{
	ULONG ConfigData;

    //
    // Disable the aperture
    //
	ReadAMDConfig(AgpHammerSlotID, &ConfigData, GART_APSIZE_OFFSET, sizeof(ConfigData));
	ConfigData &= ~GART_ENABLE_BIT;
	WriteAMDConfig(AgpHammerSlotID, &ConfigData, GART_APSIZE_OFFSET, sizeof(ConfigData));

    //
    // Nuke the Gart!  (It's meaningless now...)
    //
    if (AgpContext->Gart != NULL) {
        MmFreeContiguousMemory(AgpContext->Gart);
        AgpContext->Gart = NULL;
        AgpContext->GartLength = 0;
    }
}


//
// Function Name:  AgpReserveMemory()
//
// Description:
//		Reserves a range of memory in the GART.
//
// Parameters:
//		AgpContext - Supplies the AGP context.
//		Range - Supplies the AGP_RANGE structure.
//			AGPLIB will have filled in NumberOfPages and Type.
//			This routine will fill in MemoryBase and Context.
//
// Return:
//		STATUS_SUCCESS on success, otherwise NTSTATUS.
//
NTSTATUS
AgpReserveMemory( IN PAGP_AMD_EXTENSION AgpContext,
				  IN OUT AGP_RANGE *Range )
{
	ULONG Index;
    ULONG NewState;
    NTSTATUS Status;
	PGART_PTE FoundRange;
    BOOLEAN Backwards;

    PAGED_CODE();

    ASSERT((Range->Type == MmNonCached) || 
			(Range->Type == MmWriteCombined) ||
			(Range->Type == MmHardwareCoherentCached));

    if (Range->NumberOfPages > (AgpContext->ApertureLength / PAGE_SIZE)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);
        Status = AgpAMDCreateGart(AgpContext, Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpAMDCreateGart failed %08lx to create GART of size %lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries to satisfy
    // the request. Requests for uncached memory will scan from high addresses to
    // low addresses. Requests for write-combined memory will scan from low addresses
    // to high addresses. We will use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
	Status = AgpAMDFindRangeInGart(&AgpContext->Gart[0],
                                   &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
                                   Range->NumberOfPages,
                                   Backwards,
                                   GART_ENTRY_FREE,
								   &FoundRange);

    if (!NT_SUCCESS(Status)) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
                Range->NumberOfPages,
                Range->Type,
                AgpContext->Gart));

        //
        //  This is where we could try and grow the GART
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else if (Range->Type == MmWriteCombined) {
        NewState = GART_ENTRY_RESERVED_WC;
    } else {
        NewState = GART_ENTRY_RESERVED_CC;
    }

    for (Index = 0;Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.LowPart));

	DisplayStatus(0x40);
    return(STATUS_SUCCESS);
}


//
// Function Name:  AgpReleaseMemory()
//
// Description:
//		Releases memory previously reserved with AgpReserveMemory.
//
// Parameters:
//		AgpContext - Supplies the AGP context.
//		Range - Supplies the range to be released.
//
// Return:
//		STATUS_SUCCESS.
//
NTSTATUS
AgpReleaseMemory( IN PAGP_AMD_EXTENSION AgpContext,
				  IN PAGP_RANGE Range )
{
	PGART_PTE Pte;

    for (Pte = Range->Context;
         Pte < (PGART_PTE)Range->Context + Range->NumberOfPages;
         Pte++) 
    {
	    //
		// Go through and free all the PTEs. None of these should still
		// be valid at this point.
		//
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else if (Range->Type == MmWriteCombined) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_CC);
        }
        Pte->Soft.State = GART_ENTRY_FREE;
    }

    Range->MemoryBase.QuadPart = 0;

	DisplayStatus(0x50);
    return(STATUS_SUCCESS);
}


//
// Function Name:  AgpAMDCreateGart()
//
// Description:
//		Allocates and initializes an empty GART. The current implementation
//		attempts to allocate the entire GART on the first reserve call.
//
// Parameters:
//		AgpContext - Supplies the AGP context.
//		MinimumPages - Supplies the minimum size (in pages) of the GART 
//			to be created.
//
// Return:
//		STATUS_SUCCESS on success, otherwise NTSTATUS.
//
NTSTATUS
AgpAMDCreateGart( IN PAGP_AMD_EXTENSION AgpContext,
				  IN ULONG MinimumPages )
{
    PGART_PTE Gart;
	ULONG GartLength;
    PHYSICAL_ADDRESS GartPhysical;
    PHYSICAL_ADDRESS HighestPhysical;
    PHYSICAL_ADDRESS LowestPhysical;
    PHYSICAL_ADDRESS BoundaryPhysical;
	LONG PageCount;
    LONG Index;

    PAGED_CODE();

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture from the favored memory range.
    //
    GartLength = BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE);
    LowestPhysical.QuadPart = 0;
    HighestPhysical.QuadPart = 0xFFFFFFFF;
    BoundaryPhysical.QuadPart = 0;

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength, LowestPhysical,
                                                  HighestPhysical, BoundaryPhysical,
                                                  MmNonCached);
    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("AgpAMDCreateGart - MmAllocateContiguousMemory %lx failed\n",
                GartLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

    //
    // Get the physical address.
    //
    GartPhysical = MmGetPhysicalAddress(Gart);
    AGPLOG(AGP_NOISE,
           ("AgpAMDCreateGart - GART of length %lx created at VA %08lx, PA %08lx\n",
            GartLength,
            Gart,
            GartPhysical.LowPart));
    ASSERT(GartPhysical.HighPart == 0);
    ASSERT((GartPhysical.LowPart & (PAGE_SIZE-1)) == 0);

    //
    // Initialize all the PTEs to free
    //
	PageCount = GartLength / sizeof(GART_PTE);
    for (Index = 0;Index < PageCount; Index++) {
		Gart[Index].AsUlong = 0;
		Gart[Index].Soft.State = GART_ENTRY_FREE;
	}

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
	AgpContext->GartPhysical = GartPhysical;

	//
	// Initialize Registers for AGP operation
	//
	AgpInitializeChipset(AgpContext);

	DisplayStatus(0x30);
    return(STATUS_SUCCESS);
}


//
// Function Name:  AgpMapMemory()
//
// Description:
//		Maps physical memory into the GART somewhere in the specified range.
//
// Parameters:
//		AgpContext - Supplies the AGP context.
//		Range - Supplies the AGP range that the memory should be mapped into.
//		Mdl - Supplies the MDL describing the physical pages to be mapped.
//		OffsetInPages - Supplies the offset into the reserved range where the 
//			mapping should begin.
//		MemoryBase - Returns the physical memory in the aperture where the
//			pages were mapped.
//
// Return:
//		STATUS_SUCCESS on success, otherwise STATUS_INSUFFICIENT_RESOURCES.
//
NTSTATUS
AgpMapMemory( IN PAGP_AMD_EXTENSION AgpContext,
			  IN PAGP_RANGE Range,
			  IN PMDL Mdl,
			  IN ULONG OffsetInPages,
			  OUT PHYSICAL_ADDRESS *MemoryBase )
{
    ULONG PageCount, Index;
    ULONG TargetState;
    PPFN_NUMBER Page;
    BOOLEAN Backwards;
    GART_PTE NewPte;
	PGART_PTE Pte, StartPte;

    PAGED_CODE();

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    if (Range->Type == MmNonCached) {
        TargetState = GART_ENTRY_RESERVED_UC;
    } else if (Range->Type == MmWriteCombined) {
        TargetState = GART_ENTRY_RESERVED_WC;
    } else {
        TargetState = GART_ENTRY_RESERVED_CC;
    }

    Pte = StartPte + OffsetInPages;

    //
    // We have a suitable range, now fill it in with the supplied MDL.
    //

    NewPte.AsUlong = 0;
    if (Range->Type == MmNonCached) {
        NewPte.Soft.State = GART_ENTRY_VALID_UC;
    } else if (Range->Type == MmWriteCombined) {
        NewPte.Soft.State = GART_ENTRY_VALID_WC;
    } else {
        NewPte.Soft.State = GART_ENTRY_VALID_CC;
    }

	Page = (PPFN_NUMBER)(Mdl + 1);

    AGPLOG(AGP_NOISE,
           ("AgpMapMemory - mapped %d pages at Page %08lx\n",
            PageCount,
            *Page));

    for (Index = 0;Index < PageCount; Index++) {
        ASSERT(Pte[Index].Soft.State == TargetState);
		
#ifndef _WIN64
		NewPte.Hard.PageLow = *Page++;
#else
		NewPte.Hard.PageLow = (ULONG)*Page;
		NewPte.Hard.PageHigh = (ULONG)(*Page++ >> 20);
#endif
		Pte[Index].AsUlong = NewPte.AsUlong;
		ASSERT(Pte[Index].Hard.Valid == 1);
    }

	//
    // We have filled in all the PTEs invalidate the caches on all processors.
    //

    KeInvalidateAllCaches();
    NewPte.AsUlong = *(volatile ULONG *)&Pte[PageCount-1].AsUlong;

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

	DisplayStatus(0x60);
    return(STATUS_SUCCESS);
}


//
// Function Name:  AgpUnMapMemory()
//
// Description:
//		Unmaps previously mapped memory in the GART.
//
// Parameters:
//		AgpContext - Supplies the AGP context.
//		Range - Supplies the AGP range that the memory should be mapped into.
//		NumberOfPages - Supplies the number of pages in the range to be freed.
//		OffsetInPages - Supplies the offset into the range where the freeing 
//			should begin.
//
// Return:
//		STATUS_SUCCESS.
//
NTSTATUS
AgpUnMapMemory( IN PAGP_AMD_EXTENSION AgpContext,
				IN PAGP_RANGE AgpRange,
				IN ULONG NumberOfPages,
				IN ULONG OffsetInPages )
{
	ULONG Index;
	PGART_PTE Pte, StartPte;
    PGART_PTE LastChanged=NULL;
    ULONG NewState;

    PAGED_CODE();

    ASSERT(OffsetInPages + NumberOfPages <= AgpRange->NumberOfPages);

    StartPte = AgpRange->Context;
    Pte = &StartPte[OffsetInPages];

    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else if (AgpRange->Type == MmWriteCombined) {
        NewState = GART_ENTRY_RESERVED_WC;
    } else {
        NewState = GART_ENTRY_RESERVED_CC;
    }

    for (Index = 0;Index < NumberOfPages; Index++) {
        if (Pte[Index].Hard.Valid) {
            Pte[Index].Soft.State = NewState;
		    LastChanged = &Pte[Index];
		} else {
			//
            // This page is not mapped, just skip it.
	        //
		    AGPLOG(AGP_NOISE,
			       ("AgpUnMapMemory - PTE %08lx (%08lx) not mapped\n",
				    Pte,
					Pte[Index].AsUlong));
            ASSERT(Pte[Index].Soft.State == NewState);
		}
    }

    //
    // We have invalidated all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //

    KeInvalidateAllCaches();
    if (LastChanged != NULL) {
        ULONG Temp;
        Temp = *(volatile ULONG *)(&LastChanged->AsUlong);
    }

	DisplayStatus(0x70);
    return(STATUS_SUCCESS);
}


//
// Function Name:  AgpAMDFlushPages()
//
// Description:
//		Flushes specified pages in the GART.
//
// Parameters:
//		AgpContext - Supplies the AGP context.
//		Mdl - Supplies the MDL describing the physical pages to be flushed.
//
// Return:
//		None.
//
NTSTATUS
AgpAMDFlushPages( IN PAGP_AMD_EXTENSION AgpContext,
				  IN PMDL Mdl )
{
	ULONG CacheInvalidate = 1;
	ULONG PTEerrorClear = PTE_ERROR_BIT;

	WriteAMDConfig(AgpHammerSlotID, &CacheInvalidate, GART_CONTROL_OFFSET, sizeof(CacheInvalidate));

	do {	// wait until cache invalidate bit resets
		ReadAMDConfig(AgpHammerSlotID, &CacheInvalidate, GART_CONTROL_OFFSET, sizeof(CacheInvalidate));
		if (CacheInvalidate & PTE_ERROR_BIT)
		{
			AGPLOG(AGP_NOISE,
				  ("AgpAMDFlushPages - PTE Error set\n"));
			WriteAMDConfig(AgpHammerSlotID, &PTEerrorClear, GART_CONTROL_OFFSET, sizeof(PTEerrorClear));
		}

	} while (CacheInvalidate & CACHE_INVALIDATE_BIT);

	DisplayStatus(0x80);

    return STATUS_SUCCESS;
}


//
// Function Name:  AgpInitializeChipset()
//
// Description:
//		Initializes parameters in the Northbridge for AGP.
//
// Parameters:
//		AgpContext - Supplies the AGP context.
//
// Return:
//		None.
//
void
AgpInitializeChipset( IN PAGP_AMD_EXTENSION AgpContext )
{
	ULONG ConfigData;

	// Update GART Directory Base Address Registers
	WriteAMDConfig(AgpLokarSlotID, &AgpContext->GartPhysical.LowPart,
					AMD_GART_POINTER_LOW_OFFSET, sizeof(AgpContext->GartPhysical.LowPart));
	WriteAMDConfig(AgpLokarSlotID, &AgpContext->GartPhysical.HighPart,
					AMD_GART_POINTER_HIGH_OFFSET, sizeof(AgpContext->GartPhysical.HighPart));
	ConfigData = (AgpContext->GartPhysical.LowPart >> 8);
	ConfigData |= (AgpContext->GartPhysical.HighPart << 24);
	WriteAMDConfig(AgpHammerSlotID, &ConfigData, GART_TABLE_OFFSET, sizeof(ConfigData));


	// Enable GART
	ReadAMDConfig(AgpHammerSlotID, &ConfigData, GART_APSIZE_OFFSET, sizeof(ConfigData));
	ConfigData |= GART_ENABLE_BIT;
	WriteAMDConfig(AgpHammerSlotID, &ConfigData, GART_APSIZE_OFFSET, sizeof(ConfigData));
	
}


//
// Function Name:  AgpAMDFindRangeInGart()
//
// Description:
//		Finds a contiguous range in the GART. This routine can
//		search either from the beginning of the GART forwards or
//		the end of the GART backwards.
//
// Parameters:
//		StartPte - Supplies the first GART PTE to search.
//		EndPte - Supplies the last GART PTE to search.
//		Length - Supplies the number of contiguous free entries to search for.
//		SearchBackward - TRUE indicates that the search should begin
//			at EndIndex and search backwards. FALSE indicates that the
//			search should begin at StartIndex and search forwards
//		SearchState - Supplies the PTE state to look for.
//		GartPte - Returns pointer to GART table entry if range is found.
//
// Return:
//		STATUS_SUCCESS if a suitable range is found. 
//		Otherwise STATUS_INSUFFICIENT_RESOURCES if no suitable range exists.
//
NTSTATUS
AgpAMDFindRangeInGart( IN PGART_PTE StartPte,
					   IN PGART_PTE EndPte,
					   IN ULONG Length,
					   IN BOOLEAN SearchBackward,
					   IN ULONG SearchState,
					   OUT PGART_PTE *GartPte )
{
 	PGART_PTE Current, Last;
    LONG Delta;
    ULONG Found;

    PAGED_CODE();

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;

    while (Current != Last) {
        if (Current->Soft.State == SearchState) {
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
				if (SearchBackward) {
					*GartPte = Current;
					return(STATUS_SUCCESS);
				} else {
					*GartPte = Current - Length + 1;
					return(STATUS_SUCCESS);
				}
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

	//
	// A suitable range was not found.
	//
	*GartPte = NULL;
	return(STATUS_INSUFFICIENT_RESOURCES);
}


//
// Function Name:  AgpFindFreeRun()
//
// Description:
//		Finds the first contiguous run of free pages in the specified
//		part of the reserved range.
//
// Parameters:
//		AgpContext - Supplies the AGP context.
//		AgpRange - Supplies the AGP range.
//		NumberOfPages - Supplies the size of the region to be searched for free pages.
//		OffsetInPages - Supplies the start of the region to be searched for free pages.
//		FreePages - Returns the length of the first contiguous run of free pages.
//		FreeOffset - Returns the start of the first contiguous run of free pages.
//
// Return:
//		None.  FreePages == 0 if there are no free pages in the specified range.
//
VOID
AgpFindFreeRun( IN PVOID AgpContext,
				IN PAGP_RANGE AgpRange,
				IN ULONG NumberOfPages,
				IN ULONG OffsetInPages,
				OUT ULONG *FreePages,
				OUT ULONG *FreeOffset )
{
    PGART_PTE Pte;
    ULONG Index;
    
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (Index = 0; Index < NumberOfPages; Index++) {
        if (Pte[Index].Hard.Valid == 0) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = Index + OffsetInPages;
            *FreePages = 0;
            while ((Index<NumberOfPages) && (Pte[Index].Hard.Valid == 0)) {
                *FreePages += 1;
                ++Index;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
    return;

}


//
// Function Name:  AgpGetMappedPages()
//
// Description:
//		Returns the list of physical pages mapped into the specified 
//		range in the GART.
//
// Parameters:
//		AgpContext - Supplies the AGP context.
//		AgpRange - Supplies the AGP range.
//		NumberOfPages - Supplies the number of pages to be returned.
//		OffsetInPages - Supplies the start of the region.
//		Mdl - Returns the list of physical pages mapped in the specified range.
//
// Return:
//		None.
//
VOID
AgpGetMappedPages( IN PVOID AgpContext,
				   IN PAGP_RANGE AgpRange,
				   IN ULONG NumberOfPages,
				   IN ULONG OffsetInPages,
				   OUT PMDL Mdl )
{
    PGART_PTE Pte;
    PPFN_NUMBER Pages;
	ULONG Index;
    
    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PPFN_NUMBER)(Mdl + 1);
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    for (Index = 0; Index < NumberOfPages; Index++) {
        ASSERT(Pte[Index].Hard.Valid == 1);
        Pages[Index] = Pte[Index].Hard.PageLow;
    }

    return;
}


NTSTATUS
AgpSpecialTarget(
    IN IN PAGP_AMD_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context

    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = AgpAMDSetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }


    //
    // Add more tweaks here...
    //

    //
    // Remember Special Target settings so we can reprogram
    // them if the chip is powered off
    //
    AgpContext->SpecialTarget |= DeviceFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
AgpAMDSetRate(
    IN IN PAGP_AMD_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies the AGP context

    AgpRate - Rate to set

    note: this routine assumes that AGP has already been enabled, and that
          whatever rate we've been asked to set is supported by master

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetPciDeviceCapability(AGP_GART_BUS_ID, AgpLokarSlotID, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGPAMDSetRate: AgpLibGetPciDeviceCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGPAMDSetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetPciDeviceCapability(AGP_GART_BUS_ID, AgpLokarSlotID, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPAMDSetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPAMDSetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPStatus.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGPAMDSetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    TargetCap.AGPStatus.Rate = AgpRate;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;
        
    Status = AgpLibSetPciDeviceCapability(AGP_GART_BUS_ID, AgpLokarSlotID, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPAMDSetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        MasterCap.AGPStatus.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGPAMDSetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\inc3\agp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    agp.h

Abstract:

    Header file for common AGP library

Author:

    John Vert (jvert) 10/22/1997

Revision History:

--*/
//
// AGP is a driver, make sure we get the appropriate linkage.
//

#define _NTDRIVER_

#include "ntddk.h"
#include "ntagp.h"

//
// regstr.h uses things of type WORD, which isn't around in kernel mode.
//
#define _IN_KERNEL_
#include "regstr.h"

//
// Handy debugging and logging macros
//

//
// Always turned on for now
//
#if DEVL

#define AGP_ALWAYS   0
#define AGP_CRITICAL 1
#define AGP_WARNING  2
#define AGP_IRPTRACE 3
#define AGP_NOISE    4

#define AGP_DEBUGGING_OKAY()    \
    (KeGetCurrentIrql() < IPI_LEVEL)

#define AGP_ASSERT  \
    if (AGP_DEBUGGING_OKAY()) ASSERT

extern ULONG AgpLogLevel;
extern ULONG AgpStopLevel;
#define AGPLOG(_level_,_x_) if (((_level_) <= AgpLogLevel) && \
                                AGP_DEBUGGING_OKAY()) DbgPrint _x_; \
                            if (((_level_) <= AgpStopLevel) && \
                                AGP_DEBUGGING_OKAY()) { DbgBreakPoint(); }

#else

#define AGPLOG(_level_,_x_)

#endif

//
// Functions provided by AGPLIB for use by chipset-specific code
//

//
// Helper routines for manipulating AGP Capabilities registers
//
typedef
NTSTATUS
(*PAGP_GETSET_CONFIG_SPACE)(
    IN PVOID Context,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
AgpLibGetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN BOOLEAN DoSpecial,
    OUT PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibGetTargetCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibGetExtendedTargetCapability(
    IN PVOID AgpExtension,
    IN EXTENDED_AGP_REGISTER RegSelect,
    OUT PVOID ExtCapReg
    );

NTSTATUS
AgpLibGetMasterDeviceId(
    IN PVOID AgpExtension,
    OUT PULONG DeviceId
    );

NTSTATUS
AgpLibGetMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibGetExtendedMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_ISOCH_STATUS IsochStat
    );

VOID
AgpLibReadAgpTargetConfig(
    IN PVOID AgpExtension,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Size
    );

VOID
AgpLibWriteAgpTargetConfig(
    IN PVOID AgpExtension,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Size
    );

NTSTATUS
AgpLibSetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibSetTargetCapability(
    IN PVOID AgpExtension,
    IN PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibSetExtendedTargetCapability(
    IN PVOID AgpExtension,
    IN EXTENDED_AGP_REGISTER RegSelect,
    IN PVOID ExtCapReg
    );

NTSTATUS
AgpLibSetMasterCapability(
    IN PVOID AgpExtension,
    IN PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibSetExtendedMasterCapability(
    IN PVOID AgpExtension,
    IN PPCI_AGP_ISOCH_COMMAND IsochCmd
    );

PVOID
AgpLibAllocateMappedPhysicalMemory(
   IN PVOID AgpContext, 
   IN ULONG TotalBytes);

VOID
AgpLibFreeMappedPhysicalMemory(
    IN PVOID Addr,
    IN ULONG Length
    );

//
// Functions implemented by the chipset-specific code
//
typedef struct _AGP_RANGE {
    PHYSICAL_ADDRESS MemoryBase;
    ULONG NumberOfPages;
    MEMORY_CACHING_TYPE Type;
    PVOID Context;
    ULONG CommittedPages;
} AGP_RANGE, *PAGP_RANGE;

//
// These flags have been reserved under AGP_FLAG_SPECIAL_RESERVE
// defined in regstr.h
//
//      AGP_FLAG_SPECIAL_RESERVE 0x000F0000
//
#define AGP_FLAG_SET_RATE_1X     0x00010000
#define AGP_FLAG_SET_RATE_2X     0x00020000
#define AGP_FLAG_SET_RATE_4X     0x00040000
#define AGP_FLAG_SET_RATE_8X     0x00080000

#define AGP_FLAG_SET_RATE_SHIFT  0x00000010

NTSTATUS
AgpSpecialTarget(
    IN PVOID AgpContext,
    IN ULONGLONG DeviceFlags
    );

NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    );

NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    );

NTSTATUS
AgpQueryAperture(
    IN PVOID AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *ApertureRequirements
    );

NTSTATUS
AgpSetAperture(
    IN PVOID AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    OUT ULONG NewSizeInPages
    );

VOID
AgpDisableAperture(
    IN PVOID AgpContext
    );

NTSTATUS
AgpReserveMemory(
    IN PVOID AgpContext,
    IN OUT AGP_RANGE *AgpRange
    );

NTSTATUS
AgpReleaseMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange
    );

VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    );

VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    );

NTSTATUS
AgpMapMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

NTSTATUS
AgpUnMapMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

typedef
NTSTATUS
(*PAGP_FLUSH_PAGES)(
    IN PVOID AgpContext,
    IN PMDL Mdl
    );

//
// Globals defined by the chipset-specific code
//
extern ULONG AgpExtensionSize;
extern PAGP_FLUSH_PAGES AgpFlushPages;

//
// AGP Pool tag definitions
//
#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(_type_,_size_) ExAllocatePoolWithTag(_type_,_size_,' PGA')
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\amdagp8x\init8x.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    init8x.c

Abstract:

    This module contains the initialization code for AMDAGP8X.SYS.

Author:

    John Vert (jvert) 10/21/1997

Revision History:

--*/

/*
******************************************************************************
 * Archive File : $Archive: /Drivers/OS/Hammer/AGP/XP/amdagp/Init8x.c $
 *
 * $History: Init8x.c $
 * 
 *  
******************************************************************************
*/

#include "amdagp8x.h"

#define MAX_DEVICES		32

#ifdef DISPLAY
	ULONG	ErrorControl		= 2;
#else
	ULONG	ErrorControl		= 0;
#endif

ULONG 	VendorID		= 0;
ULONG 	DeviceID		= 0;
ULONG	AgpLokarSlotID	= 0;
ULONG	AgpHammerSlotID	= 0;

ULONG_PTR OutPostBase;

ULONG AgpExtensionSize = sizeof(AGP_AMD_EXTENSION);


//
// Function Name:  DisplayStatus()
//
// Description:
//		This routine displays the status value in the Post Display.
//
// Parameter:	
//		StatusValue - Value to display.
//
// Return:	None.
//
void
DisplayStatus( IN UCHAR StatusValue )
{
	UCHAR to80;

	if (ErrorControl) {
		to80 = StatusValue & 0xFF;
		WRITE_PORT_UCHAR((PUCHAR)OutPostBase, to80);
	}
}


//
// Function Name:  FindLokar()
//
// Description:
//		This routine locates which device number is assigned to Lokar.
//
// Parameter:	
//		SlotID - Returned slot ID for Lokar.
//
// Return:	None.
//
void
FindLokar( OUT PULONG SlotID )
{
	PCI_SLOT_NUMBER SlotNum;
	ULONG dev, TargetID;

	SlotNum.u.AsULONG = 0;
	*SlotID = 0;

	for (dev = 0; dev < MAX_DEVICES; dev++)
	{
		SlotNum.u.bits.DeviceNumber = dev;
		ReadAMDConfig(SlotNum.u.AsULONG, &TargetID, 0, sizeof(TargetID));
		if (((TargetID & DEVICEID_MASK) >> 16) == DEVICE_LOKAR)
		{
			*SlotID = SlotNum.u.AsULONG;
            AGPLOG(AGP_NOISE, ("FindLokar - SlotID=%x\n", *SlotID));
			break;
		}
	}

}


//
// Function Name:  FindHammer()
//
// Description:
//		This routine locates which device number is assigned to Hammer.
//
// Parameter:	
//		SlotID - Returned slot ID for Hammer.
//
// Return:	None.
//
void
FindHammer( OUT PULONG SlotID )
{
	PCI_SLOT_NUMBER SlotNum;
	ULONG dev, TargetID;

	SlotNum.u.AsULONG = 0;
	SlotNum.u.bits.FunctionNumber = 3;
	*SlotID = 0;

	for (dev = 0; dev < MAX_DEVICES; dev++)
	{
		SlotNum.u.bits.DeviceNumber = dev;
		ReadAMDConfig(SlotNum.u.AsULONG, &TargetID, 0, sizeof(TargetID));
		if (((TargetID & DEVICEID_MASK) >> 16) == DEVICE_HAMMER)
		{
			*SlotID = SlotNum.u.AsULONG;
            AGPLOG(AGP_NOISE, ("FindHammer - SlotID=%x\n", *SlotID));
			break;
		}
	}

}


//
// Function Name:  AgpInitializeTarget()
//
// Description:
//		Entrypoint for target initialization. This is called first.
//
// Parameters:
//		AgpExtension - Supplies the AGP extension.
//
// Return:
//		STATUS_SUCCESS on success, otherwise STATUS_UNSUCCESSFUL.
//
NTSTATUS
AgpInitializeTarget( IN PVOID AgpExtension )
{
    ULONG TargetId = 0;
	UNICODE_STRING tempString;
	unsigned short tempBuffer[20];
    PAGP_AMD_EXTENSION Extension = AgpExtension;

    //
    // This driver is not MP safe!  If there is more than one processor
    // we simply fail start
    //
    if (KeNumberProcessors > 1) {
        return STATUS_NOT_SUPPORTED;
    }
	//
	// Register OutPostCode port, if specified by ErrorControl
	//
	if (ErrorControl) {
		PHYSICAL_ADDRESS PortAddress;
		PHYSICAL_ADDRESS MappedAddress;
		ULONG MemType = 1;

		PortAddress.LowPart = 0x80;
		PortAddress.HighPart = 0;
		HalTranslateBusAddress(Isa, 0, PortAddress, &MemType, &MappedAddress);
		if (MemType == 0)
			OutPostBase = (ULONG_PTR)MmMapIoSpace(MappedAddress, 1, FALSE);
		else
			OutPostBase = (ULONG_PTR)MappedAddress.LowPart;
	}
    if (ErrorControl == 2)
        AgpLogLevel = AGP_NOISE;	// Log everything

    //
    // Make sure we are really loaded only on AMD Hammer / Lokar
    //
	FindLokar(&AgpLokarSlotID);
	FindHammer(&AgpHammerSlotID);

    ReadAMDConfig(AgpLokarSlotID, &TargetId, 0, sizeof(TargetId));
	VendorID = TargetId & VENDORID_MASK;
	DeviceID = (TargetId & DEVICEID_MASK) >> 16;
    ASSERT(VendorID == VENDOR_AMD);

    if (VendorID != VENDOR_AMD || DeviceID != DEVICE_LOKAR) {
        AGPLOG(AGP_CRITICAL,
               ("AGPAMD - AgpInitializeTarget called for platform %08lx which is not an AMD!\n",
                VendorID));
        return(STATUS_UNSUCCESSFUL);
    }
	
    //
    // Initialize our chipset-specific extension
    //
	Extension->ApertureStart.QuadPart = 0;
	Extension->ApertureLength = 0;
    Extension->Gart = NULL;
    Extension->GartLength = 0;
    Extension->GartPhysical.QuadPart = 0;
    Extension->SpecialTarget = 0;

	DisplayStatus(0x10);
    return(STATUS_SUCCESS);
}


//
// Function Name:  AgpInitializeMaster()
//
// Description:
//		Entrypoint for master initialization. This is called after target
//		initialization and should be used to initialize the AGP
//		capabilities of both master and target.
//
// Parameters:
//		AgpExtension - Supplies the AGP extension.
//		AgpCapabilities - Returns the capabilities of this AGP device.
//
// Return:
//		STATUS_SUCCESS on success, otherwise NTSTATUS.
//
NTSTATUS
AgpInitializeMaster( IN  PVOID AgpExtension,
					 OUT ULONG *AgpCapabilities )
{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    PAGP_AMD_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable = 0;
    ULONG FWEnable = 0;
    ULONG FourGBEnable = 0;
    ULONG AperturePointer;
    ULONG DataRate;
    ULONG IrongateRev = 0;
    BOOLEAN ReverseInit;

#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif
    
    //
    // Indicate that we can map memory through the GART aperture
    //
    *AgpCapabilities = AGP_CAPABILITIES_MAP_PHYSICAL;

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPAMDInitializeDevice - AgpLibGetMasterCapability failed %08lx\n",
			   Status));
		DisplayStatus(0xA0);
        return(Status);
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AGPAMDInitializeDevice - AgpLibGetMasterCapability returned no valid transfer rate\n"));
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = AgpLibGetPciDeviceCapability(AGP_GART_BUS_ID, AgpLokarSlotID, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPAMDInitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n",
			   Status));
		DisplayStatus(0xA1);
        return(Status);
    }


    //
    // Determine the greatest common denominator for data rate.
    //
	DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;
    AGP_ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);
    }

    //
    // Enable SBA if both master and target support it.
    //
	SBAEnable = (TargetCap.AGPStatus.SideBandAddressing & 
				 MasterCap.AGPStatus.SideBandAddressing);

    //
    // Enable FastWrite if both master and target support it.
    //
	FWEnable = (TargetCap.AGPStatus.FastWrite & 
				MasterCap.AGPStatus.FastWrite);

    //
    // Enable 4GB addressing if aperture pointer is 64-bit.
    //
    ReadAMDConfig(AgpLokarSlotID, &AperturePointer, APBASE_OFFSET, sizeof(AperturePointer));
	if (AperturePointer & APBASE_64BIT_MASK)
		FourGBEnable = 1;
    
	//
    // Enable the Master first.
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        MasterCap.AGPCommand.FastWriteEnable = FWEnable;
        MasterCap.AGPCommand.FourGBEnable = FourGBEnable;  
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGPAMDInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
            DisplayStatus(0xA3);
        }else {
            AGPLOG(AGP_NOISE,
                   ("AgpInitializeMaster - DataRate=%d, SBAEnable=%d\n",
                    DataRate,
                    SBAEnable));
        }
    }

    //
    // Now enable the Target.
    //
    TargetCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    TargetCap.AGPCommand.FastWriteEnable = FWEnable;
    TargetCap.AGPCommand.FourGBEnable = FourGBEnable;  
    Status = AgpLibSetPciDeviceCapability(AGP_GART_BUS_ID, AgpLokarSlotID, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPAMDInitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
		DisplayStatus(0xA2);
        return(Status);
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        MasterCap.AGPCommand.FastWriteEnable = FWEnable;
        MasterCap.AGPCommand.FourGBEnable = FourGBEnable;  
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGPAMDInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
            DisplayStatus(0xA3);
        }else {
            AGPLOG(AGP_NOISE,
                   ("AgpInitializeMaster - DataRate=%d, SBAEnable=%d\n",
                    DataRate,
                    SBAEnable));
        }
    }

#ifdef DEBUG2
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    AGP_ASSERT(NT_SUCCESS(Status));
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

    Status = AgpLibGetPciDeviceCapability(AGP_GART_BUS_ID, AgpLokarSlotID, &CurrentCap);
    AGP_ASSERT(NT_SUCCESS(Status));
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

	DisplayStatus(0x20);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\uagp35\uagp35.h ===
/*++

Copyright (2) 2002 Microsoft Corporation

Module Name:

    uagp35.h

Abstract:

    This module contains definitions for the MS AGP v3 Filter Driver

Author:

    Eric F. Nelson (enelson) June 6, 2002

Revision History:

--*/

#ifndef __UAGP35_H__
#define __UAGP35_H__

#define ON  1
#define OFF 0

#define APERTURE_BASE      0x10

#define APERTURE_BASE64_MASK 0x04

//
// Aperture sizes:
//
// bits 11 10  9  8  7  6  5  4  3  2  1  0
// ----------------------------------------
//       1  1  1  1  0  0  1  1  1  1  1  1     4MB
//       1  1  1  1  0  0  1  1  1  1  1  0     8MB
//       1  1  1  1  0  0  1  1  1  1  0  0    16MB
//       1  1  1  1  0  0  1  1  1  0  0  0    32MB
//       1  1  1  1  0  0  1  1  0  0  0  0    64MB
//       1  1  1  1  0  0  1  0  0  0  0  0   128MB
//       1  1  1  1  0  0  0  0  0  0  0  0   256MB
//       1  1  1  0  0  0  0  0  0  0  0  0   512MB
//       1  1  0  0  0  0  0  0  0  0  0  0  1024MB
//       1  0  0  0  0  0  0  0  0  0  0  0  2048MB
//       0  0  0  0  0  0  0  0  0  0  0  0  4096MB
//
typedef enum _AGP3_AP_SIZE {
//    AP_SIZE_4096MB = 0x000, // IO Resource descriptor's size is only 32-bits!
    AP_SIZE_2048MB = 0x800,
    AP_SIZE_1024MB = 0xC00,
    AP_SIZE_512MB  = 0xE00,
    AP_SIZE_256MB  = 0xF00,
    AP_SIZE_128MB  = 0xF20,
    AP_SIZE_64MB   = 0xF30,
    AP_SIZE_32MB   = 0xF38,
    AP_SIZE_16MB   = 0xF3C,
    AP_SIZE_8MB    = 0xF3E,
    AP_SIZE_4MB    = 0xF3F,
} AGP3_AP_SIZE, *PAGP3_AP_SIZE;

#define AP_SIZE_MASK(_x_) ((((_x_) & 0xF00) >> 2) | ((_x_) & 0x3F))
#define AP_BASE_MASK(_z_) (AP_SIZE_MASK((_z_)) << 22)

//
// We'll probably never use 64-bit PTE support,
// but we'll define the corresponding structures,
// and make the code explicit when using 32-bit
// format
//
typedef struct _GART_ENTRY_SW32 {
    ULONG State    : 5;
    ULONG Reserved : 27;
} GART_ENTRY_SW32, *PGART_ENTRY_SW32;

//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000
#define GART_ENTRY_COHERENT	2           //  010

#define GART_ENTRY_WC           4           //  00100
#define GART_ENTRY_UC           8           //  01000
#define GART_ENTRY_CC          16           //  10000

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC
#define GART_ENTRY_RESERVED_CC  GART_ENTRY_CC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_CC     (GART_ENTRY_VALID | GART_ENTRY_COHERENT)

typedef struct _GART_ENTRY_SW64 {
    ULONGLONG State    : 5;
    ULONGLONG Reserved : 59;
} GART_ENTRY_SW64, *PGART_ENTRY_SW64;

typedef struct _GART_ENTRY_HW32 {
    ULONG Valid     :  1;
    ULONG Coherent  :  1;
    ULONG Reserved  :  2;
    ULONG PageHigh  :  8;
    ULONG PageLow   : 20;
} GART_ENTRY_HW32, *PGART_ENTRY_HW32;

#define PAGE_HIGH_SHIFT 20

typedef struct _GART_ENTRY_HW64 {
    ULONGLONG Valid     :  1;
    ULONGLONG Coherent  :  1;
    ULONGLONG Reserved  :  2;
    ULONGLONG PageHigh  :  8;
    ULONGLONG PageLow   : 20;
    ULONGLONG PageHigh2 : 32;
} GART_ENTRY_HW64, *PGART_ENTRY_HW64;

typedef union _GART_PTE32 {
    GART_ENTRY_HW32 Hard;
    GART_ENTRY_SW32 Soft;
    ULONG           AsULONG;
} GART_PTE32, *PGART_PTE32;

typedef union _GART_PTE64 {
    GART_ENTRY_HW64 Hard;
    GART_ENTRY_SW64 Soft;
    ULONGLONG       AsULONGLONG;
} GART_PTE64, *PGART_PTE64;

//
// Define the MS AGP3-specific extension
//
typedef struct _UAGP35_EXTENSION {
    PHYSICAL_ADDRESS ApertureStart;
    PHYSICAL_ADDRESS GartPhysical;
    ULONGLONG        SpecialTarget;
    PGART_PTE32      Gart;
    ULONG            GartLength;
    ULONG            ApertureLength;
    ULONG            DeviceId;
    ULONG            CapabilityId;
    BOOLEAN          GlobalEnable;
    BOOLEAN          FourGBEnable;
} UAGP35_EXTENSION, *PUAGP35_EXTENSION;

//
// These flags are passed via the registry in the special reserve section
// of AGP device flags
//
#define AGP_FLAG_SPECIAL_NO_APERTURE_DISABLE    0x0000000000100000L
#define AGP_FLAG_SPECIAL_VIA_AGP2_RATE_PATCH    0x0000000000200000L

#endif // __UAGP35_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\uagp35\gart.c ===
/*++

Copyright (2) 2002 Microsoft Corporation

Module Name:

    gart.c

Abstract:

    This module contains the Graphics Aperture Redirection Table support
    routines for the MS AGP v3 Filter Driver

Author:

    Eric F. Nelson (enelson) June 6, 2002

Revision History:

--*/

#include "agp.h"
#include "uagp35.h"

NTSTATUS
Uagp35CreateGart(
    IN PUAGP35_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

VOID
Uagp35EnableGTLB(
    IN PUAGP35_EXTENSION AgpContext,
    IN BOOLEAN Enable
    );

NTSTATUS
Uagp35SetRate(
    IN PUAGP35_EXTENSION AgpContext,
    IN ULONG AgpRate
    );

PGART_PTE32
Uagp35FindRangeInGart32(
    IN PVOID StartPte,
    IN PVOID EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpDisableAperture)
#pragma alloc_text(PAGE, AgpQueryAperture)
#pragma alloc_text(PAGE, AgpReserveMemory)
#pragma alloc_text(PAGE, AgpReleaseMemory)
#pragma alloc_text(PAGE, Uagp35CreateGart)
#pragma alloc_text(PAGE, AgpMapMemory)
#pragma alloc_text(PAGE, AgpUnMapMemory)
#pragma alloc_text(PAGE, Uagp35FindRangeInGart32)
#pragma alloc_text(PAGE, AgpFindFreeRun)
#pragma alloc_text(PAGE, AgpGetMappedPages)
#endif

#define Uagp35EnableTB(_x_) Uagp35EnableGTLB((_x_), TRUE)
#define Uagp35DisableTB(_x_) Uagp35EnableGTLB((_x_), FALSE)


NTSTATUS
AgpQueryAperture(
    IN PUAGP35_EXTENSION AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *pApertureRequirements
    )
/*++

Routine Description:

    Queries the current size of the GART aperture, and optionally returns
    the possible GART settings

Arguments:

    AgpContext - Supplies our AGP3 context

    CurrentBase - Returns the current physical address of the GART

    CurrentSizeInPages - Returns the current GART size

    ApertureRequirements - If present, returns the possible GART settings

Return Value:

    STATUS_SUCCESS, or an appropriate error status

--*/
{
    PHYSICAL_ADDRESS ApertureBase;
    PIO_RESOURCE_LIST Requirements;
    ULONG Index;
    ULONG Length;
    USHORT ApSize;
    ULONG AltCount;

    PAGED_CODE();

    //
    // Get the current aperture base and size settings
    //
    if (!AgpContext->FourGBEnable) {
        AgpLibReadAgpTargetConfig(AgpContext,
                                  &ApertureBase.LowPart,
                                  APERTURE_BASE,
                                  sizeof(ApertureBase.LowPart));
        
    } else {
        AgpLibReadAgpTargetConfig(AgpContext,
                                  &ApertureBase,
                                  APERTURE_BASE,
                                  sizeof(ApertureBase));
    }

    AgpLibGetExtendedTargetCapability(AgpContext, ApertureSize, &ApSize);

    ASSERT(ApertureBase.QuadPart != 0);

    CurrentBase->QuadPart =
        ApertureBase.QuadPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Convert APSIZE into the actual size of the aperture
    //
    switch (ApSize) {
        case AP_SIZE_4MB:
            AltCount = 1;
            *CurrentSizeInPages = 4 * (1024 * 1024 / PAGE_SIZE);
            break;
        case AP_SIZE_8MB:
            AltCount = 2;
            *CurrentSizeInPages = 8 * (1024 * 1024 / PAGE_SIZE);
            break;
        case AP_SIZE_16MB:
            AltCount = 3;
            *CurrentSizeInPages = 16 * (1024 * 1024 / PAGE_SIZE);
            break;
        case AP_SIZE_32MB:
            AltCount = 4;
            *CurrentSizeInPages = 32 * (1024 * 1024 / PAGE_SIZE);
            break;
        case AP_SIZE_64MB:
            AltCount = 5;
            *CurrentSizeInPages = 64 * (1024 * 1024 / PAGE_SIZE);
            break;
        case AP_SIZE_128MB:
            AltCount = 6;
            *CurrentSizeInPages = 128 * (1024 * 1024 / PAGE_SIZE);
            break;
        case AP_SIZE_256MB:
            AltCount = 7;
            *CurrentSizeInPages = 256 * (1024 * 1024 / PAGE_SIZE);
            break;
        case AP_SIZE_512MB:
            AltCount = 8;
            *CurrentSizeInPages = 512 * (1024 * 1024 / PAGE_SIZE);
            break;
        case AP_SIZE_1024MB:
            AltCount = 9;
            *CurrentSizeInPages = 1024 * (1024 * 1024 / PAGE_SIZE);
            break;
        case AP_SIZE_2048MB:
            AltCount = 10;
            *CurrentSizeInPages = 2048 * (1024 * 1024 / PAGE_SIZE);
            break;

//
// IO Resource descriptor's size is only 32-bits!
//
//        case AP_SIZE_4096MB:
//            AltCount = 11;
//            *CurrentSizeInPages = 4096 * (1024 * 1024 / PAGE_SIZE);
//            break;

        default:
            AGPLOG(AGP_CRITICAL,
                   ("AgpQueryAperture - Unexpected value %x for ApSize!\n",
                    ApSize));
            ASSERT(FALSE);
            AgpContext->ApertureStart.QuadPart = 0;
            AgpContext->ApertureLength = 0;
            return STATUS_UNSUCCESSFUL;
    }

    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    if (pApertureRequirements != NULL) {

        //
        // Since the BIOS probably describes the desired size, we
        // will only attempt alternates of the same size, or less
        //
        Requirements =
            ExAllocatePoolWithTag(PagedPool,
                                  sizeof(IO_RESOURCE_LIST) +
                                  (AltCount - 1) *
                                  sizeof(IO_RESOURCE_DESCRIPTOR),
                                  'RpgA');
        if (Requirements == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        Requirements->Version = Requirements->Revision = 1;
        Requirements->Count = AltCount;
        Length = AgpContext->ApertureLength;

        for (Index = 0; Index < Requirements->Count; Index++) {
            Requirements->Descriptors[Index].Option = IO_RESOURCE_ALTERNATIVE;
            Requirements->Descriptors[Index].Type = CmResourceTypeMemory;
            Requirements->Descriptors[Index].ShareDisposition =
                CmResourceShareDeviceExclusive;
            Requirements->Descriptors[Index].Flags =
                CM_RESOURCE_MEMORY_READ_WRITE |
                CM_RESOURCE_MEMORY_PREFETCHABLE;
            Requirements->Descriptors[Index].u.Memory.Length = Length;
            Requirements->Descriptors[Index].u.Memory.Alignment = Length;
            Requirements->Descriptors[Index].u.Memory.MinimumAddress.QuadPart =
                0;
            Requirements->Descriptors[Index].u.Memory.MaximumAddress.QuadPart =
                (ULONG)-1;
            Length /= 2;
        }
        *pApertureRequirements = Requirements;
    }

    return STATUS_SUCCESS;
}



NTSTATUS
AgpSetAperture(
    IN PUAGP35_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*++

Routine Description:

    Sets the GART aperture to the supplied settings

Arguments:

    AgpContext - Supplies our AGP3 context

    NewBase - Supplies the new physical memory base for the GART

    NewSizeInPages - Supplies the new size for the GART

Return Value:

    STATUS_SUCCESS, or an appropriate error status

--*/
{
    PCI_AGP_CONTROL AgpCtrl;
    USHORT ApSize;
    PHYSICAL_ADDRESS ApBase;

    //
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) {
        case 4 * (1024 * 1024 / PAGE_SIZE):
            ApSize = AP_SIZE_4MB;
            break;
        case 8 * (1024 * 1024 / PAGE_SIZE):
            ApSize = AP_SIZE_8MB;
            break;
        case 16 * (1024 * 1024 / PAGE_SIZE):
            ApSize = AP_SIZE_16MB;
            break;
        case 32 * (1024 * 1024 / PAGE_SIZE):
            ApSize = AP_SIZE_32MB;
            break;
        case 64 * (1024 * 1024 / PAGE_SIZE):
            ApSize = AP_SIZE_64MB;
            break;
        case 128 * (1024 * 1024 / PAGE_SIZE):
            ApSize = AP_SIZE_128MB;
            break;
        case 256 * (1024 * 1024 / PAGE_SIZE):
            ApSize = AP_SIZE_256MB;
            break;
        case 512 * (1024 * 1024 / PAGE_SIZE):
            ApSize = AP_SIZE_512MB;
            break;
        case 1024 * (1024 * 1024 / PAGE_SIZE):
            ApSize = AP_SIZE_1024MB;
            break;
        case 2048 * (1024 * 1024 / PAGE_SIZE):
            ApSize = AP_SIZE_2048MB;
            break;

//
// IO Resource descriptor's size is only 32-bits!
//
//        case AP_SIZE_4096MB:
//            AltCount = 11;
//            *CurrentSizeInPages = 4096 * (1024 * 1024 / PAGE_SIZE);
//            break;
//        case 4096 * (1024 * 1024 / PAGE_SIZE):
//            ApSize = AP_SIZE_4096MB;
//            break;

        default:
            AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages "
                    "specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
            ASSERT(FALSE);
            return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary
    //
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);
    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART "
                "aperture of %lx pages\n",
                NewBase.QuadPart,
                NewSizeInPages));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }
    
    //
    // Need to reset the hardware to match the supplied settings
    //
    // If the aperture is enabled, disable it, write the new settings,
    // then reenable the aperture
    //
    //
    // Disable the aperture
    //
    AgpLibGetExtendedTargetCapability(AgpContext, AgpControl, &AgpCtrl);

    if (AgpCtrl.AP_Enable == ON) {
        AgpCtrl.AP_Enable = OFF;

        if (!(AgpContext->SpecialTarget &
              AGP_FLAG_SPECIAL_NO_APERTURE_DISABLE)) {
            AgpLibSetExtendedTargetCapability(AgpContext,
                                              AgpControl,
                                              &AgpCtrl);
        } else {
            AGPLOG(AGP_WARNING,
                   ("UAGP35MasterInit: AGP_FLAG_SPECIAL_NO_APERTURE_DISABLE\n")
                   );
        }
    }

    //
    // Write APSIZE first, as this will enable the correct bits in APBASE
    // that need to be written next
    //
    AgpLibSetExtendedTargetCapability(AgpContext, ApertureSize, &ApSize);

    //
    // Now we can update APBASE
    //
    ApBase.QuadPart = NewBase.LowPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    if (AgpContext->CapabilityId != PCI_CAPABILITY_ID_AGP_TARGET) {
        if (!AgpContext->FourGBEnable) {
            ASSERT(ApBase.HighPart == 0);
            
            AgpLibWriteAgpTargetConfig(AgpContext,
                                       &ApBase.LowPart,
                                       APERTURE_BASE,
                                       sizeof(ApBase.LowPart));
            
        } else {
            AgpLibWriteAgpTargetConfig(AgpContext,
                                       &ApBase,
                                       APERTURE_BASE,
                                       sizeof(ApBase));       
        }
    }

#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        PHYSICAL_ADDRESS DbgBase;
        USHORT DbgSize;
        ULONGLONG ApBaseMask;

        ApBaseMask = AP_BASE_MASK(ApSize);

        AgpLibGetExtendedTargetCapability(AgpContext, ApertureSize, &DbgSize);
        
        if (!AgpContext->FourGBEnable) {
            DbgBase.HighPart = 0;
            AgpLibReadAgpTargetConfig(AgpContext,
                                      &DbgBase.LowPart,
                                      APERTURE_BASE,
                                      sizeof(DbgBase.LowPart));

        } else {
            AgpLibReadAgpTargetConfig(AgpContext,
                                      &DbgBase,
                                      APERTURE_BASE,
                                      sizeof(DbgBase));
        }

        ASSERT(DbgSize == ApSize);

        //
        // If this fires, it means our BAR has moved, might be good to track
        // this during AGP3 debug
        //
        ASSERT((DbgBase.QuadPart & ApBaseMask) == ApBase.QuadPart);
    }
#endif

    //
    // Now enable the aperture if it was enabled before
    //
    if (AgpContext->GlobalEnable) {
        AgpLibGetExtendedTargetCapability(AgpContext,
                                          AgpControl,
                                          &AgpCtrl);
        
        ASSERT((AgpCtrl.AP_Enable == OFF) ||
               (AgpContext->SpecialTarget &
                AGP_FLAG_SPECIAL_NO_APERTURE_DISABLE));
        
        AgpCtrl.AP_Enable = ON;
        AgpLibSetExtendedTargetCapability(AgpContext,
                                          AgpControl,
                                          &AgpCtrl);
    }

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

    //
    // Enable the TB in case we are resuming from S3 or S4
    //
    Uagp35EnableTB(AgpContext);

    //
    // If the GART has been allocated, rewrite the ATTBASE
    //
    if (AgpContext->Gart != NULL) {
        AgpLibSetExtendedTargetCapability(AgpContext,
                                          GartLow,
                                          &AgpContext->GartPhysical.LowPart);

#ifdef _WIN64
        AgpLibSetExtendedTargetCapability(AgpContext,
                                          GartHigh,
                                          &AgpContext->GartPhysical.HighPart);
#endif
    }

    return STATUS_SUCCESS;
}



VOID
AgpDisableAperture(
    IN PUAGP35_EXTENSION AgpContext
    )
/*++

Routine Description:

    Disables the GART aperture so that this resource is available
    for other devices

Arguments:

    AgpContext - Supplies our AGP3 context

Return Value:

    None

--*/

{
    PCI_AGP_CONTROL AgpCtrl;

    //
    // Disable the aperture
    //
    AgpLibGetExtendedTargetCapability(AgpContext,
                                      AgpControl,
                                      &AgpCtrl);

    if (AgpCtrl.AP_Enable == ON) {
        AgpCtrl.AP_Enable = OFF;
        
        AgpLibSetExtendedTargetCapability(AgpContext,
                                          AgpControl,
                                          &AgpCtrl);
    }
    AgpContext->GlobalEnable = FALSE;

    //
    // Nuke the Gart!  (It's meaningless now...)
    //
    if (AgpContext->Gart != NULL) {
        MmFreeContiguousMemory(AgpContext->Gart);
        AgpContext->Gart = NULL;
        AgpContext->GartLength = 0;
    }
}



NTSTATUS
AgpReserveMemory(
    IN PUAGP35_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*++

Routine Description:

    Reserves a range of memory in the GART

Arguments:

    AgpContext - Supplies our AGP3 Context

    Range - Supplies the AGP_RANGE structure (AGPLIB will have filled
            in NumberOfPages and Type, and this routine will fill in
            MemoryBase and Context)

Return Value:

    STATUS_SUCCESS, or an appropriate error status

--*/
{
    ULONG Index;
    ULONG NewState;
    NTSTATUS Status;
    PGART_PTE32 FoundRange;
    BOOLEAN Backwards;

    PAGED_CODE();

    ASSERT((Range->Type == MmNonCached) || (Range->Type == MmWriteCombined));

    if (Range->NumberOfPages > (AgpContext->ApertureLength / PAGE_SIZE)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);

        Status = Uagp35CreateGart(AgpContext, Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("UAGP35CreateGart failed %08lx to create GART of size "
                    "%lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return Status;
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries to
    // satisfy the request, requests for uncached memory will scan from high
    // addresses to low addresses, requests for write-combined memory will
    // scan from low addresses to high addresses, we will use a first-fit
    // algorithm to try and keep the allocations
    // packed and contiguous
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
    FoundRange =
        Uagp35FindRangeInGart32(&AgpContext->Gart[0],
                                &AgpContext->Gart[(AgpContext->GartLength /
                                                   sizeof(GART_PTE32)) - 1],
                                Range->NumberOfPages,
                                Backwards,
                                GART_ENTRY_FREE);
    if (FoundRange == NULL) {

        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory: Could not find %d contiguous free pages "
                "of type %d in GART at %08lx\n",
                Range->NumberOfPages,
                Range->Type,
                AgpContext->Gart));

        //
        //  This is where we could try and grow the GART
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory: reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    switch (Range->Type) {
        case MmNonCached:
            NewState = GART_ENTRY_RESERVED_UC;
            break;
            
        case MmWriteCombined:
            NewState = GART_ENTRY_RESERVED_WC;
            break;
            
        default:

            //
            // Unknown cache type, default to HW coherent cached
            //
            AGPLOG(AGP_NOISE,
                   ("AgpReserveMemory: Unknown cache type %d\n",
                    Range->Type));

        case MmHardwareCoherentCached:
            NewState = GART_ENTRY_RESERVED_CC;
    }

    for (Index = 0; Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);

        FoundRange[Index].AsULONG = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart +
        (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory: reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.LowPart));

    return STATUS_SUCCESS;
}



NTSTATUS
AgpReleaseMemory(
    IN PUAGP35_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*++

Routine Description:

    Releases memory previously reserved with AgpReserveMemory

Arguments:

    AgpContext - Supplies our AGP3 context

    AgpRange - Supplies the range to be released

Return Value:

    STATUS_SUCCESS, or an appropriate error status    

--*/
{
    PGART_PTE32 Pte;
    ULONG Start;

    PAGED_CODE();

    //
    // Go through and free all the PTEs, none of these should still
    // be valid at this point
    //
    for (Pte = Range->Context;
         Pte < ((PGART_PTE32)Range->Context + Range->NumberOfPages);
         Pte++) {

        switch (Range->Type) {
            case MmNonCached:
                ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
                break;
            
            case MmWriteCombined:
                ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
                break;
                
            default:
                
                //
                // Unknown cache type, default to HW coherent cached
                //
                AGPLOG(AGP_NOISE,
                       ("AgpReleaseMemory: Unknown cache type %d\n",
                        Range->Type));
                
            case MmHardwareCoherentCached:
                ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_CC);
        }

        Pte->Soft.State = GART_ENTRY_FREE;
    }

    Range->MemoryBase.QuadPart = 0;

    return STATUS_SUCCESS;
}



NTSTATUS
Uagp35CreateGart(
    IN PUAGP35_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*++

Routine Description:

    Allocates and initializes an empty GART, the current implementation
    attempts to allocate the entire GART on the first reserve

Arguments:

    AgpContext - Supplies our AGP3 context

    MinimumPages - Supplies the minimum size (in pages) of the GART to be
                   created

Return Value:

    STATUS_SUCCESS, or an appropriate error status

--*/
{
    PGART_PTE32 Gart;
    ULONG GartLength;
    PHYSICAL_ADDRESS HighestAcceptable;
    PHYSICAL_ADDRESS LowestAcceptable;
    PHYSICAL_ADDRESS BoundaryMultiple;
    PHYSICAL_ADDRESS GartPhysical;
    ULONG Index;

    PAGED_CODE();

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture
    //
    LowestAcceptable.QuadPart = 0;
    BoundaryMultiple.QuadPart = 0;

#ifdef _WIN64
    HighestAcceptable.QuadPart = (ULONGLONG)-1;
#else
    HighestAcceptable.QuadPart = (ULONG)-1;
#endif

    GartLength =
        BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE32);

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength,
                                                  LowestAcceptable,
                                                  HighestAcceptable,
                                                  BoundaryMultiple,
                                                  MmNonCached);

    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("UAGP35CreateGart: MmAllocateContiguousMemorySpecifyCache %lx "
                "failed\n",
                GartLength));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE - 1)) == 0);

    //
    // Get the physical address
    //
    GartPhysical = MmGetPhysicalAddress(Gart);
    AGPLOG(AGP_NOISE,
           ("UAGP35CreateGart: GART of length %lx created at VA %08lx, "
            "PA %08lx\n",
            GartLength,
            Gart,
            GartPhysical.LowPart));
    ASSERT(GartPhysical.HighPart == 0);
    ASSERT((GartPhysical.LowPart & (PAGE_SIZE - 1)) == 0);

    //
    // Initialize all the PTEs to free
    //
    for (Index = 0; Index < (GartLength / sizeof(GART_PTE32)); Index++) {
        Gart[Index].Soft.State = GART_ENTRY_FREE;
    }

    AgpLibSetExtendedTargetCapability(AgpContext,
                                      GartLow,
                                      &GartPhysical.LowPart);

#ifdef _WIN64
    AgpLibSetExtendedTargetCapability(AgpContext,
                                      GartHigh,
                                      &GartPhysical.HighPart);
#endif

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
    AgpContext->GartPhysical = GartPhysical;

    return STATUS_SUCCESS;
}



NTSTATUS
AgpMapMemory(
    IN PUAGP35_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Maps physical memory into the GART somewhere in the specified range

Arguments:

    AgpContext - Supplies our AGP3 context

    Range - Supplies the AGP range that the memory should be mapped into

    Mdl - Supplies the MDL describing the physical pages to be mapped

    OffsetInPages - Supplies the offset into the reserved range where the 
                    mapping should begin

    MemoryBase - Returns the physical memory in the aperture where the pages
                 were mapped

Return Value:

    STATUS_SUCCESS, or an appropriate error status    

--*/
{
    ULONG PageCount;
    PGART_PTE32 Pte;
    PGART_PTE32 StartPte;
    ULONG Index;
    ULONG TargetState;
    PPFN_NUMBER Page;
    BOOLEAN Backwards;
    GART_PTE32 NewPte;
    PCI_AGP_CONTROL AgpCtrl;

    PAGED_CODE();

    ASSERT(Mdl->Next == NULL);

    NewPte.AsULONG = 0;
    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    switch (Range->Type) {
        case MmNonCached:
            TargetState = GART_ENTRY_RESERVED_UC;
            NewPte.Soft.State = GART_ENTRY_VALID_UC;
            break;
            
        case MmWriteCombined:
            TargetState = GART_ENTRY_RESERVED_WC;
            NewPte.Soft.State = GART_ENTRY_VALID_WC;
            break;
            
        default:

            //
            // Unknown cache type, default to HW coherent cached
            //
            AGPLOG(AGP_NOISE,
                   ("AgpMapMemory: Unknown cache type %d\n",
                    Range->Type));

        case MmHardwareCoherentCached:
            TargetState = GART_ENTRY_RESERVED_CC;
            NewPte.Soft.State = GART_ENTRY_VALID_CC;
    }

    Pte = StartPte + OffsetInPages;

    //
    // We have a suitable range, now fill it in with the supplied MDL
    //
    ASSERT(Pte >= StartPte);
    ASSERT((Pte + PageCount) <= (StartPte + Range->NumberOfPages));
    Page = (PPFN_NUMBER)(Mdl + 1);

    //
    // Disable the TB as per the (440?) spec, this is probably unnecessary
    // as there should be no valid entries in this range, and there should
    // be no invalid entries still in the TB, so flushing the TB seems
    // a little gratuitous but that's what the old spec said to do
    //
    Uagp35DisableTB(AgpContext);

    for (Index = 0; Index < PageCount; Index++) {
        ASSERT(Pte[Index].Soft.State == TargetState);

#ifndef _WIN64
        NewPte.Hard.PageLow = *Page++;
#else
        NewPte.Hard.PageLow = (ULONG)*Page;
        NewPte.Hard.PageHigh = (ULONG)(*Page++ >> PAGE_HIGH_SHIFT);
#endif
        Pte[Index].AsULONG = NewPte.AsULONG;
        ASSERT(Pte[Index].Hard.Valid == ON);
    }

    //
    // We have filled in all the PTEs, read back the last one we wrote
    // in order to flush the write buffers
    //
    NewPte.AsULONG = *(volatile ULONG *)&Pte[PageCount - 1].AsULONG;

    //
    // Re-enable the TB
    //
    Uagp35EnableTB(AgpContext);

    //
    // If we have not yet gotten around to enabling the GART aperture,
    // do it now
    //
    if (!AgpContext->GlobalEnable) {
        AGPLOG(AGP_NOISE, ("AgpMapMemory: Enabling global aperture access\n"));

        AgpLibGetExtendedTargetCapability(AgpContext, AgpControl, &AgpCtrl);

        AgpCtrl.AP_Enable = ON;
        
        AgpLibSetExtendedTargetCapability(AgpContext,
                                          AgpControl,
                                          &AgpCtrl);
        AgpContext->GlobalEnable = TRUE;
    }

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart +
        ((Pte - StartPte) * PAGE_SIZE);

    return STATUS_SUCCESS;
}



NTSTATUS
AgpUnMapMemory(
    IN PUAGP35_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Unmaps previously mapped memory in the GART

Arguments:

    AgpContext - Supplies our AGP3 context

    AgpRange - Supplies the AGP range that the memory should be freed from

    NumberOfPages - Supplies the number of pages in the range to be freed

    OffsetInPages - Supplies the offset into the range where the freeing
                    should begin

Return Value:

    STATUS_SUCCESS, or an appropriate error status

--*/
{
    ULONG Index;
    PGART_PTE32 Pte;
    PGART_PTE32 LastChanged = NULL;
    PGART_PTE32 StartPte;
    ULONG NewState;

    PAGED_CODE();

    ASSERT(OffsetInPages + NumberOfPages <= AgpRange->NumberOfPages);

    StartPte = AgpRange->Context;
    Pte = &StartPte[OffsetInPages];

    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else if (AgpRange->Type == MmWriteCombined) {
        NewState = GART_ENTRY_RESERVED_WC;
    } else {
        NewState = GART_ENTRY_RESERVED_CC;
    }

    //
    // Disable the TB to flush it
    //
    Uagp35DisableTB(AgpContext);
    for (Index = 0; Index < NumberOfPages; Index++) {
        if (Pte[Index].Hard.Valid) {
            Pte[Index].Soft.State = NewState;
            LastChanged = &Pte[Index];
        
        } else {
        
            //
            // This page is not mapped, just skip it
            //
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory: PTE %08lx (%08lx) at offset %d not "
                    "mapped\n",
                    &Pte[Index],
                    Pte[Index].AsULONG,
                    Index));
            ASSERT(Pte[Index].Soft.State == NewState);
        }
    }

    //
    // We have invalidated all the PTEs, read back the last one we wrote
    // in order to flush the write buffers
    //
    if (LastChanged != NULL) {
        ULONG FlushWB;

        FlushWB = *(volatile ULONG *)&LastChanged->AsULONG;
    }

    //
    // Reenable the TB
    //
    Uagp35EnableTB(AgpContext);

    return STATUS_SUCCESS;
}



PGART_PTE32
Uagp35FindRangeInGart32(
    IN PGART_PTE32 StartPte,
    IN PGART_PTE32 EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in a 32-bit PTE format GART, this
    routine can search either from the beginning of the GART
    forwards or the end of the GART backwards

Arguments:

    StartIndex - Supplies the first GART PTE to search

    EndPte - Supplies the last GART PTE to search (inclusive)

    Length - Supplies the number of contiguous free entries
             to search for

    SearchBackward - TRUE indicates that the search should begin
                     at EndPte and search backwards, FALSE indicates
                     that the search should begin at StartPte and
                     search forwards

    SearchState - Supplies the PTE state to look for

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found, and NULL if no suitable range exists

--*/
{
    PGART_PTE32 Current;
    PGART_PTE32 Last;
    LONG Delta;
    ULONG Found;
    PGART_PTE32 Candidate;

    PAGED_CODE();

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte - 1;
        Delta = -1;
    
    } else {
        Current = StartPte;
        Last = EndPte + 1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {

        if (Current->Soft.State == SearchState) {

            if (++Found == Length) {

                //
                // A suitable range was found, return it
                //
                if (SearchBackward) {
                    return Current;

                } else {
                    return(Current - Length + 1);
                }
            }

        } else {
            Found = 0;
        }
        Current += Delta;
    }

    //
    // A suitable range was not found
    //
    return NULL;
}



VOID
Uagp35EnableGTLB(
    IN PUAGP35_EXTENSION AgpContext,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    Enables or disables the GTLB by setting or clearing the GTLB_Enable bit
    in the AGPCTRL register

Arguments:

    AgpContext - Supplies our AGP3 context

    Enable - TRUE, GTLB_Enable is set to ON
             FALSE, GTLB_Enable is set to OFF

Return Value:

    None

--*/
{
    PCI_AGP_CONTROL AgpCtrl;

    AgpLibGetExtendedTargetCapability(AgpContext, AgpControl, &AgpCtrl);

    AgpCtrl.GTLB_Enable = (Enable) ? ON: OFF;
    
    AgpLibSetExtendedTargetCapability(AgpContext, AgpControl, &AgpCtrl);
}



VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range

Arguments:

    AgpContext - Supplies our AGP3 context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free
                    pages

    OffsetInPages - Supplies the start of the region to be searched for free
                    pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None

--*/
{
    PGART_PTE32 Pte;
    ULONG Index;
    
    Pte = (PGART_PTE32)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (Index = 0; Index < NumberOfPages; Index++) {

        if (Pte[Index].Hard.Valid == OFF) {

            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = Index + OffsetInPages;
            *FreePages = 0;
            while ((Index < NumberOfPages) && (Pte[Index].Hard.Valid == OFF)) {
                *FreePages += 1;
                ++Index;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
}



VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified 
    range in the GART

Arguments:

    AgpContext - Supplies our AGP3 context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region 

    Mdl - Returns the list of physical pages mapped in the specified range

Return Value:

    None

--*/
{
    PGART_PTE32 Pte;
    ULONG Index;
    PULONG Pages;
    
    ASSERT((NumberOfPages * PAGE_SIZE) == Mdl->ByteCount);

    Pages = (PULONG)(Mdl + 1);
    Pte = (PGART_PTE32)(AgpRange->Context) + OffsetInPages;

    for (Index = 0; Index < NumberOfPages; Index++) {
        ASSERT(Pte[Index].Hard.Valid == ON);
        Pages[Index] = Pte[Index].Hard.PageLow;
    }
}



NTSTATUS
AgpSpecialTarget(
    IN PUAGP35_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context
 
    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = Uagp35SetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Add more tweaks here...
    //

    AgpContext->SpecialTarget |= DeviceFlags;

    return Status;
}



NTSTATUS
Uagp35SetRate(
    IN PUAGP35_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies our AGP3 context
 
    AgpRate - Rate to set

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetTargetCapability(AgpContext, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("UAGP35SetRate: AgpLibGetTargetCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("UAGP35SetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Map AGP3 mode rates (4X/8X) into AGP2 rate bits, checking one should
    // be good enough, so we'll just ASSERT for busted video cards
    //
    if (TargetCap.AGPStatus.Agp3Mode == ON) {
        ASSERT(MasterCap.AGPStatus.Agp3Mode == ON);

        if ((AgpRate != PCI_AGP_RATE_4X) && (AgpRate != 8)) {
            return STATUS_INVALID_PARAMETER;
        }

        AgpRate >>= 2;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetTargetCapability(AgpContext, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("UAGP35SetRate: AgpLibSetTargetCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("UAGP35SetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    MasterCap.AGPCommand.Rate = AgpRate;
    TargetCap.AGPCommand.Rate = AgpRate;
    MasterCap.AGPCommand.AGPEnable = MasterEnable;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;

    //
    // Patch rate for early rev VIA 8X silicon errata
    //
    if ((AgpContext->SpecialTarget & AGP_FLAG_SPECIAL_VIA_AGP2_RATE_PATCH) &&
        (TargetCap.AGPStatus.Agp3Mode == OFF)) {
        switch (AgpRate) {
            case PCI_AGP_RATE_1X:
            case PCI_AGP_RATE_2X:
                MasterCap.AGPCommand.Rate = PCI_AGP_RATE_1X;
                TargetCap.AGPCommand.Rate = PCI_AGP_RATE_4X;
                break;
            case PCI_AGP_RATE_4X:
                MasterCap.AGPCommand.Rate = PCI_AGP_RATE_4X;
                TargetCap.AGPCommand.Rate = PCI_AGP_RATE_1X;
        }
        AGPLOG(AGP_WARNING,
               ("UAGP35SetRate: AGP_FLAG_SPECIAL_VIA_AGP2_RATE_PATCH\n"));
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("UAGP35SetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
            return Status;
        }
    }

    Status = AgpLibSetTargetCapability(AgpContext, &TargetCap);    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("UAGP35SetRate: AgpLibSetTargetCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("UAGP35SetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\viaagp\gart.c ===
/*++

Copyright (c) 1998 VIA Technologies, Inc. and  Microsoft Corporation

Module Name:

    gart.c

Abstract:

    Routines for querying and setting the VIA VT82C597 ... GART aperture


Revision History:

--*/
#include "viaagp.h"

//
// Local function prototypes
//
NTSTATUS
AgpVIACreateGart(
    IN PAGPVIA_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

NTSTATUS
AgpVIASetRate(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

PGART_PTE
AgpVIAFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

VOID
AgpVIAFlushPageTLB(
    IN PAGPVIA_EXTENSION AgpContext
    );

VOID
AgpVIAFlushData(
    IN PAGPVIA_EXTENSION AgpContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpDisableAperture)
#pragma alloc_text(PAGE, AgpQueryAperture)
#pragma alloc_text(PAGE, AgpVIAFlushData)
#pragma alloc_text(PAGE, AgpVIAFlushPageTLB)
#pragma alloc_text(PAGE, AgpMapMemory)
#pragma alloc_text(PAGE, AgpUnMapMemory)
#pragma alloc_text(PAGE, AgpReserveMemory)
#pragma alloc_text(PAGE, AgpReleaseMemory)
#pragma alloc_text(PAGE, AgpVIACreateGart)
#pragma alloc_text(PAGE, AgpVIAFindRangeInGart)
#pragma alloc_text(PAGE, AgpFindFreeRun)
#pragma alloc_text(PAGE, AgpGetMappedPages)
#endif

#define VIA_FIRST_AVAILABLE_PTE 0


NTSTATUS
AgpQueryAperture(
    IN PAGPVIA_EXTENSION AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *ApertureRequirements
    )
/*++

Routine Description:

    Queries the current size of the GART aperture. Optionally returns
    the possible GART settings.

Arguments:

    AgpContext - Supplies the AGP context.

    CurrentBase - Returns the current physical address of the GART.

    CurrentSizeInPages - Returns the current GART size.

    ApertureRequirements - if present, returns the possible GART settings

Return Value:

    NTSTATUS

--*/

{
    ULONG GaBase;
    UCHAR GaSize;
    PIO_RESOURCE_LIST Requirements;
    ULONG i;
    ULONG Length;

    PAGED_CODE();

    //
    // Get the current GABASE and GASIZE settings
    //
    ReadVIAConfig(&GaBase, GABASE_OFFSET, sizeof(GaBase));
    ReadVIAConfig(&GaSize, GASIZE_OFFSET, sizeof(GaSize));

    ASSERT(GaBase != 0);
    CurrentBase->QuadPart = GaBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Convert APSIZE into the actual size of the aperture
    //
    switch (GaSize) {
        case GA_SIZE_1MB:
            *CurrentSizeInPages = (1 * 1024*1024) / PAGE_SIZE;
            break;
        case GA_SIZE_2MB:
            *CurrentSizeInPages = (2 * 1024*1024) / PAGE_SIZE;
            break;
        case GA_SIZE_4MB:
            *CurrentSizeInPages = (4 * 1024*1024) / PAGE_SIZE;
            break;
        case GA_SIZE_8MB:
            *CurrentSizeInPages = 8 * (1024*1024 / PAGE_SIZE);
            break;
        case GA_SIZE_16MB:
            *CurrentSizeInPages = 16 * (1024*1024 / PAGE_SIZE);
            break;
        case GA_SIZE_32MB:
            *CurrentSizeInPages = 32 * (1024*1024 / PAGE_SIZE);
            break;
        case GA_SIZE_64MB:
            *CurrentSizeInPages = 64 * (1024*1024 / PAGE_SIZE);
            break;
        case GA_SIZE_128MB:
            *CurrentSizeInPages = 128 * (1024*1024 / PAGE_SIZE);
            break;
        case GA_SIZE_256MB:
            *CurrentSizeInPages = 256 * (1024*1024 / PAGE_SIZE);
            break;

        default:
            AGPLOG(AGP_CRITICAL,
                   ("VIAAGP - AgpQueryAperture - Unexpected value %x for GaSize!\n",
                    GaSize));
            ASSERT(FALSE);
            AgpContext->ApertureStart.QuadPart = 0;
            AgpContext->ApertureLength = 0;
            return(STATUS_UNSUCCESSFUL);
    }

    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    if (ApertureRequirements != NULL) {

        //
        // VIA supports 9 different aperture sizes, all must be
        // naturally aligned. Start with the largest aperture and
        // work downwards so that we get the biggest possible aperture.
        //
        Requirements = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(IO_RESOURCE_LIST) + (GA_SIZE_COUNT-1)*sizeof(IO_RESOURCE_DESCRIPTOR),
                                             'RpgA');

        if (Requirements == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        Requirements->Version = Requirements->Revision = 1;
        Requirements->Count = GA_SIZE_COUNT;
        Length = GA_MAX_SIZE;
        for (i=0; i<GA_SIZE_COUNT; i++) {
            Requirements->Descriptors[i].Option = IO_RESOURCE_ALTERNATIVE;
            Requirements->Descriptors[i].Type = CmResourceTypeMemory;
            Requirements->Descriptors[i].ShareDisposition = CmResourceShareDeviceExclusive;
            Requirements->Descriptors[i].Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;

            Requirements->Descriptors[i].u.Memory.Length = Length;
            Requirements->Descriptors[i].u.Memory.Alignment = Length;
            Requirements->Descriptors[i].u.Memory.MinimumAddress.QuadPart = 0;
            Requirements->Descriptors[i].u.Memory.MaximumAddress.QuadPart = (ULONG)-1;

            Length = Length/2;
        }
        *ApertureRequirements = Requirements;
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetAperture(
    IN PAGPVIA_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*++

Routine Description:

    Sets the GART aperture to the supplied settings

Arguments:

    AgpContext - Supplies the AGP context

    NewBase - Supplies the new physical memory base for the GART.

    NewSizeInPages - Supplies the new size for the GART

Return Value:

    NTSTATUS

--*/

{
    VIA_GATT_BASE       GATTBase;
    UCHAR GaSize;
    ULONG GaBase;

    //
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) {
        case 1 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_1MB;
            break;
        case 2 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_2MB;
            break;
        case 4 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_4MB;
            break;
        case 8 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_8MB;
            break;
        case 16 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_16MB;
            break;
        case 32 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_32MB;
            break;
        case 64 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_64MB;
            break;
        case 128 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_128MB;
            break;
        case 256 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_256MB;
            break;
        default:
            AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
            ASSERT(FALSE);
            return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary.
    //
    ASSERT(NewBase.HighPart == 0);
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);
    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART aperture of %lx pages\n",
               NewBase.QuadPart,
               NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }

    //
    // Need to reset the hardware to match the supplied settings
    //
    // If the aperture is enabled, disable it, write the new settings, then
    // reenable the aperture
    //
    ViaApertureEnable(OFF);

    //
    // Write GASIZE first, as this will enable the correct bits in GABASE that
    // need to be written next.
    //
    WriteVIAConfig(&GaSize, GASIZE_OFFSET, sizeof(GaSize));

    //
    // While the aperture base address is changed, 88[1] must be set as 1,
    // otherwise the high aperture address will not change.
    //
    ViaGartEnable(ON);

    //
    // Now we can update GABASE
    //
    GaBase = NewBase.LowPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    WriteVIAConfig(&GaBase, GABASE_OFFSET, sizeof(GaBase));

#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        ULONG DbgBase;
        UCHAR DbgSize;

        ReadVIAConfig(&DbgSize, GASIZE_OFFSET, sizeof(GaSize));
        ReadVIAConfig(&DbgBase, GABASE_OFFSET, sizeof(GaBase));
        ASSERT(DbgSize == GaSize);
        ASSERT((DbgBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK) == GaBase);  
    }
#endif

    //
    // Now enable the aperture if it was enabled before
    //
    // EFNfix:  Apparently code was added (above) which indiscriminantly
    //          enables aperture, so we must turn it off if !GlobalEnable
    //
    if (AgpContext->GlobalEnable == FALSE) {
        ViaApertureEnable(OFF);
    } else {
        ViaApertureEnable(ON);
    }

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

    //
    // Enable the TB in case we are resuming from S3 or S4
    //

    //
    // If the GART has been allocated, rewrite the GARTBASE
    //
    if (AgpContext->Gart != NULL) {
        ULONG uTmpPhysAddr;

        ReadVIAConfig(&uTmpPhysAddr, GATTBASE_OFFSET, sizeof(uTmpPhysAddr));
        uTmpPhysAddr = (AgpContext->GartPhysical.LowPart & 0xFFFFF000) |
            (uTmpPhysAddr & 0x00000FFF);
        WriteVIAConfig(&uTmpPhysAddr, GATTBASE_OFFSET, sizeof(uTmpPhysAddr));
    }

    return(STATUS_SUCCESS);
}


VOID
AgpDisableAperture(
    IN PAGPVIA_EXTENSION AgpContext
    )
/*++

Routine Description:

    Disables the GART aperture so that this resource is available
    for other devices

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None - this routine must always succeed.

--*/

{
    //
    // Disable the aperture
    //
    ViaApertureEnable(OFF);
    
    AgpContext->GlobalEnable = FALSE;

    //
    // Nuke the Gart!  (It's meaningless now...)
    //
    if (AgpContext->Gart != NULL) {
        MmFreeContiguousMemory(AgpContext->Gart);
        AgpContext->Gart = NULL;
        AgpContext->GartLength = 0;
    }
}



NTSTATUS
AgpReserveMemory(
    IN PAGPVIA_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*++

Routine Description:

    Reserves a range of memory in the GART.

Arguments:

    AgpContext - Supplies the AGP Context

    Range - Supplies the AGP_RANGE structure. AGPLIB
        will have filled in NumberOfPages and Type. This
        routine will fill in MemoryBase and Context.

Return Value:

    NTSTATUS

--*/

{
    ULONG       Index;
    ULONG       NewState;
    NTSTATUS    Status;
    PGART_PTE   FoundRange;
    BOOLEAN     Backwards;

    PAGED_CODE();

    ASSERT((Range->Type == MmNonCached) || (Range->Type == MmWriteCombined));

    if (Range->NumberOfPages > (AgpContext->ApertureLength / PAGE_SIZE)) {
         return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);
        Status = AgpVIACreateGart(AgpContext,Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpVIACreateGart failed %08lx to create GART of size %lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries to satisfy
    // the request. Requests for uncached memory will scan from high addresses to
    // low addresses. Requests for write-combined memory will scan from low addresses
    // to high addresses. We will use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
    FoundRange = AgpVIAFindRangeInGart(&AgpContext->Gart[VIA_FIRST_AVAILABLE_PTE],
                                       &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
                                       Range->NumberOfPages,
                                       Backwards,
                                       GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
                Range->NumberOfPages,
                Range->Type,
                AgpContext->Gart));

        //
        //  This is where we could try and grow the GART
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    for (Index = 0;Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.LowPart));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGPVIA_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*++

Routine Description:

    Releases memory previously reserved with AgpReserveMemory

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the range to be released.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Pte;
    ULONG Start;

    PAGED_CODE()

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point.
    //
    for (Pte = Range->Context;
         Pte < (PGART_PTE)Range->Context + Range->NumberOfPages;
         Pte++) {
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        }
        Pte->Soft.State = GART_ENTRY_FREE;
    }

    Range->MemoryBase.QuadPart = 0;
    return(STATUS_SUCCESS);
}

#define AGP_TEST_SIGNATURE 0xAA55AA55


NTSTATUS
AgpVIACreateGart(
    IN PAGPVIA_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*++

Routine Description:

    Allocates and initializes an empty GART. The current implementation
    attempts to allocate the entire GART on the first reserve.

Arguments:

    AgpContext - Supplies the AGP context

    MinimumPages - Supplies the minimum size (in pages) of the GART to be
        created.

Return Value:

    NTSTATUS

--*/

{
    PHYSICAL_ADDRESS LowestAcceptable;
    PHYSICAL_ADDRESS BoundaryMultiple;
    PGART_PTE           Gart;
    ULONG               GartLength;
    ULONG               TempPhysAddr;
    PHYSICAL_ADDRESS    HighestAcceptable;
    PHYSICAL_ADDRESS    GartPhysical;
    PULONG              TestPage;
    ULONG i;

    PAGED_CODE();
    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //
    LowestAcceptable.QuadPart = 0;
    BoundaryMultiple.QuadPart =
        (ULONGLONG)VIA_GART_ALIGN(AgpContext->ApertureLength);
    HighestAcceptable.QuadPart = 0xFFFFFFFF;
    GartLength = BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE);

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength,
                                                  LowestAcceptable,
                                                  HighestAcceptable,
                                                  BoundaryMultiple,
                                                  MmNonCached);
    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("AgpVIACreateGart - MmAllocateContiguousMemory %lx failed\n",
                GartLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

    //
    // Get the physical address.
    //
    GartPhysical = MmGetPhysicalAddress(Gart);
    AGPLOG(AGP_NOISE,
           ("AgpVIACreateGart - GART of length %lx created at VA %08lx, PA %08lx\n",
            GartLength,
            Gart,
            GartPhysical.LowPart));
    ASSERT(GartPhysical.HighPart == 0);
    ASSERT(VIA_VERIFY_GART_ALIGN(GartPhysical.LowPart,
                                 AgpContext->ApertureLength));

    //
    // Initialize all the PTEs to free
    //
    for (i=0; i<GartLength/sizeof(GART_PTE); i++) {
        Gart[i].AsUlong = 0;
        Gart[i].Soft.State = GART_ENTRY_FREE;
    }

    ReadVIAConfig(&TempPhysAddr, GATTBASE_OFFSET, sizeof(TempPhysAddr));
    TempPhysAddr = (GartPhysical.LowPart & 0xFFFFF000) |
        (TempPhysAddr & 0x00000FFF);
    WriteVIAConfig(&TempPhysAddr, GATTBASE_OFFSET, sizeof(TempPhysAddr));

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
    AgpContext->GartPhysical = GartPhysical;

#if 0
    //
    // Test if AGP is working
    //
    LowestAcceptable.QuadPart = 0;
    BoundaryMultiple.QuadPart = 0;
    HighestAcceptable.QuadPart = 0xFFFFFFFF;
    
    TestPage =
        (PULONG)MmAllocateContiguousMemorySpecifyCache(PAGE_SIZE,
                                                       LowestAcceptable,
                                                       HighestAcceptable,
                                                       BoundaryMultiple,
                                                       MmNonCached);
    if (TestPage) {
        PVOID  ApertureVa;
        ULONG  TestPte;

        TestPage[0] = AGP_TEST_SIGNATURE;
        TestPte = MmGetPhysicalAddress(TestPage).LowPart;
        
        //
        // Setup a translation so the first page at aperture base points
        // to our test page
        //
        Gart[0].AsUlong =
            (((UINT_PTR)TestPte >> PAGE_SHIFT) * PAGE_SIZE) | GART_ENTRY_VALID;
        
        //
        // Flush the write buffer
        //
        i = Gart[0].AsUlong;

        //
        // Flush the TLB
        //
        AgpVIAFlushPageTLB(AgpContext);

        //
        // Try to read our signature through the aperture/gart translation
        //
        ApertureVa = MmMapIoSpace(AgpContext->ApertureStart,
                                  PAGE_SIZE,
                                  MmNonCached);
        
        ASSERT(ApertureVa != NULL);

        i = *(PULONG)ApertureVa;

        AGPLOG(AGP_NOISE,
               ("AgpVIACreateGart AGP test: wrote (%08x) PA %08x=badceede, "
                "mapped gart[0] %08x=%08x, read AP_BASE (%08x) VA %08x=%08x\n",
                TestPage,
                TestPte,
                Gart,
                Gart[0].AsUlong,
                AgpContext->ApertureStart.LowPart,
                ApertureVa,
                i));

        MmUnmapIoSpace(ApertureVa, PAGE_SIZE);

        //
        // Cleanup
        //
        Gart[0].AsUlong = 0;
        Gart[0].Soft.State = GART_ENTRY_FREE;
        TestPage[0] = Gart[0].AsUlong;
        AgpVIAFlushPageTLB(AgpContext);
        MmFreeContiguousMemory(TestPage);

        //
        // Turn off everything, and bail, AGP is broken
        //
        if (i != AGP_TEST_SIGNATURE) {

            AGPLOG(AGP_CRITICAL,
                   ("AgpVIACreateGart - AGP failed: Read=%08x\n", i));

            AgpDisableAperture(AgpContext);
            
            //
            // Need to let the user know what happened here
            //
            //AgpLogGenericHwFailure();

            return STATUS_DEVICE_CONFIGURATION_ERROR;
        }
    }
#endif

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpMapMemory(
    IN PAGPVIA_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Maps physical memory into the GART somewhere in the specified range.

Arguments:

    AgpContext - Supplies the AGP context

    Range - Supplies the AGP range that the memory should be mapped into

    Mdl - Supplies the MDL describing the physical pages to be mapped

    MemoryBase - Returns the physical memory in the aperture where the pages
        were mapped.

Return Value:

    NTSTATUS

--*/

{
    ULONG               PageCount;
    PGART_PTE           Pte;
    PGART_PTE           StartPte;
    ULONG               Index;
    ULONG               TargetState;
    PULONG              Page;
    BOOLEAN             Backwards;
    GART_PTE            NewPte;
    VIA_GATT_BASE       GATTBase;
    NTSTATUS            Status;

    PAGED_CODE();

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    TargetState = (Range->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : GART_ENTRY_RESERVED_WC;

    Pte = StartPte + OffsetInPages;

    //
    // We have a suitable range, now fill it in with the supplied MDL.
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount <= StartPte + Range->NumberOfPages);
    NewPte.AsUlong = 0;
    NewPte.Soft.State = (Range->Type == MmNonCached) ? GART_ENTRY_VALID_UC :
                                                       GART_ENTRY_VALID_WC;
    Page = (PULONG)(Mdl + 1);


    for (Index = 0; Index < PageCount; Index++) {
        ASSERT(Pte[Index].Soft.State == TargetState);

        NewPte.Hard.Page = *Page++;
        Pte[Index].AsUlong = NewPte.AsUlong;
        ASSERT(Pte[Index].Hard.Valid == 1);
    }

    //
    // We have filled in all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    NewPte.AsUlong = *(volatile ULONG *)&Pte[PageCount-1].AsUlong;

    //
    // If we have not yet gotten around to enabling the GART aperture, do it now.
    //
    if (!AgpContext->GlobalEnable) {
        VIA_GATT_BASE GARTBASE_Config;

        AGPLOG(AGP_NOISE,
               ("AgpMapMemory - Enabling global aperture access\n"));

        ViaApertureEnable(ON);

        ReadVIAConfig(&GARTBASE_Config,
                      GATTBASE_OFFSET,
                      sizeof(GARTBASE_Config));

        GARTBASE_Config.TT_NonCache = 1;

        WriteVIAConfig(&GARTBASE_Config,
                       GATTBASE_OFFSET,
                       sizeof(GARTBASE_Config));

        ViaGartEnable(ON);

        AgpContext->GlobalEnable = TRUE;
    }

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGPVIA_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG PageOffset
    )
/*++

Routine Description:

    Unmaps previously mapped memory in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range that the memory should be mapped into

    NumberOfPages - Supplies the number of pages in the range to be freed.

    PageOffset - Supplies the offset into the range where the freeing should begin.

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    PGART_PTE Pte;
    PGART_PTE LastChanged=NULL;
    PGART_PTE StartPte;
    ULONG NewState;

    PAGED_CODE();

    ASSERT(PageOffset + NumberOfPages <= AgpRange->NumberOfPages);

    StartPte = AgpRange->Context;
    Pte = &StartPte[PageOffset];

    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    //
    // Flush TLB
    //
    AgpVIAFlushPageTLB(AgpContext);

    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid) {
            Pte[i].Soft.State = NewState;
            LastChanged = &Pte[i];
        } else {
            //
            // This page is not mapped, just skip it.
            //
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[i],
                    Pte[i].AsUlong,
                    i));
        }
    }

    //
    // We have invalidated all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    if (LastChanged != NULL) {
        ULONG Temp;
        Temp = *(volatile ULONG *)(&LastChanged->AsUlong);
    }

    return(STATUS_SUCCESS);
}


PGART_PTE
AgpVIAFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;
    PGART_PTE Candidate;

    PAGED_CODE();

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if (Current->Soft.State == SearchState) {
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
AgpVIAFlushPageTLB(
    IN PAGPVIA_EXTENSION AgpContext
    )
/*++

Routine Description:

    Flush the AGP TLB (16 entries)
    if hardware does not support FLUSH TLB, then read Aperture 32 times

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None

--*/

{
    VIA_GART_TLB_CTRL GARTCTRL_Config;

    PAGED_CODE();

    if (AgpContext->Cap_FlushTLB) {

        ReadVIAConfig(&GARTCTRL_Config,
                      GARTCTRL_OFFSET,
                      sizeof(GARTCTRL_Config));

        //Flush TLB
        GARTCTRL_Config.FlushPageTLB = 1;
        WriteVIAConfig(&GARTCTRL_Config,
                       GARTCTRL_OFFSET,
                       sizeof(GARTCTRL_Config));

        //Stop Flush TLB
        GARTCTRL_Config.FlushPageTLB = 0;
        WriteVIAConfig(&GARTCTRL_Config,
                       GARTCTRL_OFFSET,
                       sizeof(GARTCTRL_Config));

    } else {
        AgpVIAFlushData(AgpContext);
    }
}


VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;

    PAGED_CODE();
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid == 0) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                ++i;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
    return;

}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONG Pages;

    PAGED_CODE();

    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONG)(Mdl + 1);
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    for (i=0; i<NumberOfPages; i++) {
        ASSERT(Pte[i].Hard.Valid == 1);
        Pages[i] = Pte[i].Hard.Page;
    }
}


VOID
AgpVIAFlushData(
    IN PAGPVIA_EXTENSION AgpContext
    )
/*++

Routine Description:

    Flushes the chipset TB by reading 32 pages of aperture memory space.

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    NTSTATUS

--*/

{
    PVOID   ApertureVirtAddr, TempVirtualAddr;
    ULONG   ReadData;        
    ULONG   Index;

    PAGED_CODE();

    ApertureVirtAddr = MmMapIoSpace(AgpContext->ApertureStart,
                                    32 * PAGE_SIZE,
                                    MmNonCached);

    ASSERT(ApertureVirtAddr != NULL);

    if (ApertureVirtAddr != NULL) {

        TempVirtualAddr = ApertureVirtAddr;
        for (Index = 0; Index < 32; Index++) {
            ReadData = *(PULONG)TempVirtualAddr;
            TempVirtualAddr = (PVOID)((PCCHAR)TempVirtualAddr + PAGE_SIZE);
        }
        MmUnmapIoSpace(ApertureVirtAddr, 32 * PAGE_SIZE);
    
    } else {
         AGPLOG(AGP_CRITICAL,("Agp440FlushPageTLB: Invalid address\n"));
    }
}


NTSTATUS
AgpSpecialTarget(
    IN PAGPVIA_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context

    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = AgpVIASetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Add more tweaks here...
    //

    AgpContext->SpecialTarget |= DeviceFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
AgpVIASetRate(
    IN PAGPVIA_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies the AGP context

    AgpRate - Rate to set

    note: this routine assumes that AGP has already been enabled, and that
          whatever rate we've been asked to set is supported by master

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetPciDeviceCapability(0, 0, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGPVIASetRate: AgpLibGetPciDeviceCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGPVIASetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPVIASetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPVIASetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGPVIASetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    TargetCap.AGPCommand.Rate = AgpRate;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;
        
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPVIASetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGPVIASetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\viaagp\viaagp.h ===
//
// VIAAGP.sys is a driver, make sure we get the appropriate linkage.
//

#define _NTDRIVER_

#include "stdarg.h"
#include "stdio.h"
#include "ntddk.h"
#include "agp.h"

//
// Define the location of the GART aperture control registers
//

//
// The GART registers on the VIA live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//
#define AGP_VIA_GART_BUS_ID     0
#define AGP_VIA_GART_SLOT_ID    0
#define AGP_P2P_SLOT_ID         1
#define AGP_VGA_BUS_ID          1
#define AGP_VGA_SLOT_ID         0


#define AGP_VIA_IDENTIFIER    0x00001106
// 0x05971106 -> VT82C597 / VT82C597 AT

// chu
#define GABASE_OFFSET   0x10            // Graphics Aperture Base
#define GARTCTRL_OFFSET 0x80            // GART/TLB Control
#define GASIZE_OFFSET   0x84            // Graphics Aperture Size
#define GATTBASE_OFFSET 0x88            // GA Translation Table Base
#define VREF_OFFSET     0xB0            // AGP VREF control
#define AGPMISC_OFFSET  0xAC             // AGP MISC control

#define ReadVIAConfig(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_VIA_GART_BUS_ID,      \
                                  AGP_VIA_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define WriteVIAConfig(_buf_,_offset_,_size_)               \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_VIA_GART_BUS_ID,      \
                                  AGP_VIA_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define ReadP2PConfig(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_VIA_GART_BUS_ID,      \
                                  AGP_P2P_SLOT_ID,          \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define WriteP2PConfig(_buf_,_offset_,_size_)               \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_VIA_GART_BUS_ID,      \
                                  AGP_P2P_SLOT_ID,          \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define ReadVGAConfig(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_VGA_BUS_ID,           \
                                  AGP_VGA_SLOT_ID,          \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define WriteVGAConfig(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_VGA_BUS_ID,           \
                                  AGP_VGA_SLOT_ID,          \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define ON  1
#define OFF 0

#define ViaApertureEnable(Enable) \
{ \
    VIA_GART_TLB_CTRL AGPCTRL_Config; \
 \
    ReadVIAConfig(&AGPCTRL_Config, GARTCTRL_OFFSET, sizeof(AGPCTRL_Config)); \
    AGPCTRL_Config.AGP_ATFGA = (Enable); \
    AGPCTRL_Config.CPU_ATFGA = (Enable); \
    AGPCTRL_Config.PCI2_ATFGA = (Enable); \
    AGPCTRL_Config.PCI1_ATFGA = (Enable); \
    WriteVIAConfig(&AGPCTRL_Config, GARTCTRL_OFFSET, sizeof(AGPCTRL_Config)); \
}

#define ViaGartEnable(Enable) \
{ \
    VIA_GATT_BASE GARTBASE_Config; \
 \
    ReadVIAConfig(&GARTBASE_Config, GATTBASE_OFFSET, sizeof(GARTBASE_Config));\
    GARTBASE_Config.GA_Enable = (Enable); \
    WriteVIAConfig(&GARTBASE_Config, GATTBASE_OFFSET, sizeof(GARTBASE_Config));}

//
// Conversions from Graphics Aperture Size encoding to MB
//
// 0xFF (b 1111 1111) =   1MB
// 0xFE (b 1111 1110) =   2MB
// 0xFC (b 1111 1100) =   4MB
// 0xF8 (b 1111 1000) =   8MB
// 0xF0 (b 1111 0000) =  16MB
// 0xE0 (b 1110 0000) =  32MB
// 0xC0 (b 1100 0000) =  64MB
// 0x80 (b 1000 0000) = 128MB
// 0x00 (b 0000 0000) = 256MB

#define GA_SIZE_1MB     0xFF
#define GA_SIZE_2MB     0xFE
#define GA_SIZE_4MB     0xFC
#define GA_SIZE_8MB     0xF8
#define GA_SIZE_16MB    0xF0
#define GA_SIZE_32MB    0xE0
#define GA_SIZE_64MB    0xC0
#define GA_SIZE_128MB   0x80
#define GA_SIZE_256MB   0x00

#define GA_SIZE_COUNT 7
#define GA_MIN_SIZE (1 * 1024 * 1024)
#define GA_MAX_SIZE (256 * 1024 * 1024)


//
// Define the GART table entry.
//
typedef struct _GART_ENTRY_HW {
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;

//
// Aperture size in MB is equivalent to gart table allocation
// alignment requirement in KB
//
#define VIA_GART_ALIGN(Aperture) ((Aperture) >> 0xA)
#define VIA_VERIFY_GART_ALIGN(Gart, Aperture) \
    (((Gart) & (VIA_GART_ALIGN((Aperture)) - 1)) == 0)

//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)


typedef struct _GART_ENTRY_SW {
    ULONG State     : 3;
    ULONG Reserved  : 29;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the layout of the hardware registers
//

typedef struct _VIA_GART_TLB_CTRL {
    ULONG AGP_ATFGA     : 1;    // ATFGA = Address Translation for GA Access
    ULONG CPU_ATFGA     : 1;
    ULONG PCI2_ATFGA    : 1;
    ULONG PCI1_ATFGA    : 1;
    ULONG Reserved1     : 3;
    ULONG FlushPageTLB  : 1;
    ULONG Reserved2     : 8;    // test mode status
    ULONG Reserved3     : 16;
} VIA_GART_TLB_CTRL, *PVIA_GART_TLB_CTRL;

typedef struct _VIA_GATT_BASE {
    ULONG TT_NonCache   : 1;    // Translation Table Noncachable
    ULONG GA_Enable     : 1;    // Graphics Aperture Enable
    ULONG TLB_Timing    : 1;
    ULONG Reserved      : 9;
    ULONG GATT_Base     : 20;
} VIA_GATT_BASE, *PVIA_GATT_BASE;

typedef struct _VREF_REG {
    ULONG Reserved1       : 7;
    ULONG VREF_Control    : 1;
    ULONG Reserved2       : 24;
} VREF_REG, *PVREF_REG;

typedef struct _AGPMISC_REG {
    ULONG Reserved1       : 18;
    ULONG AGP4X_Support   : 1;
    ULONG Reserved2       : 1;
    ULONG FW_Support      : 1;
    ULONG AGP4G_Support   : 1;
    ULONG Reserved3       : 10;
} AGPMISC_REG, *PAGPMISC_REG;

//
// Define the VIA-specific extension
//
typedef struct _AGPVIA_EXTENSION {
    BOOLEAN             GlobalEnable;
    BOOLEAN             PCIEnable;
    PHYSICAL_ADDRESS    ApertureStart;         //Aperture Phys Base Address
    ULONG               ApertureLength;
    PGART_PTE           GartCached;
    PGART_PTE           Gart;
    ULONG               GartLength;
    PHYSICAL_ADDRESS    GartPhysical;
    BOOLEAN             Cap_FlushTLB;          //TRUE: support Flush TLB
    ULONGLONG           SpecialTarget;
} AGPVIA_EXTENSION, *PAGPVIA_EXTENSION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\uagp35\init.c ===
/*++

Copyright (2) 2002 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization support routines for the
    MS AGP v3 Filter Driver

Author:

    Eric F. Nelson (enelson) June 6, 2002

Revision History:

--*/

#include "agp.h"
#include "uagp35.h"

ULONG AgpExtensionSize = sizeof(UAGP35_EXTENSION);
PAGP_FLUSH_PAGES AgpFlushPages = NULL; // Not implemented (yet)


NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*++

Routine Description:

    Entrypoint for target initialization, this is called first

Arguments:

    AgpExtension - Supplies our AGP3 extension

Return Value:

    STATUS_SUCCESS

--*/
{
    ULONG DeviceId;
    NTSTATUS Status;
    PCI_AGP_CAPABILITY TargetCap;
    PUAGP35_EXTENSION Extension = AgpExtension;

    //
    // Zero/init our AGP3 extension
    //
    RtlZeroMemory(AgpExtension, sizeof(UAGP35_EXTENSION));

    //
    // Figure out what type of AGP3 capability our target is
    //
    Status = AgpLibGetTargetCapability(AgpExtension, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("UAGP35TargetInit: AgpLibGetTargetCapability "
                "failed %08lx\n"));
        return Status;
    }
    Extension->CapabilityId = TargetCap.Header.CapabilityID;

    //
    // Make sure the capability is v3!!!
    //
    if ((TargetCap.Major < 3) ||
        ((TargetCap.Major == 3) && (TargetCap.Minor < 5))) {
        AGPLOG(AGP_CRITICAL,
               ("UAGP35TargetInit: Capability version (%d) != 3\n",
                TargetCap.Major));
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Save the vendor and device IDs in case we need to "tweak"
    // something for a particular platform
    //
    AgpLibReadAgpTargetConfig(AgpExtension, &DeviceId, 0, sizeof(DeviceId));
    Extension->DeviceId = DeviceId;
   
    return STATUS_SUCCESS;
}



NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*++

Routine Description:

    Entrypoint for master initialization, this is called after target
    initialization and should be used to initialize the AGP capabilities
    of both master and target

    This is also called when the master transitions into the D0 state

Arguments:

    AgpExtension - Supplies our AGP3 extension

    AgpCapabilities - Returns the capabilities of this AGP device

Return Value:

    STATUS_SUCCESS, or an appropriate error status

--*/
{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    ULONG ApertureBase;
    PUAGP35_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable;
    ULONG DataRate;
    ULONG FourGBEnable = OFF;
    ULONG FastWrite;
    BOOLEAN ReverseInit;
    
#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("UAGP35MasterInit: AgpLibGetMasterCapability failed %08lx\n"));
        return Status;
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("UAGP35MasterInit: AgpLibGetMasterCapability returned "
                "no valid transfer rate\n"));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    Status = AgpLibGetTargetCapability(AgpExtension, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("UAGP35MasterInit: AgpLibGetTargetCapability "
                "failed %08lx\n"));
        return Status;
    }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;

    AGP_ASSERT(DataRate != 0);

    //
    // Select the highest common rate
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);

        //
        // If we're in AGP3 mode, and our rate was successfully
        // programmed, then we must convert into AGP2 rate bits
        //
        if (TargetCap.AGPStatus.Agp3Mode == ON) {
            ASSERT(MasterCap.AGPStatus.Agp3Mode == ON);
            ASSERT((DataRate == 8) || (DataRate == PCI_AGP_RATE_4X));
            DataRate >>= 2;
        }
    }

    //
    // Enable SBA if both master and target support it
    //
    SBAEnable = TargetCap.AGPStatus.SideBandAddressing &
        MasterCap.AGPStatus.SideBandAddressing;

    //
    // Enable FastWrite if both master and target support it
    //
    FastWrite = TargetCap.AGPStatus.FastWrite &
        MasterCap.AGPStatus.FastWrite;

    //
    // Enable 4GB addressing if aperture is 64-bit
    //    
    AgpLibReadAgpTargetConfig(AgpExtension,
                              &ApertureBase,
                              APERTURE_BASE,
                              sizeof(ApertureBase));
    
    if (ApertureBase & APERTURE_BASE64_MASK) {
        FourGBEnable = ON;
        Extension->FourGBEnable = TRUE;
    }

    //
    // Indicate whether we can map memory through the GART aperture
    //
    *AgpCapabilities = (TargetCap.AGPStatus.HostTransDisable) ? 0:
        AGP_CAPABILITIES_MAP_PHYSICAL;

    MasterCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.Rate = DataRate;
    MasterCap.AGPCommand.AGPEnable = ON;
    TargetCap.AGPCommand.AGPEnable = ON;
    MasterCap.AGPCommand.SBAEnable = SBAEnable;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    MasterCap.AGPCommand.FastWriteEnable = FastWrite;
    TargetCap.AGPCommand.FastWriteEnable = FastWrite;
    MasterCap.AGPCommand.FourGBEnable = FourGBEnable;
    TargetCap.AGPCommand.FourGBEnable = FourGBEnable;  
    MasterCap.AGPCommand.RequestQueueDepth =
        TargetCap.AGPStatus.RequestQueueDepthMaximum;
    MasterCap.AGPCommand.AsyncReqSize = 
        TargetCap.AGPStatus.AsyncRequestSize;

    //
    // Patch rate for early rev VIA 8X silicon errata
    //
    if ((Extension->SpecialTarget & AGP_FLAG_SPECIAL_VIA_AGP2_RATE_PATCH) &&
        (TargetCap.AGPStatus.Agp3Mode == OFF)) {
        switch (DataRate) {
            case PCI_AGP_RATE_1X:
            case PCI_AGP_RATE_2X:
                MasterCap.AGPCommand.Rate = PCI_AGP_RATE_1X;
                TargetCap.AGPCommand.Rate = PCI_AGP_RATE_4X;
                break;
           case PCI_AGP_RATE_4X:
               MasterCap.AGPCommand.Rate = PCI_AGP_RATE_4X;
               TargetCap.AGPCommand.Rate = PCI_AGP_RATE_1X;
        }
        AGPLOG(AGP_WARNING,
               ("UAGP35MasterInit: AGP_FLAG_SPECIAL_VIA_AGP2_RATE_PATCH\n"));
    }

    //
    // Enable the Master first if the reverse init bit is set
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("UAGP35MasterInit: AgpLibSetMasterCapability %08lx "
                    "failed %08lx\n",
                    &MasterCap,
                    Status));
            return Status;
        }
    }

    //
    // Otherwise enable the Target first
    //
    Status = AgpLibSetTargetCapability(AgpExtension, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("UAGP35MasterInit: AgpLibSetTargetCapability %08lx "
                "for target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("UAGP35MasterInit: AgpLibSetMasterCapability %08lx "
                    "failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

#if DBG
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    AGP_ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed, so loosen the assert to not require an
    // exact match
    //
    // We'll do the same for asynchronous request queue depth too
    //
    AGP_ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <=
               MasterCap.AGPCommand.RequestQueueDepth);
    AGP_ASSERT(CurrentCap.AGPCommand.AsyncReqSize <=
               MasterCap.AGPCommand.AsyncReqSize);

    CurrentCap.AGPCommand.RequestQueueDepth =
        MasterCap.AGPCommand.RequestQueueDepth;
    CurrentCap.AGPCommand.AsyncReqSize = MasterCap.AGPCommand.AsyncReqSize;

    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand,
                              &MasterCap.AGPCommand,
                              sizeof(CurrentCap.AGPCommand)));

    AGPLOG(AGP_NOISE,
           ("UAGP35MasterInit: WroteMasterCmd=%08x, ReadMasterCmd=%08lx\n",
            MasterCap.AGPCommand,
            CurrentCap.AGPCommand));

    Status = AgpLibGetTargetCapability(AgpExtension, &CurrentCap);

    AGP_ASSERT(NT_SUCCESS(Status));
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand,
                              &TargetCap.AGPCommand,
                              sizeof(CurrentCap.AGPCommand)));

    AGPLOG(AGP_NOISE,
           ("UAGP35MasterInit: WroteTargetCmd=%08x, ReadTargetCmd=%08lx\n",
            TargetCap.AGPCommand,
            CurrentCap.AGPCommand));
#endif

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\agp\viaagp\init.c ===
/*++

Copyright (c) 1998 VIA Technologies, Inc. and Microsoft Corporation.

Module Name:

    init.c

Abstract:

    This module contains the initialization code for VIAAGP.SYS.

Revision History:

--*/

#include "viaagp.h"

ULONG AgpExtensionSize = sizeof(AGPVIA_EXTENSION);
PAGP_FLUSH_PAGES AgpFlushPages = NULL;  // not implemented

VOID
AgpTweak(
    VOID
    )
/*++

Routine Description:

    Check VIA rev and video device, then tweak config accordingly

Parameters:

    None

Return Value:

    None

--*/
{
    ULONG   ulNB_ID, ulVGA_ID, ulNB_Rev=0xFFFFFFFF, ulNB_Version=0xFFFFFFFF;
    ULONG   ulTmpPhysAddr;
    UCHAR   bVMask, bVOrg;
    UCHAR   i, bMaxItem=20;
    
    //----------------------------------------------------------------
    //Patch Mapping Table
    //----------------------------------------------------------------
    ULONG NBtable[11] =
    {
        //VT3054      VT3055      VT3062      VT3064      VT3056
        0x059700FF, 0x0598000F, 0x0598101F, 0x0501000F, 0x0691000F,
        
        //VT3063      VT3073      VT3075      VT3085      VT3067
        0x0691202F, 0x0691404F, 0x0691808F, 0x0691C0CF, 0x0601000F, 0xFFFFFFFF
    };
    
    ULONG NBVersion[11] =
    {
        0x3054,     0x3055,     0x3062,     0x3064,     0x3056,
        0x3063,     0x3073,     0x3075,     0x3085,     0x3067,     0xFFFFFFFF
    };
    
#ifdef AGP_440
    DbgPrint("FineTune\n");
#endif
    
    //----------------------------------------------------------------
    //Find the type of North Bridge (device id, revision #)
    //----------------------------------------------------------------
    
    //
    //Save back door value and close back door
    //
    ReadVIAConfig(&bVOrg, 0xFC, sizeof(bVOrg));
    bVMask=bVOrg & 0xFE;
    WriteVIAConfig(&bVMask, 0xFC, sizeof(bVMask));
    ReadVIAConfig(&ulNB_ID, 0x00, sizeof(ulNB_ID))
        ulNB_ID=ulNB_ID&0xFFFF0000;
    ReadVIAConfig(&ulNB_Rev, 0x08, sizeof(ulNB_Rev));
    ulNB_Rev=ulNB_Rev&0x000000FF;
    ulNB_ID=ulNB_ID | (ulNB_Rev<<8) | ulNB_Rev;
    WriteVIAConfig(&bVOrg, 0xFC, sizeof(bVOrg));

    //
    //Find the type of North Bridge from the predefined NBtable
    //
    for ( i=0; i<bMaxItem; i++ )
    {
        if ( (NBtable[i]&0xFFFF0000) == (ulNB_ID&0xFFFF0000) )
        {
            if ( ((NBtable[i]&0x0000FF00)<=(ulNB_ID&0x0000FF00)) && ((NBtable[i]&0x000000FF)>=(ulNB_ID&0x000000FF)) )
            {
                ulNB_Version=NBVersion[i];
                break;
            }
        }
        
        if ( NBtable[i]==0xFFFFFFFF )
        {
            break;
        }
    }

    //----------------------------------------------------------------
    // General Case for NB
    //----------------------------------------------------------------
    
    //
    //Stephen Add Start, If Socket 7's chipset, write 1 to Rx51 bit 6;
    //
    if ( (ulNB_ID & 0xFF000000) == 0x05000000) {
        ReadVIAConfig(&bVMask, 0x51, sizeof(bVMask));
        bVMask=bVMask|0x40;
        WriteVIAConfig(&bVMask, 0x51, sizeof(bVMask));
    }
    
    //
    //  For the specific NB
    //
    switch(ulNB_Version)
    {
        case 0x3054:
            break;
            
        case 0x3055:
            // 51[7]=1, 51[6]=1, AC[2]=1
            if ( ulNB_Rev > 3 )
            {
                ReadVIAConfig(&bVMask, 0x51, sizeof(bVMask));
                bVMask=bVMask|0xC0;
                WriteVIAConfig(&bVMask, 0x51, sizeof(bVMask));
                ReadVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
                bVMask=bVMask|0x04;
                WriteVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
            }
            break;
            
        case 0x3056:
            // 69[1]=1, 69[0]=1, AC[2]=1, AC[5]=1
            ReadVIAConfig(&bVMask, 0x69, sizeof(bVMask));
            bVMask=bVMask|0x03;
            WriteVIAConfig(&bVMask, 0x69, sizeof(bVMask));
            ReadVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
            bVMask=bVMask|0x24;
            WriteVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
            break;
            
        case 0x3062:
        case 0x3063:
        case 0x3064:
        case 0x3073:
        case 0x3075:
        case 0x3085:
        case 0x3067:
            // AC[6]=1, AC[5]=1
            ReadVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
            bVMask=bVMask|0x60;
            WriteVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
            break;
            
        default:
            break;
    }
    
    //----------------------------------------------------------------
    //Find the type of AGP VGA Card (vender id, device id, revision #)
    //Bus 1, Device 0, Function 0
    //----------------------------------------------------------------
    
    ReadVGAConfig(&ulVGA_ID, 0x00, sizeof(ulVGA_ID));
    
#ifdef AGP_440
    DbgPrint("\nPatch for ulNB_Version=%x (ulNB_ID=%x), ulVGA_ID=%x",ulNB_Version,ulNB_ID,ulVGA_ID);
#endif
    
    //----------------------------------------------------------------
    //Patch the Compatibility between VGA Card and North Bridge
    //----------------------------------------------------------------
    
    //
    // Switch 1. For all cards of the same vender
    //
    switch(ulVGA_ID&0x0000FFFF)
    {
        //ATI
        case 0x00001002:
            switch(ulNB_Version)
            {
                case 0x3055:
                case 0x3054:
                case 0x3056:
                    // P2P, 40[7]=0
                    ReadP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    bVMask=bVMask&0x7F;
                    WriteP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    break;
            }
            break;
            
            //3DLAB
        case 0x0000104C:
            if (ulNB_Version==0x3063)
            {
                // AC[1]=0
                ReadVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
                bVMask=bVMask&0xFD;
                WriteVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
            }
            break;
    }
    
    //
    // Switch 2. For the specific card
    //
    switch(ulVGA_ID)
    {
        //ATIRage128
        case 0x52461002:
            switch(ulNB_Version)
            {
                case 0x3056:
                    // P2P, 40[7]=0
                    ReadP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    bVMask=bVMask&0x7F;
                    WriteP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    break;
                    
                case 0x3063:
                    if (ulNB_Rev == 6)
                    {
                        // P2P, 40[7]=1
                        ReadP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                        bVMask=bVMask|0x80;
                        WriteP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    }
                    else
                    {
                        // P2P, 40[7]=0
                        ReadP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                        bVMask=bVMask&0x7F;
                        WriteP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    }
                    break;
            }
            break;
            
            //TNT
        case 0x002010DE:
            switch(ulNB_Version)
            {
                case 0x3056:
                case 0x3063:
                case 0x3073:
                    // P2P, 40[1]=0
                    ReadP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    bVMask=bVMask&0xFD;
                    WriteP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    // 70[2]=0
                    ReadVIAConfig(&bVMask, 0x70, sizeof(bVMask));
                    bVMask=bVMask&0xFB;
                    WriteVIAConfig(&bVMask, 0x70, sizeof(bVMask));
                    break;
            }
            break;
            
            //S33D    
        case 0x8A225333:
            if (ulNB_Version==0x3063)
                if (ulNB_Rev==6)
                {
                    // P2P, 40[7]=0
                    ReadP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    bVMask=bVMask&0x7F;
                    WriteP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                }
            break;
    }
}


NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*++

Routine Description:

    Entrypoint for target initialization. This is called first.

Arguments:

    AgpExtension - Supplies the AGP extension

Return Value:

    NTSTATUS

--*/

{
    ULONG VendorId = 0;
    PAGPVIA_EXTENSION Extension = AgpExtension;
    VIA_GATT_BASE GARTBASE_Config;

    //
    // Make sure we are really loaded only on a VIA chipset
    //
    ReadVIAConfig(&VendorId,0,sizeof(VendorId));

    VendorId &= 0x0000FFFF;
    ASSERT(VendorId == AGP_VIA_IDENTIFIER);

    if (VendorId != AGP_VIA_IDENTIFIER) {
        AGPLOG(AGP_CRITICAL,
               ("VIAAGP - AgpInitializeTarget called for platform %08lx which is not a VIA chipset!\n",
                VendorId));
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Initialize our chipset-specific extension
    //
    Extension->ApertureStart.QuadPart = 0;
    Extension->ApertureLength = 0;
    Extension->Gart = NULL;
    Extension->GartLength = 0;
    Extension->GlobalEnable = FALSE;
    Extension->PCIEnable = FALSE;
    Extension->GartPhysical.QuadPart = 0;
    Extension->SpecialTarget = 0;

    //
    // Check whether the chipset support Flush TLB or not
    // 88[2]=0, support FLUSH TLB
    //
    ReadVIAConfig(&GARTBASE_Config, GATTBASE_OFFSET, sizeof(GARTBASE_Config));
    if ( GARTBASE_Config.TLB_Timing == 0) {
        Extension->Cap_FlushTLB = TRUE;
    } else {
        Extension->Cap_FlushTLB = FALSE;
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

Arguments:

    AgpExtension - Supplies the AGP extension

    AgpCapabilities - Returns the capabilities of this AGP device.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    PAGPVIA_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable;
    ULONG DataRate;
    ULONG FastWrite;
    ULONG FourGB;
    VIA_GART_TLB_CTRL AGPCTRL_Config;
    VIA_GATT_BASE GARTBASE_Config;
    VREF_REG VREF_Config;
    BOOLEAN ReverseInit;
    AGPMISC_REG AGPMISC_Config;

#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

    //
    // Indicate that we can map memory through the GART aperture
    //
    *AgpCapabilities = AGP_CAPABILITIES_MAP_PHYSICAL;

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPVIAInitializeDevice - AgpLibGetMasterCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability returned no valid transfer rate\n"));
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = AgpLibGetPciDeviceCapability(0,0,&TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPVIAInitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;
    AGP_ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;

        //
        //Disable FW capability
        //
        TargetCap.AGPStatus.FastWrite = 0;
        ReadVIAConfig(&AGPMISC_Config, AGPMISC_OFFSET, sizeof(AGPMISC_Config));
        AGPMISC_Config.FW_Support = 0;
        WriteVIAConfig(&AGPMISC_Config, AGPMISC_OFFSET, sizeof(AGPMISC_Config));
   }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);
    }

    //
    // Set the VREF, RxB0[7].
    // 4x -> STB#
    // 1x, 2x -> AGPREF
    //
    ReadVIAConfig(&VREF_Config, VREF_OFFSET, sizeof(VREF_Config));
    if (DataRate == PCI_AGP_RATE_4X) {
        VREF_Config.VREF_Control = 0;
    } else {
        VREF_Config.VREF_Control = 1;
    }
    WriteVIAConfig(&VREF_Config, VREF_OFFSET, sizeof(VREF_Config));

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing &
                 MasterCap.AGPStatus.SideBandAddressing);

    //
    // Enable FastWrite if both master and target support it.
    //
    FastWrite = (TargetCap.AGPStatus.FastWrite & MasterCap.AGPStatus.FastWrite);

    //
    // Enable FourGB if both master and target support it.
    //
    FourGB = (TargetCap.AGPStatus.FourGB & MasterCap.AGPStatus.FourGB);

    //
    // Fine tune the Compatibility between VGA Card and North Bridge
    //
    AgpTweak();

    //
    // Enable the Master
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.FourGBEnable = FourGB;  
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGPVIAInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    //
    // Now enable the Target
    //
    TargetCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    TargetCap.AGPCommand.FastWriteEnable = FastWrite;
    TargetCap.AGPCommand.FourGBEnable = FourGB;  
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPVIAInitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.FourGBEnable = FourGB;  
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGPVIAInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

#if DBG
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    AGP_ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    AGP_ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

    Status = AgpLibGetPciDeviceCapability(0,0,&CurrentCap);
    AGP_ASSERT(NT_SUCCESS(Status));
    AGP_ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\convert.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    xlate.c

Abstract:

    This file contains routines to translate resources between PnP ISA/BIOS
    format and Windows NT formats.

Author:

    Shie-Lin Tzong (shielint) 12-Apr-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "busp.h"
#include "pnpisa.h"
#include "cfg.h"

#if ISOLATE_CARDS
#include "..\..\ntos\io\pnpmgr\convert.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\bus.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    bus.c

Abstract:


Author:

    Shie-Lin Tzong (shielint) July-26-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "busp.h"
#include "pnpisa.h"

#if ISOLATE_CARDS

BOOLEAN
PipIsDeviceInstanceInstalled(
    IN HANDLE Handle,
    IN PUNICODE_STRING DeviceInstanceName
    );

VOID
PipInitializeDeviceInfo (
                 IN OUT PDEVICE_INFORMATION deviceInfo,
                 IN PCARD_INFORMATION cardinfo,
                 IN UCHAR index
                 );

NTSTATUS
PipGetInstalledLogConf(
    IN HANDLE EnumHandle,
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PHANDLE LogConfHandle
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PipCreateReadDataPort)
#pragma alloc_text(PAGE,PipStartReadDataPort)
#pragma alloc_text(PAGE,PipStartAndSelectRdp)
#pragma alloc_text(PAGE,PipCheckBus)
#pragma alloc_text(PAGE,PipIsDeviceInstanceInstalled)
#pragma alloc_text(PAGE,PipGetInstalledLogConf)
#pragma alloc_text(PAGE,PipInitializeDeviceInfo)
#endif


NTSTATUS
PipStartAndSelectRdp(
    PDEVICE_INFORMATION DeviceInfo,
    PPI_BUS_EXTENSION BusExtension,
    PDEVICE_OBJECT  DeviceObject,
    PCM_RESOURCE_LIST StartResources
    )
/*++

Routine Description:

    This routine selects an RDP and trims down the resources to just the RDP.

Arguments:

    DeviceInfo - device extension for RDP
    BusExtension - device extension for BUS object
    DeviceObject - device object for RDP
    StartResources - the start resources we received in the RDP start irp

Return Value:

   STATUS_SUCCESS = Current resources are fine but need trimming

   anything else - current resources failed in some way

--*/
{
    ULONG i, j, LastMapped = -1;
    UCHAR CardsFound;
    NTSTATUS status;
    
    // Already tested for null start resources, and start resource list too small

    status = PipMapAddressAndCmdPort(BusExtension);
    if (!NT_SUCCESS(status)) {
        DebugPrint((DEBUG_ERROR, "failed to map the address and command ports\n"));
        return status;
    }

    for (i = 2, j = 0; i < StartResources->List->PartialResourceList.Count; i++, j++) {

        PipReadDataPortRanges[j].CardsFound = 0;
        // RDP possibilities that we didn't get.
        if (StartResources->List->PartialResourceList.PartialDescriptors[i].u.Port.Length == 0) {
            continue;
        }

        status = PipMapReadDataPort(
                                    BusExtension,
                                    StartResources->List->PartialResourceList.PartialDescriptors[i].u.Port.Start,
                                    StartResources->List->PartialResourceList.PartialDescriptors[i].u.Port.Length
                                    );
        if (!NT_SUCCESS(status))
        {
            DebugPrint((DEBUG_ERROR, "failed to map RDP range\n"));
            continue;
        }
    
        LastMapped = i;

        PipIsolateCards(&CardsFound);
        DebugPrint((DEBUG_STATE, "Found %d cards at RDP %x\n", CardsFound, BusExtension->ReadDataPort));

        PipReadDataPortRanges[j].CardsFound = CardsFound;

        PipWaitForKey();
    }

    if (LastMapped == -1) {     // never mapped a RDP successfully
        PipCleanupAcquiredResources(BusExtension);
        return STATUS_CONFLICTING_ADDRESSES;
    }

    //
    // Establish that we want trimmed resource requirements and that
    // we're still processing the RDP.
    // 
    ASSERT((DeviceInfo->Flags & DF_PROCESSING_RDP) == 0);
    DeviceInfo->Flags |= DF_PROCESSING_RDP|DF_REQ_TRIMMED;

    //
    // Release unwanted resources.
    //
    PipCleanupAcquiredResources(BusExtension);

    IoInvalidateDeviceState(DeviceObject);
    return STATUS_SUCCESS;
}


NTSTATUS
PipStartReadDataPort(
    PDEVICE_INFORMATION DeviceInfo,
    PPI_BUS_EXTENSION BusExtension,
    PDEVICE_OBJECT  DeviceObject,
    PCM_RESOURCE_LIST StartResources
    )
{
    NTSTATUS status;
    UCHAR CardsFound;

    if (StartResources == NULL) {
        DebugPrint((DEBUG_ERROR, "Start RDP with no resources?\n"));
        ASSERT(0);
        return STATUS_UNSUCCESSFUL;
    }

    if (StartResources->List->PartialResourceList.Count < 2) {
        DebugPrint((DEBUG_ERROR, "Start RDP with insufficient resources?\n"));
        ASSERT(0);
        return STATUS_UNSUCCESSFUL;
    }

    if (StartResources->List->PartialResourceList.Count > 3) {
        return PipStartAndSelectRdp(
                                    DeviceInfo,
                                    BusExtension,
                                    DeviceObject,
                                    StartResources
                                    );
    }

    DebugPrint((DEBUG_STATE|DEBUG_PNP,
                "Starting RDP as port %x\n",
                StartResources->List->PartialResourceList.PartialDescriptors[2].u.Port.Start.LowPart + 3));

    status = PipMapAddressAndCmdPort(BusExtension);
    if (!NT_SUCCESS(status)) {
        DebugPrint((DEBUG_ERROR, "failed to map the address and command ports\n"));
        return status;
    }

    status = PipMapReadDataPort(
        BusExtension,
        StartResources->List->PartialResourceList.PartialDescriptors[2].u.Port.Start,
        StartResources->List->PartialResourceList.PartialDescriptors[2].u.Port.Length
        );

    if (!NT_SUCCESS(status)) {
        // BUGBUG probably have to free something
        DebugPrint((DEBUG_ERROR, "failed to map RDP range\n"));
        return status;
    }
    
    PipIsolateCards(&CardsFound);
    DebugPrint((DEBUG_STATE, "Found %d cards at RDP %x, WaitForKey\n", CardsFound, BusExtension->ReadDataPort));

    DeviceInfo->Flags &= ~DF_PROCESSING_RDP;
    DeviceInfo->Flags |= DF_ACTIVATED;

    PipWaitForKey();

    return status;
}

NTSTATUS
PipCreateReadDataPortBootResources(
    IN PDEVICE_INFORMATION DeviceInfo
    )
/*++

Routine Description:

    This routine creates the CM_RESOURCE_LIST reported as a partial
    boot config for the RDP.  This ensures that the RDP start isn't
    deferred excessively.

Arguments:

    DeviceInfo - device extension for PDO

Return Value:

    STATUS_SUCCESS

    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    PCM_RESOURCE_LIST bootResources;
    PCM_PARTIAL_RESOURCE_LIST partialResList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDesc;
    ULONG bootResourcesSize, i;

    bootResourcesSize = sizeof(CM_RESOURCE_LIST) +
        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                
    bootResources = ExAllocatePool(PagedPool,
                                   bootResourcesSize);
    if (bootResources == NULL) {
         return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(bootResources, bootResourcesSize);

    bootResources->Count = 1;
    partialResList = (PCM_PARTIAL_RESOURCE_LIST)&bootResources->List[0].PartialResourceList;
    partialResList->Version = 0;
    partialResList->Revision = 0x3000;
    partialResList->Count = 2;
    partialDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)&partialResList->PartialDescriptors[0];

    for (i = 0; i < 2; i++) {
        partialDesc->Type = CmResourceTypePort;
        partialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        partialDesc->Flags = CM_RESOURCE_PORT_IO;
        if (i == 0) {
            partialDesc->u.Port.Start.LowPart = COMMAND_PORT;
        }
        else {
            partialDesc->u.Port.Start.LowPart = ADDRESS_PORT;
        }
        partialDesc->Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
        partialDesc->u.Port.Length = 1;
        partialDesc++;
    }
    DeviceInfo->BootResources = bootResources;
    DeviceInfo->BootResourcesLength = bootResourcesSize;

    return STATUS_SUCCESS;
}


NTSTATUS
PipCreateReadDataPort(
    PPI_BUS_EXTENSION BusExtension
    )
/*++

Routine Description:

    This routine isolates all the PNP ISA cards.

Arguments:

    None.

Return Value:

    Always return STATUS_UNSUCCESSFUL.

--*/
{
    NTSTATUS status;
    PUCHAR readDataPort = NULL;
    PDEVICE_INFORMATION deviceInfo;
    PDEVICE_OBJECT pdo;

    status = IoCreateDevice(PipDriverObject,
                            sizeof(PDEVICE_INFORMATION),
                            NULL,    
                            FILE_DEVICE_BUS_EXTENDER,
                            FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &pdo);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    // Create a physical device object to represent this logical function
    //
    deviceInfo = ExAllocatePoolWithTag(NonPagedPool,
                                       sizeof(DEVICE_INFORMATION),
                                       'iPnP');
    if (!deviceInfo) {
        DebugPrint((DEBUG_ERROR, "PnpIsa:failed to allocate DEVICEINFO structure\n"));
        IoDeleteDevice(pdo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    PipInitializeDeviceInfo (deviceInfo,NULL,0);

    status = PipCreateReadDataPortBootResources(deviceInfo);

    if (NT_SUCCESS(status)) {
        deviceInfo->PhysicalDeviceObject = pdo;

        //
        // Mark this node as the special read data port node
        //
        deviceInfo->Flags |= DF_ENUMERATED|DF_READ_DATA_PORT;
        deviceInfo->Flags &= ~DF_NOT_FUNCTIONING;
        deviceInfo->PhysicalDeviceObject->DeviceExtension = (PVOID)deviceInfo;
        deviceInfo->ParentDeviceExtension = BusExtension;

        PipRDPNode = deviceInfo;

        PipLockDeviceDatabase();
        PushEntryList (&BusExtension->DeviceList,
                       &deviceInfo->DeviceList
                       );
        PipUnlockDeviceDatabase();

        deviceInfo->PhysicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    } else {
        IoDeleteDevice(pdo);
        ExFreePool(deviceInfo);
    }

    return status;
}

//
// PipCheckBus and PipMinimalCheckBus enumerate the ISAPNP cards present.
// 
// PipMinimalCheckBus is used on return from hibernation to avoid
// having to make everything referenced by PipCheckBus non-pageable.
//
// Conventions:
//  * Cards are marked dead by setting their CSN to 0.
//  * Cards are marked potentially missing by setting their CSN to -1.
//    Cards that are found later in the routines have their CSNs
//    properly set, any remaining cards get their CSN set to 0.
//  * Logical devices of dead cards have the DF_NOT_FUNCTIONING flag set.
//

BOOLEAN
PipMinimalCheckBus (
    IN PPI_BUS_EXTENSION BusExtension
    )
/*++

Routine Description:

    This routine enumerates the ISAPNP cards on return from hibernate.
    It is a subset of PipCheckBus and assumes that PipCheckBus will be
    run shortly thereafter.  It deals with cards that disappear after
    hibernate or new cards that have appeared.  It's primary task is
    to put cards where they used to be before the hibernate.

Arguments:

    BusExtension - FDO extension

Return Value:

    None

--*/
{
    PDEVICE_INFORMATION deviceInfo;
    PCARD_INFORMATION cardInfo;
    PSINGLE_LIST_ENTRY cardLink, deviceLink;
    ULONG dataLength; 
    UCHAR noDevices, i;
    NTSTATUS status;
    UCHAR FoundCSNs, csn;
    PUCHAR cardData;
    BOOLEAN needsFullRescan = FALSE;

    DebugPrint((DEBUG_POWER | DEBUG_ISOLATE,
                "Minimal check bus for restore: %d CSNs expected\n",
                BusExtension->NumberCSNs
                ));

    DebugPrint((DEBUG_POWER, "reset csns in extensions\n"));

    // forget any previously issued CSNs
    cardLink = BusExtension->CardList.Next;
    while (cardLink) {
        cardInfo = CONTAINING_RECORD (cardLink, CARD_INFORMATION, CardList);
        if (cardInfo->CardSelectNumber != 0) {
            cardInfo->CardSelectNumber = 0xFF;
        }
        cardLink = cardInfo->CardList.Next;
    }

    //
    // Perform Pnp isolation process.  This will assign card select number for each
    // Pnp Isa card isolated by the system.  All the isolated cards will be left in
    // isolation state.
    //

    if (PipReadDataPort && PipCommandPort && PipAddressPort) {

        PipIsolateCards(&FoundCSNs);

        DebugPrint((DEBUG_POWER | DEBUG_ISOLATE,
                    "Minimal check bus for restore: %d cards found\n",
                    FoundCSNs));
    } else {
        //
        // If we can't enumerate (no resources) stop now
        //
        DebugPrint((DEBUG_POWER | DEBUG_ISOLATE,
                    "Minimal check bus failed, no resources\n"));
        PipWaitForKey();
        return FALSE;
    }

    //
    // For each card selected build CardInformation and DeviceInformation structures.
    //
    // PipLFSRInitiation(); BUG?

    for (csn = 1; csn <= FoundCSNs; csn++) {
        
        PipConfig(csn);
        status = PipReadCardResourceData (
                            &noDevices,
                            &cardData,
                            &dataLength);
        if (!NT_SUCCESS(status)) {

            DebugPrint((DEBUG_ERROR | DEBUG_POWER, "CSN %d gives bad resource data\n", csn));
            continue;
        }

        cardInfo = PipIsCardEnumeratedAlready(BusExtension, cardData, dataLength);
        if (!cardInfo) {
            DebugPrint((DEBUG_ERROR | DEBUG_POWER,
                        "No match for card CSN %d, turning off\n", csn));
            for (i = 0; i < noDevices; i++) {
                PipSelectDevice(i);
                PipDeactivateDevice();
            }
            needsFullRescan = TRUE;
            continue;
        }

        cardInfo->CardSelectNumber = csn;

        for (deviceLink = cardInfo->LogicalDeviceList.Next; deviceLink;
             deviceLink = deviceInfo->LogicalDeviceList.Next) {             

            deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, LogicalDeviceList);
            if (deviceInfo->Flags & DF_NOT_FUNCTIONING) {
                continue;
            }

            PipSelectDevice(deviceInfo->LogicalDeviceNumber);
            if ((deviceInfo->DevicePowerState == PowerDeviceD0) &&
                (deviceInfo->Flags & DF_ACTIVATED))
            {
                DebugPrint((DEBUG_POWER, "CSN %d/LDN %d was never powered off\n",
                            (ULONG) deviceInfo->LogicalDeviceNumber,
                            (ULONG) csn));
                PipDeactivateDevice();
                (VOID) PipSetDeviceResources(deviceInfo,
                                             deviceInfo->AllocatedResources);
                PipActivateDevice();
            } else {
                PipDeactivateDevice();
            }
        }
    }
    
    cardLink = BusExtension->CardList.Next;
    while (cardLink) {
        cardInfo = CONTAINING_RECORD (cardLink, CARD_INFORMATION, CardList);
        if (cardInfo->CardSelectNumber == 0xFF) {
            DebugPrint((DEBUG_ERROR, "Marked a card as DEAD, logical devices\n"));
            cardInfo->CardSelectNumber = 0;  // Mark it is no longer present
            deviceLink = cardInfo->LogicalDeviceList.Next;
            while (deviceLink) {
                deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, LogicalDeviceList);
                deviceInfo->Flags |= DF_NOT_FUNCTIONING;
                deviceLink = deviceInfo->LogicalDeviceList.Next;
            }
            needsFullRescan = TRUE;
        }
        cardLink = cardInfo->CardList.Next;
    }

    PipWaitForKey();

    return needsFullRescan;
}



VOID
PipCheckBus (
    IN PPI_BUS_EXTENSION BusExtension
    )
/*++

Routine Description:

    The function enumerates the bus specified by BusExtension

Arguments:

    BusExtension - supplies a pointer to the BusExtension structure of the bus
                   to be enumerated.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG objectSize;
    OBJECT_ATTRIBUTES objectAttributes;
    PUCHAR cardData;
    ULONG dataLength;
    UCHAR csn, detectedCsn = 0;
    UCHAR i, noDevices;
    USHORT irqReqFlags, irqBootFlags;
    PDEVICE_INFORMATION deviceInfo;
    PCARD_INFORMATION cardInfo;
    UCHAR tmp;
    PSINGLE_LIST_ENTRY link;
    ULONG dumpData;
    UNICODE_STRING unicodeString;
    HANDLE logConfHandle, enumHandle = NULL;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    PCM_RESOURCE_LIST cmResource;
    BOOLEAN conflictDetected,requireEdge;
    ULONG dummy, bootFlags = 0;

    PSINGLE_LIST_ENTRY deviceLink;
    PSINGLE_LIST_ENTRY cardLink;

    // mark all cards as 'maybe missing'

    cardLink = BusExtension->CardList.Next;
    while (cardLink) {
        cardInfo = CONTAINING_RECORD (cardLink, CARD_INFORMATION, CardList);
        if (cardInfo->CardSelectNumber != 0) {
            cardInfo->CardSelectNumber = 0xFF;
        }
        cardLink = cardInfo->CardList.Next;
    }

    //
    // Clear DF_ENUMERTED flag for all the devices.
    //

    deviceLink = BusExtension->DeviceList.Next;
    while (deviceLink) {
        deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);
        if (!(deviceInfo->Flags & DF_READ_DATA_PORT)) {
            deviceInfo ->Flags &= ~DF_ENUMERATED;
        }
        deviceLink = deviceInfo->DeviceList.Next;
    }

    //
    // Perform Pnp isolation process.  This will assign card select number for each
    // Pnp Isa card isolated by the system.  All the isolated cards will be left in
    // isolation state.
    //

    if (PipReadDataPort && PipCommandPort && PipAddressPort) {
        DebugPrint((DEBUG_PNP, "QueryDeviceRelations checking the BUS\n"));
        PipIsolateCards(&BusExtension->NumberCSNs);
    } else {
        //
        // If we can't enumerate (no resources) stop now
        //
        DebugPrint((DEBUG_PNP, "QueryDeviceRelations: No RDP\n"));
        return;
    }

    DebugPrint((DEBUG_PNP, "CheckBus found %d cards\n",
                BusExtension->NumberCSNs));
#if NT4_DRIVER_COMPAT

    //
    // If there is no PnpISA card, we are done.
    // Oterwise, open HKLM\System\CCS\ENUM\PNPISA.
    //

    if (BusExtension->NumberCSNs != 0) {

        RtlInitUnicodeString(
                 &unicodeString,
                 L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\ENUM");
        status = PipOpenRegistryKey(&enumHandle,
                                    NULL,
                                    &unicodeString,
                                    KEY_READ,
                                    FALSE
                                    );
        if (!NT_SUCCESS(status)) {
            dumpData = status;
            PipLogError(PNPISA_OPEN_CURRENTCONTROLSET_ENUM_FAILED,
                        PNPISA_CHECKDEVICE_1,
                        status,
                        &dumpData,
                        1,
                        0,
                        NULL
                        );

            DebugPrint((DEBUG_ERROR, "PnPIsa: Unable to open HKLM\\SYSTEM\\CCS\\ENUM"));
            return;
        }
    }

#endif // NT4_DRIVER_COMPAT

    //
    // For each card selected build CardInformation and DeviceInformation structures.
    //

    for (csn = 1; csn <= BusExtension->NumberCSNs; csn++) {

        PipConfig(csn);
        status = PipReadCardResourceData (
                            &noDevices,
                            &cardData,
                            &dataLength);
        if (!NT_SUCCESS(status)) {
            //
            // card will marked 'not functioning' later
            //
            DebugPrint((DEBUG_ERROR, "PnpIsaCheckBus: Found a card which gives bad resource data\n"));
            continue;
        }

        detectedCsn++;

        cardInfo = PipIsCardEnumeratedAlready(BusExtension, cardData, dataLength);

        if (!cardInfo) {

            //
            // Allocate and initialize card information and its associate device
            // information structures.
            //

            cardInfo = (PCARD_INFORMATION)ExAllocatePoolWithTag(
                                                  NonPagedPool,
                                                  sizeof(CARD_INFORMATION),
                                                  'iPnP');
            if (!cardInfo) {
                dumpData = sizeof(CARD_INFORMATION);
                PipLogError(PNPISA_INSUFFICIENT_POOL,
                            PNPISA_CHECKBUS_1,
                            STATUS_INSUFFICIENT_RESOURCES,
                            &dumpData,
                            1,
                            0,
                            NULL
                            );

                ExFreePool(cardData);
                DebugPrint((DEBUG_ERROR, "PnpIsaCheckBus: failed to allocate CARD_INFO structure\n"));
                continue;
            }

            //
            // Initialize card information structure
            //

            RtlZeroMemory(cardInfo, sizeof(CARD_INFORMATION));
            cardInfo->CardSelectNumber = csn;
            cardInfo->NumberLogicalDevices = noDevices;
            cardInfo->CardData = cardData;
            cardInfo->CardDataLength = dataLength;
            cardInfo->CardFlags = PipGetCardFlags(cardInfo);

            PushEntryList (&BusExtension->CardList,
                           &cardInfo->CardList
                           );
            DebugPrint ((DEBUG_ISOLATE, "adding one pnp card %x\n",
                         cardInfo));

            //
            // For each logical device supported by the card build its DEVICE_INFORMATION
            // structures.
            //

            cardData += sizeof(SERIAL_IDENTIFIER);
            dataLength -= sizeof(SERIAL_IDENTIFIER);
            PipFindNextLogicalDeviceTag(&cardData, &dataLength);

            //
            // Select card
            //

            for (i = 0; i < noDevices; i++) {       // logical device number starts from 0

                //
                // Create and initialize device tracking structure (Device_Information.)
                //

                deviceInfo = (PDEVICE_INFORMATION) ExAllocatePoolWithTag(
                                                     NonPagedPool,
                                                     sizeof(DEVICE_INFORMATION),
                                                     'iPnP');
                if (!deviceInfo) {
                    dumpData = sizeof(DEVICE_INFORMATION);
                    PipLogError(PNPISA_INSUFFICIENT_POOL,
                                PNPISA_CHECKBUS_2,
                                STATUS_INSUFFICIENT_RESOURCES,
                                &dumpData,
                                1,
                                0,
                                NULL
                                );

                    DebugPrint((DEBUG_ERROR, "PnpIsa:failed to allocate DEVICEINFO structure\n"));
                    continue;
                }

                //
                // This sets card data to point to the next device.
                //
                PipInitializeDeviceInfo (deviceInfo,cardInfo,i);

                deviceInfo->ParentDeviceExtension = BusExtension;

                //
                // cardData is UPDATED by this routine to the next logical device.
                //
                deviceInfo->DeviceData = cardData;
                if (cardData) {
                    deviceInfo->DeviceDataLength = PipFindNextLogicalDeviceTag(&cardData, &dataLength);
                } else {
                    deviceInfo->DeviceDataLength = 0;
                    ASSERT(deviceInfo->DeviceDataLength != 0);
                    continue;
                }

                ASSERT(deviceInfo->DeviceDataLength != 0);

                // 
                // The PNP ISA spec lets the device specify IRQ
                // settings that don't actually work, and some that
                // work rarely.  And some devices just get it wrong.
                //
                // IRQ edge/level interpretation strategy:
                //
                // * Extract the irq requirements from the tags on a
                // per device basis.
                // * Extract the boot config, note edge/level settings
                // * Trust the boot config over requirements.  When in
                // doubt, assume edge.
                // * Fix boot config and requirements to reflect the
                // edge/level settings we've decided upon.
                // * Ignore the high/low settings in the requirements
                // and in the boot config.  Only support high- // edge
                // and low-level.
                //
                
                // Determine whether requirements specify edge or
                // level triggered interrupts.  Unfortunately, we
                // don't build the IO_REQUIREMENTS_LIST until later,
                // so just examine the tags.

                irqReqFlags = PipIrqLevelRequirementsFromDeviceData(
                    deviceInfo->DeviceData,
                    deviceInfo->DeviceDataLength
                    );

                DebugPrint((DEBUG_IRQ, "Irqs for CSN %d/LDN %d are %s\n",
                            deviceInfo->CardInformation->CardSelectNumber,
                            deviceInfo->LogicalDeviceNumber,
                            (irqReqFlags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) ? "level" : "edge"));

                //
                // Select the logical device, disable its io range check
                // and read its boot config before disabling it.
                //

                PipSelectDevice(i);
                if (!(deviceInfo->CardInformation->CardFlags & CF_IGNORE_BOOTCONFIG)) {
                    status = PipReadDeviceResources (
                        0,
                        deviceInfo->DeviceData,
                        deviceInfo->CardInformation->CardFlags,
                        &deviceInfo->BootResources,
                        &deviceInfo->BootResourcesLength,
                        &irqBootFlags
                        );
                    if (!NT_SUCCESS(status)) {
                        deviceInfo->BootResources = NULL;
                        deviceInfo->BootResourcesLength = 0;

                        // If we had a boot config on this boot,
                        // extract saved irqBootFlags that we saved earlier.
                        status = PipGetBootIrqFlags(deviceInfo, &irqBootFlags);
                        if (!NT_SUCCESS(status)) {
                            // if we have no boot config, and no saved
                            // boot config from earlier this boot then
                            // we are going to take a shot in the dark
                            // and declare it edge.  Experience has
                            // shown that if you actually believe
                            // resource requirements of level w/o
                            // confirmation from the BIOS, then you
                            // die horribly.  Very very few cards
                            // actually do level and do it right.

                            irqBootFlags = CM_RESOURCE_INTERRUPT_LATCHED;
                            (VOID) PipSaveBootIrqFlags(deviceInfo, irqBootFlags);
                        }
                    } else {
                        // save irqBootFlags in case the RDP gets
                        // removed and our boot config is lost.
                        (VOID) PipSaveBootIrqFlags(deviceInfo, irqBootFlags);
                    }
                    
                    DebugPrint((DEBUG_IRQ, "Irqs (boot config) for CSN %d/LDN %d are %s\n",
                            deviceInfo->CardInformation->CardSelectNumber,
                            deviceInfo->LogicalDeviceNumber,
                            (irqBootFlags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) ? "level" : "edge"));
                } else {
                    // when in doubt....
                    irqBootFlags = CM_RESOURCE_INTERRUPT_LATCHED;
                }
                
                if (irqBootFlags != irqReqFlags) {
                    DebugPrint((DEBUG_IRQ, "Req and Boot config disagree on irq type, favoring boot config"));
                    irqReqFlags = irqBootFlags;
                }

                // override flags in case a card *MUST* be configured
                // one way and the above code fails to do this.
                if (deviceInfo->CardInformation->CardFlags == CF_FORCE_LEVEL) {
                    irqReqFlags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
                } else if (deviceInfo->CardInformation->CardFlags == CF_FORCE_EDGE) {
                    irqReqFlags = CM_RESOURCE_INTERRUPT_LATCHED;
                }

                if (deviceInfo->BootResources) {
                    // apply irq level/edge decision to boot config
                    PipFixBootConfigIrqs(deviceInfo->BootResources,
                                     irqReqFlags);
                    (VOID) PipSaveBootResources(deviceInfo);
                    cmResource = deviceInfo->BootResources;
                } else {
                   status = PipGetSavedBootResources(deviceInfo, &cmResource);
                   if (!NT_SUCCESS(status)) {
                       cmResource = NULL;
                   }
                }

                PipDeactivateDevice();

                PipQueryDeviceResourceRequirements (
                    deviceInfo,
                    0,             // Bus Number
                    0,             // Slot number??
                    cmResource,
                    irqReqFlags,
                    &deviceInfo->ResourceRequirements,
                    &dumpData
                    );

                if (cmResource && !deviceInfo->BootResources) {
                    ExFreePool(cmResource);
                    cmResource = NULL;
                }

                //
                // Create a physical device object to represent this logical function
                //
                status = IoCreateDevice( PipDriverObject,
                                         sizeof(PDEVICE_INFORMATION),
                                         NULL,
                                         FILE_DEVICE_BUS_EXTENDER,
                                         FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
                                         FALSE,
                                         &deviceInfo->PhysicalDeviceObject);
                if (NT_SUCCESS(status)) {
                    deviceInfo->Flags |= DF_ENUMERATED;
                    deviceInfo->Flags &= ~DF_NOT_FUNCTIONING;
                    deviceInfo->PhysicalDeviceObject->DeviceExtension = (PVOID)deviceInfo;
                    //
                    // Add it to the logical device list of the pnp isa card.
                    //

                    PushEntryList (&cardInfo->LogicalDeviceList,
                                   &deviceInfo->LogicalDeviceList
                                   );

                    //
                    // Add it to the list of devices for this bus
                    //

                    PushEntryList (&BusExtension->DeviceList,
                                   &deviceInfo->DeviceList
                                   );

#if NT4_DRIVER_COMPAT

                    //
                    // Check should we enable this device.  If the device has
                    // Service setup and ForcedConfig then enable the device.
                    //

                    logConfHandle = NULL;
                    status = PipGetInstalledLogConf(enumHandle,
                                               deviceInfo,
                                               &logConfHandle);
                    if (NT_SUCCESS(status)) {
                                //
                                // Read the boot config selected by user and activate the device.
                                // First check if ForcedConfig is set.  If not, check BootConfig.
                                //

                        status = PipGetRegistryValue(logConfHandle,
                                                     L"ForcedConfig",
                                                     &keyValueInformation);
                        if (NT_SUCCESS(status)) {
                            if ((keyValueInformation->Type == REG_RESOURCE_LIST) &&
                                (keyValueInformation->DataLength != 0) &&
                                (NT_SUCCESS(PipValidateResourceList((PCM_RESOURCE_LIST)KEY_VALUE_DATA(keyValueInformation),
                                                                    keyValueInformation->DataLength
                                                                    )))) {

                                cmResource = (PCM_RESOURCE_LIST)
                                    KEY_VALUE_DATA(keyValueInformation);
                                
                                //
                                // Act as if force config
                                // reflected the level/edge
                                // decision we made based on
                                // the boot config and
                                // resource requirements.
                                //
                                        
                                PipFixBootConfigIrqs(cmResource,
                                                     irqReqFlags);
                                        
                                conflictDetected = FALSE;

                                //
                                // Before activating the device, make sure no one is using
                                // the resources.
                                //

                                status = IoReportResourceForDetection(
                                    PipDriverObject,
                                    NULL,
                                    0,
                                    deviceInfo->PhysicalDeviceObject,
                                    cmResource,
                                    keyValueInformation->DataLength,
                                    &conflictDetected
                                    );
                                if (NT_SUCCESS(status) && (conflictDetected == FALSE)) {

                                    //
                                    // Set resources and activate the device.
                                    //

                                    status = PipSetDeviceResources (deviceInfo, cmResource);
                                    if (NT_SUCCESS(status)) {
                                        PipActivateDevice();
                                        deviceInfo->Flags |= DF_ACTIVATED;
                                        deviceInfo->Flags &= ~DF_REMOVED;

                                        //
                                        // Write ForcedConfig to AllocConfig
                                        //

                                        RtlInitUnicodeString(&unicodeString, L"AllocConfig");
                                        ZwSetValueKey(logConfHandle,
                                                      &unicodeString,
                                                      0,
                                                      REG_RESOURCE_LIST,
                                                      cmResource,
                                                      keyValueInformation->DataLength
                                                      );

                                        //
                                        // Make ForcedConfig our new BootConfig.
                                        //

                                        if (deviceInfo->BootResources) {
                                            ExFreePool(deviceInfo->BootResources);
                                            deviceInfo->BootResourcesLength = 0;
                                            deviceInfo->BootResources = NULL;
                                        }
                                        deviceInfo->BootResources = (PCM_RESOURCE_LIST) ExAllocatePool (
                                            PagedPool, keyValueInformation->DataLength);
                                        if (deviceInfo->BootResources) {
                                            deviceInfo->BootResourcesLength = keyValueInformation->DataLength;
                                            RtlMoveMemory(deviceInfo->BootResources,
                                                          cmResource,
                                                          deviceInfo->BootResourcesLength
                                                          );
                                        }
                                        deviceInfo->DevicePowerState = PowerDeviceD0;
                                        deviceInfo->LogConfHandle = logConfHandle;
                                    }

                                    //
                                    // Release the resources.  If someone else gets the resources
                                    // before us, then ....
                                    //

                                    dummy = 0;
                                    IoReportResourceForDetection(
                                        PipDriverObject,
                                        NULL,
                                        0,
                                        deviceInfo->PhysicalDeviceObject,
                                        (PCM_RESOURCE_LIST) &dummy,
                                        sizeof(dummy),
                                        &conflictDetected
                                        );
                                }
                            }
                            ExFreePool(keyValueInformation);
                        }
                        if (deviceInfo->LogConfHandle == NULL) {
                            ZwClose(logConfHandle);
                        }
                    }
#endif
                    deviceInfo->PhysicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
                } else {
                    // NTRAID#20181
                    // Still leaking the DeviceInfo structure
                    // and it's contents if IoCreateDevice failed.
                }
            }
        } else {

            //
            // The card has been enumerated and setup.  We only need to change the CSN.
            //

            cardInfo->CardSelectNumber = csn;
            ExFreePool(cardData);

            //
            // Set DF_ENUMERATED flag on all the logical devices on the isapnp card.
            //

            deviceLink = cardInfo->LogicalDeviceList.Next;
            while (deviceLink) {
                deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, LogicalDeviceList);
                if (!(deviceInfo->Flags & DF_NOT_FUNCTIONING)) {
                    deviceInfo->Flags |= DF_ENUMERATED;
                }
                // what did this accomplish?
                if ((deviceInfo->DevicePowerState == PowerDeviceD0) &&
                    (deviceInfo->Flags & DF_ACTIVATED)) {                
                    PipSelectDevice(deviceInfo->LogicalDeviceNumber);
                    PipActivateDevice();
                }
                deviceLink = deviceInfo->LogicalDeviceList.Next;
            }
        }
    }

    //
    // Go through the card link list for cards that we didn't find this time.
    //

    cardLink = BusExtension->CardList.Next;
    while (cardLink) {
        cardInfo = CONTAINING_RECORD (cardLink, CARD_INFORMATION, CardList);
        if (cardInfo->CardSelectNumber == 0xFF) {
            DebugPrint((DEBUG_ERROR, "Marked a card as DEAD, logical devices\n"));
            cardInfo->CardSelectNumber = 0;  // Mark it is no longer present
            deviceLink = cardInfo->LogicalDeviceList.Next;
            while (deviceLink) {
                deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, LogicalDeviceList);
                deviceInfo->Flags |= DF_NOT_FUNCTIONING;
                deviceInfo->Flags &= ~DF_ENUMERATED;
                deviceLink = deviceInfo->LogicalDeviceList.Next;
            }
        }
        cardLink = cardInfo->CardList.Next;
    }

#if NT4_DRIVER_COMPAT
    if (enumHandle) {
        ZwClose(enumHandle);
    }
#endif
    //
    // Finaly put all cards into wait for key state.
    //

    DebugPrint((DEBUG_STATE, "All cards ready\n"));
    PipWaitForKey();

    BusExtension->NumberCSNs = detectedCsn;
}

BOOLEAN
PipIsDeviceInstanceInstalled(
    IN HANDLE Handle,
    IN PUNICODE_STRING DeviceInstanceName
    )

/*++

Routine Description:

    This routine checks if the device instance is installed.

Arguments:

    Handle - Supplies a handle to the device instanace key to be checked.

    DeviceInstanceName - supplies a pointer to a UNICODE_STRING which specifies
             the path of the device instance to be checked.

Returns:

    A BOOLEAN value.

--*/

{
    NTSTATUS status;
    ULONG deviceFlags;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    BOOLEAN installed;
    UNICODE_STRING serviceName, unicodeString;
    HANDLE handle, handlex;
    ULONG dumpData;

    //
    // Check if the "Service=" value entry initialized.  If no, its driver
    // is not installed yet.
    //
    status = PipGetRegistryValue(Handle,
                                 L"Service",
                                 &keyValueInformation);
    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_SZ) &&
            (keyValueInformation->DataLength != 0)) {
            serviceName.Buffer = (PWSTR)((PCHAR)keyValueInformation +
                                         keyValueInformation->DataOffset);
            serviceName.MaximumLength = serviceName.Length = (USHORT)keyValueInformation->DataLength;
            if (serviceName.Buffer[(keyValueInformation->DataLength / sizeof(WCHAR)) - 1] == UNICODE_NULL) {
                serviceName.Length -= sizeof(WCHAR);
            }

            //
            // try open the service key to make sure it is a valid key
            //

            RtlInitUnicodeString(
                     &unicodeString,
                     L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES");
            status = PipOpenRegistryKey(&handle,
                                        NULL,
                                        &unicodeString,
                                        KEY_READ,
                                        FALSE
                                        );
            if (!NT_SUCCESS(status)) {
                dumpData = status;
                PipLogError(PNPISA_OPEN_CURRENTCONTROLSET_SERVICE_FAILED,
                            PNPISA_CHECKINSTALLED_1,
                            status,
                            &dumpData,
                            1,
                            0,
                            NULL
                            );

                DebugPrint((DEBUG_ERROR, "PnPIsaCheckDeviceInstalled: Can not open CCS\\SERVICES key"));
                ExFreePool(keyValueInformation);
                return FALSE;
            }

            status = PipOpenRegistryKey(&handlex,
                                        handle,
                                        &serviceName,
                                        KEY_READ,
                                        FALSE
                                        );
            ZwClose (handle);
            if (!NT_SUCCESS(status)) {
                dumpData = status;
                PipLogError(PNPISA_OPEN_CURRENTCONTROLSET_SERVICE_DRIVER_FAILED,
                            PNPISA_CHECKINSTALLED_2,
                            status,
                            &dumpData,
                            1,
                            serviceName.Length,
                            serviceName.Buffer
                            );

                DebugPrint((DEBUG_ERROR, "PnPIsaCheckDeviceInstalled: Can not open CCS\\SERVICES key"));
                ExFreePool(keyValueInformation);
                return FALSE;
            }
            ZwClose(handlex);
        }
        ExFreePool(keyValueInformation);
    } else {
        return FALSE;
    }

    //
    // Check if the device instance has been disabled.
    // First check global flag: CONFIGFLAG and then CSCONFIGFLAG.
    //

    deviceFlags = 0;
    status = PipGetRegistryValue(Handle,
                                 L"ConfigFlags",
                                 &keyValueInformation);
    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength >= sizeof(ULONG))) {
            deviceFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }

    if (!(deviceFlags & CONFIGFLAG_DISABLED)) {
        deviceFlags = 0;
        status = PipGetDeviceInstanceCsConfigFlags(
                     DeviceInstanceName,
                     &deviceFlags
                     );
        if (NT_SUCCESS(status)) {
            if ((deviceFlags & CSCONFIGFLAG_DISABLED) ||
                (deviceFlags & CSCONFIGFLAG_DO_NOT_CREATE)) {
                deviceFlags = CONFIGFLAG_DISABLED;
            } else {
                deviceFlags = 0;
            }
        }
    }

    installed = TRUE;
    if (deviceFlags & CONFIGFLAG_DISABLED) {
        installed = FALSE;
    }

    return installed;
}

VOID
PipInitializeDeviceInfo (PDEVICE_INFORMATION deviceInfo,
                                 PCARD_INFORMATION cardInfo,
                                 UCHAR index
                                )
{
    ULONG dataLength;

    RtlZeroMemory (deviceInfo,sizeof (DEVICE_INFORMATION));
    deviceInfo->Flags = DF_NOT_FUNCTIONING;
    deviceInfo->CardInformation = cardInfo;
    deviceInfo->LogicalDeviceNumber = index;
    deviceInfo->DevicePowerState = PowerDeviceD0;
}


#if NT4_DRIVER_COMPAT

NTSTATUS
PipGetInstalledLogConf(
    IN HANDLE EnumHandle,
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PHANDLE LogConfHandle
)
{
    HANDLE deviceIdHandle = NULL, uniqueIdHandle = NULL, confHandle = NULL;
    PWCHAR deviceId = NULL, uniqueId = NULL, buffer;
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    ULONG length;
    ULONG deviceIdLength, uniqueIdLength;
    
    status = PipQueryDeviceId(DeviceInfo, &deviceId, &deviceIdLength, 0);
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }

    RtlInitUnicodeString(&unicodeString, deviceId);
    status = PipOpenRegistryKey(&deviceIdHandle,
                                EnumHandle,
                                &unicodeString,
                                KEY_READ,
                                FALSE
                                );
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }

    status = PipQueryDeviceUniqueId(DeviceInfo, &uniqueId, &uniqueIdLength);
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }


    //
    // Open this registry path under HKLM\CCS\System\Enum
    //

    RtlInitUnicodeString(&unicodeString, uniqueId);
    status = PipOpenRegistryKey(&uniqueIdHandle,
                                deviceIdHandle,
                                &unicodeString,
                                KEY_READ,
                                FALSE
                                );
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }

    RtlInitUnicodeString(&unicodeString, L"LogConf");
    status = PipOpenRegistryKey(&confHandle,
                                uniqueIdHandle,
                                &unicodeString,
                                KEY_READ | KEY_WRITE,
                                FALSE
                                );
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }

    // allocate enough space for "deviceid\uniqueid<unicode null>"
    length = deviceIdLength + uniqueIdLength + sizeof(L'\\') + sizeof(UNICODE_NULL);
    
    buffer = ExAllocatePool(PagedPool, length);
    if (buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (FAILED(StringCbPrintf(buffer, length,
                              L"%s\\%s", deviceId, uniqueId))) {
        status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    RtlInitUnicodeString(&unicodeString, buffer);

    if (PipIsDeviceInstanceInstalled(uniqueIdHandle, &unicodeString)) {
        status = STATUS_SUCCESS;
        *LogConfHandle = confHandle;
    } else {
        status = STATUS_UNSUCCESSFUL;
    }

    ExFreePool(buffer);

Cleanup:
    if (uniqueIdHandle) {
        ZwClose(uniqueIdHandle);
    }

    if (uniqueId) {
        ExFreePool(uniqueId);
    }

    if (deviceIdHandle) {
        ZwClose(deviceIdHandle);
    }

    if (deviceId) {
        ExFreePool(deviceId);
    }

    if (!NT_SUCCESS(status)) {
        *LogConfHandle = NULL;
        if (confHandle) {
            ZwClose(confHandle);
        }
    }

    return status;
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\busp.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    busp.h

Abstract:

    Hardware independent header file for Pnp Isa bus extender.

Author:

    Shie-Lin Tzong (shielint) July-26-1995

Environment:

    Kernel mode only.

Revision History:

--*/
#ifndef _IN_KERNEL_
#define _IN_KERNEL_
#endif

#include <stdio.h>
#include <ntddk.h>
#include <stdarg.h>
#include <regstr.h>
#include <strsafe.h>
#include "message.h"

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'pasI')
#endif

//
// Turn this on to track resource start/stop printfs
//
#define VERBOSE_DEBUG 1

//
// ISOLATE_CARDS enables the code that actually isolates ISAPNP
// devices.  WIth this turned off, all aspects of ISAPNP are disabled except
// ejecting an ISA Interrupt translator.  This is intended for
// circumstances in which we aren't sure if we can get ISAPNP not to
// load at all but for which we want ISAPNP not to isolate ISAPNP
// cards i.e Win64
//

#if defined(_WIN64)
#define ISOLATE_CARDS 0
#else
#define ISOLATE_CARDS 1
#endif

//
// NT4_DRIVER_COMPAT enables the code which checks if a force config
// is installed for an ISA pnp device.  If yes, isapnp.sys will
// activate the device.  Else, the device is deactivated until isapnp
// receives a start irp.  This supports NT4 PNPISA drivers that expect
// to find the device activated at the 'force config' that was created
// when the driver was installed.
//

#define NT4_DRIVER_COMPAT 1
#define BOOT_CONFIG_PRIORITY   0x2000
#define KEY_VALUE_DATA(k) ((PCHAR)(k) + (k)->DataOffset)

//
// Define PnpISA driver unique error code to specify where the error was reported.
//

#define PNPISA_INIT_ACQUIRE_PORT_RESOURCE  0x01
#define PNPISA_INIT_MAP_PORT               0x02
#define PNPISA_ACQUIREPORTRESOURCE_1       0x10
#define PNPISA_ACQUIREPORTRESOURCE_2       0x11
#define PNPISA_ACQUIREPORTRESOURCE_3       0x12
#define PNPISA_CHECKBUS_1                  0x20
#define PNPISA_CHECKBUS_2                  0x21
#define PNPISA_CHECKDEVICE_1               0x30
#define PNPISA_CHECKDEVICE_2               0x31
#define PNPISA_CHECKDEVICE_3               0x32
#define PNPISA_CHECKDEVICE_4               0x33
#define PNPISA_CHECKDEVICE_5               0x34
#define PNPISA_CHECKINSTALLED_1            0x40
#define PNPISA_CHECKINSTALLED_2            0x41
#define PNPISA_CHECKINSTALLED_3            0x42
#define PNPISA_BIOSTONTRESOURCES_1         0x50
#define PNPISA_BIOSTONTRESOURCES_2         0x51
#define PNPISA_BIOSTONTRESOURCES_3         0x52
#define PNPISA_BIOSTONTRESOURCES_4         0x53
#define PNPISA_READBOOTRESOURCES_1         0x60
#define PNPISA_READBOOTRESOURCES_2         0x61
#define PNPISA_CLEANUP_1                   0x70


#define ISAPNP_IO_VERSION 1
#define ISAPNP_IO_REVISION 1
//
// Structures
//

//
// Extension data for Bus extender
//

typedef struct _PI_BUS_EXTENSION {

    //
    // Flags
    //

    ULONG Flags;

    //
    // Number of cards selected
    //

    UCHAR NumberCSNs;

    //
    // ReadDataPort addr
    //

    PUCHAR ReadDataPort;
    BOOLEAN DataPortMapped;

    //
    // Address Port
    //

    PUCHAR AddressPort;
    BOOLEAN AddrPortMapped;

    //
    // Command port
    //

    PUCHAR CommandPort;
    BOOLEAN CmdPortMapped;

    //
    // Next Slot Number to assign
    //

    ULONG NextSlotNumber;

    //
    // DeviceList is the DEVICE_INFORMATION link list.
    //

    SINGLE_LIST_ENTRY DeviceList;

    //
    // CardList is the list of CARD_INFORMATION
    //

    SINGLE_LIST_ENTRY CardList;

    //
    // Physical device object
    //

    PDEVICE_OBJECT PhysicalBusDevice;

    //
    // Functional device object
    //

    PDEVICE_OBJECT FunctionalBusDevice;

    //
    // Attached Device object
    //

    PDEVICE_OBJECT AttachedDevice;

    //
    // Bus Number
    //

    ULONG BusNumber;

    //
    // Power management data
    //

    //
    // System Power state of the device
    //

    SYSTEM_POWER_STATE SystemPowerState;

    //
    // Device power state of the device
    //

    DEVICE_POWER_STATE DevicePowerState;

} PI_BUS_EXTENSION, *PPI_BUS_EXTENSION;

//
// CARD_INFORMATION Flags masks
//

typedef struct _CARD_INFORMATION_ {

    //
    // Next points to next CARD_INFORMATION structure
    //

    SINGLE_LIST_ENTRY CardList;

    //
    // Card select number for this Pnp Isa card.
    //

    UCHAR CardSelectNumber;

    //
    // Number logical devices in the card.
    //

    UCHAR NumberLogicalDevices;

    //
    // Logical device link list
    //

    SINGLE_LIST_ENTRY LogicalDeviceList;

    //
    // Pointer to card data which includes:
    //     9 byte serial identifier for the pnp isa card
    //     PlugPlay Version number type for the pnp isa card
    //     Identifier string resource type for the pnp isa card
    //     Logical device Id resource type (repeat for each logical device)
    //

    PVOID CardData;
    ULONG CardDataLength;

    // Flags for card-specific workarounds

    ULONG CardFlags;

} CARD_INFORMATION, *PCARD_INFORMATION;

//
// DEVICE_INFORMATION Flags masks
//

typedef struct _DEVICE_INFORMATION_ {

    //
    // Flags
    //

    ULONG Flags;

    //
    // Device power state of the device
    //

    DEVICE_POWER_STATE DevicePowerState;

    //
    // The device object of the device extension. I.e. the PDO
    //

    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // The isapnp bus extension which owns this device.
    //

    PPI_BUS_EXTENSION ParentDeviceExtension;

    //
    // Link list for ALL the Pnp Isa logical devices.
    // NextDevice points to next DEVICE_INFORMATION structure
    //

    SINGLE_LIST_ENTRY DeviceList;

    //
    // ResourceRequirements list
    //

    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements;

    //
    // Pointer to the CARD_INFORMATION for this device
    //

    PCARD_INFORMATION CardInformation;

    //
    // Link list for all the logical devices in a Pnp Isa card.
    //

    SINGLE_LIST_ENTRY LogicalDeviceList;

    //
    // LogicalDeviceNumber selects the corresponding logical device in the
    // pnp isa card specified by CSN.
    //

    UCHAR LogicalDeviceNumber;

    //
    // Pointer to device specific data
    //

    PUCHAR DeviceData;

    //
    // Length of the device data
    //

    ULONG DeviceDataLength;

    //
    // Boot resources
    //

    PCM_RESOURCE_LIST BootResources;
    ULONG BootResourcesLength;

    //
    // AllocatedResources
    //

    PCM_RESOURCE_LIST AllocatedResources;

    //
    // LogConfHandle - the LogConfHandle whose AllocatedResources needs to be deleted on removal irp.
    //

    HANDLE LogConfHandle;

    // Counts of how many paging and crash dump paths
    // this device is on.
    LONG Paging, CrashDump;

} DEVICE_INFORMATION, *PDEVICE_INFORMATION;

//
// IRP dispatch routines
//
typedef
NTSTATUS
(*PPI_DISPATCH)(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );



//
// These must be updated if any new PNP or PO IRPs are added
//



#define IRP_MN_PNP_MAXIMUM_FUNCTION IRP_MN_QUERY_LEGACY_BUS_INFORMATION
#define IRP_MN_PO_MAXIMUM_FUNCTION  IRP_MN_QUERY_POWER

//
// Flags definitions of DEVICE_INFORMATION and BUS_EXTENSION
//

#define DF_DELETED          0x00000001
#define DF_REMOVED          0X00000002
#define DF_NOT_FUNCTIONING  0x00000004
#define DF_ENUMERATED       0x00000008
#define DF_ACTIVATED        0x00000010
#define DF_QUERY_STOPPED    0x00000020
#define DF_SURPRISE_REMOVED 0x00000040
#define DF_PROCESSING_RDP   0x00000080
#define DF_STOPPED          0x00000100
#define DF_RESTARTED_MOVED  0x00000200
#define DF_RESTARTED_NOMOVE 0x00000400
#define DF_REQ_TRIMMED      0x00000800
#define DF_NEEDS_RESCAN     0x00001000
#define DF_READ_DATA_PORT   0x40000000
#define DF_BUS              0x80000000

//
// Flags definitions for card-related hacks
//
//

#define CF_ISOLATION_BROKEN  0x00000001 /* once started, isolation is broken */
#define CF_IGNORE_BOOTCONFIG 0x00000002 /* unusually sensitive to bad bioses */
#define CF_FORCE_LEVEL       0x00000004 /* force level triggered interrupt */
#define CF_FORCE_EDGE        0x00000008 /* force edge triggered interrupt */
#define CF_IBM_MEMBOOTCONFIG 0x00000010 /* bad register on ibm isapnp token ring */

// Possible bus states

typedef enum  {
    PiSUnknown,                    // not sure of exact state
    PiSWaitForKey,                 //
    PiSSleep,                      //
    PiSIsolation,                  // performing isolation sequence
    PiSConfig,                     // one card in config
} PNPISA_STATE;


//
// The read data port range is from 0x200 - 0x3ff.
// We will try the following optimal ranges first
// if they all fail, we then pick any port from 0x200 - 0x3ff
//
// BEST:
//   One 4-byte range in 274-2FF
//   One 4-byte range in 374-3FF
//   One 4-byte range in 338-37F
//   One 4-byte range in 238-27F
//
// NORMAL:
//   One 4-byte range in 200-3FF
//

#define READ_DATA_PORT_RANGE_CHOICES 6

typedef struct _READ_DATA_PORT_RANGE {
    ULONG MinimumAddress;
    ULONG MaximumAddress;
    ULONG Alignment;
    UCHAR CardsFound;
} READ_DATA_PORT_RANGE, *PREAD_DATA_PORT_RANGE;

//
// List node for Bus Extensions.
//
typedef struct _BUS_EXTENSION_LIST {
    PVOID Next;
    PPI_BUS_EXTENSION BusExtension;
} BUS_EXTENSION_LIST, *PBUS_EXTENSION_LIST;
//
// Constanct to control PipSelectLogicalDevice
//

#define SELECT_AND_ACTIVATE     0x1
#define SELECT_AND_DEACTIVATE   0x2
#define SELECT_ONLY             0x3

//
// Global Data references
//

extern PDRIVER_OBJECT           PipDriverObject;
extern UNICODE_STRING           PipRegistryPath;
extern PUCHAR                   PipReadDataPort;
extern PUCHAR                   PipAddressPort;
extern PUCHAR                   PipCommandPort;
extern READ_DATA_PORT_RANGE     PipReadDataPortRanges[];
extern KEVENT                   PipDeviceTreeLock;
extern KEVENT                   IsaBusNumberLock;
extern ULONG                    BusNumber;
extern ULONG                    ActiveIsaCount;
extern PBUS_EXTENSION_LIST      PipBusExtension;
extern ULONG                    BusNumberBuffer[];
extern RTL_BITMAP               BusNumBMHeader;
extern PRTL_BITMAP              BusNumBM;
extern PDEVICE_INFORMATION      PipRDPNode;
extern USHORT                   PipFirstInit;
extern PPI_DISPATCH             PiPnpDispatchTableFdo[];
extern PPI_DISPATCH             PiPnpDispatchTablePdo[];
extern ULONG                    PipDebugMask;
extern PNPISA_STATE             PipState;
extern BOOLEAN                  PipIsolationDisabled;

//
// Devnode / compat ID for the RDP
//
#define wReadDataPort (L"ReadDataPort")
#define IDReadDataPort (L"PNPRDP")
//
// Global strings
//

#define DEVSTR_PNPISA_DEVICE_NAME  (L"\\Device\\PnpIsa_Fdo_0")
#define BRIDGE_CHECK_KEY (L"DeferBridge")

extern WCHAR rgzPNPISADeviceName[sizeof(DEVSTR_PNPISA_DEVICE_NAME)/sizeof(WCHAR)];



//
// Prototypes
//

NTSTATUS
PipPassIrp(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
    );

VOID
PipCompleteRequest(
    IN OUT PIRP Irp,
    IN NTSTATUS Status,
    IN PVOID Information
    );


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PiUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
PipGetReadDataPort(
    PPI_BUS_EXTENSION BusExtension
    );

NTSTATUS
PiAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PiDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchPnpFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchPnpPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchDevCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PipGetCardIdentifier (
    PUCHAR CardData,
    PWCHAR *Buffer,
    PULONG BufferLength
    );

NTSTATUS
PipGetFunctionIdentifier (
    PUCHAR DeviceData,
    PWCHAR *Buffer,
    PULONG BufferLength
    );

NTSTATUS
PipQueryDeviceUniqueId (
    PDEVICE_INFORMATION DeviceInfo,
    PWCHAR *DeviceId,
    PULONG DeviceIdLength
    );

NTSTATUS
PipQueryDeviceId (
    PDEVICE_INFORMATION DeviceInfo,
    PWCHAR *DeviceId,
    PULONG DeviceIdLength,
    ULONG IdIndex
    );

NTSTATUS
PipQueryDeviceResources (
    PDEVICE_INFORMATION DeviceInfo,
    ULONG BusNumber,
    PCM_RESOURCE_LIST *CmResources,
    PULONG Length
    );

NTSTATUS
PipQueryDeviceResourceRequirements (
    PDEVICE_INFORMATION DeviceInfo,
    ULONG BusNumber,
    ULONG Slot,
    PCM_RESOURCE_LIST BootResources,
    USHORT IrqFlags,
    PIO_RESOURCE_REQUIREMENTS_LIST *IoResources,
    ULONG *Size
    );

NTSTATUS
PipSetDeviceResources (
    PDEVICE_INFORMATION DeviceInfo,
    PCM_RESOURCE_LIST CmResources
    );

PVOID
PipGetMappedAddress(
    IN  INTERFACE_TYPE BusType,
    IN  ULONG BusNumber,
    IN  PHYSICAL_ADDRESS IoAddress,
    IN  ULONG NumberOfBytes,
    IN  ULONG AddressSpace,
    OUT PBOOLEAN MappedAddress
    );

NTSTATUS
PipMapReadDataPort (
    IN PPI_BUS_EXTENSION BusExtension,
    IN PHYSICAL_ADDRESS BaseAddressLow,
    IN ULONG PortLength
    );

NTSTATUS
PipMapAddressAndCmdPort (
    IN PPI_BUS_EXTENSION BusExtension
    );

VOID
PipDecompressEisaId(
    IN ULONG CompressedId,
    OUT PWCHAR EisaId
    );

VOID
PipCheckBus (
    IN PPI_BUS_EXTENSION BusExtension
    );

NTSTATUS
PipReadCardResourceData (
    OUT PUCHAR NumberLogicalDevices,
    IN PVOID *ResourceData,
    OUT PULONG ResourceDataLength
    );

NTSTATUS
PipReadDeviceResources (
    IN ULONG BusNumber,
    IN PUCHAR BiosRequirements,
    IN ULONG CardFlags,
    OUT PCM_RESOURCE_LIST *ResourceData,
    OUT PULONG Length,
    OUT PUSHORT irqFlags
    );

USHORT
PipIrqLevelRequirementsFromDeviceData(
    IN PUCHAR BiosRequirements, ULONG Length);

NTSTATUS
PipWriteDeviceResources (
    IN PUCHAR BiosRequirements,
    IN PCM_RESOURCE_LIST CmResources
    );

VOID
PipFixBootConfigIrqs(
    IN PCM_RESOURCE_LIST BootResources,
    IN USHORT irqFlags
    );

VOID
PipActivateDevice (
    );
VOID
PipDeactivateDevice (
    );

VOID
PipSelectLogicalDevice (
    IN USHORT Csn,
    IN USHORT LogicalDeviceNumber,
    IN ULONG  Control
    );

VOID
PipLFSRInitiation (
    VOID
    );

VOID
PipIsolateCards (
    OUT PUCHAR NumberCSNs
    );

VOID
PipWakeAndSelectDevice(
    IN UCHAR Csn,
    IN UCHAR Device
    );

ULONG
PipFindNextLogicalDeviceTag (
    IN OUT PUCHAR *CardData,
    IN OUT LONG *Limit
    );

NTSTATUS
PipGetCompatibleDeviceId (
    PUCHAR DeviceData,
    ULONG IdIndex,
    PWCHAR *Buffer,
    PULONG BufferSize
    );
VOID
PipLogError(
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PULONG DumpData,
    IN ULONG DumpCount,
    IN USHORT StringLength,
    IN PWCHAR String
    );

VOID
PipCleanupAcquiredResources (
    IN PPI_BUS_EXTENSION BusExtension
    );

PCARD_INFORMATION
PipIsCardEnumeratedAlready(
    IN PPI_BUS_EXTENSION BusExtension,
    IN PUCHAR CardData,
    IN ULONG DataLength
    );

NTSTATUS
PipQueryDeviceRelations (
    IN PPI_BUS_EXTENSION BusExtension,
    PDEVICE_RELATIONS *DeviceRelations,
    BOOLEAN Removal
    );

PDEVICE_INFORMATION
PipReferenceDeviceInformation (
    PDEVICE_OBJECT DeviceObject, BOOLEAN ConfigHardware
    );

VOID
PipDereferenceDeviceInformation (
    PDEVICE_INFORMATION DeviceInformation, BOOLEAN ConfigHardware
    );

VOID
PipLockDeviceDatabase (
    VOID
    );

VOID
PipUnlockDeviceDatabase (
    VOID
    );

NTSTATUS
PipOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

NTSTATUS
PipGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *Information
    );

NTSTATUS
PipOpenCurrentHwProfileDeviceInstanceKey(
    OUT PHANDLE Handle,
    IN  PUNICODE_STRING DeviceInstanceName,
    IN  ACCESS_MASK DesiredAccess
    );

NTSTATUS
PipGetDeviceInstanceCsConfigFlags(
    IN PUNICODE_STRING DeviceInstance,
    OUT PULONG CsConfigFlags
    );

NTSTATUS
PipValidateResourceList(
    IN PCM_RESOURCE_LIST ResourceList,
    IN ULONG Length
    );

NTSTATUS
PiQueryInterface (
    IN PPI_BUS_EXTENSION BusExtension,
    IN OUT PIRP Irp
    );

ULONG
PipDetermineResourceListSize(
    IN PCM_RESOURCE_LIST ResourceList
    );

VOID
PipDeleteDevice (
    PDEVICE_OBJECT DeviceObject
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );

NTSTATUS
PipReleaseInterfaces(
                    IN PPI_BUS_EXTENSION PipBusExtension
                    );

NTSTATUS
PipRebuildInterfaces(
                    IN PPI_BUS_EXTENSION PipBusExtension
                    );

VOID
PipResetGlobals (
                 VOID
                 );

BOOLEAN
PipMinimalCheckBus (
    IN PPI_BUS_EXTENSION BusExtension
    );

NTSTATUS
PipStartAndSelectRdp(
    PDEVICE_INFORMATION DeviceInfo,
    PPI_BUS_EXTENSION BusExtension,
    PDEVICE_OBJECT  DeviceObject,
    PCM_RESOURCE_LIST StartResources
    );

NTSTATUS
PipStartReadDataPort(
    PDEVICE_INFORMATION DeviceInfo,
    PPI_BUS_EXTENSION BusExtension,
    PDEVICE_OBJECT  DeviceObject,
    PCM_RESOURCE_LIST StartResources
    );

NTSTATUS
PipCreateReadDataPort(
    PPI_BUS_EXTENSION BusExtension
    );

BOOLEAN
PiNeedDeferISABridge(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    );

void
PipReleaseDeviceResources (
    PDEVICE_INFORMATION deviceInfo
    );

VOID
PipReportStateChange(
    PNPISA_STATE State
    );

//
// System defined levels
//
#define DEBUG_ERROR    DPFLTR_ERROR_LEVEL
#define DEBUG_WARN     DPFLTR_WARNING_LEVEL
#define DEBUG_TRACE    DPFLTR_TRACE_LEVEL
#define DEBUG_INFO     DPFLTR_INFO_LEVEL

//
// Driver defined levels.
// Or in DPFLTR_MASK so that these are interpreted
// as mask values rather than levels.
//
#define DEBUG_PNP      (0x00000010 | DPFLTR_MASK)
#define DEBUG_POWER    (0x00000020 | DPFLTR_MASK)
#define DEBUG_STATE    (0x00000040 | DPFLTR_MASK)
#define DEBUG_ISOLATE  (0x00000080 | DPFLTR_MASK)
#define DEBUG_RDP      (0x00000100 | DPFLTR_MASK)
#define DEBUG_CARDRES  (0x00000200 | DPFLTR_MASK)
#define DEBUG_UNUSED   (0x00000400 | DPFLTR_MASK)
#define DEBUG_UNUSED2  (0x00000800 | DPFLTR_MASK)
#define DEBUG_IRQ      (0x00001000 | DPFLTR_MASK)
#define DEBUG_RESOURCE (0x00002000 | DPFLTR_MASK)

//
// Set this bit to break in after printing a
// debug message
//
#define DEBUG_BREAK    0x08000000

VOID
PipDebugPrint (
    ULONG       Level,
    PCCHAR      DebugMessage,
    ...
    );

VOID
PipDebugPrintContinue (
    ULONG       Level,
    PCCHAR      DebugMessage,
    ...
    );

VOID
PipDumpIoResourceDescriptor (
    IN PUCHAR Indent,
    IN PIO_RESOURCE_DESCRIPTOR Desc
    );

VOID
PipDumpIoResourceList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList
    );

VOID
PipDumpCmResourceDescriptor (
    IN PUCHAR Indent,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Desc
    );

VOID
PipDumpCmResourceList (
    IN PCM_RESOURCE_LIST CmList
    );

#if DBG
#define DebugPrint(arg) PipDebugPrint arg
#define DebugPrintContinue(arg) PipDebugPrintContinue arg
#else
#define DebugPrint(arg)
#define DebugPrintContinue(arg)
#endif

VOID
PipUnlockDeviceDatabase (
    VOID
    );
VOID
PipLockDeviceDatabase (
    VOID
    );

ULONG
PipGetCardFlags(
    IN PCARD_INFORMATION CardInfo
    );

NTSTATUS
PipSaveBootIrqFlags(
    IN PDEVICE_INFORMATION DeviceInfo,
    IN USHORT IrqFlags
    );

NTSTATUS
PipGetBootIrqFlags(
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PUSHORT IrqFlags
    );

NTSTATUS
PipSaveBootResources(
    IN PDEVICE_INFORMATION DeviceInfo
    );

NTSTATUS
PipGetSavedBootResources(
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PCM_RESOURCE_LIST *BootResources
    );

NTSTATUS
PipTrimResourceRequirements (
    IN PIO_RESOURCE_REQUIREMENTS_LIST *IoList,
    IN USHORT IrqFlags,
    IN PCM_RESOURCE_LIST BootResources
    );

//
// Name of the volative key under the DeviceParameters key where data that needs
// to be persistent accross removes, but NOT reboots is stored
//
#define BIOS_CONFIG_KEY_NAME L"BiosConfig"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\fdopnp.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    fdopnp.c

Abstract:

    This file contains the PNP IRP dispatch code for FDOs

Environment:

    Kernel Mode Driver.

Revision History:

--*/

#include "busp.h"
#include "pnpisa.h"
#include <wdmguid.h>
#include "halpnpp.h"


//
// Function Prototypes
//

NTSTATUS
PiDeferProcessingFdo(
    IN PPI_BUS_EXTENSION BusExtension,
    IN OUT PIRP Irp
    );

NTSTATUS
PiStartFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryRemoveStopFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiCancelRemoveStopFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiStopFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryDeviceRelationsFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiRemoveFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryLegacyBusInformationFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryInterfaceFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryPnpDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiSurpriseRemoveFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PiDispatchPnpFdo)
#pragma alloc_text(PAGE,PiDeferProcessingFdo)
#pragma alloc_text(PAGE,PiStartFdo)
#pragma alloc_text(PAGE,PiQueryRemoveStopFdo)
#pragma alloc_text(PAGE,PiRemoveFdo)
#pragma alloc_text(PAGE,PiCancelRemoveStopFdo)
#pragma alloc_text(PAGE,PiStopFdo)
#pragma alloc_text(PAGE,PiQueryRemoveStopFdo)
#pragma alloc_text(PAGE,PiCancelRemoveStopFdo)
#pragma alloc_text(PAGE,PiQueryDeviceRelationsFdo)
#pragma alloc_text(PAGE,PiQueryInterfaceFdo)
#pragma alloc_text(PAGE,PipPassIrp)
#pragma alloc_text(PAGE,PiQueryLegacyBusInformationFdo)
#pragma alloc_text(PAGE,PiQueryPnpDeviceState)
#pragma alloc_text(PAGE,PiSurpriseRemoveFdo)
#endif


//
// PNP IRP Dispatch table for FDOs
//

PPI_DISPATCH PiPnpDispatchTableFdo[] = {
    PiStartFdo,                             // IRP_MN_START_DEVICE
    PiQueryRemoveStopFdo,                   // IRP_MN_QUERY_REMOVE_DEVICE
    PiRemoveFdo,                            // IRP_MN_REMOVE_DEVICE
    PiCancelRemoveStopFdo,                  // IRP_MN_CANCEL_REMOVE_DEVICE
    PiStopFdo,                              // IRP_MN_STOP_DEVICE
    PiQueryRemoveStopFdo,                   // IRP_MN_QUERY_STOP_DEVICE
    PiCancelRemoveStopFdo,                  // IRP_MN_CANCEL_STOP_DEVICE
    PiQueryDeviceRelationsFdo,              // IRP_MN_QUERY_DEVICE_RELATIONS
    PiQueryInterfaceFdo,                    // IRP_MN_QUERY_INTERFACE
    PipPassIrp,                             // IRP_MN_QUERY_CAPABILITIES
    PipPassIrp,                             // IRP_MN_QUERY_RESOURCES
    PipPassIrp,                             // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    PipPassIrp,                             // IRP_MN_QUERY_DEVICE_TEXT
    PipPassIrp,                             // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    PipPassIrp,                             // Unused
    PipPassIrp,                             // IRP_MN_READ_CONFIG
    PipPassIrp,                             // IRP_MN_WRITE_CONFIG
    PipPassIrp,                             // IRP_MN_EJECT
    PipPassIrp,                             // IRP_MN_SET_LOCK
    PipPassIrp,                             // IRP_MN_QUERY_ID
    PiQueryPnpDeviceState,                  // IRP_MN_QUERY_PNP_DEVICE_STATE
    PipPassIrp,                             // IRP_MN_QUERY_BUS_INFORMATION
    PipPassIrp,                             // IRP_MN_DEVICE_USAGE_NOTIFICATION
    PiSurpriseRemoveFdo,                    // IRP_MN_SURPRISE_REMOVAL
    PiQueryLegacyBusInformationFdo          // IRP_MN_QUERY_LEGACY_BUS_INFORMATION
};

//
// Function declarations
//

NTSTATUS
PiDispatchPnpFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_PNP IRPs for FDOs.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    busExtension = DeviceObject->DeviceExtension;

    if (irpSp->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {

        return PipPassIrp(DeviceObject, Irp);

    } else {

        status = PiPnpDispatchTableFdo[irpSp->MinorFunction](DeviceObject, Irp);

    }



    return status;
} //PipDispatchPnpFdo

NTSTATUS
PiPnPFdoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine triggers the event to indicate that processing of the
    irp can now continue.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    KeSetEvent((PKEVENT) Context, EVENT_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
PiDeferProcessingFdo(
    IN PPI_BUS_EXTENSION BusExtension,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine uses an IoCompletion routine along with an event to
    wait until the lower level drivers have completed processing of
    the irp.

Arguments:

    BusExtension - FDO extension for the FDO devobj in question

    Irp - Pointer to the IRP_MJ_PNP IRP to defer

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Set our completion routine
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           PiPnPFdoCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );
    status =  IoCallDriver(BusExtension->AttachedDevice, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
PiStartFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PPI_BUS_EXTENSION busExtension;
    NTSTATUS status;

    DebugPrint((DEBUG_PNP,
       "*** StartDevice irp received FDO: %x\n",DeviceObject));

    busExtension = DeviceObject->DeviceExtension;

    //
    // Postpones start operations until all lower drivers have
    // finished with the IRP.
    //

    status = PiDeferProcessingFdo(busExtension, Irp);
    if (NT_SUCCESS(status)) {
        busExtension->SystemPowerState = PowerSystemWorking;
        busExtension->DevicePowerState = PowerDeviceD0;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
} // PiStartFdo


NTSTATUS
PiQueryRemoveStopFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;

    DebugPrint((DEBUG_PNP,
       "*** QR/R/StopDevice irp received FDO: %x\n",DeviceObject));

    busExtension = DeviceObject->DeviceExtension;

    KeWaitForSingleObject( &IsaBusNumberLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    if (busExtension->BusNumber != 0) {

        status = PipReleaseInterfaces(busExtension);
        if (!NT_SUCCESS(status)) {
            PipCompleteRequest(Irp,status,NULL);
            return status;
        }

        ActiveIsaCount--;
        busExtension->Flags |= DF_QUERY_STOPPED;

    } else {

        Irp->IoStatus.Status = status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
    }

    KeSetEvent( &IsaBusNumberLock,
                0,
                FALSE );

    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status =  STATUS_SUCCESS;
        status = PipPassIrp(DeviceObject, Irp);
    }

    DebugPrint((DEBUG_PNP, "QR/R/Stop Device returning: %x\n",status));

    return status;

} // PiQueryRemoveStopFdo



NTSTATUS
PiCancelRemoveStopFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;

    DebugPrint((DEBUG_PNP,
                "*** Cancel R/Stop Device irp received FDO: %x\n",DeviceObject));

    busExtension = DeviceObject->DeviceExtension;

    status = PiDeferProcessingFdo(busExtension, Irp);
    // NTRAID#53498
    // ASSERT(status == STATUS_SUCCESS);
    // Uncomment after PCI state machine is fixed to not fail bogus stops

    //
    // Add back to active count
    //
    KeWaitForSingleObject( &IsaBusNumberLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    if (busExtension->Flags & DF_QUERY_STOPPED) {
        ActiveIsaCount++;
    }

    busExtension->Flags &= ~DF_QUERY_STOPPED;


    KeSetEvent( &IsaBusNumberLock,
                0,
                FALSE );

    status = PipRebuildInterfaces (busExtension);
    ASSERT(status == STATUS_SUCCESS);
    
    PipCompleteRequest(Irp, STATUS_SUCCESS, NULL);

    DebugPrint((DEBUG_PNP, "Cancel R/Stop Device returning: %x\n",status));
    return STATUS_SUCCESS;
} // PiCancelRemoveStopFdo



NTSTATUS
PiStopFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PPI_BUS_EXTENSION busExtension;
    NTSTATUS status;

    DebugPrint((DEBUG_PNP,
       "*** Stop Device irp received FDO: %x\n",DeviceObject));

    busExtension = DeviceObject->DeviceExtension;



    KeWaitForSingleObject( &IsaBusNumberLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    //
    //Actually clear the bitmap
    //
    ASSERT (RtlAreBitsSet (BusNumBM,busExtension->BusNumber,1));
    RtlClearBits (BusNumBM,busExtension->BusNumber,1);

    KeSetEvent( &IsaBusNumberLock,
                0,
                FALSE );


    busExtension->DevicePowerState = PowerDeviceD3;
    //
    // Handled in QueryStop, pass it down.
    //
    Irp->IoStatus.Status =  STATUS_SUCCESS;

    status = PipPassIrp (DeviceObject,Irp);

    DebugPrint((DEBUG_PNP, "Stop Device returning: %x\n",status));

    return status;
} // PiStopFdo



NTSTATUS
PiQueryDeviceRelationsFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PPI_BUS_EXTENSION busExtension;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_RELATIONS deviceRelations;
    PDEVICE_INFORMATION deviceInfo;
    PSINGLE_LIST_ENTRY deviceLink;
    BOOLEAN creatingRDP=FALSE,accessHW;
    NTSTATUS status;

    DebugPrint((DEBUG_PNP, "QueryDeviceRelations FDO %x\n",
                DeviceObject));

    busExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

#if ISOLATE_CARDS

    //
    // Only support BusRelations on PnpIsa bus PDO.
    //
    switch (irpSp->Parameters.QueryDeviceRelations.Type) {
        case  BusRelations: {

            //
            // Isolation may have been disabled via registry key.  In
            // that case, never enumerate an RDP.
            //
            // Note: Must return success and empty relations list
            // *RATHER* than just passing the irp down to accomplish
            // the same task due because of assumptions in the pnpres
            // code.
            //
            if (PipIsolationDisabled) {
                deviceRelations = ExAllocatePool(PagedPool,
                                                 sizeof(DEVICE_RELATIONS));
                if (deviceRelations) {
                    deviceRelations->Count = 0;
                    Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                } else {
                    PipCompleteRequest(Irp,STATUS_INSUFFICIENT_RESOURCES,NULL);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
                break;
            }

            //
            // All relations exist on the 'root' isa bus. (don't ask)
            //
            if (busExtension->BusNumber != 0) {
                break;
            }

            if (PipRDPNode) {
                //
                // overload the notion of "creating" for multi-bridge systems
                //
                if (PipRDPNode->Flags & (DF_PROCESSING_RDP|DF_ACTIVATED)) {
                    creatingRDP=TRUE;
                }
            }



            if (PipReadDataPort == NULL && !creatingRDP && !PipRDPNode ) {

                status = PipCreateReadDataPort(busExtension);
                if (!NT_SUCCESS(status)) {
                    PipCompleteRequest(Irp, status, NULL);
                    return status;
                }

                creatingRDP=TRUE;
            }

            if ((PipRDPNode && (creatingRDP) &&
               !(PipRDPNode->Flags & DF_ACTIVATED)) ||

                (PipRDPNode && (PipRDPNode->Flags & DF_REMOVED))) {

                deviceRelations = (PDEVICE_RELATIONS) ExAllocatePool(
                                     PagedPool,
                                     sizeof(DEVICE_RELATIONS) );

                if (deviceRelations) {

                    //
                    // If a device exists, mark it as disappeared so
                    // it's not reported again
                    //
                    PipLockDeviceDatabase();
                    deviceLink = busExtension->DeviceList.Next;
                    while (deviceLink) {
                        deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);
                        if (!(deviceInfo->Flags & DF_READ_DATA_PORT)) {
                            deviceInfo->Flags &= ~DF_ENUMERATED;
                        }
                        deviceLink = deviceInfo->DeviceList.Next;
                    }
                    PipUnlockDeviceDatabase();

                    deviceRelations->Count = 1;

                    DebugPrint((DEBUG_PNP,
                               "QueryDeviceRelations handing back the FDO\n"));
                    ObReferenceObject(PipRDPNode->PhysicalDeviceObject);
                    deviceRelations->Objects[0] = PipRDPNode->PhysicalDeviceObject;
                    (PDEVICE_RELATIONS)Irp->IoStatus.Information = deviceRelations;
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    break;
                } else {
                    PipCompleteRequest(Irp, STATUS_INSUFFICIENT_RESOURCES,NULL);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }


            //
            // Perform bus check to enumerate all the device under pnpisa bus.
            //


            PipLockDeviceDatabase();

            if ((PipRDPNode->Flags & (DF_ACTIVATED|DF_QUERY_STOPPED)) == DF_ACTIVATED) {
                accessHW = TRUE;
                deviceLink = busExtension->DeviceList.Next;
                while (deviceLink) {
                    deviceInfo = CONTAINING_RECORD (deviceLink,
                                                    DEVICE_INFORMATION,
                                                    DeviceList);
                    if (!(deviceInfo->Flags & DF_READ_DATA_PORT)) {
                        accessHW = FALSE;
                        DebugPrint((DEBUG_PNP,
                                    "QueryDeviceRelations: Found 1 card, no more isolation\n"));
                        break;
                    }
                    deviceLink = deviceInfo->DeviceList.Next;
                }
            } else {
                accessHW = FALSE;
            }

            if (PipRDPNode->Flags & DF_NEEDS_RESCAN) {
                DebugPrint((DEBUG_PNP,
                            "QueryDeviceRelations: Force rescan\n"));
                PipRDPNode->Flags &= ~DF_NEEDS_RESCAN;
                accessHW = TRUE;
            }

            if (accessHW) {
                PipCheckBus(busExtension);
            } else {
                DebugPrint((DEBUG_PNP, "QueryDeviceRelations: Using cached data\n"));
            }

            status = PipQueryDeviceRelations(
                         busExtension,
                         (PDEVICE_RELATIONS *)&Irp->IoStatus.Information,
                         FALSE );
            PipUnlockDeviceDatabase();
            Irp->IoStatus.Status = status;
            if (!NT_SUCCESS(status)) {
                PipCompleteRequest(Irp, status, NULL);
                return status;
            }
        }
        break;
        case EjectionRelations: {

            if (PipRDPNode) {
                deviceRelations = (PDEVICE_RELATIONS) ExAllocatePool(
                                     PagedPool,
                                     sizeof(DEVICE_RELATIONS) );
                if (deviceRelations) {
                    deviceRelations->Count = 1;

                    ObReferenceObject(PipRDPNode->PhysicalDeviceObject);
                    deviceRelations->Objects[0] = PipRDPNode->PhysicalDeviceObject;
                    (PDEVICE_RELATIONS)Irp->IoStatus.Information = deviceRelations;
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                } else {
                    PipCompleteRequest(Irp,STATUS_INSUFFICIENT_RESOURCES,NULL);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        break;
    }
#else
    if (irpSp->Parameters.QueryDeviceRelations.Type == BusRelations &&
        busExtension->BusNumber == 0) {

        deviceRelations = (PDEVICE_RELATIONS) ExAllocatePool(
            PagedPool,
            sizeof(DEVICE_RELATIONS) );
        if (deviceRelations) {
            deviceRelations->Count = 0;
            (PDEVICE_RELATIONS)Irp->IoStatus.Information = deviceRelations;
            Irp->IoStatus.Status = STATUS_SUCCESS;
        } else {
            PipCompleteRequest(Irp,STATUS_INSUFFICIENT_RESOURCES,NULL);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
#endif

    return PipPassIrp(DeviceObject, Irp);
} // PiQueryDeviceRelationsFdo



NTSTATUS
PiRemoveFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;
    PSINGLE_LIST_ENTRY child;
    PBUS_EXTENSION_LIST busList,prevBus;
    USHORT count=0;


    DebugPrint((DEBUG_PNP,
       "*** Remove Device irp received FDO: %x\n",DeviceObject));

    busExtension = DeviceObject->DeviceExtension;


     //
     // Clear the entry in the BM. Count dropped in
     // Query Remove.
     //
    KeWaitForSingleObject( &IsaBusNumberLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    if (!(busExtension->Flags & DF_SURPRISE_REMOVED)) {

#ifdef DBG
         ASSERT (RtlAreBitsSet (BusNumBM,busExtension->BusNumber,1));
#endif

         RtlClearBits (BusNumBM,busExtension->BusNumber,1);
    }

#if ISOLATE_CARDS

     PipLockDeviceDatabase();

     //
     // Walk the list of children and delete them
     //
     child=PopEntryList (&busExtension->DeviceList);
     while (child) {
         ASSERT (CONTAINING_RECORD (child, DEVICE_INFORMATION,DeviceList)->PhysicalDeviceObject);
         //
         // This pulls them from the list!
         //
         count ++;
         if (CONTAINING_RECORD (child, DEVICE_INFORMATION,DeviceList)->Flags & DF_READ_DATA_PORT) {
             //
             // Force the recreate of the RDP
             //
             PipCleanupAcquiredResources (busExtension);
             PipReadDataPort = NULL;
             PipRDPNode = NULL;
         } else {
             PipReleaseDeviceResources ((PDEVICE_INFORMATION)child);

         }
         IoDeleteDevice (CONTAINING_RECORD (child, DEVICE_INFORMATION,DeviceList)->PhysicalDeviceObject);
         child=PopEntryList (&busExtension->DeviceList);
     }

     PipUnlockDeviceDatabase();
     
#endif
     //
     // Delete this extension.
     //
     prevBus= busList = PipBusExtension;

     ASSERT (busList != NULL);

     while (busList->BusExtension != busExtension) {
         prevBus= busList;
         busList = busList->Next;
         ASSERT (busList != NULL);
     }
     //
     // Remove the node
     //
     if (prevBus == busList) {
         //
         // First Node.
         //
         PipBusExtension=busList->Next;
     }else  {
         prevBus->Next = busList->Next;
     }

     ExFreePool (busList);
     KeSetEvent( &IsaBusNumberLock,
                 0,
                 FALSE );


     if (count  > 0 ) {
         //
         // If we STILL have an ISA bus. Do this.
         //
         if (ActiveIsaCount > 0 ) {
             ASSERT (PipBusExtension->BusExtension);
             IoInvalidateDeviceRelations (PipBusExtension->BusExtension->PhysicalBusDevice,BusRelations);
         }
     }

#if ISOLATE_CARDS
     //
     // Cleanup all the resources on the last remove.
     //
     if (!(busExtension->Flags & DF_SURPRISE_REMOVED)) {
         PipCleanupAcquiredResources (busExtension);
     }
#endif

     //
     // The PnpISa bus PDO is being removed...
     //
     IoDetachDevice(busExtension->AttachedDevice);
     Irp->IoStatus.Status=STATUS_SUCCESS;
     status = PipPassIrp(DeviceObject, Irp);
     busExtension->AttachedDevice = NULL;
     busExtension->Flags  |= DF_DELETED;
     busExtension->DevicePowerState = PowerDeviceD3;
     IoDeleteDevice(busExtension->FunctionalBusDevice);
     return status;

} // PiRemoveFdo


NTSTATUS
PiQueryLegacyBusInformationFdo(
                               IN PDEVICE_OBJECT DeviceObject,
                               IN OUT PIRP Irp
                               )
{
    PLEGACY_BUS_INFORMATION legacyBusInfo;
    PVOID information = NULL;
    PPI_BUS_EXTENSION busExtension;
    NTSTATUS status;

    busExtension = DeviceObject->DeviceExtension;

    legacyBusInfo = (PLEGACY_BUS_INFORMATION) ExAllocatePool(PagedPool, sizeof(LEGACY_BUS_INFORMATION));
    if (legacyBusInfo) {
        legacyBusInfo->BusTypeGuid = GUID_BUS_TYPE_ISAPNP;
        legacyBusInfo->LegacyBusType = Isa;
        legacyBusInfo->BusNumber = busExtension->BusNumber;
        information = legacyBusInfo;
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) information;
        return PipPassIrp(DeviceObject, Irp);

    } else {

        PipCompleteRequest (Irp,status,NULL);
        return status;
    }
}


NTSTATUS
PiQueryInterfaceFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;

    busExtension = DeviceObject->DeviceExtension;

    //
    // We are a FDO - check if we are being asked for an interface we
    // support
    //

    status = PiQueryInterface(busExtension, Irp);

    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        return PipPassIrp(DeviceObject, Irp);

    } else if (status == STATUS_NOT_SUPPORTED) {

        return PipPassIrp(DeviceObject, Irp);

    } else {

        PipCompleteRequest (Irp,status,NULL);
        return status;
    }

} // PiQueryInterfaceFdo




NTSTATUS
PiQueryPnpDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{

    PPI_BUS_EXTENSION busExtension;

    busExtension = DeviceObject->DeviceExtension;

    //
    // We are a FDO
    //

    (PNP_DEVICE_STATE) Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PipPassIrp(DeviceObject, Irp);

} // PiQueryPnpDeviceState








NTSTATUS
PiSurpriseRemoveFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{

    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;

    DebugPrint((DEBUG_PNP,
       "*** Surprise Remove Device irp received FDO: %x\n",DeviceObject));

    busExtension = DeviceObject->DeviceExtension;


     //
     // Clear the entry in the BM. Count dropped in
     // Query Remove.
     //
    KeWaitForSingleObject( &IsaBusNumberLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

#ifdef DBG
     ASSERT (RtlAreBitsSet (BusNumBM,busExtension->BusNumber,1));
#endif
     RtlClearBits (BusNumBM,busExtension->BusNumber,1);




     KeSetEvent( &IsaBusNumberLock,
                 0,
                 FALSE );

#if ISOLATE_CARDS
     PipCleanupAcquiredResources (busExtension);
#endif

     //
     // The PnpISa bus PDO is being removed...
     //
     Irp->IoStatus.Status=STATUS_SUCCESS;
     status = PipPassIrp(DeviceObject, Irp);

     busExtension->AttachedDevice = NULL;
     busExtension->Flags  |= DF_SURPRISE_REMOVED;
     busExtension->DevicePowerState = PowerDeviceD3;
     return status;

} // PiSurpriseRemoveFdo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\dispatch.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This file contains the dispatch logic for ISAPNP

Author:

    Shie-Lin Tzong (shielint)

Environment:

    Kernel Mode Driver.

--*/

#include "busp.h"
#include "pnpisa.h"
#include <initguid.h>
#include <wdmguid.h>
#include "halpnpp.h"

//
// Prototype
//

VOID
PipCompleteRequest(
    IN OUT PIRP Irp,
    IN NTSTATUS Status,
    IN PVOID Information
    );

NTSTATUS
PipPassIrp(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PiUnload)
#pragma alloc_text(PAGE, PiDispatchPnp)
#pragma alloc_text(PAGE, PiDispatchDevCtl)
#pragma alloc_text(PAGE, PiDispatchCreate)
#pragma alloc_text(PAGE, PiDispatchClose)
#pragma alloc_text(PAGE, PiAddDevice)
#pragma alloc_text(PAGE, PipPassIrp)
#endif

VOID
PiUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine checks if there is any pnpisa card in the machine.  If non, it returns
    STATUS_NO_SUCH_DEVICE.

Arguments:

    DriverObject - Pointer to our pseudo driver object.

    DeviceObject - Pointer to the device object for which this requestapplies.

Return Value:

    NT status.

--*/
{

    PAGED_CODE();
    // We can not be unload.
    // ASSERT(0);
}

NTSTATUS
PiAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine checks if there is any pnpisa card in the machine.  If non, it returns
    STATUS_NO_SUCH_DEVICE.

    (Not any more, fix this)

Arguments:

    DriverObject - Pointer to our pseudo driver object.

    DeviceObject - Pointer to the device object for which this requestapplies.

Return Value:

    NT status.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT busFdo;
    PPI_BUS_EXTENSION busExtension;
    UNICODE_STRING interfaceName;
    ULONG busNumber;

    PAGED_CODE();




    KeWaitForSingleObject( &IsaBusNumberLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );
    ActiveIsaCount++;


    //
    // We are creating the first instance of the ISA bus.
    //
    RtlInitUnicodeString(&interfaceName, NULL);

    //
    // Create an FDO to attatch to the PDO
    //
    status = IoCreateDevice( DriverObject,
                             sizeof(PI_BUS_EXTENSION),  // Extension Size
                             NULL,                      // DeviceName
                             FILE_DEVICE_BUS_EXTENDER,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &busFdo);


    if (NT_SUCCESS(status)) {
        busExtension = (PPI_BUS_EXTENSION) busFdo->DeviceExtension;
        busExtension->Flags = DF_BUS;
        busExtension->FunctionalBusDevice = busFdo;
        busExtension->AttachedDevice = IoAttachDeviceToDeviceStack(busFdo, DeviceObject);
        busExtension->PhysicalBusDevice = DeviceObject;
        
        if (PiNeedDeferISABridge(DriverObject,DeviceObject)) {
          busNumber = RtlFindClearBitsAndSet (BusNumBM,1,1);
          ASSERT (busNumber != 0);
        } else {
          busNumber = RtlFindClearBitsAndSet (BusNumBM,1,0);
        }

        ASSERT (busNumber != 0xFFFFFFFF);

        if (ActiveIsaCount ==  1) {
            if (PipFirstInit) {
#if ISOLATE_CARDS
                PipResetGlobals();
#endif
            }
            PipDriverObject = DriverObject;
            busExtension->ReadDataPort = NULL;

            ASSERT (PipBusExtension == NULL);
            //
            //bus extension can get touched in pipdeletedevice
            //
            PipBusExtension = (PBUS_EXTENSION_LIST)ExAllocatePool (NonPagedPool,sizeof (BUS_EXTENSION_LIST));
            if (!PipBusExtension) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            PipBusExtension->BusExtension = busExtension;
            PipBusExtension->Next=NULL;

            PipFirstInit = TRUE;
        } else {
            PBUS_EXTENSION_LIST busList;

            ASSERT (PipDriverObject);
            busExtension->ReadDataPort = NULL;

            ASSERT (PipBusExtension);
            busList = PipBusExtension;
            while (busList->Next) {
                busList = (PBUS_EXTENSION_LIST)busList->Next;
            }
            busList->Next = (PBUS_EXTENSION_LIST)ExAllocatePool (NonPagedPool,sizeof (BUS_EXTENSION_LIST));

            if (!busList->Next) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            busList=busList->Next;
            busList->BusExtension = busExtension;
            busList->Next=NULL;
        }
        busExtension->BusNumber = busNumber;
    
        busFdo->Flags &= ~DO_DEVICE_INITIALIZING;
    }

    KeSetEvent( &IsaBusNumberLock,
                0,
                FALSE );

    return status;
}

NTSTATUS
PiDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP_POWER IRPs.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    ULONG length;
    PVOID information = NULL;
    PWCHAR requestId, ids;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResources;
    PCM_RESOURCE_LIST cmResources;
    PDEVICE_INFORMATION deviceInfo;
    PDEVICE_CAPABILITIES deviceCapabilities;
    PPNP_BUS_INFORMATION busInfo;
    PPI_BUS_EXTENSION busExtension;
    PDEVICE_INFORMATION deviceExtension = NULL;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    busExtension = DeviceObject->DeviceExtension;
    if (busExtension->Flags & DF_BUS) {
        if (busExtension->AttachedDevice == NULL) {
            status = STATUS_NO_SUCH_DEVICE;
            PipCompleteRequest(Irp, status, information);
            goto exit;
        }
    } else {
        busExtension = NULL;
        deviceExtension = DeviceObject->DeviceExtension;
        if (deviceExtension->Flags & DF_DELETED) {
            if (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_NO_SUCH_DEVICE;
            }
            PipCompleteRequest(Irp, status, information);
            goto exit;
        }
    }


    //
    // Dispatch IRPs bound for the FDO
    //
    if (busExtension) {
        status = PiDispatchPnpFdo(
                                DeviceObject,
                                Irp
                                );

        //return status;
    } else {
#if ISOLATE_CARDS
    //
    // Dispatch IRPs bound for the PDO
    //
        status = PiDispatchPnpPdo(
                                DeviceObject,
                                Irp
                                );
        //return status;
#endif
    }



exit:
    //
    // Complete the Irp and return.
    //

   // PipCompleteRequest(Irp, status, information);
    return status;
} // PiDispatchPnp


VOID
PipCompleteRequest(
    IN OUT PIRP Irp,
    IN NTSTATUS Status,
    IN PVOID Information
    )

/*++

Routine Description:

    This routine completes PnP irps for our pseudo driver.

Arguments:

    Irp - Supplies a pointer to the irp to be completed.

    Status - completion status.

    Information - completion information to be passed back.

Return Value:

    None.

--*/

{
    //
    // Complete the IRP.  First update the status...
    //

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = (ULONG_PTR)Information;

    //
    // ... and complete it.
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS
PipPassIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Description:

    This function pass the Irp to lower level driver.

Arguments:

    DeviceObject - the Fdo or Pdo
    Irp - the request

Return:

    STATUS_PENDING

--*/
{

    PIO_STACK_LOCATION ioStackLocation;                 // our stack location
    PIO_STACK_LOCATION nextIoStackLocation;             // next guy's
    PPI_BUS_EXTENSION busExtension = (PPI_BUS_EXTENSION) DeviceObject->DeviceExtension;


    IoSkipCurrentIrpStackLocation(Irp);

    //
    // Io call next driver, we pass it to root hub's parent no matter which tier we are at.
    //

    return IoCallDriver( busExtension->AttachedDevice, Irp );
}


NTSTATUS
PiDispatchDevCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Description:

    This function passes the Device Control Irp to lower level driver.

Arguments:

    DeviceObject - the Fdo or Pdo
    Irp - the request

Return:

    STATUS_PENDING

--*/
{
    PPI_BUS_EXTENSION busExtension = (PPI_BUS_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();
    if (busExtension->Flags & DF_BUS) {
        IoSkipCurrentIrpStackLocation (Irp);
        return IoCallDriver( busExtension->AttachedDevice, Irp );
    } else {
        //
        //We're at the bottom
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return status;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\data.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    pbdata.c

Abstract:

    Declares various data which is specific to PNP ISA bus extender architecture and
    is independent of BIOS.

Author:

    Shie-Lin Tzong (shielint) July-26-95

Environment:

    Kernel mode only.

Revision History:

--*/


#include "busp.h"

// global variable for configuring level of debug spew.

ULONG PipDebugMask = DEBUG_WARN | DEBUG_ERROR;

//
// global varialbe to remember the driver object created
// by IO mgr.
//

PDRIVER_OBJECT PipDriverObject;

//
// regPNPISADeviceName
//

WCHAR rgzPNPISADeviceName[] = DEVSTR_PNPISA_DEVICE_NAME;

//
// Pointers to bus extension data.
//

PBUS_EXTENSION_LIST PipBusExtension;

//
// PipRegistryPath stores the registry path that we got upon driver entry.
// This is used later when we're attempting to allocate resources.
//

UNICODE_STRING PipRegistryPath;

//
// Variables to protect critical region.
//

KEVENT PipDeviceTreeLock;
KEVENT IsaBusNumberLock;

//
// Bus Number and DMA control counters
//
ULONG BusNumberBuffer [256/sizeof (ULONG)];
RTL_BITMAP BusNumBMHeader;
PRTL_BITMAP BusNumBM;
ULONG ActiveIsaCount;
USHORT PipFirstInit;

#if ISOLATE_CARDS

// current bus "state"

PNPISA_STATE PipState = PiSWaitForKey;

//
// Read_data_port address
// (This is mainly for convinience.  It duplicates the
//  ReadDataPort field in BUS extension structure.)
//

ULONG  ADDRESS_PORT=0x0279;
ULONG  COMMAND_PORT=0x0a79;

PUCHAR PipReadDataPort;
PUCHAR PipCommandPort;
PUCHAR PipAddressPort;

//
// The global pointer to the Read Data Port DevNode
//
PDEVICE_INFORMATION PipRDPNode;


//
// ActiveIsaCount data port range selection array
//
//this conflicts with Compaq 2ndary IDE     {0x374, 0x377, 4},
READ_DATA_PORT_RANGE
PipReadDataPortRanges[READ_DATA_PORT_RANGE_CHOICES] =
    {{0x274, 0x277, 4},
     {0x3E4, 0x3E7, 4},
     {0x204, 0x207, 4},
     {0x2E4, 0x2E7, 4},
     {0x354, 0x357, 4},
     {0x2F4, 0x2F7, 4}};

BOOLEAN PipIsolationDisabled;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\isolate.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    isolate.c

Abstract:


Author:

    Shie-Lin Tzong (shielint) July-10-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "busp.h"
#include "pbios.h"
#include "pnpisa.h"

#if ISOLATE_CARDS

#define RANGE_MASK 0xFF000000

BOOLEAN
PipFindIrqInformation (
    IN ULONG IrqLevel,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR Information
    );

BOOLEAN
PipFindMemoryInformation (
    IN ULONG Index,
    IN ULONG Base,
    IN ULONG Limit,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR NameTag,
    OUT PUCHAR Information,
    OUT PULONG NewLengh OPTIONAL
    );

BOOLEAN
PipFindIoPortInformation (
    IN ULONG BaseAddress,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR Information,
    OUT PUCHAR Alignment,
    OUT PUCHAR RangeLength
    );

BOOLEAN
PipFindDmaInformation (
    IN UCHAR ChannelMask,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR Information
    );

NTSTATUS
PipReadCardResourceDataBytes (
    IN USHORT BytesToRead,
    IN PUCHAR Buffer
    );

USHORT
PipIrqLevelRequirementsFromDeviceData(
    IN PUCHAR BiosRequirements,
    ULONG Length
    );

//
// Internal type definitions
//

typedef struct _MEMORY_DESC_{
    ULONG Base;
    ULONG Length;
    BOOLEAN Memory32;
} MEMORY_DESC, *PMEMORY_DESC;

typedef struct _IRQ_DESC_{
    UCHAR Level;
    ULONG Type;
}IRQ_DESC, *PIRQ_DESC;

#ifdef ALLOC_PRAGMA
//#pragma alloc_text(PAGE, PipFindIrqInformation)
//#pragma alloc_text(PAGE, PipFindMemoryInformation)
//#pragma alloc_text(PAGE, PipFindIoPortInformation)
//#pragma alloc_text(PAGE, PipReadCardResourceData)
#pragma alloc_text(PAGE, PipReadDeviceResources)
//#pragma alloc_text(PAGE, PipWriteDeviceResources)
//#pragma alloc_text(PAGE, PipLFSRInitiation)
//#pragma alloc_text(PAGE, PipIsolateCards)
#pragma alloc_text(PAGE, PipFindNextLogicalDeviceTag)
//#pragma alloc_text(PAGE, PipSelectLogicalDevice)
//#pragma alloc_text(PAGE, PipReadCardResourceDataBytes)

#endif

BOOLEAN
PipFindIrqInformation (
    IN ULONG IrqLevel,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR Information
    )

/*++

Routine Description:

    This routine searches the Bios resource requirement lists for the corresponding
    Irq descriptor information.  The search stops when we encounter another logical
    device id tag or the END tag.  On input, the BiosRequirements points to current
    logical id tag.

Arguments:

    IrqLevel - Supplies the irq level.

    BiosRequirements - Supplies a pointer to the bios resource requirement lists.  This
        parameter must point to the logical device Id tag.

    Information - supplies a pointer to a UCHAR to receive the port information/flags.

Return Value:

    TRUE - if memory information found.  Else False.

--*/
{
    UCHAR tag;
    ULONG increment;
    USHORT irqMask;
    PPNP_IRQ_DESCRIPTOR biosDesc;

    //
    // Skip current logical id tag
    //

    tag = *BiosRequirements;
    ASSERT((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID);
    BiosRequirements += (tag & SMALL_TAG_SIZE_MASK) + 1;

    //
    // Search the possible resource list to get the information
    // for the Irq.
    //

    irqMask = 1 << IrqLevel;
    tag = *BiosRequirements;
    while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID)) {
        if ((tag & SMALL_TAG_MASK) == TAG_IRQ) {
            biosDesc = (PPNP_IRQ_DESCRIPTOR)BiosRequirements;
            if (biosDesc->IrqMask & irqMask) {
                if ((tag & SMALL_TAG_SIZE_MASK) == 2) {

                    //
                    // if no irq info is available, a value of zero is returned.
                    // (o is not a valid irq information.)
                    //

                    *Information = 0;
                } else {
                    *Information = biosDesc->Information;
                }
                return TRUE;
            }
        }
        if (tag & LARGE_RESOURCE_TAG) {
            increment = *((USHORT UNALIGNED *)(BiosRequirements + 1));
            increment += 3;     // length of large tag
        } else {
            increment = tag & SMALL_TAG_SIZE_MASK;
            increment += 1;     // length of small tag
        }
        BiosRequirements += increment;
        tag = *BiosRequirements;
    }
    return FALSE;
}

BOOLEAN
PipFindMemoryInformation (
    IN ULONG Index,
    IN ULONG BaseAddress,
    IN ULONG Limit,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR NameTag,
    OUT PUCHAR Information,
    OUT PULONG NewLength OPTIONAL
    )

/*++

Routine Description:

    This routine searches the Bios resource requirement lists for the corresponding
    memory descriptor information.  The search stops when we encounter another logical
    device id tag or the END tag.  Note, the memory range specified by Base
    and Limit must be within a single Pnp ISA memory descriptor.

Arguments:

    Index - Which memory descriptor we're interested in.

    BaseAddress - Supplies the base address of the memory range.

    Limit - Supplies the upper limit of the memory range.

    BiosRequirements - Supplies a pointer to the bios resource requirement lists.  This
        parameter must point to the logical device Id tag.

    NameTag - Supplies a variable to receive the Tag of the memory descriptor which
        describes the memory information.

    Information - supplies a pointer to a UCHAR to receive the memory information
        for the specified memory range.

Return Value:

    TRUE - if memory information found.  Else False.

--*/
{
    UCHAR tag;
    BOOLEAN found = FALSE,foundMem24, foundMem;
    ULONG minAddr, length, maxAddr, alignment, noMem = 0;
    USHORT increment;

    //
    // Skip current logical id tag.
    //

    tag = *BiosRequirements;
    ASSERT((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID);
    BiosRequirements += (tag & SMALL_TAG_SIZE_MASK) + 1;
    //
    // Search the possible resource list to get the information
    // for the memory range described by Base and Limit.
    //
    if (NewLength) {
        *NewLength=0;
    }

    tag = *BiosRequirements;
    while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID)) {
        foundMem = foundMem24 = FALSE;
        switch (tag) {
        case TAG_MEMORY:
            minAddr = ((ULONG)(((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->MinimumAddress)) << 8;
            length = ((ULONG)(((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->MemorySize)) << 8;
            maxAddr = (((ULONG)(((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->MaximumAddress)) << 8)
                + length - 1;

            foundMem24 = TRUE;
            foundMem = TRUE;
            break;
        case TAG_MEMORY32:
            length = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->MemorySize;
            minAddr = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->MinimumAddress;
            maxAddr = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->MaximumAddress
                + length - 1;
            foundMem = TRUE;
            break;
        case TAG_MEMORY32_FIXED:
            length = ((PPNP_FIXED_MEMORY32_DESCRIPTOR)BiosRequirements)->MemorySize;
            minAddr = ((PPNP_FIXED_MEMORY32_DESCRIPTOR)BiosRequirements)->BaseAddress;
            maxAddr = minAddr + length - 1;
            foundMem = TRUE;
            break;
        }

        if (foundMem) {
            //
            // Work around cards that don't set register 43 correctly.
            // if the boot config has a value that equals the rom data, but
            // has the range type flipped, allow it, and reset
            // the length
            //
            if ((minAddr <= BaseAddress &&
                ((maxAddr >= Limit) || ((foundMem24 && (maxAddr >= (BaseAddress+(~Limit & ~RANGE_MASK))))))) && (noMem == Index)) {

                *Information = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->Information;
                *NameTag = tag;
                found = TRUE;
                //
                // did we find a 16-bit tag
                //
                if (NewLength && foundMem24) {
                    if  (maxAddr >= (BaseAddress+(~Limit & ~RANGE_MASK))) {
                        *NewLength = length;
                    }
                }
                break;
            } else {
                noMem++;
            }
        }

        //
        // Advance to next tag
        //

        if (tag & LARGE_RESOURCE_TAG) {
            increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
            increment += 3;     // length of large tag
        } else {
            increment = tag & SMALL_TAG_SIZE_MASK;
            increment += 1;     // length of small tag
        }
        BiosRequirements += increment;
        tag = *BiosRequirements;
    }
    return found;
}

BOOLEAN
PipFindIoPortInformation (
    IN ULONG BaseAddress,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR Information,
    OUT PUCHAR Alignment,
    OUT PUCHAR RangeLength
    )

/*++

Routine Description:

    This routine searches the Bios resource requirement lists for the corresponding
    Io port descriptor information.  The search stops when we encounter another logical
    device id tag or the END tag.

Arguments:

    BaseAddress - Supplies the base address of the Io port range.

    BiosRequirements - Supplies a pointer to the bios resource requirement lists.  This
        parameter must point to the logical device Id tag.

    Information - supplies a pointer to a UCHAR to receive the port information/flags.

    Alignment - supplies a pointer to a UCHAR to receive the port alignment
        information.

    RangeLength - supplies a pointer to a UCHAR to receive the port range length
        information.

Return Value:

    TRUE - if memory information found.  Else False.

--*/
{
    UCHAR tag;
    BOOLEAN found = FALSE;
    ULONG minAddr, length, maxAddr, alignment;
    USHORT increment;
    PPNP_PORT_DESCRIPTOR portDesc;
    PPNP_FIXED_PORT_DESCRIPTOR fixedPortDesc;

    tag = *BiosRequirements;
    ASSERT((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID);
    BiosRequirements += (tag & SMALL_TAG_SIZE_MASK) + 1;

    //
    // Search the possible resource list to get the information
    // for the io port range described by Base.
    //

    tag = *BiosRequirements;
    while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID)) {
        switch (tag & SMALL_TAG_MASK) {
        case TAG_IO:
             portDesc = (PPNP_PORT_DESCRIPTOR)BiosRequirements;
             minAddr = portDesc->MinimumAddress;
             maxAddr = portDesc->MaximumAddress;
             if (minAddr <= BaseAddress && maxAddr >= BaseAddress) {
                 *Information = portDesc->Information;
                 *Alignment = portDesc->Alignment;
                 *RangeLength = portDesc->Length;
                 found = TRUE;
             }
             break;
        case TAG_IO_FIXED:
             fixedPortDesc = (PPNP_FIXED_PORT_DESCRIPTOR)BiosRequirements;
             minAddr = fixedPortDesc->MinimumAddress;
             if (BaseAddress == minAddr) {
                 *Information = 0;     // 10 bit decode
                 *Alignment = 1;
                 *RangeLength = fixedPortDesc->Length;
                 found = TRUE;
             }
             break;
        }

        if (found) {
            break;
        }

        //
        // Advance to next tag
        //

        if (tag & LARGE_RESOURCE_TAG) {
            increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
            increment += 3;     // length of large tag
        } else {
            increment = tag & SMALL_TAG_SIZE_MASK;
            increment += 1;     // length of small tag
        }
        BiosRequirements += increment;
        tag = *BiosRequirements;
    }
    return found;
}

BOOLEAN
PipFindDmaInformation (
    IN UCHAR ChannelMask,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR Information
    )

/*++

Routine Description:

    This routine searches the Bios resource requirement lists for the corresponding
    Io port descriptor information.  The search stops when we encounter another logical
    device id tag or the END tag.

Arguments:

    BaseAddress - Supplies the channel mask.

    BiosRequirements - Supplies a pointer to the bios resource requirement lists.  This
        parameter must point to the logical device Id tag.

    Information - supplies a pointer to a UCHAR to receive the port information/flags.

Return Value:

    TRUE - if memory information found.  Else False.

--*/
{
    UCHAR tag;
    BOOLEAN found = FALSE;
    USHORT increment;
    PPNP_DMA_DESCRIPTOR dmaDesc;
    UCHAR biosMask;

    tag = *BiosRequirements;
    ASSERT((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID);
    BiosRequirements += (tag & SMALL_TAG_SIZE_MASK) + 1;

    //
    // Search the possible resource list to get the information
    // for the io port range described by Base.
    //

    tag = *BiosRequirements;
    while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID)) {
        if ((tag & SMALL_TAG_MASK) == TAG_DMA) {
             dmaDesc = (PPNP_DMA_DESCRIPTOR)BiosRequirements;
             biosMask = dmaDesc->ChannelMask;
             if (ChannelMask & biosMask) {
                 *Information = dmaDesc->Flags;
                 found = TRUE;
             }
        }

        if (found) {
            break;
        }

        //
        // Advance to next tag
        //

        if (tag & LARGE_RESOURCE_TAG) {
            increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
            increment += 3;     // length of large tag
        } else {
            increment = tag & SMALL_TAG_SIZE_MASK;
            increment += 1;     // length of small tag
        }
        BiosRequirements += increment;
        tag = *BiosRequirements;
    }
    return found;
}

NTSTATUS
PipReadCardResourceData (
    OUT PUCHAR NumberLogicalDevices,
    IN PUCHAR *ResourceData,
    OUT PULONG ResourceDataLength
    )
/*++

Routine Description:

    This routine reads resources data from a specified PnP ISA card.  It is
    caller's responsibility to release the memory.  Before calling this routine,
    the Pnp ISA card should be in sleep state (i.e. Initiation Key was sent.)
    After exiting this routine, the card will be left in Config state.

Arguments:

    NumberLogicalDevices - supplies a variable to receive the number of logical devices
        associated with the Pnp Isa card.

    ResourceData - Supplies a variable to receive the pointer to the resource data.

    ResourceDataLength - Supplies a variable to receive the length of the ResourceData.

Return Value:

    NT STATUS code.

--*/
{

    PUCHAR buffer, p;
    LONG sizeToRead, limit, i;
    USHORT size;
    UCHAR tag;
    UCHAR noDevices;

    BOOLEAN failed;
    NTSTATUS status;

    //
    // Allocate memory to store the resource data.
    // N.B. The buffer size should cover 99.999% of the machines.
    //

    sizeToRead = 4096;

tryAgain:

    noDevices = 0;
    buffer = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool, sizeToRead, 'iPnP');
    if (!buffer) {
        DebugPrint((DEBUG_ERROR, "PipReadCardResourceData returning STATUS_INSUFFICIENT_RESOURCES\n"));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Send card from sleep state to configuration state
    // Note, by doing this the resource data includes 9 bytes Id.
    //

    DebugPrint((DEBUG_STATE, "Read resources\n"));

    //
    // Read card id bytes
    //

    p = buffer;
    status = PipReadCardResourceDataBytes(NUMBER_CARD_ID_BYTES, p);
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        DebugPrint((DEBUG_STATE | DEBUG_ERROR,
                    "Read resources failed\n"));

        DebugPrint((DEBUG_ERROR, "PipReadCardResourceDataBytes Failed %x\n",status));
        return status;
    }
    i = NUMBER_CARD_ID_BYTES;
    p += NUMBER_CARD_ID_BYTES;

    //
    // read all the tag descriptors of the card resource data
    //

    failed = FALSE;
    limit = sizeToRead - 4 - NUMBER_CARD_ID_BYTES;;

    while (TRUE) {

        //
        // Read tag byte. Make sure it's a valid tag and determine
        // the size of the descriptor.
        //

        PipReadCardResourceDataBytes(1, p);
        tag = *p;
        i++;
        p++;
        if (tag == TAG_COMPLETE_END) {
            PipReadCardResourceDataBytes(1, p);
            p++;
            i++;
            break;
        } else if (tag == TAG_END) {  // With NO checksum
            *p = 0;
            i++;
            p++;
            break;
        }
        if (tag & LARGE_RESOURCE_TAG) {
            if (tag & 0x70) {
                failed = TRUE;
#if VERBOSE_DEBUG
    DbgPrint ("Failing Resource read on large tag: %x\n",tag);
#endif
                break;
            } else {
                PipReadCardResourceDataBytes(2, p);
                size = *((USHORT UNALIGNED *)p);
                p += 2;
                i += 2;
            }
        } else {
            if ((tag & 0x70) == 0x50 || (tag & 0x70) == 0x60 || (((tag & 0x70) == 0) && (tag != 0xa))) {
                failed = TRUE;
#if VERBOSE_DEBUG
    DbgPrint ("Failing Resource read on small tag: %x\n",tag);
#endif
                break;
            } else {
                if ((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID) {
                    noDevices++;
                }
                size = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
            }
        }

        //
        // read 'size' number of bytes for the current descriptor
        //

        i += size;
        if (i < limit) {
            PipReadCardResourceDataBytes(size, p);
            p += size;
        } else {
            ExFreePool(buffer);
            sizeToRead <<= 1;           // double the buffer

            //
            // If we can find the END tag with 32K byte, assume the resource
            // requirement list is bad.
            //

            if (sizeToRead > 0x80000) {

                DebugPrint ((DEBUG_STATE | DEBUG_ERROR, "PipReadCardResourceData returning STATUS_INVALID_PARAMETER, Sleep\n"));

                return STATUS_INVALID_PARAMETER;
            } else {
                goto tryAgain;
            }
        }
    }

    if (failed) {
        ExFreePool(buffer);
#if VERBOSE_DEBUG
        DbgPrint ("PipReadCardResourceData returning FAILED\n");
#endif

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Determine the real size of the buffer required and
    // resize the buffer.
    //

    size = (USHORT)(p - buffer); // i
    p = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool, size, 'iPnP');
    if (p) {
        RtlMoveMemory(p, buffer, size);
        ExFreePool(buffer);
    } else {

        //
        // Fail to resize the buffer.  Simply leave it alone.
        //

        p = buffer;
    }

    *ResourceData = p;
    *NumberLogicalDevices = noDevices;
    *ResourceDataLength = size;
    return STATUS_SUCCESS;
}

NTSTATUS
PipReadDeviceResources (
    IN ULONG BusNumber,
    IN PUCHAR BiosRequirements,
    IN ULONG CardFlags,
    OUT PCM_RESOURCE_LIST *ResourceData,
    OUT PULONG Length,
    OUT PUSHORT irqFlags
    )

/*++

Routine Description:

    This routine reads boot resource data from an enabled logical device of a PNP ISA
    card.  Caller must put the card into configuration state and select the logical
    device before calling this function.  It is caller's responsibility to release
    the memory. ( The boot resource data is the resources that a card assigned during
    boot.)

Arguments:

    BusNumber - specifies the bus number of the device whose resource data to be read.

    BiosRequirements - Supplies a pointer to the resource requirement list for the logical
        device.  This parameter must point to the logical device Id tag.

    CardFlags - Flags that may indicate the need to apply a workaround.

    ResourceData - Supplies a variable to receive the pointer to the resource data.

    Length - Supplies a variable to recieve the length of the resource data.

Return Value:

    NT STATUS code.

--*/
{
    UCHAR c, junk1, junk2, info;
    PUCHAR base;
    ULONG l, resourceCount;
    BOOLEAN limit;
    LONG i, j, noMemoryDesc = 0, noIoDesc = 0, noDmaDesc =0, noIrqDesc = 0;
    MEMORY_DESC memoryDesc[NUMBER_MEMORY_DESCRIPTORS + NUMBER_32_MEMORY_DESCRIPTORS];
    IRQ_DESC irqDesc[NUMBER_IRQ_DESCRIPTORS];
    UCHAR dmaDesc[NUMBER_DMA_DESCRIPTORS];
    USHORT ioDesc[NUMBER_IO_DESCRIPTORS];
    PCM_RESOURCE_LIST cmResource;
    PCM_PARTIAL_RESOURCE_LIST partialResList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDesc;
    ULONG dumpData[2];

    //
    // First make sure the specified BiosRequirements is valid and at the right tag.
    //

    if ((*BiosRequirements & SMALL_TAG_MASK) != TAG_LOGICAL_ID) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If card is not activated, don't read boot resource.
    // Because boot resource of non activated NEC98's ISAPNP card is not 0.
    //

    *irqFlags = CM_RESOURCE_INTERRUPT_LATCHED;
    PipWriteAddress(ACTIVATE_PORT);
    if (!(PipReadData() & 1)) {
        *ResourceData = NULL;
        *Length = 0;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Read memory configuration
    //

    base = (PUCHAR)ADDRESS_MEMORY_BASE;
    for (i = 0; i < NUMBER_MEMORY_DESCRIPTORS; i++) {

        //
        // Read memory base address
        //

        PipWriteAddress(base + ADDRESS_MEMORY_HI);
        c = PipReadData();
        l = c;
        l <<= 8;
        PipWriteAddress(base + ADDRESS_MEMORY_LO);
        c = PipReadData();
        l |= c;
        l <<= 8;        // l = memory base address
        if (l == 0) {
            break;
        }

        memoryDesc[noMemoryDesc].Base = l;

        //
        // Read memory control byte
        //

        PipWriteAddress(base + ADDRESS_MEMORY_CTL);
        c= PipReadData();

        limit = c & 1;

        //
        // Read memory upper limit address or range length
        //

        PipWriteAddress(base + ADDRESS_MEMORY_UPPER_HI);
        c = PipReadData();

        l = c;
        l <<= 8;

        PipWriteAddress(base + ADDRESS_MEMORY_UPPER_LO);
        c = PipReadData();
        l |= c;
        l <<= 8;

        //
        //If bit[0] of memory control is 0, this is the range length.
        //If bit[0] of memory control is 1, this is upper limit for memory
        //address (equal to memory base address plus the range length allocated).
        //
        if (limit == ADDRESS_MEMORY_CTL_LIMIT) {
            l = l - memoryDesc[noMemoryDesc].Base;
        }else {
            l = (~l+1) & ~(RANGE_MASK);
        }

        // IBM0001 Token Ring card has write-only registers 0x4B-0x4C.
        // The boot configed length comes back 0 instead of 0x2000
        if ((CardFlags & CF_IBM_MEMBOOTCONFIG) && (l == 0) &&
            (noMemoryDesc == 1)) {
            l = 0x2000;
        }

        memoryDesc[noMemoryDesc].Length = l;
        memoryDesc[noMemoryDesc].Memory32 = FALSE;
        noMemoryDesc++;
        base += ADDRESS_MEMORY_INCR;
    }

    //
    // Read memory 32 configuration
    //
    // Spec says you can't mix 24 bit and 32bit memory.  Helps on
    // cards with flakey 32 bit memory registers until we examine only
    // the boot configed resources specified in the requirements.
    if (noMemoryDesc == 0) {

        for (i = 0; i < NUMBER_32_MEMORY_DESCRIPTORS; i++) {

            base = ADDRESS_32_MEMORY_BASE(i);

            //
            // Read memory base address
            //
            l = 0;
            for (j = ADDRESS_32_MEMORY_B3; j <= ADDRESS_32_MEMORY_B0; j++) {
                PipWriteAddress(base + j);
                c = PipReadData();

                l <<= 8;
                l |= c;
            }
            if (l == 0) {
                break;
            }

            memoryDesc[noMemoryDesc].Base = l;

            //
            // Read memory control byte
            //

            PipWriteAddress(base + ADDRESS_32_MEMORY_CTL);
            c= PipReadData();

            limit = c & 1;

            //
            // Read memory upper limit address or range length
            //

            l = 0;
            for (j = ADDRESS_32_MEMORY_E3; j <= ADDRESS_32_MEMORY_E0; j++) {
                PipWriteAddress(base + j);
                c = PipReadData();
                l <<= 8;
                l |= c;
            }

            if (limit == ADDRESS_MEMORY_CTL_LIMIT) {
                l = l - memoryDesc[noMemoryDesc].Base;
            }else {
                l = ((~l)+1) & ~(RANGE_MASK);
            }

            memoryDesc[noMemoryDesc].Length = l;
            memoryDesc[noMemoryDesc].Memory32 = TRUE;
            noMemoryDesc++;
        }
    }

    //
    // Read Io Port Configuration
    //

    base =  (PUCHAR)ADDRESS_IO_BASE;
    for (i = 0; i < NUMBER_IO_DESCRIPTORS; i++) {
        PipWriteAddress(base + ADDRESS_IO_BASE_HI);
        c = PipReadData();
        l = c;
        PipWriteAddress(base + ADDRESS_IO_BASE_LO);
        c = PipReadData();
        l <<= 8;
        l |= c;
        if (l == 0) {
            break;
        }
        ioDesc[noIoDesc++] = (USHORT)l;
        base += ADDRESS_IO_INCR;
    }

    //
    // Read Interrupt configuration
    //

    base = (PUCHAR)ADDRESS_IRQ_BASE;
    for (i = 0; i < NUMBER_IRQ_DESCRIPTORS; i++) {
        PipWriteAddress(base + ADDRESS_IRQ_VALUE);
        c = PipReadData() & 0xf;
        if (c == 0) {
            break;
        }
        irqDesc[noIrqDesc].Level = c;
        PipWriteAddress(base + ADDRESS_IRQ_TYPE);
        c = PipReadData();
        irqDesc[noIrqDesc++].Type = c;
        base += ADDRESS_IRQ_INCR;

        DebugPrint((DEBUG_IRQ, "card boot config byte %x\n", (ULONG) c));
        // only if card is configured to low level do we respect level.
        // register is probably busted
        if ((c & 3) == 1) {
            *irqFlags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        }
    }

    //
    // Read DMA configuration
    //

    base = (PUCHAR)ADDRESS_DMA_BASE;
    for (i = 0; i < NUMBER_DMA_DESCRIPTORS; i++) {
        PipWriteAddress(base + ADDRESS_DMA_VALUE);
        c = PipReadData() & 0x7;
        if (c == 4) {
            break;
        }
        if (!PipFindDmaInformation ( (UCHAR)(1 << c), BiosRequirements, &info)) {
            break;
        }
        dmaDesc[noDmaDesc++] = c;
        base += ADDRESS_DMA_INCR;
    }

    //
    // Construct CM_RESOURCE_LIST structure based on the resource data
    // we collect so far.
    //

    resourceCount = noMemoryDesc + noIoDesc + noDmaDesc + noIrqDesc;

    //
    // if empty bios resources, simply return.
    //

    if (resourceCount == 0) {
        *ResourceData = NULL;
        *Length = 0;
        return STATUS_SUCCESS;
    }

    l = sizeof(CM_RESOURCE_LIST) + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) *
               ( resourceCount - 1);
    cmResource = ExAllocatePoolWithTag(PagedPool, l, 'iPnP');
    if (!cmResource) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(cmResource, l);
    *Length = l;                                   // Set returned resource data length
    cmResource->Count = 1;
    cmResource->List[0].InterfaceType = Isa;
    cmResource->List[0].BusNumber = BusNumber;
    partialResList = (PCM_PARTIAL_RESOURCE_LIST)&cmResource->List[0].PartialResourceList;
    partialResList->Version = 0;
    partialResList->Revision = 0x3000;
    partialResList->Count = resourceCount;
    partialDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)&partialResList->PartialDescriptors[0];

    //
    // Set up all the CM memory descriptors
    //
    for (i = 0; i < noMemoryDesc; i++) {

        ULONG NewLength;

        partialDesc->Type = CmResourceTypeMemory;
        partialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        partialDesc->u.Memory.Length = memoryDesc[i].Length;
        partialDesc->u.Memory.Start.HighPart = 0;
        partialDesc->u.Memory.Start.LowPart = memoryDesc[i].Base;

        //
        // Need to consult configuration data for the Flags
        //

        l = memoryDesc[i].Base + memoryDesc[i].Length - 1;
        if (PipFindMemoryInformation (i, memoryDesc[i].Base, l, BiosRequirements, &junk1, &c,&NewLength)) {

            if (NewLength != 0 ) {
                partialDesc->u.Memory.Length = NewLength;
            }

            // Mark the memory descriptor as read-only if the tags describe as
            // expansion ROM or generic non-writable memory
            if ((c & PNP_MEMORY_ROM_MASK) ||
                !(c & PNP_MEMORY_WRITE_STATUS_MASK)) {
                partialDesc->Flags =  CM_RESOURCE_MEMORY_READ_ONLY;
            }
        } else {
            DebugPrint((DEBUG_CARDRES|DEBUG_WARN,
                        "ReadDeviceResources: No matched memory req for %x to %x\n",
                        memoryDesc[i].Base, l));
            ExFreePool(cmResource);
            return STATUS_UNSUCCESSFUL;
        }
        partialDesc->Flags |= CM_RESOURCE_MEMORY_24;
        partialDesc++;
    }

    //
    // Set up all the CM io/port descriptors
    //

    for (i = 0; i < noIoDesc; i++) {
        partialDesc->Type = CmResourceTypePort;
        partialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        partialDesc->Flags = CM_RESOURCE_PORT_IO;
        partialDesc->u.Port.Start.LowPart = ioDesc[i];

        //
        // Need to consult configuration data for the Port length
        //

        if (PipFindIoPortInformation (ioDesc[i], BiosRequirements, &info, &junk2, &c)) {
            if (info & 1) {
                partialDesc->Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
            } else {
                partialDesc->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
            }
            partialDesc->u.Port.Length = c;
            partialDesc++;
        } else {
            DebugPrint((DEBUG_CARDRES|DEBUG_WARN,
                        "ReadDeviceResources: No matched port req for %x\n",
                        ioDesc[i]));
            ExFreePool(cmResource);
            return STATUS_UNSUCCESSFUL;
        }
    }

    //
    // Set up all the CM DMA descriptors
    //

    for (i = 0; i < noDmaDesc; i++) {
        partialDesc->Type = CmResourceTypeDma;
        partialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        partialDesc->Flags = 0;   // no flags for DMA descriptor
        partialDesc->u.Dma.Channel = (ULONG) dmaDesc[i];
        partialDesc->u.Dma.Port = 0;
        partialDesc->u.Dma.Reserved1 = 0;
        partialDesc++;
    }

    //
    // Set up all the CM interrupt descriptors
    //

    for (i = 0; i < noIrqDesc; i++) {
        partialDesc->Type = CmResourceTypeInterrupt;
        partialDesc->ShareDisposition = CmResourceShareDeviceExclusive;


        partialDesc->Flags = *irqFlags;
        partialDesc->u.Interrupt.Vector =
        partialDesc->u.Interrupt.Level = irqDesc[i].Level;
        partialDesc->u.Interrupt.Affinity = (ULONG)-1;
        partialDesc++;
    }

    *ResourceData = cmResource;
    return STATUS_SUCCESS;
}

NTSTATUS
PipWriteDeviceResources (
    IN PUCHAR BiosRequirements,
    IN PCM_RESOURCE_LIST CmResources
    )

/*++

Routine Description:

    This routine writes boot resource data to an enabled logical device of
    a Pnp ISA card.  Caller must put the card into configuration state and select
    the logical device before calling this function.

Arguments:

    BiosRequirements - Supplies a pointer to the possible resources for the logical
        device.  This parameter must point to the logical device Id tag.

    ResourceData - Supplies a pointer to the cm resource data.

Return Value:

    NT STATUS code.

--*/
{
    UCHAR c, information, tag;
    ULONG count, i, j, pass, base, limit;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDesc;
    ULONG noIrq =0, noIo = 0, noDma = 0, noMemory24 = 0, noMemory32 = 0, noMemory;
    PUCHAR memoryBase, irqBase, dmaBase, ioBase, tmp;
    ULONG memory32Base;

    //
    // First make sure the specified BiosRequirements is valid and at the right tag.
    //

    if ((*BiosRequirements & SMALL_TAG_MASK) != TAG_LOGICAL_ID) {
        return STATUS_INVALID_PARAMETER;
    }

    count = CmResources->List[0].PartialResourceList.Count;
    memoryBase = (PUCHAR)ADDRESS_MEMORY_BASE;
    memory32Base = 0;
    ioBase = (PUCHAR)ADDRESS_IO_BASE;
    irqBase = (PUCHAR)ADDRESS_IRQ_BASE;
    dmaBase = (PUCHAR)ADDRESS_DMA_BASE;
    for (pass = 1; pass <= 2; pass++) {

        //
        // First pass we make sure the resources to be set is acceptable.
        // Second pass we actually write the resources to the logical device's
        // configuration space.
        //
        noMemory = 0;
        cmDesc = CmResources->List[0].PartialResourceList.PartialDescriptors;
        for (i = 0; i < count; i++) {
            switch (cmDesc->Type) {
            case CmResourceTypePort:
                 if (pass == 1) {
                     noIo++;
                     if (noIo > NUMBER_IO_DESCRIPTORS ||
                         cmDesc->u.Port.Start.HighPart != 0 ||
                         cmDesc->u.Port.Start.LowPart & 0xffff0000 ||
                         cmDesc->u.Port.Length & 0xffffff00) {
                         return STATUS_INVALID_PARAMETER;
                     }
                 } else {

                     //
                     // Set the Io port base address to logical device configuration space
                     //

                     c = (UCHAR)cmDesc->u.Port.Start.LowPart;
                     PipWriteAddress(ioBase + ADDRESS_IO_BASE_LO);
                     PipWriteData(c);
                     c = (UCHAR)(cmDesc->u.Port.Start.LowPart >> 8);
                     PipWriteAddress(ioBase + ADDRESS_IO_BASE_HI);
                     PipWriteData(c);
                     ioBase += ADDRESS_IO_INCR;
                 }
                 break;
            case CmResourceTypeInterrupt:
                 if (pass == 1) {
                     noIrq++;
                     if (noIrq > NUMBER_IRQ_DESCRIPTORS ||
                         (cmDesc->u.Interrupt.Level & 0xfffffff0)) {
                         return STATUS_INVALID_PARAMETER;
                     }

                     //
                     // See if we can get the interrupt information from possible resource
                     // data.  We need it to set the configuration register.
                     //

                     if (!PipFindIrqInformation(cmDesc->u.Interrupt.Level, BiosRequirements, &information)) {
                         return STATUS_INVALID_PARAMETER;
                     }
                 } else {

                     //
                     // Set the Irq to logical device configuration space
                     //

                     c = (UCHAR)cmDesc->u.Interrupt.Level;
                     PipWriteAddress(irqBase + ADDRESS_IRQ_VALUE);
                     PipWriteData(c);

                     // Set IRQ to high edge or low level.  Explicitly
                     // ignore what was in the requirements as it may
                     // specify low edge or high level which don't
                     // actually work.

                     if (cmDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
                         c = 2;
                     } else {
                         c = 1;
                     }

                     PipWriteAddress(irqBase + ADDRESS_IRQ_TYPE);
                     PipWriteData(c);

                     DebugPrint((DEBUG_IRQ, "Wrote 0x%x to port %x\n",
                                 (ULONG) c, irqBase));
                     PipWriteAddress(irqBase + ADDRESS_IRQ_TYPE);
                     c = PipReadData();
                     DebugPrint((DEBUG_IRQ, "Read back 0x%x at port %x\n",
                                 (ULONG) c, irqBase));

                     irqBase += ADDRESS_IRQ_INCR;
                 }
                 break;
            case CmResourceTypeDma:
                 if (pass == 1) {
                     noDma++;
                     if (noDma > NUMBER_IRQ_DESCRIPTORS ||
                         (cmDesc->u.Dma.Channel & 0xfffffff8)) {
                         return STATUS_INVALID_PARAMETER;
                     }
                 } else {

                     //
                     // Set the Dma channel to logical device configuration space
                     //

                     c = (UCHAR)cmDesc->u.Dma.Channel;
                     PipWriteAddress(dmaBase + ADDRESS_DMA_VALUE);
                     PipWriteData(c);
                     dmaBase += ADDRESS_DMA_INCR;
                 }
                 break;
            case CmResourceTypeMemory:
                 if (pass == 1) {
                     base = cmDesc->u.Memory.Start.LowPart;
                     limit = base + cmDesc->u.Memory.Length - 1;
                     if (!PipFindMemoryInformation(noMemory, base, limit, BiosRequirements, &tag, &information,NULL)) {
                         return STATUS_INVALID_PARAMETER;
                     } else {
                         if (tag == TAG_MEMORY) {
                              noMemory24++;

                              //
                              // Make sure the lower 8 bits of the base address are zero.
                              //

                              if (noMemory24 > NUMBER_MEMORY_DESCRIPTORS ||
                                  base & 0xff) {
                                  return STATUS_INVALID_PARAMETER;
                              }
                         } else {
                              noMemory32++;
                              if (noMemory32 > NUMBER_32_MEMORY_DESCRIPTORS) {
                                  return STATUS_INVALID_PARAMETER;
                              }
                         }
                     }
                 } else {

                     //
                     // Find information in BiosRequirements to help determine how to  write
                     // the memory configuration space.
                     //

                     base = cmDesc->u.Memory.Start.LowPart;
                     limit = base + cmDesc->u.Memory.Length - 1;
                     PipFindMemoryInformation(noMemory, base, limit, BiosRequirements, &tag, &information,NULL);
                     if (tag == TAG_MEMORY) {
                          PipWriteAddress(memoryBase + ADDRESS_MEMORY_LO);
                          PipWriteData(base >> 0x8);

                          PipWriteAddress(memoryBase + ADDRESS_MEMORY_HI);
                          PipWriteData(base >> 0x10);

                          if ((information & 0x18) == 0) {     // 8 bit memory only
                              c = 0;
                          } else {
                              c = 2;
                          }

                          //
                          // Check range or limit
                          //

                          PipWriteAddress(memoryBase + ADDRESS_MEMORY_CTL);
                          if (PipReadData() & ADDRESS_MEMORY_CTL_LIMIT) {
                              c += ADDRESS_MEMORY_CTL_LIMIT;
                              limit = base + cmDesc->u.Memory.Length;
                          } else {
                              limit = cmDesc->u.Memory.Length; // Range
                              limit = (~limit)+1;
                          }

                          PipWriteAddress(memoryBase + ADDRESS_MEMORY_CTL);
                          PipWriteData(c);

                          PipWriteAddress(memoryBase + ADDRESS_MEMORY_UPPER_LO);
                          PipWriteData((UCHAR)(limit >> 0x8));

                          PipWriteAddress(memoryBase + ADDRESS_MEMORY_UPPER_HI);
                          PipWriteData((UCHAR)(limit >> 0x10));
                          memoryBase += ADDRESS_MEMORY_INCR;
                     } else {
                          tmp = ADDRESS_32_MEMORY_BASE(memory32Base);
                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_B0);
                          PipWriteData(base);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_B1);
                          PipWriteData(base >> 0x8);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_B2);
                          PipWriteData(base >> 0x10);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_B3);
                          PipWriteData(base >> 0x18);

                          switch (information & 0x18) {
                          case 0:      // 8 bit only
                              c = 0;
                          case 8:      // 16 bit only
                          case 0x10:   // 8 and 16 bit supported
                              c = 2;
                              break;
                          case 0x18:   // 32 bit only
                              c = 4;
                              break;
                          }
                          PipWriteAddress(ADDRESS_32_MEMORY_CTL);
                          if (PipReadData() & ADDRESS_MEMORY_CTL_LIMIT) {
                              c += ADDRESS_MEMORY_CTL_LIMIT;
                              limit = base + cmDesc->u.Memory.Length;
                          } else {
                              limit = cmDesc->u.Memory.Length; // Range
                              limit = (~limit) + 1;
                          }
                          PipWriteAddress(ADDRESS_32_MEMORY_CTL);
                          PipWriteData(c);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_E0);
                          PipWriteData(limit);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_E1);
                          PipWriteData(limit >> 0x8);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_E2);
                          PipWriteData(limit >> 0x10);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_E3);
                          PipWriteData(limit >> 0x18);
                          memory32Base++;
                     }
                 }
                 noMemory++;
            }
            cmDesc++;
        }
    }

    //
    // Finally, mark all the unused descriptors as disabled.
    //

    for (i = noMemory24; i < NUMBER_MEMORY_DESCRIPTORS; i++) {
        for (j = 0; j < 5; j++) {
            PipWriteAddress(memoryBase + j);
            PipWriteData(0);
        }
        memoryBase += ADDRESS_MEMORY_INCR;
    }
    for (i = noMemory32; i < NUMBER_32_MEMORY_DESCRIPTORS; i++) {
        tmp = ADDRESS_32_MEMORY_BASE(memory32Base);
        for (j = 0; j < 9; j++) {
            PipWriteAddress(tmp + j);
            PipWriteData(0);
        }
        memory32Base++;
    }
    for (i = noIo; i < NUMBER_IO_DESCRIPTORS; i++) {
        for (j = 0; j < 2; j++) {
            PipWriteAddress(ioBase + j);
            PipWriteData(0);
        }
        ioBase += ADDRESS_IO_INCR;
    }
    for (i = noIrq; i < NUMBER_IRQ_DESCRIPTORS; i++) {
        for (j = 0; j < 2; j++) {
            PipWriteAddress(irqBase + j);
            PipWriteData(0);
        }
        irqBase += ADDRESS_IRQ_INCR;
    }
    for (i = noDma; i < NUMBER_DMA_DESCRIPTORS; i++) {
        PipWriteAddress(dmaBase);
        PipWriteData(4);
        dmaBase += ADDRESS_DMA_INCR;
    }


    return STATUS_SUCCESS;
}

VOID
PipLFSRInitiation(
    VOID
    )

/*++

Routine Description:

    This routine insures the LFSR (linear feedback shift register) is in its
    initial state and then performs 32 writes to the ADDRESS port to initiation
    LFSR function.

    Pnp software sends the initiation key to all the Pnp ISA cards to place them
    into configuration mode.  The software then ready to perform isolation
    protocol.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR seed, bit7;
    ULONG i;

    ASSERT(PipState == PiSWaitForKey);
    //
    // First perform two writes of value zero to insure the LFSR is in the
    // initial state.
    //

    PipWriteAddress (0);
    PipWriteAddress (0);

    //
    // Perform the initiation key.
    //

    seed = LFSR_SEED;               // initial value of 0x6a
    for (i = 0; i < 32; i++) {
        PipWriteAddress (seed);
        bit7=(((seed & 2) >> 1) ^ (seed & 1)) << 7;
        seed =(seed >> 1) | bit7;
    }

    DebugPrint((DEBUG_ISOLATE, "Sent initiation key\n"));
    PipReportStateChange(PiSSleep);
}

VOID
PipIsolateCards (
    OUT PUCHAR NumberCSNs
    )

/*++

Routine Description:

    This routine performs PnP ISA cards isolation sequence.

Arguments:

    NumberCSNs - supplies the addr of a variable to receive the number of
        Pnp Isa cards isolated.

    ReadDataPort - Supplies the address of a variable to supply ReadData port
        address.

Return Value:

    None.

--*/
{
    USHORT j, i;
    UCHAR  cardId[NUMBER_CARD_ID_BYTES];
    UCHAR  bit, bit7, checksum, byte1, byte2;
    UCHAR  csn;


    //
    // First send Initiation Key to all the PNP ISA cards to enable PnP auto-config
    // ports and put all cards into sleep state
    //

    PipLFSRInitiation();

    //
    // Reset all Pnp ISA cards' CSN to 0 and return to wait-for-key state
    //

    PipWriteAddress (CONFIG_CONTROL_PORT);
    PipWriteData (CONTROL_RESET_CSN + CONTROL_WAIT_FOR_KEY);

    DebugPrint((DEBUG_STATE, "Reset CSNs, going to WaitForKey\n"));
    PipReportStateChange(PiSWaitForKey);

    csn=*NumberCSNs = 0;

    //
    // Delay 2 msec for cards to load initial configuration state.
    //

    KeStallExecutionProcessor(2000);     // delay 2 msec

    //
    // Put cards into configuration mode to ready isolation process.
    // The hardware on each PnP Isa card expects 72 pairs of I/O read
    // access to the read data port.
    //

    PipLFSRInitiation();

    //
    // Starting Pnp Isa card isolation process.
    //

    //
    // Send WAKE[CSN=0] to force all cards without CSN into isolation
    // state to set READ DATA PORT.
    //

    PipIsolation();

    KeStallExecutionProcessor(1000);     // delay 1 msec

    DebugPrint((DEBUG_STATE, "Wake all cards without CSN, Isolation\n"));

    //
    // Set read data port to current testing value.
    //

    PipWriteAddress(SET_READ_DATA_PORT);
    PipWriteData((UCHAR)((ULONG_PTR)PipReadDataPort >> 2));

    DebugPrint((DEBUG_STATE, "Set RDP to %x\n", PipReadDataPort));
    //
    // Isolate one PnP ISA card until fail
    //

    PipIsolation();

    while (TRUE) {



        //
        // Read serial isolation port to cause PnP cards in the isolation
        // state to compare one bit of the boards ID.
        //

        PipWriteAddress(SERIAL_ISOLATION_PORT);

        //
        // We need to delay 1 msec prior to starting the first pair of isolation
        // reads and must wait 250usec between each subsequent pair of isolation
        // reads.  This delay gives the ISA cards time to access information from
        // possible very slow storage device.
        //

        KeStallExecutionProcessor(1000); // delay 1 msec

        RtlZeroMemory(cardId, NUMBER_CARD_ID_BYTES);
        checksum = LFSR_SEED;
        for (j = 0; j < NUMBER_CARD_ID_BITS; j++) {

            //
            // Read card id bit by bit
            //

            byte1 = PipReadData();
            byte2 = PipReadData();
            bit = (byte1 == ISOLATION_TEST_BYTE_1) && (byte2 == ISOLATION_TEST_BYTE_2);
            cardId[j / 8] |= bit << (j % 8);
            if (j < CHECKSUMED_BITS) {

                //
                // Calculate checksum and only do it for the first 64 bits
                //

                bit7 = (((checksum & 2) >> 1) ^ (checksum & 1) ^ (bit)) << 7;
                checksum = (checksum >> 1) | bit7;
            }
            KeStallExecutionProcessor(250); // delay 250 usec
        }

        //
        // Verify the card id we read is legitimate
        // First make sure checksum is valid.  Note zero checksum is considered valid.
        //
        DebugPrint((DEBUG_ISOLATE, "Card Bytes: %X %X %X %X %X %X %X %X %X\n",cardId[0],cardId[1],cardId[2],cardId[3],cardId[4],cardId[5],cardId[6],cardId[7],cardId[8]));
        if (cardId[8] == 0 || checksum == cardId[8]) {
            //
            // Next make sure cardId is not zero
            //

            byte1 = 0;
            for (j = 0; j < NUMBER_CARD_ID_BYTES; j++) {
                byte1 |= cardId[j];
            }
            if (byte1 != 0) {

                //
                // Make sure the vender EISA ID bytes are nonzero
                //

                if ((cardId[0] & 0x7f) != 0 && cardId[1] != 0) {

                    //
                    // We found a valid Pnp Isa card, assign it a CSN number
                    //
                    DebugPrint((DEBUG_ISOLATE, "Assigning csn %d\n",csn+1));

                    PipWriteAddress(SET_CSN_PORT);
                    PipWriteData(++csn);
                    if (PipReadData() != csn) {
                        csn--;

                        DebugPrint((DEBUG_ISOLATE, "Assigning csn %d FAILED, bailing!\n",csn+1));

                        PipIsolation();
                        PipSleep();
                        *NumberCSNs = csn;
                        return;
                    }

                    //
                    // Do Wake[CSN] command to put the newly isolated card to
                    // sleep state and other un-isolated cards to isolation
                    // state.
                    //

                    PipIsolation();

                    DebugPrint((DEBUG_STATE, "Put card in Sleep, other in Isolation\n"));

                    continue;     // ... to isolate more cards ...
                }
            }
        }else {

            DebugPrint ((DEBUG_ISOLATE, "invalid read during isolation\n"));
        }
        break;                // could not isolate more cards ...
    }

    //
    // Finaly put all cards into sleep state
    //

    PipSleep();
    *NumberCSNs = csn;
}

ULONG
PipFindNextLogicalDeviceTag (
    IN OUT PUCHAR *CardData,
    IN OUT LONG *Limit
    )

/*++

Routine Description:

    This function searches the Pnp Isa card data for the Next logical
    device tag encountered.  The input *CardData should point to an logical device id tag,
    which is the current logical device tag.  If the *CardData does not point to a logical
    device id tag (but, it must point to some kind of tag), it will be moved to next
    logical device id tag.

Arguments:

    CardData - a variable to supply a pointer to the pnp Isa resource descriptors and to
        receive next logical device tag pointer.

    Limit - a variable to supply the maximum length of the search and to receive the new
        lemit after the search.

Return Value:

    Length of the data between current and next logical device tags, ie the data length
    of the current logical device.
    In case there is no 'next' logical device tag, the returned *CardData = NULL,
    *Limit = zero and the data length of current logical tag is returned as function
    returned value.

--*/
{
    UCHAR tag;
    USHORT size;
    LONG l;
    ULONG retLength;
    PUCHAR p;
    BOOLEAN atIdTag = FALSE;;

    p = *CardData;
    l = *Limit;
    tag = *p;
    retLength = 0;
    while (tag != TAG_COMPLETE_END && l > 0) {

        //
        // Determine the size of the BIOS resource descriptor
        //

        if (!(tag & LARGE_RESOURCE_TAG)) {
            size = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
            size += 1;                          // length of small tag
        } else {
            size = *((USHORT UNALIGNED *)(p + 1));
            size += 3;                          // length of large tag
        }

        p += size;
        retLength += size;
        l -= size;
        tag = *p;
        if ((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID) {
            *CardData = p;
            *Limit = l;
            return retLength;
        }
    }
    *CardData = NULL;
    *Limit = 0;
    if (tag == TAG_COMPLETE_END) {
        return (retLength + 2);             // add 2 for the length of end tag descriptor
    } else {
        return 0;
    }
}


NTSTATUS
PipReadCardResourceDataBytes (
    IN USHORT BytesToRead,
    IN PUCHAR Buffer
    )

/*++

Routine Description:

    This function reads specified number of bytes of card resource data .

Arguments:

    BytesToRead - supplies number of bytes to read.

    Buffer - supplies a pointer to a buffer to receive the read bytes.

Return Value:

    None
--*/
{
    USHORT i, j;
    PUCHAR p;
    for (i = 0, p = Buffer; i < BytesToRead; i++, p++) {

        PipWriteAddress(CONFIG_DATA_STATUS_PORT);

        //
        // Waiting for data ready status bit
        //

        j = 0;
        while ((PipReadData() & 1) != 1) {
            if (j == 10000) {
                return STATUS_NO_SUCH_DEVICE;
            }
            KeStallExecutionProcessor(1000); // delay 1 msec
            j++;
        }

        //
        // Read the data ...
        //

        PipWriteAddress(CONFIG_DATA_PORT);
        *p = PipReadData();
    }
    return STATUS_SUCCESS;

}

USHORT
PipIrqLevelRequirementsFromDeviceData(
    IN PUCHAR BiosRequirements,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine searches the resource data for IRQ tags and extracts
    information on whether edge/level is specified.  This is on a per
    logical device basis.

  Arguments:

    BiosRequirements - the per-device tags.

    Length - Length of per-device tag area.

Return Value:

    edge/level as specified by the device requirements.

--*/
{
    UCHAR tag, level;
    ULONG increment;
    USHORT irqFlags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
    PPNP_IRQ_DESCRIPTOR biosDesc;
    BOOLEAN sawIrq = FALSE;

    //
    // Skip current logical id tag
    //

    tag = *BiosRequirements;
    ASSERT((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID);
    BiosRequirements += (tag & SMALL_TAG_SIZE_MASK) + 1;

    //
    // Search the possible resource list to get the information
    // for the Irq.
    //

    tag = *BiosRequirements;
    while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID)) {
        if ((tag & SMALL_TAG_MASK) == TAG_IRQ) {
            sawIrq = TRUE;
            biosDesc = (PPNP_IRQ_DESCRIPTOR)BiosRequirements;
            if ((tag & SMALL_TAG_SIZE_MASK) == 2) {
                irqFlags = CM_RESOURCE_INTERRUPT_LATCHED;
            } else {
                level = biosDesc->Information;
                DebugPrint((DEBUG_IRQ, "Irq req info is %x\n", (ULONG) level));
                if (level == 0xF) {
                    // register is broken, assume edge
                    irqFlags = CM_RESOURCE_INTERRUPT_LATCHED;
                } else if (level & 0x3) {
                    irqFlags = CM_RESOURCE_INTERRUPT_LATCHED;
                } else if (level & 0xC) {
                    irqFlags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
                }
            }
        }
        if (tag & LARGE_RESOURCE_TAG) {
            increment = *((USHORT UNALIGNED *)(BiosRequirements + 1));
            increment += 3;     // length of large tag
        } else {
            increment = tag & SMALL_TAG_SIZE_MASK;
            increment += 1;     // length of small tag
        }
        BiosRequirements += increment;
        tag = *BiosRequirements;
    }

    if (!sawIrq) {
        return CM_RESOURCE_INTERRUPT_LATCHED;
    }

    return irqFlags;
}

VOID
PipFixBootConfigIrqs(
    IN PCM_RESOURCE_LIST BootResources,
    IN USHORT irqFlags
    )
/*++

Routine Description:

    This routine modifies the boot config resources list to reflect
    whether the devices's irqs should be considered edge or level.
    This is on a per logical device basis.

  Arguments:

    BootResources - Boot config as determined by PipReadDeviceResources()

    irqFlags - level/edge setting to apply to boot config resources

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
    ULONG count = 0, size, i, j;

    if (BootResources == NULL) {
        return;
    }

    cmFullDesc = &BootResources->List[0];
    for (i = 0; i < BootResources->Count; i++) {
        cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            size = 0;
            if (cmPartDesc->Type == CmResourceTypeInterrupt) {

                cmPartDesc->Flags = irqFlags;

                if (cmPartDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
                    cmPartDesc->ShareDisposition = CmResourceShareDeviceExclusive;
                }
            } else if (cmPartDesc->Type == CmResourceTypeDeviceSpecific) {
                    size = cmPartDesc->u.DeviceSpecificData.DataSize;
            }
            cmPartDesc++;
            cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\init.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    init.c

Abstract:

    DriverEntry initialization code for pnp isa bus driver

Author:

    Shie-Lin Tzong (shielint) 3-Jan-1997

Environment:

    Kernel mode only.

Revision History:

--*/


#include "busp.h"
#include "pnpisa.h"

BOOLEAN
PipIsIsolationDisabled(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,PipIsIsolationDisabled)
#endif

#if ISOLATE_CARDS

BOOLEAN
PipIsIsolationDisabled(
    )

/*++

Description:

    Look in the registry for flag indicating that isolation has been
    disabled.  This is a last resort hook for platforms that can't
    deal with the RDP and it's boot config.

Return Value:

   BOOLEAN indicating whether isolation is disabled or not.

--*/

{
    HANDLE         serviceHandle, paramHandle;
    UNICODE_STRING paramString;
    PKEY_VALUE_FULL_INFORMATION keyInfo;
    NTSTATUS       status;
    BOOLEAN        result = FALSE;

    status = PipOpenRegistryKey(&serviceHandle,
                                NULL,
                                &PipRegistryPath,
                                KEY_READ,
                                FALSE);
    if (!NT_SUCCESS(status)) {
        return result;
    }

    RtlInitUnicodeString(&paramString, L"Parameters");
    status = PipOpenRegistryKey(&paramHandle,
                                serviceHandle,
                                &paramString,
                                KEY_READ,
                                FALSE);
    ZwClose(serviceHandle);
    if (!NT_SUCCESS(status)) {
        return result;
    }

    status = PipGetRegistryValue(paramHandle,
                                 L"IsolationDisabled",
                                 &keyInfo);
    ZwClose(paramHandle);
    if (NT_SUCCESS(status)) {
        if((keyInfo->Type == REG_DWORD) &&
           (keyInfo->DataLength >= sizeof(ULONG))) {
            result = *(PULONG)KEY_VALUE_DATA(keyInfo) != 0;
        }
        ExFreePool(keyInfo);
    }

    return result;
}
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes driver object major function table to handle Pnp IRPs
    and AddDevice entry point.  If detection is allowed, it reports a detected device
    for the pseudo isapnp bus and performs enumeration.

Arguments:

    DriverObject - specifies the driver object for the bus extender.

    RegistryPath - supplies a pointer to a unicode string of the service key name in
        the CurrentControlSet\Services key for the bus extender.

Return Value:

    Always return STATUS_UNSUCCESSFUL.

--*/

{

    PDRIVER_EXTENSION driverExtension;
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT detectedDeviceObject = NULL;

    PipDriverObject = DriverObject;
    //
    // Fill in the driver object
    //

    DriverObject->DriverUnload = PiUnload;
    DriverObject->MajorFunction[IRP_MJ_PNP] = PiDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = PiDispatchPower;
    //
    // Device and system control IRPs can be handled in the same way
    // we basically don't touch them
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PiDispatchDevCtl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PiDispatchDevCtl;

    driverExtension = DriverObject->DriverExtension;
    driverExtension->AddDevice = PiAddDevice;

    //
    // Store our registry path globally so we can use it later
    //

    PipRegistryPath.Length = RegistryPath->Length;
    PipRegistryPath.MaximumLength = RegistryPath->MaximumLength;
    PipRegistryPath.Buffer = ExAllocatePool(PagedPool,
                                               RegistryPath->MaximumLength );
    if( PipRegistryPath.Buffer == NULL ){
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory( PipRegistryPath.Buffer,
                   RegistryPath->Buffer,
                   RegistryPath->MaximumLength );

    //
    // Initialize global varaibles
    //

    KeInitializeEvent (&PipDeviceTreeLock, SynchronizationEvent, TRUE);
    KeInitializeEvent (&IsaBusNumberLock, SynchronizationEvent, TRUE);

    BusNumBM=&BusNumBMHeader;
    RtlInitializeBitMap (BusNumBM,BusNumberBuffer,256/sizeof (ULONG));
    RtlClearAllBits (BusNumBM);

#if ISOLATE_CARDS
    PipIsolationDisabled = PipIsIsolationDisabled();
#endif

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\misc.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This file contains pnp isa bus extender support routines.

Author:

    Shie-Lin Tzong (shielint) 27-July-1995

Environment:

    Kernel mode only.

Revision History:

--*/


#include "busp.h"
#include "pnpisa.h"

#ifdef ALLOC_PRAGMA
//#pragma alloc_text(PAGE, PipLockDeviceDatabase)
//#pragma alloc_text(PAGE, PipUnlockDeviceDatabase)
#pragma alloc_text(PAGE, PipQueryDeviceRelations)
//#pragma alloc_text(PAGE, PipIsCardEnumeratedAlready)
#pragma alloc_text(PAGE, PipCleanupAcquiredResources)
#pragma alloc_text(PAGE, PipMapReadDataPort)
#pragma alloc_text(PAGE, PipGetMappedAddress)
#pragma alloc_text(PAGE, PipDecompressEisaId)
#pragma alloc_text(PAGE, PipLogError)
#pragma alloc_text(PAGE, PipOpenRegistryKey)
#pragma alloc_text(PAGE, PipGetRegistryValue)
#pragma alloc_text(PAGE, PipOpenCurrentHwProfileDeviceInstanceKey)
#pragma alloc_text(PAGE, PipGetDeviceInstanceCsConfigFlags)
#pragma alloc_text(PAGE, PipDetermineResourceListSize)
#pragma alloc_text(PAGE, PipResetGlobals)
#pragma alloc_text(PAGE, PipMapAddressAndCmdPort)
#pragma alloc_text(PAGE, PiNeedDeferISABridge)
#pragma alloc_text(PAGE, PipReleaseDeviceResources)
#if DBG
//#pragma alloc_text(PAGE, PipDebugPrint)
#pragma alloc_text(PAGE, PipDumpIoResourceDescriptor)
#pragma alloc_text(PAGE, PipDumpIoResourceList)
#pragma alloc_text(PAGE, PipDumpCmResourceDescriptor)
#pragma alloc_text(PAGE, PipDumpCmResourceList)
#endif
#endif

#define IRQFLAGS_VALUE_NAME L"IrqFlags"
#define BOOTRESOURCES_VALUE_NAME L"BootRes"

#if ISOLATE_CARDS

UCHAR CurrentCsn = 0;
UCHAR CurrentDev = 255;

VOID
PipWaitForKey(VOID)
{
    ASSERT((PipState == PiSConfig) || (PipState == PiSIsolation) || (PipState == PiSSleep));
    PipWriteAddress(CONFIG_CONTROL_PORT);
    PipWriteData(CONTROL_WAIT_FOR_KEY);
    PipReportStateChange(PiSWaitForKey);
    CurrentCsn = 0;
    CurrentDev = 255;
}

VOID
PipConfig(
    IN UCHAR Csn
)
{
    ASSERT(Csn);
    ASSERT((PipState == PiSConfig) || (PipState == PiSIsolation) || (PipState == PiSSleep));
    PipWriteAddress(WAKE_CSN_PORT);
    PipWriteData(Csn);
    DebugPrint((DEBUG_STATE, "Wake CSN %u\n", (ULONG) Csn));
    CurrentCsn = Csn;
    CurrentDev = 255;
    PipReportStateChange(PiSConfig);
}

VOID
PipIsolation(
    VOID
)
{
    ASSERT((PipState == PiSConfig) || (PipState == PiSIsolation) || (PipState == PiSSleep));
    PipWriteAddress(WAKE_CSN_PORT);
    PipWriteData(0);
    CurrentCsn = 0;
    CurrentDev = 255;
    DebugPrint((DEBUG_STATE, "Isolate cards w/o CSN\n"));
    PipReportStateChange(PiSIsolation);
}
VOID
PipSleep(
    VOID
)
{
    ASSERT((PipState == PiSConfig) || PipState == PiSIsolation);
    PipWriteAddress(WAKE_CSN_PORT);
    PipWriteData(0);
    CurrentCsn = 0;
    CurrentDev = 255;
    DebugPrint((DEBUG_STATE, "Putting all cards to sleep (we think)\n"));
    PipReportStateChange(PiSSleep);
}

VOID
PipActivateDevice (
    )
{
    UCHAR tmp;

    PipWriteAddress(IO_RANGE_CHECK_PORT);
    tmp = PipReadData();
    tmp &= ~2;
    PipWriteAddress(IO_RANGE_CHECK_PORT);
    PipWriteData(tmp);
    PipWriteAddress(ACTIVATE_PORT);
    PipWriteData(1);

    DebugPrint((DEBUG_STATE, "Activated card CSN %d/LDN %d\n",
                (ULONG) CurrentCsn,
                (ULONG) CurrentDev));
}
VOID
PipDeactivateDevice (
    )
{
    PipWriteAddress(ACTIVATE_PORT);
    PipWriteData(0);

    DebugPrint((DEBUG_STATE, "Deactivated card CSN %d/LDN %d\n",
                (ULONG) CurrentCsn,
                (ULONG) CurrentDev));
}

VOID
PipSelectDevice(
    IN UCHAR Device
    )
{
    ASSERT(PipState == PiSConfig);
    PipWriteAddress(LOGICAL_DEVICE_PORT);
    PipWriteData(Device);

    CurrentDev = Device;
    DebugPrint((DEBUG_STATE, "Selected CSN %d/LDN %d\n",
                (ULONG) CurrentCsn,
                (ULONG) Device));
}

VOID
PipWakeAndSelectDevice(
    IN UCHAR Csn,
    IN UCHAR Device
    )
{
    PipLFSRInitiation();
    PipConfig(Csn);
    PipSelectDevice(Device);
}

PDEVICE_INFORMATION
PipReferenceDeviceInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN ConfigHardware
    )

/*++

Routine Description:

    This function locks a device node so it won't go away.

    Note, this function does not lock the whole device node tree.

Arguments:

    DeviceNode - Supplies a pointer to the device information node

Return Value:

    None.

--*/

{
    PDEVICE_INFORMATION deviceInfo;

    deviceInfo = (PDEVICE_INFORMATION)DeviceObject->DeviceExtension;
    if (deviceInfo && !(deviceInfo->Flags & DF_DELETED)) {

        if ((deviceInfo->Flags & DF_NOT_FUNCTIONING) && ConfigHardware) {
            PipDereferenceDeviceInformation(NULL, FALSE);
            return NULL;
        }

        if (!(deviceInfo->Flags & DF_READ_DATA_PORT) && ConfigHardware) {
            PipWakeAndSelectDevice(
                deviceInfo->CardInformation->CardSelectNumber,
                deviceInfo->LogicalDeviceNumber);
        }

        return deviceInfo;
    } else {
        PipDereferenceDeviceInformation(NULL, FALSE);
        return NULL;
    }
}

VOID
PipDereferenceDeviceInformation(
    IN PDEVICE_INFORMATION DeviceInformation, BOOLEAN ConfigedHardware
    )

/*++

Routine Description:

    This function releases the enumeration lock of the specified device node.

Arguments:

    DeviceNode - Supplies a pointer to the device node whose lock is to be released.

Return Value:

    None.

--*/

{
    //
    // Synchronize the dec and set event operations with IopAcquireEnumerationLock.
    //

    if (DeviceInformation) {


        if (!(DeviceInformation->Flags & DF_READ_DATA_PORT) && ConfigedHardware) {
            if (PipState != PiSWaitForKey) {
                PipWaitForKey();
            }
        }
    }
}

VOID
PipLockDeviceDatabase(
    VOID
    )

/*++

Routine Description:

    This function locks the whole device node tree.  Currently, eject operation
    needs to lock the whole device node tree.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KeWaitForSingleObject( &PipDeviceTreeLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

}

VOID
PipUnlockDeviceDatabase (
    VOID
    )

/*++

Routine Description:

    This function releases the lock of the whole device node tree.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KeSetEvent( &PipDeviceTreeLock,
                0,
                FALSE );
}

VOID
PipDeleteDevice (
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine

Parameters:

    P1 -

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_INFORMATION deviceInfo, devicex, devicep;
    PCARD_INFORMATION cardInfo, cardx, cardp;
    PSINGLE_LIST_ENTRY deviceLink, cardLink;
    NTSTATUS status = STATUS_SUCCESS;
    PPI_BUS_EXTENSION busExtension;

    deviceInfo = (PDEVICE_INFORMATION)DeviceObject->DeviceExtension;

    deviceInfo->Flags |= DF_DELETED;

    //
    // Free the pool
    //

    if (deviceInfo->ResourceRequirements) {
        ExFreePool(deviceInfo->ResourceRequirements);
        deviceInfo->ResourceRequirements = NULL;
    }

    if (deviceInfo->BootResources) {
        ExFreePool(deviceInfo->BootResources);
        deviceInfo->BootResources = NULL;
    }

    if (deviceInfo->AllocatedResources) {
        ExFreePool(deviceInfo->AllocatedResources);
        deviceInfo->AllocatedResources = NULL;
    }

    if (deviceInfo->LogConfHandle) {
        ZwClose(deviceInfo->LogConfHandle);
        deviceInfo->LogConfHandle = NULL;
    }

    busExtension = deviceInfo->ParentDeviceExtension;
    cardInfo = deviceInfo->CardInformation;

    PipLockDeviceDatabase();

    //
    // Remove the device from device list.
    //

    deviceLink = busExtension->DeviceList.Next;
    devicep = NULL;
    devicex = NULL;
    while (deviceLink) {
        devicex = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);
        if (devicex == deviceInfo) {
             break;
        }
        devicep = devicex;
        deviceLink = devicex->DeviceList.Next;
    }
    ASSERT(devicex == deviceInfo);
    if (devicep == NULL) {
        busExtension->DeviceList.Next = deviceInfo->DeviceList.Next;
    } else {
        devicep->DeviceList.Next = deviceInfo->DeviceList.Next;
    }

    //
    // Remove the device from logical device list of the card
    //

    deviceLink = cardInfo->LogicalDeviceList.Next;
    devicep = NULL;
    devicex = NULL;
    while (deviceLink) {
        devicex = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, LogicalDeviceList);
        if (devicex == deviceInfo) {
             break;
        }
        devicep = devicex;
        deviceLink = devicex->LogicalDeviceList.Next;
    }
    ASSERT(devicex == deviceInfo);
    if (devicep == NULL) {
        cardInfo->LogicalDeviceList.Next = deviceInfo->LogicalDeviceList.Next;
    } else {
        devicep->LogicalDeviceList.Next = deviceInfo->LogicalDeviceList.Next;
    }

    cardInfo->NumberLogicalDevices--;

    //
    // All the devices are gone.  That means the card is removed.
    // Next remove the isapnp card structure.
    //

    if (cardInfo->NumberLogicalDevices == 0) {
        ASSERT(cardInfo->LogicalDeviceList.Next == NULL);
        cardLink = busExtension->CardList.Next;
        cardp = NULL;
        cardx = NULL;
        while (cardLink) {
            cardx = CONTAINING_RECORD (cardLink, CARD_INFORMATION, CardList);
            if (cardx == cardInfo) {
                 break;
            }
            cardp = cardx;
            cardLink = cardx->CardList.Next;
        }
        ASSERT(cardx == cardInfo);
        if (cardp == NULL) {
            busExtension->CardList.Next = cardInfo->CardList.Next;
        } else {
            cardp->CardList.Next = cardInfo->CardList.Next;
        }
    }

    PipUnlockDeviceDatabase();

    //
    // Remove the card information structure after releasing spin lock.
    //

    if (cardInfo->NumberLogicalDevices == 0) {
        if (cardInfo->CardData) {
            ExFreePool(cardInfo->CardData);
        }
        ExFreePool(cardInfo);
        deviceInfo->CardInformation = NULL;
    }

    IoDeleteDevice(DeviceObject);
}

NTSTATUS
PipQueryDeviceRelations (
    PPI_BUS_EXTENSION BusExtension,
    PDEVICE_RELATIONS *DeviceRelations,
    BOOLEAN Removal
    )

/*++

Routine Description:

    This routine

Parameters:

    P1 -

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_INFORMATION deviceInfo;
    PSINGLE_LIST_ENTRY deviceLink;
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT *devicePtr;
    ULONG count = 0;
    PDEVICE_RELATIONS deviceRelations;

    PAGED_CODE();

    *DeviceRelations = NULL;

    //
    // Go through the card link list to match the card data
    //

    deviceLink = BusExtension->DeviceList.Next;
    while (deviceLink) {
        deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);
        //
        // if it's the RDP ignore it for removal relations
        //
        if ((deviceInfo->Flags & DF_ENUMERATED) &&
            (!(deviceInfo->Flags & DF_READ_DATA_PORT) || !Removal)) {
             count++;
        } else {

            DebugPrint((DEBUG_PNP, "PipQueryDeviceRelations skipping a node, Flags: %x\n",deviceInfo->Flags));
        }
        deviceLink = deviceInfo->DeviceList.Next;
    }
    if (count != 0) {
        deviceRelations = (PDEVICE_RELATIONS) ExAllocatePool(
                             PagedPool,
                             sizeof(DEVICE_RELATIONS) + (count - 1) * sizeof(PDEVICE_OBJECT));
        if (deviceRelations) {
            deviceRelations->Count = count;
            deviceLink = BusExtension->DeviceList.Next;
            devicePtr = deviceRelations->Objects;
            while (deviceLink) {
                deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);

                if ((deviceInfo->Flags & DF_ENUMERATED) &&
                    (!(deviceInfo->Flags & DF_READ_DATA_PORT) || !(Removal))) {
                     ObReferenceObject(deviceInfo->PhysicalDeviceObject);
                     *devicePtr = deviceInfo->PhysicalDeviceObject;
                     devicePtr++;
                }
                deviceLink = deviceInfo->DeviceList.Next;
            }
            *DeviceRelations = deviceRelations;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return status;
}

PCARD_INFORMATION
PipIsCardEnumeratedAlready(
    IN PPI_BUS_EXTENSION BusExtension,
    IN PUCHAR CardData,
    IN ULONG DataLength
    )

/*++

Routine Description:

    This routine finds the card information structure which contains the same CardData.

Parameters:

    CardData - Supplies a pointer to the CardData

    DataLength - The length of the CardData

Return Value:

    A pointer to the CARD_INFORMATION structure if found.

--*/

{
    PCARD_INFORMATION cardInfo;
    PSINGLE_LIST_ENTRY cardLink;
    PSERIAL_IDENTIFIER serialId1, serialId2 = (PSERIAL_IDENTIFIER)CardData;

    //
    // Go through the card link list to match the card data
    //

    cardLink = BusExtension->CardList.Next;
    while (cardLink) {
        cardInfo = CONTAINING_RECORD (cardLink, CARD_INFORMATION, CardList);
        if (cardInfo->CardSelectNumber != 0) {   // if == 0, card is no longer present
            serialId1 = (PSERIAL_IDENTIFIER)cardInfo->CardData;
            ASSERT(serialId1 && serialId2);
            if (serialId1->VenderId == serialId2->VenderId &&
                serialId1->SerialNumber == serialId2->SerialNumber) {
                return cardInfo;
            }
        }
        cardLink = cardInfo->CardList.Next;         // Get the next addr before releasing pool
    }
    return NULL;
}

VOID
PipCleanupAcquiredResources (
    PPI_BUS_EXTENSION BusExtension
    )

/*++

Routine Description:

    This routine cleans up the resources assigned to the readdata, command and address
    ports.

Parameters:

    BusExtension - specifies the isapnp bus to be cleaned up.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Release address, command and read data port resources.
    //

    if (BusExtension->CommandPort && BusExtension->CmdPortMapped) {
        MmUnmapIoSpace(BusExtension->CommandPort, 1);
        BusExtension->CmdPortMapped = FALSE;
    }
    BusExtension->CommandPort = NULL;

    if (BusExtension->AddressPort && BusExtension->AddrPortMapped) {
        MmUnmapIoSpace(BusExtension->AddressPort, 1);
        BusExtension->AddrPortMapped = FALSE;
    }
    BusExtension->AddressPort = NULL;

    if (BusExtension->ReadDataPort) {
        PipReadDataPort = PipCommandPort = PipAddressPort = NULL;
    }
    if (BusExtension->ReadDataPort && BusExtension->DataPortMapped) {
        MmUnmapIoSpace(BusExtension->ReadDataPort - 3, 4);
        BusExtension->DataPortMapped = FALSE;
    }
    BusExtension->ReadDataPort = NULL;
}

NTSTATUS
PipMapReadDataPort (
    IN PPI_BUS_EXTENSION BusExtension,
    IN PHYSICAL_ADDRESS Start,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine maps specified port resources.

Arguments:

    BusExtension - Supplies a pointer to the pnp bus extension.

    BaseAddressLow,
    BaseAddressHi - Supplies the read data port base address range to be mapped.
Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    ULONG size;
    PHYSICAL_ADDRESS physicalAddress;
    ULONG dumpData[3];
    BOOLEAN conflictDetected;

    PAGED_CODE();

    if (BusExtension->ReadDataPort && BusExtension->DataPortMapped) {
        MmUnmapIoSpace(PipReadDataPort - 3, 4);
        PipReadDataPort = BusExtension->ReadDataPort = NULL;
        BusExtension->DataPortMapped = FALSE;
    }

    PipReadDataPort = PipGetMappedAddress(
                             Isa,             // InterfaceType
                             0,               // BusNumber,
                             Start,
                             Length,
                             CM_RESOURCE_PORT_IO,
                             &BusExtension->DataPortMapped
                             );

    DebugPrint((DEBUG_RDP, "PnpIsa:ReadDataPort is at %x\n",PipReadDataPort+3));
    if (PipReadDataPort) {
        PipReadDataPort += 3;
        BusExtension->ReadDataPort = PipReadDataPort;
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return status;
}

PVOID
PipGetMappedAddress(
    IN  INTERFACE_TYPE BusType,
    IN  ULONG BusNumber,
    IN  PHYSICAL_ADDRESS IoAddress,
    IN  ULONG NumberOfBytes,
    IN  ULONG AddressSpace,
    OUT PBOOLEAN MappedAddress
    )

/*++

Routine Description:

    This routine maps an IO address to system address space.

Arguments:

    BusType - Supplies the type of bus - eisa, mca, isa...

    IoBusNumber - Supplies the bus number.

    IoAddress - Supplies the base device address to be mapped.

    NumberOfBytes - Supplies the number of bytes for which the address is
                    valid.

    AddressSpace - Supplies whether the address is in io space or memory.

    MappedAddress - Supplies whether the address was mapped. This only has
                      meaning if the address returned is non-null.

Return Value:

    The mapped address.

--*/

{
    PHYSICAL_ADDRESS cardAddress;
    PVOID address;
    BOOLEAN returnVal;

    PAGED_CODE();

    returnVal = HalTranslateBusAddress(BusType, BusNumber, IoAddress, &AddressSpace,
                                       &cardAddress);
    if (returnVal == FALSE) {
        
        *MappedAddress = FALSE;
        return NULL;
    }

    //
    // Map the device base address into the virtual address space
    // if the address is in memory space.
    //

    if (!AddressSpace) {

        address = MmMapIoSpace(cardAddress, NumberOfBytes, FALSE);
        *MappedAddress = (address ? TRUE : FALSE);

    } else {

        address = (PVOID) cardAddress.LowPart;
        *MappedAddress = FALSE;
    }

    return address;
}

VOID
PipDecompressEisaId(
    IN ULONG CompressedId,
    OUT PWCHAR EisaId
    )

/*++

Routine Description:

    This routine decompressed compressed Eisa Id and returns the Id to caller
    specified character buffer.

Arguments:

    CompressedId - supplies the compressed Eisa Id.

    EisaId - supplies a 8-wchar buffer to receive the decompressed Eisa Id.

Return Value:

    None.

--*/

{
    USHORT c1, c2;
    LONG i;

    PAGED_CODE();

    CompressedId &= 0xffffff7f;           // remove the reserved bit (bit 7 of byte 0)
    c1 = c2 = (USHORT)CompressedId;
    c1 = (c1 & 0xff) << 8;
    c2 = (c2 & 0xff00) >> 8;
    c1 |= c2;
    for (i = 2; i >= 0; i--) {
        *(EisaId + i) = (WCHAR)(c1 & 0x1f) + 0x40;
        c1 >>= 5;
    }
    EisaId += 3;
    c1 = c2 = (USHORT)(CompressedId >> 16);
    c1 = (c1 & 0xff) << 8;
    c2 = (c2 & 0xff00) >> 8;
    c1 |= c2;
    StringCchPrintf(EisaId,
                    5,
                    L"%04x",
                    c1
                    );
}

VOID
PipLogError(
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PULONG DumpData,
    IN ULONG DumpCount,
    IN USHORT StringLength,
    IN PWCHAR String
    )

/*++

Routine Description:

    This routine contains common code to write an error log entry.  It is
    called from other routines to avoid duplication of code.  This routine
    only allows caller to supply one insertion string to the error log.

Arguments:

    ErrorCode - The error code for the error log packet.

    UniqueErrorValue - The unique error value for the error log packet.

    FinalStatus - The final status of the operation for the error log packet.

    DumpData - Pointer to an array of dump data for the error log packet.

    DumpCount - The number of entries in the dump data array.

    StringLength - The length of insertion string *NOT* including the NULL terminater.

    String - The pointer to the insertion string

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG i, size;
    PUCHAR p;

    size = sizeof(IO_ERROR_LOG_PACKET) + DumpCount * sizeof(ULONG) +
           StringLength + sizeof(UNICODE_NULL) - sizeof(ULONG);
    
    ASSERT(size <= MAXUCHAR);
    if (size > MAXUCHAR) {
        return;
    }

    errorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(
                                               PipDriverObject,
                                               (UCHAR) size
                                               );
    if (errorLogEntry != NULL) {

        RtlZeroMemory(errorLogEntry, size);

        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->DumpDataSize = (USHORT) (DumpCount * sizeof(ULONG));
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        for (i = 0; i < DumpCount; i++)
            errorLogEntry->DumpData[i] = DumpData[i];
        if (String) {
            errorLogEntry->NumberOfStrings = 1;
            errorLogEntry->StringOffset = (USHORT)(sizeof(IO_ERROR_LOG_PACKET) +
                                          DumpCount * sizeof(ULONG) - sizeof(ULONG));
            p= (PUCHAR)errorLogEntry + errorLogEntry->StringOffset;
            
            StringCbCopy((PWCHAR)p,
                         StringLength + sizeof(UNICODE_NULL),
                         String
                         );
        }
        IoWriteErrorLogEntry(errorLogEntry);
    }
}

NTSTATUS
PipOpenCurrentHwProfileDeviceInstanceKey(
    OUT PHANDLE Handle,
    IN  PUNICODE_STRING DeviceInstanceName,
    IN  ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine sets the csconfig flags for the specified device
    which is specified by the instance number under ServiceKeyName\Enum.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load. This is the RegistryPath parameter
        to the DriverEntry routine.

    Instance - Supplies the instance value under ServiceKeyName\Enum key

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

    status

--*/

{
    NTSTATUS status;
    UNICODE_STRING unicodeString;
    HANDLE profileEnumHandle;

    //
    // See if we can open the device instance key of current hardware profile
    //
    RtlInitUnicodeString (
        &unicodeString,
        L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\HARDWARE PROFILES\\CURRENT\\SYSTEM\\CURRENTCONTROLSET\\ENUM"
        );
    status = PipOpenRegistryKey(&profileEnumHandle,
                                NULL,
                                &unicodeString,
                                KEY_READ,
                                FALSE
                                );
    if (NT_SUCCESS(status)) {
        status = PipOpenRegistryKey(Handle,
                                    profileEnumHandle,
                                    DeviceInstanceName,
                                    DesiredAccess,
                                    FALSE
                                    );
        ZwClose(profileEnumHandle);
    }
    return status;
}

NTSTATUS
PipGetDeviceInstanceCsConfigFlags(
    IN PUNICODE_STRING DeviceInstance,
    OUT PULONG CsConfigFlags
    )

/*++

Routine Description:

    This routine retrieves the csconfig flags for the specified device
    which is specified by the instance number under ServiceKeyName\Enum.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load.

//    Instance - Supplies the instance value under ServiceKeyName\Enum key
//
    CsConfigFlags - Supplies a variable to receive the device's CsConfigFlags

Return Value:

    status

--*/

{
    NTSTATUS status;
    HANDLE handle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    *CsConfigFlags = 0;

    status = PipOpenCurrentHwProfileDeviceInstanceKey(&handle,
                                                      DeviceInstance,
                                                      KEY_READ
                                                      );
    if(NT_SUCCESS(status)) {
        status = PipGetRegistryValue(handle,
                                     L"CsConfigFlags",
                                     &keyValueInformation
                                    );
        if(NT_SUCCESS(status)) {
            if((keyValueInformation->Type == REG_DWORD) &&
               (keyValueInformation->DataLength >= sizeof(ULONG))) {
                *CsConfigFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            }
            ExFreePool(keyValueInformation);
        }
        ZwClose(handle);
    }
    return status;
}

ULONG
PipDetermineResourceListSize(
    IN PCM_RESOURCE_LIST ResourceList
    )

/*++

Routine Description:

    This routine determines size of the passed in ResourceList
    structure.

Arguments:

    Configuration1 - Supplies a pointer to the resource list.

Return Value:

    size of the resource list structure.

--*/

{
    ULONG totalSize, listSize, descriptorSize, i, j;
    PCM_FULL_RESOURCE_DESCRIPTOR fullResourceDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;

    if (!ResourceList) {
        totalSize = 0;
    } else {
        totalSize = FIELD_OFFSET(CM_RESOURCE_LIST, List);
        fullResourceDesc = &ResourceList->List[0];
        for (i = 0; i < ResourceList->Count; i++) {
            listSize = FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                    PartialResourceList) +
                       FIELD_OFFSET(CM_PARTIAL_RESOURCE_LIST,
                                    PartialDescriptors);
            partialDescriptor = &fullResourceDesc->PartialResourceList.PartialDescriptors[0];
            for (j = 0; j < fullResourceDesc->PartialResourceList.Count; j++) {
                descriptorSize = sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                if (partialDescriptor->Type == CmResourceTypeDeviceSpecific) {
                    descriptorSize += partialDescriptor->u.DeviceSpecificData.DataSize;
                }
                listSize += descriptorSize;
                partialDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
                                        ((PUCHAR)partialDescriptor + descriptorSize);
            }
            totalSize += listSize;
            fullResourceDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)
                                      ((PUCHAR)fullResourceDesc + listSize);
        }
    }
    return totalSize;
}
NTSTATUS
PipMapAddressAndCmdPort (
    IN PPI_BUS_EXTENSION BusExtension
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG dumpData[3];
    PHYSICAL_ADDRESS physicalAddress;
    //
    // Map port addr to memory addr if necessary.
    //

    if (PipAddressPort == NULL) {
        physicalAddress.LowPart = ADDRESS_PORT;
        physicalAddress.HighPart = 0;
        BusExtension->AddressPort =
        PipAddressPort = PipGetMappedAddress(
                             Isa,             // InterfaceType
                             0,               // BusNumber,
                             physicalAddress,
                             1,
                             CM_RESOURCE_PORT_IO,
                             &BusExtension->AddrPortMapped
                             );
        if (PipAddressPort == NULL) {
            dumpData[0] = ADDRESS_PORT;
            dumpData[1] = 1;
            dumpData[2] = CM_RESOURCE_PORT_IO;
            PipLogError(PNPISA_REGISTER_NOT_MAPPED,
                        PNPISA_ACQUIREPORTRESOURCE_1,
                        STATUS_INSUFFICIENT_RESOURCES,
                        dumpData,
                        3,
                        0,
                        NULL
                        );
            status = STATUS_UNSUCCESSFUL;
        }
    }
    if (PipCommandPort == NULL) {
        physicalAddress.LowPart = COMMAND_PORT;
        physicalAddress.HighPart = 0;
        BusExtension->CommandPort =
        PipCommandPort = PipGetMappedAddress(
                             Isa,             // InterfaceType
                             0,               // BusNumber,
                             physicalAddress,
                             1,
                             CM_RESOURCE_PORT_IO,
                             &BusExtension->CmdPortMapped
                             );
        if (PipCommandPort == NULL) {
            dumpData[0] = COMMAND_PORT;
            dumpData[1] = 1;
            dumpData[2] = CM_RESOURCE_PORT_IO;
            PipLogError(PNPISA_REGISTER_NOT_MAPPED,
                        PNPISA_ACQUIREPORTRESOURCE_2,
                        STATUS_INSUFFICIENT_RESOURCES,
                        dumpData,
                        3,
                        0,
                        NULL
                        );
            status = STATUS_UNSUCCESSFUL;
        }
    }


    return status;



}

VOID
PipReleaseDeviceResources (
    PDEVICE_INFORMATION DeviceInfo
    )
{
    UNICODE_STRING unicodeString;

    // This code is here rather than in the following conditional as
    // this best reflects how the code used to work before this code
    // was moved here from PDO stop/remove/surprise remove.
    if (DeviceInfo->LogConfHandle) {
        RtlInitUnicodeString(&unicodeString, L"AllocConfig");
        ZwDeleteValueKey (DeviceInfo->LogConfHandle, &unicodeString);
    }

    if (DeviceInfo->AllocatedResources)  {
       ExFreePool (DeviceInfo->AllocatedResources);
       DeviceInfo->AllocatedResources=NULL;

       if (DeviceInfo->LogConfHandle) {
           // As it stands now it we will close the logconf handle if
           // the device gets removed, surprise removed, or stopped.
           // When we get started, we'll try to re-create the
           // AllocConfig value but fail because of the lack of the
           // logconf handle.  This is not a change in behavior.
           //
           // The ZwDeleteKey() was definitely bogus though.

           ZwClose(DeviceInfo->LogConfHandle);
           DeviceInfo->LogConfHandle=NULL;
       }
    }

}

VOID
PipReportStateChange(
    PNPISA_STATE State
    )
{
    DebugPrint((DEBUG_STATE, "State transition: %d to %d\n",
               PipState, State));
    PipState = State;
}

ULONG
PipGetCardFlags(
    PCARD_INFORMATION CardInfo
    )

/*++

Description:

    Look in the registry for any flags for this CardId

Arguments:

    CardId    First 4 bytes of ISAPNP config space

Return Value:

    32 bit flags value from registry or 0 if not found.

--*/

{
    HANDLE         serviceHandle, paramHandle;
    NTSTATUS       status;
    ULONG          flags, returnedLength;
    UNICODE_STRING nameString;
    WCHAR          nameBuffer[9];
    WCHAR          eisaId[8];
    const PWCHAR   paramKey = L"Parameters";
    struct {
        KEY_VALUE_PARTIAL_INFORMATION   Header;

        //
        // The header contains enough space for one UCHAR, pad
        // it out by a ULONG, this will ensure the structure
        // is large enough for at lease the ULONG we need.
        //
        // N.B. Natural alignment will get it out far enough that
        // this ULONG is 4 bytes to many.
        //

        ULONG Pad;
    } returnedData;


    status = PipOpenRegistryKey(&serviceHandle,
                                NULL,
                                &PipRegistryPath,
                                KEY_READ,
                                FALSE);
    if (!NT_SUCCESS(status)) {
        return 0;
    }

    RtlInitUnicodeString(&nameString, paramKey);
    status = PipOpenRegistryKey(&paramHandle,
                                serviceHandle,
                                &nameString,
                                KEY_READ,
                                FALSE);
    if (!NT_SUCCESS(status)) {
        ZwClose(serviceHandle);
        return 0;
    }

    PipDecompressEisaId(
          ((PSERIAL_IDENTIFIER) (CardInfo->CardData))->VenderId,
          eisaId
          );
    RtlInitUnicodeString(&nameString, eisaId);
    
    //
    // Get the "value" of this value.
    //

    status = ZwQueryValueKey(
                 paramHandle,
                 &nameString,
                 KeyValuePartialInformation,
                 &returnedData,
                 sizeof(returnedData),
                 &returnedLength
                 );
    ZwClose(paramHandle);
    ZwClose(serviceHandle);

    if (NT_SUCCESS(status) && (returnedData.Header.Type == REG_DWORD) &&
        (returnedData.Header.DataLength == sizeof(ULONG))) {
        flags =  *(PULONG)(returnedData.Header.Data);
        DebugPrint((DEBUG_WARN, "Retrieving card flags for %ws: %x\n",
                    nameString.Buffer, flags));
    } else {
        flags = 0;
    }
    return flags;
}

NTSTATUS
PipBuildValueName(
    IN PDEVICE_INFORMATION DeviceInfo,
    IN PWSTR Suffix,
    OUT PWSTR *ValuePath
    )
/*++

Description:

    Builds a name describing the device via the device id and unique
    id.  Used to store per-device info in our parent's BiosConfig key

Arguments:

    DeviceInfo    Pointer to the PDO Extension for this device.

    Suffix        Suffix for value name

    IrqFlags      The edge or level setting of the boot config

Return Value:

    Status

--*/
{
    NTSTATUS status;
    PWSTR DeviceId = NULL, Instance = NULL;
    PWSTR Buffer, Current;
    ULONG length, deviceIdLength, instanceIdLength;

    status = PipQueryDeviceId(DeviceInfo, &DeviceId, &deviceIdLength, 0);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = PipQueryDeviceUniqueId(DeviceInfo, &Instance, &instanceIdLength);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    length = deviceIdLength + instanceIdLength + (wcslen(Suffix) + 1) * sizeof(WCHAR);

    Buffer = ExAllocatePool(PagedPool, length);
    if (Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    StringCbCopy(Buffer,
                 length,
                 DeviceId
                 );
    
    StringCbCat(Buffer,
                length,
                Instance
                );
    
    StringCbCat(Buffer,
                length,
                Suffix
                );

    Current = Buffer;
    while (*Current != UNICODE_NULL) {
        if (*Current == L'\\') {
            *Current = L'_';
        }
        Current++;
    }

 cleanup:
    if (Instance) {
        ExFreePool(Instance);
    }

    if (DeviceId) {
        ExFreePool(DeviceId);
    }

    if (NT_SUCCESS(status)) {
        *ValuePath = Buffer;
    } else {
        *ValuePath = NULL;
    }
    return status;
}

NTSTATUS
PipSaveBootResources(
    IN PDEVICE_INFORMATION DeviceInfo
    )
/*++

Description:

    This saves the per-boot configuration of a device in the registry

Arguments:

    DeviceInfo    Pointer to the PDO Extension for this device.

Return Value:

    Status

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING unicodeString;
    HANDLE deviceHandle, configHandle;
    PWSTR Buffer = NULL;
    ULONG Flags;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(DeviceInfo->ParentDeviceExtension->PhysicalBusDevice,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_WRITE,
                                     &deviceHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString, BIOS_CONFIG_KEY_NAME);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_KERNEL_HANDLE,
                               deviceHandle,
                               NULL
                               );

    status = ZwCreateKey(&configHandle,
                         KEY_WRITE,
                         &attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE,
                         NULL
                         );

    ZwClose(deviceHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = PipBuildValueName(DeviceInfo, BOOTRESOURCES_VALUE_NAME,
                                  &Buffer);
    if (!NT_SUCCESS(status)) {
        Buffer = NULL;
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString, Buffer);

    status = ZwSetValueKey(configHandle,
                           &unicodeString,
                           0,
                           REG_BINARY,
                           DeviceInfo->BootResources,
                           DeviceInfo->BootResourcesLength
                           );

    ZwClose(configHandle);

cleanup:
    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }
    return status;
}

NTSTATUS
PipSaveBootIrqFlags(
    IN PDEVICE_INFORMATION DeviceInfo,
    IN USHORT IrqFlags
    )
/*++

Description:

    This saves the per-boot irq configuration of a device in the registry

Arguments:

    DeviceInfo    Pointer to the PDO Extension for this device.

    IrqFlags      The edge or level setting of the boot config

Return Value:

    Status

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING unicodeString;
    HANDLE deviceHandle, configHandle;
    PWSTR Buffer = NULL;
    ULONG Flags;

    PAGED_CODE();

    Flags = (ULONG) IrqFlags;

    status = IoOpenDeviceRegistryKey(DeviceInfo->ParentDeviceExtension->PhysicalBusDevice,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_WRITE,
                                     &deviceHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString, BIOS_CONFIG_KEY_NAME);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_KERNEL_HANDLE,
                               deviceHandle,
                               NULL
                               );

    status = ZwCreateKey(&configHandle,
                         KEY_WRITE,
                         &attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE,
                         NULL
                         );

    ZwClose(deviceHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = PipBuildValueName(DeviceInfo, IRQFLAGS_VALUE_NAME, &Buffer);
    if (!NT_SUCCESS(status)) {
        Buffer = NULL;
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString, Buffer);

    status = ZwSetValueKey(configHandle,
                           &unicodeString,
                           0,
                           REG_DWORD,
                           &Flags,
                           sizeof(ULONG)
                           );

    ZwClose(configHandle);

cleanup:
    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }
    return status;
}

NTSTATUS
PipGetSavedBootResources(
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PCM_RESOURCE_LIST *BootResources
    )
/*

Description:

    This retrieves the saved boot resources

Arguments:

    DeviceInfo    Pointer to the PDO Extension for this device.

Return Value:

    Status

--*/
{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    OBJECT_ATTRIBUTES attributes;
    HANDLE deviceHandle, configHandle;
    PWSTR Buffer = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION info = NULL;
    ULONG resultLength;

    PAGED_CODE();

    *BootResources = NULL;
    status = IoOpenDeviceRegistryKey(DeviceInfo->ParentDeviceExtension->PhysicalBusDevice,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ | KEY_WRITE,
                                     &deviceHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString, BIOS_CONFIG_KEY_NAME);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_KERNEL_HANDLE,
                               deviceHandle,
                               NULL
                               );

    status = ZwOpenKey(&configHandle,
                         KEY_READ,
                         &attributes
                         );

    ZwClose(deviceHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = PipBuildValueName(DeviceInfo, BOOTRESOURCES_VALUE_NAME, &Buffer);
    if (!NT_SUCCESS(status)) {
        ZwClose(configHandle);
        Buffer = NULL;
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString,Buffer);

    status = ZwQueryValueKey(configHandle,
                             &unicodeString,
                             KeyValuePartialInformation,
                             NULL,
                             0,
                             &resultLength
                             );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        ZwClose(configHandle);
        goto cleanup;
    }

    info = ExAllocatePool(PagedPool, resultLength);
    if (info == NULL) {
        ZwClose(configHandle);
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    status = ZwQueryValueKey(configHandle,
                             &unicodeString,
                             KeyValuePartialInformation,
                             info,
                             resultLength,
                             &resultLength
                             );
    ZwClose(configHandle);
    if (!NT_SUCCESS(status)) {
        DebugPrint((DEBUG_PNP, "Failed to get boot resources from registry for %ws\n", Buffer));
        goto cleanup;
    }

    status = PipValidateResourceList((PCM_RESOURCE_LIST)info->Data, info->DataLength);
    if (!NT_SUCCESS(status)) {
        *BootResources = NULL;
        goto cleanup;
    }

    *BootResources = ExAllocatePool(PagedPool, info->DataLength);
    if (*BootResources) {
        RtlCopyMemory(*BootResources, info->Data, info->DataLength);
        DebugPrint((DEBUG_PNP, "Got boot resources from registry for %ws\n", Buffer));
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

 cleanup:

    if (info != NULL) {
        ExFreePool(info);
    }

    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }

    return status;
}

NTSTATUS
PipGetBootIrqFlags(
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PUSHORT IrqFlags
    )
/*

Description:

    This retrieves the per-boot irq configuration of a device from the registry

Arguments:

    DeviceInfo    Pointer to the PDO Extension for this device.

    IrqFlags - flags we originally derived from the device's boot
               config on this boot

Return Value:

    Status

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING unicodeString;
    HANDLE deviceHandle, configHandle;
    PWSTR Buffer = NULL;
    CHAR returnBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG) - 1];
    PKEY_VALUE_PARTIAL_INFORMATION info;
    ULONG resultLength;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(DeviceInfo->ParentDeviceExtension->PhysicalBusDevice,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ,
                                     &deviceHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString, BIOS_CONFIG_KEY_NAME);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_KERNEL_HANDLE,
                               deviceHandle,
                               NULL
                               );

    status = ZwOpenKey(&configHandle,
                         KEY_READ,
                         &attributes
                         );

    ZwClose(deviceHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = PipBuildValueName(DeviceInfo, IRQFLAGS_VALUE_NAME, &Buffer);
    if (!NT_SUCCESS(status)) {
        ZwClose(configHandle);
        Buffer = NULL;
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString,Buffer);
    
    status = ZwQueryValueKey(configHandle,
                             &unicodeString,
                             KeyValuePartialInformation,
                             returnBuffer,
                             sizeof(returnBuffer),
                             &resultLength
                             );

    ZwClose(configHandle);

    if (NT_SUCCESS(status)) {
        ULONG Temp;

        info = (PKEY_VALUE_PARTIAL_INFORMATION) returnBuffer;

        ASSERT(info->DataLength == sizeof(ULONG));

        Temp = *((PULONG) info->Data);
        ASSERT(!(Temp & 0xFFFF0000));
        *IrqFlags = (USHORT) Temp;

        DebugPrint((DEBUG_IRQ, "Got Irq Flags of %d for %ws\n",
                    (ULONG) *IrqFlags,
                    unicodeString.Buffer));
    } else {
        DebugPrint((DEBUG_IRQ, "Failed to get irq flags for %ws\n",
                    unicodeString.Buffer));
    }

 cleanup:

    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }

    return status;
}

VOID
PipResetGlobals (
                   VOID
                   )
{
    PipReadDataPort = PipCommandPort = PipAddressPort = NULL;
    PipRDPNode = NULL;
}
#endif



NTSTATUS
PipOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    )

/*++

Routine Description:

    Opens or creates a VOLATILE registry key using the name passed in based
    at the BaseHandle node.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Handle to the base path from which the key must be opened.

    KeyName - Name of the Key that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE();

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //

    if (Create) {
        return ZwCreateKey( Handle,
                            DesiredAccess,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            &disposition );
    } else {
        return ZwOpenKey( Handle,
                          DesiredAccess,
                          &objectAttributes );
    }
}

NTSTATUS
PipGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    *Information = NULL;
    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePool( NonPagedPool, keyValueLength );
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}

BOOLEAN
PiNeedDeferISABridge(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    BOOLEAN defer=FALSE;
    NTSTATUS status;
    HANDLE  hKey;
    ULONG value;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;



    status = IoOpenDeviceRegistryKey (DeviceObject,PLUGPLAY_REGKEY_DEVICE,KEY_READ,&hKey);

    if (NT_SUCCESS (status)) {
        status = PipGetRegistryValue (hKey,&BRIDGE_CHECK_KEY,&keyValueInformation);

        if (NT_SUCCESS (status)) {
            if((keyValueInformation->Type == REG_DWORD) &&
               (keyValueInformation->DataLength >= sizeof(ULONG))) {
                value = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                //
                // Assume that if the value !0 then the bridge is 'broken'
                //
                defer = (value == 0)?FALSE:TRUE;
            }
        }
        ZwClose(hKey);

    }

    return defer;
}

NTSTATUS
PipValidateResourceList(
    IN PCM_RESOURCE_LIST ResourceList,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine verifies that a resource list structure is properly
    formated and the buffer containing it is large enough.
    
Arguments:

    ResourceList - The CM_RESOURCE_LIST to verify.
    
    Length - The length of the ResourceList buffer.
    
Return Value:

    STATUS_SUCCESS if the resource list is valid
    STATUS_UNSUCCESSFUL otherwise.
    
--*/ 
{
    ULONG requiredLength;

    if (Length < sizeof(CM_RESOURCE_LIST)) {
        return STATUS_UNSUCCESSFUL;
    }

    if (ResourceList->Count != 1) {
        return STATUS_UNSUCCESSFUL;
    }

    requiredLength = sizeof(CM_RESOURCE_LIST);

    if (ResourceList->List[0].PartialResourceList.Count > 1) {
            
        requiredLength += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * (ResourceList->List[0].PartialResourceList.Count - 1);
    }

    if (requiredLength > Length) {

        return STATUS_UNSUCCESSFUL;        
    }

    return STATUS_SUCCESS;
}

#if DBG

VOID
PipDebugPrintContinue (
    ULONG       Level,
    PCCHAR      DebugMessage,
    ...
    )
/*++

Routine Description:

    This routine displays debugging message or causes a break.

Arguments:

    Level - supplies debugging levelcode.  DEBUG_MESSAGE - displays message only.
        DEBUG_BREAK - displays message and break.

    DebugMessage - supplies a pointer to the debugging message.

Return Value:

    None.

--*/

{
    va_list     ap;

    va_start(ap, DebugMessage);

    vDbgPrintEx(DPFLTR_ISAPNP_ID,
                Level,
                DebugMessage,
                ap
                );

    if (Level & DEBUG_BREAK) {
        DbgBreakPoint();
    }

    va_end(ap);
}


VOID
PipDebugPrint (
    ULONG       Level,
    PCCHAR      DebugMessage,
    ...
    )
/*++

Routine Description:

    This routine displays debugging message or causes a break.

Arguments:

    Level - supplies debugging levelcode.  DEBUG_MESSAGE - displays message only.
        DEBUG_BREAK - displays message and break.

    DebugMessage - supplies a pointer to the debugging message.

Return Value:

    None.

--*/

{
    va_list     ap;

    va_start(ap, DebugMessage);

    vDbgPrintExWithPrefix("ISAPNP: ",
                          DPFLTR_ISAPNP_ID,
                          Level,
                          DebugMessage,
                          ap
                          );

    if (Level & DEBUG_BREAK) {
        DbgBreakPoint();
    }

    va_end(ap);
}

#endif


VOID
PipDumpIoResourceDescriptor (
    IN PUCHAR Indent,
    IN PIO_RESOURCE_DESCRIPTOR Desc
    )
/*++

Routine Description:

    This routine processes a IO_RESOURCE_DESCRIPTOR and displays it.

Arguments:

    Indent - # char of indentation.

    Desc - supplies a pointer to the IO_RESOURCE_DESCRIPTOR to be displayed.

Return Value:

    None.

--*/
{
    UCHAR c = ' ';

    if (Desc->Option == IO_RESOURCE_ALTERNATIVE) {
        c = 'A';
    } else if (Desc->Option == IO_RESOURCE_PREFERRED) {
        c = 'P';
    }
    switch (Desc->Type) {
        case CmResourceTypePort:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sIO  %c Min: %x:%08x, Max: %x:%08x, Algn: %x, Len %x\n",
                Indent, c,
                Desc->u.Port.MinimumAddress.HighPart, Desc->u.Port.MinimumAddress.LowPart,
                Desc->u.Port.MaximumAddress.HighPart, Desc->u.Port.MaximumAddress.LowPart,
                Desc->u.Port.Alignment,
                Desc->u.Port.Length
                ));
            break;

        case CmResourceTypeMemory:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sMEM %c Min: %x:%08x, Max: %x:%08x, Algn: %x, Len %x\n",
                Indent, c,
                Desc->u.Memory.MinimumAddress.HighPart, Desc->u.Memory.MinimumAddress.LowPart,
                Desc->u.Memory.MaximumAddress.HighPart, Desc->u.Memory.MaximumAddress.LowPart,
                Desc->u.Memory.Alignment,
                Desc->u.Memory.Length
                ));
            break;

        case CmResourceTypeInterrupt:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sINT %c Min: %x, Max: %x\n",
                Indent, c,
                Desc->u.Interrupt.MinimumVector,
                Desc->u.Interrupt.MaximumVector
                ));
            break;

        case CmResourceTypeDma:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sDMA %c Min: %x, Max: %x\n",
                Indent, c,
                Desc->u.Dma.MinimumChannel,
                Desc->u.Dma.MaximumChannel
                ));
            break;
    }
}

VOID
PipDumpIoResourceList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList
    )
/*++

Routine Description:

    This routine displays Io resource requirements list.

Arguments:

    IoList - supplies a pointer to the Io resource requirements list to be displayed.

Return Value:

    None.

--*/
{


    PIO_RESOURCE_LIST resList;
    PIO_RESOURCE_DESCRIPTOR resDesc;
    ULONG listCount, count, i, j;

    if (IoList == NULL) {
        return;
    }
    DebugPrint((DEBUG_RESOURCE,
                  "Pnp Bios IO Resource Requirements List for Slot %x -\n",
                  IoList->SlotNumber
                  ));
    DebugPrint((DEBUG_RESOURCE,
                  "  List Count = %x, Bus Number = %x\n",
                  IoList->AlternativeLists,
                  IoList->BusNumber
                  ));
    listCount = IoList->AlternativeLists;
    resList = &IoList->List[0];
    for (i = 0; i < listCount; i++) {
        DebugPrint((DEBUG_RESOURCE,
                      "  Version = %x, Revision = %x, Desc count = %x\n",
                      resList->Version, resList->Revision, resList->Count
                      ));
        resDesc = &resList->Descriptors[0];
        count = resList->Count;
        for (j = 0; j < count; j++) {
            PipDumpIoResourceDescriptor("    ", resDesc);
            resDesc++;
        }
        resList = (PIO_RESOURCE_LIST) resDesc;
    }
}

VOID
PipDumpCmResourceDescriptor (
    IN PUCHAR Indent,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Desc
    )
/*++

Routine Description:

    This routine processes a IO_RESOURCE_DESCRIPTOR and displays it.

Arguments:

    Indent - # char of indentation.

    Desc - supplies a pointer to the IO_RESOURCE_DESCRIPTOR to be displayed.

Return Value:

    None.

--*/
{
    switch (Desc->Type) {
        case CmResourceTypePort:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sIO  Start: %x:%08x, Length:  %x\n",
                Indent,
                Desc->u.Port.Start.HighPart, Desc->u.Port.Start.LowPart,
                Desc->u.Port.Length
                ));
            break;

        case CmResourceTypeMemory:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sMEM Start: %x:%08x, Length:  %x\n",
                Indent,
                Desc->u.Memory.Start.HighPart, Desc->u.Memory.Start.LowPart,
                Desc->u.Memory.Length
                ));
            break;

        case CmResourceTypeInterrupt:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sINT Level: %x, Vector: %x, Affinity: %x\n",
                Indent,
                Desc->u.Interrupt.Level,
                Desc->u.Interrupt.Vector,
                Desc->u.Interrupt.Affinity
                ));
            break;

        case CmResourceTypeDma:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sDMA Channel: %x, Port: %x\n",
                Indent,
                Desc->u.Dma.Channel,
                Desc->u.Dma.Port
                ));
            break;
    }
}

VOID
PipDumpCmResourceList (
    IN PCM_RESOURCE_LIST CmList
    )
/*++

Routine Description:

    This routine displays CM resource list.

Arguments:

    CmList - supplies a pointer to CM resource list

Return Value:

    None.

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR fullDesc;
    PCM_PARTIAL_RESOURCE_LIST partialDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    ULONG count, i;

    if (CmList) {
        fullDesc = &CmList->List[0];
        DebugPrint((DEBUG_RESOURCE,
                      "Pnp Bios Cm Resource List -\n"
                      ));
        DebugPrint((DEBUG_RESOURCE,
                      "  List Count = %x, Bus Number = %x\n",
                      CmList->Count, fullDesc->BusNumber
                      ));
        partialDesc = &fullDesc->PartialResourceList;
        DebugPrint((DEBUG_RESOURCE,
                      "  Version = %x, Revision = %x, Desc count = %x\n",
                      partialDesc->Version, partialDesc->Revision, partialDesc->Count
                      ));
        count = partialDesc->Count;
        desc = &partialDesc->PartialDescriptors[0];
        for (i = 0; i < count; i++) {
            PipDumpCmResourceDescriptor("    ", desc);
            desc++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\pdopnp.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    pdopnp.c

Abstract:

    This file contains the PNP IRP dispatch code for PDOs

Environment:

    Kernel Mode Driver.

Revision History:

--*/

#include "busp.h"
#include "pnpisa.h"
#include <wdmguid.h>
#include "halpnpp.h"

#if ISOLATE_CARDS

//
// Function Prototypes
//

BOOLEAN PipFailStartPdo = FALSE;
BOOLEAN PipFailStartRdp = FALSE;

NTSTATUS
PiStartPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryRemoveStopPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp    );

NTSTATUS
PiCancelRemoveStopPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp    );

NTSTATUS
PiStopPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryDeviceRelationsPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryCapabilitiesPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryDeviceTextPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiFilterResourceRequirementsPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryIdPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryResourcesPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryResourceRequirementsPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiRemovePdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryBusInformationPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryInterfacePdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDeviceUsageNotificationPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiSurpriseRemovePdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiIrpNotSupported(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PipBuildRDPResources(
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *IoResources,
    IN ULONG Flags
    );

NTSTATUS
PiQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PiDispatchPnpPdo)
#pragma alloc_text(PAGE,PiStartPdo)
#pragma alloc_text(PAGE,PiQueryRemoveStopPdo)
#pragma alloc_text(PAGE,PiRemovePdo)
#pragma alloc_text(PAGE,PiCancelRemoveStopPdo)
#pragma alloc_text(PAGE,PiStopPdo)
#pragma alloc_text(PAGE,PiQueryDeviceRelationsPdo)
#pragma alloc_text(PAGE,PiQueryInterfacePdo)
#pragma alloc_text(PAGE,PiQueryCapabilitiesPdo)
#pragma alloc_text(PAGE,PiQueryResourcesPdo)
#pragma alloc_text(PAGE,PiQueryResourceRequirementsPdo)
#pragma alloc_text(PAGE,PiQueryDeviceTextPdo)
#pragma alloc_text(PAGE,PiFilterResourceRequirementsPdo)
#pragma alloc_text(PAGE,PiSurpriseRemovePdo)
#pragma alloc_text(PAGE,PiIrpNotSupported)
#pragma alloc_text(PAGE,PiQueryIdPdo)
#pragma alloc_text(PAGE,PiQueryBusInformationPdo)
#pragma alloc_text(PAGE,PiDeviceUsageNotificationPdo)
#pragma alloc_text(PAGE,PipBuildRDPResources)
#pragma alloc_text(PAGE,PiQueryDeviceState)
#endif


//
// PNP IRP Dispatch table for PDOs - This should be updated if new IRPs are added
//

PPI_DISPATCH PiPnpDispatchTablePdo[] = {
    PiStartPdo,                             // IRP_MN_START_DEVICE
    PiQueryRemoveStopPdo,                   // IRP_MN_QUERY_REMOVE_DEVICE
    PiRemovePdo,                            // IRP_MN_REMOVE_DEVICE
    PiCancelRemoveStopPdo,                  // IRP_MN_CANCEL_REMOVE_DEVICE
    PiStopPdo,                              // IRP_MN_STOP_DEVICE
    PiQueryRemoveStopPdo,                   // IRP_MN_QUERY_STOP_DEVICE
    PiCancelRemoveStopPdo,                  // IRP_MN_CANCEL_STOP_DEVICE
    PiQueryDeviceRelationsPdo,              // IRP_MN_QUERY_DEVICE_RELATIONS
    PiQueryInterfacePdo,                    // IRP_MN_QUERY_INTERFACE
    PiQueryCapabilitiesPdo,                 // IRP_MN_QUERY_CAPABILITIES
    PiQueryResourcesPdo,                    // IRP_MN_QUERY_RESOURCES
    PiQueryResourceRequirementsPdo,         // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    PiQueryDeviceTextPdo,                   // IRP_MN_QUERY_DEVICE_TEXT
    PiFilterResourceRequirementsPdo,        // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    PiIrpNotSupported,                      // Unused
    PiIrpNotSupported,                      // IRP_MN_READ_CONFIG
    PiIrpNotSupported,                      // IRP_MN_WRITE_CONFIG
    PiIrpNotSupported,                      // IRP_MN_EJECT
    PiIrpNotSupported,                      // IRP_MN_SET_LOCK
    PiQueryIdPdo,                           // IRP_MN_QUERY_ID
    PiQueryDeviceState,                     // IRP_MN_QUERY_PNP_DEVICE_STATE
    PiQueryBusInformationPdo,               // IRP_MN_QUERY_BUS_INFORMATION
    PiDeviceUsageNotificationPdo,           // IRP_MN_DEVICE_USAGE_NOTIFICATION
    PiSurpriseRemovePdo,                    // IRP_MN_SURPRISE_REMOVAL
    PiIrpNotSupported                       // IRP_MN_QUERY_LEGACY_BUS_INFORMATION
};


NTSTATUS
PiDispatchPnpPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_PNP IRPs for PDOs.

Arguments:

    DeviceObject - Pointer to the PDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{

    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PVOID information = NULL;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (irpSp->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {

        status = Irp->IoStatus.Status;

    } else {

        status = PiPnpDispatchTablePdo[irpSp->MinorFunction](DeviceObject, Irp);

        if ( status != STATUS_NOT_SUPPORTED ) {

            //
            // We understood this IRP and handled it so we need to set status before completing
            //

            Irp->IoStatus.Status = status;

        } else {

            status = Irp->IoStatus.Status;
        }

    }

    information = (PVOID)Irp->IoStatus.Information;

    ASSERT(status == Irp->IoStatus.Status);

    PipCompleteRequest(Irp, status, information);
    return status;


} //PipDispatchPnpPdo


NTSTATUS
PiStartPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{

    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PCM_RESOURCE_LIST cmResources;
    PDEVICE_INFORMATION deviceInfo;
    UNICODE_STRING unicodeString;
    ULONG length;
    POWER_STATE newPowerState;

    irpSp = IoGetCurrentIrpStackLocation(Irp);


    cmResources = irpSp->Parameters.StartDevice.AllocatedResources;

    if (PipDebugMask & DEBUG_PNP) {
        PipDumpCmResourceList(cmResources);
    } else if (!cmResources) {
        DbgPrint("StartDevice irp with empty CmResourceList\n");
    }

    DebugPrint((DEBUG_PNP,
       "*** StartDevice irp received PDO: %x\n",DeviceObject));
    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, TRUE)) {

        if (deviceInfo->Flags & DF_READ_DATA_PORT) {
            ULONG curSize,newSize;
            //
            if (PipFailStartRdp) {
                PipDereferenceDeviceInformation(deviceInfo, TRUE);
                return STATUS_UNSUCCESSFUL;
            }
            // Read data port is special
            //
            newSize=PipDetermineResourceListSize(cmResources);
            curSize=PipDetermineResourceListSize(deviceInfo->AllocatedResources);

            //
            // Check if we've been removed, or moved (the +3 is the bit mask for the RDP , we claim 4-7, need xxxi7)
            //
            if ( (deviceInfo->Flags & DF_REMOVED) ||
                 !(deviceInfo->Flags & DF_STOPPED) ||
                 (curSize != newSize) ||
                 (newSize != RtlCompareMemory (deviceInfo->AllocatedResources,cmResources,newSize))) {


                //
                // This will release the unused resources
                //
                status = PipStartReadDataPort (deviceInfo,deviceInfo->ParentDeviceExtension,DeviceObject,cmResources);
                if (NT_SUCCESS(status) || status == STATUS_NO_SUCH_DEVICE) {
                    status = STATUS_SUCCESS;
                }

                //
                // Invalidate the device relations
                //

                if (NT_SUCCESS (status)) {
                    IoInvalidateDeviceRelations (
                        deviceInfo->ParentDeviceExtension->PhysicalBusDevice,BusRelations);
                }
                deviceInfo->Flags &= ~(DF_STOPPED|DF_REMOVED|DF_SURPRISE_REMOVED);
            } else {
                deviceInfo->Flags &= ~DF_STOPPED;
                IoInvalidateDeviceRelations (
                    deviceInfo->ParentDeviceExtension->PhysicalBusDevice,BusRelations);
                status=STATUS_SUCCESS;
            }
            deviceInfo->Flags |= DF_ACTIVATED;
            PipDereferenceDeviceInformation(deviceInfo, TRUE);

            DebugPrint((DEBUG_PNP, "StartDevice(RDP) returning: %x\n",status));

            return status;
        }


        //
        if (PipFailStartPdo) {
            PipDereferenceDeviceInformation(deviceInfo, TRUE);
            return STATUS_UNSUCCESSFUL;
        }

        // Do this first, so that we allow for no-resource devices in the ref count.
        // (when we activate the RDP it won't have resources, yet)
        //

        // ASSERT (!(PipRDPNode->Flags & (DF_STOPPED|DF_REMOVED)));
        if (PipRDPNode->Flags & (DF_STOPPED|DF_REMOVED)) {
            //
            // If the RDP isn't running, fail the start.
            //
            PipDereferenceDeviceInformation(deviceInfo, TRUE);

            return STATUS_UNSUCCESSFUL;
        }

        if (cmResources) {
            deviceInfo->AllocatedResources = ExAllocatePool(
                    NonPagedPool,
                    PipDetermineResourceListSize(cmResources));
            if (deviceInfo->AllocatedResources) {
                RtlMoveMemory(deviceInfo->AllocatedResources,
                             cmResources,
                             length = PipDetermineResourceListSize(cmResources));
                deviceInfo->Flags &= ~(DF_REMOVED|DF_STOPPED);
                status = PipSetDeviceResources (deviceInfo, cmResources);
                if (NT_SUCCESS(status)) {

                    PipActivateDevice();

                    DebugPrint((DEBUG_STATE,
                                "Starting CSN %d/LDN %d\n",
                                deviceInfo->CardInformation->CardSelectNumber,
                                deviceInfo->LogicalDeviceNumber));

                    deviceInfo->Flags |= DF_ACTIVATED;
                    newPowerState.DeviceState =
                        deviceInfo->DevicePowerState = PowerDeviceD0;
                    PoSetPowerState(DeviceObject,
                                    DevicePowerState,
                                    newPowerState);
                    deviceInfo->DevicePowerState = PowerDeviceD0;

                    if (deviceInfo->LogConfHandle) {
                        RtlInitUnicodeString(&unicodeString, L"AllocConfig");
                        ZwSetValueKey(deviceInfo->LogConfHandle,
                                      &unicodeString,
                                      0,
                                      REG_RESOURCE_LIST,
                                      cmResources,
                                      length
                                      );
                    }
                }

            } else {
                status = STATUS_NO_MEMORY;
            }
        } else if (deviceInfo->ResourceRequirements) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            status = STATUS_SUCCESS;
        }
        PipDereferenceDeviceInformation(deviceInfo, TRUE);
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "StartDevice returning: %x\n",status));
    return status;

} // PiStartPdo


NTSTATUS
PiQueryRemoveStopPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    DebugPrint((DEBUG_PNP,
       "*** Query%s irp received PDO: %x\n",
                (irpSp->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) ? "Stop" : "Remove",
                DeviceObject));
    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {

        if (deviceInfo->Paging || deviceInfo->CrashDump) {
            status = STATUS_DEVICE_BUSY;
        } else if ( deviceInfo->Flags & DF_READ_DATA_PORT ) {
            if (irpSp->MinorFunction != IRP_MN_QUERY_STOP_DEVICE) {
                status = STATUS_SUCCESS;
            } else if (deviceInfo->Flags & DF_PROCESSING_RDP) {
                //
                // If we're in the middle of the two part RDP start process,
                // flag this as a device that needs to be requeried for
                // resource requirements.
                //
                status = STATUS_RESOURCE_REQUIREMENTS_CHANGED;
            } else {

                PSINGLE_LIST_ENTRY deviceLink;
                PDEVICE_INFORMATION childDeviceInfo;
                PPI_BUS_EXTENSION busExtension = deviceInfo->ParentDeviceExtension;
                //
                // If trying to stop the RDP, then if any children fail it.
                //
                PipLockDeviceDatabase();

                status = STATUS_SUCCESS;
                deviceLink = busExtension->DeviceList.Next;
                while (deviceLink) {
                    childDeviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);

                    if (!(childDeviceInfo->Flags & DF_READ_DATA_PORT) &&
                        ((childDeviceInfo->Flags & DF_ENUMERATED) ||
                         !(childDeviceInfo->Flags & DF_REMOVED)))  {

                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }
                    deviceLink = childDeviceInfo->DeviceList.Next;
                }

                PipUnlockDeviceDatabase();
            }

        } else {

            if ((irpSp->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) &&
                !(deviceInfo->Flags & DF_ENUMERATED)) {

                status = STATUS_UNSUCCESSFUL;
            } else {

                ASSERT(!(PipRDPNode->Flags & (DF_STOPPED|DF_REMOVED)));
                if ((irpSp->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE) &&
                    (deviceInfo->CardInformation->CardFlags & CF_ISOLATION_BROKEN)) {
                    DebugPrint((DEBUG_ERROR, "Failed query remove due to broken isolatee\n"));
                    status = STATUS_UNSUCCESSFUL;
                } else {
                    deviceInfo->Flags |= DF_QUERY_STOPPED;
                    status = STATUS_SUCCESS;
                }
            }
        }

        PipDereferenceDeviceInformation(deviceInfo, FALSE);
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "Query%s Device returning: %x\n",
                (irpSp->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) ? "Stop" : "Remove",
                status));

    return status;

} // PiQueryRemoveStopPdo


NTSTATUS
PiCancelRemoveStopPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    DebugPrint((DEBUG_PNP,
       "*** Cancel%s irp received PDO: %x\n",
                (irpSp->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE) ? "Stop" : "Remove",
                DeviceObject));
    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {

        deviceInfo->Flags &= ~DF_QUERY_STOPPED;

        PipDereferenceDeviceInformation(deviceInfo, FALSE);
        status = STATUS_SUCCESS;

    } else {

        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "Cancel%s Device returning: %x\n",
                (irpSp->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE) ? "Stop" : "Remove",
                status));

    return status;

} // PiCancelRemoteStopPdo


NTSTATUS
PiStopPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    POWER_STATE newPowerState;

    DebugPrint((DEBUG_PNP, "PiStopPdo %x\n",DeviceObject));

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, TRUE)) {

        //
        // Deselect the cards, but not the RDP node.
        //
        if (DeviceObject != PipRDPNode->PhysicalDeviceObject) {

            PipDeactivateDevice();
            DebugPrint((DEBUG_STATE,
                        "Stopping CSN %d/LDN %d\n",
                        deviceInfo->CardInformation->CardSelectNumber,
                        deviceInfo->LogicalDeviceNumber));

            PipReleaseDeviceResources (deviceInfo);
        }

        if ((deviceInfo->Flags & DF_ACTIVATED)) {
            deviceInfo->Flags &= ~DF_ACTIVATED;
            newPowerState.DeviceState = deviceInfo->DevicePowerState = PowerDeviceD3;
            PoSetPowerState(DeviceObject, DevicePowerState, newPowerState);
        }
        deviceInfo->Flags &= ~DF_QUERY_STOPPED;
        deviceInfo->Flags |= DF_STOPPED;

        PipDereferenceDeviceInformation(deviceInfo, TRUE);
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "StopDevice returning: %x\n",status));
    return status;

} // PiStopPdo


NTSTATUS
PiQueryDeviceRelationsPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // The QueryDeviceRelation Irp is for devices under enumerated PnpIsa device.
    //


    switch (irpSp->Parameters.QueryDeviceRelations.Type) {
        case  TargetDeviceRelation: {
            PDEVICE_RELATIONS deviceRelations;

            deviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
            if (deviceRelations == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                deviceRelations->Count = 1;
                deviceRelations->Objects[0] = DeviceObject;
                ObReferenceObject(DeviceObject);
                Irp->IoStatus.Information = (ULONG_PTR)deviceRelations;
                status = STATUS_SUCCESS;
            }
        }
        break;

        case RemovalRelations: {

            PDEVICE_RELATIONS deviceRelations;

            if (PipRDPNode && (DeviceObject == PipRDPNode->PhysicalDeviceObject)) {

                deviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
                if (deviceRelations == NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    //
                    //Don't include ourselves in the list of Removal Relations, hence the -1
                    //

                    PipLockDeviceDatabase();
                    status = PipQueryDeviceRelations(
                        PipRDPNode->ParentDeviceExtension,
                        (PDEVICE_RELATIONS *)&Irp->IoStatus.Information,
                        TRUE
                        );

                    PipUnlockDeviceDatabase();
               }

            } else {
                status = STATUS_NOT_SUPPORTED;

            }
        }
        break;

        default : {

            status = STATUS_NOT_SUPPORTED;

            break;
        }
    }


    return status;

} // PiQueryDeviceRelationsPdo


NTSTATUS
PiQueryCapabilitiesPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_CAPABILITIES deviceCapabilities;
    ULONG i;
    PDEVICE_POWER_STATE state;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    deviceCapabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;
    deviceCapabilities->SystemWake = PowerSystemUnspecified;
    deviceCapabilities->DeviceWake = PowerDeviceUnspecified;
    deviceCapabilities->LockSupported = FALSE;
    deviceCapabilities->EjectSupported = FALSE;
    deviceCapabilities->Removable = FALSE;
    deviceCapabilities->DockDevice = FALSE;
    deviceCapabilities->UniqueID = TRUE;
    state = deviceCapabilities->DeviceState;
    //
    // Init the entire DeviceState array to D3 then replace the entry
    // for system state S0.
    //
    for (i = 0;
         i <  sizeof(deviceCapabilities->DeviceState);
         i += sizeof(deviceCapabilities->DeviceState[0])) {

        //
        // Only supported state, currently, is off.
        //

        *state++ = PowerDeviceD3;
    }
    deviceCapabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;

    //deviceCapabilities->SilentInstall = TRUE;
    //deviceCapabilities->RawDeviceOK = FALSE;
    if (PipRDPNode && (PipRDPNode->PhysicalDeviceObject == DeviceObject)) {
        deviceCapabilities->SilentInstall = TRUE;
        deviceCapabilities->RawDeviceOK = TRUE;
    }

    return STATUS_SUCCESS;

} // PiQueryCapabilitiesPdo

NTSTATUS
PiQueryDeviceTextPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_INFORMATION deviceInfo;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {
        PWSTR functionId;

        ULONG functionIdLength;

        if (irpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {

            //
            // Once we know we're going to touch the IRP
            //
            status = STATUS_SUCCESS;

            PipGetFunctionIdentifier((PUCHAR)deviceInfo->DeviceData,
                                     &functionId,
                                     &functionIdLength);

            if (!functionId) {
                if (deviceInfo->CardInformation) {
                    PipGetCardIdentifier((PUCHAR)deviceInfo->CardInformation->CardData + NUMBER_CARD_ID_BYTES,
                                         &functionId,
                                         &functionIdLength);
                }else {
                    functionId=NULL;
                }
            }
            Irp->IoStatus.Information = (ULONG_PTR)functionId;
        } else {

            status = STATUS_NOT_SUPPORTED;
        }
        PipDereferenceDeviceInformation(deviceInfo, FALSE);
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    return status;

} // PiQueryDeviceTextPdo

NTSTATUS
PiFilterResourceRequirementsPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine ensures that the RDP doesn't get its requirements filtered.

    Design Note:
    This code may now be extraneous now that we ensure that the
    DF_PROCESSING_RDP and DF_REQ_TRIMMED flags are cleared on RDP
    removal.

Arguments:

    DeviceObject - Pointer to the PDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    PIO_RESOURCE_REQUIREMENTS_LIST IoResources;
    USHORT irqBootFlags;

    if ((deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) == NULL) {
        return STATUS_NO_SUCH_DEVICE;
    }

    if (deviceInfo->Flags & DF_READ_DATA_PORT) {
        DebugPrint((DEBUG_PNP, "Filtering resource requirements for RDP\n"));

        status = PipBuildRDPResources(&IoResources, deviceInfo->Flags);

        if (NT_SUCCESS(status)) {
            //
            // if someone above us filtered the RDP resource requirements,
            // free them.
            if (Irp->IoStatus.Information) {
                ExFreePool((PVOID) Irp->IoStatus.Information);
            }
            Irp->IoStatus.Information = (ULONG_PTR) IoResources;
        }
    } else {
        //
        // If the device's resource requirements are being filtered
        // and the new requirements have only one alternative vs the n
        // alternatives of the original, then we're going to assume we
        // are receiving a force config.  Apply our earlier derived
        // IRQ level/edge settings to this force config in order to
        // deal with broken force configs from NT4
        //
        // Design Note:
        // Probably should've left out the force config test
        // and done it on everything, but this is what we private
        // tested.

        IoResources =
            (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;

        if (IoResources &&
            (IoResources->AlternativeLists == 1) &&
            (deviceInfo->ResourceRequirements != NULL) &&
            (deviceInfo->ResourceRequirements->AlternativeLists > 1)) {
            status = PipGetBootIrqFlags(deviceInfo, &irqBootFlags);
            if (NT_SUCCESS(status)) {
                status = PipTrimResourceRequirements(
                    &IoResources,
                    irqBootFlags,
                    NULL);
                Irp->IoStatus.Information = (ULONG_PTR) IoResources;
            } else {
                status = STATUS_NOT_SUPPORTED;
            }
        } else {
            status = STATUS_NOT_SUPPORTED;
        }
    }

    PipDereferenceDeviceInformation(deviceInfo, FALSE);

    return status;
}



NTSTATUS
PiQueryIdPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_INFORMATION deviceInfo;
    ULONG length, bytesRemaining;
    ULONG requestIdStringLength, deviceIdStringLength;
    ULONG requestIdBufferLength, deviceIdBufferLength;
    PWCHAR requestId = NULL, ids;
    PWCHAR deviceId = NULL, p;
    PWCHAR stringEnd;


    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if ((deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) == NULL) {

        status = STATUS_NO_SUCH_DEVICE;
        return status;
    }

    switch (irpSp->Parameters.QueryId.IdType) {
    case BusQueryCompatibleIDs:

        ids = (PWCHAR)ExAllocatePool(PagedPool, 1024);
        length = 1024;
        if (ids) {
            PWCHAR p1;
            ULONG i;

            p1 = ids;
            for (i = 1; TRUE; i++) {
                //
                // Use the -1 as a sentinel so that we get the magic RDP compat. ID and also leave the loop
                //
                ASSERT (i < 256);
                if (deviceInfo->Flags & DF_READ_DATA_PORT) {
                    i =-1;
                }

                status = PipGetCompatibleDeviceId(
                              deviceInfo->DeviceData,
                              i,
                              &requestId,
                              &requestIdBufferLength
                              );
                if (NT_SUCCESS(status) && requestId) {
                    
                    if (FAILED(StringCbLength(requestId,
                                              requestIdBufferLength,
                                              &requestIdStringLength
                                              ))) {
                        status = STATUS_INVALID_PARAMETER;
                        ASSERT(FALSE);
                        break;
                    }
                    
                    if ((requestIdStringLength + 2*sizeof(WCHAR)) <= length) {
                        
                        if (FAILED(StringCbCopyEx(p1,
                                                  length,
                                                  requestId,
                                                  &stringEnd,
                                                  &bytesRemaining,
                                                  0
                                                  ))) {
                            ASSERT(FALSE);
                            status = STATUS_INVALID_PARAMETER;
                            break;
                        }
                        p1 = stringEnd;
                        p1++;

                        length = bytesRemaining - sizeof(UNICODE_NULL);
                        
                        ExFreePool(requestId);
                    } else {
                        ExFreePool(requestId);
                        break;
                    }
                    if ( i == -1 ) {
                        break;
                    }
                } else {
                   break;
                }
            }
            if (length == 1024) {
                ExFreePool(ids);
                ids = NULL;
            } else {
                *p1 = UNICODE_NULL;
            }
        }
        Irp->IoStatus.Information = (ULONG_PTR)ids;
        status = STATUS_SUCCESS;
        break;

    case BusQueryHardwareIDs:

        if (deviceInfo->Flags & DF_READ_DATA_PORT) {
            status = PipGetCompatibleDeviceId(deviceInfo->DeviceData, -1, &requestId, &requestIdBufferLength);
        }else {
            status = PipGetCompatibleDeviceId(deviceInfo->DeviceData, 0, &requestId, &requestIdBufferLength);
        }

        if (NT_SUCCESS(status) && requestId) {

            //
            // create HardwareId value name.  Even though it is a MULTI_SZ,
            // we know there is only one HardwareId for PnpIsa.
            //
            // HACK - The modem inf files use the form of isapnp\xyz0001
            //        instead of *xyz0001 as the hardware id.  To solve this
            //        problem we will generate two hardware Ids: *xyz0001 and
            //        isapnp\xyz0001 (device instance name).
            //

            status = PipQueryDeviceId(deviceInfo, &deviceId, &deviceIdBufferLength, 0);

            if (NT_SUCCESS (status)) {
                
                if (FAILED(StringCbLength(requestId,
                                          requestIdBufferLength,
                                          &requestIdStringLength
                                          ))) {
                    status = STATUS_INVALID_PARAMETER;
                    break;
                }
                if (FAILED(StringCbLength(deviceId,
                                          deviceIdBufferLength,
                                          &deviceIdStringLength
                                          ))) {
                    status = STATUS_INVALID_PARAMETER;
                    break;
                }
                //idLength = wcslen(requestId) * sizeof(WCHAR);
                //deviceIdLength = wcslen(deviceId) * sizeof(WCHAR);
                length = requestIdStringLength +                       // returned ID
                         sizeof(WCHAR) +                  // UNICODE_NULL
                         deviceIdStringLength +                 // isapnp\id
                         2 * sizeof(WCHAR);               // two UNICODE_NULLs
                ids = p = (PWCHAR)ExAllocatePool(PagedPool, length);
                if (ids) {
                    
                    if (FAILED(StringCbCopyEx(ids,
                                              length,
                                              deviceId,
                                              &stringEnd,
                                              &bytesRemaining,
                                              0
                                              ))) {
                        ASSERT(FALSE);
                        status = STATUS_INVALID_PARAMETER;
                        break;
                    }
                    p = stringEnd + 1;

                    if (FAILED(StringCbCopyEx(p,
                                              length,
                                              requestId,
                                              &stringEnd,
                                              &bytesRemaining,
                                              0
                                              ))) {
                        ASSERT(FALSE);
                        status = STATUS_INVALID_PARAMETER;
                        break;
                    }
                    p = stringEnd + 1;
                    *p = UNICODE_NULL;
                    
                    ExFreePool(requestId);
                    
                    Irp->IoStatus.Information = (ULONG_PTR)ids;
                } else {
                    Irp->IoStatus.Information = (ULONG_PTR)requestId;
                }
                if (deviceId) {
                    ExFreePool(deviceId);
                }
            }
        }
        break;

    case BusQueryDeviceID:

        status = PipQueryDeviceId(deviceInfo, &requestId, &requestIdBufferLength, 0);
        Irp->IoStatus.Information = (ULONG_PTR)requestId;
        break;

    case BusQueryInstanceID:

        status = PipQueryDeviceUniqueId (deviceInfo, &requestId, &requestIdBufferLength);
        Irp->IoStatus.Information = (ULONG_PTR)requestId;
        break;

    default:

        status = STATUS_NOT_SUPPORTED;
    }
    PipDereferenceDeviceInformation(deviceInfo, FALSE);

    return status;

} // PiQueryIdPdo


NTSTATUS
PiQueryResourcesPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status=STATUS_SUCCESS;
    PDEVICE_INFORMATION deviceInfo;
    PCM_RESOURCE_LIST cmResources=NULL;
    ULONG length;

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {
        if ((deviceInfo->Flags & DF_READ_DATA_PORT) ||
            ((deviceInfo->Flags & (DF_ENUMERATED|DF_REMOVED)) == DF_ENUMERATED)) {
            status = PipQueryDeviceResources (
                          deviceInfo,
                          0,             // BusNumber
                          &cmResources,
                          &length
                          );
        }
        PipDereferenceDeviceInformation(deviceInfo, FALSE);
        Irp->IoStatus.Information = (ULONG_PTR)cmResources;
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "PiQueryResourcesPdo returning: %x\n",status));
    return status;

} // PiQueryResourcesPdo

NTSTATUS
PiQueryResourceRequirementsPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResources;

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {
        status = STATUS_SUCCESS;

        if (deviceInfo->Flags & DF_READ_DATA_PORT) {
            status = PipBuildRDPResources (&ioResources,
                                           deviceInfo->Flags);
        } else {
            if (deviceInfo->ResourceRequirements &&
              !(deviceInfo->Flags & (DF_SURPRISE_REMOVED))) {

                ioResources = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool (
                               PagedPool, deviceInfo->ResourceRequirements->ListSize);
                if (ioResources == NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    RtlMoveMemory(ioResources,
                                  deviceInfo->ResourceRequirements,
                                  deviceInfo->ResourceRequirements->ListSize
                                  );
                }
            } else {
                ioResources = NULL;
            }
        }
        Irp->IoStatus.Information = (ULONG_PTR)ioResources;
        PipDereferenceDeviceInformation(deviceInfo, FALSE);
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "PiQueryResourceRequirementsPdo returning: %x\n",status));
    return status;

} // PiQueryResourceRequirementsPdo


NTSTATUS
PiRemovePdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    POWER_STATE newPowerState;

    //
    // One of our enumerated device is being removed.  Mark it and deactivate the
    // device.  Note, we do NOT delete its device object.
    //
    DebugPrint((DEBUG_PNP, "PiRemovePdo %x\n",DeviceObject));

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {
        if (!(deviceInfo->Flags & (DF_REMOVED|DF_SURPRISE_REMOVED))) {
            deviceInfo->Flags |= DF_REMOVED;
            deviceInfo->Flags &= ~DF_QUERY_STOPPED;

            if (deviceInfo->Flags & DF_READ_DATA_PORT) {

                PSINGLE_LIST_ENTRY deviceLink;
                PPI_BUS_EXTENSION busExtension = deviceInfo->ParentDeviceExtension;

                //
                // If the RDP is removed, mark everyone as missing, and then return only the
                // RDP
                //
                PipLockDeviceDatabase();

                deviceLink = busExtension->DeviceList.Next;
                while (deviceLink) {
                    deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);
                    if (!(deviceInfo->Flags & DF_READ_DATA_PORT)) {
                        deviceInfo->Flags &= ~DF_ENUMERATED;
                    }
                    deviceLink = deviceInfo->DeviceList.Next;
                }

                PipUnlockDeviceDatabase();

                IoInvalidateDeviceRelations (
                    deviceInfo->ParentDeviceExtension->PhysicalBusDevice,BusRelations);
                deviceInfo->Flags &= ~(DF_REQ_TRIMMED|DF_PROCESSING_RDP);
            }

            //
            // Deactivate the device
            //
            if (deviceInfo->Flags & DF_ACTIVATED) {
                deviceInfo->Flags &= ~DF_ACTIVATED;

                if (!(deviceInfo->Flags & (DF_READ_DATA_PORT|DF_NOT_FUNCTIONING))) {
                    PipWakeAndSelectDevice(
                        deviceInfo->CardInformation->CardSelectNumber,
                        deviceInfo->LogicalDeviceNumber);
                    PipDeactivateDevice();
                    PipWaitForKey();
                    DebugPrint((DEBUG_STATE,
                                "Removing CSN %d/LDN %d\n",
                                deviceInfo->CardInformation->CardSelectNumber,
                                deviceInfo->LogicalDeviceNumber));
                }
                newPowerState.DeviceState = deviceInfo->DevicePowerState = PowerDeviceD3;
                PoSetPowerState(DeviceObject, DevicePowerState, newPowerState);
            }

            PipReleaseDeviceResources (deviceInfo);
        }

        if (!(deviceInfo->Flags & DF_ENUMERATED)) {
            PipDeleteDevice(DeviceObject);
        }

        PipDereferenceDeviceInformation(deviceInfo, TRUE);
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "RemoveDevice returning: %x\n",status));

    return status;

} // PiRemovePdo


NTSTATUS
PiQueryBusInformationPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PPNP_BUS_INFORMATION pnpBusInfo;
    PVOID information = NULL;
    PPI_BUS_EXTENSION busExtension;
    NTSTATUS status;

    busExtension = DeviceObject->DeviceExtension;

    pnpBusInfo = (PPNP_BUS_INFORMATION) ExAllocatePool(PagedPool, sizeof(PNP_BUS_INFORMATION));
    if (pnpBusInfo) {
        pnpBusInfo->BusTypeGuid = GUID_BUS_TYPE_ISAPNP;
        pnpBusInfo->LegacyBusType = Isa;
        pnpBusInfo->BusNumber = busExtension->BusNumber;
        information = pnpBusInfo;
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
        information = NULL;
    }
    Irp->IoStatus.Information = (ULONG_PTR) information;

    return status;
} // PiQueryBusInformationPdo

NTSTATUS
PiDeviceUsageNotificationPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine notes whether an ISAPNP device is on the crashdump or
    paging file path.  It fails attempts to put us on the hibernation path.

Arguments:

    DeviceObject - Pointer to the PDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PDEVICE_INFORMATION deviceInfo;
    PIO_STACK_LOCATION irpSp;
    PLONG addend;
    NTSTATUS status = STATUS_SUCCESS;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if ((deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) == NULL) {

        status = STATUS_NO_SUCH_DEVICE;
        return status;
    }

    DebugPrint((DEBUG_PNP, "DeviceUsage CSN %d/LSN %d: InPath %s Type %d\n",
                deviceInfo->CardInformation->CardSelectNumber,
                deviceInfo->LogicalDeviceNumber,
                irpSp->Parameters.UsageNotification.InPath ? "TRUE" : "FALSE",
                irpSp->Parameters.UsageNotification.Type));

    switch (irpSp->Parameters.UsageNotification.Type) {
    case DeviceUsageTypePaging:
        addend = &deviceInfo->Paging;
        break;
    case DeviceUsageTypeHibernation:
        status = STATUS_DEVICE_BUSY;
        break;
    case DeviceUsageTypeDumpFile:
        addend = &deviceInfo->CrashDump;
        break;
    default:
        status = STATUS_NOT_SUPPORTED;
    }

    if (status == STATUS_SUCCESS) {
        if (irpSp->Parameters.UsageNotification.InPath) {
            //
            // Turn on broken isolation flag which causes QDR
            // to use the cache instead of beating on the hardware if
            // we're on the paging or crashdump paths.  Some
            // hardware appears unhappy during QDR and causes problems when
            // we take a page fault in this routine.
            //

            deviceInfo->CardInformation->CardFlags |= CF_ISOLATION_BROKEN;
            (*addend)++;
            IoInvalidateDeviceState(DeviceObject);
        }
        else {
            (*addend)--;
        }
    }
    PipDereferenceDeviceInformation(deviceInfo, FALSE);
    return status;
}

NTSTATUS
PiQueryInterfacePdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    return STATUS_NOT_SUPPORTED;

} // PiQueryInterfacePdo


NTSTATUS
PiSurpriseRemovePdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    PSINGLE_LIST_ENTRY deviceLink;

    DebugPrint((DEBUG_PNP, "SurpriseRemove PDO %x\n", DeviceObject));
    //
    // One of our enumerated device is being removed.  Mark it and deactivate the
    // device.  Note, we do NOT delete its device object.
    //

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {
        if (deviceInfo->Flags & DF_READ_DATA_PORT) {
            //
            // If the RDP is removed, mark everyone as missing, and then return only the
            // RDP
            //
            PipLockDeviceDatabase();

            deviceLink = deviceInfo->ParentDeviceExtension->DeviceList.Next;
            while (deviceLink) {
                deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);
                if (!(deviceInfo->Flags & DF_READ_DATA_PORT)) {
                    deviceInfo->Flags &= ~DF_ENUMERATED;
                }
                deviceLink = deviceInfo->DeviceList.Next;
            }

            PipUnlockDeviceDatabase();

            IoInvalidateDeviceRelations (
                deviceInfo->ParentDeviceExtension->PhysicalBusDevice,BusRelations);
        } else {
            DebugPrint((DEBUG_STATE,
                        "Surprise removing CSN %d/LDN %d\n",
                        deviceInfo->CardInformation->CardSelectNumber,
                        deviceInfo->LogicalDeviceNumber));
            if ((deviceInfo->Flags & (DF_ACTIVATED|DF_NOT_FUNCTIONING)) == DF_ACTIVATED) {
                PipWakeAndSelectDevice(
                    deviceInfo->CardInformation->CardSelectNumber,
                    deviceInfo->LogicalDeviceNumber);
                PipDeactivateDevice();
                PipWaitForKey();
            }

            PipReleaseDeviceResources (deviceInfo);
            deviceInfo->Flags |= DF_SURPRISE_REMOVED;
            deviceInfo->Flags &= ~(DF_QUERY_STOPPED|DF_REMOVED|DF_ACTIVATED);
        }
        PipDereferenceDeviceInformation(deviceInfo, FALSE);
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    return status;
} // PiSurpriseRemovePdo



NTSTATUS
PiIrpNotSupported(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{

    return STATUS_NOT_SUPPORTED;

} // PiIrpNotSupported

NTSTATUS
PipBuildRDPResources(
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *IoResources,
    IN ULONG    Flags
    )
{
        UCHAR MaxCards = 0, CardsFound;
        int i, j, numcases;
        int resSize;

        ASSERT(Flags & DF_READ_DATA_PORT);

        //
        // We need to assemble all possible cases for the RDP
        //
        numcases = 2*READ_DATA_PORT_RANGE_CHOICES;

        if (Flags & DF_REQ_TRIMMED) {
            numcases = 0;
            for (i = 0; i < READ_DATA_PORT_RANGE_CHOICES; i++) {
                CardsFound = PipReadDataPortRanges[i].CardsFound;
                if (MaxCards < CardsFound) {
                    MaxCards = CardsFound;
                    numcases = 1;
                } else if (MaxCards == CardsFound) {
                    numcases++;
                }
            }
        }
        //
        // need to allow for the RDP range, the address port, the cmd port and the 0
        //
        resSize = sizeof (IO_RESOURCE_LIST)+((numcases+3)*sizeof (IO_RESOURCE_REQUIREMENTS_LIST));

        *IoResources = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool (PagedPool,resSize);
        if (*IoResources == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory (*IoResources,resSize);

        (*IoResources)->BusNumber=0;
        (*IoResources)->AlternativeLists = 1;
        (*IoResources)->List->Count = numcases+4;
        (*IoResources)->List->Version = ISAPNP_IO_VERSION;
        (*IoResources)->List->Revision =ISAPNP_IO_REVISION;

        //
        // Requirements specify 16-bit decode even though the spec
        // says 12.  No ill effects have ever been observed from 16
        // and 12-bit decode broke some machines when tried.

        //
        // cmd port
        //
        (*IoResources)->List->Descriptors[0].Type=CM_RESOURCE_PORT_IO;
        (*IoResources)->List->Descriptors[0].u.Port.MinimumAddress.LowPart = COMMAND_PORT;
        (*IoResources)->List->Descriptors[0].u.Port.MaximumAddress.LowPart = COMMAND_PORT;

        (*IoResources)->List->Descriptors[0].u.Port.Length = 1;
        (*IoResources)->List->Descriptors[0].u.Port.Alignment = 1;
        (*IoResources)->List->Descriptors[0].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
        (*IoResources)->List->Descriptors[0].ShareDisposition = CmResourceShareDeviceExclusive;

        //
        // alternative of 0 for bioses that include COMMAND_PORT in
        // a PNP0C02 node.
        //
        (*IoResources)->List->Descriptors[1].Type=CM_RESOURCE_PORT_IO;
        (*IoResources)->List->Descriptors[1].u.Port.MinimumAddress.QuadPart = 0;
        (*IoResources)->List->Descriptors[1].u.Port.MaximumAddress.QuadPart = 0;

        (*IoResources)->List->Descriptors[1].u.Port.Length = 0;
        (*IoResources)->List->Descriptors[1].u.Port.Alignment  = 1;
        (*IoResources)->List->Descriptors[1].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
        (*IoResources)->List->Descriptors[1].ShareDisposition = CmResourceShareDeviceExclusive;
        (*IoResources)->List->Descriptors[1].Option = IO_RESOURCE_ALTERNATIVE;

        //
        // Address port
        //
        (*IoResources)->List->Descriptors[2].Type=CM_RESOURCE_PORT_IO;
        (*IoResources)->List->Descriptors[2].u.Port.MinimumAddress.LowPart = ADDRESS_PORT;
        (*IoResources)->List->Descriptors[2].u.Port.MaximumAddress.LowPart = ADDRESS_PORT;

        (*IoResources)->List->Descriptors[2].u.Port.Length = 1;
        (*IoResources)->List->Descriptors[2].u.Port.Alignment = 1;
        (*IoResources)->List->Descriptors[2].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
        (*IoResources)->List->Descriptors[2].ShareDisposition = CmResourceShareDeviceExclusive;
        //
        // alternative of 0
        //
        (*IoResources)->List->Descriptors[3].Type=CM_RESOURCE_PORT_IO;
        (*IoResources)->List->Descriptors[3].u.Port.MinimumAddress.QuadPart = 0;
        (*IoResources)->List->Descriptors[3].u.Port.MaximumAddress.QuadPart = 0;

        (*IoResources)->List->Descriptors[3].u.Port.Length = 0;
        (*IoResources)->List->Descriptors[3].u.Port.Alignment  = 1;
        (*IoResources)->List->Descriptors[3].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
        (*IoResources)->List->Descriptors[3].ShareDisposition = CmResourceShareDeviceExclusive;
        (*IoResources)->List->Descriptors[3].Option = IO_RESOURCE_ALTERNATIVE;

        if (Flags & DF_REQ_TRIMMED) {
            j = 0;
            for (i = 0; i < READ_DATA_PORT_RANGE_CHOICES; i++) {
                if (PipReadDataPortRanges[i].CardsFound != MaxCards) {
                    continue;
                }
                //
                // An RDP alternative
                //
                (*IoResources)->List->Descriptors[4+j].Type=CM_RESOURCE_PORT_IO;

                (*IoResources)->List->Descriptors[4+j].u.Port.MinimumAddress.LowPart =
                    PipReadDataPortRanges[i].MinimumAddress;
                (*IoResources)->List->Descriptors[4+j].u.Port.MaximumAddress.LowPart =
                    PipReadDataPortRanges[i].MaximumAddress;

                (*IoResources)->List->Descriptors[4+j].u.Port.Length =
                    PipReadDataPortRanges[i].MaximumAddress  -
                    PipReadDataPortRanges[i].MinimumAddress+1;
                (*IoResources)->List->Descriptors[4+j].u.Port.Alignment  = 1;
                (*IoResources)->List->Descriptors[4+j].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
                (*IoResources)->List->Descriptors[4+j].ShareDisposition = CmResourceShareDeviceExclusive;
                (*IoResources)->List->Descriptors[4+j].Option = IO_RESOURCE_ALTERNATIVE;
                j++;
            }
            (*IoResources)->List->Descriptors[4].Option = 0;
        } else {
            for (i = 0;i< (numcases >> 1);i++) {
                //
                // The RDP
                //
                (*IoResources)->List->Descriptors[4+i*2].Type=CM_RESOURCE_PORT_IO;

                (*IoResources)->List->Descriptors[4+i*2].u.Port.MinimumAddress.LowPart =
                    PipReadDataPortRanges[i].MinimumAddress;
                (*IoResources)->List->Descriptors[4+i*2].u.Port.MaximumAddress.LowPart =
                    PipReadDataPortRanges[i].MaximumAddress;

                (*IoResources)->List->Descriptors[4+i*2].u.Port.Length =
                    PipReadDataPortRanges[i].MaximumAddress  -
                    PipReadDataPortRanges[i].MinimumAddress+1;

                (*IoResources)->List->Descriptors[4+i*2].u.Port.Alignment  = 1;
                (*IoResources)->List->Descriptors[4+i*2].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
                (*IoResources)->List->Descriptors[4+i*2].ShareDisposition = CmResourceShareDeviceExclusive;

                //
                // alternative of 0
                //
                (*IoResources)->List->Descriptors[4+i*2+1].Type=CM_RESOURCE_PORT_IO;
                (*IoResources)->List->Descriptors[4+i*2+1].u.Port.MinimumAddress.QuadPart = 0;
                (*IoResources)->List->Descriptors[4+i*2+1].u.Port.MaximumAddress.QuadPart = 0;

                (*IoResources)->List->Descriptors[4+i*2+1].u.Port.Length = 0;
                (*IoResources)->List->Descriptors[4+i*2+1].u.Port.Alignment  = 1;
                (*IoResources)->List->Descriptors[4+i*2+1].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
                (*IoResources)->List->Descriptors[4+i*2+1].ShareDisposition = CmResourceShareDeviceExclusive;
                (*IoResources)->List->Descriptors[4+i*2+1].Option = IO_RESOURCE_ALTERNATIVE;

            }

        }
        (*IoResources)->ListSize = resSize;

        return STATUS_SUCCESS;
}

NTSTATUS
PiQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status=STATUS_NOT_SUPPORTED;
    PDEVICE_INFORMATION deviceInfo;

    //
    // One of our enumerated device is being removed.  Mark it and deactivate the
    // device.  Note, we do NOT delete its device object.
    //

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {

        if ((deviceInfo->Flags & DF_READ_DATA_PORT) && (deviceInfo->Flags & DF_PROCESSING_RDP)) {
            Irp->IoStatus.Information |= PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED |
                                         PNP_DEVICE_FAILED |
                                         PNP_DEVICE_NOT_DISABLEABLE ;
            status = STATUS_SUCCESS;
        }

        if (deviceInfo->Paging || deviceInfo->CrashDump) {
            Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
            status = STATUS_SUCCESS;
        }
        PipDereferenceDeviceInformation(deviceInfo, FALSE);
   }
   return status;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\pnpisa.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pnpisa.h

Abstract:

    This module contins definitions/declarations for PNP ISA related
    definitions.

Author:

    Shie-Lin Tzong (shielint) July-12-1995

Revision History:

--*/

//
// External references
//

extern ULONG  ADDRESS_PORT;
extern ULONG  COMMAND_PORT;

extern PUCHAR PipReadDataPort;
extern PUCHAR PipAddressPort;
extern PUCHAR PipCommandPort;

//
// Definitions
//

#if defined(_X86_)
#define ADDRESS_PORT_NEC            0x0259
#define COMMAND_PORT_NEC            0x0a59
#endif

//
// Plug and Play Card Control Registers
//

#define SET_READ_DATA_PORT          0x00
#define SERIAL_ISOLATION_PORT       0x01
#define CONFIG_CONTROL_PORT         0x02
#define WAKE_CSN_PORT               0x03
#define CONFIG_DATA_PORT            0x04
#define CONFIG_DATA_STATUS_PORT     0x05
#define SET_CSN_PORT                0x06
#define LOGICAL_DEVICE_PORT         0x07

//
// Plug and Play Logical Device Control Registers
//

#define ACTIVATE_PORT               0x30
#define IO_RANGE_CHECK_PORT         0x31

//
// Config Control command
//

#define CONTROL_RESET               0x01
#define CONTROL_WAIT_FOR_KEY        0x02
#define CONTROL_RESET_CSN           0x04

//
// Memory Space Configuration
//

#define NUMBER_MEMORY_DESCRIPTORS   4
#define ADDRESS_MEMORY_BASE         0x40
#define ADDRESS_MEMORY_INCR         0x08
#define ADDRESS_MEMORY_HI           0x00
#define ADDRESS_MEMORY_LO           0x01
#define ADDRESS_MEMORY_CTL          0x02
#define ADDRESS_MEMORY_CTL_LIMIT    0x01
#define ADDRESS_MEMORY_UPPER_HI     0x03
#define ADDRESS_MEMORY_UPPER_LO     0x04

//
// 32 Bit Memory Space Configuration
//

#define NUMBER_32_MEMORY_DESCRIPTORS 4
#define ADDRESS_32_MEMORY_BASE(x)   ((PUCHAR)(0x70+((x)*0x10)+((x==0) ? 6 : 0)))
#define ADDRESS_32_MEMORY_B3        0x0
#define ADDRESS_32_MEMORY_B2        0x1
#define ADDRESS_32_MEMORY_B1        0x2
#define ADDRESS_32_MEMORY_B0        0x3
#define ADDRESS_32_MEMORY_CTL       0x4
#define ADDRESS_32_MEMORY_E3        0x5
#define ADDRESS_32_MEMORY_E2        0x6
#define ADDRESS_32_MEMORY_E1        0x7
#define ADDRESS_32_MEMORY_E0        0x8

//
// Io Space Configuration
//

#define NUMBER_IO_DESCRIPTORS       8
#define ADDRESS_IO_BASE             0x60
#define ADDRESS_IO_INCR             0x02
#define ADDRESS_IO_BASE_HI          0x00
#define ADDRESS_IO_BASE_LO          0x01

//
// Interrupt Configuration
//

#define NUMBER_IRQ_DESCRIPTORS      2
#define ADDRESS_IRQ_BASE            0x70
#define ADDRESS_IRQ_INCR            0x02
#define ADDRESS_IRQ_VALUE           0x00
#define ADDRESS_IRQ_TYPE            0x01

//
// DMA Configuration
//

#define NUMBER_DMA_DESCRIPTORS     2
#define ADDRESS_DMA_BASE           0x74
#define ADDRESS_DMA_INCR           0x01
#define ADDRESS_DMA_VALUE          0x00
#define NO_DMA                     0x04

//
// 9 byte serial identifier of a PNP ISA Card
//

#include "pshpack1.h"
typedef struct _SERIAL_IDENTIFIER_ {
    ULONG VenderId;
    ULONG SerialNumber;
    UCHAR Checksum;
} SERIAL_IDENTIFIER, *PSERIAL_IDENTIFIER;
#include "poppack.h"

//
// Misc. definitions
//

#define MIN_READ_DATA_PORT         0x200
#define MAX_READ_DATA_PORT         0x3ff
#define MAX_CHARACTER_LENGTH       255
#define NUMBER_CARD_ID_BYTES       9
#define NUMBER_CARD_ID_BITS        (NUMBER_CARD_ID_BYTES * 8)
#define CHECKSUMED_BITS            64
#define LFSR_SEED                  0x6A
#define ISOLATION_TEST_BYTE_1      0x55
#define ISOLATION_TEST_BYTE_2      0xAA

#define PipWriteAddress(data)      WRITE_PORT_UCHAR (PipAddressPort, (UCHAR)(ULONG_PTR)(data))
#define PipWriteData(data)         WRITE_PORT_UCHAR (PipCommandPort, (UCHAR)(ULONG_PTR)(data))
#define PipReadData()              READ_PORT_UCHAR (PipReadDataPort)

VOID
PipWaitForKey(
    VOID
    );

VOID
PipConfig(
    IN UCHAR Csn
    );

VOID
PipIsolation(
    VOID
    );

VOID
PipSleep(
    VOID
    );

VOID
PipSelectDevice(
    IN UCHAR Device
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\resource.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    devres.c

Abstract:

    This module contains the high level device resources support routines.

Author:

    Shie-Lin Tzong (shielint) July-27-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "busp.h"
#include "pnpisa.h"
#include "pbios.h"
#include "pnpcvrt.h"

#if ISOLATE_CARDS

#define IDBG 0

PIO_RESOURCE_REQUIREMENTS_LIST
PipCmResourcesToIoResources (
    IN PCM_RESOURCE_LIST CmResourceList
    );

NTSTATUS
PipMergeResourceRequirementsLists (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList1,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList2,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *MergedList
    );

NTSTATUS
PipBuildBootResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList,
    IN PCM_RESOURCE_LIST CmList,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *FilteredList,
    OUT PBOOLEAN ExactMatch
    );

VOID
PipMergeBootResourcesToRequirementsList(
    PDEVICE_INFORMATION DeviceInfo,
    PCM_RESOURCE_LIST BootResources,
    PIO_RESOURCE_REQUIREMENTS_LIST *IoResources
    );

#pragma alloc_text(PAGE, PipGetCardIdentifier)
#pragma alloc_text(PAGE, PipGetFunctionIdentifier)
#pragma alloc_text(PAGE, PipGetCompatibleDeviceId)
#pragma alloc_text(PAGE, PipQueryDeviceId)
#pragma alloc_text(PAGE, PipQueryDeviceUniqueId)
//#pragma alloc_text(PAGE, PipQueryDeviceResources)
#pragma alloc_text(PAGE, PipQueryDeviceResourceRequirements)
//#pragma alloc_text(PAGE, PipFilterResourceRequirementsList)
#pragma alloc_text(PAGE, PipCmResourcesToIoResources)
#pragma alloc_text(PAGE, PipMergeResourceRequirementsLists)
#pragma alloc_text(PAGE, PipBuildBootResourceRequirementsList)
#pragma alloc_text(PAGE, PipMergeBootResourcesToRequirementsList)
//#pragma alloc_text(PAGE, PipSetDeviceResources)


NTSTATUS
PipGetCardIdentifier (
    PUCHAR CardData,
    PWCHAR *Buffer,
    PULONG BufferLength
    )
/*++

Routine Description:

    This function returns the identifier for a pnpisa card.

Arguments:

    CardData - supplies a pointer to the pnp isa device data.

    Buffer - supplies a pointer to variable to receive a pointer to the Id.

    BufferLength - supplies a pointer to a variable to receive the size of the id buffer.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR tag;
    LONG size, length;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    PCHAR ansiBuffer;

    *Buffer = NULL;
    *BufferLength = 0;

    if (CardData == NULL) {
        return status;
    }
    tag = *CardData;

    //
    // Make sure CardData does *NOT* point to a Logical Device Id tag
    //

    if ((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID) {
        DbgPrint("PipGetCardIdentifier: CardData is at a Logical Id tag\n");
        return status;
    }

    //
    // Find the resource descriptor which describle identifier string
    //

    do {

        //
        // Do we find the identifer resource tag?
        //

        if (tag == TAG_ANSI_ID) {
            CardData++;
            length = *(USHORT UNALIGNED *)CardData;
            CardData += 2;
            ansiBuffer = (PCHAR)ExAllocatePool(PagedPool, length+1);
            if (ansiBuffer == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            RtlMoveMemory(ansiBuffer, CardData, length);
            ansiBuffer[length] = 0;
            RtlInitAnsiString(&ansiString, ansiBuffer);
            status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
            ExFreePool(ansiBuffer);
            if (!NT_SUCCESS(status)) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            *Buffer = unicodeString.Buffer;
            *BufferLength = unicodeString.Length + sizeof(WCHAR);
            break;
        }

        //
        // Determine the size of the BIOS resource descriptor and
        // advance to next resource descriptor.
        //

        if (!(tag & LARGE_RESOURCE_TAG)) {
            size = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
            size += 1;     // length of small tag
        } else {
            size = *(USHORT UNALIGNED *)(CardData + 1);
            size += 3;     // length of large tag
        }

        CardData += size;
        tag = *CardData;

    } while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID));

    return status;
}

NTSTATUS
PipGetFunctionIdentifier (
    PUCHAR DeviceData,
    PWCHAR *Buffer,
    PULONG BufferLength
    )
/*++

Routine Description:

    This function returns the desired pnp isa identifier for the specified
    DeviceData/LogicalFunction.  The Identifier for a logical function is
    optional.  If no Identifier available , Buffer is set to NULL.

Arguments:

    DeviceData - supplies a pointer to the pnp isa device data.

    Buffer - supplies a pointer to variable to receive a pointer to the Id.

    BufferLength - supplies a pointer to a variable to receive the size of the id buffer.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR tag;
    LONG size, length;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    PCHAR ansiBuffer;

    *Buffer = NULL;
    *BufferLength = 0;

    if (DeviceData==NULL) {
        return status;
    }
    tag = *DeviceData;

#if DBG

    //
    // Make sure device data points to Logical Device Id tag
    //

    if ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID) {
        DbgPrint("PipGetFunctionIdentifier: DeviceData is not at a Logical Id tag\n");
    }
#endif

    //
    // Skip all the resource descriptors to find compatible Id descriptor
    //

    do {

        //
        // Determine the size of the BIOS resource descriptor and
        // advance to next resource descriptor.
        //

        if (!(tag & LARGE_RESOURCE_TAG)) {
            size = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
            size += 1;     // length of small tag
        } else {
            size = *(USHORT UNALIGNED *)(DeviceData + 1);
            size += 3;     // length of large tag
        }

        DeviceData += size;
        tag = *DeviceData;

        //
        // Do we find the identifer resource tag?
        //

        if (tag == TAG_ANSI_ID) {
            DeviceData++;
            length = *(USHORT UNALIGNED *)DeviceData;
            DeviceData += 2;
            ansiBuffer = (PCHAR)ExAllocatePool(PagedPool, length+1);
            if (ansiBuffer == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            RtlMoveMemory(ansiBuffer, DeviceData, length);
            ansiBuffer[length] = 0;
            RtlInitAnsiString(&ansiString, ansiBuffer);
            status = RtlAnsiStringToUnicodeString(&unicodeString,
                                                  &ansiString,
                                                  TRUE);
            ExFreePool(ansiBuffer);
            if (!NT_SUCCESS(status)) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            *Buffer = unicodeString.Buffer;
            *BufferLength = unicodeString.Length + sizeof(WCHAR);
            break;
        }

    } while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID));

    return status;
}

NTSTATUS
PipGetCompatibleDeviceId (
    IN PUCHAR DeviceData,
    IN ULONG IdIndex,
    OUT PWCHAR *Buffer,
    OUT PULONG BufferSize
    )
/*++

Routine Description:

    This function returns the desired pnp isa id for the specified DeviceData
    and Id index.  If Id index = 0, the Hardware ID will be return; if id
    index = n, the Nth compatible id will be returned.

Arguments:

    DeviceData - supplies a pointer to the pnp isa device data.

    IdIndex - supplies the index of the compatible id desired.

    Buffer - supplies a pointer to variable to receive a pointer to the compatible Id.
    
    BufferSize - the length of the pointer allocated and returned to the caller in *Buffer.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS status = STATUS_NO_MORE_ENTRIES;
    UCHAR tag;
    ULONG count = 0,length;
    LONG size;
    UNICODE_STRING unicodeString;
    WCHAR eisaId[8];
    ULONG id;
    ULONG bufferSize;


    //
    // Bail out BEFORE we touch the device data for the RDP
    //

    if (IdIndex == -1) {
        length = 2* sizeof(WCHAR);

        *Buffer = (PWCHAR) ExAllocatePool(PagedPool, length);
        if (*Buffer) {
            *BufferSize = length;
            RtlZeroMemory (*Buffer,length);
        }else {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        return STATUS_SUCCESS;
    }



    tag = *DeviceData;

#if DBG

    //
    // Make sure device data points to Logical Device Id tag
    //

    if ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID) {
        DbgPrint("PipGetCompatibleDeviceId: DeviceData is not at Logical Id tag\n");
    }
#endif

    if (IdIndex == 0) {

        //
        // Caller is asking for hardware id
        //

        DeviceData++;                                      // Skip tag
        id = *(ULONG UNALIGNED *)DeviceData;
        status = STATUS_SUCCESS;
    } else {

        //
        // caller is asking for compatible id
        //

        IdIndex--;

        //
        // Skip all the resource descriptors to find compatible Id descriptor
        //

        do {

            //
            // Determine the size of the BIOS resource descriptor and
            // advance to next resource descriptor.
            //

            if (!(tag & LARGE_RESOURCE_TAG)) {
                size = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
                size += 1;     // length of small tag
            } else {
                size = *(USHORT UNALIGNED *)(DeviceData + 1);
                size += 3;     // length of large tag
            }

            DeviceData += size;
            tag = *DeviceData;

            //
            // Do we reach the compatible ID descriptor?
            //

            if ((tag & SMALL_TAG_MASK) == TAG_COMPATIBLE_ID) {
                if (count == IdIndex) {
                    id = *(ULONG UNALIGNED *)(DeviceData + 1);
                    status = STATUS_SUCCESS;
                    break;
                } else {
                    count++;
                }
            }

        } while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID));
    }

    if (NT_SUCCESS(status)) {
        PipDecompressEisaId(id, eisaId);
        RtlInitUnicodeString(&unicodeString, eisaId);
        
        bufferSize = sizeof(L"*") + sizeof(WCHAR) + unicodeString.Length;
        *Buffer = (PWCHAR)ExAllocatePool (
                        PagedPool,
                        bufferSize
                        );
        if (*Buffer) {
            
            if (FAILED(StringCbPrintf(*Buffer, 
                                      bufferSize,
                                      L"*%s", 
                                      unicodeString.Buffer
                                      ))) {

                ASSERT(FALSE);
                status = STATUS_INVALID_PARAMETER;
            
            } else {
                *BufferSize = bufferSize;
            }

        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return status;
}

NTSTATUS
PipQueryDeviceUniqueId (
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PWCHAR *DeviceId,
    OUT PULONG DeviceIdLength
    )
/*++

Routine Description:

    This function returns the unique id for the particular device.

Arguments:

    DeviceData - Device data information for the specificied device.

    DeviceId - supplies a pointer to a variable to receive device id.
    
    DeviceIdLength - On success, will contain the length of the buffer
        allocated and returned to the caller in *DeviceId

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG size;

    //
    // Set up device's unique id.
    // device unique id = SerialNumber of the card
    //

    size = (8 + 1) * sizeof(WCHAR);  // serial number + null

    *DeviceId = (PWCHAR)ExAllocatePool (
                        PagedPool,
                        size
                        );
    if (*DeviceId) {
        if (DeviceInfo->Flags & DF_READ_DATA_PORT) {
            //
            // Override the unique ID for the RDP
            //
            StringCbPrintf(*DeviceId,
                           size,
                           L"0"
                           );

        } else {
            StringCbPrintf (*DeviceId,
                            size,
                            L"%01X",
                            ((PSERIAL_IDENTIFIER) (DeviceInfo->CardInformation->CardData))->SerialNumber
                            );
        }

        *DeviceIdLength = size;

#if IDBG
        {
            ANSI_STRING ansiString;
            UNICODE_STRING unicodeString;

            RtlInitUnicodeString(&unicodeString, *DeviceId);
            if (NT_SUCCESS(RtlUnicodeStringToAnsiString(&ansiString, &unicodeString, TRUE))) {
                DbgPrint("PnpIsa: return Unique Id = %s\n", ansiString.Buffer);
                RtlFreeAnsiString(&ansiString);
            }  
        }
#endif
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return status;
}

NTSTATUS
PipQueryDeviceId (
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PWCHAR *DeviceId,
    OUT PULONG DeviceIdLength,
    IN ULONG IdIndex
    )
/*++

Routine Description:

    This function returns the device id for the particular device.

Arguments:

    DeviceInfo - Device information for the specificied device.

    DeviceId - supplies a pointer to a variable to receive the device id.
    
    DeviceIdLength - On success, will contain the length of the buffer
        allocated and returned to the caller in *DeviceId

    IdIndex - specifies device id or compatible id (0 - device id)

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PWSTR format;
    ULONG size,length;
    WCHAR eisaId[8];
    UNICODE_STRING unicodeString;


    //
    // Bail out BEFORE we touch the device data for the RDP
    //

    if (DeviceInfo->Flags & DF_READ_DATA_PORT) {
        length = (sizeof (wReadDataPort)+
             + sizeof(WCHAR) +sizeof (L"ISAPNP\\"));
        *DeviceId = (PWCHAR) ExAllocatePool(PagedPool, length);
        if (*DeviceId) {
            *DeviceIdLength = length;
            StringCbPrintf(*DeviceId,
                           length,
                           L"ISAPNP\\%s",
                           wReadDataPort
                           );
        } else {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        return STATUS_SUCCESS;
    }


    //
    // Set up device's id.
    // device id = VenderId + Logical device number
    //


    if (DeviceInfo->CardInformation->NumberLogicalDevices == 1) {
        format = L"ISAPNP\\%s";
        size = sizeof(L"ISAPNP\\*") + sizeof(WCHAR);
    } else {
        format = L"ISAPNP\\%s_DEV%04X";
        size = sizeof(L"ISAPNP\\_DEV") + 4 * sizeof(WCHAR) + sizeof(WCHAR);
    }
    PipDecompressEisaId(
          ((PSERIAL_IDENTIFIER) (DeviceInfo->CardInformation->CardData))->VenderId,
          eisaId
          );
    RtlInitUnicodeString(&unicodeString, eisaId);
    
    size += unicodeString.Length;
    *DeviceId = (PWCHAR)ExAllocatePool (PagedPool, size);
    if (*DeviceId) {

        *DeviceIdLength = size;
        StringCbPrintf(*DeviceId,
                       size,
                       format,
                       unicodeString.Buffer,
                       DeviceInfo->LogicalDeviceNumber
                       );
#if IDBG
        {
            ANSI_STRING dbgAnsiString;
            UNICODE_STRING dbgUnicodeString;

            RtlInitUnicodeString(&dbgUnicodeString, *DeviceId);
            if (NT_SUCCESS(RtlUnicodeStringToAnsiString(&dbgAnsiString, &dbgUnicodeString, TRUE))) {
                DbgPrint("PnpIsa: return device Id = %s\n", dbgAnsiString.Buffer);
                RtlFreeAnsiString(&dbgAnsiString);
            }   
        }
#endif
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}

NTSTATUS
PipQueryDeviceResources (
    PDEVICE_INFORMATION DeviceInfo,
    ULONG BusNumber,
    PCM_RESOURCE_LIST *CmResources,
    ULONG *Size
    )
/*++

Routine Description:

    This function returns the bus resources being used by the specified device

Arguments:

    DeviceInfo - Device information for the specificied slot

    BusNumber - should always be 0

    CmResources - supplies a pointer to a variable to receive the device resource
                  data.

    Size - Supplies a pointer to avariable to receive the size of device resource
           data.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG length;
    NTSTATUS status = STATUS_SUCCESS;
    PCM_RESOURCE_LIST cmResources;

    *CmResources = NULL;
    *Size = 0;

    if (DeviceInfo->BootResources){ // && DeviceInfo->LogConfHandle) {

        *CmResources = ExAllocatePool(PagedPool, DeviceInfo->BootResourcesLength);
        if (*CmResources) {
            RtlMoveMemory(*CmResources, DeviceInfo->BootResources, DeviceInfo->BootResourcesLength);
            *Size = DeviceInfo->BootResourcesLength;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return status;
}

NTSTATUS
PipQueryDeviceResourceRequirements (
    PDEVICE_INFORMATION DeviceInfo,
    ULONG BusNumber,
    ULONG Slot,
    PCM_RESOURCE_LIST BootResources,
    USHORT IrqFlags,
    PIO_RESOURCE_REQUIREMENTS_LIST *IoResources,
    ULONG *Size
    )

/*++

Routine Description:

    This function returns the possible bus resources that this device may be
    satisfied with.

Arguments:

    DeviceData - Device data information for the specificied slot

    BusNumber - Supplies the bus number

    Slot - supplies the slot number of the BusNumber

    IoResources - supplies a pointer to a variable to receive the IO resource
                  requirements list

Return Value:

    The device control is completed

--*/
{
    ULONG length = 0;
    NTSTATUS status;
    PUCHAR deviceData;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResources;

    deviceData = DeviceInfo->DeviceData;
    status = PpBiosResourcesToNtResources (
                   BusNumber,
                   Slot,
                   &deviceData,
                   0,
                   &ioResources,
                   &length
                   );

    //
    // Return results
    //

    if (NT_SUCCESS(status)) {
        if (length == 0) {
            ioResources = NULL;     // Just to make sure
        } else {
            
            // * Set the irq level/edge requirements to be consistent
            //   with the our determination earlier as to what is
            //   likely to work for this card
            //
            // * Make requirements reflect boot configed ROM if any.
            //   
            // Make these changes across all alternatives.
            PipTrimResourceRequirements(&ioResources,
                                        IrqFlags,
                                        BootResources);

            //PipFilterResourceRequirementsList(&ioResources);
            PipMergeBootResourcesToRequirementsList(DeviceInfo,
                                                    BootResources,
                                                    &ioResources
                                                    );
            ASSERT(ioResources);
            length = ioResources->ListSize;
        }
        *IoResources = ioResources;
        *Size = length;
#if IDBG
        PipDumpIoResourceList(ioResources);
#endif
    }
    return status;
}

NTSTATUS
PipSetDeviceResources (
    PDEVICE_INFORMATION DeviceInfo,
    PCM_RESOURCE_LIST CmResources
    )
/*++

Routine Description:

    This function configures the device to the specified device setttings

Arguments:

    DeviceInfo - Device information for the specificied slot

    CmResources - pointer to the desired resource list

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    if (CmResources && (CmResources->Count != 0)) {
        //
        // Set resource settings for the device
        //

        status = PipWriteDeviceResources (
                        DeviceInfo->DeviceData,
                        (PCM_RESOURCE_LIST) CmResources
                        );
        //
        // Put all cards into wait for key state.
        //

        DebugPrint((DEBUG_STATE,
                    "SetDeviceResources CSN %d/LDN %d\n",
                    DeviceInfo->CardInformation->CardSelectNumber,
                    DeviceInfo->LogicalDeviceNumber));

        //
        // Delay some time for the newly set resources to be avaiable.
        // This is required on some slow machines.
        //

        KeStallExecutionProcessor(10000);     // delay 10 ms

    }

    return status;
}


PIO_RESOURCE_REQUIREMENTS_LIST
PipCmResourcesToIoResources (
    IN PCM_RESOURCE_LIST CmResourceList
    )

/*++

Routine Description:

    This routines converts the input CmResourceList to IO_RESOURCE_REQUIREMENTS_LIST.

Arguments:

    CmResourceList - the cm resource list to convert.

Return Value:

    returns a IO_RESOURCE_REQUIREMENTS_LISTST if succeeds.  Otherwise a NULL value is
    returned.

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST ioResReqList;
    ULONG count = 0, size, i, j;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
    PIO_RESOURCE_DESCRIPTOR ioDesc;

    //
    // First determine number of descriptors required.
    //

    cmFullDesc = &CmResourceList->List[0];
    for (i = 0; i < CmResourceList->Count; i++) {
        count += cmFullDesc->PartialResourceList.Count;
        cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            size = 0;
            switch (cmPartDesc->Type) {
            case CmResourceTypeDeviceSpecific:
                 size = cmPartDesc->u.DeviceSpecificData.DataSize;
                 count--;
                 break;
            }
            cmPartDesc++;
            cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
    }

    if (count == 0) {
        return NULL;
    }

    //
    // Count the extra descriptors for InterfaceType and BusNumber information.
    //

    count += CmResourceList->Count - 1;

    //
    // Allocate heap space for IO RESOURCE REQUIREMENTS LIST
    //

    count++;           // add one for CmResourceTypeConfigData
    ioResReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)ExAllocatePool(
                       PagedPool,
                       sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
                           count * sizeof(IO_RESOURCE_DESCRIPTOR)
                       );
    if (!ioResReqList) {
        return NULL;
    }

    //
    // Parse the cm resource descriptor and build its corresponding IO resource descriptor
    //

    ioResReqList->InterfaceType = CmResourceList->List[0].InterfaceType;
    ioResReqList->BusNumber = CmResourceList->List[0].BusNumber;
    ioResReqList->SlotNumber = 0;
    ioResReqList->Reserved[0] = 0;
    ioResReqList->Reserved[1] = 0;
    ioResReqList->Reserved[2] = 0;
    ioResReqList->AlternativeLists = 1;
    ioResReqList->List[0].Version = 1;
    ioResReqList->List[0].Revision = 1;
    ioResReqList->List[0].Count = count;

    //
    // Generate a CmResourceTypeConfigData descriptor
    //

    ioDesc = &ioResReqList->List[0].Descriptors[0];
    ioDesc->Option = IO_RESOURCE_PREFERRED;
    ioDesc->Type = CmResourceTypeConfigData;
    ioDesc->ShareDisposition = CmResourceShareShared;
    ioDesc->Flags = 0;
    ioDesc->Spare1 = 0;
    ioDesc->Spare2 = 0;
    ioDesc->u.ConfigData.Priority = BOOT_CONFIG_PRIORITY;
    ioDesc++;

    cmFullDesc = &CmResourceList->List[0];
    for (i = 0; i < CmResourceList->Count; i++) {
        cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            ioDesc->Option = IO_RESOURCE_PREFERRED;
            ioDesc->Type = cmPartDesc->Type;
            ioDesc->ShareDisposition = cmPartDesc->ShareDisposition;
            ioDesc->Flags = cmPartDesc->Flags;
            ioDesc->Spare1 = 0;
            ioDesc->Spare2 = 0;

            size = 0;
            switch (cmPartDesc->Type) {
            case CmResourceTypePort:
                 ioDesc->u.Port.MinimumAddress = cmPartDesc->u.Port.Start;
                 ioDesc->u.Port.MaximumAddress.QuadPart = cmPartDesc->u.Port.Start.QuadPart +
                                                             cmPartDesc->u.Port.Length - 1;
                 ioDesc->u.Port.Alignment = 1;
                 ioDesc->u.Port.Length = cmPartDesc->u.Port.Length;
                 ioDesc++;
                 break;
            case CmResourceTypeInterrupt:
#if defined(_X86_)
                ioDesc->u.Interrupt.MinimumVector = ioDesc->u.Interrupt.MaximumVector =
                   cmPartDesc->u.Interrupt.Level;
#else
                 ioDesc->u.Interrupt.MinimumVector = ioDesc->u.Interrupt.MaximumVector =
                    cmPartDesc->u.Interrupt.Vector;
#endif
                 ioDesc++;
                 break;
            case CmResourceTypeMemory:
                 ioDesc->u.Memory.MinimumAddress = cmPartDesc->u.Memory.Start;
                 ioDesc->u.Memory.MaximumAddress.QuadPart = cmPartDesc->u.Memory.Start.QuadPart +
                                                               cmPartDesc->u.Memory.Length - 1;
                 ioDesc->u.Memory.Alignment = 1;
                 ioDesc->u.Memory.Length = cmPartDesc->u.Memory.Length;
                 ioDesc++;
                 break;
            case CmResourceTypeDma:
                 ioDesc->u.Dma.MinimumChannel = cmPartDesc->u.Dma.Channel;
                 ioDesc->u.Dma.MaximumChannel = cmPartDesc->u.Dma.Channel;
                 ioDesc++;
                 break;
            case CmResourceTypeDeviceSpecific:
                 size = cmPartDesc->u.DeviceSpecificData.DataSize;
                 break;
            case CmResourceTypeBusNumber:
                 ioDesc->u.BusNumber.MinBusNumber = cmPartDesc->u.BusNumber.Start;
                 ioDesc->u.BusNumber.MaxBusNumber = cmPartDesc->u.BusNumber.Start +
                                                    cmPartDesc->u.BusNumber.Length - 1;
                 ioDesc->u.BusNumber.Length = cmPartDesc->u.BusNumber.Length;
                 ioDesc++;
                 break;
            default:
                 ioDesc->u.DevicePrivate.Data[0] = cmPartDesc->u.DevicePrivate.Data[0];
                 ioDesc->u.DevicePrivate.Data[1] = cmPartDesc->u.DevicePrivate.Data[1];
                 ioDesc->u.DevicePrivate.Data[2] = cmPartDesc->u.DevicePrivate.Data[2];
                 ioDesc++;
                 break;
            }
            cmPartDesc++;
            cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
    }
    ioResReqList->ListSize = (ULONG)((ULONG_PTR)ioDesc - (ULONG_PTR)ioResReqList);
    return ioResReqList;
}

NTSTATUS
PipMergeResourceRequirementsLists (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList1,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList2,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *MergedList
    )

/*++

Routine Description:

    This routines merges two IoLists into one.


Arguments:

    IoList1 - supplies the pointer to the first IoResourceRequirementsList

    IoList2 - supplies the pointer to the second IoResourceRequirementsList

    MergedList - Supplies a variable to receive the merged resource
             requirements list.

Return Value:

    A NTSTATUS code to indicate the result of the function.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_RESOURCE_REQUIREMENTS_LIST ioList, newList;
    ULONG size;
    PUCHAR p;

    PAGED_CODE();

    *MergedList = NULL;

    //
    // First handle the easy cases that both IO Lists are empty or any one of
    // them is empty.
    //

    if ((IoList1 == NULL || IoList1->AlternativeLists == 0) &&
        (IoList2 == NULL || IoList2->AlternativeLists == 0)) {
        return status;
    }
    ioList = NULL;
    if (IoList1 == NULL || IoList1->AlternativeLists == 0) {
        ioList = IoList2;
    } else if (IoList2 == NULL || IoList2->AlternativeLists == 0) {
        ioList = IoList1;
    }
    if (ioList) {
        newList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, ioList->ListSize);
        if (newList == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlMoveMemory(newList, ioList, ioList->ListSize);
        *MergedList = newList;
        return status;
    }

    //
    // Do real work...
    //

    size = IoList1->ListSize + IoList2->ListSize - FIELD_OFFSET(IO_RESOURCE_REQUIREMENTS_LIST, List);
    newList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(
                          PagedPool,
                          size
                          );
    if (newList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    p = (PUCHAR)newList;
    RtlMoveMemory(p, IoList1, IoList1->ListSize);
    p += IoList1->ListSize;
    RtlMoveMemory(p,
                  &IoList2->List[0],
                  size - IoList1->ListSize
                  );
    newList->ListSize = size;
    newList->AlternativeLists += IoList2->AlternativeLists;
    *MergedList = newList;
    return status;
}

VOID
PipMergeBootResourcesToRequirementsList(
    PDEVICE_INFORMATION DeviceInfo,
    PCM_RESOURCE_LIST BootResources,
    PIO_RESOURCE_REQUIREMENTS_LIST *IoResources
    )

/*++

Routine Description:

    This routines merges two IoLists into one.


Arguments:

    IoList1 - supplies the pointer to the first IoResourceRequirementsList

    IoList2 - supplies the pointer to the second IoResourceRequirementsList

    MergedList - Supplies a variable to receive the merged resource
             requirements list.

Return Value:

    A NTSTATUS code to indicate the result of the function.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResources = *IoResources, bootResReq = NULL, newList = NULL;
    BOOLEAN exactMatch;

    PAGED_CODE();

    if (DeviceInfo->BootResources) {
        PipBuildBootResourceRequirementsList (ioResources, BootResources, &bootResReq, &exactMatch);
        if (bootResReq) {
            if (exactMatch && ioResources->AlternativeLists == 1) {
                ExFreePool(ioResources);
                *IoResources = bootResReq;
            } else {
                PipMergeResourceRequirementsLists (bootResReq, ioResources, &newList);
                if (newList) {
                    ExFreePool(ioResources);
                    *IoResources = newList;
                }
                ExFreePool(bootResReq);
            }
        }
    }
}

NTSTATUS
PipBuildBootResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList,
    IN PCM_RESOURCE_LIST CmList,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *FilteredList,
    OUT PBOOLEAN ExactMatch
    )

/*++

Routine Description:

    This routines adjusts the input IoList based on input BootConfig.


Arguments:

    IoList - supplies the pointer to an IoResourceRequirementsList

    CmList - supplies the pointer to a BootConfig.

    FilteredList - Supplies a variable to receive the filtered resource
             requirements list.

Return Value:

    A NTSTATUS code to indicate the result of the function.

--*/
{
    NTSTATUS status;
    PIO_RESOURCE_REQUIREMENTS_LIST ioList, newList;
    PIO_RESOURCE_LIST ioResourceList, newIoResourceList;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor, ioResourceDescriptorEnd;
    PIO_RESOURCE_DESCRIPTOR newIoResourceDescriptor, configDataDescriptor;
    LONG ioResourceDescriptorCount = 0;
    USHORT version;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDescriptor;
    ULONG cmDescriptorCount = 0;
    ULONG size, i, j, oldCount, phase;
    LONG k, alternativeLists;
    BOOLEAN exactMatch;

    PAGED_CODE();

    *FilteredList = NULL;
    *ExactMatch = FALSE;

    //
    // Make sure there is some resource requirements to be filtered.
    // If no, we will convert CmList/BootConfig to an IoResourceRequirementsList
    //

    if (IoList == NULL || IoList->AlternativeLists == 0) {
        if (CmList && CmList->Count != 0) {
            *FilteredList = PipCmResourcesToIoResources (CmList);
        }
        return STATUS_SUCCESS;
    }

    //
    // Make a copy of the Io Resource Requirements List
    //

    ioList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, IoList->ListSize);
    if (ioList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlMoveMemory(ioList, IoList, IoList->ListSize);

    //
    // If there is no BootConfig, simply return the copy of the input Io list.
    //

    if (CmList == NULL || CmList->Count == 0) {
        *FilteredList = ioList;
        return STATUS_SUCCESS;
    }

    //
    // First determine minimum number of descriptors required.
    //

    cmFullDesc = &CmList->List[0];
    for (i = 0; i < CmList->Count; i++) {
        cmDescriptorCount += cmFullDesc->PartialResourceList.Count;
        cmDescriptor = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            size = 0;
            switch (cmDescriptor->Type) {
            case CmResourceTypeConfigData:
            case CmResourceTypeDevicePrivate:
                 cmDescriptorCount--;
                 break;
            case CmResourceTypeDeviceSpecific:
                 size = cmDescriptor->u.DeviceSpecificData.DataSize;
                 cmDescriptorCount--;
                 break;
            default:

                 //
                 // Invalid cmresource list.  Ignore it and use io resources
                 //

                 if (cmDescriptor->Type == CmResourceTypeNull ||
                     cmDescriptor->Type >= CmResourceTypeMaximum) {
                     cmDescriptorCount--;
                 }
            }
            cmDescriptor++;
            cmDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDescriptor + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDescriptor;
    }

    if (cmDescriptorCount == 0) {
        *FilteredList = ioList;
        return STATUS_SUCCESS;
    }

    //
    // cmDescriptorCount is the number of BootConfig Descriptors needs.
    //
    // For each IO list Alternative ...
    //

    ioResourceList = ioList->List;
    k = ioList->AlternativeLists;
    while (--k >= 0) {
        ioResourceDescriptor = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;
        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
            ioResourceDescriptor->Spare1 = 0;
            ioResourceDescriptor++;
        }
        ioResourceList = (PIO_RESOURCE_LIST) ioResourceDescriptorEnd;
    }

    ioResourceList = ioList->List;
    k = alternativeLists = ioList->AlternativeLists;
    while (--k >= 0) {
        version = ioResourceList->Version;
        if (version == 0xffff) {  // Convert bogus version to valid number
            version = 1;
        }

        //
        // We use Version field to store number of BootConfig found.
        // Count field to store new number of descriptor in the alternative list.
        //

        ioResourceList->Version = 0;
        oldCount = ioResourceList->Count;

        ioResourceDescriptor = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;

        if (ioResourceDescriptor == ioResourceDescriptorEnd) {

            //
            // An alternative list with zero descriptor count
            //

            ioResourceList->Version = 0xffff;  // Mark it as invalid
            ioList->AlternativeLists--;
            continue;
        }

        exactMatch = TRUE;

        //
        // For each Cm Resource descriptor ... except DevicePrivate and
        // DeviceSpecific...
        //

        cmFullDesc = &CmList->List[0];
        for (i = 0; i < CmList->Count; i++) {
            cmDescriptor = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
            for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
                size = 0;
                switch (cmDescriptor->Type) {
                case CmResourceTypeDevicePrivate:
                     break;
                case CmResourceTypeDeviceSpecific:
                     size = cmDescriptor->u.DeviceSpecificData.DataSize;
                     break;
                default:
                    if (cmDescriptor->Type == CmResourceTypeNull ||
                        cmDescriptor->Type >= CmResourceTypeMaximum) {
                        break;
                    }

                    //
                    // Check CmDescriptor against current Io Alternative list
                    //

                    for (phase = 0; phase < 2; phase++) {
                        ioResourceDescriptor = ioResourceList->Descriptors;
                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
                            if ((ioResourceDescriptor->Type == cmDescriptor->Type) &&
                                (ioResourceDescriptor->Spare1 == 0)) {
                                ULONGLONG min1, max1, min2, max2;
                                ULONG len1 = 1, len2 = 1, align1, align2;
                                UCHAR share1, share2;

                                share2 = ioResourceDescriptor->ShareDisposition;
                                share1 = cmDescriptor->ShareDisposition;
                                if ((share1 == CmResourceShareUndetermined) ||
                                    (share1 > CmResourceShareShared)) {
                                    share1 = share2;
                                }
                                if ((share2 == CmResourceShareUndetermined) ||
                                    (share2 > CmResourceShareShared)) {
                                    share2 = share1;
                                }
                                align1 = align2 = 1;

                                switch (cmDescriptor->Type) {
                                case CmResourceTypePort:
                                case CmResourceTypeMemory:
                                    min1 = cmDescriptor->u.Port.Start.QuadPart;
                                    max1 = cmDescriptor->u.Port.Start.QuadPart + cmDescriptor->u.Port.Length - 1;
                                    len1 = cmDescriptor->u.Port.Length;
                                    min2 = ioResourceDescriptor->u.Port.MinimumAddress.QuadPart;
                                    max2 = ioResourceDescriptor->u.Port.MaximumAddress.QuadPart;
                                    len2 = ioResourceDescriptor->u.Port.Length;
                                    align2 = ioResourceDescriptor->u.Port.Alignment;
                                    break;
                                case CmResourceTypeInterrupt:
                                    max1 = min1 = cmDescriptor->u.Interrupt.Vector;
                                    min2 = ioResourceDescriptor->u.Interrupt.MinimumVector;
                                    max2 = ioResourceDescriptor->u.Interrupt.MaximumVector;
                                    break;
                                case CmResourceTypeDma:
                                    min1 = max1 =cmDescriptor->u.Dma.Channel;
                                    min2 = ioResourceDescriptor->u.Dma.MinimumChannel;
                                    max2 = ioResourceDescriptor->u.Dma.MaximumChannel;
                                    break;
                                case CmResourceTypeBusNumber:
                                    min1 = cmDescriptor->u.BusNumber.Start;
                                    max1 = cmDescriptor->u.BusNumber.Start + cmDescriptor->u.BusNumber.Length - 1;
                                    len1 = cmDescriptor->u.BusNumber.Length;
                                    min2 = ioResourceDescriptor->u.BusNumber.MinBusNumber;
                                    max2 = ioResourceDescriptor->u.BusNumber.MaxBusNumber;
                                    len2 = ioResourceDescriptor->u.BusNumber.Length;
                                    break;
                                default:
                                    ASSERT(0);
                                    break;
                                }
                                if (phase == 0) {
                                    if (share1 == share2 && min2 == min1 && max2 >= max1 && len2 >= len1) {

                                        //
                                        // For phase 0 match, we want near exact match...
                                        //

                                        if (max2 != max1) {
                                            exactMatch = FALSE;
                                        }

                                        ioResourceList->Version++;
                                        ioResourceDescriptor->Spare1 = 0x80;
                                        if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                            PIO_RESOURCE_DESCRIPTOR ioDesc;

                                            ioDesc = ioResourceDescriptor;
                                            ioDesc--;
                                            while (ioDesc >= ioResourceList->Descriptors) {
                                                ioDesc->Type = CmResourceTypeNull;
                                                ioResourceList->Count--;
                                                if (ioDesc->Option == IO_RESOURCE_ALTERNATIVE) {
                                                    ioDesc--;
                                                } else {
                                                    break;
                                                }
                                            }
                                        }
                                        ioResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
                                        if (ioResourceDescriptor->Type == CmResourceTypePort ||
                                            ioResourceDescriptor->Type == CmResourceTypeMemory) {
                                            ioResourceDescriptor->u.Port.MinimumAddress.QuadPart = min1;
                                            ioResourceDescriptor->u.Port.MaximumAddress.QuadPart = min1 + len2 - 1;
                                            ioResourceDescriptor->u.Port.Alignment = 1;
                                        } else if (ioResourceDescriptor->Type == CmResourceTypeBusNumber) {
                                            ioResourceDescriptor->u.BusNumber.MinBusNumber = (ULONG)min1;
                                            ioResourceDescriptor->u.BusNumber.MaxBusNumber = (ULONG)(min1 + len2 - 1);
                                        }
                                        ioResourceDescriptor++;
                                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
                                            if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                                ioResourceDescriptor->Type = CmResourceTypeNull;
                                                ioResourceDescriptor++;
                                                ioResourceList->Count--;
                                            } else {
                                                break;
                                            }
                                        }
                                        phase = 1;   // skip phase 1
                                        break;
                                    } else {
                                        ioResourceDescriptor++;
                                    }
                                } else {
                                    exactMatch = FALSE;
                                    if (share1 == share2 && min2 <= min1 && max2 >= max1 && len2 >= len1 &&
                                        (min1 & (align2 - 1)) == 0) {

                                        //
                                        // Io range covers Cm range ... Change the Io range to what is specified
                                        // in BootConfig.
                                        //
                                        //

                                        switch (cmDescriptor->Type) {
                                        case CmResourceTypePort:
                                        case CmResourceTypeMemory:
                                            ioResourceDescriptor->u.Port.MinimumAddress.QuadPart = min1;
                                            ioResourceDescriptor->u.Port.MaximumAddress.QuadPart = min1 + len2 - 1;
                                            break;
                                        case CmResourceTypeInterrupt:
                                        case CmResourceTypeDma:
                                            ioResourceDescriptor->u.Interrupt.MinimumVector = (ULONG)min1;
                                            ioResourceDescriptor->u.Interrupt.MaximumVector = (ULONG)max1;
                                            break;
                                        case CmResourceTypeBusNumber:
                                            ioResourceDescriptor->u.BusNumber.MinBusNumber = (ULONG)min1;
                                            ioResourceDescriptor->u.BusNumber.MaxBusNumber = (ULONG)(min1 + len2 - 1);
                                            break;
                                        }
                                        ioResourceList->Version++;
                                        ioResourceDescriptor->Spare1 = 0x80;
                                        if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                            PIO_RESOURCE_DESCRIPTOR ioDesc;

                                            ioDesc = ioResourceDescriptor;
                                            ioDesc--;
                                            while (ioDesc >= ioResourceList->Descriptors) {
                                                ioDesc->Type = CmResourceTypeNull;
                                                ioResourceList->Count--;
                                                if (ioDesc->Option == IO_RESOURCE_ALTERNATIVE) {
                                                    ioDesc--;
                                                } else {
                                                    break;
                                                }
                                            }
                                        }
                                        ioResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
                                        ioResourceDescriptor++;
                                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
                                            if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                                ioResourceDescriptor->Type = CmResourceTypeNull;
                                                ioResourceList->Count--;
                                                ioResourceDescriptor++;
                                            } else {
                                                break;
                                            }
                                        }
                                        break;
                                    } else {
                                        ioResourceDescriptor++;
                                    }
                                }
                            } else {
                                ioResourceDescriptor++;
                            }
                        } // Don't add any instruction after this ...
                    } // phase
                } // switch

                //
                // Move to next Cm Descriptor
                //

                cmDescriptor++;
                cmDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDescriptor + size);
            }

            //
            // Move to next Cm List
            //

            cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDescriptor;
        }

        if (ioResourceList->Version != (USHORT)cmDescriptorCount) {

            //
            // If the current alternative list does not cover all the boot config
            // descriptors, make it as invalid.
            //

            ioResourceList->Version = 0xffff;
            ioList->AlternativeLists--;
        } else {
            ioResourceDescriptorCount += ioResourceList->Count;
            ioResourceList->Version = version;
            ioResourceList->Count = oldCount; // ++ single alternative list
            break;   // ++  single alternative list
        }
        ioResourceList->Count = oldCount;

        //
        // Move to next Io alternative list.
        //

        ioResourceList = (PIO_RESOURCE_LIST) ioResourceDescriptorEnd;
    }

    //
    // If there is not any valid alternative, convert CmList to Io list.
    //

    if (ioList->AlternativeLists == 0) {
         *FilteredList = PipCmResourcesToIoResources (CmList);
        ExFreePool(ioList);
        return STATUS_SUCCESS;
    }

    //
    // we have finished filtering the resource requirements list.  Now allocate memory
    // and rebuild a new list.
    //

    size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
               //sizeof(IO_RESOURCE_LIST) * (ioList->AlternativeLists - 1) +    // ++ Single Alternative list
               sizeof(IO_RESOURCE_DESCRIPTOR) * (ioResourceDescriptorCount);
    newList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, size);
    if (newList == NULL) {
        ExFreePool(ioList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Walk through the io resource requirements list and pick up any valid descriptor.
    //

    newList->ListSize = size;
    newList->InterfaceType = CmList->List->InterfaceType;
    newList->BusNumber = CmList->List->BusNumber;
    newList->SlotNumber = ioList->SlotNumber;
    newList->AlternativeLists = 1;

    ioResourceList = ioList->List;
    newIoResourceList = newList->List;
    while (--alternativeLists >= 0) {
        ioResourceDescriptor = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;
        if (ioResourceList->Version == 0xffff) {
            ioResourceList = (PIO_RESOURCE_LIST)ioResourceDescriptorEnd;
            continue;
        }
        newIoResourceList->Version = ioResourceList->Version;
        newIoResourceList->Revision = ioResourceList->Revision;

        newIoResourceDescriptor = newIoResourceList->Descriptors;
        if (ioResourceDescriptor->Type != CmResourceTypeConfigData) {
            newIoResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
            newIoResourceDescriptor->Type = CmResourceTypeConfigData;
            newIoResourceDescriptor->ShareDisposition = CmResourceShareShared;
            newIoResourceDescriptor->Flags = 0;
            newIoResourceDescriptor->Spare1 = 0;
            newIoResourceDescriptor->Spare2 = 0;
            newIoResourceDescriptor->u.ConfigData.Priority = BOOT_CONFIG_PRIORITY;
            configDataDescriptor = newIoResourceDescriptor;
            newIoResourceDescriptor++;
        } else {
            newList->ListSize -= sizeof(IO_RESOURCE_DESCRIPTOR);
            configDataDescriptor = newIoResourceDescriptor;
        }

        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
            if (ioResourceDescriptor->Type != CmResourceTypeNull) {
                *newIoResourceDescriptor = *ioResourceDescriptor;
                newIoResourceDescriptor++;
            }
            ioResourceDescriptor++;
        }
        newIoResourceList->Count = (ULONG)(newIoResourceDescriptor - newIoResourceList->Descriptors);
        configDataDescriptor->u.ConfigData.Priority =  BOOT_CONFIG_PRIORITY;

        break;
    }
    ASSERT((PUCHAR)newIoResourceDescriptor == ((PUCHAR)newList + newList->ListSize));

    *FilteredList = newList;
    *ExactMatch = exactMatch;
    ExFreePool(ioList);
    return STATUS_SUCCESS;
}


PCM_PARTIAL_RESOURCE_DESCRIPTOR
PipFindMatchingBootMemResource(
    IN ULONG Index,
    IN PIO_RESOURCE_DESCRIPTOR IoDesc,
    IN PCM_RESOURCE_LIST BootResources
    )
/*++

Routine Description:

    This routine finds boot resources that match the i/o descriptor


Arguments:

    Index - Index of memory boot config resource the caller is interested in.

    IoDesc - I/O descriptor

    BootResources - boot config

Return Value:

    A pointer to a matching descriptor in the boot config

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
    ULONG count = 0, size, i, j, noMem;
    
    if (BootResources == NULL) {
        return NULL;
    }

    cmFullDesc = &BootResources->List[0];
    for (i = 0; i < BootResources->Count; i++) {
        cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        noMem = 0;
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            size = 0;
            if (cmPartDesc->Type == CmResourceTypeMemory) {
                if (((cmPartDesc->u.Memory.Start.QuadPart >=
                     IoDesc->u.Memory.MinimumAddress.QuadPart) &&
                    ((cmPartDesc->u.Memory.Start.QuadPart +
                      cmPartDesc->u.Memory.Length - 1) <=
                     IoDesc->u.Memory.MaximumAddress.QuadPart)) &&
                    noMem == Index) {
                    return cmPartDesc;
                }
                noMem++;
            } else if (cmPartDesc->Type == CmResourceTypeDeviceSpecific) {
                    size = cmPartDesc->u.DeviceSpecificData.DataSize;
            }
            cmPartDesc++;
            cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
    }
    return NULL;
}

NTSTATUS
PipTrimResourceRequirements (
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *IoList,
    IN USHORT IrqFlags,
    IN PCM_RESOURCE_LIST BootResources
    )
/*++

Routine Description:

    This routine:
       * adjusts the irq requirements level/edge to the value
       decided on in PipCheckBus()

       * adjusts the memory requirements to reflect the memory boot
         config.

Arguments:

    IoList - supplies the pointer to an IoResourceRequirementsList

    IrqFlags - level/edge irq reuirements to be applied to all interrupt requirements in all alternatives.

    BootResources - Used as a reference.

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST newReqList;
    PIO_RESOURCE_LIST resList, newList;
    PIO_RESOURCE_DESCRIPTOR resDesc, newDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR bootDesc;
    ULONG listCount, i, j, pass, size, noMem;
    BOOLEAN goodAlt;

    if (IoList == NULL) {
        return STATUS_SUCCESS;
    }

    // The only way to create a new req list only if absolutely
    // necessary and make it the perfect size is perform this
    // operation in two passes.
    // 1. figure out how many alternatives will be eliminated and
    //    compute size of new req list.  if all of the alternatives
    //    survived, return the original list (now modified)
    //
    // 2. construct new reqlist minus the bad alternatives.

    listCount = 0;
    size = 0;
    for (pass = 0; pass < 2; pass++) {
        if (pass == 0) {
            size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) -
                sizeof(IO_RESOURCE_LIST);
        } else {
            newReqList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, size);
            if (newReqList == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
             }
            *newReqList = **IoList;
            newReqList->ListSize = size;
            newReqList->AlternativeLists = listCount;
            newList = &newReqList->List[0];
        }

        resList = &(*IoList)->List[0];

        for (i = 0; i < (*IoList)->AlternativeLists; i++) {
            if (pass == 1) {

                *newList = *resList;
                newDesc = &newList->Descriptors[0];
            }
            resDesc = &resList->Descriptors[0];
            goodAlt = TRUE;
            noMem = 0;
            for (j = 0; j < resList->Count; j++) {
                if (resDesc->Type == CmResourceTypeInterrupt) {
                    resDesc->Flags = IrqFlags;

                    if (resDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
                        resDesc->ShareDisposition = CmResourceShareDeviceExclusive;
                    }
                } else if (resDesc->Type == CmResourceTypeMemory) {
                    resDesc->Flags |= CM_RESOURCE_MEMORY_24;

                    if (BootResources) {
                        bootDesc = PipFindMatchingBootMemResource(noMem, resDesc, BootResources);
                        // have matching boot config resource, can trim requirements
                        if (bootDesc) {
                            if (bootDesc->Flags & CM_RESOURCE_MEMORY_READ_ONLY) {
                                // exact or inclusive ROM match is
                                // converted into a fixed requirement.
                                resDesc->u.Memory.MinimumAddress.QuadPart =
                                    bootDesc->u.Memory.Start.QuadPart;
                                if (bootDesc->u.Memory.Length) {
                                    resDesc->u.Memory.MaximumAddress.QuadPart =
                                        bootDesc->u.Memory.Start.QuadPart +
                                        bootDesc->u.Memory.Length - 1;
                                } else {
                                    resDesc->u.Memory.MaximumAddress.QuadPart =
                                        bootDesc->u.Memory.Start.QuadPart;
                                }
                                resDesc->u.Memory.Length = bootDesc->u.Memory.Length;
                                resDesc->u.Memory.Alignment = 1;
                                resDesc->Flags |= CM_RESOURCE_MEMORY_READ_ONLY;
                            }
                        } else {
                            goodAlt = FALSE;
                        }
                    } else {
                        resDesc->Flags &= ~CM_RESOURCE_MEMORY_READ_ONLY;
                    }
                    noMem++;
                }
                if (pass == 1) {
                    *newDesc = *resDesc;
                    PipDumpIoResourceDescriptor("  ", newDesc);
                    newDesc++;
                }

                resDesc++;
            }

            if (pass == 0) {
                if (goodAlt) {
                    size += sizeof(IO_RESOURCE_LIST) + 
                        sizeof(IO_RESOURCE_DESCRIPTOR) * (resList->Count - 1);
                    listCount++;
                }
            } else {
                if (goodAlt) {
                    newList = (PIO_RESOURCE_LIST) newDesc;
                } else {
                    DebugPrint((DEBUG_RESOURCE, "An alternative trimmed off of reqlist\n"));
                }
            }

            resList = (PIO_RESOURCE_LIST) resDesc;
        }

        // If we have the same number of alternatives as before use
        // the use existing (modified in-place) requirements list
        if (!pass && (listCount == (*IoList)->AlternativeLists)) {
            return STATUS_SUCCESS;
        }
 
        // if all alternatives have been eliminated, then it is better
        // to use the existing requirements list than to hope to build
        // one out of the boot config alone.
        if (!pass && (listCount == 0)) {
            DebugPrint((DEBUG_RESOURCE, "All alternatives trimmed off of reqlist, going with original\n"));
            return STATUS_SUCCESS;
        }
    }

    ExFreePool(*IoList);
    *IoList = newReqList;

    return STATUS_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\pbios.h ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    pbiosp.h

Abstract:

    PnP BIOS/ISA configuration data definitions

Author:

    Shie-Lin Tzong (shielint) April 12, 1995

Revision History:

--*/

//#include "nthal.h"
//#include "hal.h"

//
// Constants
//

#define SMALL_RESOURCE_TAG          (UCHAR)(0x00)
#define LARGE_RESOURCE_TAG          (UCHAR)(0x80)
#define SMALL_TAG_MASK              0xf8
#define SMALL_TAG_SIZE_MASK         7

//
// Small Resouce Tags with length bits stripped off
//

#define TAG_VERSION                 0x08
#define TAG_LOGICAL_ID              0x10
#define TAG_COMPATIBLE_ID           0x18
#define TAG_IRQ                     0x20
#define TAG_DMA                     0x28
#define TAG_START_DEPEND            0x30
#define TAG_END_DEPEND              0x38
#define TAG_IO                      0x40
#define TAG_IO_FIXED                0x48
#define TAG_VENDOR                  0x70
#define TAG_END                     0x78

//
// Large Resouce Tags
//

#define TAG_MEMORY                  0x81
#define TAG_ANSI_ID                 0x82
#define TAG_UNICODE_ID              0x83
#define TAG_LVENDOR                 0x84
#define TAG_MEMORY32                0x85
#define TAG_MEMORY32_FIXED          0x86

//
// Complete TAG if applicable.
//

#define TAG_COMPLETE_COMPATIBLE_ID  0x1C
#define TAG_COMPLETE_END            0x79

#include "pshpack1.h"

//
// PNP ISA Port descriptor definition
//

typedef struct _PNP_PORT_DESCRIPTOR_ {
    UCHAR   Tag;                    // 01000111B, small item name = 08, length = 7
    UCHAR   Information;            // bit [0] = 1 device decodes full 16 bit addr
                                    //         = 0 device decodes ISA addr bits[9-0]
    USHORT  MinimumAddress;
    USHORT  MaximumAddress;
    UCHAR   Alignment;              // Increment in 1 byte blocks
    UCHAR   Length;                 // # contiguous Port requested
} PNP_PORT_DESCRIPTOR, *PPNP_PORT_DESCRIPTOR;

//
// PNP ISA fixed Port descriptor definition
//

typedef struct _PNP_FIXED_PORT_DESCRIPTOR_ {
    UCHAR   Tag;                    // 01001011B, small item name = 09, length = 3
    USHORT  MinimumAddress;
    UCHAR   Length;                 // # contiguous Port requested
} PNP_FIXED_PORT_DESCRIPTOR, *PPNP_FIXED_PORT_DESCRIPTOR;

//
// PNP ISA IRQ descriptor definition
//

typedef struct _PNP_IRQ_DESCRIPTOR_ {
    UCHAR   Tag;                    // 0010001XB small item name = 4 length = 2/3
    USHORT  IrqMask;                // bit 0 is irq 0
    UCHAR   Information;            // Optional
} PNP_IRQ_DESCRIPTOR, *PPNP_IRQ_DESCRIPTOR;

//
// Masks for PNP_IRQ_DESCRIPTOR Information byte
//

#define PNP_IRQ_LEVEL_MASK          0xC
#define PNP_IRQ_EDGE_MASK           0x3

//
// PNP ISA DMA descriptor definition
//

typedef struct _PNP_DMA_DESCRIPTOR_ {
    UCHAR   Tag;                    // 00101010B, small item name = 05, length = 2
    UCHAR   ChannelMask;            // bit 0 is channel 0
    UCHAR   Flags;                  // see spec
} PNP_DMA_DESCRIPTOR, *PPNP_DMA_DESCRIPTOR;

//
// PNP ISA MEMORY descriptor
//

typedef struct _PNP_MEMORY_DESCRIPTOR_ {
    UCHAR   Tag;                    // 10000001B, Large item name = 1
    USHORT  Length;                 // Length of the descriptor = 9
    UCHAR   Information;            // See def below
    USHORT  MinimumAddress;         // address bit [8-23]
    USHORT  MaximumAddress;         // address bit [8-23]
    USHORT  Alignment;              // 0x0000 = 64KB
    USHORT  MemorySize;             // In 256 byte blocks
} PNP_MEMORY_DESCRIPTOR, *PPNP_MEMORY_DESCRIPTOR;

//
// PNP ISA MEMORY32 descriptor
//

typedef struct _PNP_MEMORY32_DESCRIPTOR_ {
    UCHAR   Tag;                    // 10000101B, Large item name = 5
    USHORT  Length;                 // Length of the descriptor = 17
    UCHAR   Information;            // See def below
    ULONG   MinimumAddress;         // 32 bit addr
    ULONG   MaximumAddress;         // 32 bit addr
    ULONG   Alignment;              // 32 bit alignment
    ULONG   MemorySize;             // 32 bit length
} PNP_MEMORY32_DESCRIPTOR, *PPNP_MEMORY32_DESCRIPTOR;

//
// PNP ISA FIXED MEMORY32 descriptor
//

typedef struct _PNP_FIXED_MEMORY32_DESCRIPTOR_ {
    UCHAR   Tag;                    // 10000110B, Large item name = 6
    USHORT  Length;                 // Length of the descriptor = 9
    UCHAR   Information;            // See def below
    ULONG   BaseAddress;            // 32 bit addr
    ULONG   MemorySize;             // 32 bit length
} PNP_FIXED_MEMORY32_DESCRIPTOR, *PPNP_FIXED_MEMORY32_DESCRIPTOR;

#define PNP_MEMORY_ROM_MASK            0x40
#define PNP_MEMORY_SHADOWABLE_MASK     0x20
#define PNP_MEMORY_CONTROL_MASK        0x18
    #define PNP_MEMORY_CONTROL_8BIT       00
    #define PNP_MEMORY_CONTROL_16BIT      01
    #define PNP_MEMORY_CONTROL_8AND16BIT  02
    #define PNP_MEMORY_CONTROL_32BIT      03
#define PNP_MEMORY_SUPPORT_TYPE_MASK   04
#define PNP_MEMORY_CACHE_SUPPORT_MASK  02
#define PNP_MEMORY_WRITE_STATUS_MASK   01

#define UNKNOWN_DOCKING_IDENTIFIER     0xffffffff
#define UNABLE_TO_DETERMINE_DOCK_CAPABILITIES 0x89
#define FUNCTION_NOT_SUPPORTED         0x82
#define SYSTEM_NOT_DOCKED              0x87

//
// Pnp BIOS device node structure
//

typedef struct _PNP_BIOS_DEVICE_NODE {
    USHORT  Size;
    UCHAR   Node;
    ULONG   ProductId;
    UCHAR   DeviceType[3];
    USHORT  DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} PNP_BIOS_DEVICE_NODE, *PPNP_BIOS_DEVICE_NODE;

//
// DeviceType definition
//

#define BASE_TYPE_DOCKING_STATION      0xA

//
// Device attributes definitions
//

#define DEVICE_DOCKING                 0x20
#define DEVICE_REMOVABLE               0x40

//
// Pnp BIOS Installation check
//

typedef struct _PNP_BIOS_INSTALLATION_CHECK {
    UCHAR   Signature[4];              // $PnP (ascii)
    UCHAR   Revision;
    UCHAR   Length;
    USHORT  ControlField;
    UCHAR   Checksum;
    ULONG   EventFlagAddress;          // Physical address
    USHORT  RealModeEntryOffset;
    USHORT  RealModeEntrySegment;
    USHORT  ProtectedModeEntryOffset;
    ULONG   ProtectedModeCodeBaseAddress;
    ULONG   OemDeviceId;
    USHORT  RealModeDataBaseAddress;
    ULONG  ProtectedModeDataBaseAddress;
} PNP_BIOS_INSTALLATION_CHECK, *PPNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Pnp BIOS ControlField masks
//

#define PNP_BIOS_CONTROL_MASK          0x3
#define PNP_BIOS_EVENT_NOT_SUPPORTED   0
#define PNP_BIOS_EVENT_POLLING         1
#define PNP_BIOS_EVENT_ASYNC           2

//
// Pnp Bios event
//

#define ABOUT_TO_CHANGE_CONFIG         1
#define DOCK_CHANGED                   2
#define SYSTEM_DEVICE_CHANGED          3
#define CONFIG_CHANGE_FAILED           4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\power.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    power.c

Abstract:

    This file contains the support for power management

Environment:

    Kernel Mode Driver.

Notes:

    Nothing in here or in routines referenced from here should be pageable.

Revision History:

--*/

#include "busp.h"
#include "pnpisa.h"
#include <initguid.h>
#include <wdmguid.h>
#include "halpnpp.h"

NTSTATUS
PiDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchPowerFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchPowerPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PipPassPowerIrpFdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
PipPowerIrpNotSupportedPdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
PipQueryPowerStatePdo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PipSetPowerStatePdo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PipSetQueryPowerStateFdo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PipRequestPowerUpCompletionRoutinePdo (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );

NTSTATUS
FdoContingentPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

const PUCHAR SystemPowerStateStrings[] = {
    "Unspecified",
    "Working",
    "Sleeping1",
    "Sleeping2",
    "Sleeping3",
    "Hibernate",
    "Shutdown"
};

const PUCHAR DevicePowerStateStrings[] = {
    "Unspecified",
    "D0",
    "D1",
    "D2",
    "D3"
};

const PPI_DISPATCH PiPowerDispatchTableFdo[] =
{
    PipPassPowerIrpFdo,
    PipPassPowerIrpFdo,
    PipSetQueryPowerStateFdo,
    PipSetQueryPowerStateFdo,
};

#if ISOLATE_CARDS
const PPI_DISPATCH PiPowerDispatchTablePdo[] =
{
    PipPowerIrpNotSupportedPdo,
    PipPowerIrpNotSupportedPdo,
    PipSetPowerStatePdo,
    PipQueryPowerStatePdo,
};
#endif


VOID
PipDumpPowerIrpLocation(
    PIO_STACK_LOCATION IrpSp
    )
{
    DebugPrintContinue((
        DEBUG_POWER,
        "%s %d\n",
        (IrpSp->Parameters.Power.Type == DevicePowerState) ?
        DevicePowerStateStrings[IrpSp->Parameters.Power.State.DeviceState] : SystemPowerStateStrings[IrpSp->Parameters.Power.State.SystemState],
        IrpSp->Parameters.Power.ShutdownType));
}

NTSTATUS
PiDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all the IRP_MJ_POWER IRPs.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    PPI_BUS_EXTENSION busExtension;

    //
    // Make sure this is a valid device object.
    //

    busExtension = DeviceObject->DeviceExtension;

#if !ISOLATE_CARDS
    return PiDispatchPowerFdo(DeviceObject, Irp);
#else
    if (busExtension->Flags & DF_BUS) {
        return PiDispatchPowerFdo(DeviceObject, Irp);
    } else {
        return PiDispatchPowerPdo(DeviceObject, Irp);
    }
#endif
}

#if ISOLATE_CARDS

NTSTATUS
PipPowerIrpNotSupportedPdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    PoStartNextPowerIrp(Irp);

    DebugPrint((DEBUG_POWER,
                "Completing unsupported power irp %x for PDO %x\n",
                irpSp->MinorFunction,
                DeviceObject
                ));

    PipCompleteRequest(Irp, STATUS_NOT_SUPPORTED, NULL);
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
PiDispatchPowerPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all the IRP_MJ_POWER IRPs.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_INFORMATION deviceExtension;

    //
    // Make sure this is a valid device object.
    //

    deviceExtension = DeviceObject->DeviceExtension;
    if (deviceExtension->Flags & DF_DELETED) {
        status = STATUS_NO_SUCH_DEVICE;
        PoStartNextPowerIrp(Irp);
        PipCompleteRequest(Irp, status, NULL);
        return status;
    }

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    if (irpSp->MinorFunction > IRP_MN_PO_MAXIMUM_FUNCTION) {
        status =  PipPowerIrpNotSupportedPdo(DeviceObject, Irp);
    } else {
        status = PiPowerDispatchTablePdo[irpSp->MinorFunction](DeviceObject, Irp);
    }
    return status;
}

NTSTATUS
PipQueryPowerStatePdo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine handles the Query_Power irp for the PDO .

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{

    DEVICE_POWER_STATE targetState;
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

    DebugPrint((DEBUG_POWER, "QueryPower on PDO %x: ", DeviceObject));
    PipDumpPowerIrpLocation(irpSp);

    if (irpSp->Parameters.Power.Type == DevicePowerState) {
        targetState=irpSp->Parameters.Power.State.DeviceState;
        ASSERT ((targetState == PowerDeviceD0) ||
                (targetState == PowerDeviceD3));

        if ((targetState == PowerDeviceD0) ||
            (targetState == PowerDeviceD3) ) {

            status=Irp->IoStatus.Status = STATUS_SUCCESS;
        } else {
            status=Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        }
    } else {
        //
        // Just succeed S irps
        //
        status=Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    PoStartNextPowerIrp (Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DebugPrint((DEBUG_POWER, "QueryPower on PDO %x: returned %x\n", DeviceObject, status));
    return status;

}

NTSTATUS
PipSetPowerStatePdo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles SET_POWER_IRP for the IsaPnp device (i.e. PDO)
    It sets the devices power state to the power state type as indicated.  In
    the case of a device state change which is transitioning a device out of
    the PowerDevice0 state, we need call PoSetPowerState prior to leaving the
    PowerDeviceD0.  In the case if a device state change which is transitioning
    a device into the PowerDeviceD0 state, we call PoSetPowerState after the
    device is successfully put into the PowerDeviceD0 state.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PDEVICE_INFORMATION pdoExtension;
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
    DEVICE_POWER_STATE targetState=irpSp->Parameters.Power.State.DeviceState;
    POWER_STATE newState;

    DebugPrint((DEBUG_POWER, "SetPower on PDO %x: ", DeviceObject));
    PipDumpPowerIrpLocation(irpSp);

    pdoExtension = PipReferenceDeviceInformation(DeviceObject, FALSE);
    if (pdoExtension == NULL) {
        status = STATUS_NO_SUCH_DEVICE;
    } else if (pdoExtension->Flags & DF_NOT_FUNCTIONING) {
        status = STATUS_NO_SUCH_DEVICE;
        PipDereferenceDeviceInformation(pdoExtension, FALSE);
    } else {
        if (irpSp->Parameters.Power.Type == DevicePowerState) {

            // * On transition from D0 to D0, we do nothing.
            //
            // * On transition to D3, we'll deactivate the card.
            //
            // * On transition from D3->D0 we'll refresh the resources
            // and activate the card.
            //
            if ((targetState == PowerDeviceD0) &&
                (pdoExtension->DevicePowerState == PowerDeviceD0)) {
                // Do not try to power device back up if this is a D0->D0
                // transition.  The device is already powered.
                DebugPrint((DEBUG_POWER,
                            "PDO %x D0 -> D0 Transition ignored\n", DeviceObject));
            } else if ((pdoExtension->DevicePowerState == PowerDeviceD0) &&
                       pdoExtension->CrashDump) {
                DebugPrint((DEBUG_POWER,
                            "PDO %x D0 -> ?? Transition ignored, crash file\n",
                            DeviceObject));
            } else if (targetState >  PowerDeviceD0) {
                targetState = PowerDeviceD3;
                DebugPrint((DEBUG_POWER,
                            "Powering down PDO %x CSN %d/LDN %d\n",
                            DeviceObject,
                            pdoExtension->CardInformation->CardSelectNumber,
                            pdoExtension->LogicalDeviceNumber
                            ));
                if ((pdoExtension->Flags & (DF_ACTIVATED | DF_READ_DATA_PORT)) == DF_ACTIVATED) {
                    if (!(PipRDPNode->Flags & (DF_STOPPED|DF_REMOVED|DF_SURPRISE_REMOVED))) {
                        PipWakeAndSelectDevice(
                            pdoExtension->CardInformation->CardSelectNumber,
                            pdoExtension->LogicalDeviceNumber);
                        PipDeactivateDevice();
                        PipWaitForKey();
                    } else {
                        targetState = PowerDeviceD0;
                    }
                }
            } else {
                if ((pdoExtension->Flags & (DF_ACTIVATED | DF_READ_DATA_PORT)) == DF_ACTIVATED) {
                    DebugPrint((DEBUG_POWER,
                                "Powering up PDO %x CSN %d/LDN %d\n",
                                DeviceObject,
                                pdoExtension->CardInformation->CardSelectNumber,
                                pdoExtension->LogicalDeviceNumber
                                ));
                    if (!(PipRDPNode->Flags & (DF_STOPPED|DF_REMOVED|DF_SURPRISE_REMOVED))) {
                        PipWakeAndSelectDevice(
                            pdoExtension->CardInformation->CardSelectNumber,
                            pdoExtension->LogicalDeviceNumber);
                        status = PipSetDeviceResources(
                            pdoExtension,
                            pdoExtension->AllocatedResources);
                        if (NT_SUCCESS(status)) {
                            PipActivateDevice();
                        }
                        PipWaitForKey();
                    } else {
                        targetState = PowerDeviceD3;
                    }

                }
            }
            newState.DeviceState = targetState;
            PoSetPowerState(DeviceObject, DevicePowerState, newState);
            pdoExtension->DevicePowerState = targetState;
        }
        status = STATUS_SUCCESS;
        PipDereferenceDeviceInformation(pdoExtension, FALSE);
    }

    Irp->IoStatus.Status = status;

    PoStartNextPowerIrp (Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DebugPrint((DEBUG_POWER, "SetPower on PDO %x: returned %x\n", DeviceObject, status));
    return status;
}
#endif

NTSTATUS
PipPassPowerIrpFdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Description:

    This function pass the power Irp to lower level driver.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return:

    STATUS_PENDING

--*/
{
    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;
    PIO_STACK_LOCATION irpSp;

    PoStartNextPowerIrp(Irp);

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    busExtension = (PPI_BUS_EXTENSION) DeviceObject->DeviceExtension;

    DebugPrint((DEBUG_POWER,
                "Passing down power irp %x for FDO %x to %x\n",
                irpSp->MinorFunction,
                DeviceObject,
                busExtension->AttachedDevice
                ));

    IoSkipCurrentIrpStackLocation(Irp);
    status = PoCallDriver(busExtension->AttachedDevice, Irp);
    DebugPrint((DEBUG_POWER,
                "Passed down power irp for FDO: returned %x\n",
                status));
    return status;
}

NTSTATUS
PiDispatchPowerFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all the IRP_MJ_POWER IRPs.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    PPI_BUS_EXTENSION busExtension;

    //
    // Make sure this is a valid device object.
    //

    busExtension = DeviceObject->DeviceExtension;
    if (busExtension->AttachedDevice == NULL) {
        status = STATUS_NO_SUCH_DEVICE;
        PoStartNextPowerIrp(Irp);
        PipCompleteRequest(Irp, status, NULL);
        return status;
    }

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    if (irpSp->MinorFunction > IRP_MN_PO_MAXIMUM_FUNCTION) {
            return PipPassPowerIrpFdo(DeviceObject, Irp);
    } else {
        status = PiPowerDispatchTableFdo[irpSp->MinorFunction](DeviceObject, Irp);
    }
    return status;
}

NTSTATUS
PipSetQueryPowerStateFdo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles QUERY_POWER or SET_POWER IRPs for the IsaPnp bus device
    (i.e. FDO). It sets the devices power state for the power state type as indicated.
    In the case of a device state change which is transitioning a device out of
    the PowerDevice0 state, we need call PoSetPowerState prior to leaving the
    PowerDeviceD0.  In the case if a device state change which is transitioning
    a device into the PowerDeviceD0 state, we call PoSetPowerState after the
    device is successfully put into the PowerDeviceD0 state.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PPI_BUS_EXTENSION  fdoExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    fdoExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    DebugPrint((DEBUG_POWER, "%s on FDO %x: ",
                (irpSp->MinorFunction == IRP_MN_SET_POWER) ? "SetPower" :
                "QueryPower", DeviceObject));
    PipDumpPowerIrpLocation(irpSp);

    if (irpSp->Parameters.Power.Type == SystemPowerState) {
        POWER_STATE powerState;

        switch (irpSp->Parameters.Power.State.SystemState) {
            case PowerSystemWorking:

                //
                // Make sure the bus is on for these system states
                //

                powerState.DeviceState = PowerDeviceD0;
                break;

            case PowerSystemSleeping1:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:

                //
                // Going to sleep  ... Power down
                //

                powerState.DeviceState = PowerDeviceD3;
                break;

            default:

                //
                // Unknown request - be safe power up
                //

                ASSERT (TRUE == FALSE);
                powerState.DeviceState = PowerDeviceD0;
                break;
        }

        DebugPrint((DEBUG_POWER, "request power irp to busdev %x, pending\n",
                    fdoExtension->FunctionalBusDevice));
        IoMarkIrpPending(Irp);
        PoRequestPowerIrp (
            fdoExtension->FunctionalBusDevice,
            irpSp->MinorFunction,
            powerState,
            FdoContingentPowerCompletionRoutine,
            Irp,
            NULL
            );

        return STATUS_PENDING;

    }

    status = PipPassPowerIrpFdo(DeviceObject, Irp);
    DebugPrint((DEBUG_POWER, "SetPower(device) on FDO %x: returned %x\n", DeviceObject, status));
    return status;
}


NTSTATUS
FdoContingentPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PIRP irp = Context;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);

    DebugPrint((DEBUG_POWER, "requested power irp completed to %x\n", DeviceObject));

    //
    // Propagate the status of the transient power IRP
    //
    irp->IoStatus.Status = IoStatus->Status;

    if (NT_SUCCESS(IoStatus->Status)) {

        PPI_BUS_EXTENSION fdoExtension;

        fdoExtension = DeviceObject->DeviceExtension;

        PoStartNextPowerIrp (irp);
        //
        // changing device power state call PoSetPowerState now.
        //

        if (MinorFunction == IRP_MN_SET_POWER) {
            SYSTEM_POWER_STATE OldSystemPowerState = fdoExtension->SystemPowerState;

            fdoExtension->SystemPowerState = irpSp->Parameters.Power.State.SystemState;
            fdoExtension->DevicePowerState = PowerState.DeviceState;
            PoSetPowerState (
                DeviceObject,
                DevicePowerState,
                PowerState
                );
            DebugPrint((DEBUG_POWER, "New FDO %x powerstate system %s/%s\n",
                        DeviceObject,
                        SystemPowerStateStrings[fdoExtension->SystemPowerState],
                        DevicePowerStateStrings[fdoExtension->DevicePowerState]));
#if ISOLATE_CARDS

            if ((OldSystemPowerState == PowerSystemHibernate) ||
                (OldSystemPowerState == PowerSystemSleeping3) ) {
                BOOLEAN needsRescan;

                PipReportStateChange(PiSWaitForKey);
                if ((fdoExtension->BusNumber == 0) && PipRDPNode &&
                    (PipRDPNode->Flags & (DF_ACTIVATED|DF_PROCESSING_RDP|DF_QUERY_STOPPED)) == DF_ACTIVATED) {
                    needsRescan = PipMinimalCheckBus(fdoExtension);
                    if (needsRescan) {
                        PipRDPNode->Flags |= DF_NEEDS_RESCAN;
                        IoInvalidateDeviceRelations(
                            fdoExtension->PhysicalBusDevice,
                            BusRelations);
                    }
                }
            }
#endif
        }

        IoSkipCurrentIrpStackLocation (irp);
        PoCallDriver (fdoExtension->AttachedDevice, irp);

    } else {

        PoStartNextPowerIrp (irp);
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return STATUS_SUCCESS;
} // FdoContingentPowerCompletionRoutine
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\isapnp\translate.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    translate.c

Abstract:

    This is the ISA pnp IRQ translator.

Author:

    Andy Thornton (andrewth) 7-June-97

Environment:

    Kernel Mode Driver.

Notes:

    This should only be temporary and will be replaced by a call into the HAL
    to retrieve its translators.

Revision History:

--*/


#include "busp.h"
#include "wdmguid.h"
#include "halpnpp.h"

//
//Prototypes
//
NTSTATUS FindInterruptTranslator (PPI_BUS_EXTENSION BusExtension,PIRP Irp);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PiQueryInterface)
#pragma alloc_text (PAGE,FindInterruptTranslator)
#pragma alloc_text (PAGE,PipReleaseInterfaces)
#pragma alloc_text (PAGE,PipRebuildInterfaces)
#endif


NTSTATUS
PiQueryInterface (
    IN PPI_BUS_EXTENSION BusExtension,
    IN OUT PIRP Irp
    )
{

    NTSTATUS              status;
    PIO_STACK_LOCATION    thisIrpSp;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    status = STATUS_NOT_SUPPORTED;

    //
    // Check if we are requesting a translator interface
    //

    if (RtlEqualMemory(&GUID_TRANSLATOR_INTERFACE_STANDARD,
                       thisIrpSp->Parameters.QueryInterface.InterfaceType,
                       sizeof(GUID))) {

        status = FindInterruptTranslator (BusExtension,Irp);
        if (NT_SUCCESS (status)) {
            //
            // Save away the hal interface, so we can unload it...
            //
        }
    }

    return status;
}

NTSTATUS
FindInterruptTranslator (PPI_BUS_EXTENSION BusExtension,PIRP Irp)
{
    NTSTATUS              status;
    PIO_STACK_LOCATION    thisIrpSp;
    PTRANSLATOR_INTERFACE translator;
    ULONG busNumber, length;
    INTERFACE_TYPE interfaceType;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    status = STATUS_NOT_SUPPORTED;

    if ((UINT_PTR)(thisIrpSp->Parameters.QueryInterface.InterfaceSpecificData) ==
    CmResourceTypeInterrupt) {

    //
    // Retrieve the bus number and interface type for the bridge
    //

    status = IoGetDeviceProperty(BusExtension->PhysicalBusDevice,
                                 DevicePropertyLegacyBusType,
                                 sizeof(INTERFACE_TYPE),
                                 &interfaceType,
                                 &length
                                 );

    //ASSERT(NT_SUCCESS(status));

    status = IoGetDeviceProperty(BusExtension->PhysicalBusDevice,
                                 DevicePropertyBusNumber,
                                 sizeof(ULONG),
                                 &busNumber,
                                 &length
                                 );

    //ASSERT(NT_SUCCESS(status));

    status = HalGetInterruptTranslator(
                interfaceType,
                busNumber,
                Isa,
                thisIrpSp->Parameters.QueryInterface.Size,
                thisIrpSp->Parameters.QueryInterface.Version,
                (PTRANSLATOR_INTERFACE) thisIrpSp->Parameters.QueryInterface.Interface,
                &busNumber
                );

    }
    return status;

}

NTSTATUS
PipReleaseInterfaces(PPI_BUS_EXTENSION PipBusExtension)
{


    return STATUS_SUCCESS;
}

NTSTATUS
PipRebuildInterfaces(PPI_BUS_EXTENSION PipBusExtension)
{

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\mf\common.c ===
/*++                 

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    common.c

Abstract:

    This module provides the functions which are common to both the PDO and FDO.
    
Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "mfp.h"

/*++
        
The majority of functions in this file are called based on their presence
in Pnp and Po dispatch tables.  In the interests of brevity the arguments
to all those functions will be described below:

NTSTATUS
MfXxxCommon(
    IN PIRP Irp,
    IN PMF_COMMON_EXTENSION Common,
	IN PIO_STACK_LOCATION IrpStack
    )

Routine Description:
    
    This function handles the Xxx requests for all multifunction devices

Arguments:

    Irp - Points to the IRP associated with this request.
    
    Parent - Points to the common device extension.
    
    IrpStack - Points to the current stack location for this request.
    
Return Value:

    Status code that indicates whether or not the function was successful.
    
    STATUS_NOT_SUPPORTED indicates that the IRP should be passed down without
    changing the Irp->IoStatus.Status field otherwise it is updated with this
    status.
    
--*/

NTSTATUS
MfDeviceUsageNotificationCommon(
    IN PIRP Irp,
    IN PMF_COMMON_EXTENSION Common,
	IN PIO_STACK_LOCATION IrpStack
    )
{
    PULONG counter;
    
    //
    // Select the appropriate counter
    //
    
    switch (IrpStack->Parameters.UsageNotification.Type) {
    
    case DeviceUsageTypePaging:
        counter = &Common->PagingCount;
        break;
    
    case DeviceUsageTypeHibernation:
        counter = &Common->HibernationCount;
        break;

    case DeviceUsageTypeDumpFile:
        counter = &Common->DumpCount;
        break;

    default:
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Update it...
    //
    
    IoAdjustPagingPathCount(counter, 
                            IrpStack->Parameters.UsageNotification.InPath
                            );
    
    return STATUS_SUCCESS;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\mf\debug.c ===
/*++      

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module provides debugging support.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#include "mfp.h"

//
// Get mappings from status codes to strings
//

#include <ntstatus.dbg>

#undef MAP
#define MAP(_Value) { (_Value), #_Value }
#define END_STRING_MAP  { 0xFFFFFFFF, NULL }
#if DBG

LONG MfDebug = -1;

PMF_STRING_MAP MfDbgStatusStringMap = (PMF_STRING_MAP) ntstatusSymbolicNames;

MF_STRING_MAP MfDbgPnpIrpStringMap[] = {

    MAP(IRP_MN_START_DEVICE),
    MAP(IRP_MN_QUERY_REMOVE_DEVICE),
    MAP(IRP_MN_REMOVE_DEVICE),
    MAP(IRP_MN_CANCEL_REMOVE_DEVICE),
    MAP(IRP_MN_STOP_DEVICE),
    MAP(IRP_MN_QUERY_STOP_DEVICE),
    MAP(IRP_MN_CANCEL_STOP_DEVICE),
    MAP(IRP_MN_QUERY_DEVICE_RELATIONS),
    MAP(IRP_MN_QUERY_INTERFACE),
    MAP(IRP_MN_QUERY_CAPABILITIES),
    MAP(IRP_MN_QUERY_RESOURCES),
    MAP(IRP_MN_QUERY_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_QUERY_DEVICE_TEXT),
    MAP(IRP_MN_FILTER_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_READ_CONFIG),
    MAP(IRP_MN_WRITE_CONFIG),
    MAP(IRP_MN_EJECT),
    MAP(IRP_MN_SET_LOCK),
    MAP(IRP_MN_QUERY_ID),
    MAP(IRP_MN_QUERY_PNP_DEVICE_STATE),
    MAP(IRP_MN_QUERY_BUS_INFORMATION),
    MAP(IRP_MN_DEVICE_USAGE_NOTIFICATION),
    MAP(IRP_MN_SURPRISE_REMOVAL),
    MAP(IRP_MN_QUERY_LEGACY_BUS_INFORMATION),
    END_STRING_MAP
};


MF_STRING_MAP MfDbgPoIrpStringMap[] = {

    MAP(IRP_MN_WAIT_WAKE),
    MAP(IRP_MN_POWER_SEQUENCE),
    MAP(IRP_MN_SET_POWER),
    MAP(IRP_MN_QUERY_POWER),
    END_STRING_MAP
};



MF_STRING_MAP MfDbgDeviceRelationStringMap[] = {
    
    MAP(BusRelations),
    MAP(EjectionRelations),
    MAP(PowerRelations),
    MAP(RemovalRelations),
    MAP(TargetDeviceRelation),
    END_STRING_MAP
    
};

MF_STRING_MAP MfDbgSystemPowerStringMap[] = {
    
    MAP(PowerSystemUnspecified),
    MAP(PowerSystemWorking),
    MAP(PowerSystemSleeping1),
    MAP(PowerSystemSleeping2),
    MAP(PowerSystemSleeping3),
    MAP(PowerSystemHibernate),
    MAP(PowerSystemShutdown),
    MAP(PowerSystemMaximum),
    END_STRING_MAP

};

MF_STRING_MAP MfDbgDevicePowerStringMap[] = {
    
    MAP(PowerDeviceUnspecified),
    MAP(PowerDeviceD0),
    MAP(PowerDeviceD1),
    MAP(PowerDeviceD2),
    MAP(PowerDeviceD3),
    MAP(PowerDeviceMaximum),
    END_STRING_MAP

};

PCHAR
MfDbgLookupString(
    IN PMF_STRING_MAP Map,
    IN ULONG Id
    )

/*++

Routine Description:

    Looks up the string associated with Id in string map Map
    
Arguments:

    Map - The string map
    
    Id - The id to lookup

Return Value:

    The string
        
--*/

{
    PMF_STRING_MAP current = Map;
    
    while(current->Id != 0xFFFFFFFF) {

        if (current->Id == Id) {
            return current->String;
        }
        
        current++;
    }
    
    return "** UNKNOWN **";
}

VOID
MfDbgPrintMultiSz(
    LONG DebugLevel,
    PWSTR MultiSz
    )

/*++

Routine Description:

    Prints a registry style REG_MULTI_SZ
    
Arguments:

    DebugLevel - The debug level at which or above the data should be displayed.
    
    MultiSz - The string to print

Return Value:

    None
            
--*/

{
    PWSTR current = MultiSz;

    if (DebugLevel <= MfDebug) {

        if (MultiSz) {
        
            while(*current) {
        
                DbgPrint("%S", current);
                
                current += wcslen(current) + 1; // include the NULL
        
                DbgPrint(*current ? ", " : "\n");
        
            }
        } else {
            DbgPrint("*** None ***\n");
        }
    }
}

VOID
MfDbgPrintResourceMap(
    LONG DebugLevel,
    PMF_RESOURCE_MAP Map
    )

/*++

Routine Description:

    Prints a resource map
        
Arguments:

    DebugLevel - The debug level at which or above the data should be displayed.
    
    Map - The map to be displayed

Return Value:

    None
            
--*/

{
    PCHAR current;
    
    if (DebugLevel <= MfDebug) {
    
        if (Map) {
            
            FOR_ALL_IN_ARRAY(Map->Resources, Map->Count, current) {
                DbgPrint("%i ", *current);
            }
            
            DbgPrint("\n");
        
        } else {
            
            DbgPrint("*** None ***\n");
        
        }
    }
}

VOID
MfDbgPrintVaryingResourceMap(
    LONG DebugLevel,
    PMF_VARYING_RESOURCE_MAP Map
    )

/*++

Routine Description:

    Prints a varying resource map
        
Arguments:

    DebugLevel - The debug level at which or above the data should be displayed.
    
    Map - The map to be displayed

Return Value:

    None
            
--*/

{
    PMF_VARYING_RESOURCE_ENTRY current;
    
    if (DebugLevel <= MfDebug) {
    
        if (Map) {
            
            DbgPrint("\n");
            FOR_ALL_IN_ARRAY(Map->Resources, Map->Count, current) {
                DbgPrint("\t\tIndex %i for %x bytes at offset %x\n",
                         current->ResourceIndex,
                         current->Size,
                         current->Offset
                         );
            }
            
        } else {
            
            DbgPrint("*** None ***\n");
        
        }
    }
}

//
// Printing resource descriptors and resource lists (stolen from PCI)
//

PUCHAR
MfDbgCmResourceTypeToText(
    UCHAR Type
    )
{
    switch (Type) {
    case CmResourceTypePort:
        return "CmResourceTypePort";
    case CmResourceTypeInterrupt:
        return "CmResourceTypeInterrupt";
    case CmResourceTypeMemory:
        return "CmResourceTypeMemory";
    case CmResourceTypeDma:
        return "CmResourceTypeDma";
    case CmResourceTypeDeviceSpecific:
        return "CmResourceTypeDeviceSpecific";
    case CmResourceTypeBusNumber:
        return "CmResourceTypeBusNumber";
    case CmResourceTypeConfigData:
        return "CmResourceTypeConfigData";
    case CmResourceTypeDevicePrivate:
        return "CmResourceTypeDevicePrivate";
    case CmResourceTypePcCardConfig:
        return "CmResourceTypePcCardConfig";
    default:
        return "*** INVALID RESOURCE TYPE ***";
    }
}

VOID
MfDbgPrintIoResource(
    IN LONG Level,
    IN PIO_RESOURCE_DESCRIPTOR D
    )
{
    ULONG  i;
    PUCHAR t;

    if (Level <= MfDebug) {
    
        t = MfDbgCmResourceTypeToText(D->Type);
        DbgPrint("     IoResource Descriptor dump:  Descriptor @0x%x\n", D);
        DbgPrint("        Option           = 0x%x\n", D->Option);
        DbgPrint("        Type             = %d (%s)\n", D->Type, t);
        DbgPrint("        ShareDisposition = %d\n", D->ShareDisposition);
        DbgPrint("        Flags            = 0x%04X\n", D->Flags);
    
        for ( i = 0; i < 6 ; i+=3 ) {
            DbgPrint("        Data[%d] = %08x  %08x  %08x\n",
                     i,
                     D->u.DevicePrivate.Data[i],
                     D->u.DevicePrivate.Data[i+1],
                     D->u.DevicePrivate.Data[i+2]);
        }
    }
}


VOID
MfDbgPrintIoResReqList(
    IN LONG Level,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResReqList
    )
{
    ULONG                   numlists;
    PIO_RESOURCE_LIST       list;


    if (Level <= MfDebug) {
    
        if (IoResReqList) {
            
            numlists = IoResReqList->AlternativeLists;
            list     = IoResReqList->List;
        
            DbgPrint("  IO_RESOURCE_REQUIREMENTS_LIST\n");
            DbgPrint("     InterfaceType        %d\n", IoResReqList->InterfaceType);
            DbgPrint("     BusNumber            %d\n", IoResReqList->BusNumber    );
            DbgPrint("     SlotNumber           %d\n",  IoResReqList->SlotNumber  );
            DbgPrint("     AlternativeLists     %d\n", numlists                   );
        
            while (numlists--) {
        
                PIO_RESOURCE_DESCRIPTOR resource = list->Descriptors;
                ULONG                   count    = list->Count;
        
                DbgPrint("\n     List[%d].Count = %d\n", numlists, count);
                while (count--) {
                    MfDbgPrintIoResource(Level, resource++);
                }
        
                list = (PIO_RESOURCE_LIST)resource;
            }
            DbgPrint("\n");
        } else {
            
            DbgPrint("  IO_RESOURCE_REQUIREMENTS_LIST\n");
            DbgPrint("     *** EMPTY ***\n");
        }
    }
}


VOID
MfDbgPrintPartialResource(
    IN LONG Level,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR D
    )
{
    ULONG  i;
    PUCHAR t;

    if (Level <= MfDebug) {

        if (D) {
        
            t = MfDbgCmResourceTypeToText(D->Type);
            DbgPrint("     Partial Resource Descriptor @0x%x\n", D);
            DbgPrint("        Type             = %d (%s)\n", D->Type, t);
            DbgPrint("        ShareDisposition = %d\n", D->ShareDisposition);
            DbgPrint("        Flags            = 0x%04X\n", D->Flags);
            
            for ( i = 0; i < 3 ; i+=3 ) {
                DbgPrint("        Data[%d] = %08x  %08x  %08x\n",
                         i,
                         D->u.DevicePrivate.Data[i],
                         D->u.DevicePrivate.Data[i+1],
                         D->u.DevicePrivate.Data[i+2]);
            }

        } else {
        
            DbgPrint("     Partial Resource Descriptor EMPTY!!\n");
        }
    }
}

PCM_PARTIAL_RESOURCE_DESCRIPTOR
MfNextPartialDescriptor(
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    Given a pointer to a CmPartialResourceDescriptor, return a pointer
    to the next descriptor in the same list.

    This is only done in a routine (rather than a simple descriptor++)
    because if the variable length resource CmResourceTypeDeviceSpecific.

Arguments:

    Descriptor   - Pointer to the descriptor being advanced over.

Return Value:

    Pointer to the next descriptor in the same list (or byte beyond
    end of list).

--*/

{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR nextDescriptor;

    nextDescriptor = Descriptor + 1;

    if (Descriptor->Type == CmResourceTypeDeviceSpecific) {

        //
        // This (old) descriptor is followed by DataSize bytes
        // of device specific data, ie, not immediatelly by the
        // next descriptor.   Adjust nextDescriptor by this amount.
        //

        nextDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
            ((PCHAR)nextDescriptor + Descriptor->u.DeviceSpecificData.DataSize);
    }
    return nextDescriptor;
}


VOID
MfDbgPrintCmResList(
    IN LONG Level,
    IN PCM_RESOURCE_LIST ResourceList
    )
{
    ULONG                           numlists;
    PCM_FULL_RESOURCE_DESCRIPTOR    full;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;

    if (Level <= MfDebug) {
    

        if (ResourceList) {
        
            numlists = ResourceList->Count;
            full     = ResourceList->List;
        
            DbgPrint("  CM_RESOURCE_LIST (List Count = %d)\n",
                     numlists);
        
            while (numlists--) {
                PCM_PARTIAL_RESOURCE_LIST partial = &full->PartialResourceList;
                ULONG                     count   = partial->Count;
        
                DbgPrint("     InterfaceType        %d\n", full->InterfaceType);
                DbgPrint("     BusNumber            %d\n", full->BusNumber    );
        
                descriptor = partial->PartialDescriptors;
                while (count--) {
                    MfDbgPrintPartialResource(Level, descriptor);
                    descriptor = MfNextPartialDescriptor(descriptor);
                }
        
                full = (PCM_FULL_RESOURCE_DESCRIPTOR)descriptor;
            }
            DbgPrint("\n");
        
        } else {
        
            DbgPrint("  CM_RESOURCE_LIST EMPTY!!!\n");
        }
    }
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\mf\arbiter.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    arbiter.c

Abstract:

    This module provides arbiters for the resources consumed by PDOs.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#include "mfp.h"
#include "arbiter.h"


NTSTATUS
MfInitializeArbiters(
    IN PMF_PARENT_EXTENSION Parent
    );

NTSTATUS
MfInitializeArbiter(
    OUT PMF_ARBITER Arbiter,
    IN PDEVICE_OBJECT BusDeviceObject,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

LONG
MfNopScore(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
MfStartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, MfInitializeArbiters)
#pragma alloc_text(PAGE, MfInitializeArbiter)
#pragma alloc_text(PAGE, MfNopScore)
#pragma alloc_text(PAGE, MfStartArbiter)

#endif


NTSTATUS
MfInitializeArbiters(
    IN PMF_PARENT_EXTENSION Parent
    )

/*++

Routine Description:

    This initializes the arbiters required to arbitrated resources for the
    parent device.

Arguments:

    Parent - The MF device we are initializing arbiters for.

Return Value:

    Status of operation.

--*/
{

    NTSTATUS status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
    PMF_ARBITER arbiter, newArbiter = NULL;
    BOOLEAN existingArbiter;

    PAGED_CODE();

    //
    // REBALANCE - if restart then free the old arbiters
    // until we do that, assume we're not restarting
    //

    ASSERT(IsListEmpty(&Parent->Arbiters));

    //
    // If we don't have any resources we don't need any arbiters
    //

    if (!Parent->ResourceList) {

        return STATUS_SUCCESS;
    }

    FOR_ALL_CM_DESCRIPTORS(Parent->ResourceList, descriptor) {

        //
        // Check if this is an nonarbitrated resource - if it is then we won't
        // be needing an arbiter for it!
        //

        if (!IS_ARBITRATED_RESOURCE(descriptor->Type)) {
            continue;
        }

        //
        // See if we already have an arbiter for this resource
        //

        existingArbiter = FALSE;

        FOR_ALL_IN_LIST(MF_ARBITER, &Parent->Arbiters, arbiter) {

            if (arbiter->Type == descriptor->Type) {

                //
                // We already have an arbiter so we don't need
                // to create a new one
                //

                existingArbiter = TRUE;

                break;
            }
        }

        if (!existingArbiter) {

            //
            // We don't have an arbiter for this resource type so make one!
            //

            DEBUG_MSG(1,
                      ("Creating arbiter for %s\n",
                       MfDbgCmResourceTypeToText(descriptor->Type)
                      ));

            newArbiter = ExAllocatePoolWithTag(PagedPool,
                                               sizeof(MF_ARBITER),
                                               MF_ARBITER_TAG
                                               );

            if (!newArbiter) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status = MfInitializeArbiter(newArbiter, Parent->Self, descriptor);

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

            InsertHeadList(&Parent->Arbiters, &newArbiter->ListEntry);

        }

    }

    FOR_ALL_IN_LIST(MF_ARBITER, &Parent->Arbiters, arbiter) {

        MfStartArbiter(&(arbiter->Instance), Parent->ResourceList);
    }

    return STATUS_SUCCESS;

cleanup:

    if (newArbiter) {

        ExFreePool(newArbiter);
    }

    return status;
}


LONG
MfNopScore(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )
{
    PAGED_CODE();

    return 0;
}

NTSTATUS
MfInitializeArbiter(
    OUT PMF_ARBITER Arbiter,
    IN PDEVICE_OBJECT BusDeviceObject,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )
/*

Routine Description:

    This initializes an arbiter to arbitrated the resources described in
    Descriptor

Arguments:

    Arbiter - Pointer to a buffer where the arbiter should reside.

    Descriptor - Describes the resources available to the arbiter.

Return Value:

    Status of operation.

*/

{

    NTSTATUS status;
    PMF_RESOURCE_TYPE resType;

    PAGED_CODE();

    //
    // Do we understand these resources
    //

    resType = MfFindResourceType(Descriptor->Type);

    if (!resType) {
        return STATUS_INVALID_PARAMETER;
    }

    Arbiter->Type = Descriptor->Type;

    RtlZeroMemory(&Arbiter->Instance, sizeof(ARBITER_INSTANCE));

    Arbiter->Instance.PackResource = resType->PackResource;
    Arbiter->Instance.UnpackResource = resType->UnpackResource;
    Arbiter->Instance.UnpackRequirement = resType->UnpackRequirement;

    //
    // Initialize the arbiter
    //

    status = ArbInitializeArbiterInstance(&Arbiter->Instance,
                                          BusDeviceObject,
                                          Arbiter->Type,
                                          L"Mf Arbiter",
                                          L"Root",  // should be NULL
                                          NULL
                                          );



    return status;

}

//
// Arbiter support functions
//

NTSTATUS
MfStartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    )
/*++

Routine Description:

    This initializes an arbiter's range list to arbitrate the
    resources described in StartResources

Arguments:

    Arbiter - Pointer to the arbiter.

    StartResources - Describes the resources available to the arbiter.

Return Value:

    Status of operation.

--*/

{
    RTL_RANGE_LIST invertedAllocation;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
    ULONGLONG start;
    ULONG length;
    NTSTATUS status;


    PAGED_CODE();

    RtlInitializeRangeList(&invertedAllocation);

    //
    // Iterate through resource descriptors, adding the resources
    // this arbiter arbitrates to the ReverseAllocation
    //

    FOR_ALL_CM_DESCRIPTORS(StartResources,descriptor) {

        if (descriptor->Type == Arbiter->ResourceType) {

            status = Arbiter->UnpackResource(descriptor,
                                             &start,
                                             &length);

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

            if (length > 0) {

                //
                // we don't care about Attributes, UserData or Owner since this
                // list is going to get trashed in a minute anyway
                //

                status = RtlAddRange(&invertedAllocation,
                                     start,
                                     END_OF_RANGE(start,length),
                                     0,                             // Attributes
                                     RTL_RANGE_LIST_ADD_SHARED|RTL_RANGE_LIST_ADD_IF_CONFLICT,
                                     0,                             // UserData
                                     NULL);                         // Owner
            }

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

        }
    }

    status = RtlInvertRangeList(Arbiter->Allocation,&invertedAllocation);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = STATUS_SUCCESS;

cleanup:

    RtlFreeRangeList(&invertedAllocation);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\mf\enum.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    enum.c

Abstract:

    This module provides the functions related to device enumeration.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "mfp.h"
#pragma hdrstop
#include <initguid.h>
#include <mf.h>
#include <wdmguid.h>

NTSTATUS
MfBuildChildRequirements(
    IN PMF_CHILD_EXTENSION Child,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList
    );

NTSTATUS
MfBuildDeviceID(
    IN PMF_PARENT_EXTENSION Parent,
    OUT PWSTR *DeviceID
    );

NTSTATUS
MfBuildInstanceID(
    IN PMF_CHILD_EXTENSION Child,
    OUT PWSTR *InstanceID
    );

NTSTATUS
MfBuildResourceMap(
    IN PUCHAR Data,
    IN ULONG Length,
    OUT PMF_RESOURCE_MAP *ResourceMap
    );

NTSTATUS
MfBuildVaryingResourceMap(
    IN PMF_REGISTRY_VARYING_RESOURCE_MAP RegistryMap,
    IN ULONG Length,
    OUT PMF_VARYING_RESOURCE_MAP *ResourceMap
    );

NTSTATUS
MfEnumRegistryChild(
    IN HANDLE ParentHandle,
    IN ULONG Index,
    IN OUT PMF_DEVICE_INFO Info
    );

NTSTATUS
MfEnumerate(
    IN PMF_PARENT_EXTENSION Parent
    );

NTSTATUS
MfEnumerateFromInterface(
    IN PMF_PARENT_EXTENSION Parent
    );

NTSTATUS
MfEnumerateFromRegistry(
    IN PMF_PARENT_EXTENSION Parent
    );

BOOLEAN
MfIsChildEnumeratedAlready(
    PMF_PARENT_EXTENSION Parent,
    PUNICODE_STRING childName
    );

BOOLEAN
MfIsResourceShared(
    IN PMF_PARENT_EXTENSION Parent,
    IN UCHAR Index,
    IN ULONG Offset,
    IN ULONG Size
    );

NTSTATUS
MfParentResourceToChildRequirement(
    IN PMF_PARENT_EXTENSION Parent,
    IN PMF_CHILD_EXTENSION Child,
    IN UCHAR Index,
    IN ULONG Offset OPTIONAL,
    IN ULONG Size OPTIONAL,
    OUT PIO_RESOURCE_DESCRIPTOR Requirement
    );

NTSTATUS
MfValidateDeviceInfo(
    IN PMF_PARENT_EXTENSION Parent,
    IN PMF_DEVICE_INFO DeviceInfo
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MfBuildChildRequirements)
#pragma alloc_text(PAGE, MfBuildDeviceID)
#pragma alloc_text(PAGE, MfBuildInstanceID)
#pragma alloc_text(PAGE, MfBuildResourceMap)
#pragma alloc_text(PAGE, MfBuildVaryingResourceMap)
#pragma alloc_text(PAGE, MfEnumRegistryChild)
#pragma alloc_text(PAGE, MfEnumerate)
#pragma alloc_text(PAGE, MfEnumerateFromInterface)
#pragma alloc_text(PAGE, MfEnumerateFromRegistry)
#pragma alloc_text(PAGE, MfIsResourceShared)
#pragma alloc_text(PAGE, MfParentResourceToChildRequirement)
#endif

NTSTATUS
MfBuildResourceMap(
    IN PUCHAR Data,
    IN ULONG Length,
    OUT PMF_RESOURCE_MAP *ResourceMap
    )

/*++

Routine Description:

    Constructs an MF_RESOURCE_MAP from information returned from the registry

Arguments:

    Data - The raw REG_BINARY data from the registry

    Length - Length in bytes of Data

    ResourceMap - On success a pointer to the resource map.  Memory should be
        freed using ExFreePool when no longer required

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{
    PMF_RESOURCE_MAP resourceMap;

    //
    // Allocate the resource map structure, add space for a count
    //

    resourceMap = ExAllocatePoolWithTag(PagedPool,
                                        sizeof(MF_RESOURCE_MAP) + Length - 1,
                                        MF_RESOURCE_MAP_TAG
                                        );

    if (!resourceMap) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill it in
    //

    resourceMap->Count = Length;

    RtlCopyMemory(&resourceMap->Resources, Data, Length);

    //
    // Hand it back to the caller
    //

    *ResourceMap = resourceMap;

    return STATUS_SUCCESS;
}

NTSTATUS
MfBuildVaryingResourceMap(
    IN PMF_REGISTRY_VARYING_RESOURCE_MAP RegistryMap,
    IN ULONG Length,
    OUT PMF_VARYING_RESOURCE_MAP *ResourceMap
    )

/*++

Routine Description:

    Constructs an MF_VARYING_RESOURCE_MAP from information returned from the registry

Arguments:

    RegistryMap - The raw REG_BINARY data from the registry

    Length - Length in bytes of RegistryMap

    ResourceMap - On success a pointer to the resource map.  Memory should be
        freed using ExFreePool when no longer required

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{

    PMF_VARYING_RESOURCE_MAP resourceMap;
    PMF_VARYING_RESOURCE_ENTRY current;
    PMF_REGISTRY_VARYING_RESOURCE_MAP currentRegistry;
    ULONG count;

    if (Length % sizeof(MF_REGISTRY_VARYING_RESOURCE_MAP) != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    count = Length / sizeof(MF_REGISTRY_VARYING_RESOURCE_MAP);

    //
    // Allocate the resource map structure
    //

    resourceMap = ExAllocatePoolWithTag(PagedPool,
                                        sizeof(MF_VARYING_RESOURCE_MAP) +
                                            (count-1) * sizeof(MF_VARYING_RESOURCE_ENTRY),
                                        MF_VARYING_MAP_TAG
                                        );

    if (!resourceMap) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill it in
    //

    resourceMap->Count = count;

    //
    // Translate the registry data into an aligned internal format
    //

    current = resourceMap->Resources;
    currentRegistry = RegistryMap;

    while (count--) {

        current->ResourceIndex = currentRegistry->ResourceIndex;
        current->Offset = currentRegistry->Offset;
        current->Size = currentRegistry->Size;

        currentRegistry++;
        current++;
    }

    //
    // Hand it back to the caller
    //

    *ResourceMap = resourceMap;

    return STATUS_SUCCESS;
}

NTSTATUS
MfEnumRegistryChild(
    IN HANDLE ParentHandle,
    IN ULONG Index,
    IN OUT PMF_DEVICE_INFO Info
    )

/*++

Routine Description:

    Initialized an MF_DEVICE_INFO from information stored in the registry.

Arguments:

    ParentHandle - Handle to the registry key under which the data is stored

    Index - Index of the subkey to use

    Info - Pointer to the device info that should be filled in


Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{
    NTSTATUS status;
    PMF_REGISTRY_VARYING_RESOURCE_MAP varyingMap = NULL;
    PUCHAR resourceMap = NULL;
    ULONG varyingMapSize = 0, resourceMapSize = 0, stringSize = 0;
    BOOLEAN gotId = FALSE;

    ASSERT(ParentHandle && Info);

    //
    // Retrieve the data - we must have a HardwareID and/or CompatibleID
    //

    status = MfGetRegistryValue(ParentHandle,
                                L"HardwareID",
                                REG_MULTI_SZ,
                                MF_GETREG_SZ_TO_MULTI_SZ,
                                &stringSize,
                                &Info->HardwareID.Buffer
                                );

    if (NT_SUCCESS(status)) {
        gotId = TRUE;
    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {
        goto cleanup;
    }

    ASSERT(stringSize <= MAXUSHORT);

    if (stringSize <= MAXUSHORT) {
        
        Info->HardwareID.Length = (USHORT)stringSize;
        Info->HardwareID.MaximumLength = Info->HardwareID.Length;    
    
    } else {
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }
    

    //
    // ... CompatibleID ...
    //

    stringSize = 0;

    status = MfGetRegistryValue(ParentHandle,
                                L"CompatibleID",
                                REG_MULTI_SZ,
                                MF_GETREG_SZ_TO_MULTI_SZ,
                                &stringSize,
                                &Info->CompatibleID.Buffer
                                );

    if (NT_SUCCESS(status)) {
        gotId = TRUE;
    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {
        goto cleanup;
    }

    ASSERT(stringSize <= MAXUSHORT);

    if (stringSize <= MAXUSHORT) {
        
        Info->CompatibleID.Length = (USHORT)stringSize;
        Info->CompatibleID.MaximumLength = Info->CompatibleID.Length;    
    
    } else {
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Now check that we have got an ID - if we don't then fail
    //

    if (!gotId) {
        status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    //
    // ...ResourceMap...
    //

    status = MfGetRegistryValue(ParentHandle,
                                L"ResourceMap",
                                REG_BINARY,
                                0,  // flags
                                &resourceMapSize,
                                &resourceMap
                                );

    if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
        goto cleanup;
    }

    //
    // If we have a resource map the store it in our device info
    //

    if (resourceMap) {

        status = MfBuildResourceMap(resourceMap,
                                    resourceMapSize,
                                    &Info->ResourceMap
                                    );
        ExFreePool(resourceMap);
        resourceMap = NULL;
        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }
    }

    //
    // ...VaryingResourceMap...
    //

    status = MfGetRegistryValue(ParentHandle,
                                L"VaryingResourceMap",
                                REG_BINARY,
                                0, // flags
                                &varyingMapSize,
                                &varyingMap
                                );

    if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
        goto cleanup;
    }

    if (varyingMap) {

        status = MfBuildVaryingResourceMap(varyingMap,
                                           varyingMapSize,
                                           &Info->VaryingResourceMap
                                           );
        ExFreePool(varyingMap);
        varyingMap = NULL;
        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

    }


    //
    // ...MfFlags
    //

    status = MfGetRegistryValue(ParentHandle,
                                L"MFFlags",
                                REG_DWORD,
                                0, // flags
                                NULL,
                                (PVOID) &Info->MfFlags
                                );

    if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
        goto cleanup;
    }

    return STATUS_SUCCESS;

cleanup:

    MfFreeDeviceInfo(Info);
    //
    // If any of the values were of the wrong type then this is an invalid
    // MF entry.
    //

    if (status == STATUS_OBJECT_TYPE_MISMATCH) {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}

NTSTATUS
MfEnumerate(
    IN PMF_PARENT_EXTENSION Parent
    )
/*++

Routine Description:

    Allocates and initialies the Children list of PDOs for this MF device.
    First from the registry and then by querying an MF_ENUMERATION_INTERFACE from
    its PDO.

Arguments:

    Parent - The MF device that should be enumerated

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{
    NTSTATUS status;
    PMF_CHILD_EXTENSION current, next;

    //
    // Try to get our children from the registry
    //

    status = MfEnumerateFromRegistry(Parent);

    if (!NT_SUCCESS(status)) {

        //
        // STATUS_UNSUCCESSFUL indicates that there wasn't any MF information
        // in the registry
        //

        if (status == STATUS_UNSUCCESSFUL) {

            //
            // See if our parent has an MF_ENUMERATION_INTERFACE for us...
            //

            status = MfEnumerateFromInterface(Parent);
        }
    }

    return status;
}


NTSTATUS
MfEnumerateFromRegistry(
    IN PMF_PARENT_EXTENSION Parent
    )

/*++

Routine Description:

    Allocates and initialies the Children list of PDOs for this MF device by
    looking in the registry

Arguments:

    Parent - The MF device that should be enumerated

Return Value:

    Status code indicating the success or otherwise of the operation.
    STATUS_UNSUCCESSFUL indicates that no MF information was found in the
    registry.

--*/

{
    NTSTATUS status;
    HANDLE parentHandle = NULL, childHandle = NULL;
    ULONG index = 0;
    UNICODE_STRING childName;
    PDEVICE_OBJECT pdo;
    PMF_CHILD_EXTENSION child;
    MF_DEVICE_INFO info;

    ASSERT(!(Parent->Common.DeviceState & MF_DEVICE_ENUMERATED));

    //
    // Open the "Device Parameters" key for our PDO and see what the INF file
    // put there.
    //

    status = IoOpenDeviceRegistryKey(Parent->PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ,
                                     &parentHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    ASSERT(parentHandle);

    //
    // Iterate over keys
    //

    for (;;) {

        //
        // Open the child key for this info
        //

        status = MfGetSubkeyByIndex(parentHandle,
                                    index,
                                    KEY_READ,
                                    &childHandle,
                                    &childName
                                    );

        if (status == STATUS_NO_MORE_ENTRIES) {

            if (IsListEmpty(&Parent->Children)) {

                //
                // There wern't any children - fail
                //
                status = STATUS_UNSUCCESSFUL;
                goto cleanup;
            }

            //
            // We've found all the children
            //
            break;
        }

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        RtlZeroMemory(&info, sizeof(info));
        if (!MfIsChildEnumeratedAlready(Parent, &childName)) {
            
            info.Name = childName;

            //
            // Query the registry for the info
            //

            status = MfEnumRegistryChild(childHandle, index, &info);
            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }
            status = MfValidateDeviceInfo(Parent,&info);
            if (!NT_SUCCESS(status)) {
                ASSERT(FALSE);
                goto cleanup;
            }
            
            status = MfCreatePdo(Parent, &pdo);
            if (NT_SUCCESS(status)) {
                child = (PMF_CHILD_EXTENSION) pdo->DeviceExtension;
                child->Info = info;
                child->Common.DeviceState |= MF_DEVICE_ENUMERATED;
            } else {
                MfFreeDeviceInfo(&info);
            }
        } else {
            RtlFreeUnicodeString(&childName);
        }

        ZwClose(childHandle);
        index++;
    }

    ZwClose(parentHandle);

    return STATUS_SUCCESS;

cleanup:

    if (parentHandle) {
        ZwClose(parentHandle);
    }

    if (childHandle) {
        ZwClose(childHandle);
    }

    return status;

}

NTSTATUS
MfEnumerateFromInterface(
    IN PMF_PARENT_EXTENSION Parent
    )

/*++

Routine Description:

    Allocates and initialies the Children list of PDOs for this MF device by
    querying its pdo for an interface

Arguments:

    Parent - The MF device that should be enumerated

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{

    NTSTATUS status;
    IO_STACK_LOCATION request;
    MF_ENUMERATION_INTERFACE interface;
    PDEVICE_OBJECT pdo;
    PMF_CHILD_EXTENSION child;
    MF_DEVICE_INFO info;
    ULONG index = 0;

    //
    // Send a query interface IRP to our parent's PDO
    //

    RtlZeroMemory(&request, sizeof(IO_STACK_LOCATION));
    RtlZeroMemory(&interface, sizeof(MF_ENUMERATION_INTERFACE));

    request.MajorFunction = IRP_MJ_PNP;
    request.MinorFunction = IRP_MN_QUERY_INTERFACE;
    request.Parameters.QueryInterface.InterfaceType = &GUID_MF_ENUMERATION_INTERFACE;
    request.Parameters.QueryInterface.Size = sizeof(MF_ENUMERATION_INTERFACE);
    request.Parameters.QueryInterface.Version = 1;
    request.Parameters.QueryInterface.Interface = (PINTERFACE) &interface;

    status = MfSendPnpIrp(Parent->PhysicalDeviceObject, &request, NULL);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    FOR_ALL_IN_LIST(MF_CHILD_EXTENSION, &Parent->Children, child) {

        child->Common.DeviceState &= ~MF_DEVICE_ENUMERATED;
    }

    for (;;) {

        RtlZeroMemory(&info, sizeof(info));
        //
        // Query the interface for the info
        //

        status = interface.EnumerateChild(interface.Context,
                                          index,
                                          &info
                                          );

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_NO_MORE_ENTRIES) {

                if (IsListEmpty(&Parent->Children)) {

                    //
                    // There wern't any children - fail
                    //
                    status = STATUS_UNSUCCESSFUL;
                    goto cleanup;
                }

                status = STATUS_SUCCESS;
                break;

            } else {
                goto cleanup;
            }
        }

        status = MfValidateDeviceInfo(Parent,&info);
        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        if (!MfIsChildEnumeratedAlready(Parent, &info.Name)) {

            //
            // Create a device object
            //

            status = MfCreatePdo(Parent, &pdo);
            if (NT_SUCCESS(status)) {
                child = (PMF_CHILD_EXTENSION) pdo->DeviceExtension;
                child->Info = info;
                child->Common.DeviceState |= MF_DEVICE_ENUMERATED;
            } else {
                MfFreeDeviceInfo(&info);
            }
        } else {
            child->Common.DeviceState |= MF_DEVICE_ENUMERATED;
            MfFreeDeviceInfo(&info);
        }
        index++;
    }

    interface.InterfaceDereference(interface.Context);

    return STATUS_SUCCESS;

cleanup:

    return status;
}

NTSTATUS
MfBuildDeviceID(
    IN PMF_PARENT_EXTENSION Parent,
    OUT PWSTR *DeviceID
    )

/*++

Routine Description:

    Constructs a device ID for the parent device

Arguments:

    Parent - Parent the device ID should be constructed for

    DeviceID - On success the device id

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{

#define MF_ENUMERATOR_STRING    L"MF\\"

    NTSTATUS status;
    PWSTR source, destination, id = NULL;
    ULONG idSize;
    PWCHAR deviceID;
    SIZE_T dummy;

    idSize = sizeof(MF_ENUMERATOR_STRING) + Parent->DeviceID.Length;

    id = ExAllocatePoolWithTag(PagedPool,
                               idSize,
                               MF_DEVICE_ID_TAG
                               );

    if (!id) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    //
    // First copy the enumerator prefix
    // the deviceID parameter points to the end of
    // this string.
    //
    if (FAILED(StringCbCopyEx(id,                        // Destination
                              idSize,                    // Destination buffer size
                              MF_ENUMERATOR_STRING,      // Source
                              &deviceID,                 // Ptr to end of the copy
                              &dummy,                    // bytes remaining in destination
                              0                          // Flags
                              ))) {
        ASSERT(FALSE);
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Now concatenate the device ID of the parent
    // to this enumerator prefix.  This means that
    // the deviceID variable points to the beginning of
    // this portion of the string.  StringCbCatN guarantees
    // NULL termination of the string.
    //
    if (FAILED(StringCbCatN(id,
                            idSize,
                            Parent->DeviceID.Buffer,
                            Parent->DeviceID.Length
                            ))) {
        ASSERT(FALSE);
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // replace each occurence of '\' in the device ID
    // portion with '#'
    //
    while (*deviceID != UNICODE_NULL) {
        
        ASSERT(*deviceID != L' ');

        if (*deviceID == L'\\') {
            *deviceID = L'#';
        }

        deviceID++;
    }
    
    *DeviceID = id;

    return STATUS_SUCCESS;

cleanup:

    if (id) {
        ExFreePool(id);
    }

    *DeviceID = NULL;

    return status;
}


NTSTATUS
MfBuildInstanceID(
    IN PMF_CHILD_EXTENSION Child,
    OUT PWSTR *InstanceID
    )

/*++

Routine Description:

    Constructs a instance ID for this child

Arguments:

    Child - Child the ID should be constructed for

    DeviceID - On success the device id

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{
    NTSTATUS status;
    PWSTR current, id = NULL;
    ULONG idSize;
    PWCHAR instancePtr;

    idSize = Child->Parent->InstanceID.Length + sizeof(L'#')
                + Child->Info.Name.Length + sizeof(UNICODE_NULL);

    id = ExAllocatePoolWithTag(PagedPool,
                               idSize,
                               MF_INSTANCE_ID_TAG
                               );

    if (!id) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }


    //
    // Copy the parents instance ID...
    //
    if (FAILED(StringCbCopyN(id,
                             idSize,
                             Child->Parent->InstanceID.Buffer,
                             Child->Parent->InstanceID.Length
                             ))) {
        ASSERT(FALSE);
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // ...then the '#'...
    //
    if (FAILED(StringCbCat(id, idSize, L"#"))) {

        ASSERT(FALSE);
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // ...the child name...
    //
    if (FAILED(StringCbCatN(id,
                           idSize,
                           Child->Info.Name.Buffer,
                           Child->Info.Name.Length
                           ))) {


        ASSERT(FALSE);
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    *InstanceID = id;

    return STATUS_SUCCESS;

cleanup:

    if (id) {
        ExFreePool(id);
    }

    *InstanceID = NULL;

    return status;

}

BOOLEAN
MfIsResourceShared(
    IN PMF_PARENT_EXTENSION Parent,
    IN UCHAR Index,
    IN ULONG Offset,
    IN ULONG Size
    )

/*++

Routine Description:

    Determines if the Parent resource of Index has been requested by more than
    one child, in which case the children wanting that resource should claim it
    shared.

Arguments:

    Parent - The parent device of the MF subtree.

    Index - The index of the parent resources we are interested in.

Return Value:

    TRUE if the resource is shared, FALSE otherwise

--*/

{

    PMF_CHILD_EXTENSION current;
    PUCHAR resource;
    PMF_VARYING_RESOURCE_ENTRY varyingResource;
    PLIST_ENTRY currentEntry;
    BOOLEAN result = FALSE;
    ULONG refCount = 0;


    //
    // Iterate through the list of children in the parent
    //

    MfAcquireChildrenLock(Parent);

    for (currentEntry = Parent->Children.Flink;
         currentEntry != &Parent->Children;
         currentEntry = currentEntry->Flink) {

        current = CONTAINING_RECORD(currentEntry,
                                    MF_CHILD_EXTENSION,
                                    ListEntry);

        //
        // Iterate through the array of descriptors
        //

        if (current->Info.ResourceMap) {

            FOR_ALL_IN_ARRAY(current->Info.ResourceMap->Resources,
                             current->Info.ResourceMap->Count,
                             resource) {

                if (*resource == Index) {

                    refCount++;

                    if (refCount > 1) {
                        result = TRUE;
                        goto out;
                    }
                }
            }
        }

        if (current->Info.VaryingResourceMap) {

            FOR_ALL_IN_ARRAY(current->Info.VaryingResourceMap->Resources,
                             current->Info.VaryingResourceMap->Count,
                             varyingResource) {

                //
                // If indexes are the same and ranges overlap, we have a reference
                //
                if ((varyingResource->ResourceIndex == Index) &&
                    ( ( Size == 0) ||
                      ( varyingResource->Offset >= Offset &&
                        varyingResource->Offset < Offset + Size) ||
                      ( Offset >= varyingResource->Offset &&
                        Offset < varyingResource->Offset + varyingResource->Size))) {

                    refCount++;

                    if (refCount > 1) {
                        result = TRUE;
                        goto out;
                    }
                }
            }
        }
    }

 out:
    MfReleaseChildrenLock(Parent);
    return result;
}

NTSTATUS
MfBuildChildRequirements(
    IN PMF_CHILD_EXTENSION Child,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList
    )

/*++

Routine Description:

    Constructs a requirements list for Child based on the resources allocated
    to the childs parent

Arguments:

    Child - Child the requirements list is to be built for

    RequirementsList - On success a pointer to the list

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{
    NTSTATUS status;
    ULONG size, count = 0;
    PIO_RESOURCE_REQUIREMENTS_LIST requirements = NULL;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PCHAR resource;
    PMF_VARYING_RESOURCE_ENTRY varyingResource;

    //
    // Check if we have a resource list.  If not, then MF has been
    // loaded on device that doesn't consume resources.  As a result,
    // the children can't consume resources either.
    //

    if (Child->Parent->ResourceList == NULL) {
        *RequirementsList = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Calculate the size of the resource list
    //

    if (Child->Info.VaryingResourceMap) {

        count += Child->Info.VaryingResourceMap->Count;
    }

    if (Child->Info.ResourceMap) {

        count += Child->Info.ResourceMap->Count;
    }

    //
    // Allocate the buffer
    //

    size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
                (count-1) * sizeof(IO_RESOURCE_DESCRIPTOR);

    requirements = ExAllocatePoolWithTag(PagedPool,
                                         size,
                                         MF_CHILD_REQUIREMENTS_TAG
                                         );
    if (!requirements) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    //
    // Build the list
    //
    RtlZeroMemory(requirements, size);

    requirements->ListSize = size;
    requirements->InterfaceType = Child->Parent->ResourceList->List[0].InterfaceType;
    requirements->BusNumber = Child->Parent->ResourceList->List[0].BusNumber;
    requirements->AlternativeLists = 1;
    requirements->List[0].Version = MF_CM_RESOURCE_VERSION;
    requirements->List[0].Revision = MF_CM_RESOURCE_REVISION;
    requirements->List[0].Count = count;

    descriptor = requirements->List[0].Descriptors;

    if (Child->Info.ResourceMap) {

        FOR_ALL_IN_ARRAY(Child->Info.ResourceMap->Resources,
                         Child->Info.ResourceMap->Count,
                         resource) {

            status = MfParentResourceToChildRequirement(Child->Parent,
                                                        Child,
                                                        *resource,
                                                        0,
                                                        0,
                                                        descriptor
                                                        );

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

            descriptor++;

        }
    }

    if (Child->Info.VaryingResourceMap) {

         FOR_ALL_IN_ARRAY(Child->Info.VaryingResourceMap->Resources,
                          Child->Info.VaryingResourceMap->Count,
                          varyingResource) {

             status = MfParentResourceToChildRequirement(Child->Parent,
                                                         Child,
                                                         varyingResource->ResourceIndex,
                                                         varyingResource->Offset,
                                                         varyingResource->Size,
                                                         descriptor
                                                         );

             if (!NT_SUCCESS(status)) {
                 goto cleanup;
             }

             descriptor++;

         }
     }


    *RequirementsList = requirements;

    return STATUS_SUCCESS;

cleanup:

    *RequirementsList = NULL;

    if (requirements) {
        ExFreePool(requirements);
    }

    return status;

}

NTSTATUS
MfParentResourceToChildRequirement(
    IN PMF_PARENT_EXTENSION Parent,
    IN PMF_CHILD_EXTENSION Child,
    IN UCHAR Index,
    IN ULONG Offset OPTIONAL,
    IN ULONG Size OPTIONAL,
    OUT PIO_RESOURCE_DESCRIPTOR Requirement
    )
/*++

Routine Description:

    This function build an requirements descriptor for a resource the parent is
    started with.

Arguments:

    Parent - The parent device of the MF subtree.

    Index - The index of the parent resources we are interested in.

    Offset - The offset within the parent resource of the requirement.
        This is actually used as an index into a table stored in the parent
        resource list describing the mapping from this given offset to the
        real offset to be used.  This allows for varying resource maps to
        access the same offset within the same resource and get a different
        requirement.  If Size == 0, this is ignored.

    Size - The length of the requirement.  If set to 0, it is assumed to be
        the length of the parent resource.

    Requirement - Pointer to a descriptor that should be filled in

Return Value:

    Success or otherwise of the operation

--*/
{
    NTSTATUS status;
    CM_PARTIAL_RESOURCE_DESCRIPTOR resource;
    PMF_RESOURCE_TYPE resType;
    ULONG effectiveOffset;
    ULONGLONG resourceStart;
    ULONG dummyLength;

    ASSERT(Parent->ResourceList->Count == 1);

    //
    // Bounds check the index
    //

    if (Index > Parent->ResourceList->List[0].PartialResourceList.Count) {

        if (Child->Info.MfFlags & MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE) {
            //
            // Fill in a null resource list
            //

            RtlZeroMemory(Requirement, sizeof(IO_RESOURCE_DESCRIPTOR));
            Requirement->Type = CmResourceTypeNull;
            return STATUS_SUCCESS;
        }

        return STATUS_INVALID_PARAMETER;
    }

    RtlCopyMemory(&resource,
                  &Parent->ResourceList->List[0].PartialResourceList.PartialDescriptors[Index],
                  sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

    //
    // Find the appropriate resource type for the resource -> requirement
    // function if this is an arbitrated resource
    //

    if (!(resource.Type & CmResourceTypeNonArbitrated)) {

        resType = MfFindResourceType(resource.Type);

        if (!resType) {

            DEBUG_MSG(1,
                      ("Unknown resource type %i at parent index 0x%x\n",
                       resource.Type,
                       Index
                      ));


            return STATUS_INVALID_PARAMETER;
        }

        //
        // update the resource with the correct offset and length
        // if size == 0 we assume it is optional and don't do the update
        //

        if (Size) {

            status = resType->UnpackResource(&resource,
                                        &resourceStart,
                                        &dummyLength);

            if (!NT_SUCCESS(status)) {
                return status;
            }

            status = resType->UpdateResource(&resource,
                                        resourceStart+Offset,
                                        Size
                                        );

            if (!NT_SUCCESS(status)) {
                return status;
            }

        }
        //
        // Convert the resource to a requirement
        //

        status = resType->RequirementFromResource(&resource, Requirement);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Update the share disposition if necessary
        //            

        if (MfIsResourceShared(Parent, Index, Offset, Size)) {
            Requirement->ShareDisposition =  CmResourceShareShared;
        }

    } else {

        //
        // This is a non-arbitrated resource so it is modled after a device
        // private, just copy the data
        //

        Requirement->Type = resource.Type;
        Requirement->ShareDisposition =  resource.ShareDisposition;
        Requirement->Flags = resource.Flags;
        Requirement->u.DevicePrivate.Data[0] = resource.u.DevicePrivate.Data[0];
        Requirement->u.DevicePrivate.Data[1] = resource.u.DevicePrivate.Data[1];
        Requirement->u.DevicePrivate.Data[2] = resource.u.DevicePrivate.Data[2];

    }

    return STATUS_SUCCESS;
}

BOOLEAN
MfIsChildEnumeratedAlready(
    PMF_PARENT_EXTENSION Parent,
    PUNICODE_STRING ChildName
    )
/*++

Routine Description:

    This function checks whether a child with this name has already
    been enumerated.

Arguments:

    Parent - The parent device of the MF subtree.

    ChildName - unicode string to compare to existing child names

Return Value:

    TRUE or FALSE

--*/
{
    PMF_CHILD_EXTENSION currentChild;
    PLIST_ENTRY currentEntry;
    BOOLEAN result = FALSE;

    for (currentEntry = Parent->Children.Flink;
         currentEntry != &Parent->Children;
         currentEntry = currentEntry->Flink) {

        currentChild = CONTAINING_RECORD(currentEntry,
                                         MF_CHILD_EXTENSION,
                                         ListEntry);

        //
        // Comparison is case-sensitive because there is no reason it
        // shouldn't be.
        //

        if (RtlEqualUnicodeString(&currentChild->Info.Name,
                                  ChildName,
                                  FALSE)) {
            result = TRUE;
            break;
        }
    }

    return result;
}

NTSTATUS
MfValidateDeviceInfo(
    IN PMF_PARENT_EXTENSION Parent,
    IN PMF_DEVICE_INFO DeviceInfo
    )
/*++

Routine Description:

    This routine validates that an MF_DEVICE_INFO structure read either from an interface
    or the registry is valid.
    
Arguments:

    Parent - The parent device for which the MF_DEVICE_INFO structure represents a child.
    
    DeviceInfo - The structure to validate.
    
Return Value:

    STATUS_SUCCESS if validation was successful.
    STATUS_UNSUCCESSFUL otherwise.
    
--*/
{
    ULONG i, parentResCount, parentResLength;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR parentResources;
    PMF_VARYING_RESOURCE_ENTRY varyingResource;

    if (Parent->ResourceList) {
        
        parentResCount = Parent->ResourceList->List[0].PartialResourceList.Count;
        parentResources = Parent->ResourceList->List[0].PartialResourceList.PartialDescriptors;    
    
    } else {
        
        //
        // The parent has no resources, so the device better not have
        // any resource maps.
        //
        if (DeviceInfo->ResourceMap || DeviceInfo->VaryingResourceMap) {
            
            return STATUS_UNSUCCESSFUL;
        }
    }
    

    //
    // Make sure that each entry in the resource map points to a valid resource
    // of the parent device.
    //
    if (DeviceInfo->ResourceMap) {
        
        for (i=0; i<DeviceInfo->ResourceMap->Count; i++) {
    
            if (DeviceInfo->ResourceMap->Resources[i] >= parentResCount) {
                return STATUS_UNSUCCESSFUL;
            }
        }   
    }
    
    //
    // Make sure that each entry in the varying resource map points to a valid
    // resource of the parent device, and additionally, make sure that the 
    // offset/length in the varying resource map entry are a subset of the
    // corresponding resource in the parent device.
    //
    if (DeviceInfo->VaryingResourceMap) {
        
        for (i=0; i<DeviceInfo->VaryingResourceMap->Count; i++) {
            
            varyingResource = &DeviceInfo->VaryingResourceMap->Resources[i];
    
            if (varyingResource->ResourceIndex >= parentResCount) {
                return STATUS_UNSUCCESSFUL;
            }
            
            parentResLength = parentResources[varyingResource->ResourceIndex].u.Generic.Length;

            if ((varyingResource->Offset >= parentResLength) ||
                (varyingResource->Size > parentResLength) ||
                ((varyingResource->Offset + varyingResource->Size) > parentResLength)) {
                
                return STATUS_UNSUCCESSFUL;
            }
        }    
    }
    

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\mf\debug.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This header provides debugging support prototypes and macros

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#if !defined(_DEBUG_)
#define DEBUG

#if DBG

typedef struct _MF_STRING_MAP {
    ULONG Id;
    PCHAR String;
} MF_STRING_MAP, *PMF_STRING_MAP;

//
// Debug globals
//

extern LONG MfDebug;
extern MF_STRING_MAP MfDbgPnpIrpStringMap[];
extern MF_STRING_MAP MfDbgPoIrpStringMap[];
extern MF_STRING_MAP MfDbgDeviceRelationStringMap[];
extern MF_STRING_MAP MfDbgSystemPowerStringMap[];
extern MF_STRING_MAP MfDbgDevicePowerStringMap[];
extern PMF_STRING_MAP MfDbgStatusStringMap;

//
// Debug prototypes
//

VOID
MfDbgInitialize(
    VOID
    );

VOID
MfDbgPrintMultiSz(
    LONG DebugLevel,
    PWSTR MultiSz
    );

PCHAR
MfDbgLookupString(
    IN PMF_STRING_MAP Map,
    IN ULONG Id
    );

VOID
MfDbgPrintResourceMap(
    LONG DebugLevel,
    PMF_RESOURCE_MAP Map
    );

VOID
MfDbgPrintVaryingResourceMap(
    LONG DebugLevel,
    PMF_VARYING_RESOURCE_MAP Map
    );

VOID
MfDbgPrintCmResList(
    IN LONG Level,
    IN PCM_RESOURCE_LIST ResourceList
    );

VOID
MfDbgPrintIoResReqList(
    IN LONG Level,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResReqList
    );

PUCHAR
MfDbgCmResourceTypeToText(
    UCHAR Type
    );


//
// Debug macros
//

#define DEBUG_PRINT(Level, Msg)                                             \
    if (Level <= MfDebug) DbgPrint Msg

#define DEBUG_MSG(Level, Msg)                                               \
    if (Level <= MfDebug) { DbgPrint("Mf: "); DbgPrint Msg; }

#define ASSERT_MF_DEVICE(DeviceObject)                                      \
    ASSERT(((PMF_COMMON_EXTENSION)DeviceObject->DeviceExtension)->Type      \
                == MfFunctionalDeviceObject                                 \
          ||                                                                \
           ((PMF_COMMON_EXTENSION)DeviceObject->DeviceExtension)->Type      \
                == MfPhysicalDeviceObject)


#define STATUS_STRING(_Status)                                              \
    (_Status) == STATUS_SUCCESS ?                                           \
        "STATUS_SUCCESS" : MfDbgLookupString(MfDbgStatusStringMap, (_Status))

#define PNP_IRP_STRING(_Irp)                                                \
    MfDbgLookupString(MfDbgPnpIrpStringMap, (_Irp))

#define PO_IRP_STRING(_Irp)                                                 \
    MfDbgLookupString(MfDbgPoIrpStringMap, (_Irp))

#define RELATION_STRING(_Relation)                                          \
    MfDbgLookupString(MfDbgDeviceRelationStringMap, (_Relation))

#define SYSTEM_POWER_STRING(_State)                                         \
    MfDbgLookupString(MfDbgSystemPowerStringMap, (_State))

#define DEVICE_POWER_STRING(_State)                                         \
    MfDbgLookupString(MfDbgDevicePowerStringMap, (_State))



#else

#define DEBUG_PRINT(Level, Msg) 
#define DEBUG_MSG(Level, Msg)
#define ASSERT_MF_DEVICE(DeviceObject)
#define STATUS_STRING(_Status)      ""
#define PNP_IRP_STRING(_Irp)        ""
#define PO_IRP_STRING(_Irp)         ""
#define RELATION_STRING(_Relation)  ""
#define SYSTEM_POWER_STRING(_State) ""
#define DEVICE_POWER_STRING(_State) ""

#endif // DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\mf\dispatch.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module provides the functions which dispatch IRPs to FDOs and PDOs.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#include "mfp.h"

NTSTATUS
MfAddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
MfDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MfDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MfDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, MfAddDevice)
#pragma alloc_text(PAGE, MfDispatchPnp)
#pragma alloc_text(PAGE, MfForwardIrpToParent)
#pragma alloc_text(PAGE, MfDispatchNop)

#endif

NTSTATUS
MfAddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    Given a physical device object, this routine creates a functional
    device object for it and attaches it to the top of the stack.

Arguments:

    DriverObject - Pointer to our driver's DRIVER_OBJECT structure.

    PhysicalDeviceObject - Pointer to the physical device object for which
                           we must create a functional device object.

Return Value:

    NT status.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT fdo = NULL;
    PMF_PARENT_EXTENSION extension;

    ASSERT(DriverObject == MfDriverObject);

    PAGED_CODE();

    //
    // Create our FDO
    //

    status = MfCreateFdo(&fdo);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    extension = fdo->DeviceExtension;

    extension->PhysicalDeviceObject = PhysicalDeviceObject;

    //
    // Attach to the stack
    //

    extension->AttachedDevice = IoAttachDeviceToDeviceStack(
                                    fdo,
                                    PhysicalDeviceObject
                                    );

    if (!extension->AttachedDevice) {

        //
        // Could not attach
        //

        status = STATUS_NO_SUCH_DEVICE;
        goto cleanup;
    }

    fdo->Flags |= DO_POWER_PAGABLE;
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    DEBUG_MSG(1, ("Completed AddDevice for PDO 0x%08x\n", PhysicalDeviceObject));

    return STATUS_SUCCESS;

cleanup:

    if (fdo) {
        IoDeleteDevice(fdo);
    }

    return status;
}

NTSTATUS
MfDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP IRPs for this driver.  It dispatches to
    the appropriate fdo/pdo routine.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PMF_COMMON_EXTENSION common;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    ASSERT_MF_DEVICE(DeviceObject);

    common = (PMF_COMMON_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    if (IS_FDO(common)) {
        return MfDispatchPnpFdo(DeviceObject,
                                (PMF_PARENT_EXTENSION) common,
                                irpStack,
                                Irp
                                );
    } else {
        return MfDispatchPnpPdo(DeviceObject,
                                (PMF_CHILD_EXTENSION) common,
                                irpStack,
                                Irp
                                );
    }
}

NTSTATUS
MfDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for this driver.  It dispatches
    to the routines described in the PoDispatchTable entry in the device object
    extension.

    This routine is NOT pageable as it can be called at DISPATCH_LEVEL

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/


{
    NTSTATUS status;
    PMF_COMMON_EXTENSION common;
    PIO_STACK_LOCATION irpStack;

    ASSERT_MF_DEVICE(DeviceObject);

    //
    // Find out who we are and what we need to do
    //

    common = (PMF_COMMON_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);

    if (IS_FDO(common)) {
        return MfDispatchPowerFdo(DeviceObject,
                                  (PMF_PARENT_EXTENSION) common,
                                  irpStack,
                                  Irp);
    } else {
        return MfDispatchPowerPdo(DeviceObject,
                                  (PMF_CHILD_EXTENSION) common,
                                  irpStack,
                                  Irp);
    }
}

NTSTATUS
MfIrpNotSupported(
    IN PIRP Irp,
    IN PVOID Extension,
    IN PIO_STACK_LOCATION IrpStack
    )
/*++

Routine Description:

    This function handles the unsupported IRPs for both mf PDOs and FDOs

    This is NOT paged because is can be called from MfDispatchPower which can
    be called at DISPATCH_LEVEL

Arguments:

    Irp - Points to the IRP associated with this request.

    Extension - Points to the device extension.

    IrpStack - Points to the current stack location for this request.

Return Value:

    STATUS_NOT_SUPPORTED

--*/

{
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Extension);
    UNREFERENCED_PARAMETER(IrpStack);

    DEBUG_MSG(1, ("Skipping upsupported IRP\n"));

    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
MfForwardIrpToParent(
    IN PIRP Irp,
    IN PMF_CHILD_EXTENSION Child,
    IN PIO_STACK_LOCATION IrpStack
    )

/*++

Routine Description:

    This function builds a new Pnp irp and sends it to the parent device,
    returning the status and information to the child stack

Arguments:

    Irp - Points to the IRP associated with this request.

    Parent - Points to the parent FDO's device extension.

    IrpStack - Points to the current stack location for this request.

Return Value:

    The status of the IRP from the parent stack.

--*/

{
    PAGED_CODE();

    DEBUG_MSG(1, ("\tForwarding IRP to parent stack\n"));

    ASSERT(Child->Common.Type == MfPhysicalDeviceObject);
    ASSERT(IrpStack->MajorFunction == IRP_MJ_PNP);

    return MfSendPnpIrp(Child->Parent->Self,
                        IrpStack,
                        &Irp->IoStatus.Information
                        );
}


NTSTATUS
MfDispatchNop(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles irps like IRP_MJ_DEVICE_CONTROL, which we don't support.
    This handler will complete the irp (if PDO) or pass it (if FDO).

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PMF_COMMON_EXTENSION common;
    PDEVICE_OBJECT attachedDevice;

    PAGED_CODE();

    ASSERT_MF_DEVICE(DeviceObject);

    common = (PMF_COMMON_EXTENSION) DeviceObject->DeviceExtension;

    if (IS_FDO(common)) {

        attachedDevice = ((PMF_PARENT_EXTENSION) common)->AttachedDevice;

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(attachedDevice, Irp);

    } else {

        status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\mf\init.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module provides the initialization and unload functions.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "mfp.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MfUnload(
    IN PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, MfUnload)
#endif

PDRIVER_OBJECT MfDriverObject;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    
    This is the entry point to MF.SYS and performs initialization.
    
Arguments:

    DriverObject - The system owned driver object for MF
    
    RegistryPath - The path to MF's service entry
    
Return Value:

    STATUS_SUCCESS

--*/
{

    DriverObject->DriverExtension->AddDevice = MfAddDevice;
    DriverObject->MajorFunction[IRP_MJ_PNP] = MfDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = MfDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MfDispatchNop;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = MfDispatchNop;
    DriverObject->DriverUnload = MfUnload;

    //
    // Remember the driver object
    //

    MfDriverObject = DriverObject;

    DEBUG_MSG(1, ("Completed DriverEntry for Driver 0x%08x\n", DriverObject));
    
    return STATUS_SUCCESS;
}

VOID
MfUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:
    
    This is called to reverse any operations performed in DriverEntry before a
    driver is unloaded.
        
Arguments:

    DriverObject - The system owned driver object for MF
    
Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();
    
    DEBUG_MSG(1, ("Completed Unload for Driver 0x%08x\n", DriverObject));
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\mf\fdo.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    fdo.c

Abstract:

    This module provides the functions which answer IRPs to functional devices.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "mfp.h"

/*++

The majority of functions in this file are called based on their presence
in Pnp and Po dispatch tables.  In the interests of brevity the arguments
to all those functions will be described below:

NTSTATUS
MfXxxFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )

Routine Description:

    This function handles the Xxx requests for multifunction FDO's

Arguments:

    Irp - Points to the IRP associated with this request.

    Parent - Points to the parent FDO's device extension.

    IrpStack - Points to the current stack location for this request.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NOT_SUPPORTED indicates that the IRP should be passed down without
    changing the Irp->IoStatus.Status field otherwise it is updated with this
    status.

--*/


NTSTATUS
MfDeferProcessingFdo(
    IN PMF_PARENT_EXTENSION Parent,
    IN OUT PIRP Irp
    );

NTSTATUS
MfStartFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfStartFdoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
MfStartFdoInitializeArbiters(
    IN PMF_PARENT_EXTENSION Parent,
    IN PCM_RESOURCE_LIST ResList,
    IN PCM_RESOURCE_LIST TranslatedResList
    );

NTSTATUS
MfQueryStopFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfCancelStopFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfQueryRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfSurpriseRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfCancelRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfQueryDeviceRelationsFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfQueryInterfaceFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfQueryCapabilitiesFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfQueryPowerFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfSetPowerFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfPassIrp(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, MfCancelRemoveFdo)
#pragma alloc_text(PAGE, MfCancelStopFdo)
#pragma alloc_text(PAGE, MfCreateFdo)
#pragma alloc_text(PAGE, MfDeferProcessingFdo)
#pragma alloc_text(PAGE, MfDispatchPnpFdo)
#pragma alloc_text(PAGE, MfPassIrp)
#pragma alloc_text(PAGE, MfQueryCapabilitiesFdo)
#pragma alloc_text(PAGE, MfQueryDeviceRelationsFdo)
#pragma alloc_text(PAGE, MfQueryInterfaceFdo)
#pragma alloc_text(PAGE, MfQueryRemoveFdo)
#pragma alloc_text(PAGE, MfQueryStopFdo)
#pragma alloc_text(PAGE, MfRemoveFdo)
#pragma alloc_text(PAGE, MfStartFdo)
#pragma alloc_text(PAGE, MfStartFdoInitializeArbiters)
#pragma alloc_text(PAGE, MfSurpriseRemoveFdo)
#endif


PMF_DISPATCH MfPnpDispatchTableFdo[] = {

    MfStartFdo,                     // IRP_MN_START_DEVICE
    MfQueryRemoveFdo,               // IRP_MN_QUERY_REMOVE_DEVICE
    MfRemoveFdo,                    // IRP_MN_REMOVE_DEVICE
    MfCancelRemoveFdo,              // IRP_MN_CANCEL_REMOVE_DEVICE
    MfPassIrp,                      // IRP_MN_STOP_DEVICE
    MfQueryStopFdo,                 // IRP_MN_QUERY_STOP_DEVICE
    MfCancelStopFdo,                // IRP_MN_CANCEL_STOP_DEVICE
    MfQueryDeviceRelationsFdo,      // IRP_MN_QUERY_DEVICE_RELATIONS
    MfQueryInterfaceFdo,            // IRP_MN_QUERY_INTERFACE
    MfQueryCapabilitiesFdo,         // IRP_MN_QUERY_CAPABILITIES
    MfPassIrp,                      // IRP_MN_QUERY_RESOURCES
    MfPassIrp,                      // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    MfPassIrp,                      // IRP_MN_QUERY_DEVICE_TEXT
    MfPassIrp,                      // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    MfPassIrp,                      // Unused
    MfPassIrp,                      // IRP_MN_READ_CONFIG
    MfPassIrp,                      // IRP_MN_WRITE_CONFIG
    MfPassIrp,                      // IRP_MN_EJECT
    MfPassIrp,                      // IRP_MN_SET_LOCK
    MfPassIrp,                      // IRP_MN_QUERY_ID
    MfPassIrp,                      // IRP_MN_QUERY_PNP_DEVICE_STATE
    MfPassIrp,                      // IRP_MN_QUERY_BUS_INFORMATION
    MfDeviceUsageNotificationCommon,// IRP_MN_DEVICE_USAGE_NOTIFICATION
    MfSurpriseRemoveFdo,            // IRP_MN_SURPRISE_REMOVAL
    MfPassIrp                       // IRP_MN_QUERY_LEGACY_BUS_INFORMATION
};

PMF_DISPATCH MfPoDispatchTableFdo[] = {

    NULL,                           // IRP_MN_WAIT_WAKE
    NULL,                           // IRP_MN_POWER_SEQUENCE
    MfSetPowerFdo,                  // IRP_MN_SET_POWER
    MfQueryPowerFdo                 // IRP_MN_QUERY_POWER

};


NTSTATUS
MfCreateFdo(
    OUT PDEVICE_OBJECT *Fdo
    )
/*++

Routine Description:

    This function creates a new FDO and initializes it.

Arguments:

    Fdo - Pointer to where the FDO should be returned

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{

    NTSTATUS status;
    PMF_PARENT_EXTENSION extension;

    PAGED_CODE();

    ASSERT((sizeof(MfPnpDispatchTableFdo) / sizeof(PMF_DISPATCH)) - 1
           == IRP_MN_PNP_MAXIMUM_FUNCTION);

    ASSERT((sizeof(MfPoDispatchTableFdo) / sizeof(PMF_DISPATCH)) -1
       == IRP_MN_PO_MAXIMUM_FUNCTION);

    *Fdo = NULL;

    status = IoCreateDevice(MfDriverObject,
                            sizeof(MF_PARENT_EXTENSION),
                            NULL,
                            FILE_DEVICE_BUS_EXTENDER,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            Fdo
                           );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }
    
    //
    // Initialize the extension
    //

    extension = (PMF_PARENT_EXTENSION) (*Fdo)->DeviceExtension;

    MfInitCommonExtension(&extension->Common, MfFunctionalDeviceObject);
    extension->Self = *Fdo;

    InitializeListHead(&extension->Arbiters);

    InitializeListHead(&extension->Children);
    KeInitializeEvent(&extension->ChildrenLock, SynchronizationEvent, TRUE);

    KeInitializeSpinLock(&extension->PowerLock);

    IoInitializeRemoveLock(&extension->RemoveLock, MF_POOL_TAG, 1, 20);

    extension->Common.PowerState = PowerDeviceD3;

    DEBUG_MSG(1, ("Created FDO @ 0x%08x\n", *Fdo));

    return status;

cleanup:

    if (*Fdo) {
        IoDeleteDevice(*Fdo);
    }

    return status;

}

VOID
MfAcquireChildrenLock(
    IN PMF_PARENT_EXTENSION Parent
    )
{
    KeWaitForSingleObject(&Parent->ChildrenLock,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL);
}

VOID
MfReleaseChildrenLock(
    IN PMF_PARENT_EXTENSION Parent
    )
{
    KeSetEvent(&Parent->ChildrenLock, 0, FALSE);
}

VOID
MfDeleteFdo(
    IN PDEVICE_OBJECT Fdo
    )
{
    PMF_PARENT_EXTENSION parent = Fdo->DeviceExtension;
    PMF_ARBITER current, next;

    if (parent->Common.DeviceState & MF_DEVICE_DELETED) {
        //
        // Trying to delete twice
        //
        ASSERT(!(parent->Common.DeviceState & MF_DEVICE_DELETED));
        return;
    }

    parent->Common.DeviceState = MF_DEVICE_DELETED;

    //
    // Free up any memory we have allocated
    //

    if (parent->ResourceList) {
        ExFreePool(parent->ResourceList);
        parent->ResourceList = NULL;
    }

    if (parent->TranslatedResourceList) {
        ExFreePool(parent->TranslatedResourceList);
        parent->TranslatedResourceList = NULL;
    }

    if (parent->DeviceID.Buffer) {
        RtlFreeUnicodeString(&parent->DeviceID);
    }

    if (parent->InstanceID.Buffer) {
        RtlFreeUnicodeString(&parent->InstanceID);
    }

    FOR_ALL_IN_LIST_SAFE(MF_ARBITER, &parent->Arbiters, current, next) {
        
        RemoveEntryList(&current->ListEntry);
        ArbDeleteArbiterInstance(&current->Instance);
        ExFreePool(current);
    }
    
    ASSERT(IsListEmpty(&parent->Children));

    IoDeleteDevice(Fdo);

    DEBUG_MSG(1, ("Deleted FDO @ 0x%08x\n", Fdo));

}

NTSTATUS
MfPassIrp(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PAGED_CODE();

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(Parent->AttachedDevice, Irp);
}

NTSTATUS
MfDispatchPnpFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_PNP IRPs for FDOs.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Parent - FDO extension

    IrpStack - Current stack location

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    BOOLEAN isRemoveDevice;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    IoAcquireRemoveLock(&Parent->RemoveLock, (PVOID) Irp);

    isRemoveDevice = IrpStack->MinorFunction == IRP_MN_REMOVE_DEVICE;

    if (IrpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {

        status = MfPassIrp(Irp, Parent, IrpStack);

    } else {

        status =
            MfPnpDispatchTableFdo[IrpStack->MinorFunction](Irp,
                                                          Parent,
                                                          IrpStack
                                                          );
    }

    if (!isRemoveDevice) {
        IoReleaseRemoveLock(&Parent->RemoveLock, (PVOID) Irp);
    }

    return status;
}

NTSTATUS
MfPnPFdoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine triggers the event to indicate that processing of the
    irp can now continue.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    KeSetEvent((PKEVENT) Context, EVENT_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
MfDeferProcessingFdo(
    IN PMF_PARENT_EXTENSION Parent,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine uses an IoCompletion routine along with an event to
    wait until the lower level drivers have completed processing of
    the irp.

Arguments:

    Parent - FDO extension for the FDO devobj in question

    Irp - Pointer to the IRP_MJ_PNP IRP to defer

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Set our completion routine
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           MfPnPFdoCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );
    status =  IoCallDriver(Parent->AttachedDevice, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
MfStartFdoInitializeArbiters(
    IN PMF_PARENT_EXTENSION Parent,
    IN PCM_RESOURCE_LIST ResList,
    IN PCM_RESOURCE_LIST TranslatedResList
    )
{

    NTSTATUS status;
    ULONG size;
    ULONG count;

    PAGED_CODE();

    DEBUG_MSG(1, ("Start Fdo arbiters intiialization\n"));

    //
    // If we were started with any resources then remember them
    //

    if (ResList && TranslatedResList) {

#if DBG
        MfDbgPrintCmResList(1, ResList);
#endif

        //
        // We only deal with resources on a single bus - which is all we
        // should see in a start irp.
        //

        ASSERT(ResList->Count == 1);
        ASSERT(TranslatedResList->Count == 1);

        //
        // Both lists should have the same number of descriptors
        //

        ASSERT(ResList->List[0].PartialResourceList.Count == TranslatedResList->List[0].PartialResourceList.Count);
        if (ResList->List[0].PartialResourceList.Count != TranslatedResList->List[0].PartialResourceList.Count) {
            
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Calculate the size of the resouceList
        //

        size = sizeof(CM_RESOURCE_LIST) +
               ((ResList->List[0].PartialResourceList.Count - 1) *
                sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

        //
        // Allocate a buffer and copy the data
        //

        Parent->ResourceList = ExAllocatePoolWithTag(NonPagedPool,
                                                     size,
                                                     MF_PARENTS_RESOURCE_TAG
                                                     );

        if (!Parent->ResourceList) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        RtlCopyMemory(Parent->ResourceList, ResList, size);

        //
        // do the same for the TranslatedResList.
        //

        Parent->TranslatedResourceList = ExAllocatePoolWithTag(NonPagedPool,
                                                               size,
                                                               MF_PARENTS_RESOURCE_TAG
                                                               );

        if (!Parent->TranslatedResourceList) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        RtlCopyMemory(Parent->TranslatedResourceList, TranslatedResList, size);

        //
        // As we have resources we are going to need some arbiters
        //

        status = MfInitializeArbiters(Parent);
        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

    } else {

        DEBUG_MSG(1, ("Parent started with no resources\n"));
    }

    return STATUS_SUCCESS;

cleanup:

    if (Parent->ResourceList) {
        ExFreePool(Parent->ResourceList);
        Parent->ResourceList = NULL;
    }

    if (Parent->TranslatedResourceList) {
        ExFreePool(Parent->TranslatedResourceList);
        Parent->TranslatedResourceList = NULL;
    }

    return status;
}

// REBALANCE
//
// FUTURE DESIGN NOTE:
// If rebalance was actually supported by this component i.e arbiters
// become stoppable, then there are various issues raised by the start
// code.  It performs a number of operations assuming that the device
// has never been started before including the query ids, resource
// list storage, etc.  There are also issues in redistributing these
// new resources to the children.  The current requirements given to
// the children are absolute.  Relative requirements have some other
// issues.
//

NTSTATUS
MfStartFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;
    IO_STACK_LOCATION location;
    PWSTR string;

    PAGED_CODE();

    status = MfDeferProcessingFdo(Parent, Irp);
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    Parent->Common.PowerState = PowerDeviceD0;

    //
    // We need to find out some information about our parent
    //

    Parent->DeviceID.Buffer = NULL;
    Parent->InstanceID.Buffer = NULL;

    RtlZeroMemory(&location, sizeof(IO_STACK_LOCATION));
    location.MajorFunction = IRP_MJ_PNP;
    location.MinorFunction = IRP_MN_QUERY_ID;

    //
    // ...DeviceID...
    //

    location.Parameters.QueryId.IdType = BusQueryDeviceID;

    status = MfSendPnpIrp(Parent->PhysicalDeviceObject,
                          &location,
                          (PULONG_PTR)&string
                          );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    RtlInitUnicodeString(&Parent->DeviceID, string);

    DEBUG_MSG(1, ("Parent DeviceID: %wZ\n", &Parent->DeviceID));

    //
    // ...InstanceID
    //

    location.Parameters.QueryId.IdType = BusQueryInstanceID;

    status = MfSendPnpIrp(Parent->PhysicalDeviceObject,
                          &location,
                          (PULONG_PTR)&string
                          );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    RtlInitUnicodeString(&Parent->InstanceID, string);

    DEBUG_MSG(1, ("Parent InstanceID: %wZ\n", &Parent->InstanceID));

    status = MfStartFdoInitializeArbiters(
                 Parent,
                 IrpStack->Parameters.StartDevice.AllocatedResources,
                 IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated
                 );

cleanup:

    Irp->IoStatus.Status = status;
    if (!NT_SUCCESS(status)) {
        if (Parent->DeviceID.Buffer) {
            ExFreePool(Parent->DeviceID.Buffer);
            Parent->DeviceID.Buffer = NULL;
        }

        if (Parent->InstanceID.Buffer) {
            ExFreePool(Parent->InstanceID.Buffer);
            Parent->InstanceID.Buffer = NULL;
        }
    } else {
        //
        // We are now started!
        //
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
MfQueryStopFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{

    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
MfCancelStopFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = MfDeferProcessingFdo(Parent, Irp);
    // NTRAID#53498
    // ASSERT(status == STATUS_SUCCESS);
    // Uncomment after PCI state machine is fixed to not fail bogus stops

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
MfQueryRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return MfPassIrp(Irp, Parent, IrpStack);
}

NTSTATUS
MfRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PMF_CHILD_EXTENSION current;
    PLIST_ENTRY currentEntry;
    NTSTATUS status;

    //
    // If we have any children then make sure they are removed and
    // delete them.
    //

    MfAcquireChildrenLock(Parent);

    while (!IsListEmpty(&Parent->Children)) {

        currentEntry = RemoveHeadList(&Parent->Children);
        ASSERT(currentEntry);

        current = CONTAINING_RECORD(currentEntry, MF_CHILD_EXTENSION,
                                    ListEntry);

        //
        // * If this child has been surprise removed, and hasn't
        // received the subsequent remove, then leave
        // the PDO intact but mark it 'missing'.
        //
        // * If this child has handled a previous remove (this is
        // fundamentally the case if we've gotten to the point of
        // removing the parent) and hasn't subsequently received a
        // surprise remove, then delete the pdo.
        //

        if (current->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) {
            //
            // Mark as 'missing' and unlink dangerous reference to parent
            //

            current->Parent = NULL;
            current->Common.DeviceState &= ~MF_DEVICE_ENUMERATED;
        } else {
            MfDeletePdo(current);
        }
    }

    MfReleaseChildrenLock(Parent);

    Parent->Common.PowerState = PowerDeviceD3;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = MfPassIrp(Irp, Parent, IrpStack);
    ASSERT(NT_SUCCESS(status));

    IoReleaseRemoveLockAndWait(&Parent->RemoveLock, (PVOID) Irp);

    //
    // Detach and delete myself
    //

    IoDetachDevice(Parent->AttachedDevice);
    Parent->AttachedDevice = NULL;

    MfDeleteFdo(Parent->Self);

    return status;
}

NTSTATUS
MfSurpriseRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PLIST_ENTRY currentEntry;
    PMF_CHILD_EXTENSION current;

    PAGED_CODE();

    Parent->Common.DeviceState |= MF_DEVICE_SURPRISE_REMOVED;

    MfAcquireChildrenLock(Parent);

    for (currentEntry = Parent->Children.Flink;
         currentEntry != &Parent->Children;
         currentEntry = currentEntry->Flink) {

        current = CONTAINING_RECORD(currentEntry,
                                    MF_CHILD_EXTENSION,
                                    ListEntry);
        current->Common.DeviceState &= ~MF_DEVICE_ENUMERATED;
    }

    MfReleaseChildrenLock(Parent);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return MfPassIrp(Irp, Parent, IrpStack);
}

NTSTATUS
MfCancelRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = MfDeferProcessingFdo(Parent, Irp);
    // NTRAID#53498
    // ASSERT(status == STATUS_SUCCESS);
    // Uncomment after PCI state machine is fixed to not fail bogus stops
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
MfQueryDeviceRelationsFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{

    NTSTATUS status;
    PDEVICE_RELATIONS relations = NULL;
    ULONG relationsSize, childrenCount, i;
    PDEVICE_OBJECT *currentRelation;
    PMF_CHILD_EXTENSION currentChild;
    PLIST_ENTRY currentEntry;

    PAGED_CODE();

    DEBUG_MSG(1,
              ("%s\n",
               RELATION_STRING(IrpStack->Parameters.QueryDeviceRelations.Type)
              ));

    switch (IrpStack->Parameters.QueryDeviceRelations.Type) {

    case BusRelations:

        MfAcquireChildrenLock(Parent);

        status = MfEnumerate(Parent);

        if (!NT_SUCCESS(status)) {
            MfReleaseChildrenLock(Parent);
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_UNSUCCESSFUL;
        }

        childrenCount = 0;
        FOR_ALL_IN_LIST(MF_CHILD_EXTENSION, &Parent->Children, currentChild) {

            if (currentChild->Common.DeviceState & MF_DEVICE_ENUMERATED) {
                childrenCount++;
            }
        }

        if (childrenCount == 0) {
            relationsSize = sizeof(DEVICE_RELATIONS);
        } else {
            relationsSize = sizeof(DEVICE_RELATIONS) +
                (childrenCount-1) * sizeof(PDEVICE_OBJECT);
        }

        relations = ExAllocatePoolWithTag(PagedPool,
                                          relationsSize,
                                          MF_BUS_RELATIONS_TAG
                                          );

        if (!relations) {
            MfReleaseChildrenLock(Parent);
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(relations, relationsSize);

        //
        // Iterate through the list of children in the parent and build the
        // relations structure
        //

        currentRelation = relations->Objects;
        relations->Count = childrenCount;

        FOR_ALL_IN_LIST(MF_CHILD_EXTENSION, &Parent->Children, currentChild) {

            if (currentChild->Common.DeviceState & MF_DEVICE_ENUMERATED) {
                
                ObReferenceObject(currentChild->Self);
                *currentRelation = currentChild->Self;
    #if DBG
                DEBUG_MSG(1, ("\tPDO Enumerated @ 0x%08x\n", currentChild));
                DEBUG_MSG(1, ("\tName: %wZ\n", &currentChild->Info.Name));
                DEBUG_MSG(1, ("\tHardwareID: "));
                MfDbgPrintMultiSz(1, currentChild->Info.HardwareID.Buffer);
    
                DEBUG_MSG(1, ("\tCompatibleID: "));
                MfDbgPrintMultiSz(1, currentChild->Info.CompatibleID.Buffer);
    
                DEBUG_MSG(1, ("\tResourceMap: "));
                MfDbgPrintResourceMap(1, currentChild->Info.ResourceMap);
    
                DEBUG_MSG(1, ("\tVaryingMap: "));
                MfDbgPrintVaryingResourceMap(1, currentChild->Info.VaryingResourceMap);
                DEBUG_MSG(1, ("\tFlags: 0x%08x\n", currentChild->Info.MfFlags));
    
    #endif
            }
            currentRelation++;
        }

        MfReleaseChildrenLock(Parent);

        //
        // Hand back the relations
        //

        Irp->IoStatus.Information = (ULONG_PTR) relations;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    //
    // For the rest of the relations just pass down the irp untouched.
    //

    default:
        break;
    }

    return MfPassIrp(Irp, Parent, IrpStack);
}

VOID
MfArbiterReference(
    PVOID Context
    )
{
}

VOID
MfArbiterDereference(
    PVOID Context
    )
{
}


NTSTATUS
MfQueryInterfaceFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PMF_ARBITER current;
    PARBITER_INTERFACE interface = (PARBITER_INTERFACE) IrpStack->Parameters.QueryInterface.Interface;

    PAGED_CODE();

    //
    // We only provide arbiters
    //

    if (MfCompareGuid(&GUID_ARBITER_INTERFACE_STANDARD,
                      IrpStack->Parameters.QueryInterface.InterfaceType)) {

        //
        // We only support version 1 of the ARBITER_INTERFACE so we
        // don't need to bother checking version numbers, just that the
        // return buffer is big enough
        //

        if (IrpStack->Parameters.QueryInterface.Size < sizeof(ARBITER_INTERFACE)) {
            Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_BUFFER_TOO_SMALL;
        }

        FOR_ALL_IN_LIST(MF_ARBITER, &Parent->Arbiters, current) {

            if (current->Type == (CM_RESOURCE_TYPE)((ULONG_PTR)
                    IrpStack->Parameters.QueryInterface.InterfaceSpecificData)) {

                DEBUG_MSG(1,("    Returning Arbiter interface\n"));

                //
                // Fill in the interface
                //

                interface->Size = sizeof(ARBITER_INTERFACE);
                interface->Version = MF_ARBITER_INTERFACE_VERSION;
                interface->Context = &current->Instance;
                interface->InterfaceReference = MfArbiterReference;
                interface->InterfaceDereference = MfArbiterDereference;
                interface->ArbiterHandler = ArbArbiterHandler;
                interface->Flags = 0;

                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;

            }
        }
    }

    return MfPassIrp(Irp, Parent, IrpStack);
}

NTSTATUS
MfQueryCapabilitiesFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = MfDeferProcessingFdo(Parent, Irp);
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (IrpStack->Parameters.DeviceCapabilities.Capabilities->Version != 1) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }

    IrpStack->Parameters.DeviceCapabilities.Capabilities->WakeFromD0 =
        IrpStack->Parameters.DeviceCapabilities.Capabilities->WakeFromD1 =
        IrpStack->Parameters.DeviceCapabilities.Capabilities->WakeFromD2 =
        IrpStack->Parameters.DeviceCapabilities.Capabilities->WakeFromD3 = 0;

    IrpStack->Parameters.DeviceCapabilities.Capabilities->DeviceWake =
        PowerSystemUnspecified;
    IrpStack->Parameters.DeviceCapabilities.Capabilities->SystemWake =
        PowerSystemUnspecified;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
MfDispatchPowerFdo(
    IN PDEVICE_OBJECT DeviceObject,
    PMF_PARENT_EXTENSION Parent,
    PIO_STACK_LOCATION IrpStack,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for the FDO.  It dispatches
    to the routines described in the PoDispatchTable entry in the device object
    extension.

    This routine is NOT pageable as it can be called at DISPATCH_LEVEL

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Parent - FDO Extension

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/


{
    NTSTATUS status;
    PMF_COMMON_EXTENSION common = (PMF_COMMON_EXTENSION) Parent;

    IoAcquireRemoveLock(&Parent->RemoveLock, (PVOID) Irp);

    //
    // Call the appropriate function
    //

    if ((IrpStack->MinorFunction <= IRP_MN_PO_MAXIMUM_FUNCTION) &&
        (MfPoDispatchTableFdo[IrpStack->MinorFunction])) {

        status =
            MfPoDispatchTableFdo[IrpStack->MinorFunction](Irp,
                                                          (PVOID) common,
                                                          IrpStack
                                                          );

    } else {
        //
        // We don't know about this irp
        //

        DEBUG_MSG(0,
                  ("Unknown POWER IRP 0x%x for FDO 0x%08x\n",
                   IrpStack->MinorFunction,
                   DeviceObject
                   ));

        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        status = PoCallDriver(Parent->AttachedDevice, Irp);
    }

    IoReleaseRemoveLock(&Parent->RemoveLock, (PVOID) Irp);

    return status;
}

NTSTATUS
MfQueryPowerFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;

    return PoCallDriver(Parent->AttachedDevice, Irp);
}

NTSTATUS
MfSetPowerFdoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PMF_PARENT_EXTENSION parent = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Remember the parent's power state
    //

    if (irpStack->Parameters.Power.Type == DevicePowerState) {
        parent->Common.PowerState =
            irpStack->Parameters.Power.State.DeviceState;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
MfSetPowerFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PoStartNextPowerIrp(Irp);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           MfSetPowerFdoCompletion,
                           NULL,   //Context
                           TRUE,   //InvokeOnSuccess
                           FALSE,  //InvokeOnError
                           FALSE   //InvokeOnCancel
                           );
    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PoCallDriver(Parent->AttachedDevice, Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

ALT_PROJECT_TARGET=drivers2
BINPLACE_PLACEFILE=$(BASEDIR)\private\ntos\dd\pccard\placefil.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\mf\mfp.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    local.h

Abstract:

    This header declares the stuctures and function prototypes shared between
    the various modules.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#if !defined(_LOCAL_)
#define _LOCAL_

#include <ntddk.h>
#include <arbiter.h>
#include <wdmguid.h>
//#include <initguid.h>
#include <mf.h>
#include <strsafe.h>

#include "msg.h"
#include "debug.h"

//
// --- Constants ---
//

#define MF_CM_RESOURCE_VERSION          1
#define MF_CM_RESOURCE_REVISION         1
#define MF_ARBITER_INTERFACE_VERSION    1
#define MF_TRANSLATOR_INTERFACE_VERSION 1

//
// These must be updated if any new PNP or PO irps are added
//

#define IRP_MN_PNP_MAXIMUM_FUNCTION IRP_MN_QUERY_LEGACY_BUS_INFORMATION
#define IRP_MN_PO_MAXIMUM_FUNCTION  IRP_MN_QUERY_POWER

//
// Pool Tags
//

#define MF_POOL_TAG                     '  fM'
#define MF_RESOURCE_MAP_TAG             'MRfM'
#define MF_VARYING_MAP_TAG              'MVfM'
#define MF_CHILD_LIST_TAG               'LCfM'
#define MF_DEVICE_ID_TAG                'IDfM'
#define MF_INSTANCE_ID_TAG              'IIfM'
#define MF_CHILD_REQUIREMENTS_TAG       'QCfM'
#define MF_CHILD_RESOURCE_TAG           'RCfM'
#define MF_HARDWARE_COMPATIBLE_ID_TAG   'IHfM'
#define MF_PARENTS_RESOURCE_TAG         'RPfM'
#define MF_PARENTS_REQUIREMENTS_TAG     'QPfM'
#define MF_BUS_RELATIONS_TAG            'RBfM'
#define MF_TARGET_RELATIONS_TAG         'RTfM'
#define MF_REQUIREMENTS_INDEX_TAG       'IRfM'
#define MF_ARBITER_TAG                  'rAfM'

//
// Device state flags
//

#define MF_DEVICE_STARTED               0x00000001
#define MF_DEVICE_REMOVED               0x00000002
#define MF_DEVICE_ENUMERATED            0x00000004
#define MF_DEVICE_REMOVE_PENDING        0x00000008 /* DEPRECATED */
#define MF_DEVICE_STOP_PENDING          0x00000010 /* DEPRECATED */
#define MF_DEVICE_CAPABILITIES_CAPTURED 0x00000020 /* DEPRECATED */
#define MF_DEVICE_REQUIREMENTS_CAPTURED 0x00000040 /* DEPRECATED */
#define MF_DEVICE_DELETED               0x00000080
#define MF_DEVICE_SURPRISE_REMOVED      0x00000100

//
// Flags to MfGetRegistryValue
//

#define MF_GETREG_SZ_TO_MULTI_SZ    0x00000001

//
// --- Type definitions ---
//

typedef enum _MF_OBJECT_TYPE {
    MfPhysicalDeviceObject   = 'dPfM',
    MfFunctionalDeviceObject = 'dFfM'
} MF_OBJECT_TYPE;

typedef
NTSTATUS
(*PMF_DISPATCH)(
    IN PIRP Irp,
    IN PVOID Extension,
    IN PIO_STACK_LOCATION IrpStack
    );

typedef ULONG Mf_MSG_ID;

//
// Structures for storing the resource distributions
//

typedef struct _MF_ARBITER {

    //
    // List of arbiters
    //
    LIST_ENTRY ListEntry;

    //
    // The resource this arbiter arbitrates
    //
    CM_RESOURCE_TYPE Type;

    //
    // The arbiter instance
    //
    ARBITER_INSTANCE Instance;

} MF_ARBITER, *PMF_ARBITER;



typedef struct _MF_COMMON_EXTENSION {

    //
    // Type of device this is
    //
    MF_OBJECT_TYPE Type;

    //
    // Dispatch tables for Pnp and Power Irps.
    //
    PMF_DISPATCH *PnpDispatchTable;
    PMF_DISPATCH *PoDispatchTable;

    //
    // Flags to indicate the device's current state (use MF_DEVICE_*)
    //
    ULONG DeviceState;

    ULONG PagingCount;
    ULONG HibernationCount;
    ULONG DumpCount;

    //
    // The power state of the device
    //
    DEVICE_POWER_STATE PowerState;

} MF_COMMON_EXTENSION, *PMF_COMMON_EXTENSION;

typedef struct _MF_CHILD_EXTENSION *PMF_CHILD_EXTENSION;
typedef struct _MF_PARENT_EXTENSION *PMF_PARENT_EXTENSION;

typedef struct _MF_CHILD_EXTENSION {

    //
    // The common extension
    //
    MF_COMMON_EXTENSION Common;

    //
    // Various Flags
    //
    ULONG Flags;

    //
    // Backpointer to the device object we are are the extension of
    //
    PDEVICE_OBJECT Self;

    //
    // The FDO who enumerated us
    //
    PMF_PARENT_EXTENSION Parent;

    //
    // Other children enumerated by the same FDO
    //
    LIST_ENTRY ListEntry;

    //
    // The pnp device state of the device
    //
    PNP_DEVICE_STATE PnpDeviceState;

    //
    // The information about this device
    //
    MF_DEVICE_INFO Info;

} MF_CHILD_EXTENSION, *PMF_CHILD_EXTENSION;


typedef struct _MF_PARENT_EXTENSION {

    //
    // The common extension
    //
    MF_COMMON_EXTENSION Common;

    //
    // Backpointer to the device object of whom we are the extension
    //
    PDEVICE_OBJECT Self;

    //
    // The PDO for the multi-function device
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Lock for the children database
    //
    KEVENT ChildrenLock;

    //
    // List of children enumerated by this device
    //
    LIST_ENTRY Children;

    //
    // The next device in the stack who we should send our IRPs down to
    //
    PDEVICE_OBJECT AttachedDevice;

    //
    // The resources with which the parent was stated
    //
    PCM_RESOURCE_LIST ResourceList;
    PCM_RESOURCE_LIST TranslatedResourceList;

    //
    // The device and instance ID's of our parent
    //
    UNICODE_STRING DeviceID;
    UNICODE_STRING InstanceID;

    //
    // The already instantiated arbiters for this device
    //
    LIST_ENTRY Arbiters;

    //
    // If we had to traverse the children in order to determine what
    // the lowest power state the parent can go to, then the
    // synchronization of the children list would become extremely
    // complicated.
    //
    // Instead, have a spinlock protected data structure consisting of
    // an array of device power states.  Each element of the array is
    // a count of how many children are in that power state.  
    //

    KSPIN_LOCK PowerLock;
    LONG ChildrenPowerReferences[PowerDeviceMaximum];

    //
    // Remove lock.  Used to prevent the FDO from being removed while
    // other operations are digging around in the extension.
    //

    IO_REMOVE_LOCK RemoveLock;

} MF_PARENT_EXTENSION, *PMF_PARENT_EXTENSION;

//
// A list of MF_CHILD_LIST_ENTRYs is returned by MfEnumerate
//

typedef struct _MF_CHILD_LIST_ENTRY {
    LIST_ENTRY ListEntry;
    MF_DEVICE_INFO Info;
} MF_CHILD_LIST_ENTRY, *PMF_CHILD_LIST_ENTRY;

//
// Registry structure - from our friends in Win9x so it must be byte aligned
//

#include <pshpack1.h>

typedef struct _MF_REGISTRY_VARYING_RESOURCE_MAP {

    UCHAR ResourceIndex; // Win9x BYTE
    ULONG Offset;
    ULONG Size;

} MF_REGISTRY_VARYING_RESOURCE_MAP, *PMF_REGISTRY_VARYING_RESOURCE_MAP;

#include <poppack.h>

typedef
NTSTATUS
(*PMF_REQUIREMENT_FROM_RESOURCE)(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource,
    OUT PIO_RESOURCE_DESCRIPTOR Requirement
    );

typedef
NTSTATUS
(*PMF_UPDATE_RESOURCE)(
    IN OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource,
    IN ULONGLONG Start,
    IN ULONG Length
    );

typedef struct _MF_RESOURCE_TYPE {

    CM_RESOURCE_TYPE Type;
    PARBITER_UNPACK_REQUIREMENT UnpackRequirement;
    PARBITER_PACK_RESOURCE PackResource;
    PARBITER_UNPACK_RESOURCE UnpackResource;
    PMF_REQUIREMENT_FROM_RESOURCE RequirementFromResource;
    PMF_UPDATE_RESOURCE UpdateResource;

} MF_RESOURCE_TYPE, *PMF_RESOURCE_TYPE;

typedef struct _MF_POWER_COMPLETION_CONTEXT {

    //
    // Event that will be set when the operation is complete
    //
    KEVENT Event;

    //
    // The status of the completed operation
    //
    NTSTATUS Status;

} MF_POWER_COMPLETION_CONTEXT, *PMF_POWER_COMPLETION_CONTEXT;


//
// --- Globals ---
//

extern PDRIVER_OBJECT MfDriverObject;

//
// --- Function prototypes ---
//

//
// arbiter.c
//

NTSTATUS
MfInitializeArbiters(
    IN PMF_PARENT_EXTENSION Parent
    );

//
// common.c
//

NTSTATUS
MfDeviceUsageNotificationCommon(
    IN PIRP Irp,
    IN PMF_COMMON_EXTENSION Common,
    IN PIO_STACK_LOCATION IrpStack
    );

//
// dispatch.c
//

NTSTATUS
MfAddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
MfDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MfDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MfIrpNotSupported(
    IN PIRP Irp,
    IN PVOID Extension,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfForwardIrpToParent(
    IN PIRP Irp,
    IN PMF_CHILD_EXTENSION Extension,
    IN PIO_STACK_LOCATION IrpStack
    );
    
NTSTATUS
MfDispatchNop(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// enum.c
//

NTSTATUS
MfEnumerate(
    IN PMF_PARENT_EXTENSION Parent
    );

NTSTATUS
MfBuildDeviceID(
    IN PMF_PARENT_EXTENSION Parent,
    OUT PWSTR *DeviceID
    );

NTSTATUS
MfBuildInstanceID(
    IN PMF_CHILD_EXTENSION Child,
    OUT PWSTR *InstanceID
    );

NTSTATUS
MfBuildChildRequirements(
    IN PMF_CHILD_EXTENSION Child,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList
    );

//
// fdo.c
//

NTSTATUS
MfDispatchPnpFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    );

NTSTATUS
MfDispatchPowerFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    );

NTSTATUS
MfCreateFdo(
    PDEVICE_OBJECT *Fdo
    );

VOID
MfAcquireChildrenLock(
    IN PMF_PARENT_EXTENSION Parent
    );

VOID
MfReleaseChildrenLock(
    IN PMF_PARENT_EXTENSION Parent
    );

//
// init.c
//

//
// pdo.c
//

NTSTATUS
MfDispatchPnpPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_CHILD_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    );

NTSTATUS
MfDispatchPowerPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_CHILD_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    );

NTSTATUS
MfCreatePdo(
    IN PMF_PARENT_EXTENSION Parent,
    OUT PDEVICE_OBJECT *PhysicalDeviceObject
    );

VOID
MfDeletePdo(
    IN PMF_CHILD_EXTENSION Child
    );

//
// resource.c
//

PMF_RESOURCE_TYPE
MfFindResourceType(
    IN CM_RESOURCE_TYPE Type
    );

//
// utils.c
//

NTSTATUS
MfGetSubkeyByIndex(
    IN HANDLE ParentHandle,
    IN ULONG Index,
    IN ACCESS_MASK Access,
    OUT PHANDLE ChildHandle,
    OUT PUNICODE_STRING Name
    );

VOID
MfInitCommonExtension(
    IN OUT PMF_COMMON_EXTENSION Common,
    IN MF_OBJECT_TYPE Type
    );

VOID
MfFreeDeviceInfo(
    PMF_DEVICE_INFO Info
    );

NTSTATUS
MfGetRegistryValue(
    IN HANDLE Handle,
    IN PWSTR Name,
    IN ULONG Type,
    IN ULONG Flags,
    IN OUT PULONG DataLength,
    IN OUT PVOID *Data OPTIONAL
    );

NTSTATUS
MfSendPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION Location,
    OUT PULONG_PTR Information OPTIONAL
    );

NTSTATUS
MfSendSetPowerIrp(
    IN PDEVICE_OBJECT Target,
    IN POWER_STATE State
    );

DEVICE_POWER_STATE
MfUpdateChildrenPowerReferences(
    IN PMF_PARENT_EXTENSION Parent,
    IN DEVICE_POWER_STATE PreviousPowerState,
    IN DEVICE_POWER_STATE NewPowerState
    );

NTSTATUS
MfUpdateParentPowerState(
    IN PMF_PARENT_EXTENSION Parent,
    IN DEVICE_POWER_STATE TargetPowerState
    );

//
// --- Macros ---
//

#define IS_FDO(Extension) \
    (((PMF_COMMON_EXTENSION)Extension)->Type == MfFunctionalDeviceObject)

#define MfCompareGuid(a,b)                                         \
    (RtlEqualMemory((PVOID)(a), (PVOID)(b), sizeof(GUID)))

//
// Control macro (used like a for loop) which iterates over all entries in
// a standard doubly linked list.  Head is the list head and the entries are of
// type Type.  A member called ListEntry is assumed to be the LIST_ENTRY
// structure linking the entries together.  Current contains a pointer to each
// entry in turn.
//
#define FOR_ALL_IN_LIST(Type, Head, Current)                            \
    for((Current) = CONTAINING_RECORD((Head)->Flink, Type, ListEntry);  \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = CONTAINING_RECORD((Current)->ListEntry.Flink,        \
                                     Type,                              \
                                     ListEntry)                         \
       )

#define FOR_ALL_IN_LIST_SAFE(Type, Head, Current, Next)                 \
    for((Current) = CONTAINING_RECORD((Head)->Flink, Type, ListEntry),  \
            (Next) = CONTAINING_RECORD((Current)->ListEntry.Flink,      \
                                       Type, ListEntry);                \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = (Next),                                              \
            (Next) = CONTAINING_RECORD((Current)->ListEntry.Flink,      \
                                     Type, ListEntry)                   \
       )

//
// Similar to the above only iteration is over an array of length _Size.
//
#define FOR_ALL_IN_ARRAY(_Array, _Size, _Current)                       \
    for ( (_Current) = (_Array);                                        \
          (_Current) < (_Array) + (_Size);                              \
          (_Current)++ )

//
// FOR_ALL_CM_DESCRIPTORS(
//      IN PCM_RESOURCE_LIST _ResList,
//      OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR _Descriptor
//      )
//
//  Iterates over the resource descriptors in a CM_RESOURCE_LIST of Count 1
//
#define FOR_ALL_CM_DESCRIPTORS(_ResList, _Descriptor)               \
    ASSERT((_ResList)->Count == 1);                                 \
    FOR_ALL_IN_ARRAY(                                               \
        (_ResList)->List[0].PartialResourceList.PartialDescriptors, \
        (_ResList)->List[0].PartialResourceList.Count,              \
        (_Descriptor)                                               \
        )

//
// BOOLEAN
// IS_ARBITRATED_RESOURCE(
//      IN CM_RESOURCE_TYPE _Resource
//      )
//
// If the top bit of the resource type (when viewed as a UCHAR) is set
// then the resource is nonarbitrated.
//
#define IS_ARBITRATED_RESOURCE(_Resource)                           \
    (!(((UCHAR)(_Resource)) & 0x80) &&                              \
     !(((UCHAR)(_Resource)) == 0x00))

#define END_OF_RANGE(_Start, _Length)                               \
    ((_Start)+(_Length)-1)
    
#endif // !defined(_LOCAL_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\mf\pdo.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    pdo.c

Abstract:

    This module provides the functions that pertain to MF.SYS PDOs

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "mfp.h"

/*++

The majority of functions in this file are called based on their presence
in Pnp and Po dispatch tables.  In the interests of brevity the arguments
to all those functions will be described below:

NTSTATUS
MfXxxPdo(
    IN PIRP Irp,
    IN PMF_CHILD_EXTENSION Child,
   IN PIO_STACK_LOCATION IrpStack
    )

Routine Description:

    This function handles the Xxx requests for multifunction PDO's

Arguments:

    Irp - Points to the IRP associated with this request.

    Child - Points to the child PDO's device extension.

    IrpStack - Points to the current stack location for this request.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NOT_SUPPORTED indicates that the IRP should be completed without
    changing the Irp->IoStatus.Status field otherwise it is updated with this
    status.

--*/

NTSTATUS
MfCreatePdo(
           IN PMF_PARENT_EXTENSION Parent,
           OUT PDEVICE_OBJECT *PhysicalDeviceObject
           );

NTSTATUS
MfStartPdo(
          IN PIRP Irp,
          IN PMF_CHILD_EXTENSION Child,
          IN PIO_STACK_LOCATION IrpStack
          );

NTSTATUS
MfQueryRemovePdo(
                IN PIRP Irp,
                IN PMF_CHILD_EXTENSION Child,
                IN PIO_STACK_LOCATION IrpStack
                );

NTSTATUS
MfRemovePdo(
           IN PIRP Irp,
           IN PMF_CHILD_EXTENSION Child,
           IN PIO_STACK_LOCATION IrpStack
           );

NTSTATUS
MfSurpriseRemovePdo(
           IN PIRP Irp,
           IN PMF_CHILD_EXTENSION Child,
           IN PIO_STACK_LOCATION IrpStack
           );

NTSTATUS
MfCancelRemovePdo(
                 IN PIRP Irp,
                 IN PMF_CHILD_EXTENSION Child,
                 IN PIO_STACK_LOCATION IrpStack
                 );

NTSTATUS
MfStopPdo(
         IN PIRP Irp,
         IN PMF_CHILD_EXTENSION Child,
         IN PIO_STACK_LOCATION IrpStack
         );

NTSTATUS
MfQueryStopPdo(
              IN PIRP Irp,
              IN PMF_CHILD_EXTENSION Child,
              IN PIO_STACK_LOCATION IrpStack
              );

NTSTATUS
MfCancelStopPdo(
               IN PIRP Irp,
               IN PMF_CHILD_EXTENSION Child,
               IN PIO_STACK_LOCATION IrpStack
               );
NTSTATUS
MfQueryDeviceRelationsPdo(
                      IN PIRP Irp,
                      IN PMF_CHILD_EXTENSION Child,
                      IN PIO_STACK_LOCATION IrpStack
                      );

NTSTATUS
MfQueryInterfacePdo(
                   IN PIRP Irp,
                   IN PMF_CHILD_EXTENSION Child,
                   IN PIO_STACK_LOCATION IrpStack
                   );
NTSTATUS
MfQueryCapabilitiesPdo(
                   IN PIRP Irp,
                   IN PMF_CHILD_EXTENSION Child,
                   IN PIO_STACK_LOCATION IrpStack
                   );

NTSTATUS
MfQueryResourcesPdo(
                   IN PIRP Irp,
                   IN PMF_CHILD_EXTENSION Child,
                   IN PIO_STACK_LOCATION IrpStack
                   );

NTSTATUS
MfQueryResourceRequirementsPdo(
                              IN PIRP Irp,
                              IN PMF_CHILD_EXTENSION Child,
                              IN PIO_STACK_LOCATION IrpStack
                              );

NTSTATUS
MfQueryDeviceTextPdo(
                    IN PIRP Irp,
                    IN PMF_CHILD_EXTENSION Child,
                    IN PIO_STACK_LOCATION IrpStack
                    );

NTSTATUS
MfQueryIdPdo(
            IN PIRP Irp,
            IN PMF_CHILD_EXTENSION Child,
            IN PIO_STACK_LOCATION IrpStack
            );


NTSTATUS
MfQueryPnpDeviceStatePdo(
                        IN PIRP Irp,
                        IN PMF_CHILD_EXTENSION Child,
                        IN PIO_STACK_LOCATION IrpStack
                        );

NTSTATUS
MfPagingNotificationPdo(
                       IN PIRP Irp,
                       IN PMF_CHILD_EXTENSION Child,
                       IN PIO_STACK_LOCATION IrpStack
                       );

NTSTATUS
MfSetPowerPdo(
             IN PIRP Irp,
             IN PMF_CHILD_EXTENSION Child,
             IN PIO_STACK_LOCATION IrpStack
             );

NTSTATUS
MfQueryPowerPdo(
               IN PIRP Irp,
               IN PMF_CHILD_EXTENSION Child,
               IN PIO_STACK_LOCATION IrpStack
               );

VOID
MfTranslatorReference(
    IN PVOID Context
    );

VOID
MfTranslatorDereference(
    IN PVOID Context
    );

BOOLEAN
MfIsSubResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Super,
    IN ULONGLONG SubStart,
    IN ULONG SubLength,
    OUT PULONGLONG Offset
    );

NTSTATUS
MfPerformTranslation(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated,
    IN ULONGLONG Offset,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
MfTransFromRawRequirements(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
MfTransFromRawResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE, MfCancelRemovePdo)
   #pragma alloc_text(PAGE, MfCancelStopPdo)
   #pragma alloc_text(PAGE, MfCreatePdo)
   #pragma alloc_text(PAGE, MfDispatchPnpPdo)
   #pragma alloc_text(PAGE, MfIsSubResource)
   #pragma alloc_text(PAGE, MfPerformTranslation)
   #pragma alloc_text(PAGE, MfQueryCapabilitiesPdo)
   #pragma alloc_text(PAGE, MfQueryDeviceRelationsPdo)
   #pragma alloc_text(PAGE, MfQueryDeviceTextPdo)
   #pragma alloc_text(PAGE, MfQueryIdPdo)
   #pragma alloc_text(PAGE, MfQueryInterfacePdo)
   #pragma alloc_text(PAGE, MfQueryRemovePdo)
   #pragma alloc_text(PAGE, MfQueryResourceRequirementsPdo)
   #pragma alloc_text(PAGE, MfQueryResourcesPdo)
   #pragma alloc_text(PAGE, MfQueryStopPdo)
   #pragma alloc_text(PAGE, MfRemovePdo)
   #pragma alloc_text(PAGE, MfStartPdo)
   #pragma alloc_text(PAGE, MfStopPdo)
   #pragma alloc_text(PAGE, MfTransFromRawRequirements)
   #pragma alloc_text(PAGE, MfTransFromRawResources)
#endif

PMF_DISPATCH MfPnpDispatchTablePdo[] = {

   MfStartPdo,                     // IRP_MN_START_DEVICE
   MfQueryRemovePdo,               // IRP_MN_QUERY_REMOVE_DEVICE
   MfRemovePdo,                    // IRP_MN_REMOVE_DEVICE
   MfCancelRemovePdo,              // IRP_MN_CANCEL_REMOVE_DEVICE
   MfIrpNotSupported,              // IRP_MN_STOP_DEVICE
   MfQueryStopPdo,                 // IRP_MN_QUERY_STOP_DEVICE
   MfCancelStopPdo,                // IRP_MN_CANCEL_STOP_DEVICE
   MfQueryDeviceRelationsPdo,      // IRP_MN_QUERY_DEVICE_RELATIONS
   MfQueryInterfacePdo,            // IRP_MN_QUERY_INTERFACE
   MfQueryCapabilitiesPdo,         // IRP_MN_QUERY_CAPABILITIES
   MfQueryResourcesPdo,            // IRP_MN_QUERY_RESOURCES
   MfQueryResourceRequirementsPdo, // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
   MfQueryDeviceTextPdo,           // IRP_MN_QUERY_DEVICE_TEXT
   MfIrpNotSupported,              // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
   MfIrpNotSupported,              // Unused
   MfForwardIrpToParent,           // IRP_MN_READ_CONFIG
   MfForwardIrpToParent,           // IRP_MN_WRITE_CONFIG
   MfForwardIrpToParent,           // IRP_MN_EJECT
   MfForwardIrpToParent,           // IRP_MN_SET_LOCK
   MfQueryIdPdo,                   // IRP_MN_QUERY_ID
   MfQueryPnpDeviceStatePdo,       // IRP_MN_QUERY_PNP_DEVICE_STATE
   MfForwardIrpToParent,           // IRP_MN_QUERY_BUS_INFORMATION
   MfDeviceUsageNotificationCommon,// IRP_MN_DEVICE_USAGE_NOTIFICATION
   MfSurpriseRemovePdo,            // IRP_MN_SURPRISE_REMOVAL
   MfIrpNotSupported               // IRP_MN_QUERY_LEGACY_BUS_INFORMATION
};

PMF_DISPATCH MfPoDispatchTablePdo[] = {
    NULL,                          // IRP_MN_WAIT_WAKE
    NULL,                          // IRP_MN_POWER_SEQUENCE
    MfSetPowerPdo,                 // IRP_MN_SET_POWER
    MfQueryPowerPdo                // IRP_MN_QUERY_POWER
};

NTSTATUS
MfCreatePdo(
           IN PMF_PARENT_EXTENSION Parent,
           OUT PDEVICE_OBJECT *PhysicalDeviceObject
           )

/*++

Routine Description:

    Creates and initializes a new pdo inserting it into the list of PDOs owned
    by Parent

Arguments:

    Parent - The parent device that owns this pdo.

    PhysicalDeviceObject - On success pointer to the physical device object created

Return Value:

    NT status.

--*/

{
   NTSTATUS status;
   PDEVICE_OBJECT pdo;
   PMF_CHILD_EXTENSION extension;

   PAGED_CODE();

   ASSERT((sizeof(MfPnpDispatchTablePdo) / sizeof(PMF_DISPATCH)) - 1
          == IRP_MN_PNP_MAXIMUM_FUNCTION);

   ASSERT((sizeof(MfPoDispatchTablePdo) / sizeof(PMF_DISPATCH)) - 1
          == IRP_MN_PO_MAXIMUM_FUNCTION);

   status = IoCreateDevice(Parent->Self->DriverObject,
                           sizeof(MF_CHILD_EXTENSION),
                           NULL, // Name
                           FILE_DEVICE_UNKNOWN,
                           FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
                           FALSE, // Exclusive
                           &pdo
                          );

   if (!NT_SUCCESS(status)) {
       return status;
   }

   //
   // Fill in our extension
   //

   extension = pdo->DeviceExtension;

   MfInitCommonExtension(&extension->Common, MfPhysicalDeviceObject);

   extension->Self = pdo;
   extension->Parent = Parent;

   extension->Common.PowerState = PowerDeviceUnspecified;

   //
   // Insert the child into the parents child list.  Access already
   // protected by the children lock taken in the QDR code.
   //

   InsertHeadList(&Parent->Children, &extension->ListEntry);

   //
   // Our FDO stack is pagable, so we need to
   // assume pagable as well.
   //

   pdo->Flags |= DO_POWER_PAGABLE;

   //
   // We have finished initializing
   //

   pdo->Flags &= ~DO_DEVICE_INITIALIZING;

   *PhysicalDeviceObject = pdo;

   //
   // Dump the info about the PDO just created
   //

   DEBUG_MSG(1, ("Created PDO @ 0x%08x\n", pdo));

   return STATUS_SUCCESS;
}


VOID
MfDeletePdo(
           IN PMF_CHILD_EXTENSION Child
           )

/*++

Routine Description:

    Cleans a PDO extension and any associated allocations.  Then
    deletes the PDO itself.

Arguments:

    Child - PDO extension

Return Value:

    None

--*/

{
    if (Child->Common.DeviceState & MF_DEVICE_DELETED) {
        //
        // Trying to delete twice
        //
        ASSERT(!(Child->Common.DeviceState & MF_DEVICE_DELETED));
        return;
    }

    MfFreeDeviceInfo(&Child->Info);

    Child->Common.DeviceState |= MF_DEVICE_DELETED;
    DEBUG_MSG(1, ("Deleted PDO @ 0x%08x\n", Child->Self));
    IoDeleteDevice(Child->Self);
}

NTSTATUS
MfDispatchPnpPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_CHILD_EXTENSION Child,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_PNP IRPs for PDOs.

Arguments:

    DeviceObject - Pointer to the PDO for which this IRP applies.

    Child - PDO extension

    IrpStack - Current stack location
    
    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/
{
    NTSTATUS status;
    BOOLEAN isRemove;
    
    PAGED_CODE();

    if (Child->Common.DeviceState & MF_DEVICE_DELETED) {
        status = Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
    } else if (IrpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {
        status = Irp->IoStatus.Status;
    } else {
        //
        // If IRP_MN_REMOVE_DEVICE is received by a pdo that was not
        // enumerated in the last BusRelations query, then it needs to
        // delete the pdo *AFTER* completing the remove irp.  As this
        // is in conflict with the standard dispatch functionality
        // provided by this function, explicitly delegate completion
        // of this irp to the dispatched routine.

        isRemove = IrpStack->MinorFunction == IRP_MN_REMOVE_DEVICE;
        status =
            MfPnpDispatchTablePdo[IrpStack->MinorFunction](Irp,
                                                           Child,
                                                           IrpStack
                                                           );
        if (isRemove) {
            return status;
        }
        if (status != STATUS_NOT_SUPPORTED) {
            Irp->IoStatus.Status = status;
        } else {
            status = Irp->IoStatus.Status;
        }
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

POWER_STATE
MfUpdatePowerPdo(
    IN PMF_CHILD_EXTENSION Child,
    IN DEVICE_POWER_STATE NewDevicePowerState
    )
{
    POWER_STATE previousState, newState;
    DEVICE_POWER_STATE newParentState;

    newState.DeviceState = NewDevicePowerState;
    previousState = PoSetPowerState(Child->Self,
                                    DevicePowerState,
                                    newState);

    ASSERT(previousState.DeviceState == Child->Common.PowerState);
    DEBUG_MSG(1,
              ("Updating child power state from %s (believed %s) to %s\n",
               DEVICE_POWER_STRING(previousState.DeviceState),
               DEVICE_POWER_STRING(Child->Common.PowerState),
               DEVICE_POWER_STRING(NewDevicePowerState)
               ));

    Child->Common.PowerState = NewDevicePowerState;

    //
    // We may be receiving an operation after our parent has been
    // surprise removed/removed in which case we should keep our
    // hands out of the cookie jar.
    //
    if (Child->Parent) {
        //
        // * We've already claimed that we can go to this power
        // state via the capabilities
        // * Said yes to QUERY_POWER
        // * Children's power state is defined to be as resource consuming
        // or less than the parent

        //
        // Update the children power state references stored in the
        // parent extension.  Compute a new target power state for the
        // parent

        newParentState =
            MfUpdateChildrenPowerReferences(Child->Parent,
                                            previousState.DeviceState,
                                            NewDevicePowerState
                                            );

        //
        // Modify the parent's power state to reflect that of it's
        // children.
        //

        MfUpdateParentPowerState(Child->Parent, newParentState);
    }

    return previousState;
}

NTSTATUS
MfStartPdo(
          IN PIRP Irp,
          IN PMF_CHILD_EXTENSION Child,
          IN PIO_STACK_LOCATION IrpStack
          )
{
   PDEVICE_OBJECT pDO;
   POWER_STATE previousState, newState;

   PAGED_CODE();

   if (Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) {
       return STATUS_NO_SUCH_DEVICE;
   }
   //
   // Trivially succeed the start
   //

   MfUpdatePowerPdo(Child, PowerDeviceD0);

   return STATUS_SUCCESS;
}
NTSTATUS
MfQueryRemovePdo(
                IN PIRP Irp,
                IN PMF_CHILD_EXTENSION Child,
                IN PIO_STACK_LOCATION IrpStack
                )
{
   PAGED_CODE();

   if (Child->Common.PagingCount > 0
       ||  Child->Common.HibernationCount > 0
       ||  Child->Common.DumpCount > 0) {

       return STATUS_DEVICE_BUSY;

   } else {

       return STATUS_SUCCESS;
   }
}

NTSTATUS
MfCancelRemovePdo(
                 IN PIRP Irp,
                 IN PMF_CHILD_EXTENSION Child,
                 IN PIO_STACK_LOCATION IrpStack
                 )
{
   PAGED_CODE();

   return STATUS_SUCCESS;
}

NTSTATUS
MfRemovePdo(
           IN PIRP Irp,
           IN PMF_CHILD_EXTENSION Child,
           IN PIO_STACK_LOCATION IrpStack
           )
{
    PAGED_CODE();

    if ((Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) == 0) {
       
        MfUpdatePowerPdo(Child, PowerDeviceD3);
    }

    Child->Common.DeviceState &= ~MF_DEVICE_SURPRISE_REMOVED;

    //
    // If child appeared in the last BusRelations then just mark it
    // removed, otherwise completely delete it.
    // 

    Irp->IoStatus.Status = STATUS_SUCCESS;
    if (Child->Common.DeviceState & MF_DEVICE_ENUMERATED) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    } else {
        if (Child->Parent) {
            MfAcquireChildrenLock(Child->Parent);
            RemoveEntryList(&Child->ListEntry);
            MfReleaseChildrenLock(Child->Parent);
        }
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        MfDeletePdo(Child);
    }
    return STATUS_SUCCESS;
}

NTSTATUS
MfSurpriseRemovePdo(
           IN PIRP Irp,
           IN PMF_CHILD_EXTENSION Child,
           IN PIO_STACK_LOCATION IrpStack
           )
{
    PAGED_CODE();

    //
    // Mark device as surprise removed.
    //
    Child->Common.DeviceState |= MF_DEVICE_SURPRISE_REMOVED;

    //
    // Update my pdo's power state *AND* my parent's power state *IFF*
    // the parent is still connected.
    //
    MfUpdatePowerPdo(Child, PowerDeviceD3);

    //
    // The surprise remove could have one of many causes.  One
    // possibility that can be excluded is MF reporting its children
    // missing directly since MF children can't disappear.
    //

    return STATUS_SUCCESS;
}

//
// Stopping is disabled at the moment because MF is dependent on
// changes in the arbiters to support resource rebalance.
//

NTSTATUS
MfStopPdo(
         IN PIRP Irp,
         IN PMF_CHILD_EXTENSION Child,
         IN PIO_STACK_LOCATION IrpStack
         )
{
   PAGED_CODE();

   return STATUS_SUCCESS;
}

NTSTATUS
MfQueryStopPdo(
              IN PIRP Irp,
              IN PMF_CHILD_EXTENSION Child,
              IN PIO_STACK_LOCATION IrpStack
              )
{
   PAGED_CODE();

   if (Child->Common.PagingCount > 0
       ||  Child->Common.HibernationCount > 0
       ||  Child->Common.DumpCount > 0) {

       return STATUS_UNSUCCESSFUL;

   } else {

       // REBALANCE
       // If rebalance was supported by parent, then this would have
       // to succeed.

       return STATUS_UNSUCCESSFUL;
   }
}


NTSTATUS
MfCancelStopPdo(
               IN PIRP Irp,
               IN PMF_CHILD_EXTENSION Child,
               IN PIO_STACK_LOCATION IrpStack
               )
{
   PAGED_CODE();

   return STATUS_SUCCESS;
}

NTSTATUS
MfQueryDeviceRelationsPdo(
                      IN PIRP Irp,
                      IN PMF_CHILD_EXTENSION Child,
                      IN PIO_STACK_LOCATION IrpStack
                      )
{
   PDEVICE_RELATIONS deviceRelations;
   PMF_CHILD_EXTENSION nextChild;
   NTSTATUS          status;
   ULONG             index;

   PAGED_CODE();

   if ((Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) ||
       (Child->Parent == NULL)) {
       return STATUS_NO_SUCH_DEVICE;
   }

   status = Irp->IoStatus.Status;

   switch (IrpStack->Parameters.QueryDeviceRelations.Type) {

   case TargetDeviceRelation:

      deviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
      if (!deviceRelations) {
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      status = ObReferenceObjectByPointer(Child->Self,
                                          0,
                                          NULL,
                                          KernelMode);
      if (!NT_SUCCESS(status)) {
         ExFreePool(deviceRelations);
         return status;
      }
      deviceRelations->Count = 1;
      deviceRelations->Objects[0] = Child->Self;
      Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
      break;

   default:
      //
      // Don't touch the status
      //
      break;
   }
   return status;
}


//
// Seeing as the MF translator don't allocate any memory for their context the
// reference and dereference are nops.
//

VOID
MfTranslatorReference(
    IN PVOID Context
    )
{
}

VOID
MfTranslatorDereference(
    IN PVOID Context
    )
{
}

BOOLEAN
MfIsSubResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Super,
    IN ULONGLONG SubStart,
    IN ULONG SubLength,
    OUT PULONGLONG Offset
    )
{
/*++

Routine Description:

    Reports whether one resource descriptor is encapsulated
    in another

Arguments:

    Super - the resource descriptor that we want to encapsulate
    SubStart - The start of the subrange
    SubLength - The length of the subrange
    Offset - On success the offset from the beginning of Super and
        SubStart.

Return Value:

    TRUE on succeess FALSE otherwise
--*/

    NTSTATUS status;
    ULONGLONG superStart;
    ULONG superLength;
    PMF_RESOURCE_TYPE restype;

    PAGED_CODE();

    ASSERT(Offset);

    restype = MfFindResourceType(Super->Type);

    if (restype == NULL) {
        ASSERT(restype != NULL);
        return FALSE;
    }

    status = restype->UnpackResource(Super,&superStart,&superLength);

    if (!NT_SUCCESS(status)) {
        ASSERT(NT_SUCCESS(status));
        return FALSE;
    }

    //
    // special case 0 length resources
    //

    if (superLength == 0) {

        if (SubLength == 0 &&
            SubStart == superStart) {

            *Offset = 0;
            return TRUE;
        }
        else return FALSE;
    }

    if (SubLength == 0) {

        if (SubStart >= superStart &&
            SubStart <= superStart + superLength - 1) {

            *Offset = SubStart-superStart;
            return TRUE;
        }

        else return FALSE;
    }

    //
    // if SubStart falls in between the ends of Super, we have
    // potential encapsulation
    //
    if ((SubStart >= superStart) && (SubStart <= superStart+superLength-1)) {

        //
        // It is an error if the two ranges overlap.  Either
        // Sub should be encapsulated in Super or they should
        // not intersect.
        //
        ASSERT(SubStart+SubLength-1 <= superStart+superLength-1);
        if (SubStart+SubLength-1 > superStart+superLength-1) {
            return FALSE;
        }
        *Offset = SubStart-superStart;
        return TRUE;

    } else {
        //
        // Checking again to make sure ranges don't overlap
        //
        ASSERT((SubStart > superStart+superLength-1) ||
               (SubStart+SubLength-1 < superStart));
        return FALSE;
    }

}

NTSTATUS
MfPerformTranslation(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated,
    IN ULONGLONG Offset,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
{
/*++

Routine Description:

    stores the translated version of the Source resource in Target.

Arguments:

    Source - the raw resource
    Translated - the translated resource that matches the raw resource
        that encapsulates Source.
    offset - the offset of the beginning of Source from the raw parent
        resource.
    Target - the resource descriptor in which the translated version of
        source is stored.

Return Value:

    status of operation

--*/

    NTSTATUS status;
    PMF_RESOURCE_TYPE restype;
    ULONGLONG translatedStart, dummy;
    ULONG sourceLength, dummy2;

    PAGED_CODE();

    RtlCopyMemory(Target, Translated, sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

    //
    // Get the length from the source
    //

    restype = MfFindResourceType(Source->Type);
    if (restype == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    status = restype->UnpackResource(Source, &dummy, &sourceLength);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get the start of the translated
    //

    restype = MfFindResourceType(Translated->Type);
    if (restype == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    status = restype->UnpackResource(Translated, &translatedStart, &dummy2);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Apply the offset and any length changes and update the descriptor
    //

    status = restype->UpdateResource(Target, translatedStart + Offset, sourceLength);

    return status;
}


NTSTATUS
MfTransFromRawResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    Translates a raw resource into a global translated resource.
    
    MF has translators to deal with child devices who request interrupts.  The system
    interrupt translator can translate for PDOs that have routing information in the BIOS.
    This includes the MF parent device.  MF child devices, however, are just logical
    subdivisions of the MF parent device, so they don't have the appropriate BIOS goop,
    and the system interrupt translator will fail translation on MF child PDOs.
    
    To handle this, MF exposes a translator.  It only translates resources, not requirements,
    since raw requirements are the same as translated requirements.  The translator recognizes
    that child resources are simply sub-resources of parent resources.  Therefore, for a given
    raw child resource, the translator finds the raw parent resource that is a superset of the
    child resource, and copies the corresponding translated parent resource into the translated
    child resource, applying appropriate offsets.  It then returns STATUS_TRANSLATION_COMPLETE
    to indicate that this is the final translation, and no other translators should be sought
    out for this device.
    
    Thus, the system interrupt translator will do the appropriate translation for the parent,
    and then MF applies this translation to the child inside its own translator.  Returning
    STATUS_TRANSLATION_COMPLETE prevents the system interrupt translator from being called
    for the child device, and so prevents it from failing the translation.

Arguments:

    Context - the parent extension that stores the raw and translated resources
    Source - the raw child resource
    Direction - ChildToParent or ParentToChild
    PhysicalDeviceObject - the PDO associated with this
    Target - the translated child resource

Return Value:

    NT Status code.  If the translation actually occurs, this will be STATUS_TRANSLATION_COMPLETE
    to indicate that pnp does not need to traverse the tree any more to find other translators.

--*/
{
    PMF_PARENT_EXTENSION parent = (PMF_PARENT_EXTENSION) Context;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR raw, translated;
    NTSTATUS status;
    ULONGLONG offset;
    ULONGLONG sourceStart;
    ULONG sourceLength;
    PMF_RESOURCE_TYPE restype;
    ULONG index;

    PAGED_CODE();

    if (Direction == TranslateParentToChild) {
        //
        // Perform an identity translation
        //
        RtlCopyMemory(Target, Source, sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));
        return STATUS_SUCCESS;

    }

    //
    // Do some real translation
    //

    ASSERT(Direction == TranslateChildToParent);

    restype = MfFindResourceType(Source->Type);
    if (restype == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    status = restype->UnpackResource(Source,&sourceStart,&sourceLength);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // runs through raw and translated resource lists, looking for the
    // element of the raw list that corresponds to the source we are
    // given as a parameter, then does the translation using the parallel
    // element of the translated list
    //
    index = 0;
    status = STATUS_INVALID_PARAMETER;
    FOR_ALL_CM_DESCRIPTORS(parent->ResourceList, raw) {

        if (raw->Type == Source->Type
        && MfIsSubResource(raw, sourceStart, sourceLength, &offset)) {

            //
            // This is a match, look up the translated entry in the parallel array
            //
            translated = &parent->TranslatedResourceList->List[0].PartialResourceList.PartialDescriptors[index];

            status = MfPerformTranslation(Source, translated, offset, Target);

            if (NT_SUCCESS(status)) {
                //
                // We did our translation from the translated resources our parent got
                // and these are already
                //
                status = STATUS_TRANSLATION_COMPLETE;
            }
            break;

        } else {
            index++;
        }
    }

    return status;
}

NTSTATUS
MfTransFromRawRequirements(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
{

    PAGED_CODE();

    *Target = ExAllocatePool(PagedPool, sizeof(IO_RESOURCE_DESCRIPTOR));
    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(*Target, Source, sizeof(IO_RESOURCE_DESCRIPTOR));
    *TargetCount = 1;

    return STATUS_TRANSLATION_COMPLETE;
}

NTSTATUS
MfQueryInterfacePdo(
                   IN PIRP Irp,
                   IN PMF_CHILD_EXTENSION Child,
                   IN PIO_STACK_LOCATION IrpStack
                   )
{
    PTRANSLATOR_INTERFACE transInterface;

    PAGED_CODE();

    if ((Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) ||
       (Child->Parent == NULL)) {
        return STATUS_NO_SUCH_DEVICE;
    }
    
    if (MfCompareGuid(&GUID_TRANSLATOR_INTERFACE_STANDARD,
                     IrpStack->Parameters.QueryInterface.InterfaceType)) {
    
        transInterface = (PTRANSLATOR_INTERFACE)IrpStack->Parameters.QueryInterface.Interface;
        
        transInterface->Size = sizeof(TRANSLATOR_INTERFACE);
        transInterface->Version = MF_TRANSLATOR_INTERFACE_VERSION;
        transInterface->Context = Child->Parent;
        transInterface->InterfaceReference = MfTranslatorReference;
        transInterface->InterfaceDereference = MfTranslatorDereference;
        transInterface->TranslateResources = MfTransFromRawResources;
        transInterface->TranslateResourceRequirements = MfTransFromRawRequirements;
        
        Irp->IoStatus.Information = 0;
        
        // NTRAID#54667
        // Aren't we supposed to reference this before returning it?
        
        
        return STATUS_SUCCESS;
    
    } else if (MfCompareGuid(&GUID_ARBITER_INTERFACE_STANDARD,
                          IrpStack->Parameters.QueryInterface.InterfaceType)) {
        return STATUS_INVALID_PARAMETER_1;
    } else if (MfCompareGuid(&GUID_MF_ENUMERATION_INTERFACE,
                          IrpStack->Parameters.QueryInterface.InterfaceType)) {
       //
       // Otherwise you wouldn't be able to instantiate MF on top of a
       // MF child.
       //
       return Irp->IoStatus.Status;
    
    } else {

       //
       // Fire these off to the parent
       //
       
       // NOTE: There is the potential that some future interface(s)
       // shouldn't be forwarded to the parent.
       
       return MfForwardIrpToParent(Irp, Child, IrpStack);
   }

}

NTSTATUS
MfQueryCapabilitiesPdo(
    IN PIRP Irp,
    IN PMF_CHILD_EXTENSION Child,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PDEVICE_CAPABILITIES capabilities;
    IO_STACK_LOCATION location;
    NTSTATUS status;

    PAGED_CODE();

    if ((Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) || 
        (Child->Parent == NULL)) {
       return STATUS_NO_SUCH_DEVICE;
    }

    ASSERT (Child->Parent);

    if (IrpStack->Parameters.DeviceCapabilities.Capabilities->Version != 1) {
        return STATUS_INVALID_PARAMETER;
    }
    
    capabilities = ExAllocatePool(PagedPool, sizeof(DEVICE_CAPABILITIES));
    if (capabilities == NULL) {
         return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(capabilities, sizeof(DEVICE_CAPABILITIES));
    capabilities->Size = sizeof(DEVICE_CAPABILITIES);
    capabilities->Version = 1;
    capabilities->Address = capabilities->UINumber = -1;

    RtlZeroMemory(&location, sizeof(IO_STACK_LOCATION));
    location.MajorFunction = IRP_MJ_PNP;
    location.MinorFunction = IRP_MN_QUERY_CAPABILITIES;
    location.Parameters.DeviceCapabilities.Capabilities = capabilities;

    status = MfSendPnpIrp(Child->Parent->Self,
                          &location,
                          NULL);
    if (NT_SUCCESS(status)) {
        RtlCopyMemory(IrpStack->Parameters.DeviceCapabilities.Capabilities,
                      location.Parameters.DeviceCapabilities.Capabilities,
                      sizeof(DEVICE_CAPABILITIES)
                      );

        //
        // The child has now inherited the capabilities of the MF
        // parent.  Some of these capabilities must now be filtered
        // out in order to avoid implying functionality that is really
        // limited to the parent's bus driver.
        //

        //
        // Child is not removable, lockable, ejectable or
        // SurpriseRemovalOK. Ensure this
        //
        IrpStack->Parameters.DeviceCapabilities.Capabilities->LockSupported = 
            IrpStack->Parameters.DeviceCapabilities.Capabilities->EjectSupported =
            IrpStack->Parameters.DeviceCapabilities.Capabilities->Removable = 
            IrpStack->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = FALSE;
    }

    ExFreePool(capabilities);
    return status;
}

NTSTATUS
MfQueryResourcesPdo(
                   IN PIRP Irp,
                   IN PMF_CHILD_EXTENSION Child,
                   IN PIO_STACK_LOCATION IrpStack
                   )
{
   PAGED_CODE();
   //
   // If the parent device had a boot config then it will have
   // reported it (and they will have been preallocated).  Don't
   // bother to report boot configs for the children as they don't
   // gain us anything other than extra arbitration.
   //

   return STATUS_NOT_SUPPORTED;
}


NTSTATUS
MfQueryResourceRequirementsPdo(
                              IN PIRP Irp,
                              IN PMF_CHILD_EXTENSION Child,
                              IN PIO_STACK_LOCATION IrpStack
                              )
{
   NTSTATUS status;
   PIO_RESOURCE_REQUIREMENTS_LIST requirements;

   PAGED_CODE();

   if ((Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) ||
       (Child->Parent == NULL)) {
       return STATUS_NO_SUCH_DEVICE;
   }

   status = MfBuildChildRequirements(Child, &requirements);

   if (NT_SUCCESS(status)) {
#if DBG
      DEBUG_MSG(1, ("Reporting resource requirements for child 0x%08x\n", Child));
      MfDbgPrintIoResReqList(1, requirements);
#endif
      Irp->IoStatus.Information = (ULONG_PTR) requirements;
   }

   return status;

}


NTSTATUS
MfQueryDeviceTextPdo(
                    IN PIRP Irp,
                    IN PMF_CHILD_EXTENSION Child,
                    IN PIO_STACK_LOCATION IrpStack
                    )
{
   NTSTATUS status;

   PAGED_CODE();

   if (IrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {
#define MF_DEFAULT_DEVICE_TEXT L"Multifunction Device"
       ULONG len = sizeof(MF_DEFAULT_DEVICE_TEXT);
       PWSTR pStr;

       pStr = ExAllocatePool(PagedPool, len);
      
       if (!pStr) {
           status = STATUS_INSUFFICIENT_RESOURCES;
       } else {
           RtlCopyMemory(pStr, MF_DEFAULT_DEVICE_TEXT, len);
           Irp->IoStatus.Information = (ULONG_PTR) pStr;
           status = STATUS_SUCCESS;
       }
   } else {
       status = Irp->IoStatus.Status;
   }

   return status;
}

NTSTATUS
MfQueryIdPdo(
            IN PIRP Irp,
            IN PMF_CHILD_EXTENSION Child,
            IN PIO_STACK_LOCATION IrpStack
            )
{

   NTSTATUS status = STATUS_SUCCESS;
   PUNICODE_STRING copy;
   PVOID buffer = NULL;

   PAGED_CODE();

   Irp->IoStatus.Information = 0;

   if ((Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) ||
       (Child->Parent == NULL)) {
       return STATUS_NO_SUCH_DEVICE;
   }

   switch (IrpStack->Parameters.QueryId.IdType) {
   case BusQueryDeviceID:       // <Enumerator>\<Enumerator-specific device id>

       return MfBuildDeviceID(Child->Parent,
                              (PWSTR*)&Irp->IoStatus.Information
                              );
       break;


   case BusQueryInstanceID:     // persistent id for this instance of the device

       return MfBuildInstanceID(Child,
                                (PWSTR*)&Irp->IoStatus.Information
                                );

       break;

   case BusQueryHardwareIDs:    // Hardware ids

       copy = &Child->Info.HardwareID;

       break;

   case BusQueryCompatibleIDs:  // compatible device ids

       copy = &Child->Info.CompatibleID;

       break;

   default:

       return Irp->IoStatus.Status;
   }

   ASSERT(copy);

   if (copy->Length == 0) {
       return STATUS_INVALID_PARAMETER;
   }
   
   //
   // Allocate the buffer for the ID and copy it
   //

   buffer = ExAllocatePoolWithTag(PagedPool,
                                  copy->Length,
                                  MF_HARDWARE_COMPATIBLE_ID_TAG
                                 );

   if (!buffer) {
       return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlCopyMemory(buffer, copy->Buffer, copy->Length);

   Irp->IoStatus.Information = (ULONG_PTR) buffer;

   return STATUS_SUCCESS;
}



NTSTATUS
MfQueryPnpDeviceStatePdo(
                        IN PIRP Irp,
                        IN PMF_CHILD_EXTENSION Child,
                        IN PIO_STACK_LOCATION IrpStack
                        )
{
    PAGED_CODE();

    if (Child->Common.PagingCount > 0
        ||  Child->Common.HibernationCount > 0
        ||  Child->Common.DumpCount > 0) {
        Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
    }

    return STATUS_SUCCESS;
}

//
// --- Power operations ---
//

NTSTATUS
MfDispatchPowerPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_CHILD_EXTENSION Child,
    IN PIO_STACK_LOCATION IrpStack,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for PDO.  It dispatches
    to the routines described in the PoDispatchTable entry in the
    device object extension.

    This routine is NOT pageable as it can be called at DISPATCH_LEVEL

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Child - PDO extension
    
    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

    IrpStack

Return Value:

    NT status.

--*/
{
    NTSTATUS status;
    PMF_COMMON_EXTENSION common = (PMF_COMMON_EXTENSION) Child;


    if ((Child->Common.DeviceState & (MF_DEVICE_SURPRISE_REMOVED|MF_DEVICE_DELETED)) ||
        (Child->Parent == NULL)) {
        PoStartNextPowerIrp(Irp);
        status = STATUS_NO_SUCH_DEVICE;
    } else if ((IrpStack->MinorFunction <= IRP_MN_PO_MAXIMUM_FUNCTION) &&
               (MfPoDispatchTablePdo[IrpStack->MinorFunction])) {

        //
        // We are interested in this irp...
        //

        DEBUG_MSG(1,
                    ("--> Dispatching %s IRP for PDO 0x%08x\n",
                     PO_IRP_STRING(IrpStack->MinorFunction),
                     DeviceObject
                    ));

        status =
            MfPoDispatchTablePdo[IrpStack->MinorFunction](Irp,
                                                          (PVOID) common,
                                                          IrpStack
                                                          );
    } else {

        //
        // We don't know about this irp
        //

        DEBUG_MSG(0,
                    ("Unknown POWER IRP 0x%x for PDO 0x%08x\n",
                     IrpStack->MinorFunction,
                     DeviceObject
                    ));

        PoStartNextPowerIrp(Irp);
        status = STATUS_NOT_SUPPORTED;
    }

    if (status != STATUS_NOT_SUPPORTED) {

        //
        // We understood the irp so we can set status - otherwise leave
        // the status alone as we don't know what we are doing and a filter
        // might have done the job for us!
        //

        Irp->IoStatus.Status = status;

        DEBUG_MSG(1,
                  ("<-- Completing irp with status %s (0x%08x)\n",
                   STATUS_STRING(status),
                   status
                   ));

    } else {

        DEBUG_MSG(1,
                  ("<-- Completing unhandled irp, status is %s (0x%08x)\n",
                   STATUS_STRING(Irp->IoStatus.Status),
                   Irp->IoStatus.Status
                   ));

        status = Irp->IoStatus.Status;

    }

    ASSERT(status == Irp->IoStatus.Status);
    
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
MfSetPowerPdo(
             IN PIRP Irp,
             IN PMF_CHILD_EXTENSION Child,
             IN PIO_STACK_LOCATION IrpStack
             )
{

   NTSTATUS status;
   POWER_STATE previousState;

   UNREFERENCED_PARAMETER(Irp);

   //
   // If this is a system power state then someone else in the stack will have
   // set the policy and we just leave well alone as we don't know anything
   // about the hardware.
   //

   if (IrpStack->Parameters.Power.Type == DevicePowerState) {
       MfUpdatePowerPdo(Child,
                        IrpStack->Parameters.Power.State.DeviceState);
   }

   PoStartNextPowerIrp(Irp);
   return STATUS_SUCCESS;
}

NTSTATUS
MfQueryPowerPdo(
               IN PIRP Irp,
               IN PMF_CHILD_EXTENSION Child,
               IN PIO_STACK_LOCATION IrpStack
               )
{

   UNREFERENCED_PARAMETER(Irp);
   UNREFERENCED_PARAMETER(Child);
   UNREFERENCED_PARAMETER(IrpStack);

   //
   // We can go to any power state...
   //

   PoStartNextPowerIrp(Irp);
   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\mf\resource.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    arbiter.c

Abstract:

    This module provides arbiters for the resources consumed by PDOs.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#include "mfp.h"

NTSTATUS
MfUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
MfPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
MfUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

NTSTATUS
MfRequirementFromResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource,
    OUT PIO_RESOURCE_DESCRIPTOR Requirement
    );

NTSTATUS
MfUpdateResource(
    IN OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource,
    IN ULONGLONG Start,
    IN ULONG Length
    );

//
// Make everything pageable
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, MfFindResourceType)
#pragma alloc_text(PAGE, MfUnpackRequirement)
#pragma alloc_text(PAGE, MfPackResource)
#pragma alloc_text(PAGE, MfUnpackResource)
#pragma alloc_text(PAGE, MfUpdateResource)

#endif // ALLOC_PRAGMA

//
// This table describes the resource types that are understood by the MF driver.
// It is implemented thus to that in the future MF could be educated about new
// resource types dynamically.
//

MF_RESOURCE_TYPE MfResourceTypes[] = {

    {
        CmResourceTypePort,
        MfUnpackRequirement,
        MfPackResource,
        MfUnpackResource,
        MfRequirementFromResource,
        MfUpdateResource

    },

    {
        CmResourceTypeInterrupt,
        MfUnpackRequirement,
        MfPackResource,
        MfUnpackResource,
        MfRequirementFromResource,
        MfUpdateResource
    },

    {
        CmResourceTypeMemory,
        MfUnpackRequirement,
        MfPackResource,
        MfUnpackResource,
        MfRequirementFromResource,
        MfUpdateResource
    },

    {
        CmResourceTypeDma,
        MfUnpackRequirement,
        MfPackResource,
        MfUnpackResource,
        MfRequirementFromResource,
        MfUpdateResource
    },

    {
        CmResourceTypeBusNumber,
        MfUnpackRequirement,
        MfPackResource,
        MfUnpackResource,
        MfRequirementFromResource,
        MfUpdateResource
    }
};

NTSTATUS
MfRequirementFromResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource,
    OUT PIO_RESOURCE_DESCRIPTOR Requirement
    )
/*++

Routine Description:

    This function build an requirements descriptor for a resource the parent is
    started with.

Arguments:

    Resource - Pointer to the resource to make a requirement from

    Requirement - Pointer to a descriptor that should be filled in

Return Value:

    Success or otherwise of the operation

--*/
{

    //
    // Copy the common fields
    //

    Requirement->Type = Resource->Type;
    Requirement->ShareDisposition =  Resource->ShareDisposition;
    Requirement->Flags = Resource->Flags;

    //
    // Fill in the requirement
    //

    switch (Resource->Type) {
    case CmResourceTypeMemory:
    case CmResourceTypePort:

        //
        // We *DO NOT* support zero length requirements
        //

        if (Resource->u.Generic.Length == 0) {
            return STATUS_INVALID_PARAMETER;
        }

        Requirement->u.Generic.MinimumAddress = Resource->u.Generic.Start;
        Requirement->u.Generic.MaximumAddress.QuadPart =
            Resource->u.Generic.Start.QuadPart + Resource->u.Generic.Length - 1;
        Requirement->u.Generic.Length = Resource->u.Generic.Length;
        Requirement->u.Generic.Alignment = 1;
        break;

    case CmResourceTypeInterrupt:
        Requirement->u.Interrupt.MinimumVector = Resource->u.Interrupt.Vector;
        Requirement->u.Interrupt.MaximumVector = Resource->u.Interrupt.Vector;
        break;

    case CmResourceTypeDma:
        Requirement->u.Dma.MinimumChannel = Resource->u.Dma.Channel;
        Requirement->u.Dma.MinimumChannel = Resource->u.Dma.Channel;
        break;

    case CmResourceTypeBusNumber:

        //
        // We *DO NOT* support zero length requirements
        //

        if (Resource->u.BusNumber.Length == 0) {
            return STATUS_INVALID_PARAMETER;
        }

        Requirement->u.BusNumber.Length = Resource->u.BusNumber.Length;
        Requirement->u.BusNumber.MinBusNumber = Resource->u.BusNumber.Start;
        Requirement->u.BusNumber.MaxBusNumber = Resource->u.BusNumber.Start +
                                                Resource->u.BusNumber.Length - 1;
        break;

    case CmResourceTypeDevicePrivate:
        Requirement->u.DevicePrivate.Data[0] = Resource->u.DevicePrivate.Data[0];
        Requirement->u.DevicePrivate.Data[1] = Resource->u.DevicePrivate.Data[1];
        Requirement->u.DevicePrivate.Data[2] = Resource->u.DevicePrivate.Data[2];
        break;

    default:
        return STATUS_INVALID_PARAMETER;

    }

    return STATUS_SUCCESS;

}

PMF_RESOURCE_TYPE
MfFindResourceType(
    IN CM_RESOURCE_TYPE Type
    )
/*++

Routine Description:

    This routine searches the database of know resource types to find the
    resource descriptor manipulation routines for resources of type Type.

Arguments:

    Type - The resource type we are interested in.

Return Value:

    Returns a pointer to the appropriate MF_RESOURCE_TYPE or NULL if one could
    not be found.

--*/


{
    PMF_RESOURCE_TYPE current;

    PAGED_CODE();

    FOR_ALL_IN_ARRAY(MfResourceTypes,
                     sizeof(MfResourceTypes) / sizeof(MF_RESOURCE_TYPE),
                     current
                     ) {

        if (current->Type == Type) {
            return current;
        }
    }

    return NULL;
}


NTSTATUS
MfUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Minimum - Pointer to where the minimum acceptable start value should be
        unpacked to.

    Maximum - Pointer to where the maximum acceptable end value should be
        unpacked to.

    Length - Pointer to where the required length should be unpacked to.

    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{

    PAGED_CODE();

    switch (Descriptor->Type) {
    case CmResourceTypePort:
    case CmResourceTypeMemory:

        *Maximum = Descriptor->u.Generic.MaximumAddress.QuadPart;
        *Minimum = Descriptor->u.Generic.MinimumAddress.QuadPart;
        *Length = Descriptor->u.Generic.Length;
        *Alignment = Descriptor->u.Generic.Alignment;
        break;

    case CmResourceTypeInterrupt:

        *Maximum = Descriptor->u.Interrupt.MaximumVector;
        *Minimum = Descriptor->u.Interrupt.MinimumVector;
        *Length = 1;
        *Alignment = 1;
        break;

    case CmResourceTypeDma:
        *Maximum = Descriptor->u.Dma.MaximumChannel;
        *Minimum = Descriptor->u.Dma.MinimumChannel;
        *Length = 1;
        *Alignment = 1;
        break;

    case CmResourceTypeBusNumber:
        *Maximum = Descriptor->u.BusNumber.MaxBusNumber;
        *Minimum = Descriptor->u.BusNumber.MinBusNumber;
        *Length = Descriptor->u.BusNumber.Length;
        *Alignment = 1;
        break;

    default:
        return STATUS_INVALID_PARAMETER;

    }
         
    //
    // Zero alignment is illegal.
    //
    if (*Alignment == 0) {
        *Alignment = 1;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MfPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.

Arguments:

    Requirement - The requirement from which this resource was chosen.

    Start - The start value of the resource.

    Descriptor - Pointer to the descriptor to pack into.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();

    switch (Requirement->Type) {
    case CmResourceTypePort:
    case CmResourceTypeMemory:
        Descriptor->u.Generic.Start.QuadPart = Start;
        Descriptor->u.Generic.Length = Requirement->u.Generic.Length;
        break;

    case CmResourceTypeInterrupt:
        ASSERT(Start <= MAXULONG);
        Descriptor->u.Interrupt.Level = (ULONG)Start;
        Descriptor->u.Interrupt.Vector = (ULONG)Start;
        Descriptor->u.Interrupt.Affinity = 0xFFFFFFFF;
        break;

    case CmResourceTypeDma:
        ASSERT(Start <= MAXULONG);
        Descriptor->u.Dma.Channel = (ULONG)Start;
        Descriptor->u.Dma.Port = 0;
        break;

    case CmResourceTypeBusNumber:
        ASSERT(Start <= MAXULONG);
        Descriptor->u.BusNumber.Start = (ULONG)Start;
        Descriptor->u.BusNumber.Length = Requirement->u.BusNumber.Length;
        break;

    default:
        return STATUS_INVALID_PARAMETER;
    }

    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->Type = Requirement->Type;

    return STATUS_SUCCESS;

}

NTSTATUS
MfUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks a resource descriptor.

Arguments:

    Descriptor - The descriptor describing the resource to unpack.

    Start - Pointer to where the start value should be unpacked to.

    End - Pointer to where the end value should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();

    switch (Descriptor->Type) {
    case CmResourceTypePort:
    case CmResourceTypeMemory:
        *Start = Descriptor->u.Generic.Start.QuadPart;
        *Length = Descriptor->u.Generic.Length;
        break;

    case CmResourceTypeInterrupt:
        *Start = Descriptor->u.Interrupt.Vector;
        *Length = 1;
        break;

    case CmResourceTypeDma:
        *Start = Descriptor->u.Dma.Channel;
        *Length = 1;
        break;

    case CmResourceTypeBusNumber:
        *Start = Descriptor->u.BusNumber.Start;
        *Length = Descriptor->u.BusNumber.Length;
        break;

    default:
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MfUpdateResource(
    IN OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource,
    IN ULONGLONG Start,
    IN ULONG Length
    )
{
    PAGED_CODE();

    ASSERT(Resource);

    switch (Resource->Type) {

    case CmResourceTypePort:
    case CmResourceTypeMemory:
        Resource->u.Generic.Start.QuadPart = Start;
        Resource->u.Generic.Length = Length;
        break;

    case CmResourceTypeInterrupt:
        ASSERT(Start < MAXULONG);
        Resource->u.Interrupt.Vector = (ULONG)Start;
        break;

    case CmResourceTypeDma:
        ASSERT(Start < MAXULONG);
        Resource->u.Dma.Channel = (ULONG)Start;
        break;

    case CmResourceTypeBusNumber:
        ASSERT(Start < MAXULONG);
        Resource->u.BusNumber.Start = (ULONG)Start;
        Resource->u.BusNumber.Length = Length;
        break;

    default:
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\inc\card.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    card.h

Abstract:

    These are the structures used for various card related requests.

Author:

    Bob Rinne (BobRi) 3-Aug-1994
    Jeff McLeman (mcleman@zso.dec.com)
    Neil Sandlin (neilsa) June 1 1999

Revision History:

--*/
#ifndef _PCMCIA_CARD_H_
#define _PCMCIA_CARD_H_
//
// Define request types
//

#define IO_REQUEST          0x1
#define IRQ_REQUEST         0x2
#define CONFIGURE_REQUEST   0x3
#define MEM_REQUEST         0x4
#define DECONFIGURE_REQUEST 0x6

//
// Define an I/O range request structure
//

typedef struct _CARD_REQUEST_IO {

    struct _CARD_IO_ENTRY {
        ULONG  BasePort;
        ULONG  NumPorts;
        UCHAR  Attributes;
    } IoEntry[MAX_NUMBER_OF_IO_RANGES];

    USHORT  NumberOfRanges;

}CARD_REQUEST_IO, *PCARD_REQUEST_IO;

//
// Define I/O attributes
//

#define IO_WAIT_STATE_16   0x1
#define IO_SOURCE_16       0x2
#define IO_ZERO_WAIT_8     0x4
#define IO_DATA_PATH_WIDTH 0x8


//
// Define an IRQ Request structure
//

typedef struct _CARD_REQUEST_IRQ {

    USHORT Attributes;
    UCHAR  AssignedIRQ;
    UCHAR  ReadyIRQ;
    UCHAR  IRQInfo1;
    UCHAR  IRQInfo2;

}CARD_REQUEST_IRQ, *PCARD_REQUEST_IRQ;

//
// define the IRQ request attributes
//

#define IRQ_EXCLUSIVE    0x00
#define IRQ_TIME_SHARED  0x01
#define IRQ_DYN_SHARED   0x02
#define IRQ_RESERVED     0x03

#define IRQ_FORCE_PULSED 0x04
#define IRQ_FIRST_SHARED 0x08
#define IRQ_PULSE_ALLOC  0x10

//
// define a configuration request
//

typedef struct _CARD_REQUEST_CONFIG {

    ULONG  ConfigBase;
    USHORT Attributes;
    UCHAR  RegisterWriteMask;
    UCHAR  InterfaceType;
    UCHAR  ConfigIndex;
    UCHAR  CardConfiguration;
    UCHAR  PinPlacement;
    UCHAR  SocketCopyRegister;
    UCHAR  ExtendedStatusRegister;
    ULONG  IoBaseRegister;
    UCHAR  IoLimitRegister;

} CARD_REQUEST_CONFIG, *PCARD_REQUEST_CONFIG;

//
// Define associated bits for above
//

//
// InterfaceType
//

#define CONFIG_INTERFACE_MEM    0x0
#define CONFIG_INTERFACE_IO_MEM 0x1

//
// RegisterWriteMask is a bit mask that controls what configuration registers are
// modified in the CONFIGURE_REQUEST call.
//

#define REGISTER_WRITE_CONFIGURATION_INDEX 0x01    /* Configuration Option Register          */
#define REGISTER_WRITE_CARD_CONFIGURATION  0x02    /* Card Configuration and Status Register */
#define REGISTER_WRITE_PIN_PLACEMENT       0x04    /* Pin Placement Register   */
#define REGISTER_WRITE_COPY_REGISTER       0x08    /* Socket and Copy Register */
#define REGISTER_WRITE_EXTENDED_STATUS     0x10    /* Extended Status Register */
#define REGISTER_WRITE_IO_BASE             0x20    /* I/O Base Register        */
#define REGISTER_WRITE_IO_LIMIT            0x40    /* I/O Limit Register       */

//
// define a request memory window structure
//

typedef struct _CARD_REQUEST_MEM {

    struct _CARD_MEMORY_ENTRY {
        ULONG   BaseAddress;
        ULONG   HostAddress;
        ULONG   WindowSize;
        UCHAR   AttributeMemory;
        BOOLEAN WindowDataSize16;
        UCHAR   WaitStates;
    } MemoryEntry[MAX_NUMBER_OF_MEMORY_RANGES];

    USHORT  NumberOfRanges;
    USHORT  Attributes;
    UCHAR   AccessSpeed;

}CARD_REQUEST_MEM, *PCARD_REQUEST_MEM;

//
// Defined attribute bits for request_mem
//

#define MEM_ATTRIBUTE          0x02
#define MEM_ENABLED            0x04
#define MEM_DATA_PATH_WIDTH_16 0x08
#define MEM_PAGED              0x10
#define MEM_SHARED             0x20
#define MEM_FIRST_SHARED       0x40
#define MEM_BIND_SPECIFIC      0x80
#define MEM_CRD_OFFSET_SIZED   0x100

#define MEM_SPEED_CODE         0x07
#define MEM_SPEED_EXP          0x07
#define MEM_SPEED_MANTISSA     0x78
#define MEM_WAIT               0x80

#define MEM_SPEED_250          0x02
#define MEM_SPEED_200          0x04
#define MEM_SPEED_150          0x08
#define MEM_SPEED_100          0x10

typedef struct _CARD_TUPLE_REQUEST {
    PVOID  SocketPointer;
    PUCHAR Buffer;
    USHORT BufferSize;
    USHORT Socket;
} CARD_TUPLE_REQUEST, *PCARD_TUPLE_REQUEST;

//
// Card configuration request packet.
//

typedef struct _CARD_REQUEST {
    USHORT  RequestType;
    union {
        CARD_REQUEST_IRQ    Irq;
        CARD_REQUEST_CONFIG Config;
        CARD_REQUEST_MEM    Memory;
        CARD_REQUEST_IO     Io;
    } u;
} CARD_REQUEST, *PCARD_REQUEST;

#endif //_PCMCIA_CARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\inc\cb.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    cb.h

Abstract:

    This header contains generic cardbus definitions.

Author(s):

    Neil Sandlin (neilsa)

Revisions:

--*/

#ifndef _PCMCIA_CB_H_
#define _PCMCIA_CB_H_

//
// Cardbus register definitions
//

#define CARDBUS_EXCA_REGISTER_BASE  0x800

#define CARDBUS_SOCKET_EVENT_REG             0x0
#define CARDBUS_SOCKET_MASK_REG              0x4
#define CARDBUS_SOCKET_PRESENT_STATE_REG     0x8
#define CARDBUS_SOCKET_FORCE_EVENT_REG       0xc
#define CARDBUS_SOCKET_CONTROL_REG           0x10


//
// Masks for testing SOCKET_PRESENT_STATE Register
//

#define CARDBUS_CARDSTS                     0x1
#define CARDBUS_CD1                         0x2
#define CARDBUS_CD2                         0x4
#define CARDBUS_PWRCYCLE                    0x8
#define CARDBUS_16BIT_CARD                  0x10
#define CARDBUS_CB_CARD                     0x20
#define CARDBUS_READY                       0x40
#define CARDBUS_NOT_A_CARD                  0x80
#define CARDBUS_DATALOST                    0x100
#define CARDBUS_BAD_VCC_REQ                 0x200
#define CARDBUS_CARD_SUPPORTS_5V            0x400
#define CARDBUS_CARD_SUPPORTS_3V            0x800
#define CARDBUS_CARD_SUPPORTS_XV            0x1000
#define CARDBUS_CARD_SUPPORTS_YV            0x2000
#define CARDBUS_SOCKET_SUPPORTS_5V          0x10000000
#define CARDBUS_SOCKET_SUPPORTS_3V          0x20000000
#define CARDBUS_SOCKET_SUPPORTS_XV          0x40000000
#define CARDBUS_SOCKET_SUPPORTS_YV          0x80000000


//CardBus Registers
#define CBREG_SKTEVENT                  0x00
#define CBREG_SKTMASK                   0x04
#define CBREG_SKTSTATE                  0x08
#define CBREG_SKTFORCE                  0x0c
#define CBREG_SKTPOWER                  0x10

//TI CardBus Registers
#define CBREG_TI_SKT_POWER_MANAGEMENT   0x20
#define CBREG_TI_CLKCTRLLEN             0x00010000L
#define CBREG_TI_CLKCTRL                0x00000001L

//O2Micro CardBus Registers
#define CBREG_O2MICRO_ZVCTRL     0x20
#define ZVCTRL_ZV_ENABLE      0x01

//Socket Event Register bits
#define SKTEVENT_CSTSCHG                0x00000001L
#define SKTEVENT_CCD1                   0x00000002L
#define SKTEVENT_CCD2                   0x00000004L
#define SKTEVENT_CCD_MASK               (SKTEVENT_CCD1 | SKTEVENT_CCD2)
#define SKTEVENT_POWERCYCLE             0x00000008L
#define SKTEVENT_MASK                   0x0000000fL

//Socket Mask Register bits
#define SKTMSK_CSTSCHG                  0x00000001L
#define SKTMSK_CCD                      0x00000006L
#define SKTMSK_CCD1                     0x00000002L
#define SKTMSK_CCD2                     0x00000004L
#define SKTMSK_POWERCYCLE               0x00000008L

//Socket Present State Register bits
#define SKTSTATE_CSTSCHG                0x00000001L
#define SKTSTATE_CCD1                   0x00000002L
#define SKTSTATE_CCD2                   0x00000004L
#define SKTSTATE_CCD_MASK               (SKTSTATE_CCD1 | SKTSTATE_CCD2)
#define SKTSTATE_POWERCYCLE             0x00000008L
#define SKTSTATE_CARDTYPE_MASK          0x00000030L
#define SKTSTATE_R2CARD                 0x00000010L
#define SKTSTATE_CBCARD                 0x00000020L
#define SKTSTATE_OPTI_DOCK              0x00000030L
#define CARDTYPE(dw)       ((dw) & SKTSTATE_CARDTYPE_MASK)
#define SKTSTATE_CARDINT                0x00000040L
#define SKTSTATE_NOTACARD               0x00000080L
#define SKTSTATE_DATALOST               0x00000100L
#define SKTSTATE_BADVCCREQ              0x00000200L
#define SKTSTATE_5VCARD                 0x00000400L
#define SKTSTATE_3VCARD                 0x00000800L
#define SKTSTATE_XVCARD                 0x00001000L
#define SKTSTATE_YVCARD                 0x00002000L
#define SKTSTATE_CARDVCC_MASK    (SKTSTATE_5VCARD | SKTSTATE_3VCARD | \
                SKTSTATE_XVCARD | SKTSTATE_YVCARD)
#define SKTSTATE_5VSOCKET               0x10000000L
#define SKTSTATE_3VSOCKET               0x20000000L
#define SKTSTATE_XVSOCKET               0x40000000L
#define SKTSTATE_YVSOCKET               0x80000000L
#define SKTSTATE_SKTVCC_MASK     (SKTSTATE_5VSOCKET | \
                SKTSTATE_3VSOCKET | \
                SKTSTATE_XVSOCKET | \
                SKTSTATE_YVSOCKET)

//Socket Froce Register bits
#define SKTFORCE_CSTSCHG                0x00000001L
#define SKTFORCE_CCD1                   0x00000002L
#define SKTFORCE_CCD2                   0x00000004L
#define SKTFORCE_POWERCYCLE             0x00000008L
#define SKTFORCE_R2CARD                 0x00000010L
#define SKTFORCE_CBCARD                 0x00000020L
#define SKTFORCE_NOTACARD               0x00000080L
#define SKTFORCE_DATALOST               0x00000100L
#define SKTFORCE_BADVCCREQ              0x00000200L
#define SKTFORCE_5VCARD                 0x00000400L
#define SKTFORCE_3VCARD                 0x00000800L
#define SKTFORCE_XVCARD                 0x00001000L
#define SKTFORCE_YVCARD                 0x00002000L
#define SKTFORCE_CVSTEST                0x00004000L
#define SKTFORCE_5VSOCKET     0x10000000L
#define SKTFORCE_3VSOCKET     0x20000000L
#define SKTFORCE_XVSOCKET     0x40000000L
#define SKTFORCE_YVSOCKET     0x80000000L

//Power Control Register bits
#define SKTPOWER_VPP_CONTROL            0x00000007L
#define SKTPOWER_VPP_OFF                0x00000000L
#define SKTPOWER_VPP_120V               0x00000001L
#define SKTPOWER_VPP_050V               0x00000002L
#define SKTPOWER_VPP_033V               0x00000003L
#define SKTPOWER_VPP_0XXV               0x00000004L
#define SKTPOWER_VPP_0YYV               0x00000005L
#define SKTPOWER_VCC_CONTROL            0x00000070L
#define SKTPOWER_VCC_OFF                0x00000000L
#define SKTPOWER_VCC_050V               0x00000020L
#define SKTPOWER_VCC_033V               0x00000030L
#define SKTPOWER_VCC_0XXV               0x00000040L
#define SKTPOWER_VCC_0YYV               0x00000050L
#define SKTPOWER_STOPCLOCK              0x00000080L

//Misc. CardBus Constants
#define NUMWIN_BRIDGE                   4       //2 Mem + 2 IO
#define EXCAREG_OFFSET                  0x0800


//
// Number of times we attempt to look at a cardbus device which has
// invalid config space.
//
// This is so that for cards like the Adaptec SlimScsi
// on TI 1250, 1260 etc. power managed controllers,
// the config space needs to be read at least twice
// to ensure reliability
//

#define CARDBUS_CONFIG_RETRY_COUNT     5

//
// The pcmcia spec only specifies 20 msec for the reset setup delay, but
// I'm seeing machine/card combination that need a lot more.
// For example:
//    Gateway Solo 9100 with 3Com/Mhz 10/100 LAN CardBus card
//    Gateway 2000 Solo with a 3c575-TX
//    Toshiba Tecra 540CDT with (unknown)
//
#define PCMCIA_CB_MODEM_READY_DELAY       1000000 // 1 sec

#define PCMCIA_CB_RESET_WIDTH_DELAY       100     // 100 usec

//
// The pcmcia spec says this should be 50msec, but some hardware seems
// to need more (for example, a Thinkpad 600 with a Xircom realport modem)
//
#define PCMCIA_CB_RESET_SETUP_DELAY       100000  // 100 msec

#define PCMCIA_CB_STALL_POWER             400000  //400ms

#endif  // _PCMCIA_CB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\mf\utils.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module provides general utility functions.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "mfp.h"

VOID
MfInitCommonExtension(
    PMF_COMMON_EXTENSION Common,
    MF_OBJECT_TYPE Type
    );

NTSTATUS
MfGetSubkeyByIndex(
    IN HANDLE ParentHandle,
    IN ULONG Index,
    IN ACCESS_MASK Access,
    OUT PHANDLE ChildHandle,
    OUT PUNICODE_STRING Name
    );

NTSTATUS
MfGetRegistryValue(
    IN HANDLE Handle,
    IN PWSTR Name,
    IN ULONG Type,
    IN ULONG Flags,
    IN OUT PULONG DataLength,
    IN OUT PVOID *Data
    );

NTSTATUS
MfSendPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION Location,
    OUT PULONG_PTR Information OPTIONAL
    );

DEVICE_POWER_STATE
MfFindLowestChildPowerState(
    IN PMF_PARENT_EXTENSION Parent
    );

NTSTATUS
MfPowerRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
MfSendSetPowerIrp(
    IN PDEVICE_OBJECT Target,
    IN POWER_STATE State
    );


#ifdef ALLOC_PRAGMA

// NOTE: Should see if the rest of the funcs can be moved out of this
// file.

#pragma alloc_text(PAGE, MfInitCommonExtension)
#pragma alloc_text(PAGE, MfGetSubkeyByIndex)
#pragma alloc_text(PAGE, MfGetRegistryValue)
#pragma alloc_text(PAGE, MfSendPnpIrp)

#endif


VOID
MfInitCommonExtension(
    PMF_COMMON_EXTENSION Common,
    MF_OBJECT_TYPE Type
    )
/*++

Routine Description:

    This initializes the fields in the common header of the device extension

Arguments:

    Common - The common header to initialize

    Type - The type of the object being initialized (ie PDO or FDO)

Return Value:

    None

--*/

{
    Common->Type = Type;
}

VOID
MfFreeDeviceInfo(
    PMF_DEVICE_INFO Info
    )
{
    if (Info->Name.Buffer) {
        ExFreePool(Info->Name.Buffer);
        Info->Name.Buffer = NULL;
    }

    if (Info->HardwareID.Buffer) {
        ExFreePool(Info->HardwareID.Buffer);
        Info->HardwareID.Buffer = NULL;
    }

    if (Info->CompatibleID.Buffer) {
        ExFreePool(Info->CompatibleID.Buffer);
        Info->CompatibleID.Buffer = NULL;
    }

    if (Info->ResourceMap) {
        ExFreePool(Info->ResourceMap);
        Info->ResourceMap = NULL;
    }

    if (Info->VaryingResourceMap) {
        ExFreePool(Info->VaryingResourceMap);
        Info->VaryingResourceMap = NULL;
    }
}

NTSTATUS
MfGetSubkeyByIndex(
    IN HANDLE ParentHandle,
    IN ULONG Index,
    IN ACCESS_MASK Access,
    OUT PHANDLE ChildHandle,
    OUT PUNICODE_STRING Name
    )

/*++

Routine Description:

    This returns the name and a handle to a subkey given that keys index

Arguments:

    ParentHandle - The handle of the key the subkeys are located under

    Index - The index of the subkey required

    Access - The type of access required to the subkey

    ChildHandle - On success contains a handle to the subkey

    Name - On success contains the name of the subkey

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{

#define INFO_BUFFER_SIZE sizeof(KEY_BASIC_INFORMATION) + 255*sizeof(WCHAR)

    NTSTATUS status;
    UCHAR buffer[INFO_BUFFER_SIZE];
    PKEY_BASIC_INFORMATION info = (PKEY_BASIC_INFORMATION) buffer;
    ULONG resultSize;
    HANDLE childHandle;
    UNICODE_STRING string = {0};
    OBJECT_ATTRIBUTES attributes;

    status = ZwEnumerateKey(ParentHandle,
                            Index,
                            KeyBasicInformation,
                            info,
                            INFO_BUFFER_SIZE,
                            &resultSize
                            );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Copy the name
    //

    ASSERT(info->NameLength <= MAXUSHORT);

    string.Length = (USHORT) info->NameLength;
    string.MaximumLength = (USHORT) info->NameLength;
    string.Buffer = ExAllocatePoolWithTag(PagedPool,
                                          info->NameLength,
                                          MF_POOL_TAG
                                          );

    if (!string.Buffer) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    RtlCopyMemory(string.Buffer, info->Name, info->NameLength);

    //
    // Open the name to get a handle
    //

    InitializeObjectAttributes(&attributes,
                               &string,
                               0,   //Attributes
                               ParentHandle,
                               NULL //SecurityDescriptoy
                               );

    status = ZwOpenKey(&childHandle,
                       Access,
                       &attributes
                       );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }


    DEBUG_MSG(1, ("\tSubkey %wZ\n", &string));

    //
    // Hand the name back to the caller
    //

    Name->Buffer = string.Buffer;
    Name->Length = string.Length;
    Name->MaximumLength = string.MaximumLength;

    *ChildHandle = childHandle;

    return STATUS_SUCCESS;

cleanup:

    if (string.Buffer) {
        ExFreePool(string.Buffer);
    }
    //
    // We should never be able to overflow as our buffer is the max size of
    // a registry key name
    //
    ASSERT(status != STATUS_BUFFER_OVERFLOW);

    return status;

}



NTSTATUS
MfGetRegistryValue(
    IN HANDLE Handle,
    IN PWSTR Name,
    IN ULONG Type,
    IN ULONG Flags,
    IN OUT PULONG DataLength,
    IN OUT PVOID *Data
    )

/*++

Routine Description:

    This retrieves a value key from the registry performing type and sanity
    checking

Arguments:

    Handle - The key the values are located under

    Name - The name of the value

    Type - The type (REG_*) of the value

    DataLength - Points to the length of the data buffer, on success contains
        the size of the data

    Data - Pointer to pointer to the buffer to return the data in, if points to
        NULL a buffer of the right size should be allocated (in this case
        DataLength should be 0)

Return Value:

    Status code that indicates whether or not the function was successful.  If
    the type of the object is not Type then we fail with STATUS_OBJECT_TYPE_MISMATCH

--*/

{

#define VALUE_BUFFER_SIZE PAGE_SIZE

    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION info = NULL;
    ULONG size = VALUE_BUFFER_SIZE, length;
    UNICODE_STRING string;
    BOOLEAN convertSzToMultiSz;
    PWCHAR stringEnd, remainingBufferPtr;
    SIZE_T stringLength, sizeRemaining;
    ULONG remainingBufferLength;

    PAGED_CODE();

    //
    // Check parameters.
    // For all types but REG_DWORD, which has special rules, if the caller
    // provided a buffer, make sure he also provided the size of the buffer.
    //

    if ((Type != REG_DWORD) &&
        (*Data && (!DataLength || !(*DataLength)))) {
        
        ASSERT(FALSE);
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    RtlInitUnicodeString(&string, Name);

    info = ExAllocatePoolWithTag(PagedPool,
                                 VALUE_BUFFER_SIZE,
                                 MF_POOL_TAG
                                 );
    if (!info) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    while ((status = ZwQueryValueKey(Handle,
                                     &string,
                                     KeyValuePartialInformation,
                                     info,
                                     size,
                                     &size
                                     )) == STATUS_BUFFER_OVERFLOW) {
        ExFreePool(info);

        info = ExAllocatePoolWithTag(PagedPool,
                                     size,
                                     MF_POOL_TAG
                                     );

        if (!info) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

    }

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }


    convertSzToMultiSz = (Type == REG_MULTI_SZ
                          && info->Type == REG_SZ
                          && Flags & MF_GETREG_SZ_TO_MULTI_SZ
                          );

    //
    // Make sure the type we got back is what we expected
    //

    if (info->Type != Type && !convertSzToMultiSz) {

        status = STATUS_OBJECT_TYPE_MISMATCH;
        goto cleanup;
    }

    //
    // Apply various common sense checks based on the type.
    // At the same time, compute the size of the buffer needed
    // to store the data.
    //

    if (info->Type == REG_DWORD) {

        //
        // If the data is a REG_DWORD then Data is a pointer to a ULONG to store
        // the data.  This is different behavior than all other data types, so
        // exit out after doing this processing.
        //

        ASSERT(info->DataLength == sizeof(ULONG));
        if (info->DataLength < sizeof(ULONG)) {
            status = STATUS_INVALID_PARAMETER;
            goto cleanup;
        }

        RtlCopyMemory(Data, info->Data, sizeof(ULONG));

        status = STATUS_SUCCESS;
        goto cleanup;
     
    } else if (info->Type == REG_SZ) {
        
        if (FAILED(StringCbLength((PWCHAR)info->Data, info->DataLength, &stringLength))) {

            status = STATUS_INVALID_PARAMETER;
            goto cleanup;
        }

    ASSERT(stringLength <= MAXULONG);

        //
        // Account for the necessary NULLs in the 
        // required buffer size calculation.
        //
        if (convertSzToMultiSz) {
            length = (ULONG)stringLength + 2*sizeof(UNICODE_NULL);
        } else {
            length = (ULONG)stringLength + sizeof(UNICODE_NULL);
        }
       
    } else if (info->Type == REG_MULTI_SZ) {
        
        status = STATUS_INVALID_PARAMETER;
        
        //
        // Iterate over the buffer looking for strings.
        // Initialize the "effective" size of the buffer to 1 character
        // smaller than the buffer actually is, because we always need
        // to look one character past the end of the string for the
        // second NULL terminator
        //
        remainingBufferPtr = (PWCHAR)info->Data;
        remainingBufferLength = (info->DataLength / sizeof(WCHAR)) - 1;
        length = 0;

        while (remainingBufferLength) {
            
            //
            // First see if we can find a NULL-terminated string
            // in the remaining buffer.  If not, this is not a MULTI_SZ.
            //
            if (FAILED(StringCchLength(remainingBufferPtr,
                                       remainingBufferLength,
                                       &stringLength
                                       ))) {
                
                goto cleanup;
            }

            length += ((ULONG)stringLength+1)*sizeof(WCHAR);

            //
            // Look for a second NULL terminator after the end of
            // the string.  If it exists, this is a MULTI_SZ.
            //
            if (remainingBufferPtr[(ULONG)stringLength+1] == UNICODE_NULL) {

                length += sizeof(UNICODE_NULL);

                status = STATUS_SUCCESS;
                break;
            }

            //
            // If not, advance past the single-null-terminated string
            // we did find and try again.
            //
            remainingBufferLength -= ((ULONG)stringLength+1);
            remainingBufferPtr += ((ULONG)stringLength+1);
        }

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

    } else {        

        length = info->DataLength;
    }
    
    //
    // Now allocate a buffer if necessary, and copy the data over.
    //
    if (*Data) {

        //
        // If the user supplied a buffer then make sure its big enough and use it
        // otherwise allocate one.
        //

        if (*DataLength < length) {
            status = STATUS_BUFFER_OVERFLOW;
            goto cleanup;
        }
    } else {
        *Data = ExAllocatePoolWithTag(PagedPool,
                                      length,
                                      MF_POOL_TAG
                                      );
        if (!*Data) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
    }

    if (convertSzToMultiSz) {

        //
        // Copy the string into the destination buffer
        // and add in the second NULL
        //
        if (FAILED(StringCbCopyEx((PWCHAR)*Data,       // Destination
                                  length,              // Destination length
                                  (PWCHAR)info->Data,  // Source
                                  &stringEnd,          // Ptr to end of copy
                                  &sizeRemaining,      // bytes left in the destination
                                  0
                                  ))) {
            ASSERT(FALSE);
            status = STATUS_INVALID_PARAMETER;
            goto cleanup;
        }

        //
        // In the sanity checking portion of this function,
        // we made sure the buffer was big enough for both
        // NULLs.  ASSERT that it's true here anyway.
        //
        ASSERT(sizeRemaining >= 2*sizeof(UNICODE_NULL));

        *(stringEnd+1) = UNICODE_NULL;
        
    } else {

        //
        // Nothing special to do.  Just copy.
        //
        RtlCopyMemory(*Data, info->Data, length);    
    }

    *DataLength = length;

    status = STATUS_SUCCESS;

cleanup:

    if (info) {
        ExFreePool(info);
    }

    return status;
}

NTSTATUS
MfSendPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION Location,
    OUT PULONG_PTR Information OPTIONAL
    )

/*++

Routine Description:

    This builds and send a pnp irp to a device.

Arguments:

    DeviceObject - The a device in the device stack the irp is to be sent to -
        the top of the device stack is always found and the irp sent there first.

    Location - The initial stack location to use - contains the IRP minor code
        and any parameters

    Information - If provided contains the final value of the irps information
        field.

Return Value:

    The final status of the completed irp or an error if the irp couldn't be sent

--*/

{

    NTSTATUS status;
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_OBJECT targetDevice = NULL;
    KEVENT irpCompleted;
    IO_STATUS_BLOCK statusBlock;

    ASSERT(Location->MajorFunction == IRP_MJ_PNP);

    //
    // Find out where we are sending the irp
    //

    targetDevice = IoGetAttachedDeviceReference(DeviceObject);

    //
    // Get an IRP
    //

    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       targetDevice,
                                       NULL,    // Buffer
                                       0,       // Length
                                       0,       // StartingOffset
                                       &irpCompleted,
                                       &statusBlock
                                       );


    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    //
    // Initialize the stack location
    //

    irpStack = IoGetNextIrpStackLocation(irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    irpStack->MinorFunction = Location->MinorFunction;
    irpStack->Parameters = Location->Parameters;

    //
    // Call the driver and wait for completion
    //

    status = IoCallDriver(targetDevice, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&irpCompleted, Executive, KernelMode, FALSE, NULL);
        status = statusBlock.Status;
    }

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Return the information
    //

    if (ARGUMENT_PRESENT(Information)) {
        *Information = statusBlock.Information;
    }

    ObDereferenceObject(targetDevice);

    ASSERT(status == STATUS_PENDING || status == statusBlock.Status);

    return statusBlock.Status;

cleanup:

    if (targetDevice) {
        ObDereferenceObject(targetDevice);
    }

    return status;
}

DEVICE_POWER_STATE
MfUpdateChildrenPowerReferences(
    IN PMF_PARENT_EXTENSION Parent,
    IN DEVICE_POWER_STATE PreviousPowerState,
    IN DEVICE_POWER_STATE NewPowerState
    )
/*++

Routine Description:

    Calculates the lowest power state the mf parent can be put into
    based on the power states of its children.

Arguments:

    Parent - The MF parent device

Return Value:

    The lowest power state

--*/

{
    PMF_CHILD_EXTENSION currentChild;
    PLIST_ENTRY currentEntry;
    DEVICE_POWER_STATE lowest;
    KIRQL oldIrql;

    DEBUG_MSG(1,
              ("Scanning 0x%08x's childrens power states:\n",
               Parent->Self
               ));

 
    KeAcquireSpinLock(&Parent->PowerLock, &oldIrql);

    //
    // ChildrenPowerStates[PowerDeviceUnspecified] will go negative as
    // children leave this state.  It will never go positive as
    // children never re-enter this state.
    //

    Parent->ChildrenPowerReferences[PreviousPowerState]--;
    Parent->ChildrenPowerReferences[NewPowerState]++;

    //
    // Find the lowest power state
    //

    for (lowest = PowerDeviceUnspecified; lowest < PowerDeviceMaximum;
         lowest++) {
        if (Parent->ChildrenPowerReferences[lowest] > 0) {
            break;
        }
    }

    KeReleaseSpinLock(&Parent->PowerLock, oldIrql);

    if (lowest == PowerDeviceMaximum) {
        lowest = PowerDeviceD3;
    }

    DEBUG_MSG(1, ("Lowest = %s\n", DEVICE_POWER_STRING(lowest)));
    return lowest;
}

NTSTATUS
MfPowerRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This is the power completion routine for all mf power operations.  It copies
    the status of the power operation into the context and then sets the completed
    event.

Arguments:

    As documented for power completion routines.

Return Value:

    STATUS_SUCCESS

--*/

{
    PMF_POWER_COMPLETION_CONTEXT completion = Context;

    completion->Status = IoStatus->Status;

    KeSetEvent(&completion->Event, 0, FALSE);

    return STATUS_SUCCESS;
}


NTSTATUS
MfSendSetPowerIrp(
    IN PDEVICE_OBJECT Target,
    IN POWER_STATE State
    )

/*++

Routine Description:

    This builds and send a IRP_MN_SET_POWER_IRP to a device.

Arguments:

    Target - The a device in the device stack the irp is to be sent to -
        the top of the device stack is always found and the irp sent there first.

    State - The device power state that should be requested.

Return Value:

    The final status of the completed irp or an error if the irp couldn't be sent

--*/


{
    NTSTATUS status;
    MF_POWER_COMPLETION_CONTEXT completion;

    KeInitializeEvent(&completion.Event, SynchronizationEvent, FALSE);

    DEBUG_MSG(1,
          ("Sending SET_POWER to 0x%08x for %s\n",
           Target,
           DEVICE_POWER_STRING(State.DeviceState)
          ));

    status = PoRequestPowerIrp(Target,
                               IRP_MN_SET_POWER,
                               State,
                               MfPowerRequestCompletion,
                               &completion,
                               NULL
                               );

    if (NT_SUCCESS(status)) {

        ASSERT(status == STATUS_PENDING);

        KeWaitForSingleObject( &completion.Event, Executive, KernelMode, FALSE, NULL );

        status = completion.Status;
    }

    return status;
}

NTSTATUS
MfUpdateParentPowerState(
    IN PMF_PARENT_EXTENSION Parent,
    IN DEVICE_POWER_STATE TargetPowerState
    )
/*++

Routine Description:

    Request Po to send the mf parent device a power irp if we need to
    change its power state because of changes to its children power
    states.

Arguments:

    Parent - The MF parent device

    TargetPowerState - The device power state that the parent should
    be updated to.

Return Value:

    The status of this operation.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    POWER_STATE newState;

    //
    // If the parent's power state need changing because of a power down or
    // power up request that it do so
    //

    if (Parent->Common.PowerState != TargetPowerState) {

        //
        // Create and send the power irp and wait for its completion
        //

        DEBUG_MSG(1,
                  ("Updating parent power state from %s to %s\n",
                   DEVICE_POWER_STRING(Parent->Common.PowerState),
                   DEVICE_POWER_STRING(TargetPowerState)
                   ));

        newState.DeviceState = TargetPowerState;

        status = MfSendSetPowerIrp(Parent->Self,
                                   newState);
        
        DEBUG_MSG(1,
                  ("Power update completed with %s (0x%08x)\n",
                   STATUS_STRING(status), status
                   ));

    } else {
        DEBUG_MSG(1,
                  ("Parent power already in %s\n",
                   DEVICE_POWER_STRING(TargetPowerState)
                   ));
    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\inc\exca.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    exca.h

Abstract:

    This module defines the 82365SL chip, and subsequent chips based on it.

Author(s):

    Jeff McLeman (mcleman@zso.dec.com)

Revisions:
    Added misc stuff
         Ravisankar Pudipeddi (ravisp) 1 Dec 1996

--*/

#ifndef _PCMCIA_EXCA_H_
#define _PCMCIA_EXCA_H_
//
// For initial debug
//

#define PCMCIA_PROTO 1

//
// Memory window sizes that will be allocated
// for this controller - to map card memory
//
#define PCIC_WINDOW_SIZE                 0x1000  //(4K)
#define PCIC_WINDOW_ALIGNMENT            0x1000  //(4K)

//
// Define on chip registers
//

#define PCIC_IDENT             0x00
#define PCIC_STATUS            0x01
#define PCIC_PWR_RST           0x02
#define PCIC_INTERRUPT         0x03
#define PCIC_CARD_CHANGE       0x04
#define PCIC_CARD_INT_CONFIG   0x05
#define PCIC_ADD_WIN_ENA       0x06

#define PCIC_IO_CONTROL        0x07
#define PCIC_IO_ADD0_STRT_L    0x08
#define PCIC_IO_ADD0_STRT_H    0x09
#define PCIC_IO_ADD0_STOP_L    0x0a
#define PCIC_IO_ADD0_STOP_H    0x0b
#define PCIC_IO_ADD1_STRT_L    0x0c
#define PCIC_IO_ADD1_STRT_H    0x0d
#define PCIC_IO_ADD1_STOP_L    0x0e
#define PCIC_IO_ADD1_STOP_H    0x0f

#define PCIC_MEM_ADD0_STRT_L   0x10
#define PCIC_MEM_ADD0_STRT_H   0x11
#define PCIC_MEM_ADD0_STOP_L   0x12
#define PCIC_MEM_ADD0_STOP_H   0x13
#define PCIC_CRDMEM_OFF_ADD0_L 0x14
#define PCIC_CRDMEM_OFF_ADD0_H 0x15

#define PCIC_MEM_ADD1_STRT_L   0x18
#define PCIC_MEM_ADD1_STRT_H   0x19
#define PCIC_MEM_ADD1_STOP_L   0x1a
#define PCIC_MEM_ADD1_STOP_H   0x1b
#define PCIC_CRDMEM_OFF_ADD1_L 0x1c
#define PCIC_CRDMEM_OFF_ADD1_H 0x1d


#define PCIC_MEM_ADD2_STRT_L   0x20
#define PCIC_MEM_ADD2_STRT_H   0x21
#define PCIC_MEM_ADD2_STOP_L   0x22
#define PCIC_MEM_ADD2_STOP_H   0x23
#define PCIC_CRDMEM_OFF_ADD2_L 0x24
#define PCIC_CRDMEM_OFF_ADD2_H 0x25

#define PCIC_MEM_ADD3_STRT_L   0x28
#define PCIC_MEM_ADD3_STRT_H   0x29
#define PCIC_MEM_ADD3_STOP_L   0x2a
#define PCIC_MEM_ADD3_STOP_H   0x2b
#define PCIC_CRDMEM_OFF_ADD3_L 0x2c
#define PCIC_CRDMEM_OFF_ADD3_H 0x2d

#define PCIC_MEM_ADD4_STRT_L   0x30
#define PCIC_MEM_ADD4_STRT_H   0x31
#define PCIC_MEM_ADD4_STOP_L   0x32
#define PCIC_MEM_ADD4_STOP_H   0x33
#define PCIC_CRDMEM_OFF_ADD4_L 0x34
#define PCIC_CRDMEM_OFF_ADD4_H 0x35


#define PCIC_IO_WIN0_OFFSET_L  0x36
#define PCIC_IO_WIN0_OFFSET_H  0x37
#define PCIC_IO_WIN1_OFFSET_L  0x38
#define PCIC_IO_WIN1_OFFSET_H  0x39

//
// TI registers
//

#define PCIC_TI_CARD_DETECT        0x16
#define PCIC_TI_GLOBAL_CONTROL     0x1e

//
// Topic registers
//
#define PCIC_TO_ADDITIONAL_GENCTRL 0x16
#define PCIC_TO_MMI_CTRL           0x3c
#define PCIC_TO_FUNC_CTRL          0x3e

//
// RICOH registers
//

#define PCIC_RICOH_MISC_CTRL1      0x2f
//
// Other Cirrus Logic registers
//
#define PCIC_CL_MISC_CTRL1      0x16
#define PCIC_CL_MISC_CTRL2      0x1e
#define PCIC_CL_CHIP_INFO      0x1f
#define PCIC_CL_MISC_CTRL3       0x125
#define PCIC_CL_MASK_REV       0x134
#define PCIC_CL_PRODUCT_ID     0x135
#define PCIC_CL_DEV_CAP_A      0x136
#define PCIC_CL_DEV_CAP_B      0x137
#define PCIC_CL_DEV_IMP_A      0x138
#define PCIC_CL_DEV_IMP_B      0x139
#define PCIC_CL_DEV_IMP_C      0x13a
#define PCIC_CL_DEV_IMP_D      0x13b

//Cirrus Logic Miscellaneous Control 1 Register bits
#define CL_MC1_5V_DETECT            0x01
#define CL_MC1_MM_ENABLE            0x01
#define CL_MC1_VCC_33V              0x02
#define CL_MC1_PULSE_MGMT_INT       0x04
#define CL_MC1_PULSE_SYSTEM_IRQ     0x08
#define CL_MC1_SPKR_ENABLE          0x10
#define CL_MC1_INPACK_ENABLE        0x80

//Cirrus Logic Miscellaneous Control 2 Register bits
#define CL_MC2_BFS                  0x01
#define CL_MC2_LPDYNAMIC_MODE       0x02
#define CL_MC2_SUSPEND              0x04
#define CL_MC2_5VCORE               0x08
#define CL_MC2_DRIVELED_ENABLE      0x10
#define CL_MC2_TIMERCLK_DIVIDE      0x10
#define CL_MC2_3STATE_BIT7          0x20
#define CL_MC2_DMA_SYSTEM           0x40
#define CL_MC2_IRQ15_RIOUT          0x80

//Cirrus Logic Miscellaneous Control 3 Register bits
#define CL_MC3_INTMODE_MASK             0x03
#define CL_MC3_INTMODE_SERIAL           0x00
#define CL_MC3_INTMODE_EXTHW            0x01
#define CL_MC3_INTMODE_PCIWAY           0x02
#define CL_MC3_INTMODE_PCI              0x03    //default
#define CL_MC3_PWRMODE_MASK             0x0c
#define CL_MC3_HWSUSPEND_ENABLE         0x10

//
// Cirrus Logic extension register 1
//
#define PCIC_CIRRUS_EXTENDED_INDEX   0x2E
#define PCIC_CIRRUS_INDEX_REG        0x2F
#define PCIC_CIRRUS_EXTENSION_CTRL_1 0x03



//                
// Databook registers
//
#define PCIC_DBK_ZV_ENABLE    0x3b

//
// Opti registers
//
#define PCIC_OPTI_GLOBAL_CTRL 0x1e


//
// This is only for cardbus controllers
//
#define PCIC_PAGE_REG         0x40

//
//
// Define offset to socket A and B
//

#define PCIC_SOCKETA_OFFSET    0x00
#define PCIC_SOCKETB_OFFSET    0x40


#define PCIC_REVISION         0x82
#define PCIC_REVISION2        0x83
#define PCIC_REVISION3        0x84
#define PCIC_SCM_REVISION     0xAB

#define SOCKET1               PCIC_SOCKETA_OFFSET
#define SOCKET2               PCIC_SOCKETB_OFFSET

#define CARD_DETECT_1         0x4
#define CARD_DETECT_2         0x8

#define CARD_IN_SOCKET_A      0x1
#define CARD_IN_SOCKET_B      0x2

#define CARD_TYPE_MODEM       0x1
#define CARD_TYPE_ENET        0x2
#define CARD_TYPE_DISK        0x3

//
// For Cirrus Logic PCI controllers
//
#define PCIC_CIRRUS_INTA      0x3
#define PCIC_CIRRUS_INTB      0x4
#define PCIC_CIRRUS_INTC      0x5
#define PCIC_CIRRUS_INTD      0x7

//
// Support IRQs:
// 15,14, , ,  11,10, 9, ,  7, ,5,4,  3, , ,
// 1  1  0  0   1  1  1 0   1 0 1 1   1 0 0 0
//
#define PCIC_SUPPORTED_INTERRUPTS 0xCEB8

//
// Support IRQs:
// 15,14, , ,  11,10, 9, ,  7, ,5,4,  3, , ,
// 0  1  0  0   0  1  0 0   1 0 1 1   1 0 0 0
//
#define CL_SUPPORTED_INTERRUPTS 0x44B8

//
// Support IRQs for NEC_98:
//   ,  ,  ,12,   ,10,  ,  ,    ,6 ,5 ,  ,  3 ,  ,  ,
// 0  0  0  1   0  1  0  0    0  1  1  0    1  0  0  0
//
#define PCIC_SUPPORTED_INTERRUPTS_NEC_98 0x1468



/*** 16-Bit Socket Constants
 */

//Device IDs for various controllers
#define DEVID_VALID_LO        0x82
#define DEVID_CL        0x82
#define DEVID_VADEM        0x83
#define DEVID_RICOH        0x83
#define DEVID_GEN_PCIC        0x84
#define DEVID_IBM_KING        0x8a
#define DEVID_OPTI_82C824     0x87
#define DEVID_OPTI_82C852     0x8f

//TI PCI-1130 specific registers
#define PCIC_TI_MEMWIN_PAGE      0x40

//ID and Revision Register bits
#define IDREV_REV_MASK                  0x0f
#define IDREV_IFID_MASK                 0xc0
#define IDREV_IFID_IO                   0x00
#define IDREV_IFID_MEM                  0x40
#define IDREV_IFID_IOMEM                0x80

//Interface Status Register bits
#define IFS_BVD_MASK                    0x03
#define IFS_BVD1                        0x01
#define IFS_BVD2                        0x02
#define IFS_CD_MASK                     0x0c
#define IFS_CD1                         0x04
#define IFS_CD2                         0x08
#define IFS_WP                          0x10
#define IFS_RDYBSY                      0x20
#define IFS_CARDPWR_ACTIVE              0x40
#define IFS_VPP_VALID                   0x80

//Power and RESETDRV Control Register bits

#define PC_VPP1_MASK                    0x03
#define PC_VPP2_MASK                    0x0c
#define PC_CARDPWR_ENABLE               0x10
#define PC_AUTOPWR_ENABLE               0x20
#define PC_RESETDRV_DISABLE             0x40
#define PC_OUTPUT_ENABLE                0x80

#define PC_PWRON_BITS                   (PC_OUTPUT_ENABLE | PC_AUTOPWR_ENABLE)

#define PC_VPP_NO_CONNECT     0x00
#define PC_VPP_SETTO_VCC      0x01
#define PC_VPP_SETTO_VPP      0x02
#define PC_VPP_RESERVED       0x03

#define PC_VPP_VLSI_MASK      0x03
#define PC_VPP_VLSI_NO_CONNECT      0x00
#define PC_VPP_VLSI_050V      0x01
#define PC_VPP_VLSI_120V      0x02
#define PC_VPP_VLSI_RESERVED     0x03

#define PC_VCC_TOPIC_033V     0x08

#define PC_VCC_VLSI_MASK      0x18
#define PC_VCC_VLSI_NO_CONNECT      0x00
#define PC_VCC_VLSI_RESERVED     0x08
#define PC_VCC_VLSI_050V      0x10
#define PC_VCC_VLSI_033V      0x18

#define PC_VPP_KING_MASK      0x03
#define PC_VPP_KING_NO_CONNECT      0x00
#define PC_VPP_KING_050V      0x01
#define PC_VPP_KING_120V      0x02
#define PC_VPP_KING_SETTO_VCC    0x03

#define PC_VCC_KING_MASK      0x0c
#define PC_VCC_KING_NO_CONNECT      0x00
#define PC_VCC_KING_050V      0x04
#define PC_VCC_KING_RESERVED     0x08
#define PC_VCC_KING_033V      0x0c

#define PC_VPP_OPTI_MASK      0x03
#define PC_VPP_OPTI_NO_CONNECT      0x00
#define PC_VPP_OPTI_SETTO_VCC    0x01
#define PC_VPP_OPTI_120V      0x02
#define PC_VPP_OPTI_0V        0x03

#define PC_VCC_OPTI_MASK      0x18
#define PC_VCC_OPTI_NO_CONNECT      0x00
#define PC_VCC_OPTI_033V      0x08
#define PC_VCC_OPTI_050V      0x10
#define PC_VCC_OPTI_0XXV      0x18

//Interrupt and General Control Register bits
#define IGC_IRQ_MASK                    0x0f
#define IGC_INTR_ENABLE                 0x10
#define IGC_PCCARD_IO                   0x20
#define IGC_PCCARD_RESETLO              0x40
#define IGC_RINGIND_ENABLE              0x80

//Card Status Change Register bits
#define CSC_CHANGE_MASK                 0x0f
#define CSC_BATT_DEAD                   0x01
#define CSC_BATT_WARNING                0x02
#define CSC_BATT_MASK         (CSC_BATT_DEAD | CSC_BATT_WARNING)
#define CSC_READY_CHANGE                0x04
#define CSC_CD_CHANGE                   0x08

//Card Status Change Interrupt Configuration Register bits
#define CSCFG_ENABLE_MASK               0x0f
#define CSCFG_BATT_DEAD                 0x01
#define CSCFG_BATT_WARNING              0x02
#define CSCFG_BATT_MASK       (CSCFG_BATT_DEAD | CSCFG_BATT_WARNING)
#define CSCFG_READY_ENABLE              0x04
#define CSCFG_CD_ENABLE                 0x08
#define CSCFG_IRQ_MASK                  0xf0

//Address Window Enable Register bits
#define WE_MEM0_ENABLE                  0x01
#define WE_MEM1_ENABLE                  0x02
#define WE_MEM2_ENABLE                  0x04
#define WE_MEM3_ENABLE                  0x08
#define WE_MEM4_ENABLE                  0x10
#define WE_MEMWIN_MASK        (WE_MEM0_ENABLE | WE_MEM1_ENABLE | \
                WE_MEM2_ENABLE | WE_MEM3_ENABLE | \
                WE_MEM4_ENABLE)
#define WE_MEMCS16_DECODE               0x20
#define WE_IO0_ENABLE                   0x40
#define WE_IO1_ENABLE                   0x80
#define WE_IOWIN_MASK         (WE_IO0_ENABLE | WE_IO1_ENABLE)

//I/O Control Register bits
#define IOC_IO0_MASK                    0x0f
#define IOC_IO0_DATASIZE                0x01
#define IOC_IO0_IOCS16                  0x02
#define IOC_IO0_ZEROWS                  0x04
#define IOC_IO0_WAITSTATE               0x08
#define IOC_IO1_MASK                    0xf0
#define IOC_IO1_DATASIZE                0x10
#define IOC_IO1_IOCS16                  0x20
#define IOC_IO1_ZEROWS                  0x40
#define IOC_IO1_WAITSTATE               0x80

//Card Detection and General Control Register
#define CDGC_SW_DET_INT       0x20

//Memory Window Start Register bits
#define MEMBASE_ADDR_MASK               0x0fff
#define MEMBASE_ZEROWS                  0x4000
#define MEMBASE_16BIT                   0x8000

//Memory Window Stop Register bits
#define MEMEND_ADDR_MASK                0x0fff
#define MEMEND_WS_MASK                  0xc000

//Memory Window Offset Register bits
#define MEMOFF_ADDR_MASK                0x3fff
#define MEMOFF_REG_ACTIVE               0x4000
#define MEMOFF_WP                       0x8000

//
//Masks used to calculate 2's-complement based offset
#define OFFSETCALC_BASE_MASK            0x00FFFFFF
#define OFFSETCALC_OFFSET_MASK          0x03FFFFFF

//Cirrus Logic Miscellaneous Control 1 Register bits
#define CL_MC1_5V_DETECT      0x01
#define CL_MC1_MM_ENABLE      0x01
#define CL_MC1_VCC_33V        0x02
#define CL_MC1_PULSE_MGMT_INT    0x04
#define CL_MC1_PULSE_SYSTEM_IRQ     0x08
#define CL_MC1_SPKR_ENABLE    0x10
#define CL_MC1_INPACK_ENABLE     0x80

//Cirrus Logic Miscellaneous Control 2 Register bits
#define CL_MC2_BFS         0x01
#define CL_MC2_LPDYNAMIC_MODE    0x02
#define CL_MC2_SUSPEND        0x04
#define CL_MC2_5VCORE         0x08
#define CL_MC2_DRIVELED_ENABLE      0x10
#define CL_MC2_TIMERCLK_DIVIDE      0x10
#define CL_MC2_3STATE_BIT7    0x20
#define CL_MC2_DMA_SYSTEM     0x40
#define CL_MC2_IRQ15_RIOUT    0x80

//Cirrus Logic Miscellaneous Control 3 Register bits
#define CL_MC3_INTMODE_MASK             0x03
#define CL_MC3_INTMODE_SERIAL           0x00
#define CL_MC3_INTMODE_EXTHW            0x01
#define CL_MC3_INTMODE_PCIWAY           0x02
#define CL_MC3_INTMODE_PCI              0x03    //default
#define CL_MC3_PWRMODE_MASK             0x0c
#define CL_MC3_HWSUSPEND_ENABLE         0x10
#define CL_MC3_MM_ARM         0x80

//Cirrus Logic Chip Info Register bits
#define CL_CI_REV_MASK        0x1e
#define CL_CI_DUAL_SOCKET     0x20
#define CL_CI_CHIP_ID         0xc0

//Cirrus Logic Mask Revision Register bits
#define CL_MSKREV_MASK        0x0f

//Cirrus Logic Product ID Register bits
#define CL_PID_PRODUCT_CODE_MASK 0x0f
#define CL_PID_FAMILY_CODE_MASK     0xf0

//Cirrus Logic Device Capability Register A bits
#define CL_CAPA_NUMSKT_MASK      0x03
#define CL_CAPA_IDE_INTERFACE    0x04
#define CL_CAPA_SLAVE_DMA     0x08
#define CL_CAPA_CPSTB_CAPABLE    0x20
#define CL_CAPA_PER_SKT_LED      0x80

//Cirrus Logic Device Capability Register B bits
#define CL_CAPB_CARDBUS_CAPABLE     0x01
#define CL_CAPB_LOCK_SUPPORT     0x02
#define CL_CAPB_CLKRUN_SUPPORT      0x04
#define CL_CAPB_EXT_DEF       0x80

//Cirrus Logic Device Implementation Register A bits
#define CL_IMPA_NUMSKT_MASK      0x03
#define CL_IMPA_SLAVE_DMA     0x04
#define CL_IMPA_VS1_VS2       0x08
#define CL_IMPA_GPSTB_A       0x10
#define CL_IMPA_GPSTB_B       0x20
#define CL_IMPA_HW_SUSPEND    0x40
#define CL_IMPA_RI_OUT        0x80

//Cirrus Logic Device Implementation Register B bits
#define CL_IMPB_033_VCC       0x01
#define CL_IMPB_050_VCC       0x02
#define CL_IMPB_0YY_VCC       0x04
#define CL_IMPB_0XX_VCC       0x08
#define CL_IMPB_120_VPP       0x10
#define CL_IMPB_VPP_VCC_1A    0x20
#define CL_IMPB_RFRATED_SKT      0x40

//Cirrus Logic Device Implementation Register C bits
#define CL_IMPC_LED        0x01
#define CL_IMPC_PER_SKT_LED      0x02
#define CL_IMPC_SPK        0x04
#define CL_IMPC_ZVP_A         0x08
#define CL_IMPC_ZVP_B         0x10

//Cirrus Logic Device Implementation Register D bits
#define CL_IMPD_CLKRUN        0x01
#define CL_IMPD_LOCK       0x02
#define CL_IMPD_EXT_CLK       0x40

//Cirrus Logic Extension Registers
#define CLEXTREG_EXTCTRL_1    0x03
#define CLEXTREG_MEMWIN0_HIADDR     0x05
#define CLEXTREG_MEMWIN1_HIADDR     0x06
#define CLEXTREG_MEMWIN2_HIADDR     0x07
#define CLEXTREG_MEMWIN3_HIADDR     0x08
#define CLEXTREG_MEMWIN4_HIADDR     0x09
#define CLEXTREG_EXT_DATA     0x0a
#define CLEXTREG_EXTCTRL_2    0x0b

//TI Global Control Register bits
#define TI_GCTRL_PWRDOWN_MODE_ENABLE    0x01
#define TI_GCTRL_CSC_LEVEL_MODE         0x02
#define TI_GCTRL_INTFLAG_CLEAR_MODE     0x04
#define TI_GCTRL_CARDA_LEVEL_MODE       0x08
#define TI_GCTRL_CARDB_LEVEL_MODE       0x10

//Cirrus Logic External Data Register bits (Index=0x6f,ExtIndex=0x0a)
#define CL_EDATA_A_VS1        0x01
#define CL_EDATA_A_VS2        0x02
#define CL_EDATA_A_5V         (CL_EDATA_A_VS1 | CL_EDATA_A_VS2)
#define CL_EDATA_B_VS1        0x04
#define CL_EDATA_B_VS2        0x08
#define CL_EDATA_B_5V         (CL_EDATA_B_VS1 | CL_EDATA_B_VS2)

//Toshiba TOPIC95 Function Control Register bits
#define TO_FCTRL_CARDPWR_ENABLE     0x01
#define TO_FCTRL_VSSTATUS_ENABLE 0x02
#define TO_FCTRL_PPEC_TIMING_ENABLE 0x04
#define TO_FCTRL_CARD_TIMING_ENABLE 0x08
#define TO_FCTRL_CARD_MEMPAGE_ENABLE   0x10
#define TO_FCTRL_DMA_ENABLE      0x20
#define TO_FCTRL_PWRCTRL_BUFFER_ENABLE 0x40

//Toshiba TOPIC95 Multimedia Interface Control Register bits
#define TO_MMI_VIDEO_CTRL     0x01
#define TO_MMI_AUDIO_CTRL     0x02
#define TO_MMI_REV_BIT        0x80

//Toshiba TOPIC95 Addition General Control Register bits
#define TO_GCTRL_CARDREMOVAL_RESET  0x02
#define TO_GCTRL_SWCD_INT     0x20

//Databook DB87144 Zoom Video Port Enable Register
#define DBK_ZVE_MODE_MASK     0x03
#define DBK_ZVE_STANDARD_MODE    0x00
#define DBK_ZVE_MM_MODE       0x03

//OPTi Global Control Register bits
#define OPTI_ZV_ENABLE                  0x20

//VLSI ELC Constants
#define VLSI_ELC_ALIAS        0x8000
#define VLSI_EA2_EA_ENABLE    0x10
#define VLSI_CC_VS1        0x04

//VADEM Constants
#define VADEM_UNLOCK_SEQ1     0x0e
#define VADEM_UNLOCK_SEQ2     0x37
#define VADEM_MISC_UNLOCK_VADEMREV  0xc0
#define VADEM_IDREV_VG469_REV    0x0c
#define VADEM_VSEL_VCC_MASK      0x03
#define VADEM_VSEL_VCC_050V      0x00
#define VADEM_VSEL_VCC_033V      0x01
#define VADEM_VSEL_VCC_XXXV      0x02
#define VADEM_VSEL_VCC_033VB     0x03
#define VADEM_VSEL_SKT_MIXEDVOLT 0x40
#define VADEM_VSENSE_A_VS1    0x01
#define VADEM_VSENSE_A_VS2    0x02
#define VADEM_VSENSE_B_VS1    0x04
#define VADEM_VSENSE_B_VS2    0x08
#define VADEM_VSENSE_050V_ONLY      0x03

//IBM King Constants
#define KING_CVS_VS1       0x01
#define KING_CVS_VS2       0x02
#define KING_CVS_VS_MASK      (KING_CVS_VS1 | KING_CVS_VS2)
#define KING_CVS_5V        (KING_CVS_VS1 | KING_CVS_VS2)
#define KING_CVS_GPI       0x80

//Ricoh RL5C466 Miscellaneous Control 1 Register bits
#define RICOH_MC1_VS                    0x01
#define RICOH_MC1_IREQ_SENSE_SEL        0x02
#define RICOH_MC1_INPACK_ENABLE         0x04
#define RICOH_MC1_ZV_ENABLE             0x08
#define RICOH_MC1_DMA_ENABLE_MASK       0x30
#define RICOH_MC1_DMA_DISABLE           0x00
#define RICOH_MC1_DMA_INPACK            0x10
#define RICOH_MC1_DMA_IOIS16            0x20
#define RICOH_MC1_DMA_SPKR              0x30

//Misc. Constants
#define EXCAREGBASE_SPACE     0x40
#define NUMWIN_PCCARD16                 7       //5 mem + 2 io per socket
#define NUMWIN_PC16_MEM                 5
#define NUMWIN_PC16_IO                  2
#define PCCARD_IOWIN_START              5

//These are default values for the slowest and fastest memory speeds supported.
//It may be necessary to change the actual values with arguments, if the bus
//speed is not the default 8MHz/8.33MHz, which gives 120ns-125ns per cycle.
//Note that the SLOW_MEM_SPEED should be the same as the default
//WaitToSpeed[3], and FAST_MEM_SPEED might as well be 1ns, since the socket
//will support arbitrarily fast memory.
#define SLOW_MEM_SPEED                  0x72    //700ns
#define FAST_MEM_SPEED                  0x08    //1ns

//
// Values for various delays for R2 cards
//
#define PCMCIA_PCIC_STALL_POWER         400000  //400ms

#define  PCMCIA_READY_DELAY_ITER       850
#define  PCMCIA_READY_STALL            10000     // 10 millesec

#define PCMCIA_PCIC_MEMORY_WINDOW_DELAY  3000    // 3 msec
#define PCMCIA_PCIC_RESET_WIDTH_DELAY    100     // 100 usec
#define PCMCIA_PCIC_RESET_SETUP_DELAY    70000   // 70 msec

#define PCMCIA_DEFAULT_ATTRIBUTE_MEMORY_LOW      0xC0000
#define PCMCIA_DEFAULT_ATTRIBUTE_MEMORY_HIGH     0xFFFFFFFF

//I/O Control Register default nibble values
//The Xircom net PC cards fails with a 16-bit wait on the AcerNote which
//has a Cirrus Logic controller.  Why the addition of a wait state causes
//this to fail is a mystery.  The Socket EA PC card fails on the IBM ThinkPad
//755 if the 16-bit wait state is not set.
#define DEF_IOC_8BIT                     0x00
#define DEF_IOC_16BIT                   (IOC_IO0_DATASIZE | IOC_IO0_IOCS16 | \
                                         IOC_IO0_WAITSTATE)
#endif  // _PCMCIA_EXCA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\inc\pcicfg.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    pcicfg.h

Abstract:

    Contains defines for vendor specific PCI configuration
    information

Author(s):

    Ravisankar Pudipeddi   (1 Nov 1997)
    Largely derived from pcskhw.h for win 9x

Revision History:

--*/

#ifndef _PCMCIA_PCICFG_H_
#define _PCMCIA_PCICFG_H_

//
// Macros for read/writing to PCI config headers
//

//
// VOID
// GetPciConfigSpace (IN PVOID  Extension,
//                    IN UCHAR  Offset,
//                    IN PUCHAR Buffer,
//                    IN ULONG  Size)
//
#define GetPciConfigSpace(Extension, Offset, Buffer, Size)    \
           (Extension)->PciBusInterface.GetBusData(           \
               (Extension)->PciBusInterface.Context,          \
               PCI_WHICHSPACE_CONFIG, Buffer, Offset, Size);


//
// VOID
// SetPciConfigSpace (IN PVOID  Extension,
//                    IN UCHAR  Offset,
//                    IN PUCHAR Buffer,
//                    IN ULONG  Size)
//
#define SetPciConfigSpace(Extension, Offset, Buffer, Size)    \
           (Extension)->PciBusInterface.SetBusData(           \
               (Extension)->PciBusInterface.Context,          \
               PCI_WHICHSPACE_CONFIG, Buffer, Offset, Size);




//ConfigSpace Registers

#define CFGSPACE_VENDOR_ID              0x00
#define CFGSPACE_DEVICE_ID              0x02
#define CFGSPACE_COMMAND                0x04
#define CFGSPACE_STATUS                 0x06
#define CFGSPACE_REV_ID                 0x08
#define CFGSPACE_CLASS_CODE             0x09
#define CFGSPACE_CLASSCODE_PI           0x09
#define CFGSPACE_CLASSCODE_SUBCLASS     0x0a
#define CFGSPACE_CLASSCODE_BASECLASS    0x0b
#define CFGSPACE_CACHE_LINESIZE         0x0c
#define CFGSPACE_LATENCY_TIMER          0x0d
#define CFGSPACE_HEADER_TYPE            0x0e
#define CFGSPACE_BIST                   0x0f
#define CFGSPACE_REGBASE_ADDR           0x10
#define CFGSPACE_CAPPTR                 0x14
#define CFGSPACE_SECOND_STATUS          0x16
#define CFGSPACE_PCI_BUSNUM             0x18
#define CFGSPACE_CARDBUS_BUSNUM         0x19
#define CFGSPACE_SUB_BUSNUM             0x1a
#define CFGSPACE_CB_LATENCY_TIMER       0x1b
#define CFGSPACE_MEMBASE_0              0x1c
#define CFGSPACE_MEMLIMIT_0             0x20
#define CFGSPACE_MEMBASE_1              0x24
#define CFGSPACE_MEMLIMIT_1             0x28
#define CFGSPACE_IOBASE_0               0x2c
#define CFGSPACE_IOLIMIT_0              0x30
#define CFGSPACE_IOBASE_1               0x34
#define CFGSPACE_IOLIMIT_1              0x38
#define CFGSPACE_INT_LINE               0x3c
#define CFGSPACE_INT_PIN                0x3d
#define CFGSPACE_BRIDGE_CTRL            0x3e
#define CFGSPACE_SUBSYS_VENDOR_ID       0x40
#define CFGSPACE_SUBSYS_ID              0x42
#define CFGSPACE_LEGACY_MODE_BASE_ADDR 0x44

//ConfigSpace registers for cardbus cards

#define CBCFG_BAR0                      0x10
#define CBCFG_BAR1                      0x14
#define CBCFG_BAR2                      0x18
#define CBCFG_BAR3                      0x1c
#define CBCFG_BAR4                      0x20
#define CBCFG_BAR5                      0x24
#define CBCFG_CISPTR                    0x28
#define CBCFG_SUBSYS_VENDOR_ID          0x2c
#define CBCFG_SUBSYS_ID                 0x2e
#define CBCFG_ROMBAR                    0x30
#define CBCFG_CAPPTR                    0x34


//Command Register bits
#define CMD_IOSPACE_ENABLE              0x0001
#define CMD_MEMSPACE_ENABLE             0x0002
#define CMD_BUSMASTER_ENABLE            0x0004
#define CMD_SPECIALCYCLE_ENABLE         0x0008
#define CMD_MEMWR_INVALIDATE_ENABLE     0x0010
#define CMD_VGA_PALETTE_SNOOP           0x0020
#define CMD_PARITY_ERROR_ENABLE         0x0040
#define CMD_WAIT_CYCLE_CTRL             0x0080
#define CMD_SYSTEM_ERROR_ENABLE         0x0100
#define CMD_FAST_BACKTOBACK_ENABLE      0x0200

//Bridge Control Register bits
#define BCTRL_PERR_RESPONSE_ENABLE      0x0001
#define BCTRL_SERR_ENABLE               0x0002
#define BCTRL_ISA_ENABLE                0x0004
#define BCTRL_VGA_ENABLE                0x0008
#define BCTRL_MASTER_ABORT_MODE         0x0020
#define BCTRL_CRST                      0x0040
#define BCTRL_IRQROUTING_ENABLE         0x0080
#define BCTRL_MEMWIN0_PREFETCH_ENABLE   0x0100
#define BCTRL_MEMWIN1_PREFETCH_ENABLE   0x0200
#define BCTRL_WRITE_POSTING_ENABLE      0x0400
#define BCTRL_CL_CSCIRQROUTING_ENABLE   0x0800

//Power Management control bits
#define PME_EN                          0x0100
#define PME_STAT                        0x8000

//
// TI
//

//ConfigSpace Registers (TI PCI1130)
#define CFGSPACE_TI_SYSTEM_CTRL         0x80
#define CFGSPACE_TI_MM_CTRL             0x84
#define CFGSPACE_TI_RETRY_STATUS        0x90
#define CFGSPACE_TI_CARD_CTRL           0x91
#define CFGSPACE_TI_DEV_CTRL            0x92

//System Control Register bits (TI PCI1130)
#define SYSCTRL_PCICLKRUN_ENABLE        0x00000001
#define SYSCTRL_KEEPCLK_ENABLE          0x00000002
#define SYSCTRL_ASYNC_INTMODE           0x00000004
#define SYSCTRL_PCPCI_DMA_ENABLE        0x00000008
#define SYSCTRL_CBDATAPARITY_SERR       0x00000010
#define SYSCTRL_EXCAIDREV_READONLY      0x00000020
#define SYSCTRL_INTERROGATING           0x00000100
#define SYSCTRL_POWERING_UP             0x00000200
#define SYSCTRL_POWERING_DOWN           0x00000400
#define SYSCTRL_POWER_STREAMING         0x00000800
#define SYSCTRL_SOCKET_ACTIVITY         0x00002000
#define SYSCTRL_PCPCI_DMA_CHAN_MASK     0x00070000
#define SYSCTRL_PCPCI_DMA_CHAN_DISABLED 0x00040000
#define SYSCTRL_PCPCI_DMA_CARD_ENABLE   0x00080000
#define SYSCTRL_REDUCED_ZV_ENABLE       0x00100000
#define SYSCTRL_VCC_PROTECT_OVERRIDE    0x00200000
#define SYSCTRL_SMI_INT_ENABLE          0x01000000
#define SYSCTRL_SMI_INT_ROUTING_SELECT  0x02000000

//Multimedia Control Register bits (TI PCI1250/1260)
#define MMCTRL_ZVEN0                    0x01
#define MMCTRL_ZVEN1                    0x02
#define MMCTRL_PORTSEL                  0x40
#define MMCTRL_ZVOUTEN                  0x80

//Retry Status Register bits (TI PCI1130)
#define RETRY_PCIM_RETRY_EXPIRED        0x01
#define RETRY_PCI_RETRY_EXPIRED         0x02
#define RETRY_CBMA_RETRY_EXPIRED        0x04
#define RETRY_CBA_RETRY_EXPIRED         0x08
#define RETRY_CBMB_RETRY_EXPIRED        0x10
#define RETRY_CBB_RETRY_EXPIRED         0x20
#define RETRY_CBRETRY_TIMEOUT_ENABLE    0x40
#define RETRY_PCIRETRY_TIMEOUT_ENABLE   0x80

//Card Control Register bits (TI PCI1130)
#define CARDCTRL_PCCARD_INTFLAG         0x01
#define CARDCTRL_SPKR_ENABLE            0x02
#define CARDCTRL_CSCINT_ENABLE          0x08
#define CARDCTRL_FUNCINT_ENABLE         0x10
#define CARDCTRL_PCIINT_ENABLE          0x20
#define CARDCTRL_ZV_ENABLE              0x40
#define CARDCTRL_RIOUT_ENABLE           0x80

//Device Control Register bits (TI PCI1130)
#define DEVCTRL_INTMODE_MASK            0x06
#define DEVCTRL_INTMODE_DISABLED        0x00
#define DEVCTRL_INTMODE_ISA             0x02
#define DEVCTRL_INTMODE_COMPAQ          0x04
#define DEVCTRL_INTMODE_SERIAL          0x06
#define DEVCTRL_ALWAYS_ONE              0x10
#define DEVCTRL_3V_ENABLE               0x20
#define DEVCTRL_5V_ENABLE               0x40

//
// TOPIC
//

//ConfigSpace Registers (TOPIC95)
#define CFGSPACE_TO_PC16_SKTCTRL        0x90
#define CFGSPACE_TO_SLOT_CTRL           0xa0
#define CFGSPACE_TO_CARD_CTRL           0xa1
#define CFGSPACE_TO_CD_CTRL             0xa3
#define CFGSPACE_TO_CBREG_CTRL          0xa4

//PC Card-16 Socket Control Register bits (TOPIC95)
#define S16CTRL_CSC_ISAIRQ              0x00000001

//Card Control Register bits (TOPIC95)
#define CARDCTRL_INTPIN_ASSIGNMASK      0x30
#define CARDCTRL_INTPIN_NONE            0x00
#define CARDCTRL_INTPIN_INTA            0x01
#define CARDCTRL_INTPIN_INTB            0x02

//Card Detect Control Register bits (TOPIC95)
#define CDCTRL_SW_DETECT                0x01
#define CDCTRL_VS_MASK                  0x06
#define CDCTRL_PCCARD_16_32             0x80

//CardBus Socket Register Control Register (TOPIC)
#define CSRCR_TO_CAUDIO_OFF             0x00000002


//
// CL
//

//ConfigSpace Registers (CL PD6834)
#define CFGSPACE_CL_CFGMISC1     0x98

//Cirrus Logic Configuration Miscellaneous 1
#define CL_CFGMISC1_ISACSC    0x02

//
// Opti
//

//ConfigSpace Registers (OPTi 82C824)
#define CFGSPACE_OPTI_HF_CTRL           0x50
#define HFC_COMBINE_CINT_CSTSCHG        0x01
#define HFC_SPKROUT_ENABLE              0x02
#define HFC_CLKRUN_DISBALE              0x04
#define HFC_CD_DEBOUNCE_250MS           0x00
#define HFC_CD_DEBOUNCE_1000MS          0x08
#define HFC_IRQLAT_ON_CLKRUN            0x10
#define HFC_VENDOR_ID_STRAP             0x20
#define HFC_LEGACY_MODE_STRAP           0x40
#define HFC_ZV_SUPPORT                  0x80

//ConfigSpace Register (OPTi 82C824)
#define CFGSPACE_OPTI_SF_CTRL2      0x52
#define SFC2_SECOND_IDSEL_ADDR_MASK 0x0f
#define SFC2_SECOND_PCICLK_SKEW_MASK   0xf0

//
// Ricoh
//

//ConfigSpace Registers (RICOH RL5C466)
#define CFGSPACE_RICOH_MISC_CTRL        0x82
#define CFGSPACE_RICOH_IF16_CTRL        0x84
#define CFGSPACE_RICOH_IO16_TIMING0     0x88
#define CFGSPACE_RICOH_MEM16_TIMING0    0x8a
#define CFGSPACE_RICOH_DMA_SLAVE_CFG    0x90

//RICOH 16-bit Interface Control Register bits
#define IF16_INDEX_RANGE_SELECT         0x0008
#define IF16_LEGACY_LEVEL_1             0x0010
#define IF16_LEGACY_LEVEL_2             0x0020
#define IF16_IO16_ENHANCE_TIMING        0x0100
#define IF16_MEM16_ENHANCE_TIMING       0x0200

//
// O2Micro
//

//ConfigSpace Registers (O2Micro)
#define CFGSPACE_O2MICRO_ZVCFG      0x80
#define ZVCFG_SKTA_SUPPORT    0x01
#define ZVCFG_SKTB_SUPPORT    0x02

#endif  // _PCMCIA_PCICFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\inc\data.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    data.h

Abstract:

    This module provides the definitions for controller types

Author(s):

    Neil Sandlin (neilsa)

Revisions:

--*/

#ifndef _PCMCIA_DATA_H_
#define _PCMCIA_DATA_H_

#define PCMCTL_ID( Type, Part, Revision) (      \
    ((Revision) << 26) | ((Part) << 8) | (Type) \
)

#define PcmciaCLPD6729     PCMCTL_ID(PcmciaIntelCompatible, 6729, 0)
#define PcmciaCLPD6832     PCMCTL_ID(PcmciaCirrusLogic, 6832, 0) 
#define PcmciaCLPD6834     PCMCTL_ID(PcmciaCirrusLogic, 6834, 0)

#define PcmciaDB87144      PCMCTL_ID(PcmciaDatabookCB, 87144, 0)

#define PcmciaNEC66369     PCMCTL_ID(PcmciaNEC, 66369, 0)
#define PcmciaNEC98        PCMCTL_ID(PcmciaNEC_98, 0, 0)
#define PcmciaNEC98102     PCMCTL_ID(PcmciaNEC_98, 102, 0)

#define PcmciaOpti82C814   PCMCTL_ID(PcmciaOpti, 814, 0)
#define PcmciaOpti82C824   PCMCTL_ID(PcmciaOpti, 824, 0)

#define PcmciaRL5C465      PCMCTL_ID(PcmciaRicoh, 465, 0)
#define PcmciaRL5C466      PCMCTL_ID(PcmciaRicoh, 466, 0)
#define PcmciaRL5C475      PCMCTL_ID(PcmciaRicoh, 475, 0)
#define PcmciaRL5C476      PCMCTL_ID(PcmciaRicoh, 476, 0)
#define PcmciaRL5C478      PCMCTL_ID(PcmciaRicoh, 478, 0)

#define PcmciaTI1031       PCMCTL_ID(PcmciaTI, 1031, 0)
#define PcmciaTI1130       PCMCTL_ID(PcmciaTI, 1130, 0)
#define PcmciaTI1131       PCMCTL_ID(PcmciaTI, 1131, 0)
#define PcmciaTI1220       PCMCTL_ID(PcmciaTI, 1220, 0)
#define PcmciaTI1250       PCMCTL_ID(PcmciaTI, 1250, 0)
#define PcmciaTI1251B      PCMCTL_ID(PcmciaTI, 1251, 1)
#define PcmciaTI1450       PCMCTL_ID(PcmciaTI, 1450, 0)

#define PcmciaTopic95      PCMCTL_ID(PcmciaTopic, 95, 0)

#define PcmciaTrid82C194   PCMCTL_ID(PcmciaTrid, 194, 0)


//
// Vendor/Device Ids for pcmcia controllers we're interested in
//
#define PCI_CIRRUSLOGIC_VENDORID 0x1013
#define PCI_TI_VENDORID          0x104C
#define PCI_TOSHIBA_VENDORID     0x1179
#define PCI_RICOH_VENDORID       0x1180
#define PCI_DATABOOK_VENDORID    0x10B3
#define PCI_OPTI_VENDORID        0x1045
#define PCI_TRIDENT_VENDORID     0x1023
#define PCI_O2MICRO_VENDORID     0x1217
#define PCI_NEC_VENDORID         0x1033


#define PCI_CLPD6729_DEVICEID    0x1100
#define PCI_CLPD6832_DEVICEID    0x1110
#define PCI_CLPD6834_DEVICEID    0x1112

#define PCI_TI1130_DEVICEID      0xAC12
#define PCI_TI1031_DEVICEID      0xAC13
#define PCI_TI1131_DEVICEID      0xAC15
#define PCI_TI1250_DEVICEID      0xAC16
#define PCI_TI1220_DEVICEID      0xAC17
#define PCI_TI1450_DEVICEID      0xAC1B
#define PCI_TI1251B_DEVICEID     0xAC1F

#define PCI_TOPIC95_DEVICEID     0x060A

#define PCI_RL5C465_DEVICEID     0x0465
#define PCI_RL5C466_DEVICEID     0x0466
#define PCI_RL5C475_DEVICEID     0x0475
#define PCI_RL5C476_DEVICEID     0x0476
#define PCI_RL5C478_DEVICEID     0x0478

#define PCI_DB87144_DEVICEID     0x3106

#define PCI_OPTI82C814_DEVICEID  0xC814
#define PCI_OPTI82C824_DEVICEID  0xC824

#define PCI_TRID82C194_DEVICEID  0x0194

#define PCI_NEC66369_DEVICEID    0x003E



#endif  // _PCMCIA_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\inc\dbsocket.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dbsocket.h

Abstract:

    Definitions and structures for Databook TCIC support.
    
Author(s):
        John Keys - Databook Inc. 7-Apr-1995

Revisions:
--*/


#ifndef _dbsocket_h_        // prevent multiple includes 
#define _dbsocket_h_

#include "pcmcia.h"

typedef struct _DBSOCKET {
    SOCKET  skt;                /* PCMCIA.H SOCKET structure        */
    UCHAR   busyLed;            /* Busy LED state                   */
    USHORT  timerStarted;       /* indicate if the BusyLED timer up */
    ULONG   physPortAddr;       /* unmapped port address            */
    USHORT  chipType;           /* TCIC silicon ID                  */
    USHORT  dflt_vcc5v;         /* default 5V Vcc bits              */
    USHORT  dflt_wctl;          /* default AR_WCTL bits             */
    USHORT  dflt_syscfg;        /* default AR_SYSCFG bits           */
    USHORT  dflt_ilock;         /* default AR_ILOCK bits            */
    USHORT  dflt_wrmctl;        /* default IR_WRMCTL bits           */
    USHORT  dflt_scfg1;         /* default IR_SCFG1 bits            */
    USHORT  clkdiv;             /* clock rate divisor (SHFT CNT.)   */
    UCHAR   IRQMapTbl[16];      /* IRQ map                          */
    UCHAR   niowins;            /* number of io windows             */
    UCHAR   nmemwins;           /* number of mem windows            */
    }DBSOCKET, *PDBSOCKET; 

    
/* Codes for various useful bits of information:
 */
#define TCIC_IS270      0x01    /* New TCIC at base+0x400 */
#define TCIC_ALIAS800   0x02    /* Aliased at base+0x800  */
#define TCIC_IS140      0x04    /* Aliased at base+0x10   */
#define TCIC_ALIAS400   0x08    /* Aliased at base+0x400  */

#define TCIC_ALIAS  1
#define TCIC_NOALIAS    2
#define TCIC_NONE   0

/* For tagging wonky-looking IRQ lines:
 */
#define TCIC_BADIRQ 0x80
#define ICODEMASK   0x7f

/* Memory offsets used in looking for TCICs at fixed distances from a base
 * address:
 */
#define TCIC_OFFSET_400     0x400
#define TCIC_OFFSET_800     0x800
#define TCIC_ALIAS_OFFSET   0x010


/* 
 * Constants for power tables 
 */
#define SPWR_VCC_SUPPLY 0x8000
#define SPWR_VPP_SUPPLY 0x6000
#define SPWR_ALL_SUPPLY (SPWR_VCC_SUPPLY | SPWR_VPP_SUPPLY)

#define SPWR_0p0V   0
#define SPWR_5p0V   50
#define SPWR_12p0V  120

#define PWRTBL_WORDS    9
#define PWRTBL_SIZE (PWRTBL_WORDS * sizeof(unsigned short))


/*
 * Fixed point integer type and handler macros
 */
typedef unsigned long FIXEDPT;
#define FIXEDPT_FRACBITS 8
#define INT2FXP(n)  (((FIXEDPT)(n)) << FIXEDPT_FRACBITS)

#define ISx84(x) (((x) == SILID_DB86084_1) || ((x) == SILID_DB86084A) || ((x) == SILID_DB86184_1))
#define ISPNP(x) (((x) == SILID_DB86084_1) || ((x) == SILID_DB86084A) || ((x) == SILID_DB86184_1))

/*
 *Chip Properties - matches capabilites to a Chip ID 
 */

typedef struct ChipProps_t {
    USHORT  chip_id;        /* The Silicon ID for this chip     */
    PUSHORT privpwrtbl;     /* the power table that applies     */
    UCHAR   reserved_1;     /* Alignment byte                   */
    PUCHAR  irqcaps;        /* table of possible IRQs           */
    USHORT  maxsockets;     /* max # of skts for this chip      */
    USHORT  niowins;        /* # I/O wins supported             */
    USHORT  nmemwins;       /* # mem wins supported             */
    USHORT  fprops;         /* Various properties flags         */ 
#   define fIS_PNP     1    /* chip is Plug-n-Play              */
#   define fEXTBUF_CHK 2    /* chip may need ext buffering check*/
#   define fSKTIRQPIN  4    /* chip has socket IRQ pin          */
#   define fINVALID    8    /* Can't get good flags             */
    }CHIPPROPS;


/* MODE_AR_SYSCFG must have, with j = ***read*** (***, R_AUX)
   and k = (j>>9)&7:
    if (k&4) k == 5
    And also:
    j&0x0f is none of 2, 8, 9, b, c, d, f
        if (j&8) must have (j&3 == 2)
        Can't have j==2
 */
#define INVALID_AR_SYSCFG(x) ((((x)&0x1000) && (((x)&0x0c00) != 0x0200)) \
                || (((((x)&0x08) == 0) || (((x)&0x03) == 2)) \
                && ((x) != 0x02)))
/* AR_ILOCK must have bits 6 and 7 the same:
 */
#define INVALID_AR_ILOCK(x) ((((x)&0xc0) != 0) && (((x)&0xc0) != 0xc0))

/* AR_TEST has some reserved bits:
 */
#define INVALID_AR_TEST(x)  (((x)&0154) != 0)

/* Wait state codes */
#define WCTL_300NS  8

/**** end of dbsocket.H ****/
#endif /* _dbsocket_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\inc\debug.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This header provides debugging support prototypes and macros

Author:

    Neil Sandlin (neilsa) 10-Aug-98
      - code merged from mf.sys and pcmcia.sys

Revision History:


--*/


#if !defined(_DEBUG_)
#define DEBUG

#if DBG

typedef struct _PCMCIA_STRING_MAP {
    ULONG Id;
    PCHAR String;
} PCMCIA_STRING_MAP, *PPCMCIA_STRING_MAP;

//
// Debug globals
//

extern ULONG PcmciaDebugMask;
extern PCMCIA_STRING_MAP PcmciaDbgPnpIrpStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgPoIrpStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgDeviceRelationStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgSystemPowerStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgDevicePowerStringMap[];
extern PPCMCIA_STRING_MAP PcmciaDbgStatusStringMap;
extern PCMCIA_STRING_MAP PcmciaDbgFdoPowerWorkerStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgPdoPowerWorkerStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgSocketPowerWorkerStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgConfigurationWorkerStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgTupleStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgWakeStateStringMap[];

//
// Debug prototypes
//

PCHAR
PcmciaDbgLookupString(
    IN PPCMCIA_STRING_MAP Map,
    IN ULONG Id
    );


VOID
PcmciaDebugPrint(
                ULONG  DebugMask,
                PCCHAR DebugMessage,
                ...
                );

VOID
PcmciaDumpSocket(
    IN PSOCKET Socket
    );

VOID
PcmciaWriteTraceEntry(
    IN PSOCKET Socket,
    IN ULONG Context
    );

//
// Debug macros
//
#define DebugPrint(X) PcmciaDebugPrint X

#define DUMP_SOCKET(Socket) PcmciaDumpSocket(Socket)

#define TRACE(Socket, Context) PcmciaWriteTraceEntry(Socket, Context)

#define STATUS_STRING(_Status)                                              \
    (_Status) == STATUS_SUCCESS ?                                           \
        "STATUS_SUCCESS" : PcmciaDbgLookupString(PcmciaDbgStatusStringMap, (_Status))

#define PNP_IRP_STRING(_Irp)                                                \
    PcmciaDbgLookupString(PcmciaDbgPnpIrpStringMap, (_Irp))

#define PO_IRP_STRING(_Irp)                                                 \
    PcmciaDbgLookupString(PcmciaDbgPoIrpStringMap, (_Irp))

#define RELATION_STRING(_Relation)                                          \
    PcmciaDbgLookupString(PcmciaDbgDeviceRelationStringMap, (_Relation))

#define SYSTEM_POWER_STRING(_State)                                         \
    PcmciaDbgLookupString(PcmciaDbgSystemPowerStringMap, (_State))

#define DEVICE_POWER_STRING(_State)                                         \
    PcmciaDbgLookupString(PcmciaDbgDevicePowerStringMap, (_State))

#define FDO_POWER_WORKER_STRING(_State)                                    \
    PcmciaDbgLookupString(PcmciaDbgFdoPowerWorkerStringMap, (_State))

#define PDO_POWER_WORKER_STRING(_State)                                    \
    PcmciaDbgLookupString(PcmciaDbgPdoPowerWorkerStringMap, (_State))

#define SOCKET_POWER_WORKER_STRING(_State)                                 \
    PcmciaDbgLookupString(PcmciaDbgSocketPowerWorkerStringMap, (_State))

#define CONFIGURATION_WORKER_STRING(_State)                                 \
    PcmciaDbgLookupString(PcmciaDbgConfigurationWorkerStringMap, (_State))

#define TUPLE_STRING(_Tuple)                                                \
    PcmciaDbgLookupString(PcmciaDbgTupleStringMap, (_Tuple))

#define WAKESTATE_STRING(_State)                                                \
    PcmciaDbgLookupString(PcmciaDbgWakeStateStringMap, (_State))

//
// Debug mask flags
//
#define PCMCIA_DEBUG_ALL       0xFFFFFFFF
#define PCMCIA_DEBUG_FAIL      0x00000001
#define PCMCIA_DEBUG_INFO      0x00000002
#define PCMCIA_DEBUG_PNP       0x00000004
#define PCMCIA_DEBUG_POWER     0x00000008
#define PCMCIA_DEBUG_SOCKET    0x00000010
#define PCMCIA_DEBUG_CONFIG    0x00000020
#define PCMCIA_DEBUG_TUPLES    0x00000040
#define PCMCIA_DEBUG_RESOURCES 0x00000080
#define PCMCIA_DEBUG_ENUM      0x00000100
#define PCMCIA_DEBUG_INTERFACE 0x00001000
#define PCMCIA_DEBUG_IOCTL     0x00002000
#define PCMCIA_DEBUG_DPC       0x00004000
#define PCMCIA_DEBUG_ISR       0x00008000
#define PCMCIA_PCCARD_READY    0x00010000
#define PCMCIA_DEBUG_DETECT    0x00020000
#define PCMCIA_COUNTERS        0x00040000
#define PCMCIA_DEBUG_IRQMASK   0x00080000
#define PCMCIA_DUMP_SOCKET     0x00100000

//
// Structures
//

typedef struct _TRACE_ENTRY {

    ULONG Context;
    ULONG CardBusReg[5];
    UCHAR ExcaReg[70];

} TRACE_ENTRY, *PTRACE_ENTRY;

#else

//
// !defined DBG
//

#define DebugPrint(X)
#define DUMP_SOCKET(Socket)
#define PDO_TRACE(PdoExt, Context)
#define STATUS_STRING(_Status)      ""
#define PNP_IRP_STRING(_Irp)        ""
#define PO_IRP_STRING(_Irp)         ""
#define RELATION_STRING(_Relation)  ""
#define SYSTEM_POWER_STRING(_State) ""
#define DEVICE_POWER_STRING(_State) ""

#endif // DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\inc\tcic2.h ===
/* tcic2.h	Mon Jul 25 1994 18:30:04 zema */

/*

Module:  tcic2.h

Function:
	Definitions for DB86082 (TCIC-2/N) PCMCIA
	V2 interface controller chip.

Version:
	V6.62f	Mon Jul 25 1994 18:30:04 zema	Edit level 34


Copyright Notice:
	This file is in the public domain.  It was created by:

		Databook Inc.
		Building E, Suite 6
		3495 Winton Place
		Rochester, NY  14623

		Telephone:	+1-716-292-5720
		Fax:		+1-716-292-5737
		BBS:		+1-716-292-5741
		Email:		support@databook.com
		Compuserve:	go databook

	This code is provided as-is.  Databook makes no warrantees of
	any kind as to its correctness or suitability for any purpose,
	and disclaims all liability for any loss or damage resulting from
	the use of this file, including without limitation contingent, 
	special, or other liability.

 
Author:
	Terry Moore, Databook Inc.	April 1991

Revision history:
   1.00a  Mon Apr 15 1991 19:16:41  tmm
	Module created.


   6.62f  Mon Jul 25 1994 18:30:04 zema
	Incorporated define of a Chip's Silicon ID into ILOCKTEST define. ex.-
	#define SILID_DBxxxx		(n)
 	#define ILOCKTEST_DBxxxx	((SILID_DBxxxx) << ILOCKTEST_ID_SHFT)

*/

/*****************************************************************************\

This file contains a set of common definitions for the Databook/Fujitsu
family of memory and I/O card controller chips, known by Databook as the 
TCIC family.

When this file is included it will define symbols for one or more chips,
depending on whether the following symbols are defined:

	MB86301		gets definitions for the Fujitsu 86301
	DB86081		gets definitions for the Databook TCIC-2/P
	DB86082		gets definitions for the Databook TCIC-2/N.
	DB86082A	gets definitions for 86082a, and for the 86082.

For backwards compatibility, the file "mcic.h" will define MB86301, then
call this file.

\*****************************************************************************/

#ifndef _TCIC2_H_		/* prevent multiple includes */
#define _TCIC2_H_


//
// Memory window sizes that will be allocated
// for this controller - to map card memory
//
#define TCIC_WINDOW_SIZE                 0x8000  //(32K)
#define TCIC_WINDOW_ALIGNMENT            0x8000  //(32K)

#define NUMSOCKETS	2
#define	CHIPBASE	0x240

/* register definitions */
#define	R_DATA	0		/* data register */
#define	R_ADDR	2		/* address register */
#define	R_ADDR2	(R_ADDR+2)	/*   high order word of address register */
#define	R_SCTRL	6		/* socket ctrl register */
#define	R_SSTAT	7		/* socket status register */
#define	R_MODE	8		/* controller mode register */
#define	R_PWR	9		/* controller power register */
#define	R_EDC	10		/* EDC register */
#define	R_ICSR	12		/* interrupt control/status register */
#define	R_IENA	13		/* interrupt enable register */
#define	R_AUX	14		/* auxiliary control registers */


/*

The TCIC-2 family defines architectural extensions for handling multiple
sockets with a single chip.  Much of this is handled via a "socket select"
field in the address register.

We define the fields first as bit fields within the high order word
of the address register, as this will be the most convenient way for
software to access them; for completeness, and for the benefit of C code, we
define the fields as part of the ULONG that represents the entire address
register.

*/

/**** first, some simple definitions ****/
#define	TCIC_SS_SHFT	12			/* default location for the
						socket select bits
						*/
#define	TCIC_SS_MASK	(7 << TCIC_SS_SHFT)	/* default mask for the
						socket select bits
						*/

/* bits in ADDR2 */
#define	ADR2_REG	(1 << 15)		/* select REG space */
#define	ADR2_SS_SHFT	TCIC_SS_SHFT		/* select sockets the usual
						way */
#define	ADR2_SS_MASK	TCIC_SS_MASK		/* ditto */
#define	ADR2_INDREG	(1 << 11)		/* access indirect registers
						||  (not card data)
						*/
#define	ADR2_IO		(1 << 10)		/* select I/O cycles, readback
						||  card /IORD, /IOWR in diag-
						||  nostic mode.
						*/

/* Bits in address register */
#define	ADDR_REG  ((unsigned long) ADR2_REG << 16)	/* OR with this for REG space */
#define	ADDR_SS_SHFT	((unsigned long) ADR2_SS_SHFT + 16)
						/* shift count, cast so that
						|| you'll get the right type
						|| if you use it but forget
						|| to cast the left arg.
						*/
#define	ADDR_SS_MASK	((unsigned long) ADR2_SS_MASK << 16)
#define	ADDR_INDREG	((unsigned long) ADR2_INDREG << 16)
#define	ADDR_IO		((unsigned long) ADR2_IO << 16)

#define	ADDR_SPACE_SIZE	((unsigned long) 1 << 26)
#define	ADDR_MASK	(ADDR_SPACE_SIZE - 1)

/* following bits are defined in diagnostic mode */
#define	ADDR_DIAG_NREG	 ((unsigned long) 1 << 31)	/* inverted! */
#define	ADDR_DIAG_NCEH	 ((unsigned long) 1 << 30)
#define	ADDR_DIAG_NCEL	 ((unsigned long) 1 << 29)
#define	ADDR_DIAG_NCWR	 ((unsigned long) 1 << 28)
#define	ADDR_DIAG_NCRD	 ((unsigned long) 1 << 27)
#define	ADDR_DIAG_CRESET ((unsigned long) 1 << 26)

/* Bits in socket control register */
#define	SCTRL_ENA	(1 << 0)	/* enable access to card */
#define	SCTRL_INCMODE	(3 << 3)	/* mask for increment mode:  */
#define  SCTRL_INCMODE_AUTO  (3 << 3)	/*   auto-increment mode */
#define  SCTRL_INCMODE_HOLD  (0 << 3)	/*   byte hold mode */
#define	 SCTRL_INCMODE_WORD  (1 << 3)	/*   word hold mode */
#define	 SCTRL_INCMODE_REG   (2 << 3)	/*   reg-space increment mode */
#define	SCTRL_EDCSUM	(1 << 5)	/* if set, use checksum (not CRC) */
#define	SCTRL_RESET	(1 << 7)	/* internal software reset */

/**** the status register (read-only):  R_SSTAT ****/
#define	SSTAT_6US	(1 << 0)	/* 6 microseconds have elapsed */
#define	SSTAT_10US	(1 << 1)	/* 10 microseconds have elapsed */
#define	SSTAT_PROGTIME	(1 << 2)	/* programming pulse timeout */
#define	SSTAT_LBAT1	(1 << 3)	/* low battery 1 */
#define	SSTAT_LBAT2	(1 << 4)	/* low battery 2 */
#define  SSTAT_BATOK	  (0 << 3)	/* battery is OK */
#define	 SSTAT_BATBAD1	  (1 << 3)	/* battery is low */
#define	 SSTAT_BATLO	  (2 << 3)	/* battery is getting low */
#define	 SSTAT_BATBAD2	  (3 << 3)	/* battery is low */
#define	SSTAT_RDY	(1 << 5)	/* card is ready (not busy) */
#define	SSTAT_WP	(1 << 6)	/* card is write-protected */
#define	SSTAT_CD	(1 << 7)	/* card present */

/**** mode register contents (R_MODE) ****/
#define	MODE_PGMMASK	(0x1F)		/* the programming mode bits */
#define	MODE_NORMAL	(0)		/*   normal mode */
#define	MODE_PGMWR	(1 << 0)	/*   assert /WR */
#define	MODE_PGMRD	(1 << 1)	/*   assert /RD */
#define	MODE_PGMCE	(1 << 2)	/*   assert /CEx */
#define	MODE_PGMDBW	(1 << 3)	/*   databus in write mode */
#define	MODE_PGMWORD	(1 << 4)	/*   word programming mode */

#define	MODE_AUXSEL_SHFT (5)		/* shift count for aux regs */
#define	MODE_AUXSEL_MASK (7 << 5)	/* the aux-reg select bits */
#define	MODE_AR_TCTL	(0 << MODE_AUXSEL_SHFT)	/* timing control */
#define	MODE_AR_PCTL	(1 << MODE_AUXSEL_SHFT)	/* pulse control */
#define	MODE_AR_WCTL	(2 << MODE_AUXSEL_SHFT)	/* wait-state control */
#define	MODE_AR_EXTERN	(3 << MODE_AUXSEL_SHFT)	/* external reg select */
#define	MODE_AR_PDATA	(4 << MODE_AUXSEL_SHFT)	/* programming data reg */
#define	MODE_AR_SYSCFG	(5 << MODE_AUXSEL_SHFT) /* system config reg */
#define	MODE_AR_ILOCK	(6 << MODE_AUXSEL_SHFT)	/* interlock control reg */
#define	MODE_AR_TEST	(7 << MODE_AUXSEL_SHFT)	/* test control reg */

#define	PWR_VCC_SHFT	(0)			/* the VCC ctl shift */
#define	PWR_VCC_MASK	(3 << PWR_VCC_SHFT)

#define	PWR_VPP_SHFT	(3)			/* the VPP ctl shift */
#define	PWR_VPP_MASK	(3 << PWR_VPP_SHFT)
#define	PWR_ENA		(1 << 5)		/* on 084, successors, this
						|| must be set to turn on
						|| power.
						*/
#define	PWR_VCC5V	(1 << 2)		/* enable +5 (not +3) */
#define	PWR_VOFF_POFF	(0)			/* turn off VCC, VPP */
#define	PWR_VON_PVCC	(1)			/* turn on VCC, VPP=VCC */
#define	PWR_VON_PVPP	(2)			/* turn on VCC, VPP=12V */
#define	PWR_VON_POFF	(3)			/* turn on VCC, VPP=0V */

#define	PWR_CLIMENA	(1 << 6)		/* the current-limit enable */
#define	PWR_CLIMSTAT	(1 << 7)		/* current limit sense (r/o) */

/**** int CSR ****/
#define	ICSR_IOCHK	(1 << 7)		/* I/O check */
#define	ICSR_CDCHG	(1 << 6)		/* card status change: top 5
						|| bits of SSTAT register.
						*/
#define	ICSR_ERR	(1 << 5)		/* error condition */
#define	ICSR_PROGTIME	(1 << 4)		/* program timer ding */
#define	ICSR_ILOCK	(1 << 3)		/* interlock change */
#define	ICSR_STOPCPU	(1 << 2)		/* Stop CPU was asserted */
#define	ICSR_SET	(1 << 1)		/* (w/o:  enable writes that set bits */
#define	ICSR_CLEAR	(1 << 0)		/* (w/o:  enable writes that clear */
#define	ICSR_JAM	(ICSR_SET|ICSR_CLEAR)	/* jam value into ICSR */

/**** interrupt enable bits ****/
#define	IENA_CDCHG	(1 << 6)	/* enable INT when ICSR_CDCHG is set */
#define	IENA_ERR	(1 << 5)	/* enable INT when ICSR_ERR is set */
#define	IENA_PROGTIME	(1 << 4)	/* enable INT when ICSR_PROGTIME " */
#define	IENA_ILOCK	(1 << 3)	/* enable INT when ICSR_ILOCK is set */
#define	IENA_CFG_MASK	(3 << 0)	/* select the bits for IRQ config: */
#define	IENA_CFG_OFF	(0 << 0)	/*  IRQ is high-impedance */
#define	IENA_CFG_OD	(1 << 0)	/*  IRQ is active low, open drain. */
#define	IENA_CFG_LOW	(2 << 0)	/*  IRQ is active low, totem pole */
#define	IENA_CFG_HIGH	(3 << 0)	/*  IRQ is active high, totem pole */

/**** aux registers ****/
#define	WAIT_COUNT_MASK	(0x1F)		/* the count of 1/2 wait states */
#define	WAIT_COUNT_SHFT (0)		/* the wait-count shift */
#define	WAIT_ASYNC	(1 << 5)	/* set for asynch, clear for synch cycles */

#define	WAIT_SENSE	(1 << 6)	/* select rising (1) or falling (0) 
					|| edge of wait clock as reference 
					|| edge.
					*/
#define	WAIT_SRC	(1 << 7)	/* select constant clock (0) or bus
					|| clock (1) as the timing source 
					*/

/**** some derived constants ****/
#define	WAIT_BCLK	(1 * WAIT_SRC)
#define	WAIT_CCLK	(0 * WAIT_SRC)
#define	WAIT_RISING	(1 * WAIT_SENSE)
#define	WAIT_FALLING	(0 * WAIT_SENSE)

/**** high byte ****/
#define	WCTL_WR		(1 << 8)	/* control:  pulse write */
#define	WCTL_RD		(1 << 9)	/* control:  pulse read */
#define	WCTL_CE		(1 << 10)	/* control:  pulse chip ena */
#define	WCTL_LLBAT1	(1 << 11)	/* status:  latched LBAT1 */
#define	WCTL_LLBAT2	(1 << 12)	/* status:  latched LBAT2 */
#define	WCTL_LRDY	(1 << 13)	/* status:  latched RDY */
#define	WCTL_LWP	(1 << 14)	/* status:  latched WP */
#define	WCTL_LCD	(1 << 15)	/* status:  latched CD */

/**** the same thing, from a byte perspective ****/
#define	AR_WCTL_WAIT	(R_AUX + 0)	/* the wait state control byte */
#define	AR_WCTL_XCSR	(R_AUX + 1)	/* extended control/status */

#define	XCSR_WR		(1 << 0)	/* control:  pulse write */
#define	XCSR_RD		(1 << 1)	/* control:  pulse read */
#define	XCSR_CE		(1 << 2)	/* control:  pulse chip ena */
#define	XCSR_LLBAT1	(1 << 3)	/* status:  latched LBAT1 */
#define	XCSR_LLBAT2	(1 << 4)	/* status:  latched LBAT2 */
#define	XCSR_LRDY	(1 << 5)	/* status:  latched RDY */
#define	XCSR_LWP	(1 << 6)	/* status:  latched WP */
#define	XCSR_LCD	(1 << 7)	/* status:  latched CD */

/**** prog timers ****/
#define	TCTL_6US_SHFT	(0)		/* the shift count for the 6 us ctr */
#define	TCTL_10US_SHFT	(8)		/* the shift count for the 10 us ctr */
#define	TCTL_6US_MASK	(0xFF << TCTL_6US_SHFT)
#define	TCTL_10US_MASK	(0xFF << TCTL_10US_SHFT)

#define	AR_TCTL_6US	(R_AUX + 0)	/* the byte access handle */
#define	AR_TCTL_10US	(R_AUX + 1)	/* the byte access handle */

/**** The programming pulse register ****/
#define	AR_PULSE_LO	(R_AUX + 0)
#define	AR_PULSE_HI	(R_AUX + 1)

/**** The programming data register ****/
#define	AR_PDATA_LO	(R_AUX + 0)
#define	AR_PDATA_HI	(R_AUX + 1)

/**** the system configuration register ****/
/*
|| The bottom four bits specify the steering of the socket IRQ.  On
|| the 2N, the socket IRQ is (by default) pointed at the dedicated
|| pin.
*/
#define	SYSCFG_IRQ_MASK		(0xF)		/* mask for this bit field. */
#define	  SYSCFG_SSIRQDFLT	(0)	/* default:  use SKTIRQ (2/N) 
					||	disable (2/P)
					*/
#define   SYSCFG_SSIRQ		(0x1)	/* use SKTIRQ (explicit) (2/N) 
					||	do not use (2/P)
					*/
#define   SYSCFG_SIRQ3		(0x3)	/* use IRQ3 */
#define   SYSCFG_SIRQ4		(0x4)	/* use IRQ4 */
#define   SYSCFG_SIRQ5		(0x5)	/* use IRQ5 (2/N) */
#define   SYSCFG_SIRQ6		(0x6)	/* use IRQ6 (2/N) */
#define   SYSCFG_SIRQ7		(0x7)	/* use IRQ7 (2/N) */
#define   SYSCFG_SIRQ10		(0xA)	/* use IRQ10 */
#define   SYSCFG_SIRQ14		(0xE)	/* use IRQ14 */

#define	SYSCFG_MCSFULL	(1 << 4)	/* 
	If set, use full address (a[12:23]) for MCS16 generation.
	If clear, run in ISA-compatible mode (only using a[17:23]).
	With many chip sets, the TCIC-2/N's timing will will allow full
	address decoding to be used rather than limiting us to LA[17:23];
	thus we can get around the ISA spec which limits the granularity
	of bus sizing to 128K blocks.
*/
#define	SYSCFG_IO1723	(1 << 5)	/*
	Flag indicating that LA[17:23] can be trusted to be zero during a true
	I/O cycle.  Setting this bit will allow us to reduce power consumption
	further by eliminating I/O address broadcasts for memory cycles.

	Unfortunately, you cannot trust LA[17:23] to be zero on all systems,
	because the ISA specs do not require that LA[17:23] be zero when an
	alternate bus master runs an I/O cycle.  However, on a palmtop or
	notebook, it is a good guess.
*/

#define	SYSCFG_MCSXB	(1 << 6)	/*
	If set, assume presence of an external buffer for MCS16:  operate
	the driver as a totem-pole output.
	
	If clear, run in psuedo-ISA mode; output is open drain.  But note 
	that on the 082 the output buffers cannot drive a 300-ohm
	load.
*/
#define	SYSCFG_ICSXB	(1 << 7)	/*
	If set, assume presence of an external buffer for IOCS16*; operate
	the buffer as a totem-pole output.

	If clear, run in psuedo-ISA mode; output is open drain.  But note 
	that on the 082 the output buffers cannot drive a 300-ohm
	load.
*/
#define	SYSCFG_NOPDN	(1 << 8)	/*
	If set, disable the auto power-down sequencing.  The chip will
	run card cycles somewhat more quickly (though perhaps not
	significantly so); but it will dissipate significantly more power.

	If clear, the low-power operating modes are enabled.  This
	causes the part to go into low-power mode automatically at
	system reset.

*/
#define	SYSCFG_MPSEL_SHFT (9)
#define	SYSCFG_MPSEL_MASK (7 << 9)		/*
	This field controls the operation of the multipurpose pin on the
	86082.  It has the following codes:
*/
#define	  SYSCFGMPSEL_OFF	(0 << SYSCFG_MPSEL_SHFT)	/*
		This is the reset state; it indicates that the Multi-purpose
		pin is not used.  The pin will be held in a high-impedance
		state.  It can be read by monitoring SYSCFG_MPSENSE.
*/
#define	  SYSCFGMPSEL_NEEDCLK	(1 << SYSCFG_MPSEL_SHFT)	/*
		NMULTI is an output.
		External indication that CCLK or BCLK are needed in order
		to complete an internal operation.  External logic can use
		this to control the clocks coming to the chip.
*/
#define	  SYSCFGMPSEL_MIO	(2 << SYSCFG_MPSEL_SHFT)	/*
		NMULTI is an input; it is an unambiguous M/IO signal, issued
		with timing similar to the LA[] lines.
*/
#define	  SYSCFGMPSEL_EXTSEL	(3 << SYSCFG_MPSEL_SHFT)	/*
		NMULTI is an output; it is the external register select
		pulse, generated whenever software attempts to access
		aux register AR_EXTRN. Of course, the 86082 will ignore
		writes to AR_EXTRN, and will float the data bus if
		the CPU reads from AR_EXTRN.
*/
/*				(4 << SCFG_MPSEL_SHFT)	 is reserved */

#define	  SYSCFGMPSEL_RI	(5 << SYSCFG_MPSEL_SHFT)	/*
		NMULTI is an output; it indicates a RI (active-going)
		transition has occurred lately on a an appropriately-
		configured socket.  The output is active low.
*/
/*
		Codes 4, 6 and 7 are reserved, and must NOT be output.  It is
		indeed possibly hazardous to your system to encode values in
		this field that do not match your hardware!
*/

/*			1 << 12		reserved */

#define	SYSCFG_MPSENSE	(1 << 13)	/* 
	This bit, when read, returns the sense of the multi-purpose
	pin.
*/


#define	SYSCFG_AUTOBUSY	(1 << 14)	/* 
	This bit, when set, causes the busy led to be gated with the
	SYSCFG_ACC bit.  When clear, the busy led reflects whether the
	socket is actually enabled.  If AUTOBUSY is set and ACC is clear,
	then the busy light will be off, even if a socket is enabled.
	If AUTOBUSY is clear, then the busy light will be on if either
	socket is enabled.

	Note, that when in a programming mode, you should either clear this
	bit (causing the busy light to be on whenever the socket is enabled)
	or set both this bit and the ACC bit (causing the light to be on
	all the time).	

	On the '084 and '184, this bit is per-socket.

*/

#define	SYSCFG_ACC	(1<<15)		/* 
	This bit will be set automatically by the hardware whenever the CPU
	accesses data on a card.  It can be cleared under software control.

	In AUTOBUSY mode, it has the additional effect of turning on the
	busy light.

	Since we'll tristate the command lines as the card is going out of
	the socket, and since the shared lines idle low, there's no real
	danger if the busy light is off even though the socket is enabled.

	On the '084 and '184, this bit is per-socket.

*/

/*
 C0: The interlock control register.
*/
#define	AR_ILOCK	(R_AUX+0)	/* symbolic handle for low byte */

#define	ILOCK_OUT	(1 << 0)	/* interlock output 
					|| per-socket on x84
					*/
#define	ILOCK_SENSE	(1 << 1)	/* (r/o) interlock sense
					||  0 -> /cilock not asserted;
					||  1 -> /cilock is asserted.
					|| per-socket on x84.
					*/
#define	ILOCK_CRESET	(1 << 2)	/* card reset output level (S) */
#define	ILOCK_CRESENA	(1 << 3)	/* enable card reset output (S) */
#define	ILOCK_CWAIT	(1 << 4)	/* enable card wait (S) */
#define	ILOCK_CWAITSNS	(1 << 5)	/* (r/o) sense current state of wait 
					||  0 -> /cwait not asserted; 
					||  1 -> /cwait is asserted
					|| (S)
					*/
/*  the shift count & mask for the hold-time control */
#define	ILOCK_HOLD_SHIFT	6	/* shift count for the hold-time ctl (G) */
#define	ILOCK_HOLD_MASK		(3 << ILOCK_HOLD_SHIFT)

/* 
|| quick hold mode waits until we observe that the strobe is high,
|| guaranteeing 10ns or so of hold time.
*/
#define	  ILOCK_HOLD_QUICK	(0 << ILOCK_HOLD_SHIFT)

/*
|| CCLK hold mode waits (asynchronously) for an edge on CCLK.  Minimum is 1 
|| CCLK + epsilon; maximum is 2 CCLKs + epsilon.
||
|| for the 86081 & '82, this mode enables the multi-step
|| sequencer that generates setup and hold times based on CCLK.  This
|| is the recommended mode of operation for the '81 and '82.
*/
#define	  ILOCK_HOLD_CCLK	(3 << ILOCK_HOLD_SHIFT)

/**** The following bits are only present on the x84 and later parts ****/
#define	ILOCK_INPACK	(1 << 11)	/* (r/o, S) this bit is a diagnostic
					|| read-back for card input
					|| acknowledge.
					|| The sense is inverted from the
					|| level at the pin.
					*/
#define	ILOCK_CP0	(1 << 12)	/* (r/o, S) this bit is a diagnostic
					|| monitor for card present pin 0.
					|| The sense is inverted from the
					|| level at the pin.
					*/
#define	ILOCK_CP1	(1 << 13)	/* (r/o, S) this bit is a diagnostic
					|| monitor for card present pin 1.
					|| The sense is inverted from the
					|| level at the pin.
					*/
#define	ILOCK_VS1	(1 << 14)	/* (r/o, S) this bit is the primary
					|| monitor for Card Voltage Sense
					|| pin 1.
					|| The sense is inverted from the
					|| level at the pin.
					*/
#define	ILOCK_VS2	(1 << 15)	/* (r/o, S) this bit is the primary
					|| monitor for Card Voltage Sense
					|| pin 2.
					|| The sense is inverted from the
					|| level at the pin.
					*/
/*

	Silicon Version Register

In diagnostic mode, the high byte of the interlock register is defined as the 
silicon identity byte.

In order to read this byte, the chip must be placed in diagnostic
mode by setting bit 15 of the TESTDIAG register.  (This may or may
not be enforced by the silicon.)

The layout is:

	15 14 13 12 11 10 9 8    7 6 5 4 3 2 1 0
	m  <-------ID------->	 <----ILOCK---->

The fields are:

m	Always reset.

ID	This field is one of the following:

	0x02	the db86082

	0x03	the db86082a

	0x04	the db86084

	0x05	the DB86072ES,	(Engineering Sample)

	0x07	the db86082bES,	(Engineering Sample)

	0x08	the db86084a

	0x14	the DB86184

	0x15	the DB86072,	(Production)

	0x17	the db86082b,	(Production)

*/

/*
|| Defines for Silicon IDs described above.
||
|| Use the following convention for defining SILID_DBxxxxxY:
||
||	SILID_DBxxxxx_1		The First step of chip.
||	SILID_DBxxxxxA		The Second step of chip.
||	SILID_DBxxxxxB		The Third step of chip.
||	SILID_DBxxxxx...	The ... step of chip.
||
||	SILID_DBxxxxx"step of chip"_ES	An Engineering Sample of chip.
||
*/
#define SILID_DB86082_1		(0x02)
#define SILID_DB86082A		(0x03)
#define SILID_DB86082B_ES	(0x07)
#define SILID_DB86082B		(0x17)

#define SILID_DB86084_1		(0x04)
#define SILID_DB86084A		(0x08)

#define SILID_DB86184_1		(0x14)

#define SILID_DB86072_1_ES	(0x05)
#define SILID_DB86072_1		(0x15)


/**** the high order bits (in diag mode) give the chip version ****/
#define	AR_ILOCK_ID	(R_AUX + 1)

#define	ILOCKTEST_ID_SHFT	8	/* the shift count */
#define	ILOCKTEST_ID_MASK	(0x7F << ILOCKTEST_ID_SHFT)
					/* the mask for the field */

/*
|| Use the following convention for defining ILOCKTEST_DBxxxxxY:
||
||	ILOCKTEST_DBxxxxx_1	The First step of chip.
||	ILOCKTEST_DBxxxxxA	The Second step of chip.
||	ILOCKTEST_DBxxxxxB	The Third step of chip.
||	ILOCKTEST_DBxxxxx...	The ... step of chip.
||
||	ILOCKTEST_DBxxxxx"step of chip"_ES	An Engineering Sample of chip.
||
*/
#define	ILOCKTEST_TCIC2N_1	((SILID_DB86082_1) << ILOCKTEST_ID_SHFT)
#define	ILOCKTEST_DB86082_1	ILOCKTEST_TCIC2N_1
#define	ILOCKTEST_TCIC2N_2	((SILID_DB86082A) << ILOCKTEST_ID_SHFT)
#define	ILOCKTEST_DB86082A	ILOCKTEST_TCIC2N_2
#define	ILOCKTEST_TCIC2N_3	((SILID_DB86082B_ES) << ILOCKTEST_ID_SHFT)
#define	ILOCKTEST_DB86082B_ES	ILOCKTEST_TCIC2N_3

#define	ILOCKTEST_DB86082B	((SILID_DB86082B) << ILOCKTEST_ID_SHFT)

#define	ILOCKTEST_DB86084_1	((SILID_DB86084_1) << ILOCKTEST_ID_SHFT)
#define	ILOCKTEST_DB86084A	((SILID_DB86084A) << ILOCKTEST_ID_SHFT)

#define	ILOCKTEST_DB86184_1	((SILID_DB86184_1) << ILOCKTEST_ID_SHFT)

#define	ILOCKTEST_DB86072_1	((SILID_DB86072_1) << ILOCKTEST_ID_SHFT)
#define	ILOCKTEST_DB86072_1_ES	((SILID_DB86072_1_ES) << ILOCKTEST_ID_SHFT)

/**** the test control register ****/
#define	AR_TEST	(R_AUX + 0)
#define	TEST_AEN	(1 << 0)	/* force card AEN */
#define	TEST_CEN	(1 << 1)	/* force card CEN */
#define	TEST_CTR	(1 << 2)	/* test programming pulse, address ctrs */
#define	TEST_ENA	(1 << 3)	/* force card-present (for test), and
					|| special VPP test mode
					*/
#define	TEST_IO		(1 << 4)	/* feed back some I/O signals
					|| internally.
					*/
#define	TEST_OUT1	(1 << 5)	/* force special address output mode */
#define	TEST_ZPB	(1 << 6)	/* enter ZPB test mode */
#define	TEST_WAIT	(1 << 7)	/* force-enable WAIT pin */
#define	TEST_PCTR	(1 << 8)	/* program counter in read-test mode */
#define	TEST_VCTL	(1 << 9)	/* force-enable power-supply controls */
#define	TEST_EXTA	(1 << 10)	/* external access doesn't override
					|| internal decoding.
					*/
#define	TEST_DRIVECDB	(1 << 11)	/* drive the card data bus all the time */
#define	TEST_ISTP	(1 << 12)	/* turn off CCLK to the interrupt CSR */
#define	TEST_BSTP	(1 << 13)	/* turn off BCLK internal to the chip */
#define	TEST_CSTP	(1 << 14)	/* turn off CCLK except to int CSR */
#define	TEST_DIAG	(1 << 15)	/* enable diagnostic read-back mode */

/*

	Indirectly Addressed Registers

Indirect address	Function
----------------	--------

[$000:$003]		Socket configuration registers for socket 0.
[$008:$00A]		Socket configuration registers for socket 1.
			(we allow for up to 8 sockets per adapter)

[$00B:$0FF]		reserved

[$100:$107]		Memory window 0 translation registers:
			$100: reserved;
			$102: base window address
			$104: map to card address
			$106: control register.
[$108:$10F]		Memory window 1 translation registers
[$110:$117]		Memory window 2 translation registers
			...
[$138:$13F]		Memory window 7 translation registers
[$140:$147]		Memory window 8 translation registers
[$148:$14F]		Memory window 9 translation registers

			(the architecture reserves room for up to
			32 windows.)

[$200:$203]		I/O window 0 translation registers
[$204:$207]		I/O window 1 translation registers
[$208:$20B]		I/O window 2 translation registers
[$20C:$20F]		I/O window 3 translation registers

[$210:$2FF]

[$300:$301]		Adapter configuration register 0 ('x84 and later)

[$320:$321]		Configuration ROM CSR.

[$380:$381]		Plug and Play ISA read port and address port reister
[$382:$383]		Plug and Play ISA configuration sequence number and
			logical device number register.
[$384:$385]		Plug and Play chip ID/test register.
[$386:$387]		Plug and Play config selection register.
[$386:$3FFFFFF]		Reserved  -- do not read or write.

*/

/*

Bit definitions:

1) The Indirect Socket Configuration Registers:

*/

#define	IR_SCFG_S(skt)	(0 + (skt) * 8)	/* base indices of socket config */
#define	IR_SCFG_S0	IR_SCFG_S(0)	/* base indices of socket config */
#define	IR_SCFG_S1	IR_SCFG_S(1)	/*   regs for socket 0, 1 */


#define	IR_MWIN_BASE		0x100	/* where they start */

#define	IR_MWIN_NUM_082		8	/* number of memory windows */
#define	IR_MWIN_NUM_082A	10	/* number of memory windows in 082a */
#define	IR_MWIN_NUM_082B	10	/* number of memory windows in 082b */
#define	IR_MWIN_NUM_084		10	/* number of memory windows in 084 */
#define	IR_MWIN_NUM_184		10	/* number of memory windows in 184 */
#define	IR_MWIN_NUM_072		10	/* number of memory windows in 072 */
#define	IR_MWIN_NUM_MAX		32	/* make arrays of windows this big */

#define	IR_MWIN_SIZE		8	/* 8 bytes per window descriptor */
#define	IR_MBASE_X		2	/* index to the memory base controlreg */
#define	IR_MMAP_X		4	/* index to the memory map control reg */
#define	IR_MCTL_X		6	/* index to the memory window control reg */

#define	IR_MBASE_W(w)	(IR_MWIN_BASE + (w) * IR_MWIN_SIZE + IR_MBASE_X)
#define	IR_MMAP_W(w)	(IR_MWIN_BASE + (w) * IR_MWIN_SIZE + IR_MMAP_X)
#define	IR_MCTL_W(w)	(IR_MWIN_BASE + (w) * IR_MWIN_SIZE + IR_MCTL_X)

#define	IR_IOWIN_BASE		0x200	/* where they start */
#define	IR_IOWIN_SIZE		4	/* bytes per window descriptor */
#define	IR_IOWIN_NUM		4	/* we have 4 of them on the 082 */
					/* should be defined as 0 on the
					86301 */
#define	IR_IOBASE_X		0	/* index to the I/O base register */
#define	IR_IOCTL_X		2	/* index to the I/O window control register */

#define	IR_IOBASE_W(w)	(IR_IOWIN_BASE + (w) * IR_IOWIN_SIZE + IR_IOBASE_X)
#define	IR_IOCTL_W(w)	(IR_IOWIN_BASE + (w) * IR_IOWIN_SIZE + IR_IOCTL_X)

/**** patterns in the indirect registers ****/
#define	IRSCFG_IRQ_MASK		(0xF)	/* mask for this bit field */
#define	  IRSCFG_IRQOFF		(0)	/* disable */
#define   IRSCFG_SIRQ		(0x1)	/* use SKTIRQ (2/N) */
#define   IRSCFG_IRQ3		(0x3)	/* use IRQ3 */
#define   IRSCFG_IRQ4		(0x4)	/* use IRQ4 */
#define   IRSCFG_IRQ5		(0x5)	/* use IRQ5 */
#define   IRSCFG_IRQ6		(0x6)	/* use IRQ6 */
#define   IRSCFG_IRQ7		(0x7)	/* use IRQ7 */
#define	  IRSCFG_IRQ9		(0x9)	/* use IRQ9 */
#define   IRSCFG_IRQ10		(0xA)	/* use IRQ10 */
#define	  IRSCFG_IRQ11		(0xB)	/* use IRQ11 */
#define	  IRSCFG_IRQ12		(0xC)	/* use IRQ12 */
#define   IRSCFG_IRQ14		(0xE)	/* use IRQ14 */
#define	  IRSCFG_IRQ15		(0xF)	/* use IRQ15 */


#define	IRSCFG_IRQOC		(1 << 4)	/* selected IRQ is
						|| open-collector, and active
						|| low; otherwise it's totem-
						|| pole and active hi.
						*/
#define	IRSCFG_PCVT		(1 << 5)	/* convert level-mode IRQ
						|| to pulse mode, or stretch
						|| pulses from card.
						*/
#define	IRSCFG_IRDY		(1 << 6)	/* interrupt from RDY (not
						|| from /IREQ).  Used with
						|| ATA drives.
						*/
#define	IRSCFG_ATA		(1 << 7)	/* Special ATA drive mode.
						|| CEL/H become CE1/2 in
						|| the IDE sense; CEL is
						|| activated for even window
						|| matches, and CEH for
						|| odd window matches.
						*/
#define	IRSCFG_DMA_SHIFT	8		/* offset to DMA selects; */
#define	IRSCFG_DMA_MASK		(0x7 << IRSCFG_DMA_SHIFT)

#define	  IRSCFG_DMAOFF		(0 << IRSCFG_DMA_SHIFT)	/* disable DMA */
#define	  IRSCFG_DREQ2		(2 << IRSCFG_DMA_SHIFT)	/* enable DMA on DRQ2 */

#define	IRSCFG_IOSTS		(1 << 11)	/* enable I/O status mode;
						||  allows CIORD/CIOWR to
						||  become low-Z.
						*/
#define	IRSCFG_SPKR		(1 << 12)	/* enable SPKR output from
						|| this card
						*/
#define	IRSCFG_FINPACK		(1 << 13)	/* force card input
						|| acknowledge during I/O
						|| cycles.  Has no effect
						|| if no windows map to card
						*/
#define	IRSCFG_DELWR		(1 << 14)	/* force -all- data to
						|| meet 60ns setup time
						|| ("DELay WRite")
						*/
#define	IRSCFG_HD7IDE		(1 << 15)	/* Enable special IDE
						|| data register mode:  odd
						|| byte addresses in odd
						|| I/O windows will not
						|| drive HD7.
						*/

/***** bits in the second config register *****/
#define	IR_SCF2_S(skt)	(IR_SCFG_S(skt) + 2)	/* index to second config reg */
#define	IR_SCF2_S0	IR_SCF2_S(0)		/* second config for socket 0 */
#define	IR_SCF2_S1	IR_SCF2_S(1)		/* second config for socket 0 */

#define	IRSCF2_RI	(1 << 0)		/* enable RI pin from STSCHG 
						|| (2/N)
						*/
#define	IRSCF2_IDBR	(1 << 1)		/* force I/O data bus routing
						|| for this socket, regardless
						|| of cycle type. (2/N)
						*/
#define	IRSCF2_MDBR	(1 << 2)		/* force memory window data
						|| bus routing for this
						|| socket, regardless of cycle
						|| type. (2/N)
						*/
#define	IRSCF2_MLBAT1	(1 << 3)		/* disable status change
						|| ints from LBAT1 (or
						|| "STSCHG"
						*/
#define	IRSCF2_MLBAT2	(1 << 4)		/* disable status change
						|| ints from LBAT2 (or
						|| "SPKR"
						*/
#define	IRSCF2_MRDY	(1 << 5)		/* disable status change ints
						|| from RDY/BSY (or /IREQ).
						|| note that you get ints on
						|| both high- and low-going
						|| edges if this is enabled.
						*/
#define	IRSCF2_MWP	(1 << 6)		/* disable status-change ints
						|| from WP (or /IOIS16).
						|| If you're using status
						|| change ints, you better set
						|| this once an I/O window is
						|| enabled, before accessing
						|| it.
						*/
#define	IRSCF2_MCD	(1 << 7)		/* disable status-change ints
						|| from Card Detect.
						*/

/* 
|| note that these bits match the top 5 bits of the socket status register
|| in order and sense.
*/

#define	IRSCF2_DMASRC_MASK	(0x3 << 8)	/* mask for this bit field */
						/*-- DMA Source --*/
#define	  IRSCF2_DRQ_BVD2	(0x0 << 8)	/*     BVD2       */
#define   IRSCF2_DRQ_IOIS16	(0x1 << 8)	/*     IOIS16     */
#define   IRSCF2_DRQ_INPACK	(0x2 << 8)	/*     INPACK     */
#define   IRSCF2_DRQ_FORCE	(0x3 << 8)	/*     Force it   */

/*	reserved	(0xFC00) */		/* top 6 bits are RFU */


/****************************************************************************\
|
| The memory window control registers.
|
\****************************************************************************/

/*
|| The BASE ADDRESS register establishes a correspondence between
|| a host bus address and a particular memory window.
||
|| The MAP ADDRESS register establishes a correspondence between a
|| window and a particular card address.  The contents of this register
|| are ADDED to the address from the host, and (therefore) are not
|| independent of the value in the BASE ADDRESS register.  That is,
|| the value to put into the MAP ADDRESS register to map to page
|| 0 of common space is NOT (in general) 0; it is, rather, (-window
|| base address), in twos complement.
||
|| Of course, you must use the twos complement of the actual window
|| base, NOT of the value that's actually in the BASE ADDRESS register;
|| that value also has the window size encoded in it.
||
|| The window enable bit for a given window is automatically cleared whenever 
|| you write to the BASE ADDRESS register.
*/
/**** the base register ****/
#define	MBASE_ILV	(1 << 15)		/* rfu */
#define	MBASE_4K	(1 << MBASE_4K_BIT)	/* if set, addresses are 4K */
#define	  MBASE_4K_BIT	14			/*  (bit shift count) */
#define	MBASE_HA_SHFT	(12)			/* shift host addresses 
						|| right this much 
						*/
#define	MBASE_HA_MASK	(0xFFF)			/* mask for host address
						|| bits in this register
						*/
#define	MBASE_HA2BASE(ha)	\
	( \
	 ((USHORT) ((ha) >> MBASE_HA_SHFT) & MBASE_HA_MASK) \
	| \
	 (((USHORT) (ha) & (1 << 11)) << (MBASE_4K_BIT - 11)) \
	)

#define	MBASE_BASE2HA(base) \
	( \
	((ULONG) ((base) & MBASE_HA_MASK) << MBASE_HA_SHFT) \
	| \
	(((base) & MBASE_4K) >> (MBASE_4K_BIT - 11)) \
	)

/**** the card mapping register ****/
#define	MMAP_CA_SHFT	12		/* shift card address right this much */
#define	MMAP_CA_MASK	(0x3FFF)	/* then mask with this */
#define	MMAP_REG	(1 << 15)	/* the REG bit */

/**** the mem window control register ****/
#define	MCTL_WSCNT_MASK	0x1F		/* the wait-state mask register */
#define	MCTL_WSCNT_SHFT	0		/* how to align it */

/* reserved		(1<<5)		-- this bit is reserved */

#define	MCTL_QUIET	(1<<6)		/* the window is quiet */
#define	MCTL_WP		(1<<7)		/* prohibit writes via this window */
#define	MCTL_ACC	(1<<8)		/* if set, we've used this window */
#define	MCTL_KE		(1<<9)		/* enable caching on this window */
#define	MCTL_EDC	(1<<10)		/* enable EDC on this window */
#define	MCTL_B8		(1<<11)		/* force window to be 8 bits */
#define	MCTL_SS_SHFT	(TCIC_SS_SHFT)	/* socket select in standard place (bits 12-14) */
#define	MCTL_SS_MASK	(TCIC_SS_MASK)	/* ditto for mask */
#define	MCTL_ENA	(1<<15)		/* enable the window */

/**** the I/O base register ****/
/*
||  the base and length are encoded here, pretty much as they are for the
||  memory base register; however, a 17th bit is needed, and can be found
||  in the I/O window control register (IOCTL_TINY).
*/

/**** the I/O control register ****/
#define	ICTL_WSCNT_MASK	MCTL_WSCNT_MASK	/* these are the same */
#define	ICTL_WSCNT_SFHT	MCTL_WSCNT_SHFT	/* and are shown this way to ensure
					|| that you can use the same code to
					||generate them, if you like
					*/
#define	ICTL_PASS16	(1 << 5)	/* If this bit is set, then all 16
					|| bits of an I/O address will be
					|| passed through to the card, even
					|| if the window is only a 10-bit
					|| window.  If reset, then only 10
					|| bits will be passed if this is a
					|| 1K window, even if HA[15:10] were
					|| non-zero.  Regardless of the
					|| value of this bit, the 082 always
					|| acts as if this bit were clear.
					*/
#define	ICTL_QUIET	MCTL_QUIET	/* more commonality */
#define	ICTL_1K		(1 << 7)	/* ignore ha[15:10] in comparisons;
					|| this makes us 100% PC compatible.
					*/
#define	ICTL_ACC	MCTL_ACC	/* more commonality */
#define	ICTL_TINY	(1 << 9)	/* window is exactly 1 byte long */
#define	ICTL_B16	(1 << 10)	/* I/O mode stuff; force 16 bit, but
					|| also encodes stuff; see below.
					*/
#define	ICTL_B8		(MCTL_B8)

/* B8 and B16, taken together, define the bus width for this window: */
#define	  ICTL_BW_MASK	(ICTL_B8 | ICTL_B16)	/* the field itself. */
#define	  ICTL_BW_DYN	(0)			/* use CIOIS16 */
#define	  ICTL_BW_8	(ICTL_B8)		/* force 8-bit (no /HIOCS16) */
#define	  ICTL_BW_16	(ICTL_B16)		/* force 16-bit (force HIOCS16) */
#define	  ICTL_BW_ATA	(ICTL_B8|ICTL_B16)	/* ATA mode IOCS16 */

/* 

"ATA mode IOCS16" means that this window is to be used with an ATA/IDE-like
drive.  /HIOCS16 is asserted for references to addresses 0, 8, ...  within
the window; it is deasserted for all other addresses.

*/

/* socket is selected in the usual way, using the usual fields */
#define	ICTL_SS_SHFT	(TCIC_SS_SHFT)	/* the shift count for the socket 
					|| for this window (12) 
					*/
#define	ICTL_SS_MASK	(TCIC_SS_MASK)	/* the mask for the field (0x7000) */

#define	ICTL_ENA	(MCTL_ENA)	/* enable the window (same fn/same bit) */

/****************************************************************************\
|
|	The TCIC architecture V2.0 registers
|
\****************************************************************************/

#define	IR_ADPTCFG0	0x300		/* The primary adapter config register */
#define IRADPCF0_PNPCS	(1 << 0)	/* if set, using PnP to set base addr */
#define	IRADPCF0_MULTI	(1 << 1)	/* if set, NMULTI# functions are available */
#define	IRADPCF0_EE1K	(1 << 2)	/* if set, if EEPROM is present, it's 1K (max) */
#define	IRADPCF0_EE	(1 << 3)	/* if set, EE control is present */
#define	IRADPCF0_DRQ2	(1 << 4)	/* if set, DMA is possible */
#define	IRADPCF0_IRQ6	(1 << 5)	/* if set, IRQ6 is available */
#define	IRADPCF0_IRQ9	(1 << 6)	/* if set, IRQ9 is available */
#define	IRADPCF0_IRQ12	(1 << 7)	/* if set, IRQ12 is available */
#define	IRADPCF0_IRQ15	(1 << 8)	/* if set, IRQ15 is available */
#define	IRADPCF0_3V	(1 << 9)	/* if set, CVS & 3V/5V are enabled */
#define	IRADPCF0_BUSYLED (1 << 10)	/* if set, we have busy light(s) */
#define	IRADPCF0_BUSYSKT (1 << 11)	/* if set, busy lights are per skt */
#define	IRADPCF0_ILOCK	(1 << 12)	/* if set, we have interlocks */
#define	IRADPCF0_ILOCKSKT (1 << 13)	/* if set, ilocks are per-skt */
#define	IRADPCF0_NONSTD	(1 << 14)	/* if set, a hardware-specific driver
					|| is required.
					*/
#define	IRADPCF0_READY	(1 << 15)	/* if set, TCIC has finished power-up
					|| self configuration.
					*/

#define	IR_ROMCSR	0x320		/* the config ROM csr */
					
#define	IR_ROMCSR_ADDR_MASK	0xFF	/* the WORD address bits */
#define	IR_ROMCSR_CMD_SHFT	12	/* the ROM command bit offset */
#define	IR_ROMCSR_CMD_MASK	(3 << 12) 

#define	IR_ROMCSR_GO	(1 << 14)	/* set this bit to process a command */
#define	IR_ROMCSR_BUSY	(1 << 15)	/* r/o:  set while working */

/**** the READ command -- data shows up in PDATA ****/
#define	IR_ROMCSR_READCMD(a)	\
	((2 << IR_ROMCSR_CMD_SHFT) | \
	((a) & IR_ROMCSR_ADDR_MASK))

/**** the WRITE command ****/
#define	IR_ROMCSR_WRITECMD(a)	\
	((1 << IR_ROMCSR_CMD_SHFT) | \
	((a) & IR_ROMCSR_ADDR_MASK))

/**** the ERASE WORD command ****/
#define	IR_ROMCSR_ERASEWDCMD(a)	\
	((3 << IR_ROMCSR_CMD_SHFT) | \
	((a) & IR_ROMCSR_ADDR_MASK))

/**** the WRITE-ENABLE command ****/
#define	IR_ROMCSR_WRITEENA \
	((0 << IR_ROMCSR_CMD_SHFT) | \
	((0x03) & IR_ROMCSR_ADDR_MASK))

/**** the WRITE-DISABLE command ****/
#define	IR_ROMCSR_WRITEDSA \
	((0 << IR_ROMCSR_CMD_SHFT) | \
	((0x00) & IR_ROMCSR_ADDR_MASK))

/****************************************************************************\
|
|	The plug and play test registers 
|
\****************************************************************************/

#define	IR_PNPADDRP	0x380		/* PnP ISA:  read port, address port */
#define	IRPNPADDR_ADDR_MASK	0x00FF	/* the last value written to the 
					|| PnP address register.
					*/
#define	IRPNPADDR_ADDR_SHFT	0
#define	IRPNPADDR_RDP_MASK	0xFF00	/* the last value written to the read-
					|| data port-address PnP register.
					*/
#define	IRPNPADDR_RDP_SHFT	8	

/**** handy place to figure out CSN, LDN ****/
#define	IR_PNPCSNLDN	0x382		/* PnP ISA:  card seq no, log dev no */
#define	IRPNPCSN_LDN_MASK	0xFF00	/* the last value written to this
					|| chip's PnP logical dev # reg.
					*/
#define	IRPNPCSN_LDN_SHFT	8
#define	IRPNPCSN_CSN_MASK	0x00FF	/* the last value written to this
					|| chip's PnP CSN register.
					*/
#define	IRPNPCSN_CSN_SHFT	0	

/**** handy place to figure out chip ID ****/
#define	IR_PNPTEST	0x384		/* PnP ISA:  chip id */
#define	IRPNPTEST_CHIPID_MASK	0x00FF	/* the Chip ID captured during the last
					|| PnP wake-up seqeunce.
					*/
#define	IRPNPTEST_CHIPID_SHFT	0	
#define	IRPNPTEST_LSTCFGCTL_SHFT 8	/* the last value written to cfgctl */
#define	IRPNPTEST_LSTCFGCTL_MASK (7 << IRPNPTEST_LSTCFGCTL_SHFT)
#define	IRPNPTEST_ISO2ND	(1 << 11)
#define	IRPNPTEST_MTCH1ST	(1 << 12)
#define	IRPNPTEST_STATE_SHFT	13
#define	IRPNPTEST_STATE_MASK	(3 << IRPNPTEST_STATE_SHFT)
#define	IRPNPTEST_STATE_WFK	(0 << IRPNPTEST_STATE_SHFT)
#define IRPNPTEST_STATE_SLP	(1 << IRPNPTEST_STATE_SHFT)
#define	IRPNPTEST_STATE_ISO	(2 << IRPNPTEST_STATE_SHFT)
#define	IRPNPTEST_STATE_CFG	(3 << IRPNPTEST_STATE_SHFT)

/**** the following register lets us see what PNP software has done ****/
#define	IR_PNPCFG	0x386		/* PnP ISA:  configuration info */
#define	IRPNPCFG_IRQ_SHFT	0
#define	IRPNPCFG_IRQ_MASK	(0xF << IRPNPCFG_IRQ_SHFT)

#define	IRPNPCFG_IRQLVL		(1 << 4)	/* Level IRQ selected */
#define	IRPNPCFG_IRQHIGH	(1 << 5)	/* active high IRQ select */

#define	IRPNPCFG_DMA_SHFT	8
#define	IRPNPCFG_DMA_MASK	(7 << IRPNPCFG_DMA_SHFT)

/**** end of tcic2.h ****/
#endif /* _TCIC2_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\inc\extern.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    extern.h

Abstract:

    External definitions for intermodule functions.

Revision History:
    6-Apr-95
         Databook support added.
    2-Nov-96
         Overhaul for plug'n'play - Ravisankar Pudipeddi (ravisp)

--*/
#ifndef _PCMCIA_EXTERN_H_
#define _PCMCIA_EXTERN_H_

//
// Global data referenced by the driver
//
extern const DEVICE_DISPATCH_TABLE    DeviceDispatchTable[];
extern const PCMCIA_ID_ENTRY          PcmciaAdapterHardwareIds[];
extern const PCMCIA_CONTEXT_RANGE     DefaultPciContextSave[];
extern const PCMCIA_CONTEXT_RANGE     DefaultCardbusContextSave[];
extern const PCMCIA_CONTEXT_RANGE     ExcludeCardbusContextRange[];
extern const PCMCIA_REGISTER_INIT     PcicRegisterInitTable[];
extern const PCMCIA_DEVICE_CONFIG_PARAMS DeviceConfigParams[];
extern ULONG                          PcmciaGlobalFlags;
extern ULONG                          PcmciaDebugMask;
extern PDEVICE_OBJECT                 FdoList;

extern ULONG globalOverrideIrqMask;
extern ULONG globalFilterIrqMask;
extern ULONG globalAttributeMemoryLow;
extern ULONG globalAttributeMemoryHigh;
extern ULONG globalAttributeMemorySize;
extern ULONG initUsePolledCsc;
extern ULONG initDisableAcpiNameSpaceCheck;
extern ULONG initDefaultRouteR2ToIsa;
extern ULONG pcmciaDisableIsaPciRouting;
extern ULONG pcmciaIsaIrqRescanComplete;
extern ULONG pcmciaIrqRouteToPciController;
extern ULONG pcmciaIrqRouteToIsaController;
extern ULONG pcmciaIrqRouteToPciLocation;
extern ULONG pcmciaIrqRouteToIsaLocation;
extern ULONG pcmciaReportMTD0002AsError;
extern ULONG pcmciaIoctlInterface;

extern GLOBAL_REGISTRY_INFORMATION GlobalRegistryInfo[];
extern ULONG GlobalInfoCount;

extern const PCI_CONTROLLER_INFORMATION PciControllerInformation[];
extern const PCI_VENDOR_INFORMATION     PciVendorInformation[];
extern KEVENT                           PcmciaDelayTimerEvent;
extern KSPIN_LOCK PcmciaGlobalLock;
extern PPCMCIA_NTDETECT_DATA pNtDetectDataList;
extern ULONG EventDpcDelay;
extern ULONG PcmciaPowerPolicy;
extern LONG PcmciaControllerDeviceWake;

//
// Irp dispatch routines
//

VOID
PcmciaInitDeviceDispatchTable(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
PcmciaDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PcmciaFdoPnpDispatch(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    );

NTSTATUS
PcmciaPdoPnpDispatch(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    );

NTSTATUS
PcmciaPdoCardBusPnPDispatch(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    );

NTSTATUS
PcmciaFdoPowerDispatch(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    );

NTSTATUS
PcmciaPdoPowerDispatch(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    );

NTSTATUS
PcmciaOpenCloseDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PcmciaCleanupDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PcmciaDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PcmciaPdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PcmciaFdoSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PcmciaPdoSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// enumeration routines
//

NTSTATUS
PcmciaDeviceRelations(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );


//
// controller support routines
//

NTSTATUS
PcmciaAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT pdo
    );

NTSTATUS
PcmciaStartPcmciaController(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
PcmciaGetLegacyDetectedControllerType(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PPCMCIA_CONTROLLER_TYPE ControllerType
    );

NTSTATUS
PcmciaSetLegacyDetectedControllerType(
    IN PDEVICE_OBJECT Pdo,
    IN PCMCIA_CONTROLLER_TYPE ControllerType
    );

VOID
PcmciaSetControllerType(
    IN PFDO_EXTENSION FdoExtension,
    IN PCMCIA_CONTROLLER_TYPE ControllerType
    );

NTSTATUS
PcmciaInitializeController(
    IN PDEVICE_OBJECT Fdo
    );

VOID
PcmciaCleanupPdo(
    IN PDEVICE_OBJECT Pdo
    );

//
// Interface routines
//

NTSTATUS
PcmciaPdoQueryInterface(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP         Irp
    );

NTSTATUS
PcmciaGetInterface(
    IN PDEVICE_OBJECT Pdo,
    IN CONST GUID *pGuid,
    IN USHORT sizeofInterface,
    OUT PINTERFACE pInterface
    );

NTSTATUS
PcmciaGetSetPciConfigData(
    IN PDEVICE_OBJECT PciPdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    IN BOOLEAN Read
    );

NTSTATUS
PcmciaUpdateInterruptLine(
    IN PPDO_EXTENSION PdoExtension,
    IN PFDO_EXTENSION FdoExtension
    );

//
// Socket routines
//

VOID
PcmciaSocketPowerWorker(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
PcmciaRequestSocketPower(
    IN PPDO_EXTENSION PdoExtension,
    IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine
    );

NTSTATUS
PcmciaReleaseSocketPower(
    IN PPDO_EXTENSION PdoExtension,
    IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine
    );

NTSTATUS
PcmciaSetSocketPower(
    IN PSOCKET Socket,
    IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine,
    IN PVOID Context,
    IN BOOLEAN PowerOn
    );

VOID
PcmciaGetSocketStatus(
    IN PSOCKET Socket
    );

UCHAR
PcmciaReadCISChar(
    IN PPDO_EXTENSION PdoExtension,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG Offset
    );

NTSTATUS
PcmciaConfigureCardBusCard(
    IN PPDO_EXTENSION pdoExtension
    );

NTSTATUS
PcmciaConfigurePcCard(
    IN PPDO_EXTENSION pdoExtension,
    IN PPCMCIA_COMPLETION_ROUTINE ConfigCompletionRoutine
    );

VOID
PcmciaConfigurationWorker(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
PcmciaSocketDeconfigure(
    IN PSOCKET Socket
    );

NTSTATUS
PcmciaReadWriteCardMemory(
    IN PDEVICE_OBJECT Pdo,
    IN ULONG            WhichSpace,
    IN OUT PUCHAR       Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN BOOLEAN          Read
    );

NTSTATUS
PcmciaGetConfigData(
    IN PPDO_EXTENSION PdoExtension
    );

VOID
PcmciaCleanupCisCache(
    IN PSOCKET Socket
    );

BOOLEAN
PcmciaVerifyCardInSocket(
    IN PSOCKET Socket
    );

//
// Pnp id routines
//

NTSTATUS
PcmciaGetDeviceId(
    IN  PDEVICE_OBJECT  Pdo,
    IN  ULONG             FunctionNumber,
    OUT PUNICODE_STRING DeviceId
    );

NTSTATUS
PcmciaGetHardwareIds(
    IN  PDEVICE_OBJECT  Pdo,
    IN  ULONG             FunctionNumber,
    OUT PUNICODE_STRING HardwareIds
    );

NTSTATUS
PcmciaGetCompatibleIds(
    IN  PDEVICE_OBJECT  Pdo,
    IN  ULONG             FunctionNumber,
    OUT PUNICODE_STRING CompatibleIds
    );

NTSTATUS
PcmciaGetInstanceId(
    IN PDEVICE_OBJECT   Pdo,
    OUT PUNICODE_STRING InstanceId
    );

NTSTATUS
PcmciaStringsToMultiString(
    IN PCSTR * Strings,
    IN ULONG Count,
    IN PUNICODE_STRING MultiString
    );

//
// Registry routines
//

NTSTATUS
PcmciaLoadGlobalRegistryValues(
    VOID
    );

NTSTATUS
PcmciaGetControllerRegistrySettings(
    IN OUT PFDO_EXTENSION FdoExtension
    );

VOID
PcmciaGetRegistryFdoIrqMask(
    IN OUT PFDO_EXTENSION FdoExtension
    );

//
// Intel PCIC (82365SL) and compatible routines.
//

NTSTATUS
PcicBuildSocketList(
    IN PFDO_EXTENSION FdoExtension
    );

UCHAR
PcicReadSocket(
    IN PSOCKET Socket,
    IN ULONG   Register
    );

VOID
PcicWriteSocket(
    IN PSOCKET Socket,
    IN ULONG   Register,
    IN UCHAR  DataByte
    );

NTSTATUS
PcicIsaDetect(
    IN PFDO_EXTENSION DeviceExtension
    );

NTSTATUS
PcicSetPower(
    IN PSOCKET Socket,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    );

//
// Utility routines for pcmcia work.
//

NTSTATUS
PcmciaIoCallDriverSynchronous(
    PDEVICE_OBJECT deviceObject,
    PIRP Irp
    );

VOID
PcmciaWait(
    IN ULONG MilliSeconds
    );

VOID
PcmciaLogError(
    IN PFDO_EXTENSION DeviceExtension,
    IN ULONG ErrorCode,
    IN ULONG UniqueId,
    IN ULONG Argument
    );

VOID
PcmciaLogErrorWithStrings(
    IN PFDO_EXTENSION DeviceExtension,
    IN ULONG                ErrorCode,
    IN ULONG                UniqueId,
    IN PUNICODE_STRING  String1,
    IN PUNICODE_STRING  String2
    );

BOOLEAN
PcmciaReportControllerError(
    IN PFDO_EXTENSION FdoExtension,
    NTSTATUS ErrorCode
    );

ULONG
PcmciaCountOnes(
    IN ULONG Data
    );


//
// Power management routines

NTSTATUS
PcmciaFdoArmForWake(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
PcmciaFdoDisarmWake(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
PcmciaPdoWaitWakeCompletion(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP             Irp,
    IN PPDO_EXTENSION PdoExtension
    );

NTSTATUS
PcmciaSetPdoDevicePowerState(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    );

VOID
PcmciaPdoPowerWorkerDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
PcmciaFdoRetryPdoPowerRequest(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
PcmciaFdoPowerWorkerDpc(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
PcmciaFdoCheckForIdle(
    IN PFDO_EXTENSION FdoExtension
    );

//
//
// Tuple processing routines.
//

NTSTATUS
PcmciaParseFunctionData(
    IN PSOCKET        Socket,
    IN PSOCKET_DATA  SocketData
    );

NTSTATUS
PcmciaParseFunctionDataForID(
    IN PSOCKET_DATA  SocketData
    );

VOID
PcmciaFilterTupleData(
    IN PPDO_EXTENSION PdoExtension
    );

//
// General detection and support.
//

NTSTATUS
PcmciaDetectPcmciaControllers(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

BOOLEAN
PcmciaLegacyDetectionOk(
    VOID
    );

//
// Databook TCIC2 and compatible routines.
//

NTSTATUS
TcicBuildSocketList(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
TcicDetect(
    IN PFDO_EXTENSION DeviceExtension
    );

VOID
TcicGetControllerProperties (
    IN PSOCKET socketPtr,
    IN PUSHORT pIoPortBase,
    IN PUSHORT pIoPortSize
    );

NTSTATUS
TcicSetPower(
    IN PSOCKET Socket,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    );


//
// Cardbus support routines
//

NTSTATUS
CBBuildSocketList(
    IN PFDO_EXTENSION FdoExtension
    );

ULONG
CBReadSocketRegister(
    IN PSOCKET Socket,
    IN UCHAR Register
    );

VOID
CBWriteSocketRegister(
    IN PSOCKET Socket,
    IN UCHAR Register,
    IN ULONG Data
    );

BOOLEAN
CBEnableDeviceInterruptRouting(
    IN PSOCKET Socket
    );

VOID
CBIssueCvsTest(
    IN PSOCKET Socket
    );

//
// Cardbus vendor specific exports
//

VOID
TIInitialize(
    IN PFDO_EXTENSION FdoExtension
    );

BOOLEAN
TISetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    );

BOOLEAN
TISetWindowPage(
    IN PSOCKET Socket,
    USHORT Index,
    UCHAR Page
    );

VOID
CLInitialize(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
CLSetPower(
    IN PSOCKET Socket,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    );

BOOLEAN
CLSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    );

VOID
RicohInitialize(
    IN PFDO_EXTENSION FdoExtension
    );

BOOLEAN
RicohSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    );

VOID
OptiInitialize(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
OptiSetPower(
    IN PSOCKET Socket,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    );

BOOLEAN
OptiSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    );

VOID
TopicInitialize(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
TopicSetPower(
    IN PSOCKET Socket,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    );

VOID
TopicSetAudio(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    );

BOOLEAN
TopicSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    );

VOID
O2MInitialize(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
O2MSetPower(
    IN PSOCKET Socket,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    );

BOOLEAN
O2MSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    );

VOID
DBInitialize(
    IN PFDO_EXTENSION FdoExtension
    );

BOOLEAN
DBSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    );

BOOLEAN
TridSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    );

NTSTATUS
CBSetPower(
    IN PSOCKET Socket,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    );

BOOLEAN
CBSetWindowPage(
    IN PSOCKET Socket,
    USHORT Index,
    UCHAR Page
    );

#endif // _PCMCIA_EXTERN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\inc\pcmcia.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    pcmcia.h

Abstract:

Revision History
    27-Apr-95
         Databook support added.
    1-Nov-96
         Complete overhaul to make this a bus enumerator +
         CardBus support
                       - Ravisankar Pudipeddi (ravisp)
--*/

#ifndef _PCMCIAPRT_
#define _PCMCIAPRT_

#define MAX_NUMBER_OF_IO_RANGES     2
#define MAX_NUMBER_OF_MEMORY_RANGES 4

#define MAX_MANFID_LENGTH    64
#define MAX_IDENT_LENGTH     64


//
// Function number for a multi-function pc-card
//
#define PCMCIA_MULTIFUNCTION_PARENT     0xFFFFFFFF

typedef enum _DEVICE_OBJECT_TYPE {
    FDO = 0,
    PDO
} DEVICE_OBJECT_TYPE;

//
// Type of the controller
//
typedef ULONG PCMCIA_CONTROLLER_TYPE, *PPCMCIA_CONTROLLER_TYPE;

struct _SOCKET;                              //forward references
struct _FDO_EXTENSION;
struct _PDO_EXTENSION;

//
// Define SynchronizeExecution routine.
//

typedef
BOOLEAN
(*PSYNCHRONIZATION_ROUTINE) (
    IN PKINTERRUPT           Interrupt,
    IN PKSYNCHRONIZE_ROUTINE Routine,
    IN PVOID                     SynchronizeContext
    );

//
// Define the Pcmcia controller detection routine
//

typedef
NTSTATUS
(*PPCMCIA_DETECT_ROUTINE) (
    struct _FDO_EXTENSION  *DeviceExtension
    );

//
// Completion routine called by various timed routines
//

typedef
VOID
(*PPCMCIA_COMPLETION_ROUTINE) (
    IN PVOID Context,
    IN NTSTATUS status
    );

//
// Register context structure used to save register contents
// when cardbus controllers are powered down..
//
typedef struct _PCMCIA_CONTEXT_RANGE {
    USHORT wOffset;
    USHORT wLen;
} PCMCIA_CONTEXT_RANGE, *PPCMCIA_CONTEXT_RANGE;

typedef struct _PCMCIA_CONTEXT {
    PPCMCIA_CONTEXT_RANGE Range;
    ULONG                    RangeCount;
    ULONG                    BufferLength;
    ULONG                    MaxLen;
} PCMCIA_CONTEXT, *PPCMCIA_CONTEXT;

//
// Configuration entry parsed from CISTPL_CFTABLE_ENTRY
// on a pc-card. Indicates what kind of resource configurations
// the pc-card supports
//
typedef struct _CONFIG_ENTRY {
    struct _CONFIG_ENTRY *NextEntry;
    USHORT                   NumberOfIoPortRanges;
    USHORT                   NumberOfMemoryRanges;
    USHORT                   IoPortBase[MAX_NUMBER_OF_IO_RANGES];
    USHORT                   IoPortLength[MAX_NUMBER_OF_IO_RANGES];
    USHORT                   IoPortAlignment[MAX_NUMBER_OF_IO_RANGES];
    ULONG                    MemoryHostBase[MAX_NUMBER_OF_MEMORY_RANGES];
    ULONG                    MemoryCardBase[MAX_NUMBER_OF_MEMORY_RANGES];
    ULONG                    MemoryLength[MAX_NUMBER_OF_MEMORY_RANGES];
    USHORT                   IrqMask;

    //
    // Only one flag used now. Expect to have more in future..
    //
#define PCMCIA_INVALID_CONFIGURATION     0x00000001
    USHORT                   Flags;

    //
    // Level or Edge triggered IRQ
    //
    UCHAR                    LevelIrq;
    //
    // Share disp.for the IRQ
    //
    UCHAR                    ShareDisposition;
    UCHAR                    IndexForThisConfiguration;
    //
    // Indicates if the i/o requirement supports 16-bit access
    //
    BOOLEAN                  Io16BitAccess;
    //
    // Indicates if the i/o requirement supports 8-bit access
    // At least one of Io8BitAccess and Io16BitAccess must always
    // be true for a valid configuration
    //
    BOOLEAN                  Io8BitAccess;
} CONFIG_ENTRY, *PCONFIG_ENTRY;

//
// Function configuration holds the data that goes in each functions's
// configuration registers
//

typedef struct _FUNCTION_CONFIGURATION {
    struct _FUNCTION_CONFIGURATION *Next;
    ULONG   ConfigRegisterBase;
    UCHAR   ConfigOptions;
    UCHAR   ConfigFlags;
    UCHAR   IoLimit;
    UCHAR   Reserved;
    ULONG   IoBase;
} FUNCTION_CONFIGURATION, *PFUNCTION_CONFIGURATION;

//
// Socket configuration is the holder of the actual controller setup
//

typedef struct _SOCKET_CONFIGURATION {
    //
    // Device irq assigned
    //
    ULONG   Irq;
    //
    // Optional Irq to indicate when card is ready
    //
    ULONG   ReadyIrq;
    ULONG   ConfigRegisterBase;

    ULONG   NumberOfIoPortRanges;

    struct _SOCKET_CONFIG_IO_ENTRY {
        ULONG Base;
        USHORT Length;
        BOOLEAN Width16;
        BOOLEAN WaitState16;
        BOOLEAN Source16;
        BOOLEAN ZeroWait8;
    } Io[MAX_NUMBER_OF_IO_RANGES];

    ULONG   NumberOfMemoryRanges;

    struct _SOCKET_CONFIG_MEM_ENTRY {
        ULONG HostBase;
        ULONG CardBase;
        ULONG Length;
        UCHAR IsAttribute;
        UCHAR WaitState;
        BOOLEAN Width16;
    } Memory[MAX_NUMBER_OF_MEMORY_RANGES];

    PFUNCTION_CONFIGURATION FunctionConfiguration;
    UCHAR   IndexForCurrentConfiguration;
} SOCKET_CONFIGURATION, *PSOCKET_CONFIGURATION;


//
// Each function on a PCCARD present gets socket data.  Socket data
// contains information concerning the function and its configuration.
//

typedef struct _SOCKET_DATA {
    //
    // Multi function pcards: links to
    // other socket-datas' off the same PC-Card
    //
    struct _SOCKET_DATA  *Next;
    struct _SOCKET_DATA  *Prev;

    struct _SOCKET       *Socket;
    //
    // Pointer to the pdo's extension corresponding
    // to this socket
    //
    struct _PDO_EXTENSION *PdoExtension;


    UCHAR           Mfg[MAX_MANFID_LENGTH];
    UCHAR           Ident[MAX_IDENT_LENGTH];
    USHORT          ManufacturerCode;
    USHORT          ManufacturerInfo;

    ULONG           ConfigRegisterBase; // Base address from config tuple.

    //
    // Number of configurations possible
    //
    ULONG           NumberOfConfigEntries;
    //
    // Pointer to head of list of configurations
    //
    PCONFIG_ENTRY   ConfigEntryChain;               // Offset 0x114
    //
    // CRC calculated from the relevant tuples, used in
    // constructing hardware ids
    //
    USHORT          CisCrc;
    //
    // Device Type: PCCARD_TYPE_xxxx
    //
    UCHAR           DeviceType;
    UCHAR           LastEntryInCardConfig;
    //
    // Voltage values requested
    //
    UCHAR           Vcc;
    UCHAR           Vpp1;
    UCHAR           Vpp2;
    UCHAR           Audio;

    UCHAR           RegistersPresentMask[16];
    //
    // Configuration entry number used when actually
    // starting the pc-card
    //
    UCHAR           ConfigIndexUsed;
    //
    // Number of function in a multifunction card - zero-based
    //
    UCHAR           Function;
    UCHAR           Flags;
    //
    // Pointer to the default configuration among the list of config entries
    // which will be used when the default bit is zero in a tuple (and
    // set when the default bit is one)
    //
    PCONFIG_ENTRY   DefaultConfiguration;

    ULONG           Instance;
    USHORT          JedecId;
    //
    // Resource map indices for the requested resources in the
    // merged multifunction resource requirements list
    //
    UCHAR           MfIrqResourceMapIndex;
    UCHAR           MfIoPortResourceMapIndex;
    UCHAR           MfMemoryResourceMapIndex;
    BOOLEAN         MfNeedsIrq;
    USHORT          MfIoPortCount;
    USHORT          MfMemoryCount;
} SOCKET_DATA, *PSOCKET_DATA;

//
// Bits defined in Flags field
//
#define SDF_ZV      1                                   // Zoom video custom interface
#define SDF_JEDEC_ID 2

#define IsConfigRegisterPresent(xSocketData, reg) ((((xSocketData)->RegistersPresentMask[reg / 8] &          \
                                                                                                             (1 << (reg % 8)) )) ?       \
                                                                                                                                TRUE:FALSE)

//
// Config list is an array used in translating CONFIG_ENTRY data to
// IO_RESOURCE_LISTs
//

typedef struct _CONFIG_LIST {

    PSOCKET_DATA SocketData;
    PCONFIG_ENTRY ConfigEntry;

} CONFIG_LIST, * PCONFIG_LIST;

//
// PCMCIA configuration information structure contains information
// about the PCMCIA controller attached and its configuration.
//

typedef struct _PCMCIA_CONFIGURATION_INFORMATION {
    INTERFACE_TYPE                       InterfaceType;
    ULONG                                BusNumber;
    ULONG                                SlotNumber;
    PHYSICAL_ADDRESS                     PortAddress;
    USHORT                               PortSize;
    USHORT                               UntranslatedPortAddress;
    //
    // Card status change interrupt: these fields are used only
    // for cardbus controllers.
    //
    CM_PARTIAL_RESOURCE_DESCRIPTOR Interrupt;
    CM_PARTIAL_RESOURCE_DESCRIPTOR TranslatedInterrupt;
    //
    // For PCI-based controllers, indicates the pin number which we need
    // for programming the controller interrupt.
    // NOTE: This is no longer needed (this was to handle CSC interrupts
    // for PCI-PCMCIA bridges (like CL PD6729). We no longer support interrupt
    // based card status change for these cntrollers. Get rid of it
    // whenever possible.
    //
    UCHAR                                InterruptPin;
    //
    // Another dead field. Legacy.
    //
    BOOLEAN                              FloatingSave;
    USHORT                               Reserved;    // Alignment
} PCMCIA_CONFIGURATION_INFORMATION, *PPCMCIA_CONFIGURATION_INFORMATION;

//
// PCMCIA_CTRL_BLOCK allows for a level of indirection, thereby allowing
// the top-level PCMCIA code to do it's work without worrying about who's
// particular brand of PCMCIA controller it's addressing.
//
// Note that this only implements TWO architectures, pcic and tcic. For
// more indirection, see DEVICE_DISPATCH_TABLE


typedef struct _PCMCIA_CTRL_BLOCK {

    //
    // Function to initialize the socket
    //

    BOOLEAN (*PCBInitializePcmciaSocket)(
        IN struct _SOCKET *Socket
        );

    //
    // Function to initialize the card in the socket.
    //

    NTSTATUS
    (*PCBResetCard)(
        IN struct _SOCKET *Socket,
        OUT PULONG pDelayTime
        );

    //
    // Function to determine if a card is in the socket
    //

    BOOLEAN (*PCBDetectCardInSocket)(
        IN struct _SOCKET *Socket
        );

    //
    // Function to determine if insertion status has changed.
    //

    BOOLEAN (*PCBDetectCardChanged)(
        IN struct _SOCKET *Socket
        );

    //
    // Function to determine if card status has been asserted.
    //

    BOOLEAN (*PCBDetectCardStatus)(
        IN struct _SOCKET *Socket
        );

    //
    // Function to determine if "card ready" status has changed
    //

    BOOLEAN (*PCBDetectReadyChanged)(
        IN struct _SOCKET *Socket
        );

    //
    // Function which requests that the controller be examined to
    // determine what power settings the current device in the socket
    // requires.
    //

    NTSTATUS
    (*PCBGetPowerRequirements)(
        IN struct _SOCKET *Socket
        );

    //
    // Function to configure cards.
    //

    BOOLEAN (*PCBProcessConfigureRequest)(
        IN struct _SOCKET *Socket,
        IN struct _CARD_REQUEST *ConfigRequest,
        IN PUCHAR            Base
        );

    //
    // Function to enable/disable status change interrupts
    //

    BOOLEAN (*PCBEnableDisableCardDetectEvent)(
        IN struct _SOCKET *Socket,
        IN BOOLEAN           Enable
        );

    //
    // Function to set/reset the ring enable bit  for the given
    // socket. Setting Ring Enable would cause the CSC to be used
    // as a wakeup event for pc-card modems/netcards etc.
    //

    VOID (*PCBEnableDisableWakeupEvent) (
        IN  struct _SOCKET *SocketPtr,
        IN struct _PDO_EXTENSION *PdoExtension,
        IN  BOOLEAN Enable
        );

    //
    // Function to return the set of IRQs supported
    // by the controller
    //
    ULONG (*PCBGetIrqMask) (
        IN struct _FDO_EXTENSION *DeviceExtension
        );

    //
    // Function to read the memory contents (attribute/common)
    // on the given PC-Card
    //
    ULONG (*PCBReadCardMemory) (
        IN struct _PDO_EXTENSION *PdoExtension,
        IN MEMORY_SPACE MemorySpace,
        IN ULONG  Offset,
        IN PUCHAR Buffer,
        IN ULONG  Length
        );

    //
    // Function to write to the attribute/common memory of
    // the given PC-Card
    //
    ULONG (*PCBWriteCardMemory) (
        IN struct _PDO_EXTENSION *PdoExtension,
        IN  MEMORY_SPACE MemorySpace,
        IN  ULONG  Offset,
        IN  PUCHAR Buffer,
        IN  ULONG  Length
        );

    //
    // Flash memory card interfaces:
    //
    //
    // Function to slide the host memory window on a pc-card
    //
    PPCMCIA_MODIFY_MEMORY_WINDOW PCBModifyMemoryWindow;
    //
    // Function to set the Vpp to the supplied value
    //
    PPCMCIA_SET_VPP               PCBSetVpp;
    //
    // Function to test if the given card is write protected
    //
    PPCMCIA_IS_WRITE_PROTECTED   PCBIsWriteProtected;

}PCMCIA_CTRL_BLOCK, *PPCMCIA_CTRL_BLOCK;

//
// Each socket on the PCMCIA controller has a socket structure
// to contain current information on the state of the socket and
// and PCCARD inserted.
//

#define IsSocketFlagSet(Socket, Flag)           (((Socket)->Flags & (Flag))?TRUE:FALSE)
#define SetSocketFlag(Socket, Flag)             ((Socket)->Flags |= (Flag))
#define ResetSocketFlag(Socket,Flag)            ((Socket)->Flags &= ~(Flag))

//
// Socket flags
//
#define SOCKET_CARD_INITIALIZED         0x00000002
#define SOCKET_CARD_POWERED_UP          0x00000004
#define SOCKET_CARD_CONFIGURED          0x00000008
#define SOCKET_CARD_MULTIFUNCTION       0x00000010
#define SOCKET_CARD_MEMORY              0x00000040
#define SOCKET_CHANGE_INTERRUPT         0x00000080
#define SOCKET_CUSTOM_INTERFACE         0x00000100
#define SOCKET_SUPPORT_MESSAGE_SENT     0x00000800
#define SOCKET_MEMORY_WINDOW_ENABLED    0x00001000
#define SOCKET_CARD_STATUS_CHANGE       0x00002000
#define SOCKET_ENUMERATE_PENDING        0x00008000
#define SOCKET_CLEANUP_PENDING          0x00010000
#define SOCKET_CB_ROUTE_R2_TO_PCI       0x00020000
#define SOCKET_POWER_PREFER_3V          0x00040000
#define SOCKET_ENABLED_FOR_CARD_DETECT 0x00080000
#define SOCKET_DEVICE_HIDDEN                0x00100000

#define SOCKET_CLEANUP_MASK (SOCKET_CARD_CONFIGURED | SOCKET_CLEANUP_PENDING)

//
// Socket insertion states
//
#define SKT_Empty                       0
#define SKT_CardBusCard                 1
#define SKT_R2Card                      2

//
// Worker states for socket power operations
//
typedef enum _SPW_STATE {
    SPW_Stopped = 0,
    SPW_Exit,
    SPW_RequestPower,
    SPW_ReleasePower,
    SPW_SetPowerOn,
    SPW_SetPowerOff,
    SPW_ResetCard,
    SPW_Deconfigure
} SPW_STATE;


#define PCMCIA_SOCKET_SIGNATURE                 'SmcP'

//
// Socket structure
//

typedef struct _SOCKET {
    ULONG                       Signature;

    struct _SOCKET              *NextSocket;
    //
    // Pointer to the pdo for the pc-card in this socket. This is a linked
    // list running through "NextPdoInSocket" in the pdo extension. This list
    // represents the functions that are physically contained within a socket.
    //
    PDEVICE_OBJECT              PdoList;
    //
    // Parent pcmcia controller's fdo extension of this socket
    //
    struct _FDO_EXTENSION       *DeviceExtension;
    //
    // Pointer to the miniport-like
    //
    PPCMCIA_CTRL_BLOCK          SocketFnPtr;
    //
    // Flags prefixed SOCKET_ defined above
    //
    ULONG                       Flags;
    //
    // For 16-bit cards we use the i/o address port to read/write
    // to the socket registers
    // For cardbus cards, we use the CardBus socket register base
    //
    PUCHAR                      AddressPort;

    KEVENT                      PCCardReadyEvent;
    BOOLEAN                     ReadyChanged;
    //
    // Voltage values requested
    //
    UCHAR                       Vcc;
    UCHAR                       Vpp1;
    UCHAR                       Vpp2;
    //
    // Socket states
    //
    UCHAR                       DeviceState;
    UCHAR                       Reserved0;
    //
    // For PCIC controllers: register offset of the socket
    //
    USHORT                      RegisterOffset;
    //
    // PCIC revision
    //
    UCHAR                       Revision;
    //
    // PCIC controllers: zero-based number of the socket
    //
    UCHAR                       SocketNumber;
    //
    // Indicates the number of functions this pc-card has
    // (this will be > 1 only for multifunction cards like modem/net combos)
    //
    UCHAR                       NumberOfFunctions;
    //
    // Current memory window used internally for reading attributes
    //
    UCHAR                       CurrentMemWindow;

    //
    // Timer and DPC objects to handle socket power and initialization
    //
    KTIMER                      PowerTimer;
    KDPC                        PowerDpc;
    //
    // Function and parameter to call at the end of power operation
    //
    PPCMCIA_COMPLETION_ROUTINE  PowerCompletionRoutine;
    PVOID                       PowerCompletionContext;
    NTSTATUS                    CallerStatus;
    NTSTATUS                    DeferredStatus;
    LONG                        DeferredStatusLock;
    //
    // Phase variables control state machine for socket power
    //
    LONG                        WorkerBusy;
    SPW_STATE                   WorkerState;
    UCHAR                       PowerPhase;
    UCHAR                       CardResetPhase;

    UCHAR                       Reserved;
    //
    // PowerData is temporary storage for power "miniports"
    //
    ULONG                       PowerData;
    //
    // semaphore to count # of functions requesting power on this socket
    //
    LONG                        PowerRequests;
    //
    // Context buffers
    //
    PUCHAR                      CardbusContextBuffer;
    PUCHAR                      ExcaContextBuffer;
    //
    // Current IRQ routing settings on socket
    //
    ULONG                       IrqMask;
    ULONG                       FdoIrq;
} SOCKET, *PSOCKET;



//
// Lock used for synhing access to device(pcmcia controller registers etc.)
// If the definition for this changes, the following 3 defs for
// acquiring/releasing the locks also may need to change
//
typedef struct _PCMCIA_DEVICE_LOCK {

    KSPIN_LOCK  Lock;
    KIRQL       Irql;

} PCMCIA_DEVICE_LOCK, * PPCMCIA_DEVICE_LOCK;

#define PCMCIA_INITIALIZE_DEVICE_LOCK(X)                KeInitializeSpinLock(&(X)->DeviceLock.Lock)
#define PCMCIA_ACQUIRE_DEVICE_LOCK(X)                   KeAcquireSpinLock(&(X)->DeviceLock.Lock, &(X)->DeviceLock.Irql)
#define PCMCIA_ACQUIRE_DEVICE_LOCK_AT_DPC_LEVEL(X)      KeAcquireSpinLockAtDpcLevel(&(X)->DeviceLock.Lock)
#define PCMCIA_RELEASE_DEVICE_LOCK(X)                   KeReleaseSpinLock(&(X)->DeviceLock.Lock, (X)->DeviceLock.Irql)
#define PCMCIA_RELEASE_DEVICE_LOCK_FROM_DPC_LEVEL(X)    KeReleaseSpinLockFromDpcLevel(&(X)->DeviceLock.Lock)

#define PCMCIA_TEST_AND_SET(X)  (InterlockedCompareExchange(X, 1, 0) == 0)
#define PCMCIA_TEST_AND_RESET(X) (InterlockedCompareExchange(X, 0, 1) == 1)

//
// Wait-Wake states
//
typedef enum {
    WAKESTATE_DISARMED,
    WAKESTATE_WAITING,
    WAKESTATE_WAITING_CANCELLED,
    WAKESTATE_ARMED,
    WAKESTATE_ARMING_CANCELLED,
    WAKESTATE_COMPLETING
} WAKESTATE;

//
// Power Policy Flags
//

#define PCMCIA_PP_WAKE_FROM_D0                  0x00000001
#define PCMCIA_PP_D3_ON_IDLE                    0x00000002

//
// Functional Device Object's device extension information
//
// There is one device object for each PCMCIA socket controller
// located in the system.   This contains the root pointers for
// each of the lists of information on this controller.
//

//
// Flags common to both fdoExtension and pdoExtension
//

#define PCMCIA_DEVICE_STARTED                   0x00000001
#define PCMCIA_DEVICE_LOGICALLY_REMOVED         0x00000002
#define PCMCIA_DEVICE_PHYSICALLY_REMOVED        0x00000004
#define PCMCIA_DEVICE_DELETED                   0x00000040
#define PCMCIA_DEVICE_CARDBUS                   0x00000080

//
// Flags indicating controller state (fdoExtension)
//

#define PCMCIA_DEVICE_LEGACY_DETECTED           0x00000020
#define PCMCIA_FILTER_ADDED_MEMORY              0x00000100
#define PCMCIA_MEMORY_24BIT                     0x00000200
#define PCMCIA_CARDBUS_NOT_SUPPORTED            0x00000400
#define PCMCIA_USE_POLLED_CSC                   0x00000800
#define PCMCIA_ATTRIBUTE_MEMORY_MAPPED          0x00001000
#define PCMCIA_SOCKET_REGISTER_BASE_MAPPED      0x00002000
#define PCMCIA_INTMODE_COMPAQ                   0x00004000
#define PCMCIA_INT_ROUTE_INTERFACE              0x00080000
#define PCMCIA_FDO_CONTEXT_SAVED                0x00100000
#define PCMCIA_FDO_OFFLINE                      0x00800000
#define PCMCIA_FDO_ON_DEBUG_PATH                0x01000000
#define PCMCIA_FDO_DISABLE_AUTO_POWEROFF        0x02000000
#define PCMCIA_FDO_PREFER_3V                    0x04000000
#define PCMCIA_FDO_IOCTL_INTERFACE_ENABLED      0x08000000

//
// FDO Flags
//

#define PCMCIA_FDO_IRQ_DETECT_DEVICE_FOUND      0x00000001
#define PCMCIA_FDO_IRQ_DETECT_COMPLETED         0x00000002
#define PCMCIA_FDO_IN_ACPI_NAMESPACE            0x00000004

#define PCMCIA_FDO_FORCE_PCI_ROUTING            0x00000010
#define PCMCIA_FDO_PREFER_PCI_ROUTING           0x00000020
#define PCMCIA_FDO_FORCE_ISA_ROUTING            0x00000040
#define PCMCIA_FDO_PREFER_ISA_ROUTING           0x00000080

#define PCMCIA_FDO_WAKE_BY_CD                   0x00000100

//
// states for FdoPowerWorker
//

typedef enum _FDO_POWER_WORKER_STATE {
    FPW_Stopped = 0,
    FPW_BeginPowerDown,
    FPW_PowerDown,
    FPW_PowerDownSocket,
    FPW_PowerDownComplete,
    FPW_BeginPowerUp,
    FPW_PowerUp,
    FPW_PowerUpSocket,
    FPW_PowerUpSocket2,
    FPW_PowerUpSocketVerify,
    FPW_PowerUpSocketComplete,
    FPW_PowerUpComplete,
    FPW_SendIrpDown,
    FPW_CompleteIrp
} FDO_POWER_WORKER_STATE;

#define FPW_END_SEQUENCE 128

#define PCMCIA_FDO_EXTENSION_SIGNATURE      'FmcP'

//
// Device extension for the functional device object for pcmcia controllers
//
typedef struct _FDO_EXTENSION {
    ULONG                                   Signature;
    //
    // Pointer to the next pcmcia controller's FDO in the central list
    // of all pcmcia controller managed by this driver.
    // The head of the list is pointed to by the global variable FdoList
    //
    PDEVICE_OBJECT                          NextFdo;
    //
    // The PDO ejected by the parent bus driver for this pcmcia controller
    //
    //
    PDEVICE_OBJECT                          Pdo;
    //
    // The immediately lower device attached beneath the pcmcia controller's FDO.
    // This would be the same as the Pdo above, excepting in cases when there are
    // lower filter drivers for the pcmcia controller - like the ACPI driver
    //
    PDEVICE_OBJECT                          LowerDevice;
    //
    // Pointer to the list of sockets which hang off this pcmcia controller
    //
    PSOCKET                                 SocketList;
    //
    // Various flags used to track the state of this
    // (flags prefixed by PCMCIA_ above)
    //
    ULONG                                   Flags;
    //
    // FDO specific flags
    //
    ULONG                                   FdoFlags;
    //
    // Bus numbering for PCI devices
    //
    UCHAR                                   PciBusNumber;
    UCHAR                                   PciDeviceNumber;
    UCHAR                                   PciFunctionNumber;
    UCHAR                                   reserved;
    //
    // Type of the controller. We need to know this since this is
    // a monolithic driver. We can do controller specific stuff
    // based on the type if needed.
    //
    PCMCIA_CONTROLLER_TYPE                  ControllerType;
    //
    // Index into the device dispatch table for vendor-specific
    // controller functions
    //
    ULONG                                   DeviceDispatchIndex;

    PDEVICE_OBJECT                          DeviceObject;
    PDRIVER_OBJECT                          DriverObject;
    PUNICODE_STRING                         RegistryPath;
    //
    // Symbolic link name exported for this pcmcia controller
    //
    UNICODE_STRING                          LinkName;
    //
    // Head of the list of child pc-card PDO's hanging off this controller.
    // This is a linked list running through "NextPdoInFdoChain" in the pdo
    // extension. This list represents the devices that were enumerated by
    // the fdo.
    //
    PDEVICE_OBJECT                          PdoList;
    //
    // Keeps track of the number of PDOs which are actually
    // valid (not removed).  This is primarily used in
    // enumeration of the pcmcia controller upon an IRP_MN_QUERY_DEVICE_RELATIONS
    //
    ULONG                                   LivePdoCount;
    //
    // Lock for synching device access
    //
    PCMCIA_DEVICE_LOCK                      DeviceLock;

    //
    // Card status change poll related structures
    //
    //
    // Dpc which periodically polls to see if card has been inserted or removed
    //
    KDPC                                    TimerDpc;
    //
    // The PollTimer object which is initialized and triggered if a Card Status change
    // interrupt is not used & we resort to polling..
    //
    KTIMER                                  PollTimer;
    //
    // Kernel objects to defer power up initialization of controller
    //
    KTIMER                                  PowerTimer;
    KDPC                                    PowerDpc;
    //
    // Kernel objects to handle controller events
    //
    KTIMER                                  EventTimer;
    KDPC                                    EventDpc;

    //
    // IRQ Mask used in determining which IRQs are allowed for this
    // controller & it's child pc-cards.
    // 1's in the mask correspond to valid IRQs.
    // IRQs are numbered 0 - 15, lsb to msb
    // LegacyIrqMask is a fixed masked used if detection fails and PCI routing is disabled
    //
    USHORT                                  DetectedIrqMask;
    USHORT                                  LegacyIrqMask;

    //
    // Physical address of the attribute memory window used
    // read tuples off a pc-card.
    //
    PHYSICAL_ADDRESS                        PhysicalBase;
    //
    // Attribute memory resource requirement limits
    //
    ULONG                                   AttributeMemoryLow;
    ULONG                                   AttributeMemoryHigh;

    //
    // Size of the attribute memory window requested
    //
    ULONG                                   AttributeMemorySize;
    //
    // Alignment of the attribute memory window
    //
    ULONG                                   AttributeMemoryAlignment;
    //
    // Virtual address mapped to the attribute memory window (PhysicalBase)
    //
    PUCHAR                                  AttributeMemoryBase;
    //
    // Sequence number for  event logging
    //
    ULONG                                   SequenceNumber;

    //
    // Pointer to the interrupt object - if we use interrupt based
    // card status change detection
    //
    PKINTERRUPT                             PcmciaInterruptObject;

    //
    // Power management related stuff.
    //
    //
    // Current system power state..
    //
    SYSTEM_POWER_STATE                      SystemPowerState;
    //
    // Device power state the pcmcia controller is currently in
    //
    DEVICE_POWER_STATE                      DevicePowerState;
    //
    // Indicates how many children (pc-cards) are pending on an
    // IRP_MN_WAIT_WAKE
    //
    ULONG                                   ChildWaitWakeCount;
    //
    // Device capabilities as reported by our bus driver
    //
    DEVICE_CAPABILITIES                     DeviceCapabilities;
    //
    // Pending wait wake Irp
    //
    PIRP                                    WaitWakeIrp;
    LONG                                    WaitWakeState;

    //
    // Pci config register state
    //
    PCMCIA_CONTEXT                          PciContext;
    //
    // Interface obtained from PCI driver, for cardbus controllers.
    // This contains interfaces to enumerate CardBus cards
    // (not this interface is private to PCI & PCMCIA.
    // No other driver is expected to use these interfaces
    //
    PCI_CARDBUS_INTERFACE_PRIVATE           PciCardBusInterface;
    PVOID                                   PciCardBusDeviceContext;
    //
    // PCI Bus interface standard
    // This contains interfaces to read/write from PCI config space
    // of the cardbus controller, among other stuff..
    //
    BUS_INTERFACE_STANDARD                  PciBusInterface;
    //
    // PCI Int Route interface standard
    // This contains the interface to update the raw interrupt line
    // of the cardbus card
    //
    INT_ROUTE_INTERFACE_STANDARD            PciIntRouteInterface;
    //
    // Configuration resources for the PCMCIA controller
    //
    PCMCIA_CONFIGURATION_INFORMATION Configuration;
    //
    // Pending power irp
    //
    PIRP                                    PendingPowerIrp;
    PSOCKET                                 PendingPowerSocket;
    //
    // Power worker state machine context
    //
    FDO_POWER_WORKER_STATE                  *PowerWorkerSequence;
    FDO_POWER_WORKER_STATE                  PowerWorkerState;
    UCHAR                                   PowerWorkerPhase;
    UCHAR                                   PowerWorkerMaxPhase;
    //
    // Type of bus we are on
    //
    INTERFACE_TYPE                          InterfaceType;
    //
    // CardBus socket base
    //
    PUCHAR                                  CardBusSocketRegisterBase;
    //
    // Size of the socket register base that has been mapped
    //
    ULONG                                   CardBusSocketRegisterSize;
    //
    // configuration context
    //
    PCMCIA_CONTEXT                          CardbusContext;
    PCMCIA_CONTEXT                          ExcaContext;
    PUCHAR                                  PciContextBuffer;
    //
    // Deferred pdo power irp handling
    //
    LIST_ENTRY                              PdoPowerRetryList;
    KDPC                                    PdoPowerRetryDpc;
    //
    // Count to track cardbus PCI interface calls
    //
    ULONG                                   PciAddCardBusCount;
    //
    // Deletion Mutex
    //
    ULONG                                   DeletionLock;
} FDO_EXTENSION, *PFDO_EXTENSION;



//
// Physical Device Object's device extension information
//
// There is one device object for each function of each
// PC-card in a socket per PCMCIA controller
// in the system.  This is referred to as the 'PDO' (physical device
// object)- handled by this bus driver.
//

//
// Flags indicating card state
//
#define PCMCIA_DEVICE_MULTIFUNCTION         0x00000008
#define PCMCIA_DEVICE_WAKE_PENDING          0x00000010
#define PCMCIA_POWER_WORKER_POWERUP         0x00008000
#define PCMCIA_CONFIG_STATUS_DEFERRED       0x00020000
#define PCMCIA_POWER_STATUS_DEFERRED        0x00040000
#define PCMCIA_PDO_ENABLE_AUDIO             0x00200000
#define PCMCIA_PDO_EXCLUSIVE_IRQ            0x00400000

#define PCMCIA_PDO_INDIRECT_CIS             0x00000001
#define PCMCIA_PDO_SUPPORTS_WAKE            0x00000002

//
// states for PdoPowerWorker
//
typedef enum _PDO_POWER_WORKER_STATE {
    PPW_Stopped = 0,
    PPW_Exit,
    PPW_InitialState,
    PPW_PowerUp,
    PPW_PowerDown,
    PPW_SendIrpDown,
    PPW_16BitConfigure,
    PPW_CardBusRefresh,
    PPW_CardBusDelay
} PDO_POWER_WORKER_STATE;

//
// phases for ConfigurationWorker
//
typedef enum _CW_STATE {
    CW_Stopped = 0,
    CW_InitialState,
    CW_ResetCard,
    CW_Phase1,
    CW_Phase2,
    CW_Phase3,
    CW_Exit
} CW_STATE;

//
// Flags for ConfigurationWorker
//

#define CONFIG_WORKER_APPLY_MODEM_HACK  0x01


#define PCMCIA_PDO_EXTENSION_SIGNATURE      'PmcP'

//
// Device extension for the physical device object for pcmcia cards
//
typedef struct _PDO_EXTENSION {
    ULONG                                   Signature;

    PDEVICE_OBJECT                          DeviceObject;

    //
    // Link to next pdo in the Fdo's pdo chain
    //
    PDEVICE_OBJECT                          NextPdoInFdoChain;

    //
    // Link to next pdo in the Socket's pdo chain
    //
    PDEVICE_OBJECT                          NextPdoInSocket;

    //
    // Following two declarations valid only for cardbus cards
    //
    // Device attached just below us
    //
    PDEVICE_OBJECT                          LowerDevice;
    //
    // Actual PDO (owned by PCI) that was enumerated for this
    // cardbus card
    //
    PDEVICE_OBJECT                          PciPdo;

    //
    // Cached copy of device id
    //
    PUCHAR                                  DeviceId;

    //
    // Pointer to the appropriate socket struc in the parent FDO
    //
    PSOCKET                                 Socket;
    //
    // Pointer to the structure assembled by gleaning off tuple data
    // from a 16-bit pc-card
    //
    PSOCKET_DATA                            SocketData;

    //
    // Resource configuration assigned to this socket
    //
    PSOCKET_CONFIGURATION                   SocketConfiguration;

    //
    // Flags prefixed PCMCIA_ above
    //
    ULONG                                   Flags;

    //
    // PDO Flags
    //
    ULONG                                   PdoFlags;

    //
    // Power declarations
    //
    DEVICE_POWER_STATE                      DevicePowerState;
    SYSTEM_POWER_STATE                      SystemPowerState;
    //
    // Device Capabilities
    //
    DEVICE_CAPABILITIES                     DeviceCapabilities;
    //
    // Pending wait wake irp
    //
    PIRP                                    WaitWakeIrp;
    //
    // Other pending power irps
    //
    PIRP                                    PendingPowerIrp;
    //
    // power worker state machine variables
    //
    KTIMER                                  PowerWorkerTimer;
    KDPC                                    PowerWorkerDpc;
    NTSTATUS                                PowerWorkerDpcStatus;
    PUCHAR                                  PowerWorkerSequence;
    UCHAR                                   PowerWorkerPhase;
    PDO_POWER_WORKER_STATE                  PowerWorkerState;
    //
    // Type of card based on an INF override
    //
    UCHAR                                   SpecifiedDeviceType;

    //
    // Timer and DPC objects to handle card enables
    //
    CW_STATE                                ConfigurationPhase;
    UCHAR                                   ConfigurationFlags;
    KTIMER                                  ConfigurationTimer;
    KDPC                                    ConfigurationDpc;
    NTSTATUS                                ConfigurationStatus;
    NTSTATUS                                DeferredConfigurationStatus;
    USHORT                                  ConfigureDelay1;
    USHORT                                  ConfigureDelay2;
    USHORT                                  ConfigureDelay3;
    USHORT                                  Reserved2;
    PPCMCIA_COMPLETION_ROUTINE              ConfigCompletionRoutine;
    //
    // PCI Bus interface standard
    // This contains interfaces to read/write from PCI config space
    // of the cardbus card, among other stuff..
    //
    BUS_INTERFACE_STANDARD                  PciBusInterface;          // size 0x20  (32)
    //
    // ID used to check for card changes while powered off
    //
    ULONG                                   CardBusId;
    //
    // CIS cache for reading tuple data
    //
    PUCHAR                                  CisCache;
    MEMORY_SPACE                            CisCacheSpace;
    ULONG                                   CisCacheBase;
    //
    // Lock for power requests
    //
    LONG                                    SocketPowerRequested;
    //
    // Deletion Mutex
    //
    ULONG                                   DeletionLock;
} PDO_EXTENSION, *PPDO_EXTENSION;


//
// Struct for Database of card bus controller information
// which maps the vendor id/device id to a CONTROLLER_TYPE
//

typedef struct _PCI_CONTROLLER_INFORMATION {
    USHORT           VendorID;
    USHORT           DeviceID;
    PCMCIA_CONTROLLER_TYPE ControllerType;
} PCI_CONTROLLER_INFORMATION, *PPCI_CONTROLLER_INFORMATION;

//
// Struct for database of generic vendor class based on vendor ID
//

typedef struct _PCI_VENDOR_INFORMATION {
    USHORT           VendorID;
    PCMCIA_CONTROLLER_CLASS ControllerClass;
} PCI_VENDOR_INFORMATION, *PPCI_VENDOR_INFORMATION;


//
// Tuple packet used to access tuples
//
typedef struct _TUPLE_PACKET {
    PSOCKET      Socket;
    PSOCKET_DATA SocketData;
    UCHAR        TupleCode;
    UCHAR        TupleLink;
    UCHAR        TupleOffset;
    UCHAR        DesiredTuple;
    USHORT       Attributes;
    USHORT       TupleDataMaxLength;
    USHORT       TupleDataIndex;
    PUCHAR       TupleData;
    ULONG        LinkOffset;
    ULONG        CISOffset;
    USHORT       TupleDataLength;
    USHORT       Flags;
    UCHAR        Function;
} TUPLE_PACKET, * PTUPLE_PACKET;

//
// Memory space definitions for accessing CardBus CIS data
//

#define   PCCARD_CARDBUS_BAR0               0x6e627301
#define   PCCARD_CARDBUS_BAR1               0x6e627302
#define   PCCARD_CARDBUS_BAR2               0x6e627303
#define   PCCARD_CARDBUS_BAR3               0x6e627304
#define   PCCARD_CARDBUS_BAR4               0x6e627305
#define   PCCARD_CARDBUS_BAR5               0x6e627306
#define   PCCARD_CARDBUS_ROM                0x6e627307

//
// Chain of resource lists built by PcmciaConfigEntriesToResourceList
//
typedef struct _PCMCIA_RESOURCE_CHAIN {
    struct _PCMCIA_RESOURCE_CHAIN *NextList;
    PIO_RESOURCE_LIST IoResList;
} PCMCIA_RESOURCE_CHAIN, *PPCMCIA_RESOURCE_CHAIN;

//
// Linked list of CM_PCCARD_DEVICE_DATA's pulled from the registry
//

typedef struct _PCMCIA_NTDETECT_DATA {
    struct _PCMCIA_NTDETECT_DATA *Next;
    CM_PCCARD_DEVICE_DATA PcCardData;
} PCMCIA_NTDETECT_DATA, *PPCMCIA_NTDETECT_DATA;


//
// Poll interval for card status change (in case interrupt not available)
// Expressed in milliseconds
//
#define PCMCIA_CSC_POLL_INTERVAL 1000    // 1 Second

// The pccard device id prefix
#define PCMCIA_ID_STRING            "PCMCIA"

// String to be substituted if manufacturer name is not known
#define PCMCIA_UNKNOWN_MANUFACTURER_STRING "UNKNOWN_MANUFACTURER"

// Max length of device id
#define PCMCIA_MAXIMUM_DEVICE_ID_LENGTH 128

// Pcmcia controller device name
#define PCMCIA_DEVICE_NAME      "\\Device\\Pcmcia"

// Pcmcia controller device symbolic link name
#define PCMCIA_LINK_NAME            "\\DosDevices\\Pcmcia"

// PcCard's device name (PDO name)
#define PCMCIA_PCCARD_NAME      "\\Device\\PcCard"

// Jedec prefix for memory cards
#define PCMCIA_MEMORY_ID_STRING "MTD"

//
// Max no. of pccard instances of a particular device id allowed
// at a time
#define PCMCIA_MAX_INSTANCE     100             //arbitrary

#define PCMCIA_ENABLE_DELAY                       10000

//
// Number of times we attempt to configure the card before
// we give up   (could be the card has been removed)
//
#define PCMCIA_MAX_CONFIG_TRIES         2

//
// problems observed on tecra 750 and satellite 300, with dec-chipset cb nic
//
#define PCMCIA_CONTROLLER_POWERUP_DELAY  250000   // 250 msec

//
// Amount of time to wait after an event interrupt was asserted on the controller
//
#define PCMCIA_DEFAULT_EVENT_DPC_DELAY  400000   // 400 msec
#define PCMCIA_MAX_EVENT_DPC_DELAY       2000000

//
// Timeout for deletion locks (secs)
//
#define PCMCIA_DELETION_TIMEOUT         20

//
// Global Flags
//
#define   PCMCIA_GLOBAL_FORCE_POLL_MODE     0x00000002      // use polled mode for detecting card insert/remove
#define PCMCIA_DISABLE_ACPI_NAMESPACE_CHECK 0x00000004      // irq routing test
#define PCMCIA_DEFAULT_ROUTE_R2_TO_ISA      0x00000008
//
// Flags for PcmciaSetSocketPower
//

#define PCMCIA_POWERON TRUE
#define PCMCIA_POWEROFF FALSE

//
// This accepts device extension as  paramter: need to keep adding to this macro
// as more PciPcmciaBridges are supported
//
  #define PciPcmciaBridgeExtension(DeviceExtension)  (((DeviceExtension)->ControllerType==PcmciaPciPcmciaBridge)    ||   \
                                                                      ((DeviceExtension)->ControllerType==PcmciaCLPD6729))


// These accept the socket as parameter

//
// Cirrus Logic PD6729 PCI-PCMCIA Bridge
//
#define CLPD6729(s)   (((s)->DeviceExtension) && ((s)->DeviceExtension->ControllerType==PcmciaCLPD6729))

//
// Databook TCIC 16-bit pcmcia controller
//
#define Databook(s)   (((s)->DeviceExtension) && ((s)->DeviceExtension->ControllerType==PcmciaDatabook))

//
// Compaq Elite controller
//
#define Elc(s)        (((s)->DeviceExtension) && ((s)->DeviceExtension->ControllerType==PcmciaElcController))

//
// Generic cardbus controller
//
#define CardBus(s)    (((s)->DeviceExtension) && CardBusExtension((s)->DeviceExtension))

//
// Generic PCI-PCMCIA Bridge
//
#define PciPcmciaBridge(s) (((s)->DeviceExtension) && PciPcmciaBridgeExtension((s)->DeviceExtension))

//
// Macros for manipulating PDO's flags
//

#define IsDeviceFlagSet(deviceExtension, Flag)          (((deviceExtension)->Flags & (Flag))?TRUE:FALSE)
#define SetDeviceFlag(deviceExtension, Flag)            ((deviceExtension)->Flags |= (Flag))
#define ResetDeviceFlag(deviceExtension,Flag)           ((deviceExtension)->Flags &= ~(Flag))

#define IsFdoFlagSet(fdoExtension, Flag)                (((fdoExtension)->FdoFlags & (Flag))?TRUE:FALSE)
#define SetFdoFlag(fdoExtension, Flag)                  ((fdoExtension)->FdoFlags |= (Flag))
#define ResetFdoFlag(fdoExtension,Flag)                 ((fdoExtension)->FdoFlags &= ~(Flag))

#define IsPdoFlagSet(pdoExtension, Flag)                (((pdoExtension)->PdoFlags & (Flag))?TRUE:FALSE)
#define SetPdoFlag(pdoExtension, Flag)                  ((pdoExtension)->PdoFlags |= (Flag))
#define ResetPdoFlag(pdoExtension,Flag)                 ((pdoExtension)->PdoFlags &= ~(Flag))

#define IsFdoExtension(fdoExtension)                    (fdoExtension->Signature == PCMCIA_FDO_EXTENSION_SIGNATURE)
#define IsPdoExtension(pdoExtension)                    (pdoExtension->Signature == PCMCIA_PDO_EXTENSION_SIGNATURE)
#define IsSocket(socket)                                (socket->Signature == PCMCIA_SOCKET_SIGNATURE)


#define MarkDeviceStarted(deviceExtension)              ((deviceExtension)->Flags |=  PCMCIA_DEVICE_STARTED)
#define MarkDeviceNotStarted(deviceExtension)           ((deviceExtension)->Flags &= ~PCMCIA_DEVICE_STARTED)
#define MarkDeviceDeleted(deviceExtension)              ((deviceExtension)->Flags |= PCMCIA_DEVICE_DELETED);
#define MarkDevicePhysicallyRemoved(deviceExtension) \
                                                        ((deviceExtension)->Flags |=  PCMCIA_DEVICE_PHYSICALLY_REMOVED)
#define MarkDevicePhysicallyInserted(deviceExtension) \
                                                        ((deviceExtension)->Flags &= ~PCMCIA_DEVICE_PHYSICALLY_REMOVED)
#define MarkDeviceLogicallyRemoved(deviceExtension) \
                                                        ((deviceExtension)->Flags |=  PCMCIA_DEVICE_LOGICALLY_REMOVED)
#define MarkDeviceLogicallyInserted(deviceExtension) \
                                                        ((deviceExtension)->Flags &= ~PCMCIA_DEVICE_LOGICALLY_REMOVED)
#define MarkDeviceCardBus(deviceExtension)              ((deviceExtension)->Flags |= PCMCIA_DEVICE_CARDBUS)
#define MarkDevice16Bit(deviceExtension)                ((deviceExtension)->Flags &= ~PCMCIA_DEVICE_CARDBUS)
#define MarkDeviceMultifunction(deviceExtension) \
                                                        ((deviceExtension)->Flags |= PCMCIA_DEVICE_MULTIFUNCTION)


#define IsDeviceStarted(deviceExtension)                (((deviceExtension)->Flags & PCMCIA_DEVICE_STARTED)?TRUE:FALSE)
#define IsDevicePhysicallyRemoved(deviceExtension) \
                                                        (((deviceExtension)->Flags & PCMCIA_DEVICE_PHYSICALLY_REMOVED)?TRUE:FALSE)
#define IsDeviceLogicallyRemoved(deviceExtension) \
                                                        (((deviceExtension)->Flags & PCMCIA_DEVICE_LOGICALLY_REMOVED)?TRUE:FALSE)
#define IsDeviceDeleted(deviceExtension)                (((deviceExtension)->Flags & PCMCIA_DEVICE_DELETED)?TRUE:FALSE)
#define IsDeviceMultifunction(deviceExtension)          (((deviceExtension)->Flags & PCMCIA_DEVICE_MULTIFUNCTION)?TRUE:FALSE)

#define IsCardBusCard(deviceExtension)                  (((deviceExtension)->Flags & PCMCIA_DEVICE_CARDBUS)?TRUE:FALSE)
#define Is16BitCard(deviceExtension)                    (((deviceExtension)->Flags & PCMCIA_DEVICE_CARDBUS)?FALSE:TRUE)

#define CardBusExtension(deviceExtension)               (((deviceExtension)->Flags & PCMCIA_DEVICE_CARDBUS)?TRUE:FALSE)

//
// Macros for checking & setting type of PC-CARD in a socket
//
#define IsCardBusCardInSocket(SocketPtr)                (((SocketPtr)->DeviceState == SKT_CardBusCard)?TRUE:FALSE)
#define Is16BitCardInSocket(SocketPtr)                  (((SocketPtr)->DeviceState == SKT_R2Card)?TRUE:FALSE)
#define IsCardInSocket(SocketPtr)                       (((SocketPtr)->DeviceState == SKT_Empty)?FALSE:TRUE)

#define SetCardBusCardInSocket(SocketPtr)               ((SocketPtr)->DeviceState = SKT_CardBusCard)
#define Set16BitCardInSocket(SocketPtr)                 ((SocketPtr)->DeviceState = SKT_R2Card)
#define SetSocketEmpty(SocketPtr)                       ((SocketPtr)->DeviceState = SKT_Empty)

//
// NT definitions
//
#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'cmcP')
#endif

#define IO_RESOURCE_LIST_VERSION  0x1
#define IO_RESOURCE_LIST_REVISION 0x1

#define IRP_MN_PNP_MAXIMUM_FUNCTION IRP_MN_QUERY_LEGACY_BUS_INFORMATION

//
// Some useful macros
//
#define MIN(x,y) ((x) > (y) ? (y) : (x))            // return minimum among x & y
#define MAX(x,y) ((x) > (y) ? (x) : (y))            // return maximum among x & y

//
// BOOLEAN
// IS_PDO (IN PDEVICE_OBJECT DeviceObject);
//
#define IS_PDO(DeviceObject)         (((DeviceObject)->Flags & DO_BUS_ENUMERATED_DEVICE)?TRUE:FALSE)

//
// VOID
// MARK_AS_PDO (IN PDEVICE_OBJECT DeviceObject);
//
#define MARK_AS_PDO(DeviceObject) ((DeviceObject)->Flags |= DO_BUS_ENUMERATED_DEVICE)

//
// BOOLEAN
// PcmciaSetWindowPage(IN FDO_EXTENSION fdoExtension,
//                        IN PSOCKET Socket,
//                        IN USHORT Index,
//                        IN UCHAR Page);
//
#define PcmciaSetWindowPage(fdoExtension, Socket, Index, Page)                                          \
    ((DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetWindowPage) ?                           \
        (*DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetWindowPage)(Socket, Index, Page) :  \
        FALSE)

#define HasWindowPageRegister(fdoExtension) \
    ((BOOLEAN)(DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetWindowPage))

//
// VOID
// PcmciaSetAudio(
//  IN PSOCKET Socket,
//  IN BOOLEAN enable
//  );
//
#define PcmciaSetAudio(fdoExtension, socket, enable)                                                    \
    if ((DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetAudio)) {                            \
        (*DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetAudio)(socket, enable);             \
        }

//
// BOOLEAN
// PcmciaSetZV(
//  IN PSOCKET Socket,
//  IN BOOLEAN enable
//  );
//
#define PcmciaSetZV(fdoExtension, socket, enable)                                                       \
    ((DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetZV) ?                                   \
        (*DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetZV)(socket, enable) :               \
        FALSE)

//
// Io extension macro to just pass on the Irp to a lower driver
//

//
// VOID
// PcmciaSkipCallLowerDriver(OUT NTSTATUS Status,
//                                IN    PDEVICE_OBJECT DeviceObject,
//                                IN    PIRP Irp);
//
#define PcmciaSkipCallLowerDriver(Status, DeviceObject, Irp) {          \
                    IoSkipCurrentIrpStackLocation(Irp);                 \
                    Status = IoCallDriver(DeviceObject,Irp);}

//
// VOID
// PcmciaCopyCallLowerDriver(OUT NTSTATUS Status,
//                                IN    PDEVICE_OBJECT DeviceObject,
//                                IN    PIRP Irp);
//
#define PcmciaCopyCallLowerDriver(Status, DeviceObject, Irp) {          \
                    IoCopyCurrentIrpStackLocationToNext(Irp);           \
                    Status = IoCallDriver(DeviceObject,Irp); }

//  BOOLEAN
//  CompareGuid(
//    IN LPGUID guid1,
//    IN LPGUID guid2
//    );

#define CompareGuid(g1, g2)  ((g1) == (g2) ?TRUE:                           \
                                            RtlCompareMemory((g1),          \
                                                             (g2),          \
                                                             sizeof(GUID))  \
                                            == sizeof(GUID)                 \
                                      )

//
// BOOLEAN
// ValidateController(IN FDO_EXTENSION fdoExtension)
//
// Bit of paranoia code. Make sure that the cardbus controller's registers
// are still visible.
//

#define ValidateController(fdoExtension) \
        (CardBusExtension(fdoExtension) ?  \
            ((CBReadSocketRegister(fdoExtension->SocketList, CBREG_SKTMASK) & 0xfffffff0) == 0)  \
            : TRUE)

//
// Registers for accessing indirect access space
//

#define IAR_CONTROL_LOW     2
#define IAR_ADDRESS         4
#define IAR_DATA            8

// Flags defined in "Control"
#define IARF_COMMON         1
#define IARF_AUTO_INC       2
#define IARF_BYTE_GRAN      4

//
// Vendor specific dispatches for various controllers
//
typedef struct _DEVICE_DISPATCH_TABLE {

    //
    // Type of controller for which the dispatches apply
    //
    PCMCIA_CONTROLLER_CLASS   ControllerClass;

    //
    // Function to vendor-specific initialize controller
    //
    VOID     (*InitController) (IN PFDO_EXTENSION FdoExtension);

    //
    // Vendor specific function to set power for a pc-card
    //
    NTSTATUS
    (*SetPower) (
        IN PSOCKET SocketPtr,
        IN BOOLEAN Enable,
        OUT PULONG pDelayTime
        );

    //
    // Vendor specific function to set/reset Audio
    //
    VOID
    (*SetAudio) (
        IN PSOCKET Socket,
        IN BOOLEAN Enable
        );

    //
    // Vendor specific function to set/reset Zoom Video mode
    //
    BOOLEAN
    (*SetZV) (
        IN PSOCKET Socket,
        IN BOOLEAN Enable
        );

    //
    // Vendor specific function to set page register for memory windows
    //
    BOOLEAN (*SetWindowPage) (IN PSOCKET SocketPtr,
                              IN USHORT Index,
                              IN UCHAR Page);

} DEVICE_DISPATCH_TABLE, *PDEVICE_DISPATCH_TABLE;

//
// Controller types to hardware/device/compatible id mapping
//
typedef struct _PCMCIA_ID_ENTRY {
    PCMCIA_CONTROLLER_TYPE ControllerType;
    PUCHAR                Id;
} PCMCIA_ID_ENTRY, *PPCMCIA_ID_ENTRY;

//
// Exca & cardbus register init structure used to
// initialize the registers on start up
//
typedef struct _PCMCIA_REGISTER_INIT {
    //
    // Register offset
    //
    ULONG Register;
    //
    // value: EXCA regs need only a byte,
    // so only the LSB of this field is used for
    // initializing them. Cardbus regs need the
    // entire DWORD
    //
    ULONG Value;
} PCMCIA_REGISTER_INIT, *PPCMCIA_REGISTER_INIT;

//
// Structure which defines special per-device configuration parameters
//

typedef struct _PCMCIA_DEVICE_CONFIG_PARAMS {
    UCHAR ValidEntry;
    UCHAR DeviceType;
    USHORT ManufacturerCode;
    USHORT ManufacturerInfo;
    USHORT CisCrc;
    USHORT ConfigDelay1;
    USHORT ConfigDelay2;
    USHORT ConfigDelay3;
    UCHAR ConfigFlags;
} PCMCIA_DEVICE_CONFIG_PARAMS, *PPCMCIA_DEVICE_CONFIG_PARAMS;

//
// Structure which defines what global parameters are read from the registry
//

typedef struct _GLOBAL_REGISTRY_INFORMATION {
    PWSTR Name;
    PULONG pValue;
    ULONG Default;
} GLOBAL_REGISTRY_INFORMATION, *PGLOBAL_REGISTRY_INFORMATION;

//
// Defines used both by data.c and registry.c
//

#define PCMCIA_REGISTRY_ISA_IRQ_RESCAN_COMPLETE      L"IsaIrqRescanComplete"

#endif  //_PCMCIAPRT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\inc\tcicregs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    tcicregs.h

Abstract:

	Databook TCIC register structures for DEBUG support.
	
Author(s):
		John Keys - Databook Inc. 7-Apr-1995

Revisions:
--*/
#ifndef _tcicregs_h_			// prevent multiple includes 
#define _tcicregs_h_

typedef struct _BASEREGS {
	UCHAR	sctrl;
	UCHAR 	sstat;
	UCHAR	mode;
	UCHAR	pwr;
	USHORT  edc;
	UCHAR	icsr;
	UCHAR	iena;
	USHORT  wctl;
	USHORT	syscfg;
	USHORT	ilock;
	USHORT  test;
}BASEREGS, *PBASEREGS;


typedef struct _SKTREGS {
	USHORT  scfg1;
	USHORT	scfg2;
}SKTREGS, *PSKTREGS;

typedef struct _IOWIN {
	USHORT iobase;
	USHORT ioctl;
}IOWIN, *PIOWIN;

typedef struct _MEMWIN {
	USHORT mbase;
	USHORT mmap;
	USHORT mctl;
}MEMWIN, *PMEMWIN;


typedef struct _TCIC {
	BASEREGS baseregs[2];
	SKTREGS	 sktregs[2];
	IOWIN	 iowins[4];
	MEMWIN	 memwins[10];
}TCIC, *PTCIC;

#endif  //_tcicregs_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\memcard\debug.c ===
/*++      

Copyright (c) 1999 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module provides debugging support.

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Revision History:


--*/


#include "pch.h"

#if DBG

ULONG MemCardDebugLevel = 1;

VOID
MemCardDebugPrint(
                ULONG  DebugMask,
                PCCHAR DebugMessage,
                ...
                )

/*++

Routine Description:

    Debug print for the PCMCIA enabler.

Arguments:

    Check the mask value to see if the debug message is requested.

Return Value:

    None

--*/

{
    va_list ap;
    char    buffer[256];

    va_start(ap, DebugMessage);

    if (DebugMask & MemCardDebugLevel) {
       vsprintf(buffer, DebugMessage, ap);
       DbgPrint(buffer);
    }

    va_end(ap);
} // end MemcardDebugPrint()




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\inc\tcicext.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    tcicext.h

Abstract:

	Definitions for TCIC support helper functions.
	
Author(s):
		John Keys - Databook Inc. 7-Apr-1995

Revisions:
--*/

#ifndef _tcicext_h_				// prevent multiple includes 
#define _tcicext_h_

BOOLEAN 
TcicReservedBitsOK(
	IN PSOCKET pskt
	);

VOID
TcicFillInAdapter(
	IN PSOCKET plocskt,
	IN PSOCKET *psocketPtr, 
	IN PSOCKET *previousSocketPtr, 
	IN PFDO_EXTENSION DeviceExtension,
	IN ULONG   ioPortBase
	);

USHORT
TcicReadBaseReg(
    IN PSOCKET SocketPtr,
    IN ULONG   Register
    );
	
VOID
TcicWriteBaseReg(
    IN PSOCKET SocketPtr,
    IN ULONG   Register,
	IN USHORT  value
    );
	
ULONG
TcicReadAddrReg(
    IN PSOCKET SocketPtr
	);

VOID
TcicWriteAddrReg(
	IN PSOCKET SocketPtr,
	IN ULONG   addr
	);

USHORT
TcicReadAuxReg(
    IN PSOCKET SocketPtr,
    IN ULONG   Register
    );

VOID
TcicWriteAuxReg(
    IN PSOCKET SocketPtr,
    IN ULONG   Register,
	IN USHORT  value
    );

VOID
TcicReadIndirectRegs(
    IN PSOCKET SocketPtr,
    IN ULONG   StartRegister,
	IN USHORT  numWords,
	IN PUSHORT ReadBuffer
    );
	
VOID
TcicWriteIndirectRegs(
    IN PSOCKET SocketPtr,
    IN ULONG   StartRegister,
	IN USHORT  numWords,
	IN PUSHORT WriteBuffer
    );

USHORT 
TcicSocketSelect(
	IN PSOCKET SocketPtr,
	IN USHORT sktnum
	);

PUCHAR
TcicAllocateMemRange(
    IN PFDO_EXTENSION DeviceExtension,
    IN PULONG Mapped,
    IN PULONG Physical
    );

USHORT 
TcicChipID (
	IN PDBSOCKET pInst
	);

BOOLEAN 
TcicCheckSkt(
	IN PSOCKET pInst, 
	IN int iSocket
	);
	
USHORT 
TcicCheckAliasing(
	IN PDBSOCKET pdbskt, 
	IN USHORT offst
	);
	
USHORT 
TcicCheckAliasType (
	IN PDBSOCKET pInst
	);
	
BOOLEAN 
TcicCheckXBufNeeded(
	IN PSOCKET pInst
	);
	
VOID TcicSetMemWindow(
	IN PSOCKET pInst, 
	IN USHORT wnum, 
	IN ULONG_PTR base, 
	IN USHORT npages, 
	IN USHORT mctl
	);
	
VOID 
TcicGetPossibleIRQs(
	IN PDBSOCKET pInst, 
	IN UCHAR *ptbl
	);

CHIPPROPS *
TcicGetChipProperties(
	IN PDBSOCKET pInst
	);
	
BOOLEAN 
TcicChipIDKnown(
	IN PDBSOCKET pInst
	);
	
USHORT 
TcicGetnIOWins(
	IN PDBSOCKET pInst
	);

USHORT 
TcicGetnMemWins(
	IN PDBSOCKET pInst
	);

USHORT 
TcicGetFlags(
	IN PDBSOCKET pInst
	);

BOOLEAN 
TcicIsPnP(
	IN PDBSOCKET pInst
	);

BOOLEAN 
TcicHasSktIRQPin(
	IN PDBSOCKET pInst
	);

VOID 
TcicGetAdapterInfo(
	IN PDBSOCKET dbsocketPtr
	);
	
USHORT 
TcicGet5vVccVal(
	IN PDBSOCKET pInst
	);
	
VOID 
TcicGetIRQMap(
	IN PDBSOCKET pInst
	);
	

USHORT 
TcicClockRate(
	PSOCKET pInst
	);

VOID
TcicSetIoWin(
	IN PSOCKET socketPtr,
	IN USHORT  winIdx,
	IN ULONG   BasePort,
	IN ULONG   NumPorts,
	IN UCHAR   Attributes	
	);
	
VOID
TcicSetMemWin(
	IN PSOCKET socketPtr,
	IN USHORT  winIdx,
	IN ULONG   cardbase,
	IN ULONG   base,
	IN ULONG   size,
	IN UCHAR   AttrMem,
	IN UCHAR   AccessSpeed,		
	IN USHORT  Attributes	
	);


USHORT	
TcicMapSpeedCode(
	IN PDBSOCKET pdb, 
	IN UCHAR AccessSpeed
	);

VOID 
TcicAutoBusyOff(
	IN PDBSOCKET pdbs
	);
	
UCHAR 
TcicAutoBusyCheck(
	IN PDBSOCKET pdbs
	);
	
VOID
TcicCheckSktLED(	
	IN PDBSOCKET pdbs
	);
	
VOID
TcicBusyLedRoutine(
	IN PDEVICE_OBJECT DeviceObject,
	IN PVOID Context
	);
	
VOID 
TcicDecodeIoWin(
	USHORT	iobase,
	USHORT  ioctl,
	USHORT	*NumPorts,
	USHORT	*BasePort
	);
	
VOID 
TcicDecodeMemWin(
	USHORT	mbase,
	USHORT	mmap,
	USHORT  mctl,
	ULONG  *Host,
	ULONG  *Card,
	ULONG  *Size,
	UCHAR  *Attr
	);
	
	
#endif // _tcicext_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\memcard\debug.h ===
/*++

Copyright (c) 1991 - 1993 Microsoft Corporation

Module Name:

    debug.h

Abstract:


Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

Notes:


--*/


#if DBG
//
// For checked kernels, define a macro to print out informational
// messages.
//
// MemCardDebug is normally 0.  At compile-time or at run-time, it can be
// set to some bit patter for increasingly detailed messages.
//
// Big, nasty errors are noted with DBGP.  Errors that might be
// recoverable are handled by the WARN bit.  More information on
// unusual but possibly normal happenings are handled by the INFO bit.
// And finally, boring details such as routines entered and register
// dumps are handled by the SHOW bit.
//
#define MEMCARDDBGP              ((ULONG)0x00000001)
#define MEMCARDWARN              ((ULONG)0x00000002)
#define MEMCARDINFO              ((ULONG)0x00000004)
#define MEMCARDSHOW              ((ULONG)0x00000008)
#define MEMCARDIRPPATH           ((ULONG)0x00000010)
#define MEMCARDFORMAT            ((ULONG)0x00000020)
#define MEMCARDSTATUS            ((ULONG)0x00000040)
#define MEMCARDPNP               ((ULONG)0x00000080)
#define MEMCARDIOCTL             ((ULONG)0x00000100)
#define MEMCARDRW                ((ULONG)0x00000200)
extern ULONG MemCardDebugLevel;
#define MemCardDump(LEVEL,STRING) \
        do { \
            if (MemCardDebugLevel & (LEVEL)) { \
                DbgPrint STRING; \
            } \
        } while (0)
#else
#define MemCardDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\memcard\memcard.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    memcard.c

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

//
// Internal References
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MemCardUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
MemCardCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)

#pragma alloc_text(PAGE,MemCardCreateClose)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a mutex to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:

    DriverObject - a pointer to the object that represents this device
                   driver.

    RegistryPath - a pointer to this driver's key in the Services tree.

Return Value:

    STATUS_SUCCESS unless we can't allocate a mutex.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;


    MemCardDump(MEMCARDSHOW, ("MemCard: DriverEntry\n") );

    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = MemCardCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = MemCardCreateClose;
    DriverObject->MajorFunction[IRP_MJ_READ]           = MemCardIrpReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = MemCardIrpReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MemCardDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = MemCardPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = MemCardPower;

    DriverObject->DriverUnload = MemCardUnload;

    DriverObject->DriverExtension->AddDevice = MemCardAddDevice;
    
    return ntStatus;
}


VOID
MemCardUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Unload the driver from the system.  The paging mutex is freed before
    final unload.

Arguments:

    DriverObject - a pointer to the object that represents this device
                   driver.

Return Value:
    
    none

--*/

{
    MemCardDump( MEMCARDSHOW, ("MemCardUnload:\n"));

    //
    //  The device object(s) should all be gone by now.
    //
    ASSERT( DriverObject->DeviceObject == NULL );

    return;
}



NTSTATUS
MemCardCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called only rarely by the I/O system; it's mainly
    for layered drivers to call.  All it does is complete the IRP
    successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    Always returns STATUS_SUCCESS, since this is a null operation.

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );

    MemCardDump(
        MEMCARDSHOW,
        ("MemCardCreateClose...\n")
        );

    //
    // Null operation.  Do not give an I/O boost since
    // no I/O was actually done.  IoStatus.Information should be
    // FILE_OPENED for an open; it's undefined for a close.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = FILE_OPENED;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\memcard\io.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    io.c

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MemCardIrpReadWrite)
#pragma alloc_text(PAGE,MemCardReadWrite)
#endif



NTSTATUS
MemCardIrpReadWrite(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )

/*++

Routine Description:

   This routine handles read/write irps for the memory card. It validates
   parameters and calls MemCardReadWrite to do the real work.

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   STATUS_SUCCESS if the packet was successfully read or written; the
   appropriate error is propogated otherwise.

--*/

{
   NTSTATUS status = STATUS_SUCCESS;
   PMEMCARD_EXTENSION memcardExtension = DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
   BOOLEAN            writeOperation;
   
   //
   //  If the device is not active (not started yet or removed) we will
   //  just fail this request outright.
   //
   if ( memcardExtension->IsRemoved || !memcardExtension->IsStarted) {

      if ( memcardExtension->IsRemoved) {
         status = STATUS_DELETE_PENDING;
      } else {
         status = STATUS_UNSUCCESSFUL;
      }
      goto ReadWriteComplete;
   } 

   if (((irpSp->Parameters.Read.ByteOffset.LowPart +
          irpSp->Parameters.Read.Length) > memcardExtension->ByteCapacity) ||
          (irpSp->Parameters.Read.ByteOffset.HighPart != 0)) {

      status = STATUS_INVALID_PARAMETER;
      goto ReadWriteComplete;
   } 

   //
   // verify that user is really expecting some I/O operation to
   // occur.
   //
   if (!irpSp->Parameters.Read.Length) {
      //
      // Complete this zero length request with no boost.
      //
      Irp->IoStatus.Status = STATUS_SUCCESS;
      goto ReadWriteComplete;
   }
   
   if ((DeviceObject->Flags & DO_VERIFY_VOLUME) && !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME)) {
      //
      // The disk changed, and we set this bit.  Fail
      // all current IRPs for this device; when all are
      // returned, the file system will clear
      // DO_VERIFY_VOLUME.
      //
      status = STATUS_VERIFY_REQUIRED;
      goto ReadWriteComplete;
   }

   writeOperation = (irpSp->MajorFunction == IRP_MJ_WRITE) ? TRUE : FALSE;
   
   //
   // Do the operation
   //
   status = MemCardReadWrite(memcardExtension,
                             irpSp->Parameters.Read.ByteOffset.LowPart,
                             MmGetSystemAddressForMdl(Irp->MdlAddress),
                             irpSp->Parameters.Read.Length,
                             writeOperation);
                               
ReadWriteComplete:

   if (NT_SUCCESS(status)) {
      Irp->IoStatus.Information = irpSp->Parameters.Read.Length;
   } else {
      Irp->IoStatus.Information = 0;
   }   

   Irp->IoStatus.Status = status;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
   return status;
}   

   

NTSTATUS
MemCardReadWrite(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN ULONG              startOffset,
   IN PVOID              UserBuffer,
   IN ULONG              lengthToCopy,
   IN BOOLEAN            writeOperation
   )

/*++

Routine Description:

   This routine is called to read/write data to/from the memory card.
   It breaks the request into pieces based on the size of our memory
   window.

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   STATUS_SUCCESS if the packet was successfully read or written; the
   appropriate error is propogated otherwise.

--*/

{
   NTSTATUS status = STATUS_SUCCESS;
   PCHAR     userBuffer = UserBuffer;
   ULONG     windowOffset;
   ULONG     singleCopyLength;
   BOOLEAN   bSuccess;
   ULONGLONG CardBase;
   
   if (writeOperation && (memcardExtension->PcmciaInterface.IsWriteProtected)(memcardExtension->UnderlyingPDO)) {
      return STATUS_MEDIA_WRITE_PROTECTED;
   }      
   
   MemCardDump(MEMCARDRW,("MemCard: DO %.8x %s offset %.8x, buffer %.8x, len %x\n",
                           memcardExtension->DeviceObject,
                           writeOperation?"WRITE":"READ",
                           startOffset, UserBuffer, lengthToCopy));
                           
   // pcmcia controller is 4k page granular
   windowOffset = startOffset % 4096;
   CardBase = startOffset - windowOffset;
   
   while(lengthToCopy) {
   
      bSuccess = (memcardExtension->PcmciaInterface.ModifyMemoryWindow) (
                       memcardExtension->UnderlyingPDO,
                       memcardExtension->HostBase,
                       CardBase,
                       TRUE,
                       memcardExtension->MemoryWindowSize,
                       0, 0, FALSE);
     
      if (!bSuccess) {
         status = STATUS_DEVICE_NOT_READY;
         break;
      }
     
      singleCopyLength = (lengthToCopy <= (memcardExtension->MemoryWindowSize - windowOffset)) ?
                                    lengthToCopy :
                                    (memcardExtension->MemoryWindowSize - windowOffset);
      
     
      MemCardDump(MEMCARDRW,("MemCard: COPY %.8x (devbase %.8x) %s buffer %.8x, len %x\n",
                           memcardExtension->MemoryWindowBase+windowOffset,
                           (ULONG)(CardBase+windowOffset),
                           (writeOperation ? "<=" : "=>"),
                           userBuffer,
                           singleCopyLength));
                           
      if (writeOperation) {

         MemCardMtdWrite(memcardExtension, 
                         userBuffer,    
                         memcardExtension->MemoryWindowBase+windowOffset,
                         singleCopyLength);

      } else {

         MemCardMtdRead(memcardExtension, 
                        userBuffer,    
                        memcardExtension->MemoryWindowBase+windowOffset,
                        singleCopyLength);

      }
      
      lengthToCopy -= singleCopyLength;
      userBuffer += singleCopyLength;
      
      CardBase += memcardExtension->MemoryWindowSize;
      windowOffset = 0;
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\memcard\pch.h ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    pch.h

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/

//
// Include files.
//

#include "stdio.h"
#include <stdarg.h>

#include "ntosp.h"                       // various NT definitions
#include <zwapi.h>
#include "ntdddisk.h"                    // disk device driver I/O control codes
#include "initguid.h"
#include "wdmguid.h"
#include "ntddpcm.h"
#include "mountdev.h"
#include "acpiioct.h"

#include <memcard.h>                    // this driver's data declarations
#include <extern.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\memcard\extern.h ===
/*++

Copyright (c) 1991 - 1993 Microsoft Corporation

Module Name:

    extern.h

Abstract:


Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

Notes:


--*/



//
// Prototypes of driver routines.
//

NTSTATUS
MemCardDeviceControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
MemCardIrpReadWrite(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
MemCardAddDevice(
   IN      PDRIVER_OBJECT DriverObject,
   IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
   );

NTSTATUS
MemCardPnp(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
MemCardPower(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );
    
NTSTATUS
MemCardReadWrite(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN ULONG              startOffset,
   IN PVOID              userBuffer,
   IN ULONG              lengthToCopy,
   IN BOOLEAN            writeOperation
   );
   
ULONG
MemCardGetCapacity(
   IN PMEMCARD_EXTENSION memcardExtension
   );
   
NTSTATUS
MemCardInitializeMtd(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN PUNICODE_STRING TechnologyName
   );
   
VOID
MemCardMtdRead(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN PVOID TargetBuffer,
   IN CONST PVOID DeviceBuffer,
   IN ULONG Length
   );
   
VOID
MemCardMtdWrite(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN CONST PVOID SourceBuffer,
   IN PVOID DeviceBuffer,
   IN ULONG Length
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\memcard\ioctl.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MemCardDeviceControl)
#endif


NTSTATUS
MemCardDeviceControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )

/*++

Routine Description:

   This routine is called by the I/O system to perform a device I/O
   control function.

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
   STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
   PIO_STACK_LOCATION irpSp;
   PMEMCARD_EXTENSION memcardExtension;
   PDISK_GEOMETRY outputBuffer;
   NTSTATUS status;
   ULONG outputBufferLength;
   UCHAR i;
   ULONG formatExParametersSize;
   PFORMAT_EX_PARAMETERS formatExParameters;

   MemCardDump( MEMCARDIOCTL, ("MemCard: IOCTL entered\n") );

   memcardExtension = DeviceObject->DeviceExtension;
   irpSp = IoGetCurrentIrpStackLocation( Irp );

   //
   //  If the device has been removed we will just fail this request outright.
   //
   if ( memcardExtension->IsRemoved ) {

       Irp->IoStatus.Information = 0;
       Irp->IoStatus.Status = STATUS_DELETE_PENDING;
       IoCompleteRequest( Irp, IO_NO_INCREMENT );
       return STATUS_DELETE_PENDING;
   }

   //
   // If the device hasn't been started we will let the IOCTL through. This
   // is another hack for ACPI.
   //
   if (!memcardExtension->IsStarted) {

       IoSkipCurrentIrpStackLocation( Irp );
       return IoCallDriver( memcardExtension->TargetObject, Irp );
   }

   switch( irpSp->Parameters.DeviceIoControl.IoControlCode ) {

      case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME: {

         PMOUNTDEV_NAME mountName;

         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_MOUNTDEV_QUERY_DEVICE_NAME\n",
                                        DeviceObject, Irp));
                                        
         ASSERT(memcardExtension->DeviceName.Buffer);

         if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(MOUNTDEV_NAME) ) {

             status = STATUS_INVALID_PARAMETER;
             break;
         }

         mountName = Irp->AssociatedIrp.SystemBuffer;
         mountName->NameLength = memcardExtension->DeviceName.Length;

         if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(USHORT) + mountName->NameLength) {

             status = STATUS_BUFFER_OVERFLOW;
             Irp->IoStatus.Information = sizeof(MOUNTDEV_NAME);
             break;
         }

         RtlCopyMemory( mountName->Name, memcardExtension->DeviceName.Buffer,
                        mountName->NameLength);

         mountName->Name[mountName->NameLength / sizeof(USHORT)] = L'0';

         status = STATUS_SUCCESS;
         Irp->IoStatus.Information = sizeof(USHORT) + mountName->NameLength;
         break;
         }

      case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID: {

         PMOUNTDEV_UNIQUE_ID uniqueId;

         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_MOUNTDEV_QUERY_UNIQUE_ID\n",
                                        DeviceObject, Irp));

         if ( !memcardExtension->InterfaceString.Buffer ||
              irpSp->Parameters.DeviceIoControl.OutputBufferLength <
               sizeof(MOUNTDEV_UNIQUE_ID)) {

             status = STATUS_INVALID_PARAMETER;
             break;
         }

         uniqueId = Irp->AssociatedIrp.SystemBuffer;
         uniqueId->UniqueIdLength =
                 memcardExtension->InterfaceString.Length;

         if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(USHORT) + uniqueId->UniqueIdLength) {

             status = STATUS_BUFFER_OVERFLOW;
             Irp->IoStatus.Information = sizeof(MOUNTDEV_UNIQUE_ID);
             break;
         }

         RtlCopyMemory( uniqueId->UniqueId,
                        memcardExtension->InterfaceString.Buffer,
                        uniqueId->UniqueIdLength );

         status = STATUS_SUCCESS;
         Irp->IoStatus.Information = sizeof(USHORT) +
                                     uniqueId->UniqueIdLength;
         break;
         }

      case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME: {
      
         MemCardDump(MEMCARDIOCTL,("MemCard: DO %.8x Irp %.8x IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME\n",
                                    DeviceObject, Irp));

         status = STATUS_INVALID_DEVICE_REQUEST;
         break;
      }

      case IOCTL_DISK_GET_MEDIA_TYPES: {
         ULONG ByteCapacity;
      
         MemCardDump(MEMCARDIOCTL,("MemCard: DO %.8x Irp %.8x IOCTL_DISK_GET_MEDIA_TYPES\n",
                                   DeviceObject, Irp));
                                   
         outputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
         outputBuffer = (PDISK_GEOMETRY) Irp->AssociatedIrp.SystemBuffer;

         //
         // Make sure that the input buffer has enough room to return
         // at least one descriptions of a supported media type.
         //
         if (outputBufferLength < (sizeof(DISK_GEOMETRY))) {
             status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         //
         // Assume success, although we might modify it to a buffer
         // overflow warning below (if the buffer isn't big enough
         // to hold ALL of the media descriptions).
         //
         status = STATUS_SUCCESS;
         
         i = 0;
         Irp->IoStatus.Information = 0;

         //
         // Fill in capacities from 512K to 8M
         //
         for (ByteCapacity = 0x80000; ByteCapacity <= 0x800000; ByteCapacity*=2) {            
            if (outputBufferLength < (sizeof(DISK_GEOMETRY) + Irp->IoStatus.Information)) {
               status = STATUS_BUFFER_OVERFLOW;
               break;
            }        

            outputBuffer->MediaType          = FixedMedia;
            outputBuffer->Cylinders.LowPart  = ByteCapacity / (8 * 2 * 512);
            outputBuffer->Cylinders.HighPart = 0;
            outputBuffer->TracksPerCylinder  = 2;
            outputBuffer->SectorsPerTrack    = 8;
            outputBuffer->BytesPerSector     = 512;
            MemCardDump( MEMCARDIOCTL, ("MemCard: Cyls=%x\n", outputBuffer->Cylinders.LowPart));
            
            outputBuffer++;
            Irp->IoStatus.Information += sizeof( DISK_GEOMETRY );
         }        
         break;        
      }
              
      case IOCTL_DISK_CHECK_VERIFY:
         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_DISK_CHECK_VERIFY\n",
                                     DeviceObject, Irp));
         status = STATUS_SUCCESS;
         break;

      case IOCTL_DISK_GET_DRIVE_GEOMETRY: {
         PDISK_GEOMETRY outputBuffer = (PDISK_GEOMETRY) Irp->AssociatedIrp.SystemBuffer;
         
         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_DISK_GET_DRIVE_GEOMETRY\n",
                                     DeviceObject, Irp));
                                        
         if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof( DISK_GEOMETRY ) ) {
            status = STATUS_INVALID_PARAMETER;        
            break;
         }

         status = STATUS_SUCCESS;

         if (!memcardExtension->ByteCapacity) {
            //
            // Just zero out everything.  The
            // caller shouldn't look at it.
            //
            outputBuffer->MediaType = Unknown;
            outputBuffer->Cylinders.LowPart = 0;
            outputBuffer->Cylinders.HighPart = 0;
            outputBuffer->TracksPerCylinder = 0;
            outputBuffer->SectorsPerTrack = 0;
            outputBuffer->BytesPerSector = 0;

         } else {
            //
            // Return the geometry of the current
            // media.
            //
            outputBuffer->MediaType = FixedMedia;
            outputBuffer->Cylinders.HighPart = 0;
            outputBuffer->Cylinders.LowPart  = memcardExtension->ByteCapacity / (8 * 2 * 512);
            outputBuffer->TracksPerCylinder  = 2;
            outputBuffer->SectorsPerTrack    = 8;
            outputBuffer->BytesPerSector     = 512;
         }

         MemCardDump( MEMCARDIOCTL, ("MemCard: Capacity=%.8x => Cyl=%x\n",
                                     memcardExtension->ByteCapacity, outputBuffer->Cylinders.LowPart));
         Irp->IoStatus.Information = sizeof( DISK_GEOMETRY );
         break;
      }

      case IOCTL_DISK_IS_WRITABLE: {
         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_DISK_IS_WRITABLE\n",
                                     DeviceObject, Irp));
                                     
         if ((memcardExtension->PcmciaInterface.IsWriteProtected)(memcardExtension->UnderlyingPDO)) {
            status = STATUS_INVALID_PARAMETER;
         } else {
            status = STATUS_SUCCESS;
         }               
         break;                                        
      }        

      case IOCTL_DISK_VERIFY: {
         PVERIFY_INFORMATION verifyInformation = Irp->AssociatedIrp.SystemBuffer;
         
         if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(VERIFY_INFORMATION)) {
            status = STATUS_INVALID_PARAMETER;        
            break;
         }         

         //NOTE: not implemented
         Irp->IoStatus.Information = verifyInformation->Length;        
         status = STATUS_SUCCESS;
         break;
      }            
      
      case IOCTL_DISK_GET_DRIVE_LAYOUT: {
         PDRIVE_LAYOUT_INFORMATION outputBuffer = (PDRIVE_LAYOUT_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
         
         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_DISK_GET_DRIVE_LAYOUT\n",
                                     DeviceObject, Irp));
                                        
         if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(DRIVE_LAYOUT_INFORMATION) ) {
            status = STATUS_INVALID_PARAMETER;        
            break;
         }
         RtlZeroMemory(outputBuffer, sizeof(DRIVE_LAYOUT_INFORMATION));

         outputBuffer->PartitionCount = 1;
         outputBuffer->PartitionEntry[0].StartingOffset.LowPart = 512;
         outputBuffer->PartitionEntry[0].PartitionLength.LowPart = memcardExtension->ByteCapacity;
         outputBuffer->PartitionEntry[0].RecognizedPartition = TRUE;

         status = STATUS_SUCCESS;
         
         Irp->IoStatus.Information = sizeof(DRIVE_LAYOUT_INFORMATION);
         break;
      }        
      
      case IOCTL_DISK_GET_PARTITION_INFO: {
         PPARTITION_INFORMATION outputBuffer = (PPARTITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer;
         
         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_DISK_GET_PARTITION_INFO\n",
                                     DeviceObject, Irp));
                                     
         if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof( PARTITION_INFORMATION ) ) {
            status = STATUS_INVALID_PARAMETER;
            break;
         } 

         RtlZeroMemory(outputBuffer, sizeof(PARTITION_INFORMATION));
         
         outputBuffer->RecognizedPartition = TRUE;
         outputBuffer->StartingOffset.LowPart = 512;
         outputBuffer->PartitionLength.LowPart = memcardExtension->ByteCapacity;

         status = STATUS_SUCCESS;
         Irp->IoStatus.Information = sizeof( PARTITION_INFORMATION );
         break;
      }
      
      
      case IOCTL_DISK_SET_DRIVE_LAYOUT:
         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_DISK_SET_DRIVE_LAYOUT\n",
                                      DeviceObject, Irp));
      case IOCTL_MOUNTMGR_CHANGE_NOTIFY:
      case IOCTL_MOUNTDEV_LINK_CREATED:
      case IOCTL_MOUNTDEV_LINK_DELETED:
      default: {

         MemCardDump(MEMCARDIOCTL,
             ("MemCard: IOCTL - unsupported device request %.8x\n", irpSp->Parameters.DeviceIoControl.IoControlCode));

         status = STATUS_INVALID_DEVICE_REQUEST;
         break;
         
         //IoSkipCurrentIrpStackLocation( Irp );
         //status = IoCallDriver( memcardExtension->TargetObject, Irp );
         //return status;
      }
   }

   if ( status != STATUS_PENDING ) {

      Irp->IoStatus.Status = status;
      if (!NT_SUCCESS( status ) && IoIsErrorUserInduced( status )) {
         IoSetHardErrorOrVerifyDevice( Irp, DeviceObject );
      }
      MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL comp %.8x\n", DeviceObject, Irp, status));
                                         
      IoCompleteRequest( Irp, IO_NO_INCREMENT );
   }

   MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL <-- %.8x \n", DeviceObject, Irp, status));
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\memcard\memcard.h ===
/*++

Copyright (c) 1991 - 1993 Microsoft Corporation

Module Name:

    memcard.h

Abstract:


Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

Notes:


--*/

#ifndef _MEMCARD_H_
#define _MEMCARD_H_


#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'cmeM')
#endif

//
// The byte in the boot sector that specifies the type of media, and
// the values that it can assume.  We can often tell what type of media
// is in the drive by seeing which controller parameters allow us to read
// the diskette, but some different densities are readable with the same
// parameters so we use this byte to decide the media type.
//
#pragma pack(1)

typedef struct _BOOT_SECTOR_INFO {
    UCHAR   JumpByte;
    UCHAR   Ignore1[2];
    UCHAR   OemData[8];
    USHORT  BytesPerSector;
    UCHAR   SectorsPerCluster;
    USHORT  ReservedSectors;
    UCHAR   NumberOfFATs;
    USHORT  RootEntries;
    USHORT  TotalSectors;
    UCHAR   MediaDescriptor;
    USHORT  SectorsPerFAT;
    USHORT  SectorsPerTrack;
    USHORT  Heads;
    ULONG   BigHiddenSectors;
    ULONG   BigTotalSectors;
} BOOT_SECTOR_INFO, *PBOOT_SECTOR_INFO;

#pragma pack()



//
// Runtime device structures
//
//
// There is one MEMCARD_EXTENSION attached to the device object of each
// MEMCARDpy drive.  Only data directly related to that drive (and the media
// in it) is stored here; common data is in CONTROLLER_DATA.  So the
// MEMCARD_EXTENSION has a pointer to the CONTROLLER_DATA.
//

typedef struct _MEMCARD_EXTENSION {
    PDEVICE_OBJECT          UnderlyingPDO;
    PDEVICE_OBJECT          TargetObject;
    PDEVICE_OBJECT          DeviceObject;
    UNICODE_STRING          DeviceName;
    UNICODE_STRING          LinkName;
    UNICODE_STRING          InterfaceString;

    ULONG                   MediaIndex;
    ULONG                   ByteCapacity;
    BOOLEAN                 IsStarted;
    BOOLEAN                 IsRemoved;
    BOOLEAN                 IsMemoryMapped;
    BOOLEAN                 NoDrive;
    
    ULONGLONG               HostBase;    
    PCHAR                   MemoryWindowBase;
    ULONG                   MemoryWindowSize;
    
    ULONG                   TechnologyIndex;
    
    PCMCIA_INTERFACE_STANDARD PcmciaInterface;
    PCMCIA_BUS_INTERFACE_STANDARD  PcmciaBusInterface;
} MEMCARD_EXTENSION, *PMEMCARD_EXTENSION;


//
// macros for ReadWriteMemory
//

#define MEMCARD_READ(Extension, Offset, Buffer, Size)       \
   MemCardReadWrite(Extension, Offset, Buffer, Size, FALSE)

#define MEMCARD_WRITE(Extension, Offset, Buffer, Size)      \
   MemCardReadWrite(Extension, Offset, Buffer, Size, TRUE)

#endif  // _MEMCARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\memcard\pnp.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

//
// Internal References
//

NTSTATUS
MemCardStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MemCardGetResourceRequirements(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
  );

NTSTATUS
MemCardPnpComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
MemCardGetDeviceParameters(
    IN PMEMCARD_EXTENSION memcardExtension
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MemCardAddDevice)
#pragma alloc_text(PAGE,MemCardPnp)
#pragma alloc_text(PAGE,MemCardStartDevice)
#endif


#define MEMCARD_DEVICE_NAME            L"\\Device\\Memcard"
#define MEMCARD_LINK_NAME              L"\\DosDevices\\Memcard"
#define MEMCARD_REGISTRY_NODRIVE_KEY   L"NoDrive"
#define MEMCARD_REGISTRY_MTD_KEY       L"Mtd"



NTSTATUS
MemCardAddDevice(
   IN      PDRIVER_OBJECT DriverObject,
   IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
   )
/*++

Routine Description:

   This routine is the driver's pnp add device entry point.  It is
   called by the pnp manager to initialize the driver.

   Add device creates and initializes a device object for this FDO and
   attaches to the underlying PDO.

Arguments:

   DriverObject - a pointer to the object that represents this device driver.
   PhysicalDeviceObject - a pointer to the underlying PDO to which this new device will attach.

Return Value:

   If we successfully create a device object, STATUS_SUCCESS is
   returned.  Otherwise, return the appropriate error code.

--*/

{
   NTSTATUS             status = STATUS_SUCCESS;
   PDEVICE_OBJECT       deviceObject;
   PMEMCARD_EXTENSION   memcardExtension;
   WCHAR                NameBuffer[128];
   UNICODE_STRING       deviceName;
   UNICODE_STRING       linkName;
   LONG                 deviceNumber = -1;
   KEVENT               event;
   PIRP                 irp;
   IO_STATUS_BLOCK      statusBlock;
   PIO_STACK_LOCATION   irpSp;

   MemCardDump(MEMCARDSHOW, ("MemCard: AddDevice...\n"));

   //
   //  Create a device.  We will use the first available device name for
   //  this device.
   //
   do {

      swprintf(NameBuffer, L"%s%d", MEMCARD_DEVICE_NAME, ++deviceNumber);
      RtlInitUnicodeString(&deviceName, NameBuffer);
      status = IoCreateDevice(DriverObject,
                                 sizeof(MEMCARD_EXTENSION),
                                 &deviceName,
                                 FILE_DEVICE_DISK,
                                 FILE_REMOVABLE_MEDIA | FILE_DEVICE_SECURE_OPEN,
                                 FALSE,
                                 &deviceObject);

   } while (status == STATUS_OBJECT_NAME_COLLISION);

   if (!NT_SUCCESS(status)) {
      return status;
   }

   memcardExtension = (PMEMCARD_EXTENSION)deviceObject->DeviceExtension;
   RtlZeroMemory(memcardExtension, sizeof(MEMCARD_EXTENSION));

   memcardExtension->DeviceObject = deviceObject;

   //
   //  Save the device name.
   //
   MemCardDump(MEMCARDSHOW | MEMCARDPNP,
               ("MemCard: AddDevice - Device Object Name - %S\n", NameBuffer));

   memcardExtension->DeviceName.Buffer = ExAllocatePool(PagedPool, deviceName.Length);
   if (memcardExtension->DeviceName.Buffer == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto errorExit;
   }
   memcardExtension->DeviceName.Length = 0;
   memcardExtension->DeviceName.MaximumLength = deviceName.Length;
   RtlCopyUnicodeString(&memcardExtension->DeviceName, &deviceName);

   //
   // create the link name
   //

   swprintf(NameBuffer, L"%s%d", MEMCARD_LINK_NAME, deviceNumber);
   RtlInitUnicodeString(&linkName, NameBuffer);

   memcardExtension->LinkName.Buffer = ExAllocatePool(PagedPool, linkName.Length);
   if (memcardExtension->LinkName.Buffer == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto errorExit;
   }
   memcardExtension->LinkName.Length = 0;
   memcardExtension->LinkName.MaximumLength = linkName.Length;
   RtlCopyUnicodeString(&memcardExtension->LinkName, &linkName);

   status = IoCreateSymbolicLink(&memcardExtension->LinkName, &memcardExtension->DeviceName);

   if (!NT_SUCCESS(status)) {
      goto errorExit;
   }

   //
   // Set the PDO for use with PlugPlay functions
   //

   memcardExtension->UnderlyingPDO = PhysicalDeviceObject;

   MemCardDump(MEMCARDSHOW, ("MemCard: AddDevice attaching %p to %p\n", deviceObject, PhysicalDeviceObject));

   memcardExtension->TargetObject = IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

   MemCardDump(MEMCARDSHOW,
               ("MemCard: AddDevice TargetObject = %p\n",
               memcardExtension->TargetObject));


   //
   // Get pcmcia interfaces
   //
   KeInitializeEvent(&event, NotificationEvent, FALSE);
   irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP, memcardExtension->UnderlyingPDO,
                                      NULL, 0, 0, &event, &statusBlock);

   if (!irp) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto errorExit;
   }

   irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
   irp->IoStatus.Information = 0;

   irpSp = IoGetNextIrpStackLocation(irp);

   irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;

   irpSp->Parameters.QueryInterface.InterfaceType= &GUID_PCMCIA_INTERFACE_STANDARD;
   irpSp->Parameters.QueryInterface.Size = sizeof(PCMCIA_INTERFACE_STANDARD);
   irpSp->Parameters.QueryInterface.Version = 1;
   irpSp->Parameters.QueryInterface.Interface = (PINTERFACE) &memcardExtension->PcmciaInterface;

   status = IoCallDriver(memcardExtension->UnderlyingPDO, irp);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
      status = statusBlock.Status;
   }

   if (!NT_SUCCESS(status)) {
      goto errorExit;
   }

   KeInitializeEvent(&event, NotificationEvent, FALSE);
   irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP, memcardExtension->UnderlyingPDO,
                                      NULL, 0, 0, &event, &statusBlock);

   if (!irp) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto errorExit;
   }

   irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
   irp->IoStatus.Information = 0;

   irpSp = IoGetNextIrpStackLocation(irp);

   irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;

   irpSp->Parameters.QueryInterface.InterfaceType= &GUID_PCMCIA_BUS_INTERFACE_STANDARD;
   irpSp->Parameters.QueryInterface.Size = sizeof(PCMCIA_BUS_INTERFACE_STANDARD);
   irpSp->Parameters.QueryInterface.Version = 1;
   irpSp->Parameters.QueryInterface.Interface = (PINTERFACE) &memcardExtension->PcmciaBusInterface;

   status = IoCallDriver(memcardExtension->UnderlyingPDO, irp);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
      status = statusBlock.Status;
   }

   if (!NT_SUCCESS(status)) {
      goto errorExit;
   }

   status = MemCardGetDeviceParameters(memcardExtension);
   if (!NT_SUCCESS(status)) {
      goto errorExit;
   }

   //
   // done
   //

   deviceObject->Flags |= DO_DIRECT_IO | DO_POWER_PAGABLE;
   deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

   memcardExtension->IsStarted = FALSE;
   memcardExtension->IsRemoved = FALSE;

   return STATUS_SUCCESS;

errorExit:

   if (memcardExtension->DeviceName.Buffer != NULL) {
      ExFreePool(memcardExtension->DeviceName.Buffer);
   }

   if (memcardExtension->LinkName.Buffer != NULL) {
      IoDeleteSymbolicLink(&memcardExtension->LinkName);
      ExFreePool(memcardExtension->LinkName.Buffer);
   }

   if (memcardExtension->TargetObject) {
      IoDetachDevice(memcardExtension->TargetObject);
   }

   IoDeleteDevice(deviceObject);
   return status;
}



NTSTATUS
MemCardPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
   )
/*++

Routine Description:

   Main PNP irp dispatch routine

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   status

--*/
{
   PIO_STACK_LOCATION irpSp;
   PMEMCARD_EXTENSION memcardExtension;
   NTSTATUS status = STATUS_SUCCESS;
   ULONG i;


   memcardExtension = DeviceObject->DeviceExtension;

   irpSp = IoGetCurrentIrpStackLocation(Irp);

   MemCardDump(MEMCARDPNP, ("MemCard: DO %.8x Irp %.8x PNP func %x\n",
                           DeviceObject, Irp, irpSp->MinorFunction));

   if (memcardExtension->IsRemoved) {

      //
      // Since the device is stopped, but we don't hold IRPs,
      // this is a surprise removal. Just fail it.
      //
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_DELETE_PENDING;
      IoCompleteRequest (Irp, IO_NO_INCREMENT);
      return STATUS_DELETE_PENDING;
   }

   switch (irpSp->MinorFunction) {

   case IRP_MN_START_DEVICE:

      status = MemCardStartDevice(DeviceObject, Irp);
      break;

   case IRP_MN_QUERY_STOP_DEVICE:
   case IRP_MN_QUERY_REMOVE_DEVICE:

      if (irpSp->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) {
         MemCardDump(MEMCARDPNP,("MemCard: IRP_MN_QUERY_STOP_DEVICE\n"));
      } else {
         MemCardDump(MEMCARDPNP,("MemCard: IRP_MN_QUERY_REMOVE_DEVICE\n"));
      }

      if (!memcardExtension->IsStarted) {
         //
         // If we aren't started, we'll just pass the irp down.
         //
         IoSkipCurrentIrpStackLocation (Irp);
         status = IoCallDriver(memcardExtension->TargetObject, Irp);

         return status;
      }


      Irp->IoStatus.Status = STATUS_SUCCESS;
      IoSkipCurrentIrpStackLocation(Irp);
      status = IoCallDriver(memcardExtension->TargetObject, Irp);

      break;

   case IRP_MN_CANCEL_STOP_DEVICE:
   case IRP_MN_CANCEL_REMOVE_DEVICE:

      if (irpSp->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE) {
         MemCardDump(MEMCARDPNP,("MemCard: IRP_MN_CANCEL_STOP_DEVICE\n"));
      } else {
         MemCardDump(MEMCARDPNP,("MemCard: IRP_MN_CANCEL_REMOVE_DEVICE\n"));
      }

      if (!memcardExtension->IsStarted) {

         //
         // Nothing to do, just pass the irp down:
         // no need to start the device
         //
         IoSkipCurrentIrpStackLocation (Irp);
         status = IoCallDriver(memcardExtension->TargetObject, Irp);

      } else  {

         KEVENT doneEvent;

         //
         // Set the status to STATUS_SUCCESS
         //
         Irp->IoStatus.Status = STATUS_SUCCESS;

         //
         // We need to wait for the lower drivers to do their job.
         //
         IoCopyCurrentIrpStackLocationToNext (Irp);

         //
         // Clear the event: it will be set in the completion
         // routine.
         //
         KeInitializeEvent(&doneEvent,
                            SynchronizationEvent,
                            FALSE);

         IoSetCompletionRoutine(Irp,
                                 MemCardPnpComplete,
                                 &doneEvent,
                                 TRUE, TRUE, TRUE);

         status = IoCallDriver(memcardExtension->TargetObject, Irp);

         if (status == STATUS_PENDING) {

             KeWaitForSingleObject(&doneEvent,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

             status = Irp->IoStatus.Status;
         }

         //
         // We must now complete the IRP, since we stopped it in the
         // completetion routine with MORE_PROCESSING_REQUIRED.
         //
         Irp->IoStatus.Status = status;
         Irp->IoStatus.Information = 0;
         IoCompleteRequest (Irp, IO_NO_INCREMENT);
      }
      break;

   case IRP_MN_STOP_DEVICE:

       MemCardDump(MEMCARDPNP,("MemCard: IRP_MN_STOP_DEVICE\n"));

       if (memcardExtension->IsMemoryMapped) {
           MmUnmapIoSpace(memcardExtension->MemoryWindowBase, memcardExtension->MemoryWindowSize);
           memcardExtension->MemoryWindowBase = 0;
           memcardExtension->MemoryWindowSize = 0;
           memcardExtension->IsMemoryMapped = FALSE;
       }

       memcardExtension->IsStarted = FALSE;

       Irp->IoStatus.Status = STATUS_SUCCESS;
       IoSkipCurrentIrpStackLocation(Irp);
       status = IoCallDriver(memcardExtension->TargetObject, Irp);

       break;

   case IRP_MN_REMOVE_DEVICE:

       MemCardDump(MEMCARDPNP,("MemCard: IRP_MN_REMOVE_DEVICE\n"));

       //
       // We need to mark the fact that we don't hold requests first, since
       // we asserted earlier that we are holding requests only if
       // we're not removed.
       //
       memcardExtension->IsStarted = FALSE;
       memcardExtension->IsRemoved = TRUE;

       //
       //  Forward this Irp to the underlying PDO
       //
       IoSkipCurrentIrpStackLocation(Irp);
       Irp->IoStatus.Status = STATUS_SUCCESS;
       status = IoCallDriver(memcardExtension->TargetObject, Irp);

       //
       //  Send notification that we are going away.
       //
       if (memcardExtension->InterfaceString.Buffer != NULL) {

           IoSetDeviceInterfaceState(&memcardExtension->InterfaceString,
                                      FALSE);

           RtlFreeUnicodeString(&memcardExtension->InterfaceString);
           RtlInitUnicodeString(&memcardExtension->InterfaceString, NULL);
       }

       //
       // Remove our link
       //
       IoDeleteSymbolicLink(&memcardExtension->LinkName);

       RtlFreeUnicodeString(&memcardExtension->LinkName);
       RtlInitUnicodeString(&memcardExtension->LinkName, NULL);

       RtlFreeUnicodeString(&memcardExtension->DeviceName);
       RtlInitUnicodeString(&memcardExtension->DeviceName, NULL);

       //
       //  Detatch from the undelying device.
       //
       IoDetachDevice(memcardExtension->TargetObject);

       //
       //  And delete the device.
       //
       IoDeleteDevice(DeviceObject);

       break;


   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
      status = MemCardGetResourceRequirements(DeviceObject, Irp);
      break;


   default:
       MemCardDump(MEMCARDPNP, ("MemCardPnp: Unsupported PNP Request %x - Irp: %p\n",irpSp->MinorFunction, Irp));
       IoSkipCurrentIrpStackLocation(Irp);
       status = IoCallDriver(memcardExtension->TargetObject, Irp);
   }

   return status;
}



NTSTATUS
MemCardStartDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

   Start device routine

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   status

--*/
{
   NTSTATUS status;
   NTSTATUS pnpStatus;
   KEVENT doneEvent;
   PCM_RESOURCE_LIST ResourceList;
   PCM_RESOURCE_LIST TranslatedResourceList;
   PCM_PARTIAL_RESOURCE_LIST        partialResourceList, partialTranslatedList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR  partialResourceDesc, partialTranslatedDesc;
   PCM_FULL_RESOURCE_DESCRIPTOR     fullResourceDesc, fullTranslatedDesc;

   PMEMCARD_EXTENSION memcardExtension = (PMEMCARD_EXTENSION)DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

   MemCardDump(MEMCARDPNP,("MemCard: StartDevice\n"));
   MemCardDump(MEMCARDSHOW, ("        AllocatedResources = %08x\n",irpSp->Parameters.StartDevice.AllocatedResources));
   MemCardDump(MEMCARDSHOW, ("        AllocatedResourcesTranslated = %08x\n",irpSp->Parameters.StartDevice.AllocatedResourcesTranslated));

   //
   // First we must pass this Irp on to the PDO.
   //
   KeInitializeEvent(&doneEvent, NotificationEvent, FALSE);

   IoCopyCurrentIrpStackLocationToNext(Irp);

   IoSetCompletionRoutine(Irp,
                           MemCardPnpComplete,
                           &doneEvent,
                           TRUE, TRUE, TRUE);

   status = IoCallDriver(memcardExtension->TargetObject, Irp);

   if (status == STATUS_PENDING) {

       status = KeWaitForSingleObject(&doneEvent,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         NULL);

       ASSERT(status == STATUS_SUCCESS);

       status = Irp->IoStatus.Status;
   }

   if (!NT_SUCCESS(status)) {
      Irp->IoStatus.Status = status;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return status;
   }

   //
   // Parse the resources to map the memory window
   //
   ResourceList = irpSp->Parameters.StartDevice.AllocatedResources;
   TranslatedResourceList = irpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

   fullResourceDesc = &ResourceList->List[0];
   fullTranslatedDesc = &TranslatedResourceList->List[0];

   partialResourceList   = &fullResourceDesc->PartialResourceList;
   partialTranslatedList = &fullTranslatedDesc->PartialResourceList;

   partialResourceDesc   = partialResourceList->PartialDescriptors;
   partialTranslatedDesc = partialTranslatedList->PartialDescriptors;

   if (partialResourceDesc->Type != CmResourceTypeMemory) {
      ASSERT(partialResourceDesc->Type == CmResourceTypeMemory);
      Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return STATUS_INVALID_PARAMETER;
   }

   memcardExtension->HostBase = partialTranslatedDesc->u.Memory.Start.QuadPart;
   memcardExtension->MemoryWindowSize = partialTranslatedDesc->u.Memory.Length;
   //
   //

   switch (partialTranslatedDesc->Type) {

   case CmResourceTypeMemory:
      memcardExtension->MemoryWindowBase = MmMapIoSpace(partialTranslatedDesc->u.Memory.Start,
                                                       partialTranslatedDesc->u.Memory.Length,
                                                       FALSE);
      memcardExtension->IsMemoryMapped = TRUE;
      break;

   case CmResourceTypePort:
      memcardExtension->MemoryWindowBase = (PUCHAR) partialResourceDesc->u.Port.Start.QuadPart;
      memcardExtension->IsMemoryMapped = FALSE;
      break;

   default:
      ASSERT(FALSE);
      Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return STATUS_INVALID_PARAMETER;
   }

   //
   // Try to get the capacity of the card
   //
   memcardExtension->ByteCapacity = MemCardGetCapacity(memcardExtension);

   //
   // If we can't get the capacity, the must be broken in some way
   //

   if (!memcardExtension->ByteCapacity) {
      Irp->IoStatus.Status = STATUS_UNRECOGNIZED_MEDIA;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return STATUS_UNRECOGNIZED_MEDIA;
   }


   if (!memcardExtension->NoDrive) {
      pnpStatus = IoRegisterDeviceInterface(memcardExtension->UnderlyingPDO,
                                            (LPGUID)&MOUNTDEV_MOUNTED_DEVICE_GUID,
                                            NULL,
                                            &memcardExtension->InterfaceString);

      if ( NT_SUCCESS(pnpStatus) ) {

          pnpStatus = IoSetDeviceInterfaceState(&memcardExtension->InterfaceString,
                                                TRUE);
      }
   }

   memcardExtension->IsStarted = TRUE;

   Irp->IoStatus.Status = status;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   return status;
}


NTSTATUS
MemCardPnpComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
  )
/*++
Routine Description:
    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.

--*/
{

    KeSetEvent ((PKEVENT) Context, 1, FALSE);
    // No special priority
    // No Wait

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}

NTSTATUS
MemCardGetResourceRequirements(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

   Provides a memory resource requirement in case the bus driver
   doesn't.

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   status

--*/
{
   NTSTATUS status;
   KEVENT doneEvent;
   PIO_RESOURCE_REQUIREMENTS_LIST ioResourceRequirementsList;
   PIO_RESOURCE_LIST ioResourceList;
   PIO_RESOURCE_DESCRIPTOR ioResourceDesc;
   PMEMCARD_EXTENSION memcardExtension = (PMEMCARD_EXTENSION)DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
   ULONG listSize;

   //
   // First we must pass this Irp on to the PDO.
   //
   KeInitializeEvent(&doneEvent, NotificationEvent, FALSE);

   IoCopyCurrentIrpStackLocationToNext(Irp);

   IoSetCompletionRoutine(Irp,
                          MemCardPnpComplete,
                          &doneEvent,
                          TRUE, TRUE, TRUE);

   status = IoCallDriver(memcardExtension->TargetObject, Irp);

   if (status == STATUS_PENDING) {

      status = KeWaitForSingleObject(&doneEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

      ASSERT(status == STATUS_SUCCESS);

      status = Irp->IoStatus.Status;
   }

   if (NT_SUCCESS(status) && (Irp->IoStatus.Information == 0)) {

      listSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST);

      ioResourceRequirementsList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, listSize);

      RtlZeroMemory(ioResourceRequirementsList, listSize);

      ioResourceRequirementsList->ListSize = listSize;
      ioResourceRequirementsList->AlternativeLists = 1;
      //
      // NOTE: not quite sure if the following values are the best choices
      //
      ioResourceRequirementsList->InterfaceType = Isa;
      ioResourceRequirementsList->BusNumber = 0;
      ioResourceRequirementsList->SlotNumber = 0;

      ioResourceList = &ioResourceRequirementsList->List[0];

      ioResourceList->Version  = 1;
      ioResourceList->Revision = 1;
      ioResourceList->Count    = 1;

      ioResourceDesc = &ioResourceList->Descriptors[0];
      ioResourceDesc->Option = 0;
      ioResourceDesc->Type  =  CmResourceTypeMemory;
      ioResourceDesc->Flags =  CM_RESOURCE_MEMORY_READ_WRITE;
      ioResourceDesc->ShareDisposition =  CmResourceShareDeviceExclusive;
      ioResourceDesc->u.Memory.MinimumAddress.QuadPart = 0;
      ioResourceDesc->u.Memory.MaximumAddress.QuadPart = (ULONGLONG)-1;
      ioResourceDesc->u.Memory.Length = 0x2000;
      ioResourceDesc->u.Memory.Alignment = 0x2000;

      Irp->IoStatus.Information = (ULONG_PTR)ioResourceRequirementsList;
   }
   Irp->IoStatus.Status = status;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   return status;
}


NTSTATUS
MemCardGetDeviceParameters(
    IN PMEMCARD_EXTENSION memcardExtension
    )
/*++

Routine Description:

   Loads device specific parameters from the registry

Arguments:

   memcardExtension - device extension of the device

Return Value:

   status

--*/
{
   NTSTATUS status;
   HANDLE instanceHandle;
   UNICODE_STRING KeyName;
   UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 32*sizeof(UCHAR)];
   PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
   ULONG length;

   if (!memcardExtension->UnderlyingPDO) {
      return STATUS_UNSUCCESSFUL;
   }

   status = IoOpenDeviceRegistryKey(memcardExtension->UnderlyingPDO,
                                    PLUGPLAY_REGKEY_DRIVER,
                                    KEY_READ,
                                    &instanceHandle
                                    );
   if (!NT_SUCCESS(status)) {
      return(status);
   }

   //
   // Read in the "NoDrive" parameter
   //

   RtlInitUnicodeString(&KeyName, MEMCARD_REGISTRY_NODRIVE_KEY);

   status =  ZwQueryValueKey(instanceHandle,
                             &KeyName,
                             KeyValuePartialInformation,
                             value,
                             sizeof(buffer),
                             &length);

   if (NT_SUCCESS(status)) {
      memcardExtension->NoDrive = (BOOLEAN) (*(PULONG)(value->Data) != 0);
   }

   //
   // Read in the MTD name
   //

   RtlInitUnicodeString(&KeyName, MEMCARD_REGISTRY_MTD_KEY);

   status =  ZwQueryValueKey(instanceHandle,
                             &KeyName,
                             KeyValuePartialInformation,
                             value,
                             sizeof(buffer),
                             &length);

   if (NT_SUCCESS(status)) {
      UNICODE_STRING TechnologyName;

      RtlInitUnicodeString(&TechnologyName, (PVOID)value->Data);

      status = MemCardInitializeMtd(memcardExtension, &TechnologyName);
   }

   ZwClose(instanceHandle);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\memcard\mtd.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    mtd.c

Abstract:

    This module supplies the structure for simple "mtd" functionality
    for memory card devices.

    Note that to keep the driver simple, and because of the limited
    number of memory technologies, the code supplied here does not
    implement true mtd capability where an independent device driver
    is loaded. Instead, the driver allows a device to name its technology,
    but the choices are limited to what is directly implemented here.
    
    Alternatively, this could be extended to add a p-code style interpreter
    to allow for greater flexibility, but that's not in here yet.    

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

//
// Internal References
//

VOID
MtdStandardRead(
   IN PVOID TargetBuffer,
   IN CONST PVOID DeviceBuffer,
   IN ULONG Length
   );
   
VOID
MtdSramWrite(
   IN CONST PVOID SourceBuffer,
   IN PVOID DeviceBuffer,
   IN ULONG Length
   );

VOID
MtdUndefinedRead(
   IN PVOID TargetBuffer,
   IN CONST PVOID DeviceBuffer,
   IN ULONG Length
   );
   
VOID
MtdUndefinedWrite(
   IN CONST PVOID SourceBuffer,
   IN PVOID DeviceBuffer,
   IN ULONG Length
   );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MemCardInitializeMtd)
#pragma alloc_text(PAGE,MtdStandardRead)
#pragma alloc_text(PAGE,MtdSramWrite)
#endif


typedef struct _MTD_ENTRY {
   PCWSTR TechnologyName;
   
   VOID (*MtdReadProc)(
              IN PVOID TargetBuffer,
              IN CONST PVOID DeviceBuffer,
              IN ULONG Length
              );
   
   VOID (*MtdWriteProc)(
              IN PVOID TargetBuffer,
              IN CONST PVOID DeviceBuffer,
              IN ULONG Length
              );

} MTD_ENTRY, *PMTD_ENTRY;              
   

MTD_ENTRY MtdTable[] = {
   L"UNDEFINED", MtdUndefinedRead, MtdUndefinedWrite,
   L"SRAM", MtdStandardRead, MtdSramWrite,
   NULL, NULL, NULL
   };
   


NTSTATUS
MemCardInitializeMtd(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN PUNICODE_STRING TechnologyName
   )
/*++

Routine Description:

Arguments:

   device extension for the card

Return Value:


--*/
{
   ULONG i = 0;
   
   memcardExtension->TechnologyIndex = 0;
   
   while(MtdTable[i].TechnologyName) {
      UNICODE_STRING tableName;
      
      RtlInitUnicodeString(&tableName, MtdTable[i].TechnologyName);
      
      if (!RtlCompareUnicodeString(TechnologyName, &tableName, TRUE)) {
         memcardExtension->TechnologyIndex = i;
         return STATUS_SUCCESS;  
      }
      
      i++;
   }
   return STATUS_INVALID_PARAMETER;
}


VOID
MemCardMtdRead(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN PVOID TargetBuffer,
   IN CONST PVOID DeviceBuffer,
   IN ULONG Length
   )
{
   (*MtdTable[memcardExtension->TechnologyIndex].MtdReadProc)(TargetBuffer, DeviceBuffer, Length);
}
   
VOID
MemCardMtdWrite(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN CONST PVOID SourceBuffer,
   IN PVOID DeviceBuffer,
   IN ULONG Length
   )
{
   (*MtdTable[memcardExtension->TechnologyIndex].MtdWriteProc)(SourceBuffer, DeviceBuffer, Length);
}   


VOID
MtdUndefinedRead(
   IN PVOID TargetBuffer,
   IN CONST PVOID DeviceBuffer,
   IN ULONG Length
   )
{
}
   
VOID
MtdUndefinedWrite(
   IN CONST PVOID SourceBuffer,
   IN PVOID DeviceBuffer,
   IN ULONG Length
   )
{
}

VOID
MtdStandardRead(
   IN PVOID TargetBuffer,
   IN CONST PVOID DeviceBuffer,
   IN ULONG Length
   )
{
   RtlCopyMemory(TargetBuffer, DeviceBuffer, Length);
}   
   
VOID
MtdSramWrite(
   IN CONST PVOID SourceBuffer,
   IN PVOID DeviceBuffer,
   IN ULONG Length
   )
{
   RtlCopyMemory(DeviceBuffer, SourceBuffer, Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\memcard\utils.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    utils.c

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

//
// Internal References
//

ULONG
MemCardGetCapacityFromCIS(
   IN PMEMCARD_EXTENSION memcardExtension
   );
   
ULONG
MemCardGetCapacityFromBootSector(
   IN PMEMCARD_EXTENSION memcardExtension
   );

ULONG
MemCardProbeForCapacity(
   IN PMEMCARD_EXTENSION memcardExtension
   );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MemCardGetCapacityFromCIS)
#pragma alloc_text(PAGE,MemCardGetCapacityFromBootSector)
#pragma alloc_text(PAGE,MemCardProbeForCapacity)
#endif



ULONG
MemCardGetCapacity(
   IN PMEMCARD_EXTENSION memcardExtension
   )
/*++

Routine Description:

Arguments:

   device extension for the card

Return Value:


--*/
{
   ULONG capacity;
   
   capacity = MemCardGetCapacityFromCIS(memcardExtension);
   
   if (capacity) {
      return capacity;
   }
   
   capacity = MemCardGetCapacityFromBootSector(memcardExtension);
   
   if (capacity) {
      return capacity;
   }
   
   return MemCardProbeForCapacity(memcardExtension);   
}



ULONG
MemCardGetCapacityFromBootSector(
   IN PMEMCARD_EXTENSION memcardExtension
   )
/*++

Routine Description:

Arguments:

   device extension for the card

Return Value:


--*/

{
   NTSTATUS status;
   BOOT_SECTOR_INFO BootSector;
   ULONG capacity = 0;
   
   status = MEMCARD_READ(memcardExtension, 0, &BootSector, sizeof(BootSector));
   
   if (NT_SUCCESS(status)) {

#define BYTES_PER_SECTOR 512
      //
      // see if this really looks like a boot sector
      // These are the same tests done in the win9x sram support
      //
      if ((BootSector.JumpByte == 0xE9 || BootSector.JumpByte == 0xEB) &&
      
          BootSector.BytesPerSector == BYTES_PER_SECTOR &&
      
          BootSector.SectorsPerCluster != 0 &&
          
          BootSector.ReservedSectors == 1 &&
          
         (BootSector.NumberOfFATs == 1 || BootSector.NumberOfFATs == 2) &&
         
          BootSector.RootEntries != 0 && (BootSector.RootEntries & 15) == 0 &&
          
         (BootSector.TotalSectors != 0 || BootSector.BigTotalSectors != 0) &&
         
          BootSector.SectorsPerFAT != 0 &&
          
          BootSector.SectorsPerTrack != 0 &&
          
          BootSector.Heads != 0 &&
          
          BootSector.MediaDescriptor >= 0xF0) {

         //
         // Finally it appears valid, return total size of region.
         //
         capacity = BootSector.TotalSectors * BYTES_PER_SECTOR;
   
      }
   }
   return capacity;
}



ULONG
MemCardGetCapacityFromCIS(
   IN PMEMCARD_EXTENSION memcardExtension
   )
/*++

Routine Description:

   This is a quick and dirty routine to read the tuples of the card, if they
   exist, to get the capacity.

Arguments:

   device extension for the card

Return Value:

   The # of bytes of memory on the device

--*/

{
   UCHAR tupleData[16];
   ULONG bytesRead;
   ULONG dataCount;
   ULONG unitSize;
   ULONG unitCount;
   ULONG i;
   
   //
   // get device capacity
   // all this stuff should really be in the bus driver
   //
   
   bytesRead = (memcardExtension->PcmciaBusInterface.ReadConfig)(memcardExtension->UnderlyingPDO, 
                                                                 PCCARD_ATTRIBUTE_MEMORY,
                                                                 tupleData,
                                                                 0,
                                                                 16);

   if ((bytesRead != 16) || (tupleData[0] != 1)){
      return 0;
   }
   
   dataCount = (ULONG)tupleData[1];                                                                       

   if ((dataCount < 2) || (dataCount>14)){   
      return 0;
   }

   i = 3;
   if ((tupleData[2] & 7) == 7) {
      while(tupleData[i] & 0x80) {
         if ((i-2) > dataCount) {
            return 0;
         }
         i++;
      }
   }
   
   if ((tupleData[i]&7) == 7) {
      return 0;
   }      
   unitSize = 512 << ((tupleData[i]&7)*2);
   unitCount = (tupleData[i]>>3)+1;
   
   return(unitCount * unitSize);
}


ULONG
MemCardProbeForCapacity(
   IN PMEMCARD_EXTENSION memcardExtension
   )
/*++

Routine Description:

   Since we were unable to determine the card capacity through other means, 
   here we actually write stuff out on the card to check how big it is.
   This algorithm for testing the card capacity was ported from win9x.

Arguments:

   device extension for the card

Return Value:

   byte capacity of device

--*/
{
   NTSTATUS status;
   ULONG capacity = 0;
   USHORT origValue, ChkValue, StartValue;
   USHORT mcSig = 'Mc';
   USHORT zeroes = 0;
#define SRAM_BLK_SIZE (16*1024)   
   ULONG CardOff = SRAM_BLK_SIZE;
   USHORT CurValue;

   if ((memcardExtension->PcmciaInterface.IsWriteProtected)(memcardExtension->UnderlyingPDO)) {
      return 0;
   }

   //
   // 
   if (!NT_SUCCESS(MEMCARD_READ (memcardExtension, 0, &origValue, sizeof(origValue))) ||
       !NT_SUCCESS(MEMCARD_WRITE(memcardExtension, 0, &mcSig,     sizeof(mcSig)))     ||
       !NT_SUCCESS(MEMCARD_READ (memcardExtension, 0, &ChkValue,  sizeof(ChkValue))))   {
      return 0;
   }   

   if (ChkValue != mcSig) {
      //
      // not sram
      //
      return 0;
   }

   for (;;) {
      if (!NT_SUCCESS(MEMCARD_READ (memcardExtension, CardOff, &CurValue, sizeof(CurValue))) ||
          !NT_SUCCESS(MEMCARD_WRITE(memcardExtension, CardOff, &zeroes,   sizeof(zeroes)))   ||
          !NT_SUCCESS(MEMCARD_READ (memcardExtension, CardOff, &ChkValue, sizeof(ChkValue))) ||
          !NT_SUCCESS(MEMCARD_READ (memcardExtension, 0, &StartValue, sizeof(StartValue)))) {
         break;
      }

      // We stop when either we can't write 0 anymore or the 0
      // has wrapped over the 0x9090 at card offset 0

      if (ChkValue != zeroes || StartValue == zeroes) {
         capacity = CardOff;
         break;
      }

      // Restore the saved value from the start of the block.

      if (!NT_SUCCESS(MEMCARD_WRITE(memcardExtension, CardOff, &CurValue, sizeof(CurValue)))) {
         break;
      }
      CardOff += SRAM_BLK_SIZE;       // increment to the next block
   }   
   
   //
   // try to restore original value
   //   
   MEMCARD_WRITE(memcardExtension, 0, &origValue, sizeof(origValue));
   
   return capacity;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\memcard\power.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    power.c

Abstract:

    This module contains code to handle IRP_MJ_POWER dispatches for
    PCMCIA memory card devices

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

NTSTATUS
MemCardSetFdoPowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   );

NTSTATUS
MemCardSetFdoSystemPowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   );

VOID
MemCardFdoSystemPowerDeviceIrpComplete(
   IN PDEVICE_OBJECT Fdo,
   IN UCHAR MinorFunction,
   IN POWER_STATE PowerState,
   IN PVOID Context,
   IN PIO_STATUS_BLOCK IoStatus
   );
   
NTSTATUS
MemCardSetFdoDevicePowerState (
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MemCardPower)
#endif


NTSTATUS
MemCardPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
   PMEMCARD_EXTENSION memcardExtension = DeviceObject->DeviceExtension;

    MemCardDump( MEMCARDSHOW, ("MemCardPower:\n"));

    switch (irpSp->MinorFunction) {
    
    case IRP_MN_SET_POWER:
         status = MemCardSetFdoPowerState(DeviceObject, Irp);
         break;

    case IRP_MN_QUERY_POWER:
         //
         // No need to send this irp down
         //
         status = STATUS_SUCCESS;
         PoStartNextPowerIrp(Irp);
         Irp->IoStatus.Status = status;
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;
          
    default: 

         PoStartNextPowerIrp( Irp );
         IoSkipCurrentIrpStackLocation(Irp);
         status = PoCallDriver(memcardExtension->TargetObject, Irp);
         break;
    }

    return status;
}



NTSTATUS
MemCardSetFdoPowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description

   Dispatches the IRP based on whether a system power state
   or device power state transition is requested

Arguments

   DeviceObject      - Pointer to the functional device object for the pcmcia controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS           status;

   if (irpStack->Parameters.Power.Type == DevicePowerState) {
      status = MemCardSetFdoDevicePowerState(Fdo, Irp);

   } else if (irpStack->Parameters.Power.Type == SystemPowerState) {
      status = MemCardSetFdoSystemPowerState(Fdo, Irp);

   } else {
      status = STATUS_NOT_SUPPORTED;
      Irp->IoStatus.Status = status;
      PoStartNextPowerIrp (Irp);
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   }

   return status;
}


NTSTATUS
MemCardSetFdoSystemPowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description

   Handles system power state IRPs for the pccard controller.

Arguments

   DeviceObject      - Pointer to the functional device object for the pcmcia controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
   PMEMCARD_EXTENSION memcardExtension = Fdo->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   SYSTEM_POWER_STATE newSystemState = irpStack->Parameters.Power.State.SystemState;
   NTSTATUS           status = STATUS_SUCCESS;
   POWER_STATE        powerState;

   MemCardDump( MEMCARDSHOW, ("MemCard: Set System Power(%d)\n", newSystemState));
   ASSERT(irpStack->Parameters.Power.Type == SystemPowerState);

   //
   // Find the device power state corresponding to this system state
   //
   if (newSystemState == PowerSystemWorking) {
      powerState.DeviceState = PowerDeviceD0;
   } else {
      powerState.DeviceState = PowerDeviceD3;
   }      
   //
   // Send a D IRP to the stack if necessary
   //
   MemCardDump( MEMCARDSHOW, ("MemCard: generating D irp (%d)\n", powerState.DeviceState));
       
   status = PoRequestPowerIrp(memcardExtension->DeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              MemCardFdoSystemPowerDeviceIrpComplete,
                              Irp,
                              NULL
                              );
   return status;
}


VOID
MemCardFdoSystemPowerDeviceIrpComplete(
   IN PDEVICE_OBJECT Fdo,
   IN UCHAR MinorFunction,
   IN POWER_STATE PowerState,
   IN PVOID Context,
   IN PIO_STATUS_BLOCK IoStatus
   )
/*++

Routine Description

   This routine is called on completion of a D irp generated by an S irp.

Parameters

   DeviceObject   -  Pointer to the Fdo for the PCMCIA controller
   MinorFunction  -  Minor function of the IRP_MJ_POWER request
   PowerState     -  Power state requested 
   Context        -  Context passed in to the completion routine
   IoStatus       -  Pointer to the status block which will contain
                     the returned status
Return Value

   Status

--*/
{
   PMEMCARD_EXTENSION memcardExtension = Fdo->DeviceExtension;
   PIRP Irp = Context;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   
   ASSERT(NT_SUCCESS(IoStatus->Status));
   
   PoSetPowerState (Fdo, SystemPowerState, irpStack->Parameters.Power.State);
   
   //
   // Send the S IRP to the pdo
   //
   PoStartNextPowerIrp (Irp);
   IoSkipCurrentIrpStackLocation(Irp);
   PoCallDriver(memcardExtension->TargetObject, Irp);
}



NTSTATUS
MemCardSetFdoDevicePowerState (
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description

   Handles device power state IRPs for the pccard controller.

Arguments

   DeviceObject      - Pointer to the functional device object for the pcmcia controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
   NTSTATUS           status;
   PMEMCARD_EXTENSION memcardExtension = Fdo->DeviceExtension;
   MemCardDump( MEMCARDSHOW, ("MemCard: Set Device Power\n"));

   PoStartNextPowerIrp (Irp);
   IoSkipCurrentIrpStackLocation(Irp);
   status = PoCallDriver(memcardExtension->TargetObject, Irp);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\data.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    data.c

Abstract:

    Data definitions for discardable/pageable data

Author:
    Ravisankar Pudipeddi (ravisp) -  1 Feb 1997
    Neil Sandlin (neilsa) June 1 1999

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg ("INIT")
#endif
//
// Beginning of Init Data
//

//
// Global registry values (in pcmcia\\parameters)
//
#define PCMCIA_REGISTRY_INTERRUPT_MASK_VALUE         L"ForcedInterruptMask"
#define PCMCIA_REGISTRY_INTERRUPT_FILTER_VALUE       L"FilterInterruptMask"
#define PCMCIA_REGISTRY_ATTRIBUTE_MEMORY_LO_VALUE    L"AttributeMemoryLow"
#define PCMCIA_REGISTRY_ATTRIBUTE_MEMORY_HI_VALUE    L"AttributeMemoryHigh"
#define PCMCIA_REGISTRY_ATTRIBUTE_MEMORY_SIZE_VALUE L"AttributeMemorySize"
#define PCMCIA_REGISTRY_POWER_POLICY_VALUE           L"PowerPolicy"
#define PCMCIA_REGISTRY_FORCE_CTLR_DEVICE_WAKE       L"ForceControllerDeviceWake"
#define PCMCIA_REGISTRY_USE_POLLED_CSC_VALUE         L"ForcePolledMode"
#define PCMCIA_REGISTRY_DISABLE_ISA_PCI_ROUTING      L"DisableIsaToPciRouting"
#define PCMCIA_REGISTRY_DEFAULT_ROUTE_R2_TO_ISA      L"DefaultRouteToIsa"
#define PCMCIA_REGISTRY_DISABLE_ACPI_NAMESPACE_CHK  L"DisableAcpiNameSpaceCheck"
#define PCMCIA_REGISTRY_IRQ_ROUTE_PCI_CTLR           L"IrqRouteToPciController"
#define PCMCIA_REGISTRY_IRQ_ROUTE_ISA_CTLR           L"IrqRouteToIsaController"
#define PCMCIA_REGISTRY_IRQ_ROUTE_PCI_LOC            L"IrqRouteToPciLocation"
#define PCMCIA_REGISTRY_IRQ_ROUTE_ISA_LOC            L"IrqRouteToIsaLocation"
#define PCMCIA_REGISTRY_REPORT_MTD0002_AS_ERROR      L"ReportMTD0002AsError"
#define PCMCIA_REGISTRY_DEBUG_MASK                       L"DebugMask"
#define PCMCIA_REGISTRY_EVENT_DPC_DELAY              L"EventDpcDelay"
#define PCMCIA_REGISTRY_IOCTL_INTERFACE              L"IoctlInterface"

//
// Table which defines global registry settings
//
//          RegistryName                                    Internal Variable                Default Value
//          ------------                                    -----------------                -------------
GLOBAL_REGISTRY_INFORMATION GlobalRegistryInfo[] = {
#if DBG
    PCMCIA_REGISTRY_DEBUG_MASK,                     &PcmciaDebugMask,               1,
#endif
    PCMCIA_REGISTRY_INTERRUPT_MASK_VALUE,           &globalOverrideIrqMask,         0,
    PCMCIA_REGISTRY_INTERRUPT_FILTER_VALUE,     &globalFilterIrqMask,           0,
    PCMCIA_REGISTRY_ATTRIBUTE_MEMORY_LO_VALUE,  &globalAttributeMemoryLow,  PCMCIA_DEFAULT_ATTRIBUTE_MEMORY_LOW,
    PCMCIA_REGISTRY_ATTRIBUTE_MEMORY_HI_VALUE,  &globalAttributeMemoryHigh, PCMCIA_DEFAULT_ATTRIBUTE_MEMORY_HIGH,
    PCMCIA_REGISTRY_ATTRIBUTE_MEMORY_SIZE_VALUE, &globalAttributeMemorySize,    0,
    PCMCIA_REGISTRY_POWER_POLICY_VALUE,             &PcmciaPowerPolicy,             PCMCIA_PP_WAKE_FROM_D0,
    PCMCIA_REGISTRY_FORCE_CTLR_DEVICE_WAKE,     &PcmciaControllerDeviceWake,    0,
    PCMCIA_REGISTRY_USE_POLLED_CSC_VALUE,           &initUsePolledCsc,              0,
    PCMCIA_REGISTRY_DISABLE_ISA_PCI_ROUTING,        &pcmciaDisableIsaPciRouting,    0,
    PCMCIA_REGISTRY_ISA_IRQ_RESCAN_COMPLETE,        &pcmciaIsaIrqRescanComplete,    0,
    PCMCIA_REGISTRY_IRQ_ROUTE_PCI_CTLR,             &pcmciaIrqRouteToPciController, 0,
    PCMCIA_REGISTRY_IRQ_ROUTE_ISA_CTLR,             &pcmciaIrqRouteToIsaController, 0,
    PCMCIA_REGISTRY_IRQ_ROUTE_PCI_LOC,              &pcmciaIrqRouteToPciLocation, 0,
    PCMCIA_REGISTRY_IRQ_ROUTE_ISA_LOC,              &pcmciaIrqRouteToIsaLocation, 0,
    PCMCIA_REGISTRY_DISABLE_ACPI_NAMESPACE_CHK, &initDisableAcpiNameSpaceCheck, 0,
    PCMCIA_REGISTRY_DEFAULT_ROUTE_R2_TO_ISA,        &initDefaultRouteR2ToIsa,       0,
    PCMCIA_REGISTRY_EVENT_DPC_DELAY,                &EventDpcDelay,                 PCMCIA_DEFAULT_EVENT_DPC_DELAY,
    PCMCIA_REGISTRY_REPORT_MTD0002_AS_ERROR,        &pcmciaReportMTD0002AsError,    1,
    PCMCIA_REGISTRY_IOCTL_INTERFACE,                &pcmciaIoctlInterface,          0
};

ULONG GlobalInfoCount = sizeof(GlobalRegistryInfo) / sizeof(GLOBAL_REGISTRY_INFORMATION);

ULONG initUsePolledCsc;
ULONG initDisableAcpiNameSpaceCheck;
ULONG initDefaultRouteR2ToIsa;
//
// end of Init Data
//
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg ()
#endif


#ifdef ALLOC_DATA_PRAGMA
    #pragma data_seg()
#endif
//
// Non-Paged global variables
//

//
// List of FDOs managed by this driver
//
PDEVICE_OBJECT   FdoList;
//
// GLobal Flags
//
ULONG             PcmciaGlobalFlags = 0;
//
// Event used by PcmciaWait
//
KEVENT            PcmciaDelayTimerEvent;

KSPIN_LOCK PcmciaGlobalLock;
PPCMCIA_NTDETECT_DATA pNtDetectDataList = NULL;

//
// Various values set by PcmciaLoadGlobalRegistryValues
//
ULONG EventDpcDelay;
ULONG PcmciaPowerPolicy;
LONG PcmciaControllerDeviceWake;

ULONG globalOverrideIrqMask;
ULONG globalFilterIrqMask;
ULONG globalAttributeMemoryLow;
ULONG globalAttributeMemoryHigh;
ULONG globalAttributeMemorySize;
ULONG pcmciaDisableIsaPciRouting;
ULONG pcmciaIsaIrqRescanComplete;
ULONG pcmciaIrqRouteToPciController;
ULONG pcmciaIrqRouteToIsaController;
ULONG pcmciaIrqRouteToPciLocation;
ULONG pcmciaIrqRouteToIsaLocation;
ULONG pcmciaReportMTD0002AsError;
ULONG pcmciaIoctlInterface;
#if DBG
ULONG PcmciaDebugMask;
#endif

#ifdef ALLOC_DATA_PRAGMA
    #pragma data_seg("PAGE")
#endif
//
// Paged const tables
//


const
PCI_CONTROLLER_INFORMATION PciControllerInformation[] = {

    // Vendor id                      Device Id                      Controller type
    // -------------------------------------------------------------------------------
    PCI_CIRRUSLOGIC_VENDORID, PCI_CLPD6729_DEVICEID,     PcmciaCLPD6729,
    PCI_CIRRUSLOGIC_VENDORID, PCI_CLPD6832_DEVICEID,     PcmciaCLPD6832,
    PCI_CIRRUSLOGIC_VENDORID, PCI_CLPD6834_DEVICEID,     PcmciaCLPD6834,
    PCI_TI_VENDORID,              PCI_TI1031_DEVICEID,       PcmciaTI1031,
    PCI_TI_VENDORID,              PCI_TI1130_DEVICEID,       PcmciaTI1130,
    PCI_TI_VENDORID,              PCI_TI1131_DEVICEID,       PcmciaTI1131,
    PCI_TI_VENDORID,              PCI_TI1250_DEVICEID,       PcmciaTI1250,
    PCI_TI_VENDORID,              PCI_TI1220_DEVICEID,       PcmciaTI1220,
    PCI_TI_VENDORID,              PCI_TI1251B_DEVICEID,      PcmciaTI1251B,
    PCI_TI_VENDORID,              PCI_TI1450_DEVICEID,       PcmciaTI1450,
    PCI_TOSHIBA_VENDORID,     PCI_TOPIC95_DEVICEID,      PcmciaTopic95,
    PCI_RICOH_VENDORID,       PCI_RL5C465_DEVICEID,      PcmciaRL5C465,
    PCI_RICOH_VENDORID,       PCI_RL5C466_DEVICEID,      PcmciaRL5C466,
    PCI_RICOH_VENDORID,       PCI_RL5C475_DEVICEID,      PcmciaRL5C475,
    PCI_RICOH_VENDORID,       PCI_RL5C476_DEVICEID,      PcmciaRL5C476,
    PCI_RICOH_VENDORID,       PCI_RL5C478_DEVICEID,      PcmciaRL5C478,
    PCI_DATABOOK_VENDORID,    PCI_DB87144_DEVICEID,      PcmciaDB87144,
    PCI_OPTI_VENDORID,        PCI_OPTI82C814_DEVICEID,  PcmciaOpti82C814,
    PCI_OPTI_VENDORID,        PCI_OPTI82C824_DEVICEID,  PcmciaOpti82C824,
    PCI_TRIDENT_VENDORID,     PCI_TRID82C194_DEVICEID,  PcmciaTrid82C194,
    PCI_NEC_VENDORID,         PCI_NEC66369_DEVICEID,     PcmciaNEC66369,
    // --------------------------------------------------------------------
    // Additional database entries go above this line
    //
    PCI_INVALID_VENDORID,     0,                                 0,
};

const
PCI_VENDOR_INFORMATION PciVendorInformation[] = {
    PCI_TI_VENDORID,                PcmciaTI,
    PCI_TOSHIBA_VENDORID,       PcmciaTopic,
    PCI_RICOH_VENDORID,         PcmciaRicoh,
    PCI_O2MICRO_VENDORID,       PcmciaO2Micro,
    PCI_NEC_VENDORID,           PcmciaNEC,
    PCI_DATABOOK_VENDORID,      PcmciaDatabook,
    PCI_OPTI_VENDORID,          PcmciaOpti,
    PCI_TRIDENT_VENDORID,       PcmciaTrid,
    PCI_INVALID_VENDORID,       0
};

const
DEVICE_DISPATCH_TABLE DeviceDispatchTable[] = {
    {PcmciaIntelCompatible, NULL,         PcicSetPower,  NULL,            NULL,       NULL},
    {PcmciaPciPcmciaBridge, NULL,         PcicSetPower,  NULL,            NULL,       NULL},
    {PcmciaElcController,   NULL,         PcicSetPower,  NULL,            NULL,       NULL},

    {PcmciaCardBusCompatible, NULL,       CBSetPower,     NULL,           NULL,       CBSetWindowPage},
    {PcmciaDatabook,     NULL,                TcicSetPower,  NULL,            NULL,       NULL},
    {PcmciaTI,           TIInitialize,    CBSetPower,     NULL,           TISetZV,    TISetWindowPage},
    {PcmciaCirrusLogic,CLInitialize,      CLSetPower,     NULL,           CLSetZV,    CBSetWindowPage},
    {PcmciaTopic,        TopicInitialize,   TopicSetPower, TopicSetAudio, TopicSetZV, CBSetWindowPage},
    {PcmciaRicoh,        RicohInitialize,   CBSetPower,   NULL,           RicohSetZV, CBSetWindowPage},
    {PcmciaDatabookCB, DBInitialize,      CBSetPower,     NULL,           DBSetZV,    CBSetWindowPage},
    {PcmciaOpti,         OptiInitialize,      OptiSetPower,  NULL,            OptiSetZV,  NULL},
    {PcmciaTrid,         NULL,                CBSetPower,     NULL,           NULL,       NULL},
    {PcmciaO2Micro,  O2MInitialize,   O2MSetPower,   NULL,            O2MSetZV,   CBSetWindowPage},
    {PcmciaNEC_98,   NULL,                PcicSetPower,  NULL,            NULL,       NULL},
    {PcmciaNEC,          NULL,                CBSetPower,     NULL,           NULL,       NULL},

    //------------------------------------------------------------------
    // Additional dispatch table entries go above this line
    //
    {PcmciaInvalidControllerClass,  NULL, NULL, NULL, NULL}
};

const
PCMCIA_ID_ENTRY PcmciaAdapterHardwareIds[] = {
    PcmciaIntelCompatible,        "*PNP0E00",
    PcmciaElcController,          "*PNP0E02",
    PcmciaDatabook,               "*DBK0000",
    PcmciaCLPD6729,               "*PNP0E01",
    PcmciaNEC98,                      "*nEC1E01",
    PcmciaNEC98102,               "*nEC8091",
    PcmciaInvalidControllerType,    0
};

const
PCMCIA_REGISTER_INIT PcicRegisterInitTable[] = {
    PCIC_INTERRUPT,             IGC_PCCARD_RESETLO,
    PCIC_CARD_CHANGE,           0x00,
    PCIC_CARD_INT_CONFIG,       0x00,
    PCIC_ADD_WIN_ENA,           0x00,
    PCIC_IO_CONTROL,                0x00,
    //
    // Init the 2 I/O windows
    //
    PCIC_IO_ADD0_STRT_L,        0x00,
    PCIC_IO_ADD0_STRT_H,        0x00,
    PCIC_IO_ADD0_STOP_L,        0x00,
    PCIC_IO_ADD0_STOP_H,        0x00,

    PCIC_IO_ADD1_STRT_L,        0x00,
    PCIC_IO_ADD1_STRT_H,        0x00,
    PCIC_IO_ADD1_STOP_L,        0x00,
    PCIC_IO_ADD1_STOP_H,        0x00,
    //
    // Init all 5 memory windows
    //
    PCIC_MEM_ADD0_STRT_L,       0xFF,
    PCIC_MEM_ADD0_STRT_H,       0x0F,
    PCIC_MEM_ADD0_STOP_L,       0xFF,
    PCIC_MEM_ADD0_STOP_H,       0x0F,
    PCIC_CRDMEM_OFF_ADD0_L,     0x00,
    PCIC_CRDMEM_OFF_ADD0_H,     0x00,

    PCIC_MEM_ADD1_STRT_L,       0xFF,
    PCIC_MEM_ADD1_STRT_H,       0x0F,
    PCIC_MEM_ADD1_STOP_L,       0xFF,
    PCIC_MEM_ADD1_STOP_H,       0x0F,
    PCIC_CRDMEM_OFF_ADD1_L,     0x00,
    PCIC_CRDMEM_OFF_ADD1_H,     0x00,

    PCIC_MEM_ADD2_STRT_L,       0xFF,
    PCIC_MEM_ADD2_STRT_H,       0x0F,
    PCIC_MEM_ADD2_STOP_L,       0xFF,
    PCIC_MEM_ADD2_STOP_H,       0x0F,
    PCIC_CRDMEM_OFF_ADD2_L,     0x00,
    PCIC_CRDMEM_OFF_ADD2_H,     0x00,

    PCIC_MEM_ADD3_STRT_L,       0xFF,
    PCIC_MEM_ADD3_STRT_H,       0x0F,
    PCIC_MEM_ADD3_STOP_L,       0xFF,
    PCIC_MEM_ADD3_STOP_H,       0x0F,
    PCIC_CRDMEM_OFF_ADD3_L,     0x00,
    PCIC_CRDMEM_OFF_ADD3_H,     0x00,

    PCIC_MEM_ADD4_STRT_L,       0xFF,
    PCIC_MEM_ADD4_STRT_H,       0x0F,
    PCIC_MEM_ADD4_STOP_L,       0xFF,
    PCIC_MEM_ADD4_STOP_H,       0x0F,
    PCIC_CRDMEM_OFF_ADD4_L,     0x00,
    PCIC_CRDMEM_OFF_ADD4_H,     0x00,
    //
    // Any other registers go here
    //
    0xFFFFFFFF,                     0x00
};

#ifdef ALLOC_DATA_PRAGMA
    #pragma data_seg()
#endif
//
// Non-paged const tables
//

//
// This should be non-pageable since it is referenced by the
// Power management code - most of which runs at raised IRQL
// This represents the default set of registers that need to be
// saved/restored on a cardbus controller power-down/power-up
//

//
// Register context for the pcmcia controller
//
const
PCMCIA_CONTEXT_RANGE DefaultPciContextSave[] = {
    CFGSPACE_BRIDGE_CTRL,             2,
    CFGSPACE_LEGACY_MODE_BASE_ADDR, 4,
//   CFGSPACE_CB_LATENCY_TIMER, 1,
    0, 0
};

//
// cardbus socket registers required to be saved
//
const
PCMCIA_CONTEXT_RANGE DefaultCardbusContextSave[] = {
    0, 0
};

//
// cardbus socket registers excluded from context save
//
const
PCMCIA_CONTEXT_RANGE ExcludeCardbusContextRange[] = {
    CARDBUS_SOCKET_EVENT_REG,                   0x4,
    CARDBUS_SOCKET_PRESENT_STATE_REG,       0xc,
    0, 0
};

//
// The following table defines any devices that need special
// attention during configuration. Note that values of 0xffff
// mean "don't care". The table is scanned until a match is made
// for the current device.
//
// Values are:
//  validentry, devicetype, manufacturer, code, crc, configdelay1, configdelay2, configdelay3, configflags
//
// delay values are in milliseconds
//
const
PCMCIA_DEVICE_CONFIG_PARAMS DeviceConfigParams[] = {
    1, PCCARD_TYPE_MODEM,  0x109,  0x505, 0xD293,   3100,  900,     0, CONFIG_WORKER_APPLY_MODEM_HACK,  // motorola BitSurfr 56k
    1, PCCARD_TYPE_MODEM, 0xffff, 0xffff, 0xffff,       0, 1800,    0, 0,                                       // any other modem
    1, PCCARD_TYPE_ATA,  0xffff, 0xffff, 0xffff,        0,  0, 2000, 0,                                         // any ata device
    0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\cl.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    cl.c

Abstract:

    This module contains the code that contains
    Cirrus Logic controller specific initialization and
    other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97


Environment:

    Kernel mode

Revision History :

    Neil Sandlin (neilsa) 3-Mar-99
       new setpower routine interface

--*/

#include "pch.h"


VOID
CLInitialize(IN PFDO_EXTENSION FdoExtension)
/*++

Routine Description:

    Initialize Cirrus Logic cardbus controllers

Arguments:

    FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

    None
--*/
{
    UCHAR                   byte, revisionID;
    USHORT                  word;


    byte = PcicReadSocket(FdoExtension->SocketList,
                                 PCIC_CL_MISC_CTRL3);

    if ((FdoExtension->ControllerType == PcmciaCLPD6832) &&
        ((byte & CL_MC3_INTMODE_MASK) == CL_MC3_INTMODE_EXTHW)) {

        FdoExtension->LegacyIrqMask = 0xd8b8;     //3,4,5,7,11,12,14,15

    }

    GetPciConfigSpace(FdoExtension, CFGSPACE_REV_ID, &revisionID, 1);
    if (FdoExtension->ControllerType == PcmciaCLPD6832) {
        //disable CSC IRQ routing (use PCI interrupt for CSC)
        GetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
        word &= ~BCTRL_CL_CSCIRQROUTING_ENABLE;
        SetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
    }
    else {
        //disable CSC IRQ routing (use PCI interrupt for CSC)
        GetPciConfigSpace(FdoExtension, CFGSPACE_CL_CFGMISC1, &byte, 1);
        byte &= ~CL_CFGMISC1_ISACSC;
        SetPciConfigSpace(FdoExtension, CFGSPACE_CL_CFGMISC1, &byte, 1);
    }

    //enable speaker
    byte = PcicReadSocket(FdoExtension->SocketList, PCIC_CL_MISC_CTRL1);
    byte |= CL_MC1_SPKR_ENABLE;
    PcicWriteSocket(FdoExtension->SocketList, PCIC_CL_MISC_CTRL1, byte);

    byte = PcicReadSocket(FdoExtension->SocketList, PCIC_CL_DEV_IMP_C);
    if (byte & (CL_IMPC_ZVP_A | CL_IMPC_ZVP_B)) {
        //enable multimedia support (i.e. ZV)
        byte = PcicReadSocket(FdoExtension->SocketList,PCIC_CL_MISC_CTRL3);
        byte |= CL_MC3_MM_ARM;
        PcicWriteSocket(FdoExtension->SocketList, PCIC_CL_MISC_CTRL3,byte);
    }
}

NTSTATUS
CLSetPower(
    IN PSOCKET SocketPtr,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    )
/*++

Routine Description:

    Set power to the specified socket.

Arguments:

    SocketPtr - the socket to set
    Enable - TRUE means to set power - FALSE is to turn it off.
    pDelayTime - specifies delay (msec) to occur after the current phase

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/

{
    NTSTATUS status;
    UCHAR               oldPower, newPower, oldMiscCtrl, newMiscCtrl;

    if (IsCardBusCardInSocket(SocketPtr)) {
        //
        // Hand over to generic power setting routine
        //
        return(CBSetPower(SocketPtr, Enable, pDelayTime));

    }

    switch(SocketPtr->PowerPhase) {
    case 1:
        //
        // R2 card - special handling
        //
        oldPower = PcicReadSocket(SocketPtr, PCIC_PWR_RST);
        oldMiscCtrl = PcicReadSocket(SocketPtr, PCIC_CL_MISC_CTRL1);

        //
        // Set new vcc
        //
        newPower = (Enable ? PC_CARDPWR_ENABLE: 0);
        //
        // Since we always set 5V for R2 cards, we let MISC control be 0
        // other wise it should be CL_MC1_VCC_3V if the vcc was 3.3V
        //
        newMiscCtrl = 0;

        //
        // Set vpp
        //
        if (Enable) {
             //
             // We - as always - set vpp to vcc..
             //
             newPower |= PC_VPP_SETTO_VCC;
        }
        //
        // Don't nuke the non-power related bits in the register..
        //
        newPower |= (oldPower & PC_PWRON_BITS);
        newMiscCtrl |= (oldMiscCtrl & ~CL_MC1_VCC_33V);
        //
        // If Vcc is turned off, reset OUTPUT_ENABLE & AUTOPWR_ENABLE
        //
        if (!(newPower & PC_CARDPWR_ENABLE)) {
            newPower &= ~PC_PWRON_BITS;
        }
        //
        // Only set power if nothing's changed..
        //
        status = STATUS_SUCCESS;
        if ((newPower != oldPower) || (newMiscCtrl != oldMiscCtrl)) {
            PcicWriteSocket(SocketPtr, PCIC_PWR_RST, newPower);
            PcicWriteSocket(SocketPtr, PCIC_CL_MISC_CTRL1, newMiscCtrl);
            //
            // Allow ramp up.. (actually we don't need to this if
            // Enable was FALSE).  Keep it for paranoia's sake
            //
            *pDelayTime = PCMCIA_PCIC_STALL_POWER;
            SocketPtr->PowerData = (ULONG) newPower;
            status = STATUS_MORE_PROCESSING_REQUIRED;
        }
        break;

    case 2:

        newPower = (UCHAR) SocketPtr->PowerData;

        if ((newPower & PC_CARDPWR_ENABLE) &&
             ((newPower & PC_PWRON_BITS) != PC_PWRON_BITS)) {
            //
            // More paranoia?
            //
            newPower |= PC_PWRON_BITS;
            PcicWriteSocket(SocketPtr, PCIC_PWR_RST, newPower);
        }
        status = STATUS_SUCCESS;
        break;

    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }
    return status;
}


BOOLEAN
CLSetZV(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    )
{
    UCHAR bData;

    if (Enable) {

        bData = PcicReadSocket(Socket, PCIC_CL_MISC_CTRL1);
        bData |= CL_MC1_MM_ENABLE;
        bData &= ~CL_MC1_SPKR_ENABLE;
        PcicWriteSocket(Socket, PCIC_CL_MISC_CTRL1, bData);

    } else {

        bData = PcicReadSocket(Socket, PCIC_CL_MISC_CTRL1);
        bData &= ~CL_MC1_MM_ENABLE;
        bData |= CL_MC1_SPKR_ENABLE;
        PcicWriteSocket(Socket, PCIC_CL_MISC_CTRL1, bData);

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\cb.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    cb.c

Abstract:

    This module contains the code that contains
    generic (Yenta compliant) cardbus controller
    specific initialization and other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97
    Neil Sandlin (neilsa) June 1 1999


Environment:

    Kernel mode

Revision History :

    Neil Sandlin (neilsa) 3-Mar-99
       new setpower routine interface

--*/

#include "pch.h"

//
// Function Prototypes
//

BOOLEAN
CBInitializePcmciaSocket(
    PSOCKET Socket
    );

NTSTATUS
CBResetCard(
    PSOCKET Socket,
    PULONG pDelayTime
    );

BOOLEAN
CBDetectCardInSocket(
    IN PSOCKET Socket
    );

BOOLEAN
CBDetectCardChanged(
    IN PSOCKET Socket
    );

BOOLEAN
CBDetectCardStatus(
    IN PSOCKET Socket
    );

BOOLEAN
CBDetectReadyChanged(
    IN PSOCKET Socket
    );

NTSTATUS
CBGetPowerRequirements(
    IN PSOCKET Socket
    );

BOOLEAN
CBProcessConfigureRequest(
    IN PSOCKET Socket,
    IN PVOID  ConfigRequest,
    IN PUCHAR Base
    );

BOOLEAN
CBEnableDisableCardDetectEvent(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    );

ULONG
CBGetIrqMask(
    IN PFDO_EXTENSION DeviceExtension
    );

ULONG
CBReadCardMemory(
    IN PPDO_EXTENSION PdoExtension,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG   Offset,
    IN PUCHAR Buffer,
    IN ULONG  Length
    );

ULONG
CBWriteCardMemory(
    IN PPDO_EXTENSION PdoExtension,
    IN  MEMORY_SPACE MemorySpace,
    IN  ULONG  Offset,
    IN  PUCHAR Buffer,
    IN  ULONG  Length
    );

VOID
CBEnableDisableWakeupEvent(
    IN PSOCKET Socket,
    IN PPDO_EXTENSION PdoExtension,
    IN BOOLEAN Enable
    );

BOOLEAN
CBModifyMemoryWindow(
    IN PDEVICE_OBJECT Pdo,
    IN ULONGLONG HostBase,
    IN ULONGLONG CardBase OPTIONAL,
    IN BOOLEAN   Enable,
    IN ULONG     WindowSize  OPTIONAL,
    IN UCHAR     AccessSpeed OPTIONAL,
    IN UCHAR     BusWidth    OPTIONAL,
    IN BOOLEAN   IsAttributeMemory OPTIONAL
    );

BOOLEAN
CBSetVpp(
    IN PDEVICE_OBJECT Pdo,
    IN UCHAR            Vpp
    );

BOOLEAN
CBIsWriteProtected(
    IN PDEVICE_OBJECT Pdo
    );

//
// Function dispatch data block
//

PCMCIA_CTRL_BLOCK CBSupportFns = {
    CBInitializePcmciaSocket,
    CBResetCard,
    CBDetectCardInSocket,
    CBDetectCardChanged,
    CBDetectCardStatus,
    CBDetectReadyChanged,
    CBGetPowerRequirements,
    CBProcessConfigureRequest,
    CBEnableDisableCardDetectEvent,
    CBEnableDisableWakeupEvent,
    CBGetIrqMask,
    CBReadCardMemory,
    CBWriteCardMemory,
    CBModifyMemoryWindow,
    CBSetVpp,
    CBIsWriteProtected
};

extern PCMCIA_CTRL_BLOCK PcicSupportFns;

//
// Support functions
//


NTSTATUS
CBBuildSocketList(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine builds the socket list for the given FDO. This is very
    simple for cardbus since there is always only 1 socket per controller.

Arguments:

    FdoExtension - device extension for the controller

Return Value:

    ntstatus

--*/
{
    PSOCKET         socket = NULL;

    socket = ExAllocatePool(NonPagedPool, sizeof(SOCKET));
    if (!socket) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(socket, sizeof(SOCKET));

    FdoExtension->SocketList = socket;

    socket->DeviceExtension = FdoExtension;
    socket->SocketFnPtr = &CBSupportFns;

    return STATUS_SUCCESS;
}




BOOLEAN
CBInitializePcmciaSocket(
    PSOCKET Socket
    )
/*++

Routine Description:

    This routine will setup the controller into a state where the pcmcia support
    module will be able to issue commands to read device tuples from the
    cards in the sockets.

Arguments:

    Socket - socket specific information

Return Value:

    TRUE if successful
    FALSE if not successful

--*/
{
    UCHAR               index;
    UCHAR               reg;

    //
    // Initialize exca registers
    //
    if (!PcicSupportFns.PCBInitializePcmciaSocket(Socket)) {
        return FALSE;
    }

    //
    // Clear pending events
    //
    CBWriteSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG, 0x0000000F);

    //
    // Since we may have just powered up, do a cvstest to make sure the socket registers
    // are valid
    //

    if (CBDetectCardInSocket(Socket) &&
         !IsDeviceFlagSet(Socket->DeviceExtension, PCMCIA_FDO_ON_DEBUG_PATH)) {
        CBIssueCvsTest(Socket);
    }

    return TRUE;
}



VOID
CBIssueCvsTest(
    IN PSOCKET Socket
    )
/*++

Routine Description:

    This routine forces the controller to reinterrogate the card type and voltage
    requirements. This is to insure correct values read from the socket registers.

Arguments:

    Socket - socket specific information

Return Value:

    none

--*/
{
    ULONG dwSktMask;

    //
    // Issue CVSTEST to interrogate card
    // Disable interrupt temporarily because TI 12xx could cause spurious
    // interrupt when playing with SktForce register.
    //
    dwSktMask = CBReadSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG);
    CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, 0);
    CBWriteSocketRegister(Socket, CARDBUS_SOCKET_FORCE_EVENT_REG, SKTFORCE_CVSTEST);

    CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, dwSktMask);

    // it would be nice to figure out a cleaner way to determine when interrogation is complete
    PcmciaWait(300000);
}



BOOLEAN
CBEnableDeviceInterruptRouting(
    IN PSOCKET Socket
    )
/*++

Routine Description:

Arguments:

    Socket - socket specific information

Return Value:

    FALSE - irq to PCI
    TRUE - route to ISA

--*/
{
    USHORT word, orig_word;

    //
    // set up IRQ routing
    //

    GetPciConfigSpace(Socket->DeviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
    orig_word = word;

    if (IsCardBusCardInSocket(Socket) ||
        (Is16BitCardInSocket(Socket) && IsSocketFlagSet(Socket, SOCKET_CB_ROUTE_R2_TO_PCI))) {
        //
        // route to PCI
        //
        word &= ~BCTRL_IRQROUTING_ENABLE;
    } else {
        //
        // route to ISA
        //
        word |= BCTRL_IRQROUTING_ENABLE;
    }

    if (orig_word != word) {
        SetPciConfigSpace(Socket->DeviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
    }

    // return TRUE for routing to ISA
    return ((word & BCTRL_IRQROUTING_ENABLE) == BCTRL_IRQROUTING_ENABLE);
}



NTSTATUS
CBResetCard(
    PSOCKET Socket,
    OUT PULONG pDelayTime
    )
/*++

Routine Description:

    Resets the pc-card in the given socket.

Arguments:

    Socket - Pointer to the socket in which the pc-card resides
    pDelayTime - specifies delay (msec) to occur after the current phase

Return value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/
{
    NTSTATUS status = STATUS_MORE_PROCESSING_REQUIRED;
    UCHAR               byte;
    USHORT              word;
    PFDO_EXTENSION  deviceExtension=Socket->DeviceExtension;


    if (Is16BitCardInSocket(Socket)) {
        if (Socket->CardResetPhase == 2) {
            GetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
            //
            // R2 card. Turn off write posting
            //
            word &= ~BCTRL_WRITE_POSTING_ENABLE;
            SetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
        }

        status = PcicSupportFns.PCBResetCard(Socket, pDelayTime);
        return status;
    }


    switch(Socket->CardResetPhase) {
    case 1:

        //
        // Reset via bridge control
        //
        GetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
        word |= BCTRL_CRST;
        SetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);

        Socket->PowerData = (ULONG) word;
        *pDelayTime = PCMCIA_CB_RESET_WIDTH_DELAY;
        break;

    case 2:

        word = (USHORT)Socket->PowerData;
        word &= ~BCTRL_CRST;
        //
        // CardBus card. Turn on write posting
        //
        word |= BCTRL_WRITE_POSTING_ENABLE;
        word &= ~BCTRL_IRQROUTING_ENABLE;
        //
        // Hack: turn of write posting for topic95 to avoid hardware
        // bug with intel NICs
        //
        if (deviceExtension->ControllerType == PcmciaTopic95) {
            word &= ~BCTRL_WRITE_POSTING_ENABLE;
        }
        //
        // Stop bridge control reset
        //
        SetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL,  &word, 2);

        *pDelayTime = PCMCIA_CB_RESET_SETUP_DELAY;
        break;

    case 3:
        status = STATUS_SUCCESS;
        break;

    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}



BOOLEAN
CBDetectCardInSocket(
    IN PSOCKET Socket
    )
/*++

Routine Description:

    This routine will determine if a card is in the socket

Arguments:

    Socket -- Socket information

Return Value:

    TRUE if card is present.

--*/
{
    ULONG state;
    BOOLEAN cardPresent=FALSE;

    if (IsSocketFlagSet(Socket, SOCKET_DEVICE_HIDDEN)) {
        return FALSE;
    }
    //
    // Read the CARDBUS status register to see if the card is in there.
    //
    state = CBReadSocketRegister(Socket, CARDBUS_SOCKET_PRESENT_STATE_REG);
    if ((state & SKTSTATE_CCD_MASK) == 0) {
        cardPresent = TRUE;
    }
    return(cardPresent);
}


BOOLEAN
CBDetectCardChanged(
    IN PSOCKET Socket
    )
/*++

Routine Description:

     This routine will determine if socket's card insertion status has changed.

Arguments:

     Socket -- Socket info.

Return Value:

     TRUE if card insertion status has changed.

--*/
{
    BOOLEAN retVal = FALSE;
    ULONG   tmp;
    //
    // Read SOCKET Event register to see if CD's changed
    //
    tmp = CBReadSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG);
    if ((tmp & SKTEVENT_CCD_MASK) != 0) {
        //
        // Yes they did..
        // first clear the interrupt
        CBWriteSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG, SKTEVENT_CCD_MASK);
        retVal = TRUE;
    }
    return retVal;
}



BOOLEAN
CBDetectCardStatus(
    IN PSOCKET Socket
    )
/*++

Routine Description:

    This routine will determine if socket's card insertion status has changed.

Arguments:

    Socket -- Socket info.

Return Value:

    TRUE if card insertion status has changed.

--*/
{
    BOOLEAN retVal = FALSE;
    ULONG   tmp;

    if (Is16BitCardInSocket(Socket)) {
        // NOTE: UNIMPLEMENTED: may need to do something for 16-bit cards
        return FALSE;
    }

    //
    // Read SOCKET Event register to see if CD's changed
    //
    tmp = CBReadSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG);
    if ((tmp & SKTEVENT_CSTSCHG) != 0) {
        //
        // Yes they did..
        // first clear the interrupt
        CBWriteSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG, SKTEVENT_CSTSCHG);
        retVal = TRUE;
    }
    return retVal;
}



BOOLEAN
CBDetectReadyChanged(
    IN PSOCKET Socket
    )
{
    return(PcicSupportFns.PCBDetectReadyChanged(Socket));
}


BOOLEAN
CBProcessConfigureRequest(
    IN PSOCKET Socket,
    IN PCARD_REQUEST Request,
    IN PUCHAR Base
    )
{
    BOOLEAN bStatus = TRUE;
    USHORT word;

    //
    // Shouldn't this check for 16-bit cards?
    //

    switch (Request->RequestType) {

    case IRQ_REQUEST:

        if (CBEnableDeviceInterruptRouting(Socket)) {
            bStatus = PcicSupportFns.PCBProcessConfigureRequest(Socket, Request, Base);
        }
        break;

    case DECONFIGURE_REQUEST:

        bStatus = PcicSupportFns.PCBProcessConfigureRequest(Socket, Request, Base);
        GetPciConfigSpace(Socket->DeviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
        word |= BCTRL_IRQROUTING_ENABLE;
        SetPciConfigSpace(Socket->DeviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
        break;

    default:
        bStatus = PcicSupportFns.PCBProcessConfigureRequest(Socket, Request, Base);
    }

    return bStatus;
}


BOOLEAN
CBEnableDisableCardDetectEvent(
    IN PSOCKET Socket,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

     Enable card detect/card ready interrupt.

Arguments:

     Socket - socket information
     Enable - if  TRUE, CSC interrupt is enabled,
                 if FALSE, it is disabled
Return Value:

     TRUE if successful
     FALSE if not successful

--*/
{

    switch (Enable) {

    case TRUE: {
            UCHAR byte;
            //
            // Only if TI 1130/1250?
            // Route through PCI interrupts
            byte = PcicReadSocket(Socket, PCIC_INTERRUPT);
            byte |= IGC_INTR_ENABLE;
            PcicWriteSocket(Socket, PCIC_INTERRUPT, byte);

            //
            // Clear the bits in Socket Event Register
            //
            CBWriteSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG, 0xF);

            //
            // Enable card-detect interrupt in Socket Mask Register
            //
            CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, SKTMSK_CCD);
            break;
        }

    case FALSE: {
            ULONG oldValue;
            //
            // Clear the bits in Socket Event Register
            //
            CBWriteSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG, 0xF);

            //
            // Disable card-detect interrupt in Socket Mask Register
            //
            oldValue = CBReadSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG);
            oldValue &= ~SKTMSK_CCD;
            CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, oldValue);
            break;
        }
    }

    return TRUE;
}



VOID
CBEnableDisableWakeupEvent(
    IN PSOCKET Socket,
    IN PPDO_EXTENSION PdoExtension,
    IN BOOLEAN Enable
    )
/*++

Routine Description:



Arguments:

    Socket - socket information
    Enable - if  TRUE, interrupt is enabled,
                if FALSE, it is disabled

Return Value:

    none

--*/
{
    ULONG dwValue;

    switch (Enable) {

    case TRUE: {

            if (PdoExtension && !IsCardBusCard(PdoExtension)) {
                PcicSupportFns.PCBEnableDisableWakeupEvent(Socket, PdoExtension, Enable);
                break;
            }

            //
            // Enable card-status interrupt in Socket Mask Register
            //
            dwValue = CBReadSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG);
            dwValue |= SKTMSK_CSTSCHG;
            CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, dwValue);

            if (PdoExtension && IsCardBusCard(PdoExtension)) {
                UCHAR capptr;
                ULONG powercaps;
                //
                // HACK ALERT - should be handled by PCI.SYS
                // Have a look to see if PME_ENABLE has been turned on by PCI. If not then we do it.
                //

                GetPciConfigSpace(PdoExtension, CBCFG_CAPPTR, &capptr, sizeof(capptr));
                if (capptr) {
                    GetPciConfigSpace(PdoExtension, capptr, &powercaps, sizeof(powercaps));
                    if ((powercaps & 0xff) == 1) {
                        GetPciConfigSpace(PdoExtension, capptr+4, &powercaps, sizeof(powercaps));
                        if (!(powercaps & PME_EN)) {
                            powercaps |= PME_EN;
                            DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x setting PME_EN!\n", PdoExtension->DeviceObject));
                            SetPciConfigSpace(PdoExtension, capptr+4, &powercaps, sizeof(powercaps));
                        }
                    }
                }
            }

            break;
        }

    case FALSE: {

            PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
            UCHAR capptr;
            ULONG powercaps, newPowercaps;

            //
            // Check to see if PMESTAT is on... It shouldn't be. If it is, it probably means
            // that the BIOS did not notify us that the device did the wake, and PCI didn't
            // get a chance to clear the condition. This is really a BIOS bug.
            //
            if (PdoExtension) {
                if (IsCardBusCard(PdoExtension)) {

                    GetPciConfigSpace(PdoExtension, CBCFG_CAPPTR, &capptr, sizeof(capptr));
                    if (capptr) {
                        GetPciConfigSpace(PdoExtension, capptr, &powercaps, sizeof(powercaps));
                        if ((powercaps & 0xff) == 1) {
                            GetPciConfigSpace(PdoExtension, capptr+4, &powercaps, sizeof(powercaps));
                            if (powercaps & (PME_STAT | PME_EN)) {

                                DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x PME bits still set! stat=%x en=%x\n",
                                                PdoExtension->DeviceObject, ((powercaps&PME_STAT)!=0), ((powercaps&PME_EN)!=0)));

                                powercaps |= PME_STAT;
                                powercaps &= ~PME_EN;
                                SetPciConfigSpace(PdoExtension, capptr+4, &powercaps, sizeof(powercaps));
                            }
                        }
                    }
                } else {
                    PcicSupportFns.PCBEnableDisableWakeupEvent(Socket, PdoExtension, Enable);
                }
            }

            GetPciConfigSpace(fdoExtension, CFGSPACE_CAPPTR, &capptr, sizeof(capptr));
            if (capptr) {
                GetPciConfigSpace(fdoExtension, capptr, &powercaps, sizeof(powercaps));
                if ((powercaps & 0xff) == 1) {

                    //
                    // Clear PMESTAT, if on
                    //
                    GetPciConfigSpace(fdoExtension, capptr+4, &powercaps, sizeof(powercaps));
                    if (powercaps & PME_STAT) {

                        DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x PME_STAT still set!\n", fdoExtension->DeviceObject));

                        SetPciConfigSpace(fdoExtension, capptr+4, &powercaps, sizeof(powercaps));
                    }
                }
            }

            if (PdoExtension && !IsCardBusCard(PdoExtension)) {
                break;
            }

            //
            // Disable card-status interrupt in Socket Mask Register
            //
            dwValue = CBReadSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG);
            dwValue &= ~SKTMSK_CSTSCHG;
            CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, dwValue);

            //
            // Clear the event in Socket Event Register
            //
            CBWriteSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG, SKTEVENT_CSTSCHG);

            break;
        }
    }
}



ULONG
CBGetIrqMask(
    IN PFDO_EXTENSION DeviceExtension
    )
{
    return(PcicSupportFns.PCBGetIrqMask(DeviceExtension));
}


ULONG
CBReadCardMemory(
    IN PPDO_EXTENSION PdoExtension,
    IN MEMORY_SPACE MemorySpace,
    IN ULONG   Offset,
    IN PUCHAR Buffer,
    IN ULONG  Length
    )
{
    ULONG bytesCopied = 0;

    if (!IsCardBusCard(PdoExtension)) {
        return(PcicSupportFns.PCBReadCardMemory(PdoExtension,
                                                             MemorySpace,
                                                             Offset,
                                                             Buffer,
                                                             Length));
    }

    switch(MemorySpace){

    case PCCARD_PCI_CONFIGURATION_SPACE:
        bytesCopied = GetPciConfigSpace(PdoExtension, Offset, Buffer, Length);
        break;

    case PCCARD_CARDBUS_BAR0:
    case PCCARD_CARDBUS_BAR1:
    case PCCARD_CARDBUS_BAR2:
    case PCCARD_CARDBUS_BAR3:
    case PCCARD_CARDBUS_BAR4:
    case PCCARD_CARDBUS_BAR5:
        break;

    case PCCARD_CARDBUS_ROM:
        bytesCopied =   PdoExtension->PciBusInterface.GetBusData(
                                                  PdoExtension->PciBusInterface.Context,
                                                  PCI_WHICHSPACE_ROM, Buffer, Offset, Length);
        break;

    }
    return bytesCopied;
}


ULONG
CBWriteCardMemory(
    IN PPDO_EXTENSION PdoExtension,
    IN  MEMORY_SPACE MemorySpace,
    IN  ULONG  Offset,
    IN  PUCHAR Buffer,
    IN  ULONG  Length
    )
{
    if (IsCardBusCard(PdoExtension)) {
        return 0;
    }
    return(PcicSupportFns.PCBWriteCardMemory(PdoExtension,
                                                          MemorySpace,
                                                          Offset,
                                                          Buffer,
                                                          Length));
}


BOOLEAN
CBModifyMemoryWindow(
    IN PDEVICE_OBJECT Pdo,
    IN ULONGLONG HostBase,
    IN ULONGLONG CardBase OPTIONAL,
    IN BOOLEAN   Enable,
    IN ULONG     WindowSize  OPTIONAL,
    IN UCHAR     AccessSpeed OPTIONAL,
    IN UCHAR     BusWidth    OPTIONAL,
    IN BOOLEAN   IsAttributeMemory OPTIONAL
    )
{
    return(PcicSupportFns.PCBModifyMemoryWindow(Pdo,
                                                              HostBase,
                                                              CardBase,
                                                              Enable,
                                                              WindowSize,
                                                              AccessSpeed,
                                                              BusWidth,
                                                              IsAttributeMemory));
}


BOOLEAN
CBSetVpp(
    IN PDEVICE_OBJECT Pdo,
    IN UCHAR            Vpp
    )
{
    return(PcicSupportFns.PCBSetVpp(Pdo, Vpp));
}


BOOLEAN
CBIsWriteProtected(
    IN PDEVICE_OBJECT Pdo
    )
{
    return(PcicSupportFns.PCBIsWriteProtected(Pdo));
}



NTSTATUS
CBGetPowerRequirements(
    IN PSOCKET Socket
    )
/*++

Routine Description:

     Look at the hardware to see what it says the card needs, and update the
     socket structure accordingly.

Arguments:

     Socket - the socket to examine

Return Value:

     n/a

--*/
{
    ULONG state;
    UCHAR voltage;

    //
    // Check what voltages are supported by this card
    //
    state = CBReadSocketRegister(Socket, CARDBUS_SOCKET_PRESENT_STATE_REG);

    if (!(state & (SKTSTATE_5VCARD | SKTSTATE_3VCARD))) {
        ULONG dwSktMask;
        //
        // neither 5v or 3v is set... try cvstest
        // Disable interrupt temporarily because TI 12xx could cause spurious
        // interrupt when playing with SktForce register.
        //
        dwSktMask = CBReadSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG);
        CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, 0);

        CBWriteSocketRegister(Socket, CARDBUS_SOCKET_FORCE_EVENT_REG, SKTFORCE_CVSTEST);
        state = CBReadSocketRegister(Socket, CARDBUS_SOCKET_PRESENT_STATE_REG);

        CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, dwSktMask);
    }

    state &= (SKTSTATE_5VCARD | SKTSTATE_3VCARD);

    if (state == 0) {
        return STATUS_UNSUCCESSFUL;
    }

    if (state == (SKTSTATE_5VCARD | SKTSTATE_3VCARD)) {
        //
        // both are specified. Check for preference
        //
        voltage = IsDeviceFlagSet(Socket->DeviceExtension, PCMCIA_FDO_PREFER_3V) ? 33 : 50;

    } else {

        voltage = (state & SKTSTATE_5VCARD) ? 50 : 33;

    }

    Socket->Vcc = Socket->Vpp1 = Socket->Vpp2 = voltage;

    return STATUS_SUCCESS;
}



NTSTATUS
CBSetPower(
    IN PSOCKET Socket,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    )
/*++

Routine Description:

     Set power to the specified socket.

Arguments:

     Socket - the socket to set
     Enable - TRUE means to set power - FALSE is to turn it off.
     pDelayTime - specifies delay (msec) to occur after the current phase

Return Value:

     STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
     other status values terminate sequence

--*/

{
    NTSTATUS status;
    ULONG               oldPower, state, newPower;
    ULONG               vcc, vpp;
    UCHAR               tmp;
    USHORT              word;

    switch(Socket->PowerPhase) {
    case 1:

        if (Enable) {

            //
            // Turn on the power
            //

            switch(Socket->Vcc) {

            case 50: vcc = SKTPOWER_VCC_050V; break;
            case 33: vcc = SKTPOWER_VCC_033V; break;
            default: vcc = SKTPOWER_VCC_OFF;

            }

            switch(Socket->Vpp1) {

            case 120: vpp = SKTPOWER_VPP_120V; break;
            case 50: vpp = SKTPOWER_VPP_050V; break;
            case 33: vpp = SKTPOWER_VPP_033V; break;
            default: vpp = SKTPOWER_VPP_OFF;

            }

        } else {

            //
            // Power off
            //
            vcc = SKTPOWER_VCC_OFF;
            vpp = SKTPOWER_VPP_OFF;

            //
            // Disable output before powering down to avoid spurious signals
            // from reaching the card
            //
            if (Is16BitCardInSocket(Socket)) {
                tmp = PcicReadSocket(Socket, PCIC_PWR_RST);
                if (tmp & PC_OUTPUT_ENABLE) {
                    tmp &= ~PC_OUTPUT_ENABLE;
                    PcicWriteSocket(Socket, PCIC_PWR_RST, tmp);
                }
            }
        }

        oldPower = CBReadSocketRegister(Socket, CARDBUS_SOCKET_CONTROL_REG);

        newPower = vcc | vpp;
        newPower|= oldPower & ~(SKTPOWER_VPP_CONTROL |SKTPOWER_VCC_CONTROL);

        if (newPower != oldPower) {
            CBWriteSocketRegister(Socket, CARDBUS_SOCKET_CONTROL_REG, newPower);
            //
            // When power is enabled always stall to give the PCCARD
            // a chance to react.
            //
            *pDelayTime = PCMCIA_CB_STALL_POWER;
            Socket->PowerData = newPower;
            status = STATUS_MORE_PROCESSING_REQUIRED;
        } else {
            //
            // Indicate that nothing was done
            //
            status = STATUS_INVALID_DEVICE_STATE;
        }
        break;

    case 2:
    case 3:
    case 4:

        newPower = Socket->PowerData;
        //
        // Try to apply the required power setting a few times.
        // We bail if it doesn't succeed after the given number of tries
        //
        state = CBReadSocketRegister(Socket, CARDBUS_SOCKET_PRESENT_STATE_REG);

        if (state & SKTSTATE_BADVCCREQ) {
            DebugPrint((PCMCIA_DEBUG_INFO, "skt %08 CBSetPower: Bad vcc request\n", Socket));
            //
            // Clear the status bits & try again
            //
            CBWriteSocketRegister(Socket, CARDBUS_SOCKET_FORCE_EVENT_REG, 0);
            CBWriteSocketRegister(Socket, CARDBUS_SOCKET_CONTROL_REG, newPower);
            *pDelayTime = PCMCIA_CB_STALL_POWER;
            status = STATUS_MORE_PROCESSING_REQUIRED;

        } else {
            status = STATUS_SUCCESS;
            if (Is16BitCardInSocket(Socket)) {
                tmp = PcicReadSocket(Socket, PCIC_PWR_RST);
                if (newPower & SKTPOWER_VCC_CONTROL) {
                    //
                    // Vcc is on..
                    //
                    tmp |= PC_OUTPUT_ENABLE | PC_AUTOPWR_ENABLE;
                    PcicWriteSocket(Socket, PCIC_PWR_RST, tmp);
                    *pDelayTime = PCMCIA_CB_STALL_POWER;
                } else {
                    //
                    // power off..
                    //
                    tmp &= ~(PC_OUTPUT_ENABLE | PC_AUTOPWR_ENABLE);
                    PcicWriteSocket(Socket, PCIC_PWR_RST, tmp);

                }
            }
        }
        break;

    default:
        DebugPrint((PCMCIA_DEBUG_FAIL, "skt %08 CBSetPower: Final retry failed - bad vcc\n", Socket));
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}


BOOLEAN
CBSetWindowPage(
    IN PSOCKET Socket,
    USHORT Index,
    UCHAR Page
    )
{
    ASSERT(Index <= 4);

    PcicWriteSocket(Socket, (UCHAR) (PCIC_PAGE_REG + Index), Page);
    return TRUE;
}


ULONG
CBReadSocketRegister(
    IN PSOCKET Socket,
    IN UCHAR Register
    )
/*++

Routine Description

    Returns the contents of the specified Cardbus socket register for the
    given socket

Arguments

    Socket      - Pointer to the socket
    Register        - Cardbus socket register

Return Value

    Contents of the register

--*/
{
    ULONG data = 0xFFFFFFFF;
    PFDO_EXTENSION fdoExtension;
    BOOLEAN dataWasRead = FALSE;

    //
    // Sanity check in case controller wasn't started
    // or if the register is not dword aligned
    //
    if (Socket && IsSocket(Socket) && CardBus(Socket)) {
        fdoExtension = Socket->DeviceExtension;

        if (fdoExtension && IsFdoExtension(fdoExtension) &&
            (fdoExtension->CardBusSocketRegisterBase) && ((Register&3) == 0)) {

            data = READ_REGISTER_ULONG((PULONG) (Socket->DeviceExtension->CardBusSocketRegisterBase+Register));
            dataWasRead = TRUE;
        }
    }

    ASSERT(dataWasRead);
    return data;
}


VOID
CBWriteSocketRegister(
    IN PSOCKET Socket,
    IN UCHAR Register,
    IN ULONG Data
    )
/*++

Routine Description

    Writes the supplied value to the Cardbus socket register for the
    given socket

Arguments

    Socket      - Pointer to the socket
    Register        - Cardbus socket register
    Data                - Value to be written to the register

Return Value

--*/
{
    PFDO_EXTENSION fdoExtension;
    BOOLEAN dataWasWritten = FALSE;

    //
    // Sanity check in case controller wasn't started
    // or if the register is not dword aligned
    //
    if (Socket && IsSocket(Socket) && CardBus(Socket)) {
        fdoExtension = Socket->DeviceExtension;

        if (fdoExtension && IsFdoExtension(fdoExtension) &&
            (fdoExtension->CardBusSocketRegisterBase) && ((Register&3) == 0)) {

            WRITE_REGISTER_ULONG((PULONG) (Socket->DeviceExtension->CardBusSocketRegisterBase+Register), Data);
            dataWasWritten = TRUE;
        }
    }

    ASSERT(dataWasWritten);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\pccard\pcmcibus\ctlr.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ctlr.c

Abstract:

    This module contains code to support starting and stopping the
    pcmcia controller.

Author:

    Neil Sandlin (neilsa) 1-Jun-1999

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaInitializeController(
    IN PDEVICE_OBJECT Fdo
    );


NTSTATUS
PcmciaGetPciControllerType(
    IN PDEVICE_OBJECT Pdo,
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
PcmciaCreateFdo(
    IN PDRIVER_OBJECT DriverObject,
    OUT PDEVICE_OBJECT *NewDeviceObject
    );

BOOLEAN
PcmciaInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PVOID        Context
    );

VOID
PcmciaInterruptDpc(
    IN PKDPC            Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID            SystemContext1,
    IN PVOID            SystemContext2
    );

VOID
PcmciaTimerDpc(
    IN PKDPC            Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID            SystemContext1,
    IN PVOID            SystemContext2
    );

VOID
PcmciaDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );


PUNICODE_STRING  DriverRegistryPath;

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, PcmciaAddDevice)
    #pragma alloc_text(PAGE, PcmciaCreateFdo)
    #pragma alloc_text(PAGE, PcmciaStartPcmciaController)
    #pragma alloc_text(PAGE, PcmciaSetControllerType)
    #pragma alloc_text(PAGE, PcmciaGetPciControllerType)
#endif




NTSTATUS
PcmciaAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine creates functional device objects for each Pcmcia controller in the
    system and attaches them to the physical device objects for the controllers


Arguments:

    DriverObject - a pointer to the object for this driver
    PhysicalDeviceObject - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{
    PDEVICE_OBJECT fdo = NULL;
    PDEVICE_OBJECT lowerDevice = NULL;

    PFDO_EXTENSION deviceExtension;
    ULONG           resultLength;

    NTSTATUS status;

    PAGED_CODE();

    DebugPrint((PCMCIA_DEBUG_PNP, "AddDevice Entered with pdo %x\n", Pdo));

    if (Pdo == NULL) {

        //
        // Have we been asked to do detection on our own?
        // if so just return no more devices
        //

        DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaAddDevice - asked to do detection\n"));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // create and initialize the new functional device object
    //

    status = PcmciaCreateFdo(DriverObject, &fdo);

    if (!NT_SUCCESS(status)) {

        DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaAddDevice - error creating Fdo [%#08lx]\n",
                        status));
        return status;
    }

    deviceExtension = fdo->DeviceExtension;
    KeInitializeTimer(&deviceExtension->EventTimer);
    KeInitializeDpc(&deviceExtension->EventDpc, PcmciaDpc, fdo);

    KeInitializeTimer(&deviceExtension->PowerTimer);
    KeInitializeDpc(&deviceExtension->PowerDpc, PcmciaFdoPowerWorkerDpc, deviceExtension);

    InitializeListHead(&deviceExtension->PdoPowerRetryList);
    KeInitializeDpc(&deviceExtension->PdoPowerRetryDpc, PcmciaFdoRetryPdoPowerRequest, deviceExtension);

    //
    // Layer our FDO 