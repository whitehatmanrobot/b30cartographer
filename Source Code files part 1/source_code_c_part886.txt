       eax, edx                // eax = &VgaColorHash[hashKey]

            mov         edx, [eax]
            xor         edx, [esi]
            and         edx, 0x00FFFFFF
            jz          special_color           // colors match

            test        [eax], 0x80000000
            jnz         special_collision       // hash table collision

#endif
            movd        mm1, [ebx]              // mm1 = 0 | 0 | R | GB

            punpcklbw   mm0, mm7                // mm0 = A | R | G | B
            punpcklbw   mm1, mm7                // mm1 = 0 | R | G | B

            paddw       mm0, mm1                // mm0 = A | R | G | B
            pmulhw      mm0, mm2                // divide by 51

            pmaddwd     mm0, mm3                // mm0 = (36 * R) | ((6 * G) + B)
            movq        mm4, mm0
            psrlq       mm4, 32                 // mm4 = 0 | (36 * R)
            paddsw      mm0, mm4                // mm0 = (36 * R) | ((36 * R) + (6 * G) + B)
            
            movd        eax, mm0                // eax = (36 * R) + (6 * G) + B
            add         eax, pTranslate         // eax = &pTranslate[(36 * R) + (6 * G) + B]
            
            mov         al, BYTE PTR [eax + 40] // al = pTranslate[(36 * R) + (6 * G) + B + 40]
#if defined(SPECIAL_COLORS)

set_pixel:

#endif
            add         ebx, 4                  // Prepare for next iteration: pHtStartRow++
            mov         BYTE PTR [edi], al      // Write al to destination
            add         esi, 4                  // Prepare for next iteration: s++
            inc         edi                     // Prepare for next iteration: d++

            dec         ecx
            jg          inner_loop

            cmp         count, 0
            je          exit_loop

            mov         edx, HALFTONE_SIZE
            sub         ebx, 4 * HALFTONE_SIZE
            jmp         outer_loop
#if defined(SPECIAL_COLORS)

special_color:

            mov         eax, [eax]
            shr         eax, 24
            and         eax, 0x3F
            add         eax, pTranslate
            mov         al, BYTE PTR [eax]      // al = pTranslate[index from hash]
            
            jmp         set_pixel

special_collision:

            sub         eax, VgaColorHash
            shr         eax, 2
            inc         eax
            and         eax, (1 << VGA_HASH_BITS) - 1 // eax = next hashKey

            jmp         check_special
#endif

exit_loop:

            emms
        }
    }
    else
#endif // defined(_X86_) && defined(HALFTONE_MMX)
    {
        UINT   r, g, b;
    
        for (;;)
        {
#ifdef GDIP_DO_HALFTONE_GAMMA
            // Have to linearize the color before halftoning it
            b = GammaTable216[s[0]];
            g = GammaTable216[s[1]];
            r = GammaTable216[s[2]];
        
            // The gamma correction is messing up the colors in 
            // Office's color dialogs :(
#else
            b = s[0];
            g = s[1];
            r = s[2];
#endif
            s += 4;

            INT palIndex;

#if defined(SPECIAL_COLORS)
            BOOL found = 0;

            // We have to guarantee that if the color is one of the
            // 20 system colors, it will be solid (not halftoned).  Since
            // several of these colors are not a subset of the 216 halftoning
            // colors, we have to check for them as a special case.
        
            // We use a hash table to detect these colors quickly.

            UINT hashKey = VGAHashColor(r, g, b);
       
            ARGB tblEntry = VgaColorHash[hashKey];

            // Re-read the source pixel in ARGB form - it's quicker than
            // constructing it from r, g, and b.
        
            ARGB color = *reinterpret_cast<const ARGB *>(s-4);
        
            // See if the lower 3 bytes of 'tblEntry' match the
            // lower 3 bytes of 'color'.

            if (((tblEntry ^ color) & 0xffffff) == 0)
            {
                palIndex = (tblEntry >> 24) & 0x3f;
                found = 1;
            }
            else
            {
                // If there was a collision at this position, iterate through
                // all the possible values at this address. Collision entries
                // are marked by setting the high bit.
            
                while (static_cast<INT>(tblEntry) < 0)
                {
                    hashKey++;
                    hashKey &= (1 << VGA_HASH_BITS) - 1;
                
                    tblEntry = VgaColorHash[hashKey];
                
                    if (((tblEntry ^ color) & 0xffffff) == 0)
                    {
                        palIndex = (tblEntry >> 24) & 0x3f;
                        found = 1;
                        break;
                    }
                }
            }
        
            if (!found)
#endif
            {
                ULONG   rQuo, gQuo, bQuo;
                ULONG   rRem, gRem, bRem;
                // MUST do >, not >= so that a remainder of 0 works correctly

                DIV_51(r, rQuo, rRem);
                r = rQuo + (rRem > HT_SuperCell_Red216  [htStartRow + orgX]);
            
                DIV_51(g, gQuo, gRem);
                g = gQuo + (gRem > HT_SuperCell_Green216[htStartRow + orgX]);
            
                DIV_51(b, bQuo, bRem);
                b = bQuo + (bRem > HT_SuperCell_Blue216 [htStartRow + orgX]);

                palIndex = b + Mult6plus40LUT[g] + Mult36LUT[r];
            }
            *d++ = pTranslate[palIndex];
                        
            if (--count == 0)
            {
                break;
            }

            orgX++;
        
            orgX = (orgX == HALFTONE_SIZE) ? 0 : orgX;
        }
    }
}
#pragma optimize ("", on)

// Halftone to 8bpp, using the 16-color VGA palette

VOID FASTCALL
ScanOperation::HalftoneToScreen_sRGB_8_16(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    
// NOTE: this algorithm assumes the default palette 
//       (and that the default palette is the same as HTColorPalette[]).
    
    ASSERT((s != NULL) && (d != NULL));
    ASSERT(s != d);
    ASSERT(otherParams);
        
    if (count == 0)
    {
        return;
    }
    
    INT orgX = RemainderI(otherParams->X, HALFTONE_SIZE);
    INT orgY = RemainderI(otherParams->Y, HALFTONE_SIZE);
    INT htStartRow = orgY * HALFTONE_SIZE;
    
    INT             htIndex    = htStartRow + orgX;
    INT             palIndex;
    INT             numFF;
    INT             num80;
    INT             htCell;
    INT             max;
    INT             rFF, gFF, bFF;
    INT             r, g, b;
    COLORREF        rgb;
    
    // Bug #360060: Some times it's possible the PaletteMap may be NULL
    // if we are in the process of a display mode change, say 32 to 8bpp.  In 
    // these cases we just assume an identity palette map to avoid AVing.
    // This means we may render improperly but we expect this to occur
    // only briefly before a new WM_PAINT occurs.

    const BYTE *pTranslate = otherParams->PaletteMap ?
        otherParams->PaletteMap->GetTranslate() : &identityTranslate[0];

    for (;;)
    {
#ifdef GDIP_DO_HALFTONE_GAMMA
        // Have to linearize the color before halftoning it
        r = GammaTable16[s[2]];
        g = GammaTable16[s[1]];
        b = GammaTable16[s[0]];
#else
        // The gamma correction is messing up the UI icons for WFC :(
        r = s[2];
        g = s[1];
        b = s[0];
#endif
        s += 4;

        // We have to guarantee that if the color is one of the
        // 20 system colors, it will be solid (not halftoned).  Since
        // we halftone with only 15 of the colors, there are 5
        // that we have to check for as a special case.

        rgb = (b << 16) | (g << 8) | r;     // Equivalent of RGB macro
        
        // If the the order of the colors in HTColorPalette changes,
        // this code will have to change as well!
        
        if (rgb == 0x00C0C0C0)
        {
            palIndex = 7;
        }
        else if (rgb == Globals::SystemColors[16])
        {
            palIndex = 8;
        }
        else if (rgb == Globals::SystemColors[17])
        {
            palIndex = 9;
        }
        else if (rgb == Globals::SystemColors[18])
        {
            palIndex = 10;
        }
        else if (rgb == Globals::SystemColors[19])
        {
            palIndex = 11;
        }
        else
        {
            max = (r > g) ? r : g;
            if (b > max)
            {
                max = b;
            }

            htCell = HT_SuperCell_GreenMono[htIndex];

            if (max > 0x80)
            {
                if (max < 255)
                {
                    numFF = ((max - 128) * 2);
                    num80 = 256 - numFF;
                    num80 = (num80 >> 1);
    
                    if ((rFF = (r - num80)) > 0)
                    {
                        r = 0xff;
                    }

                    if ((gFF = (g - num80)) > 0)
                    {
                        g = 0xff;
                    }

                    if ((bFF = (b - num80)) > 0)
                    {
                        b = 0xff;
                    }
                }
                else
                {
                    rFF = r;
                    gFF = g;
                    bFF = b;
                    goto UseTopOfPalette;
                }
        
                if (numFF > htCell)
                {
UseTopOfPalette:
                    palIndex = 12;
                    if (bFF > htCell)
                    {
                        palIndex += 4;
                    }
                    if (gFF > htCell)
                    {
                        palIndex += 2;
                    }
                    if (rFF > htCell)
                    {
                        palIndex++;
                    }
                }
                else
                {
                    goto UseBottomOfPalette;
                }
            }
            else
            {
UseBottomOfPalette:
                htCell = (255 - htCell) >> 1;
                palIndex = 0;
                if (b > htCell)
                {
                    palIndex += 4;
                }
                if (g > htCell)
                {
                    palIndex += 2;
                }
                if (r > htCell)
                {
                    palIndex++;
                    if (palIndex == 7)
                    {
                        palIndex = 12;
                    }
                }
            }
        }

        *d++ = pTranslate[palIndex];

        if (--count == 0)
        {
            break;
        }

        htIndex++;
        if (++orgX >= 91)
        {
            orgX = 0;
            htIndex = htStartRow;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\sodither.inc ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module name:
*
*   Include file to generate either 5-5-5 or 5-6-5 versions of the
*   dither code.
*
* Notes:
*
*   When DITHER_BLEND_555 is #defined to 1, then this file will generate
*   5-5-5 versions of the included routines.
*
*   When DITHER_BLEND_555 is #defined to 0, then we will generate 5-6-5
*   versions.
*
* Revision History:
*
*   03/15/2000 andrewgo
*       Created it.
*
\**************************************************************************/

#undef DITHER_ARRAY
#undef RED_SHIFT
#undef GREEN_SHIFT
#undef BLUE_SHIFT
#undef DITHERBLEND_FUNC
#undef DITHER_FUNC

#if DITHER_BLEND_555

    #define DITHER_ARRAY Dither555
    #define RED_SHIFT 9
    #define GREEN_SHIFT 6
    #define BLUE_SHIFT 3
    #define DITHERBLEND_FUNC ScanOperation::Dither_Blend_sRGB_555_MMX
    #define DITHER_FUNC ScanOperation::Dither_sRGB_555_MMX

#else

    #define DITHER_ARRAY Dither565
    #define RED_SHIFT 8
    #define GREEN_SHIFT 5
    #define BLUE_SHIFT 3
    #define DITHERBLEND_FUNC ScanOperation::Dither_Blend_sRGB_565_MMX
    #define DITHER_FUNC ScanOperation::Dither_sRGB_565_MMX
    
#endif

// Do a dithered blend to 16bpp using MMX

VOID FASTCALL
DITHERBLEND_FUNC(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
#if defined(_X86_)

    DEFINE_POINTERS(ARGB, WORD);
    DEFINE_BLEND_POINTER(ARGB);
    
    ASSERT(count != 0);
    ASSERT(otherParams);

    static ULONGLONG redBlueMask = 0x00f800f800f800f8;
    static ULONGLONG flipAlphaBits = 0x00ff00ff00ff00ff;

#if DITHER_BLEND_555
    static ULONGLONG greenMask = 0x0000f8000000f800;
    static ULONGLONG redBlueMultiplier = 0x0400000104000001;
#else
    static ULONGLONG greenMask = 0x0000fc000000fc00;
    static ULONGLONG redBlueMultiplier = 0x0800000108000001;
#endif

    INT x = otherParams->X;
    INT y = otherParams->Y;

    UINT32 *dither = (otherParams->DoingDither) 
                   ? &DITHER_ARRAY[8 * (y & 3)] 
                   : &DitherNone[0];
    UINT32 ditherIncrement = (x & 3) * 4;               

    const ARGB *blendPixel = bl;

    _asm
    {
        ; ecx = count
        ; esi = source
        ; edi = destination
        ; mm4 = red and blue mask (0xf800f8)
        ; mm5 = green mask (0x00fc00) (0x00f800 for 5-5-5)
        ; mm6 = C1 | C0 dither
        ; mm7 = C3 | C2 dither

        mov             eax, ditherIncrement
        mov             esi, blendPixel
        mov             edi, d
        mov             ecx, count
        movq            mm4, redBlueMask
        movq            mm5, greenMask
    
        ; We always want our qword reads from the screen to be aligned.
        ; So if the initial pixel is not qword-aligned, we handle up to
        ; three pixels up front to make it qword-aligned.
        ;
        ; (Note that as a consequence of us aligning to the destination,
        ; we're often doing unaligned reads on the source.  But it's
        ; a much bigger performance win to align operations to the screen
        ; than to system memory, due to the terrible screen read
        ; performance.)

alignment_loop:
        add             eax, dither
        test            edi, 6
        movq            mm6, [eax]      
        movq            mm7, [eax+8]    
        jz              done_start_alignment
        call            do_single_pixel        

        ; Adjust our pointers and load our new dither values:

        mov             eax, ditherIncrement
        add             eax, 4
        and             eax, 0x0000000F
        mov             ditherIncrement, eax
        add             esi, 4
        add             edi, 2
        dec             ecx
        jz              all_done
        jmp             alignment_loop

    done_start_alignment:
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    do_main_loop:
        sub             ecx, 4                  ; pre-decrement by 4
        jl              do_pair

        ; We do chunks of 4 pixels at a time so that we can unroll our
        ; dither loop (our dither repeats every 4 pixels).
        
    do_main_loop_2:
        mov             al, [esi+3]           
        and             al, [esi+7]
        and             al, [esi+11]
        and             al, [esi+15]
        inc             al                      ; if all alphas were 0xff, this
        jnz             do_pair                 ;   will wrap to zero
    

        ; The four pixels starting at [esi] are opaque.  We only need to
        ; dither them and convert to 16bpp.  The following codepath will
        ; process all four in parallel (two at a time) in order to optimize
        ; usage of the execution units and minimize dependencies between
        ; consecutive instructions.
            
        ; We start by reading the four pixels into mm0 and mm1, adding
        ; the dither component, and then breaking into group 0 (pixels 0
        ; and 2) and group 1 (pixels 1 and 3).  I will use **0** and **1**
        ; in the comments below to show which pixel group the instruction is
        ; processing

        movq            mm0, [esi]              ; mm0 = DW1 | DW0
        movq            mm1, [esi + 8]          ; mm1 = DW3 | DW2

        paddusb         mm0, mm6                ; add dither
        movq            mm2, mm0
        paddusb         mm1, mm7                ; add dither

        add             edi, 8
        
        punpckhdq       mm2, mm1         ; **1**  mm2 = DW3 | DW1
        punpckldq       mm0, mm1         ; **0**  mm0 = DW2 | DW0
        
        movq            mm3, mm2         ; **1**
        pand            mm2, mm4         ; **1**  red and blue
        
        movq            mm1, mm0         ; **0**
        pand            mm0, mm4         ; **0**  red and blue

        pand            mm3, mm5         ; **1**  green

        psrlw           mm0, 3           ; **0**  shift red and blue to lowest 
                                         ; 5 bits in register
        
        ; Note the use of the pmaddwd to simultaneously shift both the red and
        ; blue bits into their appropriate positions.  The constant 
        ; redBlueMultiplier contains four shorts, each of which is equal to
        ; 2^i where i is the number of bits that we need to shift that color
        ; component by in order to attain the correct position in the 16bpp
        ; color.  This is possible only because the red and blue
        ; components lie on different shorts in the 64bits register (green has
        ; been masked earlier), and so we can dedicate an entire 16bit short
        ; to red and to blue.

        pmaddwd         mm2, redBlueMultiplier  ; **1**
                
        add             esi, 16

        pand            mm1, mm5         ; **0**  green

        psrld           mm3, GREEN_SHIFT-3 ; **1**
        
        pmaddwd         mm0, redBlueMultiplier  ; **0**
            
        sub             ecx, 4                  ; pre-decrement for next iteration

        por             mm2, mm3         ; **1**  combine green with red/blue
                                         ;        mm2 = 0  | W3 | 0  | W1
        
        psrld           mm1, GREEN_SHIFT ; **0**

        psllq           mm2, 13          ; **1**  mm2 = W3 | 0  | W1 | 0

        por             mm0, mm1         ; **0**  combine green with red/blue
                                         ;        mm1 = 0  | W2 | 0  | W0

        por             mm0, mm2                ; mm2 = W3 | W2 | W1 | W0
        movq            [edi - 8], mm0

        jge             do_main_loop_2
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    do_pair:
        add             ecx, 2                  ; pre-decrement for this iteration
        jl              do_last_pixel
    
        ; We're doing only a single pair of pixels, so swap our dither
        ; values in preparation for the next iteration:
    
        pxor            mm6, mm7
        pxor            mm7, mm6
        pxor            mm6, mm7                ; swap mm6 and mm7
    
        mov             al, [esi+3]
        inc             al
        cmp             al, 1
        ja              do_pair_blend

        mov             al, [esi+7]
        inc             al
        cmp             al, 1
        ja              do_pair_blend

        mov             al, [esi+3]             ; Do we really want this here?
        or              al, [esi+7]
        jz              do_pair_done
    
        movq            mm0, [esi]
        paddusb         mm0, mm7                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT        ; green (6 for 5-5-5)
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT         ; blue
        psrld           mm2, RED_SHIFT          ; red (9 for 5-5-5)
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
        movq            mm1, mm0
        psrlq           mm1, 32
        punpcklwd       mm0, mm1                ; mm0 = X | X | C1 | C0
    
        movd            eax, mm0
        cmp             byte ptr [esi+3], 0
        je              do_pair_done_first_write        
        mov             [edi], ax        
    do_pair_done_first_write:
        cmp             byte ptr [esi+7], 0
        je              do_pair_done_second_write
        shr             eax, 16
        mov             [edi+2], ax
    do_pair_done_second_write:
        add             edi, 4
        add             esi, 8
        jmp             do_main_loop
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    do_pair_blend:
        movd            mm1, [edi]              ; read destination, X | X | C1 | C0
        punpcklwd       mm1, mm1                ; C1 | C1 | C0 | C0
        psrld           mm1, 16                 ; 0 | C1 | 0 | C0
                                                ;  (trick using single red and
                                                ;  blue mask requires high bits
                                                ;  to be zero)
        movq            mm0, mm1
        movq            mm2, mm1
        pslld           mm1, BLUE_SHIFT         ; blue
        pslld           mm0, GREEN_SHIFT        ; green (6 for 5-5-5)
        pslld           mm2, RED_SHIFT          ; red (9 for 5-5-5)
        por             mm1, mm2                ; combine red and blue
        pand            mm1, mm4                ; leave valid red and blue bits
        pand            mm0, mm5                ; leave valid green bits
        por             mm1, mm0                ; mm1 = C1 | C0        
    
        ; Okay now we've got the destination read and split.  Handle the first 
        ; blend:
    
        movd            mm2, [esi]
        punpcklbw       mm2, mm2
        psrlw           mm2, 8                  ; mm2 = S
        movq            mm3, mm2
        punpckhwd       mm3, mm3
        punpckhdq       mm3, mm3                ; mm3 = alpha
        movq            mm0, mm1
        punpcklbw       mm0, mm0
        psrlw           mm0, 8                  ; mm0 = D
    #if NO_PREMULTIPLIED_ALPHA
        psubw           mm2, mm0               
        pmullw          mm2, mm3                ; mm2 = alpha * (S - D)
        movq            mm3, mm2
        psrlw           mm3, 8
        paddw           mm2, mm3                ; approximate x/255 by 257/65536
        psrlw           mm2, 8                  ; mm2 = alpha * (S - D)
        paddb           mm0, mm2                ; mm0 = C0 = D + alpha * (S - D)
    #else
        pxor            mm3, flipAlphaBits
        pmullw          mm0, mm3                ; mm2 = (255 - alpha) * D
        movq            mm3, mm0
        psrlw           mm0, 8                  ; approximate x/255 by 257/65536
        paddw           mm0, mm3                ; mm2 = (255 - alpha) * D / 255
        psrlw           mm0, 8                  ; don't care about rounding, not enough bits
        paddb           mm0, mm2                ; mm0 = C0 = S + (1 - alpha) * D
    #endif
    
        ; Handle the second blend (change mm0 to mm1):
    
        movd            mm2, [esi+4]
        punpcklbw       mm2, mm2
        psrlw           mm2, 8                  ; mm2 = S
        movq            mm3, mm2
        punpckhwd       mm3, mm3
        punpckhdq       mm3, mm3                ; mm3 = alpha
        punpckhbw       mm1, mm1
        psrlw           mm1, 8                  ; mm1 = D
    #if NO_PREMULTIPLIED_ALPHA
        psubw           mm2, mm1               
        pmullw          mm2, mm3                ; mm2 = alpha * (S - D)
        movq            mm3, mm2
        psrlw           mm3, 8
        paddw           mm2, mm3                ; approximate x/255 by 257/65536
        psrlw           mm2, 8                  ; mm2 = alpha * (S - D)
        paddb           mm1, mm2                ; mm1 = C1 = D + alpha * (S - D)
    #else
        pxor            mm3, flipAlphaBits    
        pmullw          mm1, mm3                ; mm2 = (255 - alpha) * D
        movq            mm3, mm1
        psrlw           mm1, 8                  ; approximate x/255 by 257/65536
        paddw           mm1, mm3                ; mm2 = (255 - alpha) * D / 255
        psrlw           mm1, 8                  ; don't care about rounding, not enough bits
        paddb           mm1, mm2                ; mm1 = C1 = S + (1 - alpha) * D
    #endif
        packuswb        mm0, mm1                ; mm0 = C1 | C0
    
        ; Dither and pack everything back up:
    
        paddusb         mm0, mm7                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT        ; green
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT         ; blue
        psrld           mm2, RED_SHIFT          ; red
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
        movq            mm1, mm0
        psrlq           mm1, 32                 ; mm1 = 0 | 0 | X | C1
        punpcklwd       mm0, mm1                ; mm0 = X | X | C1 | C0
    
        movd            [edi], mm0
    
    do_pair_done:
        add             edi, 4
        add             esi, 8
        jmp             do_main_loop
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    do_single_pixel:
        movd            mm0, [esi]
        mov             al, [esi+3]
        inc             al
        jnz             do_single_blend         ; if not completely opaque 
    
        paddusb         mm0, mm6                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT
        psrld           mm2, RED_SHIFT
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
    
        movd            eax, mm0
        mov             [edi], ax        
    do_single_done:
        ret
    
    do_single_blend:
        dec             al
        jz              do_single_done          ; completely transparent pixel
    
        ; alpha is between 0 and 255
    
        movzx           eax, word ptr [edi]     ; do the destination read
        movd            mm1, eax                ; mm1 = 0 | 0 | 0 | C0
        movq            mm0, mm1
        movq            mm2, mm1
        pslld           mm1, BLUE_SHIFT         ; blue 
        pslld           mm0, GREEN_SHIFT        ; green (6 for 5-5-5)
        pslld           mm2, RED_SHIFT          ; red (9 for 5-5-5)
        por             mm1, mm2                ; combine red and blue
        pand            mm1, mm4                ; leave valid red and blue bits
        pand            mm0, mm5                ; leave valid green bits
        por             mm1, mm0                ; mm1 = C1 | C0        
    
        ; Okay now we've got the destination read and split.  Handle the first blend:
    
        movd            mm2, [esi]
        punpcklbw       mm2, mm2
        psrlw           mm2, 8                  ; mm2 = S
        movq            mm3, mm2
        punpckhwd       mm3, mm3
        punpckhdq       mm3, mm3                ; mm3 = alpha
        movq            mm0, mm1
        punpcklbw       mm0, mm0
        psrlw           mm0, 8                  ; mm0 = D
    #if NO_PREMULTIPLIED_ALPHA
        psubw           mm2, mm0               
        pmullw          mm2, mm3                ; mm2 = alpha * (S - D)
        movq            mm3, mm2
        psrlw           mm3, 8
        paddw           mm2, mm3                ; approximate x/255 by 257/65536
        psrlw           mm2, 8                  ; mm2 = alpha * (S - D)
        paddb           mm0, mm2                ; mm0 = C0 = D + alpha * (S - D)
    #else
        pxor            mm3, flipAlphaBits    
        pmullw          mm0, mm3                ; mm2 = (255 - alpha) * D
        movq            mm3, mm0
        psrlw           mm0, 8                  ; approximate x/255 by 257/65536
        paddw           mm0, mm3                ; mm2 = (255 - alpha) * D / 255
        psrlw           mm0, 8                  ; don't care about rounding, not enough bits
        paddb           mm0, mm2                ; mm0 = C0 = S + (1 - alpha) * D
    #endif
        packuswb        mm0, mm0                ; mm0 = C1 | C0
    
        ; Dither and pack everything back up:
    
        paddusb         mm0, mm6                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT
        psrld           mm2, RED_SHIFT
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
    
        movd            eax, mm0
        mov             [edi], ax        
        ret
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    do_last_pixel:
        test            ecx, 1
        jz              all_done
        call            do_single_pixel

    all_done:
        emms      
    }

#endif
}

// Dither to 16bpp using MMX

VOID FASTCALL
DITHER_FUNC(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
#if defined(_X86_)

    DEFINE_POINTERS(ARGB, WORD);
    
    ASSERT(count != 0);
    ASSERT(otherParams);

    static ULONGLONG redBlueMask = 0x00f800f800f800f8;
    static ULONGLONG flipAlphaBits = 0x00ff00ff00ff00ff;

#if DITHER_BLEND_555
    static ULONGLONG greenMask = 0x0000f8000000f800;
#else
    static ULONGLONG greenMask = 0x0000fc000000fc00;
#endif

    INT x = otherParams->X;
    INT y = otherParams->Y;

    UINT32 *dither = (otherParams->DoingDither) 
                   ? &DITHER_ARRAY[8 * (y & 3) + (x & 3)] 
                   : &DitherNone[0];
                   
    _asm
    {
        ; ecx = count
        ; esi = source
        ; edi = destination
        ; mm4 = red and blue mask (0xf800f8)
        ; mm5 = green mask (0x00fc00) (0x00f800 for 5-5-5)
        ; mm6 = C1 | C0 dither
        ; mm7 = C3 | C2 dither

        mov             eax, dither
        mov             esi, s
        mov             edi, d
        mov             ecx, count
        movq            mm4, redBlueMask
        movq            mm5, greenMask
        movq            mm6, [eax]      
        movq            mm7, [eax+8]    
        sub             ecx, 4                  ; pre-decrement by 4
        jl              do_last_3_pixels_or_less
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; We do chunks of 4 pixels at a time so that we can unroll our
        ; dither loop (our dither repeats every 4 pixels).

    do_main_loop:
        movq            mm0, [esi]
        paddusb         mm0, mm6                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT        ; green (6 for 5-5-5)
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT         ; blue
        psrld           mm2, RED_SHIFT          ; red (9 for 5-5-5)
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
        movq            mm1, mm0
        psrlq           mm1, 32                 ; mm1 = X | X | X | C1
        punpcklwd       mm0, mm1                ; mm0 = X | X | C1 | C0
        movd            [edi], mm0
    
        movq            mm0, [esi+8]
        paddusb         mm0, mm7                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT
        psrld           mm2, RED_SHIFT
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
        movq            mm1, mm0
        psrlq           mm1, 32
        punpcklwd       mm0, mm1                ; mm0 = X | X | C1 | C0
        movd            [edi+4], mm0
    
        add             edi, 8
        add             esi, 16
        sub             ecx, 4                  ; pre-decrement for next iteration
        jge             do_main_loop
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    do_last_3_pixels_or_less:
        add             ecx, 4                  ; get back 'real' count
        jz              all_done

        dec             ecx                     ; if exactly 1 pixel left
        jz              do_last_pixel
        
    ; do 2 pixels
        ; we'll decrement ecx again later

        movq            mm0, [esi]
        paddusb         mm0, mm6                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT        ; green (6 for 5-5-5)
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT         ; blue
        psrld           mm2, RED_SHIFT          ; red (9 for 5-5-5)
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
        movq            mm1, mm0
        psrlq           mm1, 32                 ; mm1 = X | X | X | C1
        punpcklwd       mm0, mm1                ; mm0 = X | X | C1 | C0
        movd            eax, mm0
        mov             [edi], eax
        
        dec             ecx
        jz              all_done
        
        add             esi, 8
        add             edi, 4

    do_last_pixel:    
        movd            mm0, [esi]
        paddusb         mm0, mm7                ; add dither
        movq            mm2, mm0
        pand            mm0, mm5                ; green
        pand            mm2, mm4                ; red and blue
        psrld           mm0, GREEN_SHIFT
        movq            mm3, mm2
        psrld           mm3, BLUE_SHIFT
        psrld           mm2, RED_SHIFT
        por             mm0, mm3
        por             mm0, mm2                ; mm0 = X | C1 | X | C0
        movq            mm1, mm0
        psrlq           mm1, 32
        punpcklwd       mm0, mm1                ; mm0 = X | X | C1 | C0
        movd            eax, mm0
        mov             [edi], ax

    all_done:
        emms      
    }

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\sogammaconvert.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "GammaConvert" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   These operations convert from one format to another, accounting
*   for differing gamma ramps.
*
* Revision History:
*
*   12/06/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   GammaConvert: Convert from one format to another, accounting
*                 for differing gamma ramps.
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan
*   count       - The length of the scan, in pixels
*   otherParams - Additional conversion data.
*
* Return Value:
*
*   None
*
* History:
*
*   12/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/

// 32bpp sRGB to 64bpp sRGB64

VOID FASTCALL
ScanOperation::GammaConvert_sRGB_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB64)
    while (count--)
    {
        sRGB::ConvertTosRGB64(*s++,d++);
    }
}

// 64bpp sRGB64 to 32bpp sRGB

VOID FASTCALL
ScanOperation::GammaConvert_sRGB64_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, ARGB)
    while (count--)
    {
        *d++ = sRGB::ConvertTosRGB(*s++);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\solidfill.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Engine solid fill routines.
*
* Revision History:
*
*   12/11/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster as a solid color.
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus
DpOutputSolidColorSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    INT width = xMax - xMin;

    FillMemoryInt32(Scan->NextBuffer(xMin, y, width), width, Argb);

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Fills a path.  This distributes to the individual brush fill method.  
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] path       - the path to fill
*   [IN] brush      - the brush to use
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/21/1999 ikkof
*
\**************************************************************************/

GpStatus
DpDriver::FillPath(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpBrush *brush
    )
{
    GpStatus status = GenericError;

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);

    BOOL noTransparentPixels = (!context->AntiAliasMode) && (gpBrush->IsOpaque()); 

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        noTransparentPixels);

    if (scan.IsValid())
    {
        if (brush->Type == BrushTypeSolidColor)
        {
            GpColor color(brush->SolidColor.GetValue());    
            DpOutputSolidColorSpan output(color.GetPremultipliedValue(), &scan);

            status = RasterizePath(path, 
                                   &context->WorldToDevice, 
                                   path->GetFillMode(),
                                   context->AntiAliasMode, 
                                   FALSE,
                                   &output, 
                                   &context->VisibleClip, 
                                   drawBounds);
        }
        else
        {
            // If there is a shrinking world to device transform when using
            // a path gradient, then scale the brush and the path to be 
            // in device units. This eliminates the need to create potentially 
            // very large gradients or textures.
            
            // Only handle positive scale because some of our driver rectangle
            // filling code can't handle negative rects. Doing ABS preserves
            // the sign of the input world coordinate rectangles/path.
            
            REAL scaleX = REALABS(context->WorldToDevice.GetM11());
            REAL scaleY = REALABS(context->WorldToDevice.GetM22());
            DpOutputSpan * output = NULL;
            
            if (brush->Type == BrushTypePathGradient &&
                context->WorldToDevice.IsTranslateScale() &&
                REALABS(scaleX) > REAL_EPSILON && 
                REALABS(scaleY) > REAL_EPSILON &&
                (REALABS(scaleX) < 1.0f || REALABS(scaleY) < 1.0f))
            {
                // I don't like the following hack for magically getting
                // a GpBrush from a DpBrush, but DpOutputSpan already does this...
                GpBrush * gpbrush = GpBrush::GetBrush( (DpBrush *)(brush));
                GpPathGradient *scaledBrush = (GpPathGradient*)(gpbrush->Clone());

                if (scaledBrush == NULL)
                {
                    return OutOfMemory;
                }

                // Scale the cloned brush's path and bounding rect into
                // device units.
                scaledBrush->ScalePath(scaleX,scaleY);

                REAL mOrig[6];
                context->WorldToDevice.GetMatrix(mOrig);
                context->WorldToDevice.Scale(1.0f/scaleX, 1.0f/scaleY);
                output = DpOutputSpan::Create(scaledBrush->GetDeviceBrush(), &scan, context, drawBounds);

                if (output != NULL)
                {
                    GpPath *scalePath = ((GpPath*)path)->Clone();
                    
                    if (scalePath != NULL)
                    {
                        GpMatrix  scaleMatrix (scaleX, 0.0f, 0.0f, scaleY, 0.0f, 0.0f);
                        scalePath->Transform(&scaleMatrix);
                        
                        status = RasterizePath(scalePath, 
                                       &context->WorldToDevice, 
                                       path->GetFillMode(),
                                       context->AntiAliasMode, 
                                       FALSE,
                                       output, 
                                       &context->VisibleClip, 
                                       drawBounds);
    
                        delete scalePath;
                    }
                    else
                    {
                        status = OutOfMemory;
                    }
                    delete output;
                }
                else
                {
                    status = OutOfMemory;
                }
                delete scaledBrush;
                context->WorldToDevice.SetMatrix(mOrig);
            }
            else
            {
                output = DpOutputSpan::Create(brush, &scan, context, drawBounds);
                if (output != NULL)
                {
                    status = RasterizePath(path, 
                                       &context->WorldToDevice, 
                                       path->GetFillMode(),
                                       context->AntiAliasMode, 
                                       FALSE,
                                       output, 
                                       &context->VisibleClip, 
                                       drawBounds);                
                    delete output;
                }

            }
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draws a path.  This distributes to the individual pen draw method.  
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to draw to
*   [IN] drawBounds - the surface bounds
*   [IN] path       - the path to stroke
*   [IN] pen        - the pen to use
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 ikkof
*
\**************************************************************************/

GpStatus
DpDriver::StrokePath(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpPen *pen
    )
{
    GpStatus status = GenericError;

    const DpBrush *brush = pen->Brush;

    REAL dpiX = (context->GetDpiX() > 0) 
              ? (context->GetDpiX())
              : (Globals::DesktopDpiX);

    BOOL isOnePixelWide = pen->IsOnePixelWide(&context->WorldToDevice, dpiX) &&
                          pen->IsCenterNoAnchor();
    BOOL isOnePixelWideOpaque = isOnePixelWide &&
                                (brush->Type == BrushTypeSolidColor) && 
                                (brush->SolidColor.IsOpaque()) &&
                                !(context->AntiAliasMode);
    BOOL isOnePixelWideSolid = isOnePixelWide && 
                                pen->IsSimple();

    // We have a special fast-path for doing single-pixel-wide, 
    // solid color, opaque, aliased lines:

    // !!! [asecchia] RAID 239905.
    // The single pixel wide optimized code has significant rounding problems
    // that are particularly problematic on bezier curves.
    // Bezier curves tend to be enumerated in a particular way that causes
    // the SolidStrokePathOnePixel code to enumerate the line segments backward
    // hitting badly tested end point conditions, though the problem seems
    // to be pervasive. 
    // The general rasterizer does not have these problems but is about 
    // 30% slower for single pixel solid lines. 
    // Turn on the optimization only for polylines until this is fixed.
    
    if (isOnePixelWideOpaque && isOnePixelWideSolid && !path->HasCurve())
    {
        return SolidStrokePathOnePixel(
            context,
            surface,
            drawBounds,
            path,
            pen,
            TRUE
        ); 
    }

    const DpPath* widenedPath;
    const DpPath* allocatedPath;

    GpMatrix *transform;
    GpMatrix identityTransform;

    if (isOnePixelWideSolid)
    {
        // Our RasterizePath code can directly draw a one-pixel-wide solid 
        // line directly:

        widenedPath = path;
        allocatedPath = NULL;
        transform = &context->WorldToDevice;
    }
    else
    {
        // We have to widen  the path before we can give it to the
        // rasterizer.  Generate new path now:

        REAL dpiX = context->GetDpiX();
        REAL dpiY = context->GetDpiY();

        if ((dpiX <= 0) || (dpiY <= 0))
        {
            dpiX = Globals::DesktopDpiX;
            dpiY = Globals::DesktopDpiY;
        }

        widenedPath = path->GetFlattenedPath(
            isOnePixelWideOpaque ? NULL : &context->WorldToDevice,
            isOnePixelWideOpaque ? Flattened : Widened,
            pen
        );

        allocatedPath = widenedPath;
        transform = &identityTransform;

        if (!widenedPath)
            return OutOfMemory;

        // If this line is aliased, opaque and dashed, dash it now and pass the
        // dashed path to the single pixel stroking code.
        if (isOnePixelWideOpaque && pen->DashStyle != DashStyleSolid)
        {
            DpPath *dashPath = NULL;

            dashPath = ((GpPath*)widenedPath)->CreateDashedPath(pen, 
                NULL, 
                dpiX, 
                dpiY,
                1.0f,
                FALSE /* don't need caps in 1 px wide case */);
            
            if (!dashPath)
            {
                delete widenedPath;
                return OutOfMemory;
            }

            Status status = SolidStrokePathOnePixel(context,
                                                    surface,
                                                    drawBounds,
                                                    dashPath,
                                                    pen,
                                                    FALSE); 
            delete dashPath;
            delete widenedPath;
            
            return status;
        }
    }

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);
    BOOL noTransparentPixels = (!context->AntiAliasMode) && (gpBrush->IsOpaque()); 

    DpScanBuffer scan(surface->Scan, this, context, surface, noTransparentPixels);

    if (scan.IsValid())
    {
        if (brush->Type == BrushTypeSolidColor)
        {
            GpColor color(brush->SolidColor.GetValue());    
            DpOutputSolidColorSpan output(color.GetPremultipliedValue(), &scan);

            status = RasterizePath(widenedPath, 
                                   transform, 
                                   widenedPath->GetFillMode(),
                                   context->AntiAliasMode, 
                                   isOnePixelWideSolid,
                                   &output, 
                                   &context->VisibleClip, 
                                   drawBounds);
        }
        else
        {
            DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, context, 
                                                         drawBounds);
            if (output != NULL)
            {
                status = RasterizePath(widenedPath, 
                                       transform, 
                                       widenedPath->GetFillMode(),
                                       context->AntiAliasMode, 
                                       isOnePixelWideSolid,
                                       output, 
                                       &context->VisibleClip, 
                                       drawBounds);
    
                delete output;
            }
        }
    }

    if (allocatedPath)
    {
        delete allocatedPath;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Fills a region.  This distributes to the individual brush fill method.  
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] region     - the region to fill
*   [IN] brush      - the brush to use
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/25/1999 DCurtis
*
\**************************************************************************/

GpStatus
DpDriver::FillRegion(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpRegion *region,
    const DpBrush *brush
    )
{
    GpStatus    status = GenericError;

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        gpBrush->IsOpaque());

    if (scan.IsValid())
    {
        DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, 
                                                     context, drawBounds);

        if (output != NULL)
        {
            DpClipRegion *          clipRegion = &(context->VisibleClip);
            GpRect                  clipBounds;
            GpRect *                clipBoundsPointer = NULL;
            DpRegion::Visibility    visibility;
        
            visibility = clipRegion->GetRectVisibility(
                            drawBounds->X,
                            drawBounds->Y,
                            drawBounds->X + drawBounds->Width,
                            drawBounds->Y + drawBounds->Height);

            switch (visibility)
            {
              default:                          // Need to clip
                clipRegion->GetBounds(&clipBounds);
                clipBoundsPointer = &clipBounds;
                clipRegion->InitClipping(output, drawBounds->Y);
                status = region->Fill(clipRegion, clipBoundsPointer);
                break;

              case DpRegion::TotallyVisible:    // No clipping needed
                status = region->Fill(output, clipBoundsPointer);
                break;
            
              case DpRegion::Invisible:
                status = Ok;
                break;
            }

            delete output;
            clipRegion->EndClipping();
        }
    }

    return status;
}

GpStatus
DpDriver::MoveBits(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const GpRect *dstRect,     
    const GpPoint *srcPoint
    )
{
    return(GenericError);
}

GpStatus 
DpDriver::Lock(
    DpBitmap *surface,
    const GpRect *drawBounds,
    INT *stride,                    // [OUT] - Returned stride
    VOID **bits                     // [OUT] - Returned pointer to bits
    )
{
    return(Ok);
}

VOID 
DpDriver::Unlock(
    DpBitmap *surface
    )
{
}

/**************************************************************************\
*
* Function Description:
*
*   Engine version of routine to fill rectangles.
*   This is not limited to filling solid color.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   TRUE if successful.
*
* History:
*
*   01/13/1999 ikkof
*       Created it.
*
\**************************************************************************/

// !!![andrewgo] What is this doing in a file called "solidfill.cpp"?

GpStatus
DpDriver::FillRects(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    INT numRects, 
    const GpRectF *rects,
    const DpBrush *brush
    )
{
    GpStatus    status = Ok;
    GpBrushType type   = brush->Type;

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        gpBrush->IsOpaque());

    if(!scan.IsValid())
    {
        return(GenericError);
    }

    DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, 
                                           context, drawBounds);

    if(output == NULL)
        return(GenericError);

    DpRegion::Visibility visibility = DpRegion::TotallyVisible;
    DpClipRegion * clipRegion = NULL;

    if (context->VisibleClip.GetRectVisibility(
        drawBounds->X, drawBounds->Y, 
        drawBounds->GetRight(), drawBounds->GetBottom()) != 
        DpRegion::TotallyVisible)
    {
        clipRegion = &(context->VisibleClip);
        clipRegion->InitClipping(output, drawBounds->Y);
    }
   
    GpMatrix *worldToDevice = &context->WorldToDevice;
    
    const GpRectF * rect = rects;
    INT y;

    for (INT i = numRects; i != 0; i--, rect++)
    {
        // We have to check for empty rectangles in world space (because
        // after the transform they might have flipped):

        if ((rect->Width > 0) && (rect->Height > 0))
        {
            GpPointF points[4];

            points[0].X = rect->X;
            points[0].Y = rect->Y;
            points[1].X = rect->X + rect->Width;
            points[1].Y = rect->Y + rect->Height;

            // FillRects only ever gets called when a scaling transform:
            // !!![ericvan] printing code calls this to render the brush onto a rectangle,
            //              but the transform in effect may not be TranslateScale
            // !!![andrewgo] Yeah but then isn't the printer case completely
            //               broken when there is an arbitrary transform?!?

            ASSERT(context->IsPrinter ||
                   worldToDevice->IsTranslateScale());
            
            worldToDevice->Transform(points, 2);

            INT left;
            INT right;

            // convert to INT the same way the GDI+ rasterizer does
            // so we get the same rounding error in both places.

            if (points[0].X <= points[1].X)
            {
                left  = RasterizerCeiling(points[0].X);
                right = RasterizerCeiling(points[1].X);     // exclusive
            }
            else
            {
                left  = RasterizerCeiling(points[1].X);
                right = RasterizerCeiling(points[0].X);     // exclusive
            }

            // Since right is exclusive, we don't draw anything
            // if left >= right.

            INT width = right - left;
            INT top;
            INT bottom;

            if (points[0].Y <= points[1].Y)
            {
                top    = RasterizerCeiling(points[0].Y);
                bottom = RasterizerCeiling(points[1].Y);    // exclusive
            }
            else
            {
                top    = RasterizerCeiling(points[1].Y);
                bottom = RasterizerCeiling(points[0].Y);    // exclusive
            }
             
            // Since bottom is exclusive, we don't draw anything
            // if top >= bottom.

            if ((width > 0) && (top < bottom))
            {
                GpRect clippedRect;
                
                if(clipRegion)
                {
                    visibility = 
                            clipRegion->GetRectVisibility(
                                left, top, 
                                right, bottom, &clippedRect);
                }

                switch (visibility)
                {
                case DpRegion::ClippedVisible:
                    left   = clippedRect.X;
                    top    = clippedRect.Y;
                    right  = clippedRect.GetRight();
                    bottom = clippedRect.GetBottom();
                    width  = right - left;
                    // FALLTHRU
        
                case DpRegion::TotallyVisible:
                    for (y = top; y < bottom; y++)
                    {
                        output->OutputSpan(y, left, right);
                    }
                    break;
        
                case DpRegion::PartiallyVisible:
                    for (y = top; y < bottom; y++)
                    {
                        clipRegion->OutputSpan(y, left, right);
                    }
                    break;

                case DpRegion::Invisible:
                    break;
                }
            }
        }
    }

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }

    delete output;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\soquantize.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "Quantize" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   This module implements scan operations for converting pixels from
*   one format, to another of less color precision.
*   "Quantize" uses a simple, fixed mapping, which maps each source color
*   level to a particular destination color level.
*
* Notes:
*
*   The "Quantize" operation is fast but can cause Mach banding.
*   An alternative is the "Halftone" operation, in SOHalftone.cpp.
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   12/01/1999 agodfrey
*       Moved to it from Imaging\Api\convertfmt.cpp.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Operation Description:
*
*   Quantize: Quickly convert format down from 32bpp ARGB.
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan (32bpp ARGB)
*   count       - The length of the scan, in pixels
*   otherParams - Additional data. (Ignored.)
*
* Return Value:
*
*   None
*
* History:
*
*   05/13/1999 davidx
*       Created it.
*   12/02/1999 agodfrey
*       Moved & reorganized it.
*
\**************************************************************************/

// Quantize from sRGB to 16bpp RGB555

VOID FASTCALL
ScanOperation::Quantize_sRGB_555(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, WORD)
    
    while (count--)
    {
        ARGB argb = *s++;

        *d++ = (WORD) ((((argb >> (RED_SHIFT+3)) & 0x1f) << 10) |
                       (((argb >> (GREEN_SHIFT+3)) & 0x1f) << 5) |
                       ((argb >> (BLUE_SHIFT+3)) & 0x1f));
    }
}

// Quantize from sRGB to 16bpp RGB565

VOID FASTCALL
ScanOperation::Quantize_sRGB_565(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, WORD)
    
    while (count--)
    {
        ARGB argb = *s++;

        *d++ = (WORD) ((((argb >> (RED_SHIFT+3)) & 0x1f) << 11) |
                       (((argb >> (GREEN_SHIFT+2)) & 0x3f) << 5) |
                       ((argb >> (BLUE_SHIFT+3)) & 0x1f));
    }
}

// Quantize from sRGB to 16bpp RGB1555

VOID FASTCALL
ScanOperation::Quantize_sRGB_1555(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, WORD)
    
    while (count--)
    {
        ARGB argb = *s++;

        // NOTE: Very crude conversion of alpha data
        // from 8bpp down to 1bpp

        *d++ = (WORD) ((((argb >> ALPHA_SHIFT) >= 128) ? 0x8000 : 0) |
                       (((argb >> (RED_SHIFT+3)) & 0x1f) << 10) |
                       (((argb >> (GREEN_SHIFT+3)) & 0x1f) << 5) |
                       ((argb >> (BLUE_SHIFT+3)) & 0x1f));
    }
}

// Quantize from sRGB to 24bpp RGB

VOID FASTCALL
ScanOperation::Quantize_sRGB_24(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, BYTE)
    
    while (count--)
    {
        ARGB argb = *s++;

        d[0] = (BYTE) (argb >> BLUE_SHIFT);
        d[1] = (BYTE) (argb >> GREEN_SHIFT);
        d[2] = (BYTE) (argb >> RED_SHIFT);
        d += 3;
    }
}

// Quantize from sRGB to 24bpp BGR

VOID FASTCALL
ScanOperation::Quantize_sRGB_24BGR(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, BYTE)
    
    while (count--)
    {
        ARGB argb = *s++;

        d[0] = (BYTE) (argb >> RED_SHIFT);
        d[1] = (BYTE) (argb >> GREEN_SHIFT);
        d[2] = (BYTE) (argb >> BLUE_SHIFT);
        d += 3;
    }
}

// Quantize from sRGB to 32bpp RGB

VOID FASTCALL
ScanOperation::Quantize_sRGB_32RGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB, ARGB)
    
    while (count--)
    {
        *d++ = *s++ | ALPHA_MASK;
    }
}

// Quantize from sRGB64 to 48bpp RGB

VOID FASTCALL
ScanOperation::Quantize_sRGB64_48(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(ARGB64, INT16)
    
    while (count--)
    {
        sRGB::sRGB64Color c;
        c.argb = *s++;

        d[0] = c.b;
        d[1] = c.g;
        d[2] = c.r;
        d += 3;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\srgb.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   sRGB/sRGB64 conversion.
*
* Abstract:
*
*   Conversion between the sRGB and sRGB64 color spaces.
*
* Created:
*
*   6/9/1999 agodfrey
*
\**************************************************************************/

#ifndef _SRGB_HPP
#define _SRGB_HPP

// We cast ARGB and ARGB64 variables to these unions when necessary.
// We could instead define ARGB and ARGB64 to be unions themselves, but the
// compiler is bad at enregistering unions.

namespace sRGB
{

    // LinearizeLUT: Lookup table used to convert from sRGB to sRGB64
    static DWORD LinearizeLUT[256] = 
    {
        0x0, 0x2, 0x5, 0x7, 0xa, 0xc, 0xf, 0x11,
        0x14, 0x16, 0x19, 0x1b, 0x1e, 0x21, 0x24, 0x27,
        0x2a, 0x2e, 0x32, 0x35, 0x39, 0x3d, 0x42, 0x46,
        0x4b, 0x50, 0x55, 0x5a, 0x5f, 0x65, 0x6a, 0x70,
        0x76, 0x7d, 0x83, 0x8a, 0x91, 0x98, 0x9f, 0xa6,
        0xae, 0xb6, 0xbe, 0xc6, 0xce, 0xd7, 0xe0, 0xe9,
        0xf2, 0xfc, 0x105, 0x10f, 0x119, 0x124, 0x12e, 0x139,
        0x144, 0x14f, 0x15b, 0x166, 0x172, 0x17e, 0x18b, 0x197,
        0x1a4, 0x1b1, 0x1be, 0x1cc, 0x1da, 0x1e8, 0x1f6, 0x204,
        0x213, 0x222, 0x231, 0x240, 0x250, 0x260, 0x270, 0x281,
        0x291, 0x2a2, 0x2b3, 0x2c5, 0x2d6, 0x2e8, 0x2fa, 0x30d,
        0x31f, 0x332, 0x346, 0x359, 0x36d, 0x381, 0x395, 0x3a9,
        0x3be, 0x3d3, 0x3e9, 0x3fe, 0x414, 0x42a, 0x440, 0x457,
        0x46e, 0x485, 0x49d, 0x4b4, 0x4cc, 0x4e5, 0x4fd, 0x516,
        0x52f, 0x549, 0x562, 0x57c, 0x597, 0x5b1, 0x5cc, 0x5e7,
        0x603, 0x61e, 0x63a, 0x657, 0x673, 0x690, 0x6ad, 0x6cb,
        0x6e8, 0x706, 0x725, 0x743, 0x762, 0x781, 0x7a1, 0x7c1,
        0x7e1, 0x801, 0x822, 0x843, 0x864, 0x886, 0x8a8, 0x8ca,
        0x8ed, 0x910, 0x933, 0x956, 0x97a, 0x99e, 0x9c2, 0x9e7,
        0xa0c, 0xa32, 0xa57, 0xa7d, 0xaa3, 0xaca, 0xaf1, 0xb18,
        0xb40, 0xb68, 0xb90, 0xbb8, 0xbe1, 0xc0a, 0xc34, 0xc5e,
        0xc88, 0xcb2, 0xcdd, 0xd08, 0xd34, 0xd5f, 0xd8b, 0xdb8,
        0xde5, 0xe12, 0xe3f, 0xe6d, 0xe9b, 0xec9, 0xef8, 0xf27,
        0xf57, 0xf86, 0xfb6, 0xfe7, 0x1018, 0x1049, 0x107a, 0x10ac,
        0x10de, 0x1111, 0x1143, 0x1177, 0x11aa, 0x11de, 0x1212, 0x1247,
        0x127c, 0x12b1, 0x12e6, 0x131c, 0x1353, 0x1389, 0x13c0, 0x13f7,
        0x142f, 0x1467, 0x14a0, 0x14d8, 0x1511, 0x154b, 0x1585, 0x15bf,
        0x15f9, 0x1634, 0x166f, 0x16ab, 0x16e7, 0x1723, 0x1760, 0x179d,
        0x17da, 0x1818, 0x1856, 0x1895, 0x18d4, 0x1913, 0x1952, 0x1992,
        0x19d3, 0x1a13, 0x1a54, 0x1a96, 0x1ad7, 0x1b1a, 0x1b5c, 0x1b9f,
        0x1be2, 0x1c26, 0x1c6a, 0x1cae, 0x1cf3, 0x1d38, 0x1d7e, 0x1dc3,
        0x1e0a, 0x1e50, 0x1e97, 0x1edf, 0x1f26, 0x1f6f, 0x1fb7, 0x2000,
    };

    // Lookup table to convert alpha to sRGB64, which is:
    // LinearizeAlphaLUT[i]=i*SRGB_ONE/255;
    static DWORD LinearizeAlphaLUT[256]=
    {
        0x0000, 0x0020, 0x0040, 0x0060, 0x0080, 0x00A0, 0x00C0, 0x00E0,
        0x0101, 0x0121, 0x0141, 0x0161, 0x0181, 0x01A1, 0x01C1, 0x01E1,
        0x0202, 0x0222, 0x0242, 0x0262, 0x0282, 0x02A2, 0x02C2, 0x02E2,
        0x0303, 0x0323, 0x0343, 0x0363, 0x0383, 0x03A3, 0x03C3, 0x03E3,
        0x0404, 0x0424, 0x0444, 0x0464, 0x0484, 0x04A4, 0x04C4, 0x04E4,
        0x0505, 0x0525, 0x0545, 0x0565, 0x0585, 0x05A5, 0x05C5, 0x05E5,
        0x0606, 0x0626, 0x0646, 0x0666, 0x0686, 0x06A6, 0x06C6, 0x06E6,
        0x0707, 0x0727, 0x0747, 0x0767, 0x0787, 0x07A7, 0x07C7, 0x07E7,
        0x0808, 0x0828, 0x0848, 0x0868, 0x0888, 0x08A8, 0x08C8, 0x08E8,
        0x0909, 0x0929, 0x0949, 0x0969, 0x0989, 0x09A9, 0x09C9, 0x09E9,
        0x0A0A, 0x0A2A, 0x0A4A, 0x0A6A, 0x0A8A, 0x0AAA, 0x0ACA, 0x0AEA,
        0x0B0B, 0x0B2B, 0x0B4B, 0x0B6B, 0x0B8B, 0x0BAB, 0x0BCB, 0x0BEB,
        0x0C0C, 0x0C2C, 0x0C4C, 0x0C6C, 0x0C8C, 0x0CAC, 0x0CCC, 0x0CEC,
        0x0D0D, 0x0D2D, 0x0D4D, 0x0D6D, 0x0D8D, 0x0DAD, 0x0DCD, 0x0DED,
        0x0E0E, 0x0E2E, 0x0E4E, 0x0E6E, 0x0E8E, 0x0EAE, 0x0ECE, 0x0EEE,
        0x0F0F, 0x0F2F, 0x0F4F, 0x0F6F, 0x0F8F, 0x0FAF, 0x0FCF, 0x0FEF,
        0x1010, 0x1030, 0x1050, 0x1070, 0x1090, 0x10B0, 0x10D0, 0x10F0,
        0x1111, 0x1131, 0x1151, 0x1171, 0x1191, 0x11B1, 0x11D1, 0x11F1,
        0x1212, 0x1232, 0x1252, 0x1272, 0x1292, 0x12B2, 0x12D2, 0x12F2,
        0x1313, 0x1333, 0x1353, 0x1373, 0x1393, 0x13B3, 0x13D3, 0x13F3,
        0x1414, 0x1434, 0x1454, 0x1474, 0x1494, 0x14B4, 0x14D4, 0x14F4,
        0x1515, 0x1535, 0x1555, 0x1575, 0x1595, 0x15B5, 0x15D5, 0x15F5,
        0x1616, 0x1636, 0x1656, 0x1676, 0x1696, 0x16B6, 0x16D6, 0x16F6,
        0x1717, 0x1737, 0x1757, 0x1777, 0x1797, 0x17B7, 0x17D7, 0x17F7,
        0x1818, 0x1838, 0x1858, 0x1878, 0x1898, 0x18B8, 0x18D8, 0x18F8,
        0x1919, 0x1939, 0x1959, 0x1979, 0x1999, 0x19B9, 0x19D9, 0x19F9,
        0x1A1A, 0x1A3A, 0x1A5A, 0x1A7A, 0x1A9A, 0x1ABA, 0x1ADA, 0x1AFA,
        0x1B1B, 0x1B3B, 0x1B5B, 0x1B7B, 0x1B9B, 0x1BBB, 0x1BDB, 0x1BFB,
        0x1C1C, 0x1C3C, 0x1C5C, 0x1C7C, 0x1C9C, 0x1CBC, 0x1CDC, 0x1CFC,
        0x1D1D, 0x1D3D, 0x1D5D, 0x1D7D, 0x1D9D, 0x1DBD, 0x1DDD, 0x1DFD,
        0x1E1E, 0x1E3E, 0x1E5E, 0x1E7E, 0x1E9E, 0x1EBE, 0x1EDE, 0x1EFE,
        0x1F1F, 0x1F3F, 0x1F5F, 0x1F7F, 0x1F9F, 0x1FBF, 0x1FDF, 0x2000
    };

    union sRGBColor
    {
        struct 
        {
            BYTE b, g, r, a;
        };
        ARGB argb;
    };

    #define SRGB_FRACTIONBITS 13
    #define SRGB_INTEGERBITS (16-SRGB_FRACTIONBITS)
    #define SRGB_ONE (1<<(SRGB_FRACTIONBITS))
    #define SRGB_HALF (1<<(SRGB_FRACTIONBITS-1))

    union sRGB64Color
    {
        struct
        {
            INT16 b, g, r, a;
        };
        ARGB64 argb;
    };

    inline VOID ConvertTosRGB64(ARGB color,ARGB64 *result)
    {
        (*(DWORD*)result)=(LinearizeLUT[(DWORD)(color&0x0000ff00)>>8]<<16) | (LinearizeLUT[(DWORD)color&0x000000ff]);       // GGBB
        (*((DWORD*)result+1))=(LinearizeAlphaLUT[(DWORD)color>>24]<<16) | (LinearizeLUT[(DWORD)(color&0x00ff0000)>>16]);    // AARR
    }
    ARGB   ConvertTosRGB(ARGB64 color);

    // isTranslucent* returns FALSE if the specified alpha value is either
    // completely transparent or completely opaque.
    //
    // NOTE: This method EXPECTS overflow on the alpha byte (a tricky
    //       way to avoid an extra 'if')

    // Equivalent to: (alpha != 0) && (alpha != 255)
    inline BOOL isTranslucent(ARGB argb)
    {
		ASSERT((((ARGB)0)-1) > 0);         // Make sure ARGB is an unsigned dword
        return ((argb>>24)-1 < 0xFE);
    }

    // Equivalent to: (alpha > 0) && (alpha < sRGB::SRGB_ONE)
    // !!![agodfrey] Revisit this when we know the meaning of
    //     alpha > 1 and alpha < 0.
    
    inline BOOL isTranslucent64(INT16 alpha)
    {
        return (((UINT16) (alpha-1)) <= ((UINT16) SRGB_ONE));
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\stretch.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name & Abstract
*
*   Stretch. This module contains the code to do various stretching
*   by applying a kernel filter. The code correctly handles minification.
*
* Notes:
*
*   This code does not handle rotation or shear.
*
* Created:
*
*   04/17/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _STRETCH_HPP
#define _STRETCH_HPP


// All the filter modes supported by DpOutputSpanStretch.

enum FilterModeType {
    HighQualityBilinear = 0,
    HighQualityBicubic = 1,
    FilterModeMax
};

// Filter width is 1 for Bilinear and 2 for Bicubic.

const INT FilterWidth[FilterModeMax] = {1, 2};


template<FilterModeType FilterMode>
class DpOutputSpanStretch : public DpOutputSpan
{
public:
    const DpBitmap *dBitmap;
    BitmapData BmpData;
    DpScanBuffer *Scan;
    GpRectF SrcRect;
    GpRectF DstRect;

    // Wrap mode state

    WrapMode QWrapMode;
    ARGB ClampColor;
    BYTE ClampColorA;
    BYTE ClampColorR;
    BYTE ClampColorG;
    BYTE ClampColorB;
    BOOL WrapZeroClamp;

    // Destination rectangle for valid bits.
    // The valid bits are the translation of the source valid bits to
    // the destination space.

    FIX16 fixDLeft;
    FIX16 fixDTop;
    FIX16 fixDRight;
    FIX16 fixDBottom;

    // x scale state.

    FIX16 xkci;       // Initial x- kernel position 
    FIX16 xw;         // Width of x- kernel from center to edge
    FIX16 xa;         // 1/xw
    FIX16 xscale;     // x- scale factor (magnification or minification)
    FIX16 xscaleinv;  // 1/xscale
    INT ixleft;

    // y scale state.

    FIX16 ykci;       // Initial y- kernel position                           
    FIX16 yw;         // Width of y- kernel from center to edge               
    FIX16 ya;         // 1/yw                                                 
    FIX16 yscale;     // y- scale factor (magnification or minification)      
    FIX16 yscaleinv;  // 1/yscale                                             

    // This is the last y scanline that contributed to the previous run.

    INT last_k;

    // This is the destination y scanline corresponding to the top of the
    // destination rectangle.

    INT iytop;

    // Buffer to store the temporary results for the 1D x-scale.
    // The xbuffer is implemented as a rotational buffer of scanlines.
    // Each scanline is the width required to hold one destination width
    // scanline and there are enough scanlines to fill a y-dimension kernel.

    ARGB *xbuffer;

    // This represents the first scanline in the rotational xbuffer.

    INT xbuffer_start_scanline;

    // These represent the dimensions of the xbuffer - height is the number
    // of scanlines and width is the x-size in pixels.

    INT xbuffer_height;
    INT xbuffer_width;

    // This is an array of y-coefficient values.
    // The kernel weights are computed for each contributing scanline and
    // stored in this array (1-1 correspondence with the xbuffer) so that
    // they don't have to be recomputed for every x coordinate.

    FIX16 *ycoeff;

    bool isValid;

public:
    DpOutputSpanStretch(
        DpBitmap* bitmap,
        DpScanBuffer * scan,
        DpContext* context,
        DpImageAttributes imgAttributes,
        const GpRectF *dstRect,
        const GpRectF *srcRect
    )
    {
        InitializeClass(bitmap, scan, context, imgAttributes, dstRect, srcRect);
    }

    void InitializeClass(
        DpBitmap* bitmap,
        DpScanBuffer * scan,
        DpContext* context,
        DpImageAttributes imgAttributes,
        const GpRectF *dstRect,
        const GpRectF *srcRect
    );


    virtual GpStatus OutputSpan(
        INT y,
        INT xMin,
        INT xMax
    );

    void StretchScanline(
        ARGB *dst,       // destination pointer                                 
        ARGB *src,       // source pointer                                      
        INT dw,          // destination width (pixels)                          
        INT sw,          // source width (pixels)                               
        FIX16 kci,       // initial position of the kernel center               
        FIX16 scale,     // scale factor                                        
        FIX16 w,         // width from center of the kernel to the edge         
        FIX16 a          // 1/w                                                 
    );

    void StretchMiddleScanline2_MMX(
        ARGB *dst, 
        ARGB *src, 
        INT dw, 
        FIX16 kci
    );

    virtual BOOL IsValid() const { return (isValid && (dBitmap!=NULL)); }
    DpScanBuffer* GetScanBuffer(){ return Scan; }

    virtual ~DpOutputSpanStretch()
    {
        // throw away our working buffer.

        GpFree(xbuffer);
        GpFree(ycoeff);
    }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\soreadrmw.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "ReadRMW" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   This module implements scan operations for prereading from the
*   destination surface, when we are later going to do a SrcOver operation.
*   We call this the 'RMW optimization' ('read-modify-write' optimization).
*
*   Reads from video memory (or AGP memory) are stupendously expensive.
*   (For example, on my PCI Pentium II, which is representative of both
*   PCI and AGP machines, reads max out at 5.5 MB/s, whereas writes are
*   90 MB/s.  Not only is there that raw throughput difference, but
*   writes can be buffered and so allow some CPU cycles between writes,
*   which isn't possible on reads.)
*
*       o Aligned dword reads are typically twice as fast as aligned
*         word reads.  That is, an aligned dword read typically takes
*         the same amount of time as an aligned word read.  
*         BUT: This rule is a little complicated.  Random dword reads 
*         on my machine do indeed take the same amount of time as random 
*         word reads, but consecutive dword reads are significantly slower 
*         than consecutive word reads (although are still faster in terms
*         of throughput).
*       o Most alpha values in the source buffer are 0 or 255, meaning
*         that we really don't need to do the read of the destination
*         at all for those pixels
*       o Write combining is more effective with a batch of writes.
*         That is, instead of doing read/write for every pixel, 
*         doing all the reads up front and then doing all the writes
*         is more efficient.
*
*   In some cases (e.g. if we do the blend in sRGB64), we want to do other 
*   operations between the read and the blend. If we use ReadRMW as a separate
*   operation, we don't need to write RMW versions of those intermediate
*   operations.
*
*   So for an sRGB blend, it's more efficient to do a separate 
*   pre-read pass when the destination format is 16-bit or 24-bit.
*   There are sRGB64 versions for 16-bit, 24-bit and 
*   32-bit destination formats.
*
*   If we use ReadRMW, we have to be careful about the final write. 
*   If a blend pixel has an alpha of 0, we won't read from the destination,
*   so we must avoid writing to the destination for that pixel, or we'll
*   write garbage. So the final scan operation used must be a WriteRMW
*   operation. (The 'Blend' operations are also classified as WriteRMW
*   operations, so if the destination format is canonical, we don't have to
*   use a separate WriteRMW.)
*
* Revision History:
*
*   12/08/1998 andrewgo
*       Created it.
*   07/14/1999 agodfrey
*       Removed TRANSLUCENT5, added sRGB64, moved it from Ddi\scan.cpp.
*
\**************************************************************************/

#include "precomp.hpp"

// SHOULDCOPY* returns FALSE if the specified alpha value is either
// completely transparent or completely opaque. In either case, we
// don't actually need to read the destination.

#define SHOULDCOPY_sRGB64(x) (sRGB::isTranslucent64(x))

// Helper macros for declaring pointers to the blend pixels.

#define DECLARE_BLEND_sRGB \
    const ARGB *bl = \
        static_cast<const ARGB *>(otherParams->BlendingScan);
    
#define DECLARE_ALPHA_sRGB64 \
    const INT16 *alpha = \
        static_cast<const INT16 *>(otherParams->BlendingScan) + 3;

/**************************************************************************\
*
* Operation Description:
*
*   ReadRMW: Copy all pixels where the corresponding pixel in
*            otherParams->BlendingScan is translucent (i.e. alpha is
*            neither 0 nor 1.)
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan
*   count       - The length of the scan, in pixels
*   otherParams - Additional data (we use BlendingScan).
*
* Return Value:
*
*   None
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*   07/14/1999 agodfrey
*       Removed TRANSLUCENT5, added sRGB64, moved it from Ddi\scan.cpp. 
*   08/10/2000 agodfrey
*       Made it write zero when it decides not to read - the palette may
*       not have 256 entries (e.g. we hit this for 16-color mode, though we
*       probably shouldn't).
*
\**************************************************************************/

// 8bpp, for sRGB

VOID FASTCALL
ScanOperation::ReadRMW_8_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_BLEND_sRGB
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    INT align = (INT) ((-((LONG_PTR) s)) & 0x3);
    align = min(count, align);
    
    count -= align;
    
    while (align)
    {
        if (sRGB::isTranslucent(*bl))
        {
            *d = *s;
        }
        else
        {
            *d = 0;
        }
                                        
        d++;
        s++;
        bl++;
        align--;
    }

    // Now go through the aligned dword loop:
    
    while (count >= 4)
    {
        ASSERT((((ULONG_PTR) s) & 0x3) == 0);
    
        if (sRGB::isTranslucent(*bl) ||
            sRGB::isTranslucent(*(bl+1)) ||
            sRGB::isTranslucent(*(bl+2)) ||
            sRGB::isTranslucent(*(bl+3)))
        {
            // Do a dword read. We can be sloppy here (but not in WriteRMW)
            // - reading extra bytes doesn't hurt correctness, and
            // the perf impact (of possibly reading bytes we don't need to)
            // should be quite small.
            
            *((UNALIGNED UINT32*) d) = *((UINT32*) s);
        }
        else
        {
            *((UNALIGNED UINT32*) d) = 0;
        }
        
        
        d += 4;
        s += 4;
        bl += 4;
        count -= 4;
    }

    // Handle the last few pixels:

    while (count)
    {
        if (sRGB::isTranslucent(*bl))
        {
            *d = *s;
        }
        else
        {
            *d = 0;
        }
                                        
        d++;
        s++;
        bl++;
        count--;
    }
}

// 8bpp, for sRGB64

VOID FASTCALL
ScanOperation::ReadRMW_8_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_ALPHA_sRGB64
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    INT align = (INT) ((-((LONG_PTR) s)) & 0x3);
    align = min(count, align);
    
    count -= align;
    
    while (align)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *d = *s;
        }
                                        
        d++;
        s++;
        alpha += 4;
        align--;
    }

    // Now go through the aligned dword loop:

    while (count >= 4)
    {
        ASSERT((((ULONG_PTR) s) & 0x3) == 0);
    
        if (SHOULDCOPY_sRGB64(*alpha) ||
            SHOULDCOPY_sRGB64(*(alpha+4)) ||
            SHOULDCOPY_sRGB64(*(alpha+8)) ||
            SHOULDCOPY_sRGB64(*(alpha+12)))
        {
            // Do a dword read.

            *((UNALIGNED UINT32*) d) = *((UINT32*) s);
        }
        
        d += 4;
        s += 4;
        alpha += 16;
        count -= 4;
    }
    
    // Handle the last few pixels:

    while (count)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *d = *s;
        }
                                        
        d++;
        s++;
        alpha += 4;
        count--;
    }
}

// 16bpp, for sRGB

VOID FASTCALL
ScanOperation::ReadRMW_16_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT16, UINT16)
    DECLARE_BLEND_sRGB
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    if (((ULONG_PTR) s) & 0x2)
    {
        if (sRGB::isTranslucent(*bl))
        {
            *(d) = *(s);
        }
                                        
        d++;
        s++;
        bl++;
        count--;
    }

    // Now go through the aligned dword loop:

    while ((count -= 2) >= 0)
    {
        if (sRGB::isTranslucent(*bl))
        {
            if (sRGB::isTranslucent(*(bl+1)))
            {
                // Both pixels have partial alpha, so do a dword read:

                *((UNALIGNED UINT32*) d) = *((UINT32*) s);
            }
            else
            {
                // Only the first pixel has partial alpha, so do a word read:

                *(d) = *(s);
            }
        }
        else if (sRGB::isTranslucent(*(bl+1)))
        {
            // Only the second pixel has partial alpha, so do a word read:

            *(d + 1) = *(s + 1);
        }

        d += 2;
        s += 2;
        bl += 2;
    }

    // Handle the end alignment:

    if (count & 1)
    {
        if (sRGB::isTranslucent(*bl))
        {
            *(d) = *(s);
        }
    }
}

// 16bpp, for sRGB64

VOID FASTCALL
ScanOperation::ReadRMW_16_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT16, UINT16)
    DECLARE_ALPHA_sRGB64

    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    if (((ULONG_PTR) s) & 0x2)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *(d) = *(s);
        }
                                        
        d++;
        s++;
        alpha += 4;
        count--;
    }

    // Now go through the aligned dword loop:

    while ((count -= 2) >= 0)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            if (SHOULDCOPY_sRGB64(*(alpha + 4)))
            {
                // Both pixels have partial alpha, so do a dword read:

                *((UNALIGNED UINT32*) d) = *((UINT32*) s);
            }
            else
            {
                // Only the first pixel has partial alpha, so do a word read:

                *(d) = *(s);
            }
        }
        else if (SHOULDCOPY_sRGB64(*(alpha + 4)))
        {
            // Only the second pixel has partial alpha, so do a word read:

            *(d + 1) = *(s + 1);
        }

        d += 2;
        s += 2;
        alpha += 8;
    }

    // Handle the end alignment:

    if (count & 1)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *(d) = *(s);
        }
    }
}

// 24bpp, for sRGB

VOID FASTCALL
ScanOperation::ReadRMW_24_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_BLEND_sRGB
    
    ULONG_PTR srcToDstDelta = (ULONG_PTR) d - (ULONG_PTR) s;

    // Handle the initial partial read:

    INT initialAlignment = (INT) ((ULONG_PTR) s & 3);
    if (initialAlignment)
    {
        if (sRGB::isTranslucent(*bl))
        {
            UINT32 *alignedSrc = (UINT32*) ((ULONG_PTR) s & ~3);
            DWORD dwBuffer[2];

            // Get pointer to start of pixel inside dwBuffer
            BYTE *pByte = (BYTE*) dwBuffer + initialAlignment;

            // Copy first aligned DWORDS from the source
            dwBuffer[0] = *alignedSrc;
            // Copy next one only if pixel is split between 2 aligned DWORDS
            if (initialAlignment >= 2)
                dwBuffer[1] = *(alignedSrc + 1);

            // Copy 4 bytes to the destination
            //  This will cause an extra byte to have garbage in the
            //  destination buffer, but will be overwritten if next pixel
            //  is used.
            *((DWORD*) d) = *((UNALIGNED DWORD*) pByte);
        }

        bl++;
        s += 3;
        if (--count == 0)
            return;
    }

    while (TRUE)
    {
        // Find the first pixel to copy
    
        while (!sRGB::isTranslucent(*bl))
        {
            bl++;
            s += 3;
            if (--count == 0)
            {                           
                return;
            }
        }

        UINT32 *startSrc = (UINT32*) ((ULONG_PTR) (s) & ~3);
    
        // Now find the first "don't copy" pixel after that:
    
        while (sRGB::isTranslucent(*bl))
        {
            bl++;
            s += 3;
            if (--count == 0)
            {
                break;
            }
        }

        // 'endSrc' is inclusive of the last pixel's last byte:

        UINT32 *endSrc = (UINT32*) ((ULONG_PTR) (s + 2) & ~3);
        UNALIGNED UINT32 *dstPtr = (UNALIGNED UINT32*) ((ULONG_PTR) startSrc + srcToDstDelta);
    
        while (startSrc <= endSrc)
        {
            *dstPtr++ = *startSrc++;
        }

        if (count == 0)
            return;
    }
}

// 24bpp, for sRGB64

VOID FASTCALL
ScanOperation::ReadRMW_24_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_ALPHA_sRGB64
    
    ULONG_PTR srcToDstDelta = (ULONG_PTR) d - (ULONG_PTR) s;

    // Handle the initial partial read:

    INT initialAlignment = (INT) ((ULONG_PTR) s & 3);
    if (initialAlignment)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            UINT32 *alignedSrc = (UINT32*) ((ULONG_PTR) s & ~3);
            DWORD dwBuffer[2];

            // Get pointer to start of pixel inside dwBuffer
            BYTE *pByte = (BYTE*) dwBuffer + initialAlignment;

            // Copy first aligned DWORDS from the source
            dwBuffer[0] = *alignedSrc;
            // Copy next one only if pixel is split between 2 aligned DWORDS
            if (initialAlignment >= 2)
                dwBuffer[1] = *(alignedSrc + 1);

            // Copy 4 bytes to the destination
            //  This will cause an extra byte to have garbage in the
            //  destination buffer, but will be overwritten if next pixel
            //  is used.
            *((DWORD*) d) = *((UNALIGNED DWORD*) pByte);
        }

        alpha += 4;
        s += 3;
        if (--count == 0)
            return;
    }

    while (TRUE)
    {
        // Find the first pixel to copy
    
        while (!SHOULDCOPY_sRGB64(*alpha))
        {
            alpha += 4;
            s += 3;
            if (--count == 0)
            {                           
                return;
            }
        }

        UINT32 *startSrc = (UINT32*) ((ULONG_PTR) (s) & ~3);
    
        // Now find the first "don't copy" pixel after that:
    
        while (SHOULDCOPY_sRGB64(*alpha))
        {
            alpha += 4;
            s += 3;
            if (--count == 0)
            {
                break;
            }
        }

        // 'endSrc' is inclusive of the last pixel's last byte:

        UINT32 *endSrc = (UINT32*) ((ULONG_PTR) (s + 2) & ~3);
        UNALIGNED UINT32 *dstPtr = (UNALIGNED UINT32*) ((ULONG_PTR) startSrc + srcToDstDelta);
    
        while (startSrc <= endSrc)
        {
            *dstPtr++ = *startSrc++;
        }

        if (count == 0)
            return;
    }
}

// 32bpp, for sRGB

VOID FASTCALL
ScanOperation::ReadRMW_32_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT32, UINT32)
    DECLARE_BLEND_sRGB
    
    while (count--)
    {
        if (sRGB::isTranslucent(*bl))
        {
            *d = *s;
        }
        
        d++;
        s++;
        bl++;
    }
}

// 32bpp, for sRGB64

VOID FASTCALL
ScanOperation::ReadRMW_32_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT32, UINT32)
    DECLARE_ALPHA_sRGB64
    
    while (count--)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *d = *s;
        }
        
        d++;
        s++;
        alpha += 4;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\stretch.inc ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name & Abstract
*
*   Stretch. This module contains the code to do various stretching
*   by applying a kernel filter. The code correctly handles minification.
*
* Note:
*   This module is not compiled into an .obj file, rather it is included
*   directly into the header file stretch.hpp.
*   This is due to the use of template functions.
*
*
* Notes:
*
*   This code does not handle rotation or shear.
*
* Created:
*
*   04/17/2000 asecchia
*      Created it.
*
**************************************************************************/

#define LAST_K_UNUSED ((INT)0x7fffffff)

const INT BicubicKernelShift = 7;
const INT BicubicKernelSize = 1 << BicubicKernelShift;
const FIX16 BicubicKernel[BicubicKernelSize+1] =
{
    65536, 65496, 65379, 65186, 64920, 64583, 64177, 63705,
    63168, 62569, 61911, 61195, 60424, 59600, 58725, 57802,
    56832, 55818, 54763, 53668, 52536, 51369, 50169, 48939,
    47680, 46395, 45087, 43757, 42408, 41042, 39661, 38268,
    36864, 35452, 34035, 32614, 31192, 29771, 28353, 26941,
    25536, 24141, 22759, 21391, 20040, 18708, 17397, 16110,
    14848, 13614, 12411, 11240, 10104,  9005,  7945,  6927,
     5952,  5023,  4143,  3313, 2536,  1814,  1149,   544,
        0,  -496,  -961, -1395, -1800, -2176, -2523, -2843,
    -3136, -3403, -3645, -3862, -4056, -4227, -4375, -4502,
    -4608, -4694, -4761, -4809, -4840, -4854, -4851, -4833,
    -4800, -4753, -4693, -4620, -4536, -4441, -4335, -4220,
    -4096, -3964, -3825, -3679, -3528, -3372, -3211, -3047,
    -2880, -2711, -2541, -2370, -2200, -2031, -1863, -1698,
    -1536, -1378, -1225, -1077, -936,  -802,  -675,  -557,
     -448,  -349,  -261,  -184, -120,   -69,   -31,    -8,
        0
};

const FIX16 SymmetricBicubicKernel[BicubicKernelSize * 2 + 1] =
{
    0,
     -8, -31, -69, -120, -184, -261,-349, -448,
    -557, -675,  -802, -936, -1077, -1225, -1378, -1536,
    -1698, -1863, -2031, -2200, -2370, -2541, -2711, -2880,
    -3047, -3211, -3372, -3528, -3679, -3825, -3964, -4096,
    -4220, -4335, -4441, -4536, -4620, -4693, -4753, -4800,
    -4833, -4851, -4854, -4840, -4809, -4761, -4694, -4608,
    -4502, -4375, -4227, -4056, -3862, -3645, -3403, -3136,
    -2843, -2523, -2176, -1800, -1395, -961, -496,
    0,
    544, 1149, 1814, 2536, 3313, 4143, 5023, 5952,
    6927,  7945,9005, 10104, 11240, 12411, 13614, 14848,
    16110,  17397, 18708, 20040, 21391, 22759, 24141, 25536,
    26941, 28353, 29771, 31192, 32614, 34035, 35452, 36864,
    38268, 39661, 41042, 42408, 43757,  45087, 46395, 47680,
    48939,  50169, 51369, 52536, 53668, 54763, 55818, 56832,
    57802,  58725, 59600, 60424, 61195, 61911, 62569, 63168,
    63705,  64177, 64583, 64920, 65186, 65379, 65496,
65536,
    65496, 65379, 65186, 64920, 64583, 64177, 63705,
    63168, 62569, 61911, 61195, 60424, 59600, 58725, 57802,
    56832, 55818, 54763, 53668, 52536, 51369, 50169, 48939,
    47680, 46395, 45087, 43757, 42408, 41042, 39661, 38268,
    36864, 35452, 34035, 32614, 31192, 29771, 28353, 26941,
    25536, 24141, 22759, 21391, 20040, 18708, 17397, 16110,
    14848, 13614, 12411, 11240, 10104,  9005,  7945,  6927,
     5952,  5023,  4143,  3313, 2536,  1814,  1149,   544,
     0,
    -496,  -961, -1395, -1800, -2176, -2523, -2843,
    -3136, -3403, -3645, -3862, -4056, -4227, -4375, -4502,
    -4608, -4694, -4761, -4809, -4840, -4854, -4851, -4833,
    -4800, -4753, -4693, -4620, -4536, -4441, -4335, -4220,
    -4096, -3964, -3825, -3679, -3528, -3372, -3211, -3047,
    -2880, -2711, -2541, -2370, -2200, -2031, -1863, -1698,
    -1536, -1378, -1225, -1077, -936,  -802,  -675,  -557,
     -448,  -349,  -261,  -184, -120,   -69,   -31,    -8,
     0
};

/*
// Higher precision bicubic kernel - more data.
// Commented out in case we eventually need it.
const FIX16 BK[512+1] = 
{
    0,
    -2, -8, -18, -31, -48, -69, -93, -120, 
    -151, -184, -221, -261, -304, -349, -397, -448, 
    -501, -557, -615, -675, -737, -802, -868, -936, 
    -1006, -1077, -1150, -1225, -1301, -1378, -1457, -1536, 
    -1616, -1698, -1780, -1863, -1947, -2031, -2115, -2200, 
    -2285, -2370, -2456, -2541, -2626, -2711, -2796, -2880, 
    -2964, -3047, -3129, -3211, -3292, -3372, -3450, -3528, 
    -3604, -3679, -3753, -3825, -3895, -3964, -4031, -4096, 
    -4159, -4220, -4279, -4335, -4389, -4441, -4490, -4536, 
    -4580, -4620, -4658, -4693, -4725, -4753, -4778, -4800, 
    -4818, -4833, -4844, -4851, -4854, -4854, -4849, -4840, 
    -4827, -4809, -4787, -4761, -4730, -4694, -4654, -4608, 
    -4557, -4502, -4441, -4375, -4304, -4227, -4144, -4056, 
    -3962, -3862, -3757, -3645, -3527, -3403, -3273, -3136, 
    -2993, -2843, -2686, -2523, -2353, -2176, -1991, -1800, 
    -1601, -1395, -1182, -961, -732, -496, -252, 
    0, 
    264, 544, 839, 1149, 1474, 1814, 2168, 2536, 
    2918, 3313, 3722, 4143, 4577, 5023, 5482, 5952, 
    6434, 6927, 7430, 7945, 8470, 9005, 9550, 10104, 
    10668, 11240, 11821, 12411, 13009, 13614, 14228, 14848, 
    15475, 16110, 16750, 17397, 18050, 18708, 19371, 20040, 
    20713, 21391, 22073, 22759, 23449, 24141, 24837, 25536, 
    26237, 26941, 27646, 28353, 29061, 29771, 30481, 31192, 
    31903, 32614, 33325, 34035, 34744, 35452, 36159, 36864, 
    37567, 38268, 38966, 39661, 40353, 41042, 41727, 42408, 
    43085, 43757, 44425, 45087, 45744, 46395, 47041, 47680, 
    48313, 48939, 49557, 50169, 50773, 51369, 51957, 52536, 
    53107, 53668, 54220, 54763, 55296, 55818, 56331, 56832, 
    57322, 57802, 58269, 58725, 59169, 59600, 60018, 60424, 
    60816, 61195, 61560, 61911, 62248, 62569, 62876, 63168, 
    63444, 63705, 63949, 64177, 64388, 64583, 64760, 64920, 
    65062, 65186, 65292, 65379, 65447, 65496, 65526, 
    65536, 
    65526, 65496, 65447, 65379, 65292, 65186, 65062, 64920, 
    64760, 64583, 64388, 64177, 63949, 63705, 63444, 63168, 
    62876, 62569, 62248, 61911, 61560, 61195, 60816, 60424, 
    60018, 59600, 59169, 58725, 58269, 57802, 57322, 56832, 
    56331, 55818, 55296, 54763, 54220, 53668, 53107, 52536, 
    51957, 51369, 50773, 50169, 49557, 48939, 48313, 47680, 
    47041, 46395, 45744, 45087, 44425, 43757, 43085, 42408, 
    41727, 41042, 40353, 39661, 38966, 38268, 37567, 36864, 
    36159, 35452, 34744, 34035, 33325, 32614, 31903, 31192, 
    30481, 29771, 29061, 28353, 27646, 26941, 26237, 25536, 
    24837, 24141, 23449, 22759, 22073, 21391, 20713, 20040, 
    19371, 18708, 18050, 17397, 16750, 16110, 15475, 14848, 
    14228, 13614, 13009, 12411, 11821, 11240, 10668, 10104, 
    9550, 9005, 8470, 7945, 7430, 6927, 6434, 5952, 
    5482, 5023, 4577, 4143, 3722, 3313, 2918, 2536, 
    2168, 1814, 1474, 1149, 839, 544, 264, 
    0,
    -252, -496, -732, -961, -1182, -1395, -1601, -1800, 
    -1991, -2176, -2353, -2523, -2686, -2843, -2993, -3136, 
    -3273, -3403, -3527, -3645, -3757, -3862, -3962, -4056, 
    -4144, -4227, -4304, -4375, -4441, -4502, -4557, -4608, 
    -4654, -4694, -4730, -4761, -4787, -4809, -4827, -4840, 
    -4849, -4854, -4854, -4851, -4844, -4833, -4818, -4800, 
    -4778, -4753, -4725, -4693, -4658, -4620, -4580, -4536, 
    -4490, -4441, -4389, -4335, -4279, -4220, -4159, -4096, 
    -4031, -3964, -3895, -3825, -3753, -3679, -3604, -3528, 
    -3450, -3372, -3292, -3211, -3129, -3047, -2964, -2880, 
    -2796, -2711, -2626, -2541, -2456, -2370, -2285, -2200, 
    -2115, -2031, -1947, -1863, -1780, -1698, -1616, -1536, 
    -1457, -1378, -1301, -1225, -1150, -1077, -1006, -936, 
    -868, -802, -737, -675, -615, -557, -501, -448, 
    -397, -349, -304, -261, -221, -184, -151, -120, 
    -93, -69, -48, -31, -18, -8, -2, 
    0
};


// Bicubic kernel with the 'perceptual' coefficient tweaked
// see Wolberg. Provides a slightly different experience.
// Commented out in case we eventually need it.

const FIX16 BK_V[512+1] =
{

    0,
    -4, -16, -35, -62, -96, -137, -185, -240, 
    -301, -369, -442, -522, -607, -698, -795, -896, 
    -1002, -1114, -1230, -1350, -1475, -1603, -1736, -1872, 
    -2012, -2155, -2301, -2450, -2602, -2756, -2913, -3072, 
    -3233, -3396, -3560, -3726, -3893, -4061, -4230, -4400, 
    -4570, -4741, -4911, -5082, -5252, -5422, -5592, -5760, 
    -5927, -6094, -6259, -6422, -6584, -6743, -6901, -7056, 
    -7209, -7359, -7506, -7650, -7791, -7928, -8062, -8192, 
    -8318, -8440, -8557, -8670, -8778, -8881, -8979, -9072, 
    -9159, -9241, -9316, -9386, -9449, -9506, -9557, -9600, 
    -9636, -9666, -9688, -9702, -9709, -9707, -9698, -9680, 
    -9654, -9619, -9575, -9522, -9460, -9388, -9307, -9216, 
    -9115, -9004, -8882, -8750, -8607, -8453, -8288, -8112, 
    -7924, -7725, -7513, -7290, -7054, -6806, -6546, -6272, 
    -5985, -5686, -5373, -5046, -4706, -4351, -3983, -3600, 
    -3203, -2791, -2364, -1922, -1465, -992, -504, 
    0, 
    516, 1040, 1571, 2110, 2656, 3209, 3769, 4336, 
    4909, 5489, 6074, 6666, 7263, 7866, 8475, 9088, 
    9706, 10330, 10958, 11590, 12227, 12867, 13512, 14160, 
    14812, 15467, 16125, 16786, 17450, 18116, 18785, 19456, 
    20129, 20804, 21480, 22158, 22837, 23517, 24198, 24880, 
    25562, 26245, 26927, 27610, 28292, 28974, 29656, 30336, 
    31015, 31694, 32371, 33046, 33720, 34391, 35061, 35728, 
    36393, 37055, 37714, 38370, 39023, 39672, 40318, 40960, 
    41598, 42232, 42861, 43486, 44106, 44721, 45331, 45936, 
    46535, 47129, 47716, 48298, 48873, 49442, 50005, 50560, 
    51108, 51650, 52184, 52710, 53229, 53739, 54242, 54736, 
    55222, 55699, 56167, 56626, 57076, 57516, 57947, 58368, 
    58779, 59180, 59570, 59950, 60319, 60677, 61024, 61360, 
    61684, 61997, 62297, 62586, 62862, 63126, 63378, 63616, 
    63841, 64054, 64253, 64438, 64610, 64767, 64911, 65040, 
    65155, 65255, 65340, 65410, 65465, 65504, 65528, 
    65536, 
    65528, 65504, 65465, 65410, 65340, 65255, 65155, 65040, 
    64911, 64767, 64610, 64438, 64253, 64054, 63841, 63616, 
    63378, 63126, 62862, 62586, 62297, 61997, 61684, 61360, 
    61024, 60677, 60319, 59950, 59570, 59180, 58779, 58368, 
    57947, 57516, 57076, 56626, 56167, 55699, 55222, 54736, 
    54242, 53739, 53229, 52710, 52184, 51650, 51108, 50560, 
    50005, 49442, 48873, 48298, 47716, 47129, 46535, 45936, 
    45331, 44721, 44106, 43486, 42861, 42232, 41598, 40960, 
    40318, 39672, 39023, 38370, 37714, 37055, 36393, 35728, 
    35061, 34391, 33720, 33046, 32371, 31694, 31015, 30336, 
    29656, 28974, 28292, 27610, 26927, 26245, 25562, 24880, 
    24198, 23517, 22837, 22158, 21480, 20804, 20129, 19456, 
    18785, 18116, 17450, 16786, 16125, 15467, 14812, 14160, 
    13512, 12867, 12227, 11590, 10958, 10330, 9706, 9088, 
    8475, 7866, 7263, 6666, 6074, 5489, 4909, 4336, 
    3769, 3209, 2656, 2110, 1571, 1040, 516, 
    0, 
    -504, -992, -1465, -1922, -2364, -2791, -3203, -3600, 
    -3983, -4351, -4706, -5046, -5373, -5686, -5985, -6272, 
    -6546, -6806, -7054, -7290, -7513, -7725, -7924, -8112, 
    -8288, -8453, -8607, -8750, -8882, -9004, -9115, -9216, 
    -9307, -9388, -9460, -9522, -9575, -9619, -9654, -9680, 
    -9698, -9707, -9709, -9702, -9688, -9666, -9636, -9600, 
    -9557, -9506, -9449, -9386, -9316, -9241, -9159, -9072, 
    -8979, -8881, -8778, -8670, -8557, -8440, -8318, -8192, 
    -8062, -7928, -7791, -7650, -7506, -7359, -7209, -7056, 
    -6901, -6743, -6584, -6422, -6259, -6094, -5927, -5760, 
    -5592, -5422, -5252, -5082, -4911, -4741, -4570, -4400, 
    -4230, -4061, -3893, -3726, -3560, -3396, -3233, -3072, 
    -2913, -2756, -2602, -2450, -2301, -2155, -2012, -1872, 
    -1736, -1603, -1475, -1350, -1230, -1114, -1002, -896, 
    -795, -698, -607, -522, -442, -369, -301, 
    -240, -185, -137, -96, -62, -35, -16, -4, 
    0
};
*/


// This is the table of partial sums of the bilinear kernel.
// Simply put, each point in the array represents the integral
// from -infinity to position x in the kernel function.
// We can subtract two table lookups to get the integral
// of the kernel (area) between the two points.
// The table is padded with zeros and ones at the beginning and end
// so we can consistently address areas outside of the actual kernel
// Currently we don't make use of the zeros at the beginning but
// we definitely sample past the end by at least one half-width
// of the kernel.

const FIX16 BilinearPartialIntegral[512+1] =
{   
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    
    0,2, 8, 18, 32, 50, 72, 98, 
    128, 162, 200, 242, 288, 338, 392, 450, 
    512, 578, 648, 722, 800, 882, 968, 1058, 
    1152, 1250, 1352, 1458, 1568, 1682, 1800, 1922, 
    2048, 2178, 2312, 2450, 2592, 2738, 2888, 3042, 
    3200, 3362, 3528, 3698, 3872, 4050, 4232, 4418, 
    4608, 4802, 5000, 5202, 5408, 5618, 5832, 6050, 
    6272, 6498, 6728, 6962, 7200, 7442, 7688, 7938, 
    8192, 8450, 8712, 8978, 9248, 9522, 9800, 10082, 
    10368, 10658, 10952, 11250, 11552, 11858, 12168, 12482, 
    12800, 13122, 13448, 13778, 14112, 14450, 14792, 15138, 
    15488, 15842, 16200, 16562, 16928, 17298, 17672, 18050, 
    18432, 18818, 19208, 19602, 20000, 20402, 20808, 21218, 
    21632, 22050, 22472, 22898, 23328, 23762, 24200, 24642, 
    25088, 25538, 25992, 26450, 26912, 27378, 27848, 28322, 
    28800, 29282, 29768, 30258, 30752, 31250, 31752, 32258, 
    
    32768, // center of the kernel. Index 256
    
    33278, 33784, 34286, 34784, 35278, 35768, 36254, 36736, 
    37214, 37688, 38158, 38624, 39086, 39544, 39998, 40448, 
    40894, 41336, 41774, 42208, 42638, 43064, 43486, 43904, 
    44318, 44728, 45134, 45536, 45934, 46328, 46718, 47104, 
    47486, 47864, 48238, 48608, 48974, 49336, 49694, 50048, 
    50398, 50744, 51086, 51424, 51758, 52088, 52414, 52736, 
    53054, 53368, 53678, 53984, 54286, 54584, 54878, 55168, 
    55454, 55736, 56014, 56288, 56558, 56824, 57086, 57344, 
    57598, 57848, 58094, 58336, 58574, 58808, 59038, 59264, 
    59486, 59704, 59918, 60128, 60334, 60536, 60734, 60928, 
    61118, 61304, 61486, 61664, 61838, 62008, 62174, 62336, 
    62494, 62648, 62798, 62944, 63086, 63224, 63358, 63488, 
    63614, 63736, 63854, 63968, 64078, 64184, 64286, 64384, 
    64478, 64568, 64654, 64736, 64814, 64888, 64958, 65024, 
    65086, 65144, 65198, 65248, 65294, 65336, 65374, 65408, 
    65438, 65464, 65486, 65504, 65518, 65528, 65534, 65536,
    
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
};

// This is the table of partial sums of the bicubic kernel.
// Simply put, each point in the array represents the integral
// from -infinity to position x in the kernel function.
// We can subtract two table lookups to get the integral
// of the kernel (area) between the two points.
// The table is padded with zeros and ones at the beginning and end
// so we can consistently address areas outside of the actual kernel
// Currently we don't make use of the zeros at the beginning but
// we definitely sample past the end by at least one half-width
// of the kernel.

const FIX16 BicubicPartialIntegral[1024+1] =
{   
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,

    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,

    0, 0, 0, 0, -1, -2, -3, -4, 
    -6, -8, -11, -15, -19, -24, -29, -35, 
    -42, -50, -59, -68, -79, -90, -103, -117, 
    -131, -147, -164, -182, -201, -221, -243, -265, 
    -289, -315, -341, -369, -398, -429, -460, -493, 
    -528, -563, -600, -639, -679, -720, -762, -806, 
    -851, -897, -945, -993, -1044, -1095, -1148, -1202, 
    -1257, -1313, -1371, -1429, -1489, -1550, -1612, -1675, 
    -1739, -1804, -1870, -1937, -2004, -2073, -2142, -2212, 
    -2283, -2355, -2427, -2500, -2573, -2647, -2721, -2796, 
    -2871, -2946, -3022, -3097, -3173, -3249, -3325, -3401, 
    -3476, -3552, -3627, -3702, -3776, -3850, -3923, -3996, 
    -4068, -4139, -4209, -4279, -4347, -4414, -4481, -4545, 
    -4609, -4671, -4731, -4790, -4847, -4902, -4955, -5006, 
    -5055, -5102, -5146, -5188, -5228, -5264, -5298, -5329, 
    -5358, -5383, -5404, -5423, -5438, -5449, -5457, -5461, 
    -5461, -5457, -5449, -5437, -5420, -5399, -5374, -5345, 
    -5311, -5273, -5230, -5182, -5130, -5073, -5012, -4946, 
    -4875, -4799, -4718, -4633, -4542, -4447, -4346, -4240, 
    -4130, -4014, -3893, -3767, -3636, -3500, -3358, -3212, 
    -3060, -2902, -2740, -2572, -2399, -2220, -2037, -1848, 
    -1653, -1454, -1249, -1038, -822, -601, -375, -143, 
    94, 336, 584, 836, 1095, 1358, 1627, 1901, 
    2180, 2464, 2754, 3048, 3348, 3653, 3963, 4278, 
    4598, 4923, 5253, 5588, 5927, 6272, 6621, 6975, 
    7334, 7698, 8066, 8439, 8816, 9198, 9584, 9975, 
    10370, 10769, 11173, 11580, 11992, 12408, 12828, 13252, 
    13679, 14111, 14546, 14985, 15427, 15873, 16322, 16775, 
    17231, 17690, 18152, 18618, 19086, 19557, 20032, 20508, 
    20988, 21470, 21954, 22441, 22930, 23421, 23914, 24409, 
    24906, 25405, 25905, 26407, 26911, 27415, 27921, 28428, 
    28937, 29446, 29955, 30466, 30977, 31488, 32000, 32512, 
    
    33024, // center of the kernel. Index 512
    
    33536, 34048, 34559, 35070, 35581, 36090, 36599, 37108, 
    37615, 38121, 38625, 39129, 39631, 40131, 40630, 41127, 
    41622, 42115, 42606, 43095, 43582, 44066, 44548, 45028, 
    45504, 45979, 46450, 46918, 47384, 47846, 48305, 48761, 
    49214, 49663, 50109, 50551, 50990, 51425, 51857, 52284, 
    52708, 53128, 53544, 53956, 54363, 54767, 55166, 55561, 
    55952, 56338, 56720, 57097, 57470, 57838, 58202, 58561, 
    58915, 59264, 59609, 59948, 60283, 60613, 60938, 61258, 
    61573, 61883, 62188, 62488, 62782, 63072, 63356, 63635, 
    63909, 64178, 64441, 64700, 64952, 65200, 65442, 65679, 
    65911, 66137, 66358, 66574, 66785, 66990, 67189, 67384, 
    67573, 67756, 67935, 68108, 68276, 68438, 68596, 68748, 
    68894, 69036, 69172, 69303, 69429, 69550, 69666, 69776, 
    69882, 69983, 70078, 70169, 70254, 70335, 70411, 70482, 
    70548, 70609, 70666, 70718, 70766, 70809, 70847, 70881, 
    70910, 70935, 70956, 70973, 70985, 70993, 70997, 70997, 
    70993, 70985, 70974, 70959, 70940, 70919, 70894, 70865, 
    70834, 70800, 70764, 70724, 70682, 70638, 70591, 70542, 
    70491, 70438, 70383, 70326, 70267, 70207, 70145, 70081, 
    70017, 69950, 69883, 69815, 69745, 69675, 69604, 69532, 
    69459, 69386, 69312, 69238, 69163, 69088, 69012, 68937, 
    68861, 68785, 68709, 68633, 68558, 68482, 68407, 68332, 
    68257, 68183, 68109, 68036, 67963, 67891, 67819, 67748, 
    67678, 67609, 67540, 67473, 67406, 67340, 67275, 67211, 
    67148, 67086, 67025, 66965, 66907, 66849, 66793, 66738, 
    66684, 66631, 66580, 66529, 66481, 66433, 66387, 66342, 
    66298, 66256, 66215, 66175, 66136, 66099, 66064, 66029, 
    65996, 65965, 65934, 65905, 65877, 65851, 65825, 65801, 
    65779, 65757, 65737, 65718, 65700, 65683, 65667, 65653, 
    65639, 65626, 65615, 65604, 65595, 65586, 65578, 65571, 
    65565, 65560, 65555, 65551, 65547, 65544, 65542, 65540, 
    65539, 65538, 65537, 65536, 65536, 65536, 65536, 65536, 

    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 

    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
    65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 
};


// We use a biased pointer to the center of the array
// so that we can look up the negative part of the kernel
// without repositioning the index or using an absolute value
// computation in the inner loop.

// Linear Partial Integral Center.
const FIX16 *LPIC = &BilinearPartialIntegral[256];

// Cubic Partial Integral Center.
const FIX16 *CPIC = &BicubicPartialIntegral[512];

const FIX16 *SymmetricBicubicKernelCenter = &SymmetricBicubicKernel[128];

const ULONGLONG FIX14_HALF_MMX = 0x0000200000002000;

/**************************************************************************
*
* Function Description:
*
*   Constructor for the DpOutputSpanStretch class.
*
* Return Value:
*
*   NONE
*
* Created:
*
*   04/17/2000 asecchia
*      Created it.
*
**************************************************************************/

#define FIX4TOFIX16_SHIFT (FIX16_SHIFT - FIX4_SHIFT)

template<FilterModeType FilterMode>
void DpOutputSpanStretch<FilterMode>::InitializeClass(
    DpBitmap* bitmap,
    DpScanBuffer * scan,
    DpContext* /*context*/,
    DpImageAttributes imgAttributes,
    const GpRectF *dstRect,
    const GpRectF *srcRect
    )
{
    isValid = true;
    
    // Make sure these get initialized up front before we can early out
    // otherwise we could end up freeing uninitialized pointers in our
    // destructor.
    
    ycoeff = NULL;
    xbuffer = NULL;
    
    Scan     = scan;
    dBitmap   = bitmap;

    QWrapMode = imgAttributes.wrapMode;

    ClampColor = imgAttributes.clampColor;

    ClampColorA = (BYTE)( (ClampColor >> 24) );
    ClampColorR = (BYTE)( (ClampColor >> 16) & 0xff);
    ClampColorG = (BYTE)( (ClampColor >> 8) & 0xff);
    ClampColorB = (BYTE)(  ClampColor & 0xff);

    // Accleration for clamp mode with zero clamp color (transparent)

    WrapZeroClamp = FALSE;
    if((QWrapMode == WrapModeClamp) &&
       (imgAttributes.clampColor == 0))
    {
        WrapZeroClamp = TRUE;
    }



    ASSERT(dBitmap != NULL);
    ASSERT(dBitmap->IsValid());

    // on bad bitmap, we return with Valid = FALSE
    if (dBitmap == NULL ||
        !dBitmap->IsValid()
        )
    {
        dBitmap = NULL;
        isValid = false;
        return;
    } else {
        BmpData.Width = dBitmap->Width;
        BmpData.Height = dBitmap->Height;
        BmpData.PixelFormat = PIXFMT_32BPP_PARGB;
        BmpData.Stride = dBitmap->Delta;
        BmpData.Scan0 = dBitmap->Bits;
    }

    if(srcRect)
        SrcRect = *srcRect;
    else
    {
        SrcRect.X = 0.0f;
        SrcRect.Y = 0.0f;
        SrcRect.Width  = (REAL)dBitmap->Width;
        SrcRect.Height = (REAL) dBitmap->Height;
    }

    // Set up the translation.
    if(dstRect)
    {
         DstRect = *dstRect;
    }
    else
    {
         DstRect.X = 0.0f;
         DstRect.Y = 0.0f;
         DstRect.Width = (REAL)SrcRect.Width;
         DstRect.Height = (REAL)SrcRect.Height;
    }


    if( !GpValidFixed16(SrcRect.X) ||
        !GpValidFixed16(SrcRect.Y) ||
        !GpValidFixed16(SrcRect.Width) ||
        !GpValidFixed16(SrcRect.Height) ||
        !GpValidFixed16(DstRect.X) ||
        !GpValidFixed16(DstRect.Y) ||
        !GpValidFixed16(DstRect.Width) ||
        !GpValidFixed16(DstRect.Height) )
    {
        // punt
        
        isValid = false;
        return;
    }
        

    // Initialize the state for the x-dimension scale.

    xscale = GpRealToFix16(SrcRect.Width/DstRect.Width);
    xscaleinv = GpRealToFix16(DstRect.Width/SrcRect.Width);

    // Initialize the state for the y-dimension scale.

    yscale = GpRealToFix16(SrcRect.Height/DstRect.Height);
    yscaleinv = GpRealToFix16(DstRect.Height/SrcRect.Height);

    // Compute the destination contribution.
    // Note: the actual pixels touched are the floor of
    // the top left to the ceiling of the bottom right.
    // (modulus the clipping)

    // Note: We want to be tracking our internal state in FIX16 so we have
    // the extra fractional precision, but when we compute our bounds for the
    // drawing, we use Ceiling and Floor on these FIX16 numbers below. We want
    // the rounding to match the rounding of the FIX4 numbers (i.e. we don't
    // want to track any extra fractional precision errors from the float
    // representation) because we use FIX4 in our DrawImage loop.
    // To accomplish this, we round to FIX4 dropping all error that is smaller
    // than the FIX4 precision and then upconvert to FIX16. Now when we use
    // Fix16Ceiling and Floor, we'll get the same results as Fix4Ceiling and
    // Floor.

    REAL xinv = DstRect.Width/SrcRect.Width;
    REAL yinv = DstRect.Height/SrcRect.Height;

    fixDLeft = GpRealToFix4(DstRect.X);
    fixDRight = GpRealToFix4(xinv * (SrcRect.Width) + DstRect.X);
    fixDTop = GpRealToFix4(DstRect.Y);
    fixDBottom = GpRealToFix4(yinv * (SrcRect.Height) + DstRect.Y);

    // Handle negative scale

    FIX16 fixTemp;

    if(fixDLeft > fixDRight)
    {
        // Swap the left and right x coordinates.
        fixTemp = fixDLeft;
        fixDLeft = fixDRight;
        fixDRight = fixTemp;
    }

    if(fixDTop > fixDBottom)
    {
        // Swap the top and bottom x coordinates.
        fixTemp = fixDTop;
        fixDTop = fixDBottom;
        fixDBottom = fixTemp;
    }

    // Compute the left edge using the rasterizer rounding rules. Used
    // for clipping in x.
    
    ixleft = GpFix4Ceiling(fixDLeft);
    
    // Convert up to FIX16.
    
    fixDLeft   <<= FIX4TOFIX16_SHIFT;    
    fixDRight  <<= FIX4TOFIX16_SHIFT;    
    fixDTop    <<= FIX4TOFIX16_SHIFT;    
    fixDBottom <<= FIX4TOFIX16_SHIFT;    

    // Get the initial kernel center. This specifies the x-dimension
    // fractional pixel offset.

    if(xscale < 0)
    {
        xkci = GpRealToFix16(
            (((DstRect.X+DstRect.Width) - GpFix16Ceiling(fixDRight)) *
            (xscale)) / FIX16_ONE +
            SrcRect.X
        );
    }
    else
    {
        xkci = GpRealToFix16(
            ((DstRect.X - GpFix16Floor(fixDLeft)) *
            xscale) / FIX16_ONE +
            SrcRect.X
        );
    }

    // Get the width of the kernel.
    // Make sure to multiply by the actual width of the filter kernel in
    // normalized space (FilterWidth[i])

    xw = GpRealToFix16(
        (SrcRect.Width*FilterWidth[FilterMode]) /
        DstRect.Width
    );       // convert to FIX16

    // Handle the negative transform

    if(xscale < 0)
    {
        xw = -xw;
    }

    // the width of the kernel must be a positive quantity.

    ASSERT(xw >= 0);

    // if the width is less than one we're doing a stretch, not a shrink.
    // in this case we clamp the kernel size to one.

    if(xw < FIX16_ONE * FilterWidth[FilterMode])
    {
        xw = FIX16_ONE * FilterWidth[FilterMode];
    }

    // a is 1/w - used to work out the tent filter.

    xa = GpRealToFix16(65536.0f/xw);

    // Get the initial kernel center. This specifies the y-dimension
    // fractional pixel offset.

    if(yscale < 0)
    {
        ykci = GpRealToFix16(
            ((GpFix16Ceiling(fixDBottom) - (DstRect.Y+DstRect.Height)) *
            (-yscale)) / FIX16_ONE +
            SrcRect.Y
        );
    }
    else
    {
        ykci = GpRealToFix16(
            ((GpFix16Floor(fixDTop) - DstRect.Y) *
            yscale) / FIX16_ONE +
            SrcRect.Y
        );
    }

    // Get the width of the kernel.
    // Make sure to multiply by the actual width of the filter kernel in
    // normalized space (FilterWidth[i])

    yw = GpRealToFix16(
        (SrcRect.Height * FilterWidth[FilterMode]) /
        DstRect.Height
    );      // Convert to FIX16

    // Handle the negative transform

    if(yscale < 0)
    {
        yw = -yw;
    }

    // the width of the kernel must be a positive quantity.

    ASSERT(yw >= 0);

    // if the kernel width is less than one we're doing a stretch, not
    // a shrink. In this case we clamp the kernel size to one.

    if(yw < (FIX16_ONE * FilterWidth[FilterMode]))
    {
        yw = FIX16_ONE * FilterWidth[FilterMode];
    }

    // a is 1/w - used to work out the tent filter.

    ya = GpRealToFix16(65536.0f/yw);

    // !!! [asecchia] The rounding used here should match the rounding used to compute
    // the parameters to StretchBitsMainLoop.

    iytop = GpFix16Floor(fixDTop);

    // Compute the width of one scanline in the destination.

    xbuffer_width = GpFix16Ceiling(fixDRight) - GpFix16Floor(fixDLeft);
    ASSERT(xbuffer_width >= 0);

    xbuffer_height = GpFix16Ceiling(yw)*2+1;
    ASSERT(xbuffer_height >= 0);

    // set the rotational array to start at the first scanline.

    xbuffer_start_scanline = 0;

    // allocate the xbuffer.

    // !!! PERF [asecchia]. Ouch this is ugly.
    // we should at least try use a stack buffer for small images.
    // Maybe a lookaside list or something.

    xbuffer = (ARGB *)GpMalloc(xbuffer_height*xbuffer_width*sizeof(ARGB));
    
    // ycoeff needs to have 2 entries more than xbuffer_height because
    // it may be reused to store the MMX coefficients (see OutputSpan
    // routine for details).

    ycoeff = (FIX16 *)GpMalloc((xbuffer_height + 2) * sizeof(FIX16));

    if((NULL == ycoeff) || (NULL == xbuffer))
    {
        isValid = false;
        
        GpFree(xbuffer);
        GpFree(ycoeff);
        
        // Make sure these get initialized to NULL before we can early out
        // otherwise we could end up double freeing the pointers in our
        // destructor.
    
        xbuffer = NULL;
        ycoeff = NULL;
        
        return;
    }

    // set the initial value of last_k to maxint

    last_k = LAST_K_UNUSED;
}



/**************************************************************************\
*
* Function Description:
*
*   This function performs a 1d stretch using the tent filter
*
* Arguments:
*
*   dst   - destination buffer
*   src   - source pixels
*   dw    - destination width in pixels
*   sw    - source width in pixels
*   kci   - the initial kernel centering position (for fractional translate)
*   scale - the scale of the filter - sw/dw
*   w     - the width of the filter kernel - typically the ceiling of sw/dw
*   a     - 1/w
*
* History:
*   04/16/2000 asecchia   created it.
*
\**************************************************************************/

// !!! Perf [asecchia] For really complicated wrapmodes where many of the
//     pixels are outside of the source and hence need to be wrapped, it may
//     make more sense to copy the source into an extended buffer and pre-wrap
//     the end points (i.e. overallocate) for each scanline.
//     This could simplify the code for the complex wrap conditions.
//     However, for the simple codepath, this would give an extra copy per
//     pixel and might not be worth it.


// Ick. Why does the compiler do a better job of optimizing macros?
// These should really be inline function calls.

#define ClampColors() \
        if(FilterMode == HighQualityBilinear)       \
        {                                           \
            ta = GpFix16Round(ta);                  \
            tr = GpFix16Round(tr);                  \
            tg = GpFix16Round(tg);                  \
            tb = GpFix16Round(tb);                  \
            if(ta>255) ta = 255;                    \
            if(tr>255) tr = 255;                    \
            if(tg>255) tg = 255;                    \
            if(tb>255) tb = 255;                    \
        }                                           \
        if(FilterMode == HighQualityBicubic)        \
        {                                           \
            ta = GpFix16Round(ta);                  \
            tr = GpFix16Round(tr);                  \
            tg = GpFix16Round(tg);                  \
            tb = GpFix16Round(tb);                  \
            if(ta>255) ta = 255;                    \
            if(tr>ta) tr = ta;                      \
            if(tg>ta) tg = ta;                      \
            if(tb>ta) tb = ta;                      \
            if(ta<0) ta = 0;                        \
            if(tr<0) tr = 0;                        \
            if(tg<0) tg = 0;                        \
            if(tb<0) tb = 0;                        \
        }


// Compute the kernel in the inner loop
// Note: the If statements are compiled away in the final code
// because they are template variable comparisons which can be 
// done at compile time.

// This macro looks up the new kernel value, subtracts the old one
// to get the area of contribution for this pixel, computes the 
// new kernel position and stores the current table lookup.

#define ComputeKernel(pc, a, pa, pa_old, krn) \
            if(FilterMode == HighQualityBilinear)              \
            {                                                  \
                pa = LPIC[krn >> 9];                           \
                pc = pa-pa_old;                                \
                krn += (a);                                    \
                pa_old = pa;                                   \
            }                                                  \
            if(FilterMode == HighQualityBicubic)               \
            {                                                  \
                pa = CPIC[krn >> 8];                           \
                pc = pa-pa_old;                                \
                krn += (a);                                    \
                pa_old = pa;                                   \
            }

// This block of code accumulates the individual channels from
// kptr into the accumulation buffers tb, tg, tr, and ta.

#define AccumulateChannels(pc, kptr) \
{                        \
    tb += pc * kptr[0];  \
    tg += pc * kptr[1];  \
    tr += pc * kptr[2];  \
    ta += pc * kptr[3];  \
}



inline void Apply1DWrapModeX(INT WrapMode, INT &x, INT w)
{
    INT xm;
    switch(WrapMode) {

    case WrapModeTileFlipY:
    case WrapModeTile:
        x = RemainderI(x, w);
    break;

    case WrapModeTileFlipX:
    case WrapModeTileFlipXY:
        xm = RemainderI(x, w);
        if(((x-xm)/w) & 1) {
            x = w-1-xm;
        }
        else
        {
            x = xm;
        }
    break;

    default:
        // Caller should correctly anticipate other wrap modes.
        ASSERT(FALSE);
    break;
    }
}

inline void Apply1DWrapModeY(INT WrapMode, INT &y, INT h)
{
    INT ym;
    switch(WrapMode) {

    case WrapModeTile:
    case WrapModeTileFlipX:
        y = RemainderI(y, h);
        break;

    case WrapModeTileFlipY:
    case WrapModeTileFlipXY:
        ym = RemainderI(y, h);
        if(((y-ym)/h) & 1) {
            y = h-1-ym;
        }
        else
        {
            y = ym;
        }
    break;

    default:
        // Caller should correctly anticipate other wrap modes.
        ASSERT(FALSE);
    break;
    }
}


#undef RemainderI


/**************************************************************************
*
* Function Description:
*
*   Outputs the middle pixels in a 2:1 stretched scanline.  Note that
*   this function doesn't need to handle wrap modes.
*
*   Note:  this function must not use floating point values, because it could be
*   called with an invalid floating point state (prior to the call to emms)
*
* Arguments:
*
*   dst - The first pixel to be output
*   src - The first pixel in the source that will affect the destination
*         pixel in a bicubic 2:1 stretch
*   dw  - The number of pixels in the destination
*   kci - The subpixel shift in the position of the destination pixels
*
**************************************************************************/

void DpOutputSpanStretch<HighQualityBilinear>::StretchMiddleScanline2_MMX(
    ARGB *dst, 
    ARGB *src, 
    INT dw, 
    FIX16 kci 
)
{
    ASSERT(FALSE);
}

void DpOutputSpanStretch<HighQualityBicubic>::StretchMiddleScanline2_MMX(
    ARGB *dst, 
    ARGB *src, 
    INT dw, 
    FIX16 kci 
)
{
#if defined(_X86_)

    //
    // In order to store the kernel multipliers in 16bit registers, we 
    // will lose the bottom 3 precision bits (hence each k[i] must be 
    // right shifted by three).  The summation of the kernel multipliers
    // should come to 16K, hence KERNEL_SHIFT_AMOUNT is 14.
    //
     
#define KERNEL_SHIFT_AMOUNT 14     
     
    FIX16 k[8];
    FIX16 kernelIncrement = FIX16_ONE >> 2 ;
    FIX16 kCurrent = (kci >> 2) - FIX16_ONE;
    for (INT i = 0; i < 8; i++)
    {
        ASSERT(kCurrent >= -FIX16_ONE);
        ASSERT(kCurrent <= FIX16_ONE);

        k[i] = SymmetricBicubicKernelCenter[kCurrent >> (FIX16_SHIFT-BicubicKernelShift)]; 
        k[i] >>= 3;

        kCurrent += kernelIncrement;        
    }
    
    //
    // Setup 64bit aligned workspace for the MMX code
    //
    // 0 - zero
    // 8  - kernel multiplier 0
    // 16 - kernel multiplier 1
    // 24 - kernel multiplier 2
    // 32 - kernel multiplier 3
    // 40 - accumulator 3: g, b
    // 48 - accumulator 3: a, r
    // 56 - FIX14_HALF
    //

    #define BUFFER_SIZE 16    
    INT buffer[BUFFER_SIZE + 1];
    INT *buffer_64bitAligned = (INT *) ((((UINT_PTR) buffer) + 4) & ~0x7);
    
    buffer_64bitAligned[0]  = 0; // zero
    buffer_64bitAligned[1]  = 0;
    
    buffer_64bitAligned[2]  = (k[7] << 16) | (k[6] & 0xFFFF);   // kernel multiplier 0 
    buffer_64bitAligned[3]  = buffer_64bitAligned[2];

    buffer_64bitAligned[4]  = (k[5] << 16) | (k[4] & 0xFFFF);   // kernel multiplier 1 
    buffer_64bitAligned[5]  = buffer_64bitAligned[4];

    buffer_64bitAligned[6]  = (k[3] << 16) | (k[2] & 0xFFFF);   // kernel multiplier 2 
    buffer_64bitAligned[7]  = buffer_64bitAligned[6];

    buffer_64bitAligned[8]  = (k[1] << 16) | (k[0] & 0xFFFF);   // kernel multiplier 3 
    buffer_64bitAligned[9]  = buffer_64bitAligned[8];

    buffer_64bitAligned[10]  = 0; // Accumulator 3
    buffer_64bitAligned[11]  = 0;
    buffer_64bitAligned[12]  = 0;
    buffer_64bitAligned[13]  = 0;
    
    buffer_64bitAligned[14] = (1 << (14 - 1));       // FIX14_HALF
    buffer_64bitAligned[15] = (1 << (14 - 1));

    //
    // eax - counter for the first loop
    // ebx - 0xffffffff
    // esi - source
    // edi - destination
    // ecx - counter
    // edx - 64it aligned workspace buffer
    //
    // mm6, mm7: accumulator 0
    // mm4, mm5: accumulator 1
    //
    
    _asm
    {
        mov ebx, 0xFFFFFFFF
        mov esi, src
        mov edi, dst
        mov ecx, dw
        mov edx, buffer_64bitAligned
   

        //
        // The first loop loads the initial values into the accumulators, but
        // doesn't write out any pixels.  It executes exactly three times.
        //

        pxor mm4, mm4
        pxor mm5, mm5
        mov  eax, 3
            
loop1:
        
        //
        // Read expanded pixel values into mm0 and mm1
        //

        movd      mm1, [esi]         ; mm1 = 00000000a1r1g1b1
        movd      mm2, [esi + 4]     ; mm2 = 00000000a2r2g2b2
        add       esi, 8

        punpcklbw mm1, [edx]         ; mm1 = 00a100r100g100b1
        punpcklbw mm2, [edx]         ; mm2 = 00a200r200g200b2

        movq      mm0, mm1           ; mm0 = 00a100r100g100b1

        punpckhwd mm1, mm2           ; mm1 = 00a200a100r200r1
        punpcklwd mm0, mm2           ; mm0 = 00g200g100b200b1

        //
        // Add the contribution to accumulator 1
        //

        movq      mm6, [edx + 16]    ; kernel multiplier 1
        movq      mm7, mm6           ; kernel multiplier 1
        pmaddwd   mm6, mm0
        pmaddwd   mm7, mm1
        paddd     mm6, mm4
        paddd     mm7, mm5

        //
        // Add the contribution to accumulator 2
        //

        movq      mm4, [edx + 24]    ; kernel multiplier 2
        movq      mm5, mm4           ; kernel multiplier 2
        pmaddwd   mm4, mm0
        pmaddwd   mm5, mm1
        paddd     mm4, [edx + 40]
        paddd     mm5, [edx + 48]

        //
        // Compute the new third accumulator
        //

        pmaddwd   mm0, [edx + 32]    ; multiply by kernel multiplier 3
        pmaddwd   mm1, [edx + 32]
        movq      [edx + 40], mm0
        movq      [edx + 48], mm1

        dec eax
        jnz loop1


        //
        // The second loop continues to compute the accumulators, but
        // also writes out destination pixels.
        //

loop2:
        
        //
        // Read expanded pixel values into mm0 and mm1
        //

        movd      mm1, [esi]         ; mm1 = 00000000a1r1g1b1
        movd      mm2, [esi + 4]     ; mm2 = 00000000a2r2g2b2
        add       esi, 8

        punpcklbw mm1, [edx]         ; mm1 = 00a100r100g100b1
        punpcklbw mm2, [edx]         ; mm2 = 00a200r200g200b2

        movq      mm0, mm1           ; mm0 = 00a100r100g100b1

        punpckhwd mm1, mm2           ; mm1 = 00a200a100r200r1
        punpcklwd mm0, mm2           ; mm0 = 00g200g100b200b1

        //
        // Add the contribution to accumulator 0
        //

        movq      mm2, [edx + 8]     ; mm2 = kernel multiplier 0
        movq      mm3, mm2           ; mm3 = kernel multiplier 0
        pmaddwd   mm2, mm0           ; mm2 = 0000gggg0000bbbb
        pmaddwd   mm3, mm1           ; mm3 = 0000aaaa0000rrrr
        paddd     mm6, mm2           ; add contributions to accumulator 0
        paddd     mm7, mm3

        //
        // Extract the pixel value from accumulator 0.
        //

        paddd     mm6, [edx + 56]    ; round
        psrad     mm6, KERNEL_SHIFT_AMOUNT
        paddd     mm7, [edx + 56]
        psrad     mm7, KERNEL_SHIFT_AMOUNT
        packssdw  mm6, mm7           ; mm6 = 00aa00rr00gg00bb    
        packuswb  mm6, mm6           ; mm6 = 00000000aarrggbb

        //
        // Clip all channels to alpha
        //

        movd      mm2, ebx           ; mm2 = 00000000ffffffff
        movq      mm7, mm6           ; mm7 = 00000000aarrggbb
        psrad     mm7, 24            ; mm7 = 00000000000000aa
        punpcklbw mm7, mm7           ; mm7 = 000000000000aaaa
        punpcklbw mm7, mm7           ; mm7 = 00000000aaaaaaaa
        psubusb   mm2, mm7
        paddusb   mm6, mm2
        psubusb   mm6, mm2

        movd      [edi], mm6
        add       edi, 4
        
        //
        // Add the contribution to accumulator 1
        //

        movq      mm6, [edx + 16]    ; kernel multiplier 1
        movq      mm7, mm6           ; kernel multiplier 1
        pmaddwd   mm6, mm0
        pmaddwd   mm7, mm1
        paddd     mm6, mm4
        paddd     mm7, mm5

        //
        // Add the contribution to accumulator 2
        //

        movq      mm4, [edx + 24]    ; kernel multiplier 2
        movq      mm5, mm4           ; kernel multiplier 2
        pmaddwd   mm4, mm0
        pmaddwd   mm5, mm1
        paddd     mm4, [edx + 40]
        paddd     mm5, [edx + 48]

        //
        // Compute the new third accumulator
        //

        pmaddwd   mm0, [edx + 32]    ; multiply by kernel multiplier 3
        pmaddwd   mm1, [edx + 32]
        movq      [edx + 40], mm0
        movq      [edx + 48], mm1

        dec ecx
        jnz loop2
        emms
    }

#undef KERNEL_SHIFT_AMOUNT

#endif // defined(_X86_)
}

/**************************************************************************\
*
* Function Description:
*
*   DpOutputSpanStretch<FilterMode>::StretchScanline
*   Stretches a single scanline (magnification or minification) using
*   the reconstruction/interpolation mode specified by the template
*   parameter. Currently this is used for bilinear and bicubic filters.
*
* Arguments:
*
*    ARGB *dst,    // destination pointer
*    ARGB *src,    // source pointer
*    INT dw,       // destination width (pixels)
*    INT sw,       // source width (pixels)
*    FIX16 kci,    // initial position of the kernel center
*    FIX16 scale,  // scale factor
*    FIX16 w,      // width from center of the kernel to the edge
*    FIX16 a,      // 1/w
*
* Notes:
*   

The following description is based on the bilinear (tent) filter but it is
equally applicable to the bicubic - though the pictures and description would
be slightly more complicated.

The code below is significantly complicated by the fact that we want the inner
kernel loop to be quick and therefore not handle the wrap modes. In order to 
make this work, we first compute the number of pixels on the left and right
of the scanline that need to consider the wrap mode. We process the left first
and then run the optimized loop for all the inner pixels (which ignores the 
wrap conditions). After that we run the right edge.
          
Bilinear filter convolution kernel:
Note that each kernel has an intrinsic width - bilinear = 1 and bicubic = 2.
This width is scaled by the inverse of the stretch factor - i.e. a shrink
that results in 1/3 of the size being output requires a width (w) of 3 for the
bilinear and 6 for the bicubic. Also the height of the filter kernel is scaled
by the scale factor - i.e. the height of 1 (for all kernels) becomes 1/3 in 
the above example.

          
                            --- | ---                      ^
                        ---  .  |  .  ---                  |
                    ---      .  |  .     .---              h
                ---    .     .  |  .     .    ---          |
            ---  .     .     .  |  .     .     .  ---      |
        ---.     .     .     .  |  .     .     .     .---  v
-----0-----1-----2-----3-----4--|--5-----6-----7-----8-----9------------        
                                |
     kb                         kc                         ke
                                <------------w----------->

The filter kernel is shifted so that kc is exactly at the position of the
required destination pixel transformed into the source pixel array by the
scale factor. This will in general fall somewhere between two pixel samples - 
in the above picture, between pixels 4 and 5.

The goal is to get a color value for the position at kc and emit that into
the destination pixel stream. The standard evaluation method is to compute 
the height of the filter kernel at each of the pixel samples under the filter 
convolution corresponding to pixels 0, 1, ... 9. These heights are used to
weight each pixel sample and the result is summed giving the destination pixel
at kc. 

The problem with the standard evaluation is that at non-integer shrinks 
the mathematical evaluation of the kernel produces ripples in the output - i.e.
a solid field of pixels responds with a sine-wave-like ripple output. This is 
a theoretical problem with the discrete evaluation of the kernel integral.

Our evaluation actually stores a table of partial integrals from -inf to x. We
use this table to compute the area around each pixel and the area is used as
the weight. This evaluation is guaranteed to respond with exactly one for any
position and scale factor of the kernel. This property gives a stable field 
response allowing us to have non-ripple shrinks.

                            ---.: ---                       
                        ---.....:     ---                   
                    ---   :.....:         ---               
                ---       :.....:             ---           
            ---           :.....:                 ---       
        ---               :.....:                     ---   
-----0-----1-----2-----3-----4-----5-----6-----7-----8-----9------------        
                                                              
To evaluate this properly, we lookup the integral from -inf to 4.5 ( actually
we rescale so that the center of the kernel is at 0 ) and then subtract the 
table lookup for the integral from -inf to 3.5. This gives us an exact 
(within the error of the table) computation for the area from 3.5 to 4.5. 
This is what we use for the weight of pixel 4. Note that contrary to the 
standard evaluation pixel 9 does contribute even though 9 is outside of the
kernel. 8.5 is inside the kernel so the area under the kernel from 8.5 to 9.5 
is a small triangular area and is not equal to zero. Not accounting for this is 
the major source of error in the standard evaluation.

Note that the lookup for the end point integral for pixel 4 of -inf to 4.5 can 
be reused as the start point for the next pixel (5). An important property of 
this is that any error (e) in the lookup for -inf to 4.5 is added in pixel 
4's contribution and subtracted in pixel 5's contribution which results in 
the total error for the filter response -- due to table discretization -- being
completely subtracted away --- the end points have an error of exactly zero 
because we sample from beyond the left (area of exactly 0) to beyond the right 
(area of exactly 1). This is not precisely true because the error is scaled
by the pixel values, but it does help.

Note that this integral method is equivalent to convolving the input pixels
(comb) with the box filter of width 1 pixel and then convolving the result
with the filter kernel. [analysis due to Jim Blinn - see documentation in 
the Specs directory.]

Further documentation is available in the specs directory:
gdiplus\specs\filter\convolution.doc


*   Note:  this function must not use floating point values, because it could be
*   called with an invalid floating point state (prior to the call to emms)
*
* History:
*
*   04/16/2000 asecchia   created it
*
\**************************************************************************/


template<FilterModeType FilterMode>
void DpOutputSpanStretch<FilterMode>::StretchScanline(
    ARGB *dst,    // destination pointer
    ARGB *src,    // source pointer
    INT dw,       // destination width (pixels)
    INT sw,       // source width (pixels)
    FIX16 kci,    // initial position of the kernel center
    FIX16 scale,  // scale factor
    FIX16 w,      // width from center of the kernel to the edge
    FIX16 a       // 1/w
)
{
    // Note: this is a template class so the value of FilterMode
    // is defined at compile time. We're relying on the compiler
    // to perform dead code removal for each template instantiation
    // eliminating both the constant comparison and all the
    // code branches corresponding to other FilterMode values.
    // That way our inner loop is not impacted by extra code for
    // filter modes we're not using and extraneous conditional
    // statements.

    // Center of the filter kernel.
    // Shift over to the left by half because we want to center the area of
    // contribution for each sample on the sample - rather than taking the 
    // area between two point samples as the contribution for the sample on 
    // the right.

    FIX16 kc = kci - FIX16_HALF;

    // Left and right extent of the kernel, intra-kernel position,
    // and pixel contribution.

    INT kb, ke;
    INT kbt, ket;
    FIX16 kp, pc, pa, pa_old;

    // Loop variables

    INT x, k;

    // Incremental loop state, intermediate computation.

    ARGB *d = dst;
    FIX16 krn = 0;

    // Color channel accumulators.

    FIX16 ta, tr, tg, tb;

    // Compute the first pixel along the destination scanline that doesn't
    // have any wrap contribution and then the last pixel (l & r).
    // Note that all the terms have a FIX16_ONE factor which cancel out.

    // !!! Perf: [asecchia] This stuff is computed every scanline -
    //     and it's always the same. We could pass these coordinates to
    //     this routine and have them precomputed.

    INT lWrapX;
    INT rWrapX;

    if(scale>=0)
    {
        // x==sw is considered outside of the source.

        FIX16 fix_sw = (sw-1) << FIX16_SHIFT;

        // add (scale-1) and use idiv to get a Ceiling()

        lWrapX = (w-kc+(scale-1))/scale;

        // idiv should give us Floor().

        rWrapX = (fix_sw-w-kc)/scale;
    }
    else
    {
        // x==sw is considered outside of the source.

        FIX16 fix_sw = (sw-1) << FIX16_SHIFT;

        // note: in the -x scale transform, the sense of lWrapX and rWrapX
        // can be confusing. The l&r apply to the destination left and right
        // and are swapped here when we compute the initial position from
        // the inverted left and right source points.
        // As we traverse the destination from left to right we'll encounter
        // lWrapX first and then rWrapX, but the kc (kernel center) will be
        // moving through the source from right to left decrementing by
        // scale each time.

        // use idiv to get a Floor()

        rWrapX = (w-kc)/scale;

        // add scale+1 and use idiv for Ceiling().

        lWrapX = (fix_sw-w-kc+(scale+1))/scale;
    }

    // Now clamp to the range of the destination we're going to draw.

    lWrapX = max(0, lWrapX);
    rWrapX = min(dw, rWrapX);

    BYTE *kptr;
    INT  k_wrap;

    // Do the left wrapmode pixels.
/*          
                            --- | ---                      ^
                        ---     |     ---                  |
                    ---         |         ---              h
                ---             |             ---          |
            ---                 |                 ---      |
        ---                     |                     ---  v
-----0-----1-----2-----3-----4--|--5-----6-----7-----8-----9------------        
     kb                         kc <-----------w---------->ke
                   kbt                     ket
      <----wrap----><---------texture------><----wrap----->
       +ve transform                         -ve transform
      or straddle case                      or straddle case

The following loop handles the case where the wrap happens on the left of the
kernel. There are three subloops - first to handle the pixels in the wrap 
segment on the left, then to handle the pixels in the texture. Normally the
texture pixels will extend to the right edge of the kernel and we'll be done, 
but two cases make the right wrap essential at this point. First if the 
transform is negative, the sense is flipped and the texture extends from the 
left edge to the middle point and the wrap extends the rest of the kernel to 
the right edge. Also if the texture is sufficiently small and the shrink factor 
sufficiently large, the filter kernel could overlap both the left and right edge
of the texture and require wrapping on both sides.
*/

    for(x=0; x<min(lWrapX, dw); x++)
    {
        ASSERT(x<dw);
        // Compute the start and end of the filter kernel coverage

        kb = GpFix16Ceiling(kc-w);
        ke = GpFix16Ceiling(kc+w);

        // Bound the pixels in the texture.

        // kbt == kernel begin texture coordinate.
        // ket == kernel end texture coordinate.

        kbt = max(0,kb);
        ket = min(ke, sw-1);

        // Initialize the component accumulators. We accumulate the
        // contribution of each color component scaled by the kernel
        // response into these variables.

        ta = tr = tg = tb = 0;

        // These pixels are off the left of the texture.
        pa_old = 0;

        // Iterate over each pixel under the filter kernel.
        // if ke==kb then there is one point.
        krn = Int32x32Mod16(a, (kb << FIX16_SHIFT) - kc);

        if(QWrapMode == WrapModeClamp)
        {
            // Clamp modes.

            for(k=kb; k<min(kbt, ke+1); k++)
            {
                // these pixels are always off the left of the texture.

                ASSERT(k<0);

                ComputeKernel(pc, a, pa, pa_old, krn);

                ta += pc * ClampColorA;
                tr += pc * ClampColorR;
                tg += pc * ClampColorG;
                tb += pc * ClampColorB;
            }
        }
        else
        {
            // Do the full wrap computation.

            for(k=kb; k<min(kbt, ke+1); k++)
            {
                // these pixels are always off the left of the texture.

                k_wrap = k;

                ASSERT(k<0);

                // !!! Perf: [asecchia] This is really slow.
                //     If we ever decide to make wrap modes propagate
                //     through the outcrop region and decide that wrap
                //     tile and flip x,y are important perf scenarios,
                //     we should come back and replace this divide with
                //     repeated subtraction - most times it can be avoided.
                //     However, right now this is only used for a few
                //     pixels on the edges and we don't really mind the
                //     perf hit for these modes.

                Apply1DWrapModeX(QWrapMode, k_wrap, sw);
                ComputeKernel(pc, a, pa, pa_old, krn);
                kptr = (BYTE*)(src + k_wrap);
                AccumulateChannels(pc, kptr);
            }

        }

        // Initialize the color channel accessor pointer to the beginning
        // of the source pixel array for this kernel.

        kptr = (BYTE*)(src + kbt);

        // HighQualityBicubic needs to initialize the krn value.
        // It is used to do the kernel table lookup.
        // HighQualityBilinear doesn't use this as it works out it's
        // kernel by direct computation.

        krn = Int32x32Mod16(a, (kbt << FIX16_SHIFT) - kc);

        // These pixels hit the texture.

        for(k=kbt; k<=ket; k++)
        {
            ComputeKernel(pc, a, pa, pa_old, krn);

            // Accumulate the contribution of this source pixel to the pixel
            // we're working on.
            AccumulateChannels(pc, kptr);
            kptr += 4;
        }

        // These pixels are off the right of the texture.
        // This can happen if the kernel spans the entire source texture.

        // Iterate over each pixel under the filter kernel.
        // if ke==kb then there is one point.

        krn = Int32x32Mod16(a, (max(ket+1, kb) << FIX16_SHIFT) - kc);

        if(QWrapMode == WrapModeClamp)
        {
            // Clamp modes.

            for(k=max(ket+1, kb); k<=ke; k++)
            {
                ComputeKernel(pc, a, pa, pa_old, krn);

                ta += pc * ClampColorA;
                tr += pc * ClampColorR;
                tg += pc * ClampColorG;
                tb += pc * ClampColorB;
            }
        }
        else
        {
            // Do the full wrap computation.

            for(k=max(ket+1, kb); k<=ke; k++)
            {
                k_wrap = k;
                Apply1DWrapModeX(QWrapMode, k_wrap, sw);
                ComputeKernel(pc, a, pa, pa_old, krn);
                kptr = (BYTE*)(src + k_wrap);
                AccumulateChannels(pc, kptr);
            }

        }
        // Done with this pixel - store it in the destination buffer.

        // clamp the results to byte range.

        ClampColors();

        // Combine the channels, set the destination pixel and increment
        // to the next pixel

        *d++ = (ta << 24) | (tr << 16) | (tg << 8) | tb;
        kc += scale;
    }

    // For all points, x, in the destination compute the position of the
    // kernel center in the source and sum the contribution under the filter.

    const INT minCenterWidthMMX = 16;
    INT dstCenterWidth = rWrapX - lWrapX;
    INT srcFirst = GpFix16Ceiling(kc - w);
    INT srcLast  = GpFix16Floor(kc+w + (dstCenterWidth - 1) * scale);

    // srcLast_2Stretch is the last pixel touched by the MMX routine.
    // The number of pixels touched by the routine is equal to six
    // (setup pixels) plus two times the width of the center strip
    // in the destination.  We subtract one in order the get the actual
    // last pixel touched by StretchMiddleScanline2_MMX (so that we can
    // compare it with srcLast).

    INT srcLast_2Stretch = srcFirst + (dstCenterWidth + 3) * 2 - 1;

#if defined(_X86_)
    if ((OSInfo::HasMMX) &&
        (FilterMode == HighQualityBicubic))
    {
        // MMX and high quality bicubic

        if ((dstCenterWidth >= minCenterWidthMMX) &&
            ((srcLast_2Stretch == srcLast) || (srcLast_2Stretch == (srcLast - 1))))
        {
            ASSERT(srcFirst >= 0);
            ASSERT(srcLast_2Stretch < sw);

            // Stretch the middle pixels by a factor of two using optimized MMX
            // code.

            FIX16 kc_center = kc + FIX16_HALF;
            StretchMiddleScanline2_MMX(d,
                                       src + srcFirst,
                                       dstCenterWidth,
                                       kc_center - (GpFix16Floor(kc_center) * FIX16_ONE));
            d += dstCenterWidth;
            kc += scale * dstCenterWidth;
            x += dstCenterWidth;
        }
        else
        {
            // This is the MMX version of the general purpose bicubic scaling
            // code.

            for(x=lWrapX; x<rWrapX; x++)
            {
                // Cannot go over dw because rWrap is < dw

                ASSERT(x<dw);

                // Compute the start and end of the filter kernel coverage

                kb = GpFix16Ceiling(kc-w);
                ke = GpFix16Ceiling(kc+w);

                // Default loop assumes most pixels don't have to worry about
                // wrap mode along the ends of the scanline.

                ASSERT(kb>=0);
                ASSERT(ke<sw);

                // Initialize the color channel accessor pointer to the beginning
                // of the source pixel array for this kernel.

                kptr = (BYTE*)(src + kb);

                // HighQualityBicubic needs to initialize the krn value.
                // It is used to do the kernel table lookup.
                // HighQualityBilinear doesn't use this as it works out it's
                // kernel by direct computation.

                krn = Int32x32Mod16(a, (kb << FIX16_SHIFT) - kc);

                // Iterate over each pixel under the filter kernel.
                // if ke==kb then there is one point.

                INT bcl_count = ke - kb + 1;
                INT bcl_half_count = bcl_count >> 1;
                bcl_count &= 0x1;

                _asm
                {
                    // eax - krn
                    // ebx - kptr
                    // esi - LPIC
                    // edi - a
                    //
                    // mm5 - pold
                    // mm6 - green ; blue
                    // mm7 - alpha ; red

                    mov          eax, krn
                    mov          ebx, kptr
                    mov          esi, CPIC
                    mov          edi, a
                    pxor         mm5, mm5
                    movq         mm6, FIX14_HALF_MMX
                    movq         mm7, mm6
                    pxor         mm0, mm0

                    dec          bcl_half_count
                    jl           bicubic_center_loop_last_pixel

                bicubic_center_loop:

                    // Read the next two pixels into mm2 and mm1

                    movd         mm2, [ebx]      // mm2 = pixel1
                    movd         mm1, [ebx + 4]  // mm1 = pixel2
                    add          ebx, 8

                    // Compute the kernel values for these two pixels

                    mov          edx, eax
                    sar          edx, 8
                      punpcklbw    mm2, mm0
                    movd         mm3, [esi + 4 * edx] // mm3 = p1

                    lea          edx, [eax + edi]
                    sar          edx, 8
                      punpcklbw    mm1, mm0
                    movd         mm4, [esi + 4 * edx] // mm4 = p2

                    punpckldq    mm5, mm3             // mm5 = p1 | pold
                    lea          eax, [eax + 2 * edi]
                    punpckldq    mm3, mm4             // mm3 = p2 | p1

                    psrad        mm5, 2
                    psrad        mm3, 2

                    psubd        mm3, mm5             // mm3 = kernel2 | kernel1
                    movq         mm5, mm4             // mm5 = pold
                    packssdw     mm3, mm3             // mm3 = kernel2 | kernel1 | kernel2 | kernel1

                    // At this point:
                    // mm3 = kernel2 | kernel1 | kernel2 | kernel1
                    // mm2, mm1 contain pixel1 and pixel2 respectively

                    movq         mm4, mm2
                    punpcklwd    mm2, mm1
                    pmaddwd      mm2, mm3    
                    punpckhwd    mm4, mm1
                    paddd        mm6, mm2
                    dec          bcl_half_count
                    pmaddwd      mm4, mm3
                    paddd        mm7, mm4

                    jge          bicubic_center_loop

                bicubic_center_loop_last_pixel:

                    dec          bcl_count
                    jl           bicubic_center_loop_done

                    // Read the last pixel into mm2

                    movd         mm2, [ebx]
                    punpcklbw    mm2, mm0 // mm2 = a | r | g | b
                    movq         mm3, mm2
                    punpcklwd    mm2, mm0 // mm2 = 0 | g | 0 | b
                    punpckhwd    mm3, mm0 // mm3 = 0 | a | 0 | r

                    // Compute the kernel value for this pixel

                    sar          eax, 8
                    psrad        mm5, 2
                    movd         mm4, [esi + 4 * eax] // mm4 = p
                    psrad        mm4, 2
                    psubd        mm4, mm5
                    packssdw     mm4, mm4

                    pmaddwd      mm2, mm4
                    pmaddwd      mm3, mm4

                    paddd        mm6, mm2
                    paddd        mm7, mm3

                bicubic_center_loop_done:

                    // At this point, mm6 and mm7 contain the output channels
                    // for the pixel.  We need to clamp the alpha and store it
                    // in the destination buffer.

                    psrad        mm6, 14
                    psrad        mm7, 14
                    packssdw     mm6, mm7 // mm6 = a | r | g | b
                    packuswb     mm6, mm6 // mm6 = 00000000aarrggbb

                    movq         mm7, mm6 // mm7 = 00000000aarrggbb
                    psrad        mm6, 24  // mm6 = xxxxxxxxxxxxxxaa
                      mov          eax, 0xFFFFFFFF
                    punpcklbw    mm6, mm6 // mm6 = xxxxxxxxxxxxaaaa
                      movd         mm2, eax
                    punpcklbw    mm6, mm6 // mm6 = xxxxxxxxaaaaaaaa

                    psubusb      mm2, mm6
                      mov          eax, d
                    paddusb      mm7, mm2
                    psubusb      mm7, mm2

                    movd         [eax], mm7
                    add          eax, 4
                    mov          d, eax
                }
            
                kc += scale;
            }
        }
    }
    else
#endif // defined(_X86_)    
/*          
                            --- | ---                      ^
                        ---     |     ---                  |
                    ---         |         ---              h
                ---             |             ---          |
            ---                 |                 ---      |
        ---                     |                     ---  v
-----0-----1-----2-----3-----4--|--5-----6-----7-----8-----9------------        
     kb                         kc <-----------w---------->ke
                                
      <-----------------------texture--------------------->

The following loop is guaranteed to only hit texture for every pixel under
the kernel. This is the majority of the pixels in most normal stretch 
cases. We can simplify this loop because of this assumption and therefore
get a performance win.
Many of the degenerate wrap cases will simply skip this loop.
*/
    {
        // no MMX

        for(x=lWrapX; x<rWrapX; x++)
        {
            // Cannot go over dw because rWrap is < dw

            ASSERT(x<dw);

            // Compute the start and end of the filter kernel coverage

            kb = GpFix16Ceiling(kc-w);
            ke = GpFix16Ceiling(kc+w);

            // Default loop assumes most pixels don't have to worry about
            // wrap mode along the ends of the scanline.

            ASSERT(kb>=0);
            ASSERT(ke<sw);

            // Initialize the component accumulators. We accumulate the
            // contribution of each color component scaled by the kernel
            // response into these variables.

            ta = tr = tg = tb = 0;

            // Initialize the color channel accessor pointer to the beginning
            // of the source pixel array for this kernel.

            kptr = (BYTE*)(src + kb);

            // HighQualityBicubic needs to initialize the krn value.
            // It is used to do the kernel table lookup.
            // HighQualityBilinear doesn't use this as it works out it's
            // kernel by direct computation.

            krn = Int32x32Mod16(a, (kb << FIX16_SHIFT) - kc);
            pa_old = 0;

            // Iterate over each pixel under the filter kernel.
            // if ke==kb then there is one point.

            for(k=kb; k<=ke; k++)
            {
                ComputeKernel(pc, a, pa, pa_old, krn);

                // Accumulate the contribution of this source pixel to the pixel
                // we're working on.
                
                AccumulateChannels(pc, kptr);

                kptr += 4;
            }

            // Done with this pixel - store it in the destination buffer.

            // clamp the results to byte range.

            ClampColors();
        
            ASSERT(tr<=ta);
            ASSERT(tg<=ta);
            ASSERT(tb<=ta);
            ASSERT(ta>=0);
            ASSERT(tr>=0);
            ASSERT(tg>=0);
            ASSERT(tb>=0);

            // Combine the channels, set the destination pixel and increment
            // to the next pixel

            *d++ = (ta << 24) | (tr << 16) | (tg << 8) | tb;
            
            kc += scale;
        }
    }

    // Need to use max() here to handle the case where lWrapX > rWrapX
    // which can happen if the filter spans both edges of the scanline.

    // Do the right wrapmode pixels.

/*          
                            --- | ---                      ^
                        ---     |     ---                  |
                    ---         |         ---              h
                ---             |             ---          |
            ---                 |                 ---      |
        ---                     |                     ---  v
-----0-----1-----2-----3-----4--|--5-----6-----7-----8-----9------------        
     kb                         kc <-----------w---------->ke
                   kbt                     ket
      <----wrap----><---------texture------><----wrap----->
      -ve transform                           +ve tranform
        case only                               case only
      
The following loop handles the case where the wrap happens on the right of the
kernel. There are three subloops - first to handle the pixels in the wrap 
segment on the left - if any, then to handle the pixels in the texture. After 
that handle the pixels in the right wrap. Normally the texture pixels will 
extend to the left edge of the kernel and the first subloop will simply be 
skipped, but the left wrap is essential if the transform is negative --- the 
sense is flipped and the texture extends from the right edge to the middle 
point and the wrap extends the rest of the kernel to the left edge. 
Note it's not possible at this point to have wrapping at both edges of the 
kernel the wrap is on the left iff the transform is negative. The wrap is on 
the right iff the transform is positive. The case where both wrapmodes is 
present has already been taken care of in the first loop.
*/

    for(x=max(x, rWrapX); x<dw; x++)
    {
        // Compute the start and end of the filter kernel coverage

        kb = GpFix16Ceiling(kc-w);
        ke = GpFix16Ceiling(kc+w);

        // Bound the pixels in the texture.

        // ket == kernel end texture coordinate (inclusive).
        // kbt == kernel begin texture coordinate.

        kbt = max(0,kb);
        ket = min(ke, sw-1);

        // Initialize the component accumulators. We accumulate the
        // contribution of each color component scaled by the kernel
        // response into these variables.

        ta = tr = tg = tb = 0;

        // Initialize the color channel accessor pointer to the beginning
        // of the source pixel array for this kernel.

        kptr = (BYTE*)(src + kb);

        // HighQualityBicubic needs to initialize the krn value.
        // It is used to do the kernel table lookup.
        // HighQualityBilinear doesn't use this as it works out it's
        // kernel by direct computation.

        pa_old = 0;

        if(kb<kbt)
        {  
            krn = Int32x32Mod16(a, (kb << FIX16_SHIFT) - kc);
        }

        // Iterate over each pixel under the filter kernel.
        // if ke==kb then there is one point.

        // These pixels are off the left of the texture.
        // This is possible for negative transform cases.

        if(QWrapMode == WrapModeClamp)
        {
            // Clamp modes.

            for(k=kb; k<min(kbt, ke+1); k++)
            {
                // these pixels are always off the left of the texture.

                ASSERT(k<0);

                ComputeKernel(pc, a, pa, pa_old, krn);

                ta += pc * ClampColorA;
                tr += pc * ClampColorR;
                tg += pc * ClampColorG;
                tb += pc * ClampColorB;
            }
        }
        else
        {
            // Do the full wrap computation.

            for(k=kb; k<min(kbt, ke+1); k++)
            {
                // these pixels are always off the left of the texture.

                k_wrap = k;

                ASSERT(k<0);

                // !!! Perf: [asecchia] This is really slow.
                //     If we ever decide to make wrap modes propagate
                //     through the outcrop region and decide that wrap
                //     tile and flip x,y are important perf scenarios,
                //     we should come back and replace this divide with
                //     repeated subtraction - most times it can be avoided.
                //     However, right now this is only used for a few
                //     pixels on the edges and we don't really mind the
                //     perf hit for these modes.

                Apply1DWrapModeX(QWrapMode, k_wrap, sw);
                ComputeKernel(pc, a, pa, pa_old, krn);
                kptr = (BYTE*)(src + k_wrap);
                AccumulateChannels(pc, kptr);
            }

        }

        // Initialize the color channel accessor pointer to the beginning
        // of the source pixel array for this kernel.

        kptr = (BYTE*)(src + kbt);

        // HighQualityBicubic needs to initialize the krn value.
        // It is used to do the kernel table lookup.
        // HighQualityBilinear doesn't use this as it works out it's
        // kernel by direct computation.

        krn = Int32x32Mod16(a, (kbt << FIX16_SHIFT) - kc);

        // These pixels hit the texture.

        for(k=kbt; k<=ket; k++)
        {
            ComputeKernel(pc, a, pa, pa_old, krn);

            // Accumulate the contribution of this source pixel to the pixel
            // we're working on.
            
            AccumulateChannels(pc, kptr);
            kptr += 4;
        }

        // These pixels are off the right of the texture.
        
        // Iterate over each pixel under the filter kernel.
        // if ke==kb then there is one point.
        krn = Int32x32Mod16(a, ((max(ket+1, kb)) << FIX16_SHIFT) - kc);

        if(QWrapMode == WrapModeClamp)
        {
            // Clamp modes.

            for(k=max(ket+1, kb); k<=ke; k++)
            {
                ComputeKernel(pc, a, pa, pa_old, krn);

                ta += pc * ClampColorA;
                tr += pc * ClampColorR;
                tg += pc * ClampColorG;
                tb += pc * ClampColorB;
            }
        }
        else
        {
            // Do the full wrap computation.

            for(k=max(ket+1, kb); k<=ke; k++)
            {
                // Apply the general pixel wrap

                k_wrap = k;
                Apply1DWrapModeX(QWrapMode, k_wrap, sw);
                ComputeKernel(pc, a, pa, pa_old, krn);
                kptr = (BYTE*)(src + k_wrap);
                AccumulateChannels(pc, kptr);
            }
        }

        // Done with this pixel - store it in the destination buffer.

        // clamp the results to byte range.

        ClampColors();

        // Combine the channels, set the destination pixel and increment
        // to the next pixel

        *d++ = (ta << 24) | (tr << 16) | (tg << 8) | tb;
        kc += scale;
    }
#ifdef _X86_
    if ((OSInfo::HasMMX) &&
        (FilterMode == HighQualityBicubic))
    {
        _asm
        {
            emms
        }
    }
#endif // _X86_
}



/**************************************************************************
*
* Function Description:
*
*   Outputs one scanline on the destination device
*
*   Note:  this function must not use floating point values because of
*   potential conflicts with the MMX register values.
*
* Return Value:
*
*   GpStatus. Always returns Ok.
*   !!! [asecchia] are we going to remove this return value - these
*   always return success.
*
* Created:
*
*   04/17/2000 asecchia
*      Created it.
*
**************************************************************************/

template<FilterModeType FilterMode>
GpStatus DpOutputSpanStretch<FilterMode>::OutputSpan(
  INT y,
  INT xMin,
  INT xMax     // xMax is exclusive
)
{
    ASSERT(isValid);
    
    // This function assumes that it's called with a correctly ordered span.

    ASSERT((xMax-xMin)>=0);

    INT width = xMax-xMin;

    // We can't have someone draw outside our specified destination.
    // If this assert fires, we don't have enough buffer space to store the
    // destination xscale so we'd overrun the buffer. The caller set us up
    // with an incorrect destination rectangle or got their rounding wrong.

    ASSERT(width <= xbuffer_width);

    INT left = xMin;
    INT right = xMax;
    // If there's nothing to do, simply return.

    if(right < left)
    {
        return Ok;
    }

    ASSERT(right >= left);

    // Make sure the caller clipped correctly - we can't handle
    // being called to draw outside out destination rectangle.

    ASSERT(y >= iytop);

    // Compute the kernel center for this y coordinate relative to the first
    // y coordinate (y coordinate corresponding to DstRect.Y) and offset
    // by the source rectangle.

    FIX16 kc;

    if(yscale < 0)
    {
        kc = ykci - (y - iytop) * (-yscale);
    }
    else
    {
        kc = ykci + (y - iytop) * yscale;
    }
    
    // Center of the filter kernel.
    // Shift over to the left by half because we want to center the area of
    // contribution for each sample on the sample - rather than taking the 
    // area between two point samples as the contribution for the sample on 
    // the right.
    
    kc -= FIX16_HALF;

    // Compute the start and end of the filter kernel coverage

    FIX16 kb = GpFix16Ceiling(kc-yw);
    FIX16 ke = GpFix16Ceiling(kc+yw);

    // Get the source pointer.

    ARGB *srcPtr0 = static_cast<ARGB*> (BmpData.Scan0);
    INT stride = BmpData.Stride/sizeof(ARGB);

    ARGB *src;
    ARGB *dst;

    FIX16 pc, kp, pa, pa_old;
    FIX16 ta, tr, tg, tb;

    ARGB pix;

    INT k, x, kmod;

    FIX16 krn = 0;

    // if there was a last_k before this iteration

    // compute the new xbuffer_start_scanline

    if(last_k != LAST_K_UNUSED)
    {
        // If there is no overlap in the rotational buffer from the
        // last time, initialize the rotational buffer to the start.

        if(yscale < 0)
        {
            // Negative y scale.

            if(ke-last_k < 0)
            {
                xbuffer_start_scanline = 0;
            }
            else
            {
                xbuffer_start_scanline -= last_k-kb;
                if(xbuffer_start_scanline < 0)
                {
                    xbuffer_start_scanline += xbuffer_height;
                }

            }
        }
        else
        {
            // Positive y scale.

            if(last_k-kb < 0)
            {
                xbuffer_start_scanline = 0;
            }
            else
            {
                // Figure out where to start in the xbuffer so that we
                // can reuse the already scaled scanlines.

                xbuffer_start_scanline -= (last_k-kb)+1;
                if(xbuffer_start_scanline < 0)
                {
                    xbuffer_start_scanline += xbuffer_height;
                }
            }
        }
    }
    else
    {
        // this should be the first time we're hitting this
        // routine. xbuffer_start_scanline should be properly
        // initialized.

        ASSERT(xbuffer_start_scanline == 0);
    }

    // make sure we're going to access valid memory in the xbuffer.

    ASSERT(xbuffer_start_scanline >= 0);
    ASSERT(xbuffer_start_scanline < xbuffer_height);

    // !!! [asecchia] if we thought about it some, we could probably
    // import the code in StretchScanline into this loop
    // and merge this and the next loop significantly reducing the memory
    // requirements for the xbuffer.

    // The xbuffer_height should be == (ke-kb)+1 for all cases except when
    // the center (kc) is exactly on an integer in which case the first and
    // last entries under the kernel have a contribution of zero so it doesn't
    // matter if we drop one scanline in that case.
    // Start at the position we left off from the previous scanline. Use the
    // rotational buffer to remember the data from the previous scanline work.

    // HighQualityBicubic needs to initialize the krn value.
    // It is used to do the kernel table lookup.
    // HighQualityBilinear doesn't use this as it works out it's
    // kernel by direct computation.

    // Note: this is a template class so the value of FilterMode
    // is defined at compile time. We're relying on the compiler
    // to perform dead code removal for each template instantiation
    // eliminating both the constant comparison and all the
    // code branches corresponding to other FilterMode values.
    // That way our inner loop is not impacted by extra code for
    // filter modes we're not using and extraneous conditional
    // statements.

    krn = Int32x32Mod16(ya, (kb << FIX16_SHIFT) - kc);
    pa_old = 0;

    for(k=0; k<xbuffer_height; k++)
    {
        kmod = xbuffer_start_scanline + k;
        if(kmod >= xbuffer_height) kmod -= xbuffer_height;

        // We avoid using a mod (%) computation above because we
        // know that the xbuffer_start_scanline is always within
        // the range 0..xbuffer_height-1.
        // ASSERT that this assumption is true.

        ASSERT(kmod < xbuffer_height);
        ASSERT(kmod >= 0);

        // Compute the kernel response for this pixel based on the
        // positive value of kp


        if(kb+k>ke)
        {
            // The buffer could be larger than the actual kernel,
            // in that case, simply set the extra coefficients to 
            // zero.
            
            ycoeff[kmod] = 0;
        }
        else
        {
            ComputeKernel(ycoeff[kmod], ya, pa, pa_old, krn);
        }

        // Compute the position in the destination buffer to draw to.

        dst = xbuffer + xbuffer_width * kmod;

        // This assert fires if the arithmetic for computing the size of the
        // xbuffer or the iteration over the kernel support has a bug. The
        // xbuffer_height should be the maximum width of the kernel support.

        ASSERT(k < xbuffer_height);
        ASSERT(kmod < xbuffer_height);

        INT k_wrap = kb+k;

        // NTRAID#NTBUG9-370168-2001/04/18-asecchia
        // This is an unsigned/signed comparison.
        // NOTE: the (INT) cast is the invalid one. BmpData.Height is UINT
        // and is always positive - casting it to int is irrelevant.
        // However, the k_wrap is signed and _can_ be negative. The unsigned
        // cast is by design - it allows us to figure out both sides of the 
        // wrap using one comparison.
        // The unsigned comparison >= Height tells us if k_wrap does not fall 
        // within the range 0..Height-1 and therefore needs wrapping because 
        // negative numbers cast to huge positive numbers and succeed the 
        // comparison too.
        // NOTE also that this kind of comparison limits the effective range
        // of Height to (max unsigned)/2 with the single caveat of k_wrap being
        // equal to -MAXINT.
        // For code that's executed once per scanline, this kind of subtlety
        // is probably not warranted.

        if((UINT)(k_wrap) >= (INT)BmpData.Height)
        {
            // Handle the wrap mode here.

            if(WrapZeroClamp)
            {
                // GpMemset(dst, 0, (right-left)*sizeof(ARGB));

                // If we're filling with zero, we may as well optimize the kernel
                // contribution.

                ycoeff[kmod] = 0;

                // done this scan - go on to the next

                continue;
            }
            else
            {
                if(QWrapMode == WrapModeClamp)
                {
                    INT i = right-left;
                    ARGB *d = dst;
                    while(i--)
                    {
                        *d++ = ClampColor;
                    }

                    // done this scan - go on to the next

                    continue;
                }
                else
                {
                    // Apply the general wrap code.

                    Apply1DWrapModeY(QWrapMode, k_wrap, (INT)BmpData.Height);
                    src = srcPtr0 + stride*k_wrap;

                    // Not done yet - fall through and call StretchScanline.
                }
            }
        }
        else
        {
            // If the x2 and x1 are out of order, we failed to correctly
            // compute the span in the above logic.

            // Seek to the start of the scanline.
            // Note: whatever X coordinate we add to the src pointer
            // we need to subtract from the width passed to the
            // StretchScanline routine below.

            src = srcPtr0 + stride*(k_wrap);
        }

        // Only x-scale if we haven't already done this scanline on a previous
        // call and stored the result in the xbuffer.

        if((last_k==LAST_K_UNUSED) || (
               (yscale >= 0) && (last_k-(kb+k) < 0) ||
               (yscale < 0) && (last_k-(kb+k) > 0)
            )
           )
        {

            // Filter in the x-dimension.

            StretchScanline(
                dst,
                src,
                xbuffer_width,
                static_cast<INT>(BmpData.Width),
                xkci,
                xscale,
                xw,
                xa
            );
        }
    }

    // set up the k_last for the next iteration. This represents the last
    // scanline for which we actually have x-scaled data.

    if(yscale < 0)
    {
        last_k = kb;
    }
    else
    {
        last_k = kb + xbuffer_height - 1;
    }

    
    // Get the final destination buffer

    ARGB *buffer = Scan->NextBuffer(left, y, width);

    // Now we have the entire buffer full with the x-dimension scaled data.

    // for every x coordinate, apply the y kernel.
    
#ifdef _X86_
    if (OSInfo::HasMMX)
    {
        // MMX
    
        INT *ycoeffMMX = (INT *) ((((UINT_PTR) ycoeff) + 4) & ~0x7);
        INT n = (xbuffer_height + 1) >> 1;

        // Transform the kernel coeffecient array into a form that is
        // easily usable by MMX code.  The loop must go backward so that
        // we don't erase kernel coefficients (MMX starting point could
        // be 4 bytes ahead of integer starting point).
        // ycoeff must be large enough to hold the MMX coefficients (2 extra
        // entries)

        for (INT i = n-1; i >= 0; i--)
        {
            INT kernel1   = ycoeff[i * 2]     >> 2;
            INT kernel2   = ycoeff[i * 2 + 1] >> 2;
            INT kernelMMX = (kernel1 & 0xFFFF) | (kernel2 << 16); 

            ycoeffMMX[i * 2]     = kernelMMX;
            ycoeffMMX[i * 2 + 1] = kernelMMX;
        }

        for(x=0; x<width; x++)
        {
            // iterate over every point under the kernel

            // Note we don't need the kmod arithmetic here because
            // we've precomputed the coefficients and we don't care what order
            // we sum them.

            BYTE *kptr = (BYTE*)(xbuffer + x + (left - ixleft));

            // Compute the increment in bytes to move from the current scanline
            // to the next in the xbuffer.

            INT kptr_inc_MMX = xbuffer_width*sizeof(ARGB);

            INT bos_count      = xbuffer_height;
            INT bos_half_count = bos_count >> 1;
            bos_count &= 0x1;

            _asm
            {
                    // eax - kptr
                    // ebx - kptr_inc
                    // ecx - counter
                    // esi - ycoeff current pointer

                    pxor       mm0, mm0
                    movq       mm6, FIX14_HALF_MMX
                    movq       mm7, mm6
                    mov        eax, kptr
                    mov        ebx, kptr_inc_MMX
                    mov        ecx, bos_half_count
                    mov        esi, ycoeffMMX

                    dec        ecx
                    jl         bicubic_output_span_loop_last_pixel

                bicubic_output_span_loop:

                    movd       mm2, [eax]  // mm2 = 00000000a1r1b1g1
                    movd       mm4, [eax + ebx]

                    punpcklbw  mm2, mm0    // mm2 = 00a100r100g100b1
                    movq       mm1, [esi]  // mm1 = kernel2 | kernel1 | kernel2 | kernel1

                    punpcklbw  mm4, mm0    // mm4 = 00a200r200g200b2
                    movq       mm3, mm2    // mm3 = 00a100r100g100b1

                    punpcklwd  mm2, mm4    // mm2 = 00g200g100b200b1
                    add        esi, 8
                    pmaddwd    mm2, mm1
                    punpckhwd  mm3, mm4    // mm3 = 00a200a100r200r1
                    paddd      mm6, mm2
                    dec        ecx
                    pmaddwd    mm3, mm1
                    lea        eax, [eax + 2 * ebx] // does not affect flags      
                    paddd      mm7, mm3

                    jge        bicubic_output_span_loop

                bicubic_output_span_loop_last_pixel:

                    dec        bos_count
                    jl         bicubic_output_span_loop_done

                    movd       mm2, [eax]  // mm2 = 00000000aarrggbb
                    punpcklbw  mm2, mm0    // mm2 = 00aa00rr00gg00bb
                    movq       mm3, mm2
                    punpcklwd  mm2, mm0    // mm2 = 000000gg000000bb
                    movq       mm1, [esi]  // mm1 = xxxx | kernel1 | xxxx |kernel1
                    punpckhwd  mm3, mm0    // mm3 = 000000aa000000bb

                    pmaddwd    mm2, mm1
                    pmaddwd    mm3, mm1

                    paddd      mm6, mm2
                    paddd      mm7, mm3

                bicubic_output_span_loop_done:

                    // At this point, mm6 and mm7 contain the output channels
                    // for the pixel.  We need to clamp the alpha and store it
                    // in the destination buffer.

                    psrad        mm6, 14
                    psrad        mm7, 14
                    packssdw     mm6, mm7 // mm6 = a | r | g | b
                    packuswb     mm6, mm6 // mm6 = 00000000aarrggbb

                    movq         mm7, mm6 // mm7 = 00000000aarrggbb
                    psrad        mm6, 24  // mm6 = xxxxxxxxxxxxxxaa
                      mov          eax, 0xFFFFFFFF
                    punpcklbw    mm6, mm6 // mm6 = xxxxxxxxxxxxaaaa
                      movd         mm2, eax
                    punpcklbw    mm6, mm6 // mm6 = xxxxxxxxaaaaaaaa

                    psubusb      mm2, mm6
                      mov          eax, buffer
                    paddusb      mm7, mm2
                    psubusb      mm7, mm2

                    movd         [eax], mm7
                    add          eax, 4
                    mov          buffer, eax
            }
        }
    }
    else
#endif // _X86_
    {
        // No MMX

        for(x=0; x<width; x++)
        {
            // Initialize the component accumulators. We accumulate the
            // contribution of each color component scaled by the kernel
            // response into these variables.

            ta = tr = tg = tb = 0;

            // iterate over every point under the kernel

            // Note we don't need the kmod arithmetic here because
            // we've precomputed the coefficients and we don't care what order
            // we sum them.

            BYTE *kptr = (BYTE*)(xbuffer + x + (left - ixleft));

            // Compute the increment in bytes to move from the current scanline
            // to the next in the xbuffer after incrementing through 3 of the
            // color channels.

            INT kptr_inc = xbuffer_width*sizeof(ARGB);
            
            for(k=0; k<xbuffer_height; k++)
            {
                // Find the pixel contributing to this part of the kernel
                // taking into account the edge conditions.

                // lookup the kernel coefficient for this scanline.

                pc = ycoeff[k];

                // Accumulate the contribution of this source pixel to the pixel
                // we're working on.

                AccumulateChannels(pc, kptr);

                kptr += kptr_inc;
            }

            // Done with this pixel - store it in the destination buffer.

            // clamp the results to byte range.

            ClampColors();

            // Combine the channels, set the destination pixel and increment
            // to the next pixel

            *buffer++ = (ta << 24) | (tr << 16) | (tg << 8) | tb;
        }
    }

#ifdef _X86_
    if (OSInfo::HasMMX)
    {
        _asm
        {
            emms
        }
    }
#endif // _X86_


    return Ok;
}

#undef ClampColors
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\srgb.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   sRGB <-> sRGB64 color conversion
*
* Abstract:
*
*   Converts colors between the sRGB and sRGB64 color spaces.
*
* Notes:
*
*   !!![agodfrey]
*   For sRGB64->sRGB, we just clamp out-of-range components to [0,255].
*   We may need to provide the option of doing something more sophisticated.
*
* Revision History:
*
*   06/09/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

namespace sRGB
{
    BYTE UnlinLookup(INT16 input);
}

// UnlinearizeLUT, UnlinearizeLUT2: Lookup tables used to convert from
// sRGB64 to sRGB.
//
// The first table maps the high byte of the input to the smallest possible
// corresponding output.
//
// The second table describes, for each output, the maximum input which
// produces that output. The algorithm uses the first table to find an
// approximate answer, then scans the second table to find the exact result.

static BYTE UnlinearizeLUT[32] = 
{
    0x0, 0x31, 0x47, 0x56, 0x63, 0x6e, 0x78, 0x81,
    0x89, 0x91, 0x98, 0x9e, 0xa5, 0xab, 0xb1, 0xb6,
    0xbc, 0xc1, 0xc6, 0xca, 0xcf, 0xd4, 0xd8, 0xdc,
    0xe1, 0xe5, 0xe9, 0xed, 0xf0, 0xf4, 0xf8, 0xfb,
};

static INT16 UnlinearizeLUT2[256] = 
{
    0x1, 0x3, 0x6, 0x8, 0xb, 0xd, 0x10, 0x12,
    0x15, 0x17, 0x1a, 0x1c, 0x1f, 0x22, 0x25, 0x28,
    0x2c, 0x2f, 0x33, 0x37, 0x3b, 0x3f, 0x43, 0x48,
    0x4d, 0x52, 0x57, 0x5c, 0x61, 0x67, 0x6d, 0x73,
    0x79, 0x7f, 0x86, 0x8d, 0x94, 0x9b, 0xa2, 0xa9,
    0xb1, 0xb9, 0xc1, 0xca, 0xd2, 0xdb, 0xe4, 0xed,
    0xf6, 0x100, 0x10a, 0x114, 0x11e, 0x128, 0x133, 0x13e,
    0x149, 0x154, 0x160, 0x16c, 0x178, 0x184, 0x190, 0x19d,
    0x1aa, 0x1b7, 0x1c5, 0x1d2, 0x1e0, 0x1ee, 0x1fc, 0x20b,
    0x21a, 0x229, 0x238, 0x248, 0x257, 0x268, 0x278, 0x288,
    0x299, 0x2aa, 0x2bb, 0x2cd, 0x2df, 0x2f1, 0x303, 0x316,
    0x328, 0x33b, 0x34f, 0x362, 0x376, 0x38a, 0x39f, 0x3b3,
    0x3c8, 0x3dd, 0x3f3, 0x409, 0x41e, 0x435, 0x44b, 0x462,
    0x479, 0x490, 0x4a8, 0x4c0, 0x4d8, 0x4f1, 0x509, 0x522,
    0x53c, 0x555, 0x56f, 0x589, 0x5a3, 0x5be, 0x5d9, 0x5f4,
    0x610, 0x62c, 0x648, 0x664, 0x681, 0x69e, 0x6bb, 0x6d9,
    0x6f7, 0x715, 0x733, 0x752, 0x771, 0x791, 0x7b0, 0x7d0,
    0x7f1, 0x811, 0x832, 0x853, 0x875, 0x896, 0x8b8, 0x8db,
    0x8fe, 0x921, 0x944, 0x968, 0x98b, 0x9b0, 0x9d4, 0x9f9,
    0xa1e, 0xa44, 0xa6a, 0xa90, 0xab6, 0xadd, 0xb04, 0xb2b,
    0xb53, 0xb7b, 0xba4, 0xbcc, 0xbf5, 0xc1f, 0xc48, 0xc72,
    0xc9c, 0xcc7, 0xcf2, 0xd1d, 0xd49, 0xd75, 0xda1, 0xdce,
    0xdfb, 0xe28, 0xe55, 0xe83, 0xeb2, 0xee0, 0xf0f, 0xf3e,
    0xf6e, 0xf9e, 0xfce, 0xfff, 0x1030, 0x1061, 0x1093, 0x10c5,
    0x10f7, 0x1129, 0x115c, 0x1190, 0x11c3, 0x11f7, 0x122c, 0x1261,
    0x1296, 0x12cb, 0x1301, 0x1337, 0x136d, 0x13a4, 0x13db, 0x1413,
    0x144b, 0x1483, 0x14bb, 0x14f4, 0x152e, 0x1567, 0x15a1, 0x15dc,
    0x1616, 0x1651, 0x168d, 0x16c8, 0x1705, 0x1741, 0x177e, 0x17bb,
    0x17f9, 0x1837, 0x1875, 0x18b4, 0x18f3, 0x1932, 0x1972, 0x19b2,
    0x19f2, 0x1a33, 0x1a74, 0x1ab6, 0x1af8, 0x1b3a, 0x1b7d, 0x1bc0,
    0x1c04, 0x1c47, 0x1c8c, 0x1cd0, 0x1d15, 0x1d5a, 0x1da0, 0x1de6,
    0x1e2c, 0x1e73, 0x1eba, 0x1f02, 0x1f4a, 0x1f92, 0x1fdb, 0x7fff,
};

// Method of unlinearizing using a lookup table
//
// This has two steps - first, we use the high byte of the input
// to get an approximate answer for the output (using UnlinearizeLUT).
//
// Then we scan UnlinearizeLUT2 to find the exact answer.
// The i'th entry of UnlinearizeLUT2 is the highest input which will map
// to i.

BYTE
sRGB::UnlinLookup(
    INT16 input
    )
{
    BYTE temp = UnlinearizeLUT[(input & 0xff00)>>8];
    INT16 *lutPtr = &UnlinearizeLUT2[temp];
    
    while (*lutPtr < input) 
    {
        temp++;
        lutPtr++;
    }
    return temp;
}

// CLAMP64: Map inputs below 0 to 0, above SRGB_ONE to 255,
//   and in between to the given expression.

#define CLAMP64(input, expr) (((input) <= 0) ? 0 : \
                              (((input) >= SRGB_ONE) ? 255 : \
                              (expr)))

ARGB
sRGB::ConvertTosRGB(
    ARGB64 color
    ) 
{
    sRGBColor result;
    sRGB64Color c;
    
    c.argb = color;
    
    // [agodfrey] The compiler generates an IMUL for the multiply by 255, 
    // and I can't get it to use a MUL instead. Oh well, it's probably
    // insignificant.
    
    result.a = CLAMP64(c.a, (c.a * 255) >> SRGB_FRACTIONBITS);
    result.r = CLAMP64(c.r, UnlinLookup(c.r));
    result.g = CLAMP64(c.g, UnlinLookup(c.g));
    result.b = CLAMP64(c.b, UnlinLookup(c.b));
    
    return result.argb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\stretch.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name & Abstract
*
*   Stretch. This module contains the code to do various stretching
*   by applying a kernel filter. The code correctly handles minification.
*
* Note:
*   This module is not compiled into an .obj file, rather it is included
*   directly into the header file stretch.hpp.
*   This is due to the use of template functions.
*
*
* Notes:
*
*   This code does not handle rotation or shear.
*
* Created:
*
*   04/17/2000 asecchia
*      Created it.
*
**************************************************************************/

// Actually all the code is moved to stretch.inc because
// it's implemented as a template class and has to be included in
// the module that causes it to be instantiated.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\texturefill.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   TextureFill.cpp
*
* Abstract:
*
*   texture fill routines.
*
* Revision History:
*
*    01/21/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Initializes the fixed point variables needed for texture mapping.
*
* Created:
*
*   03/14/2000 andrewgo
*
\**************************************************************************/

VOID
DpOutputBilinearSpan_MMX::InitializeFixedPointState()
{
    // If the numbers are too large for 16.16 fixed, we'll do the computation
    // in floating-point, per call to OutputSpan:

    ScaleMatrixValid =  GpValidFixed16(DeviceToWorld.GetM11()) &&
                        GpValidFixed16(DeviceToWorld.GetM12()) &&
                        GpValidFixed16(DeviceToWorld.GetM21()) &&
                        GpValidFixed16(DeviceToWorld.GetM22());

    if (ScaleMatrixValid)
    {
        GpPointF vector(1.0f, 0.0f);
        DeviceToWorld.VectorTransform(&vector);
        UIncrement = GpRound(vector.X * (1L << 16));
        VIncrement = GpRound(vector.Y * (1L << 16));

        TranslateMatrixValid = GpValidFixed16(DeviceToWorld.GetDx()) &&
                               GpValidFixed16(DeviceToWorld.GetDy());
                               
        if (TranslateMatrixValid)
        {
            M11 = GpRound(DeviceToWorld.GetM11() * (1L << 16));
            M12 = GpRound(DeviceToWorld.GetM12() * (1L << 16));
            M21 = GpRound(DeviceToWorld.GetM21() * (1L << 16));
            M22 = GpRound(DeviceToWorld.GetM22() * (1L << 16));
            Dx  = GpRound(DeviceToWorld.GetDx() * (1L << 16));
            Dy  = GpRound(DeviceToWorld.GetDy() * (1L << 16));
        }

        ModulusWidth = (BmpData.Width << 16);
        ModulusHeight = (BmpData.Height << 16);

        // When the u,v coordinates have the pixel in the last row or column
        // of the texture space, the offset of the pixel to the right and the
        // pixel below (for bilinear filtering) is the following (for tile modes)
        // because they wrap around the texture space.

        // The XEdgeIncrement is the byte increment of the pixel to the right of
        // the pixel on the far right hand column of the texture. In tile mode,
        // we want the pixel on the same scanline, but in the first column of the
        // texture hence 4bytes - stride

        XEdgeIncrement = 4-BmpData.Stride;

        // The YEdgeIncrement is the byte increment of the pixel below the current
        // pixel when the current pixel is in the last scanline of the texture.
        // In tile mode the correct pixel is the one directly above this one in
        // the first scanline - hence the increment below:

        YEdgeIncrement = -(INT)(BmpData.Height-1)*(INT)(BmpData.Stride);

        if ((BilinearWrapMode == WrapModeTileFlipX) ||
            (BilinearWrapMode == WrapModeTileFlipXY))
        {
            ModulusWidth *= 2;

            // Wrap increment is zero for Flip mode

            XEdgeIncrement = 0;
        }
        if ((BilinearWrapMode == WrapModeTileFlipY) ||
            (BilinearWrapMode == WrapModeTileFlipXY))
        {
            ModulusHeight *= 2;

            // Wrap increment is zero for Flip mode

            YEdgeIncrement = 0;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Texture brush constructor.
*
* Arguments:
*
* Created:
*
*   04/26/1999 ikkof
*
\**************************************************************************/

DpOutputBilinearSpan::DpOutputBilinearSpan(
    const GpTexture *textureBrush,
    DpScanBuffer *scan,
    GpMatrix *worldToDevice,
    DpContext *context
    )
{
    ASSERT(textureBrush);

    dBitmap = NULL;
    Scan     = scan;

    // Initialize the wrap state.

    BilinearWrapMode = textureBrush->GetWrapMode();
    ClampColor = 0;
    SrcRectClamp = FALSE;

    if(textureBrush->GetImageType() != ImageTypeBitmap)
    {
        // Currently, Metafile is not implemented yet.

        Bitmap = NULL;
        return;
    }

    Bitmap = textureBrush->GetBitmap();

    // on bad bitmap, we return with Valid = FALSE
    if (Bitmap == NULL ||
        !Bitmap->IsValid() ||
        Bitmap->LockBits(
            NULL,
            IMGLOCK_READ,
            PixelFormat32bppPARGB,
            &BmpData
        ) != Ok)
    {
        Bitmap = NULL;
        return;
    }

    Size size;
    Bitmap->GetSize(&size);

    SrcRect.X = SrcRect.Y = 0;
    SrcRect.Width  = (REAL)size.Width;
    SrcRect.Height = (REAL)size.Height;
    WorldToDevice = *worldToDevice;

    // If we have a PixelOffset of Half then offset the srcRect by -0.5
    // need to change the WorldToDevice to take this into account.
    // We need to do this here because texture brushes don't have enough
    // information to handle the PixelOffset at a higher level. We construct
    // the SrcRect here, so we apply the PixelOffset immediately.
    
    if (context->PixelOffset == PixelOffsetModeHalf ||
        context->PixelOffset == PixelOffsetModeHighQuality)
    {
        SrcRect.Offset(-0.5f, -0.5f);
        WorldToDevice.Translate(0.5f, 0.5f, MatrixOrderPrepend);
    }

    if(WorldToDevice.IsInvertible())
    {
        // !!![andrewgo] This failure case is bad, we will fall over
        //               later with an uninitialized DeviceToWorld.

        DeviceToWorld = WorldToDevice;
        DeviceToWorld.Invert();
    }
}

DpOutputBilinearSpan::DpOutputBilinearSpan(
    const DpBitmap *bitmap,
    DpScanBuffer *scan,
    GpMatrix *worldToDevice,
    DpContext *context,
    DpImageAttributes *imageAttributes
    )
{
    ASSERT(bitmap);

    dBitmap = bitmap;
    Scan     = scan;

    // Set the imageAttributes state that's relevant to the bilinear span.

    BilinearWrapMode = imageAttributes->wrapMode;
    ClampColor = imageAttributes->clampColor;
    SrcRectClamp = imageAttributes->srcRectClamp;

    Bitmap = NULL;

    // on bad bitmap, we return with Valid = FALSE
    if (dBitmap == NULL || !dBitmap->IsValid() )
    {
        dBitmap = NULL;
        return;
    }
    else
    {
        BmpData.Width = dBitmap->Width;
        BmpData.Height = dBitmap->Height;
        BmpData.PixelFormat = PIXFMT_32BPP_PARGB;
        BmpData.Stride = dBitmap->Delta;
        BmpData.Scan0 = dBitmap->Bits;
    }

    // NOTE: SrcRect is not used.
    // The HalfPixelOffset is already incorporated into the 
    // wordToDevice matrix passed in - which is not the same matrix as
    // context->WorldToDevice
    
    SrcRect.X = 0;
    SrcRect.Y = 0;
    SrcRect.Width  = (REAL)dBitmap->Width;
    SrcRect.Height = (REAL)dBitmap->Height;

    WorldToDevice = *worldToDevice;

    if(WorldToDevice.IsInvertible())
    {
        // !!![andrewgo] This failure case is bad, we will fall over
        //               later with an uninitialized DeviceToWorld.

        DeviceToWorld = WorldToDevice;
        DeviceToWorld.Invert();
    }
}



/**************************************************************************\
*
* Function Description:
*
*   Texture brush constructor.
*
* Arguments:
*
* Created:
*
*   04/26/1999 ikkof
*
\**************************************************************************/

DpOutputBilinearSpan::DpOutputBilinearSpan(
    DpBitmap* bitmap,
    DpScanBuffer * scan,
    DpContext* context,
    DpImageAttributes imageAttributes,
    INT numPoints,
    const GpPointF *dstPoints,
    const GpRectF *srcRect
    )
{
    // NOTE: This constructor is not used.
    // I have no idea if it even works anymore.
    
    WARNING(("DpOutputBilinearSpan: unsupported constructor"));
    
    Scan     = scan;
    BilinearWrapMode = imageAttributes.wrapMode;
    ClampColor = imageAttributes.clampColor;
    SrcRectClamp = imageAttributes.srcRectClamp;
    dBitmap  = bitmap;
    Bitmap   = NULL;

    // on bad bitmap, we return with Valid = FALSE
    if (dBitmap == NULL || !dBitmap->IsValid() )
    {
        dBitmap = NULL;
        return;
    }
    else
    {
        BmpData.Width = dBitmap->Width;
        BmpData.Height = dBitmap->Height;
        BmpData.PixelFormat = PIXFMT_32BPP_PARGB;
        BmpData.Stride = dBitmap->Delta;
        BmpData.Scan0 = dBitmap->Bits;
    }

    WorldToDevice = context->WorldToDevice;
    context->GetDeviceToWorld(&DeviceToWorld);

    // If we have a srcRect then it's already taking the PixelOffset mode into
    // account.
    if(srcRect)
        SrcRect = *srcRect;
    else
    {
        SrcRect.X = 0;
        SrcRect.Y = 0;
        SrcRect.Width  = (REAL)dBitmap->Width;
        SrcRect.Height = (REAL)dBitmap->Height;
        if (context->PixelOffset == PixelOffsetModeHalf ||
            context->PixelOffset == PixelOffsetModeHighQuality)
        {
            SrcRect.Offset(-0.5f, -0.5f);
        }
    }

    GpPointF points[4];

    GpMatrix xForm;
    BOOL existsTransform = TRUE;

    switch(numPoints)
    {
    case 0:
        points[0].X = 0;
        points[0].Y = 0;
        points[1].X = (REAL) SrcRect.Width;
        points[1].Y = 0;
        points[2].X = 0;
        points[2].Y = (REAL) SrcRect.Height;
        break;

    case 1:
        points[0] = dstPoints[0];
        points[1].X = (REAL) (points[0].X + SrcRect.Width);
        points[1].Y = points[0].Y;
        points[2].X = points[0].X;
        points[2].Y = (REAL) (points[0].Y + SrcRect.Height);
        break;

    case 3:
    case 4:
        GpMemcpy(&points[0], dstPoints, numPoints*sizeof(GpPointF));
        break;

    default:
        existsTransform = FALSE;
    }

    if(existsTransform)
    {
        xForm.InferAffineMatrix(points, SrcRect);
    }

    WorldToDevice = context->WorldToDevice;
    WorldToDevice.Prepend(xForm);
    if(WorldToDevice.IsInvertible())
    {
        DeviceToWorld = WorldToDevice;
        DeviceToWorld.Invert();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   From the ARGB value of the four corners, this returns
*   the bilinearly interpolated ARGB value.
*
* Arguments:
*
*   [IN] colors - ARGB values at the four corners.
*   [IN] xFrac  - the fractional value of the x-coordinates.
*   [IN] yFrac  - the fractional value of the y-coordinates.
*   [IN] one, shift. half2, shift2 - the extra arguments used in the
*                                       calculations.
*
* Return Value:
*
*   ARGB: returns the biliearly interpolated ARGB.
*
* Created:
*
*   04/26/1999 ikkof
*
\**************************************************************************/

inline ARGB
getBilinearFilteredARGB(
    ARGB* colors,
    INT xFrac,
    INT yFrac,
    INT one,
    INT shift,
    INT half2,
    INT shift2)
{
    INT a[4], r[4], g[4], b[4];
    INT alpha, red, green, blue;

    for(INT k = 0; k < 4; k++)
    {
        ARGB c = colors[k];
        a[k] = GpColor::GetAlphaARGB(c);
        r[k] = GpColor::GetRedARGB(c);
        g[k] = GpColor::GetGreenARGB(c);
        b[k] = GpColor::GetBlueARGB(c);
    }

    alpha =
        (
            (one - yFrac)*((a[0] << shift)
            + (a[1] - a[0])*xFrac)
            + yFrac*((a[2] << shift)
            + (a[3] - a[2])*xFrac)
            + half2
        ) >> shift2;
    red =
        (
            (one - yFrac)*((r[0] << shift)
            + (r[1] - r[0])*xFrac)
            + yFrac*((r[2] << shift)
            + (r[3] - r[2])*xFrac)
            + half2
        ) >> shift2;
    green =
        (
            (one - yFrac)*((g[0] << shift)
            + (g[1] - g[0])*xFrac)
            + yFrac*((g[2] << shift)
            + (g[3] - g[2])*xFrac)
            + half2
        ) >> shift2;
    blue =
        (
            (one - yFrac)*((b[0] << shift)
            + (b[1] - b[0])*xFrac)
            + yFrac*((b[2] << shift)
            + (b[3] - b[2])*xFrac)
            + half2
        ) >> shift2;

    return  GpColor::MakeARGB
                (
                    (BYTE) alpha,
                    (BYTE) red,
                    (BYTE) green,
                    (BYTE) blue
                );
}



/**************************************************************************\
*
* Function Description:
*   virtual destructor for DpOutputBilinearSpan
*
\**************************************************************************/

DpOutputBilinearSpan::~DpOutputBilinearSpan()
{
    if (Bitmap != NULL)
    {
        Bitmap->UnlockBits(&BmpData);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Applies the correct wrap mode to a set of coordinates
*
* Created:
*
*   03/10/2000 asecchia
*
\**************************************************************************/

void ApplyWrapMode(INT WrapMode, INT &x, INT &y, INT w, INT h)
{
    INT xm, ym;
    switch(WrapMode) {
    case WrapModeTile:
        x = RemainderI(x, w);
        y = RemainderI(y, h);
        break;
    case WrapModeTileFlipX:
        xm = RemainderI(x, w);
        if(((x-xm)/w) & 1) {
            x = w-1-xm;
        }
        else
        {
            x = xm;
        }
        y = RemainderI(y, h);
        break;
    case WrapModeTileFlipY:
        x = RemainderI(x, w);
        ym = RemainderI(y, h);
        if(((y-ym)/h) & 1) {
            y = h-1-ym;
        }
        else
        {
            y = ym;
        }
        break;
    case WrapModeTileFlipXY:
        xm = RemainderI(x, w);
        if(((x-xm)/w) & 1) {
            x = w-1-xm;
        }
        else
        {
            x = xm;
        }
        ym = RemainderI(y, h);
        if(((y-ym)/h) & 1) {
            y = h-1-ym;
        }
        else
        {
            y = ym;
        }
        break;
/*
    // WrapModeExtrapolate is no longer used.

    case WrapModeExtrapolate:
        // Clamp the coordinates to the edge pixels of the source
        if(x<0) x=0;
        if(x>w-1) x=w-1;
        if(y<0) y=0;
        if(y>h-1) y=h-1;
        break;
*/
    case WrapModeClamp:
        // Don't do anything - the filter code will substitute the clamp
        // color when it detects clamp.
    default:
        break;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a texture.
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   01/21/1999 ikkof
*
\**************************************************************************/

GpStatus
DpOutputBilinearSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    // Nothing to do.

    if(xMin==xMax)
    {
        return Ok;
    }

    ASSERT(xMin < xMax);

    ARGB    argb;
    INT     width  = xMax - xMin;
    ARGB *  buffer = Scan->NextBuffer(xMin, y, width);

    GpPointF pt1, pt2;
    pt1.X = (REAL) xMin;
    pt1.Y = pt2.Y = (REAL) y;
    pt2.X = (REAL) xMax;

    DeviceToWorld.Transform(&pt1);
    DeviceToWorld.Transform(&pt2);

    ARGB *srcPtr0 = static_cast<ARGB*> (BmpData.Scan0);
    INT stride = BmpData.Stride/sizeof(ARGB);
    INT i;

    REAL dx, dy, x0, y0;
    INT ix, iy;

    x0 = pt1.X;
    y0 = pt1.Y;

    ASSERT(width > 0);
    dx = (pt2.X - pt1.X)/width;
    dy = (pt2.Y - pt1.Y)/width;

    // Filtered image stretch.

    ARGB *srcPtr1, *srcPtr2;
    INT shift = 11;  // (2*shift + 8 < 32 bits --> shift < 12)
    INT shift2 = shift + shift;
    INT one = 1 << shift;
    INT half2 = 1 << (shift2 - 1);
    INT xFrac, yFrac;
    REAL real;
    ARGB colors[4];

    INT x1, y1, x2, y2;
    for(i = 0; i < width; i++)
    {
        iy = GpFloor(y0);
        ix = GpFloor(x0);
        xFrac = GpRound((x0 - ix)*one);
        yFrac = GpRound((y0 - iy)*one);

        x1=ix;
        x2=ix+1;
        y1=iy;
        y2=iy+1;

        if( ((UINT)ix >= (UINT)(BmpData.Width-1) ) ||
            ((UINT)iy >= (UINT)(BmpData.Height-1)) )
        {
            ApplyWrapMode(BilinearWrapMode, x1, y1, BmpData.Width, BmpData.Height);
            ApplyWrapMode(BilinearWrapMode, x2, y2, BmpData.Width, BmpData.Height);
        }

        if(y1 >= 0 && y1 < (INT) BmpData.Height)
        {
            srcPtr1 = srcPtr0 + stride*y1;
        }
        else
        {
            srcPtr1 = NULL;
        }

        if(y2 >= 0 && y2 < (INT) BmpData.Height)
        {
            srcPtr2 = srcPtr0 + stride*y2;
        }
        else
        {
            srcPtr2 = NULL;
        }

        if(x1 >= 0 && x1 < (INT) BmpData.Width)
        {
            if(srcPtr1)
            {
                colors[0] = *(srcPtr1 + x1);
            }
            else
            {
                colors[0] = ClampColor;
            }

            if(srcPtr2)
            {
                colors[2] = *(srcPtr2 + x1);
            }
            else
            {
                colors[2] = ClampColor;
            }
        }
        else
        {
            colors[0] = ClampColor;
            colors[2] = ClampColor;
        }

        if(x2 >= 0 && x2 < (INT) BmpData.Width)
        {
            if(srcPtr1)
            {
                colors[1] = *(srcPtr1 + x2);
            }
            else
            {
                colors[1] = ClampColor;
            }

            if(srcPtr2)
            {
                colors[3] = *(srcPtr2 + x2);
            }
            else
            {
                colors[3] = ClampColor;
            }
        }
        else
        {
            colors[1] = ClampColor;
            colors[3] = ClampColor;
        }

        if((x2 >= 0) &&
           (x1 < (INT) BmpData.Width) &&
           (y2 >= 0) &&
           (y1 < (INT) BmpData.Height))
        {
            *buffer++ = ::getBilinearFilteredARGB(
                colors,
                xFrac,
                yFrac,
                one,
                shift,
                half2,
                shift2
            );
        }
        else
        {
            *buffer++ = ClampColor;
        }

        x0 += dx;
        y0 += dy;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Handles bilinear texture drawing with arbitrary rotation using MMX.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   01/06/2000 andrewgo
*
\**************************************************************************/

GpStatus
DpOutputBilinearSpan_MMX::OutputSpan(
    INT y,
    INT xMin,
    INT xMax   // xMax is exclusive
    )
{
    // Be a little paranoid in checking some state.

    ASSERT((((ULONG_PTR) BmpData.Scan0) & 3) == 0);
    ASSERT((BmpData.Stride & 3) == 0);
    ASSERT(xMax > xMin);

#if defined(_X86_)

    INT count = xMax - xMin;
    ARGB *buffer = Scan->NextBuffer(xMin, y, count);

    // Transform an array of points using the matrix v' = v M:
    //
    //                                  ( M11 M12 0 )
    //      (vx', vy', 1) = (vx, vy, 1) ( M21 M22 0 )
    //                                  ( dx  dy  1 )
    //
    // All (u, v) calculations are done in 16.16 fixed point.

    INT u;
    INT v;

    // If the values were out of range for fixed point, compute u and v in
    // floating-point, then convert:

    if (TranslateMatrixValid)
    {
        u = M11 * xMin + M21 * y + Dx;
        v = M12 * xMin + M22 * y + Dy;
    }
    else
    {
        GpPointF point(TOREAL(xMin), TOREAL(y));
        DeviceToWorld.Transform(&point, 1);

        u = GpRound(point.X * (1 << 16));
        v = GpRound(point.Y * (1 << 16));
    }

    INT uIncrement = UIncrement;
    INT vIncrement = VIncrement;
    INT modulusWidth = ModulusWidth;
    INT modulusHeight = ModulusHeight;
    VOID *scan0 = BmpData.Scan0;
    INT stride = BmpData.Stride;
    INT width = BmpData.Width;
    INT height = BmpData.Height;
    INT xEdgeIncrement = XEdgeIncrement;
    INT yEdgeIncrement = YEdgeIncrement;

    INT widthMinus1 = width - 1;
    INT heightMinus1 = height - 1;
    UINT uMax = widthMinus1 << 16;
    UINT vMax = heightMinus1 << 16;
    BOOL clampMode = (BilinearWrapMode == WrapModeClamp);
    ARGB clampColor = ClampColor;
    static ULONGLONG Half8dot8 = 0x0080008000800080;

    _asm
    {
        mov         eax, u
        mov         ebx, v
        mov         ecx, stride
        mov         edi, buffer
        pxor        mm0, mm0
        movq        mm3, Half8dot8

        ; edx = scratch
        ; esi = source pixel

    PixelLoop:

        ; Most of the time, our texture coordinate will be from the interior
        ; of the texture.  Things only really get tricky when we have to
        ; span the texture edges.
        ;
        ; Fortunately, the interior case will happen most of the time,
        ; so we make that as fast as possible.  We pop out-of-line to
        ; handle the tricky cases.

        cmp         eax, uMax
        jae         HandleTiling            ; Note unsigned compare

        cmp         ebx, vMax
        jae         HandleTiling            ; Note unsigned compare

        mov         edx, eax
        shr         edx, 14
        and         edx, 0xfffffffc

        mov         esi, ebx
        shr         esi, 16
        imul        esi, ecx

        add         esi, edx
        add         esi, scan0              ; esi = upper left pixel

        ; Stall city.  Write first, then reorder with VTune.

        movd        mm4, [esi]
        movd        mm5, [esi+4]
        movd        mm6, [esi+ecx]
        movd        mm7, [esi+ecx+4]

    ContinueLoop:
        movd        mm1, eax
        punpcklwd   mm1, mm1
        punpckldq   mm1, mm1
        psrlw       mm1, 8                  ; mm1 = x fraction in low bytes

        movd        mm2, ebx
        punpcklwd   mm2, mm2
        punpckldq   mm2, mm2
        psrlw       mm2, 8                  ; mm2 = y fraction in low bytes

        punpcklbw   mm4, mm0
        punpcklbw   mm5, mm0                ; unpack pixels A & B to low bytes

        psubw       mm5, mm4
        pmullw      mm5, mm1
        paddw       mm5, mm3
        psrlw       mm5, 8
        paddb       mm5, mm4                ; mm5 = A' = A + xFrac * (B - A)

        punpcklbw   mm6, mm0
        punpcklbw   mm7, mm0                ; unpack pixels C & D to low bytes

        psubw       mm7, mm6
        pmullw      mm7, mm1
        paddw       mm7, mm3
        psrlw       mm7, 8
        paddb       mm7, mm6                ; mm7 = B' = C + xFrac * (D - C)

        psubw       mm7, mm5
        pmullw      mm7, mm2
        paddw       mm7, mm3
        psrlw       mm7, 8
        paddb       mm7, mm5                ; mm7 = A' + yFrac * (B' - A')

        packuswb    mm7, mm7
        movd        [edi], mm7              ; write the final pixel

        add         eax, uIncrement
        add         ebx, vIncrement
        add         edi, 4

        dec         count
        jnz         PixelLoop
        jmp         AllDone

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; Handle tiling cases here
    ;
    ; All the tough edge cases are handled here, where we deal with
    ; texture coordinates that span the texture boundary.

    HandleTiling:
        cmp         clampMode, 0
        jnz         HandleClamping

        ; Get 'u' in the range 0 <= u < modulusWidth:

        cmp         eax, modulusWidth
        jb          WidthInRange            ; note unsigned compare

        cdq
        idiv        modulusWidth
        mov         eax, edx                ; u %= modulusWidth

        cmp         eax, 0
        jge         WidthInRange
        add         eax, modulusWidth       ; 0 <= u < modulusWidth

    WidthInRange:

        ; Get 'v' in the range 0 <= v < modulusHeight:

        cmp         ebx, modulusHeight
        jb          HeightInRange

        push        eax
        mov         eax, ebx
        cdq
        idiv        modulusHeight
        mov         ebx, edx                ; v %= modulusHeight
        pop         eax

        cmp         ebx, 0
        jge         HeightInRange
        add         ebx, modulusHeight      ; 0 <= v < modulusHeight

    HeightInRange:

        ; Now we're going to need to convert our 'u' and 'v' values
        ; to integers, so save the 16.16 versions:

        push        eax
        push        ebx
        push        ecx
        push        edi

        sar         eax, 16
        sar         ebx, 16                 ; note arithmetic shift

        ; Handle 'flipping'.  Note that edi hold flipping flags, where
        ; the bits have the following meanings:
        ;   1 = X flip in progress
        ;   2 = Y flip in progress
        ;   4 = X flip end boundary not yet reached
        ;   8 = Y flip end boundary not yet reached.

        xor         edi, edi
        cmp         eax, width
        jb          XFlipHandled

        ; u is in the range (width <= u < 2*width).
        ;
        ; We want to flip it such that (0 <= u' < width), which we do by
        ; u' = 2*width - u - 1.  Don't forget ~u = -u - 1.

        or          edi, 1                  ; mark the flip
        not         eax
        add         eax, width
        add         eax, width
        jz          XFlipHandled
        sub         eax, 1
        or          edi, 4                  ; mark flip where adjacent pixels available


    XFlipHandled:
        cmp         ebx, height
        jb          YFlipHandled


        ; v is in the range (height <= v < 2*height).
        ;
        ; We want to flip it such that (0 <= v' < height), which we do by
        ; v' = 2*height - v - 1.  Don't forget ~v = -v - 1.

        or          edi, 2                  ; mark the flip
        not         ebx
        add         ebx, height
        add         ebx, height
        jz          YFlipHandled
        sub         ebx, 1
        or          edi, 8                  ; mark flip where adjacent pixels available

    YFlipHandled:
        mov         esi, ebx
        imul        esi, ecx                ; esi = y * stride

        ; Set 'edx' to the byte offset to the pixel one to the right, accounting
        ; for wrapping past the edge of the bitmap.  Only set the byte offset to
        ; point to right pixel for non edge cases.

        mov         edx, 4
        test        edi, 4
        jnz         RightIncrementCalculated
        test        edi, 1
        jnz         SetXEdgeInc
        cmp         eax, widthMinus1
        jb          RightIncrementCalculated
    SetXEdgeInc:
        mov         edx, xEdgeIncrement

        ; When we flipX and the current pixel is the last pixel in the texture
        ; line, wrapping past the end of the bitmap wraps back in the same side
        ; of the bitmap. I.e. for this one specific pixel we can set the pixel
        ; on-the-right to be the same as this pixel (increment of zero).
        ; Only valid because this is the edge condition.
        ; Note that this will occur for two successive pixels as the texture
        ; wrap occurs - first at width-1 and then at width-1 after wrapping.
        ;
        ; A | B
        ; --+--
        ; C | D
        ;
        ; At this point, pixel A has been computed correctly accounting for the
        ; flip/tile and wrapping beyond the edge of the texture. We work out
        ; the offset of B from A, but we again need to take into account the
        ; possible flipX mode if pixel A happens to be the last pixel in the
        ; texture scanline (the code immediately above takes into account
        ; tiling across the texture boundary, but not the flip)


    RightIncrementCalculated:

        ; Set 'ecx' to the byte offset to the pixel one down, accounting for
        ; wrapping past the edge of the bitmap.  Only set the byte offset to
        ; point to one pixel down for non edge cases.

        test        edi, 8
        jnz         DownIncrementCalculated
        test        edi, 2
        jnz         SetYEdgeInc
        cmp         ebx, heightMinus1
        jb          DownIncrementCalculated
    SetYEdgeInc:
        mov         ecx, yEdgeIncrement

        ; When we flipY and the current pixel is in the last scanline in the
        ; texture, wrapping past the end of the bitmap wraps back in the same
        ; side of the bitmap. I.e. for this one specific scanline we can set
        ; the pixel offset one down to be the same as this pixel
        ; (increment of zero).
        ; Only valid because this is the edge condition.
        ; (see comment above RightIncrementCalculated:)

    DownIncrementCalculated:

        ; Finish calculating the upper-left pixel address:

        add         esi, scan0
        shl         eax, 2
        add         esi, eax                ; esi = upper left pixel

        ; Load the 4 pixels:

        movd        mm4, [esi]
        movd        mm5, [esi+edx]
        add         esi, ecx
        movd        mm6, [esi]
        movd        mm7, [esi+edx]

        ; Finish handling the flip:

        test        edi, 1
        jz          XSwapDone

        movq        mm1, mm5
        movq        mm5, mm4
        movq        mm4, mm1                ; swap pixels A and B

        movq        mm1, mm6
        movq        mm6, mm7
        movq        mm7, mm1                ; swap pixels C and D

    XSwapDone:
        test        edi, 2
        jz          YSwapDone

        movq        mm1, mm4
        movq        mm4, mm6
        movq        mm6, mm1                ; swap pixels A and C

        movq        mm1, mm5
        movq        mm5, mm7
        movq        mm7, mm1                ; swap pixels B and D

    YSwapDone:

        ; Restore everything and get out:

        pop         edi
        pop         ecx
        pop         ebx
        pop         eax
        jmp         ContinueLoop

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; Clamp mode.
    ;
    ; Set the pixel values to 0 for any not on the texture.

    HandleClamping:
        push        eax
        push        ebx

        movd        mm4, clampColor
        movq        mm5, mm4
        movq        mm6, mm4                ; initialize invisible pixels to
        movq        mm7, mm4                ; the clampColor.

        sar         eax, 16
        sar         ebx, 16                 ; note these are arithmetic shifts

        ; We need to look at a 2x2 square of pixels in the texture, where
        ; (eax, ebx) represents the (x, y) texture coordinates.  First we
        ; check for the case where none of the four pixel locations are
        ; actually anywhere on the texture.

        cmp         eax, -1
        jl          FinishClamp
        cmp         eax, width
        jge         FinishClamp             ; early out if (x < -1) or (x >= width)

        cmp         ebx, -1
        jl          FinishClamp
        cmp         ebx, height
        jge         FinishClamp             ; handle trivial rejection

        ; Okay, now we know that we have to pull at least one pixel from
        ; the texture.  Find the address of the upper-left pixel:

        mov         edx, eax
        shl         edx, 2
        mov         esi, ebx
        imul        esi, ecx
        add         esi, edx
        add         esi, scan0              ; esi = upper left pixel

        ; Our pixel nomenclature for the 2x2 square is as follows:
        ;
        ;   A | B
        ;  ---+---
        ;   C | D

        cmp         ebx, 0                  ; if (y < 0), we can't look at
        jl          Handle_CD               ;   row y
        cmp         eax, 0                  ; if (x < 0), we can't look at
        jl          Done_A                  ;   column x
        movd        mm4, [esi]              ; read pixel (x, y)

    Done_A:
        cmp         eax, widthMinus1        ; if (x >= width - 1), we can't
        jge         Handle_CD               ;   look at column x
        movd        mm5, [esi+4]            ; read pixel (x+1, y)

    Handle_CD:
        cmp         ebx, heightMinus1       ; if (y >= height - 1), we can't
        jge         FinishClamp             ;   look at row y
        cmp         eax, 0                  ; if (x < 0), we can't look at
        jl          Done_C                  ;   column x
        movd        mm6, [esi+ecx]          ; read pixel (x, y+1)

    Done_C:
        cmp         eax, widthMinus1        ; if (x >= width - 1), we can't
        jge         FinishClamp             ;   look at column x
        movd        mm7, [esi+ecx+4]        ; read pixel (x+1, y+1)

    FinishClamp:
        pop         ebx
        pop         eax
        jmp         ContinueLoop

    AllDone:
        emms

    }

#endif

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Output routine for handling texture brushes with indentity transforms
*   and either 'Tile' or 'Clamp' wrap modes.
*
* Created:
*
*   03/14/2000 andrewgo
*
\**************************************************************************/
GpStatus
DpOutputBilinearSpan_Identity::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    ASSERT(xMax > xMin);

    INT count = xMax - xMin;
    ARGB *buffer = Scan->NextBuffer(xMin, y, count);

    INT u = xMin + Dx;
    INT v = y + Dy;
    INT width = BmpData.Width;
    INT height = BmpData.Height;
    INT i;

    if (BilinearWrapMode == WrapModeTile)
    {
        if (PowerOfTwo)
        {
            u &= (width - 1);
            v &= (height - 1);
        }
        else
        {
            // Single unsigned compare handles (u < 0) and (u >= width)

            if (static_cast<unsigned>(u) >= static_cast<unsigned>(width))
            {
                u = RemainderI(u, width);
            }

            // Single unsigned compare handles (v < 0) and (v >= width)

            if (static_cast<unsigned>(v) >= static_cast<unsigned>(height))
            {
                v = RemainderI(v, height);
            }
        }

        ARGB *row = reinterpret_cast<ARGB*>
                    (static_cast<BYTE*>(BmpData.Scan0) + (v * BmpData.Stride));
        ARGB *src;

        src = row + u;
        i = min(width - u, count);
        count -= i;

        // We don't call GpMemcpy here because by doing the copy explicitly,
        // the compiler still converts to a 'rep movsd', but it doesn't have
        // to add to the destination 'buffer' pointer when done:

        do {
            *buffer++ = *src++;

        } while (--i != 0);

        while (count > 0)
        {
            src = row;
            i = min(width, count);
            count -= i;

            do {
                *buffer++ = *src++;

            } while (--i != 0);
        }
    }
    else
    {
        ASSERT(BilinearWrapMode == WrapModeClamp);

        ARGB borderColor = ClampColor;

        // Check for trivial rejection.  Unsigned compare handles
        // (v < 0) and (v >= height).

        if ((static_cast<unsigned>(v) >= static_cast<unsigned>(height)) ||
            (u >= width) ||
            (u + count <= 0))
        {
            // The whole scan should be the border color:

            i = count;
            do {
                *buffer++ = borderColor;

            } while (--i != 0);
        }
        else
        {
            ARGB *src = reinterpret_cast<ARGB*>
                        (static_cast<BYTE*>(BmpData.Scan0) + (v * BmpData.Stride));

            if (u < 0)
            {
                i = -u;
                count -= i;
                do {
                    *buffer++ = borderColor;

                } while (--i != 0);
            }
            else
            {
                src += u;
                width -= u;
            }

            i = min(count, width);
            ASSERT(i > 0);              // Trivial rejection ensures this
            count -= i;


            /*
            The compiler was generating particularly stupid code
            for this loop.

            do {
                *buffer++ = *src++;

            } while (--i != 0);
            */

            GpMemcpy(buffer, src, i*sizeof(ARGB));
            buffer += i;

            while (count-- > 0)
            {
                *buffer++ = borderColor;
            }
        }
    }

    return(Ok);
}

/**************************************************************************\
*
* Function Description:
*
*   Hatch brush constructor.
*
* Arguments:
*
* Created:
*
*   04/15/1999 ikkof
*
\**************************************************************************/

DpOutputHatchSpan::DpOutputHatchSpan(
    const GpHatch *hatchBrush,
    DpScanBuffer * scan,
    DpContext* context
    )
{
    Scan = scan;
    ForeARGB = hatchBrush->DeviceBrush.Colors[0].GetPremultipliedValue();
    BackARGB = hatchBrush->DeviceBrush.Colors[1].GetPremultipliedValue();

    // Store the context rendering origin for the brush origin.
    
    m_BrushOriginX = context->RenderingOriginX;
    m_BrushOriginY = context->RenderingOriginY;

    INT a[3], r[3], g[3], b[3];

    a[0] = (BYTE) GpColor::GetAlphaARGB(ForeARGB);
    r[0] = (BYTE) GpColor::GetRedARGB(ForeARGB);
    g[0] = (BYTE) GpColor::GetGreenARGB(ForeARGB);
    b[0] = (BYTE) GpColor::GetBlueARGB(ForeARGB);
    a[1] = (BYTE) GpColor::GetAlphaARGB(BackARGB);
    r[1] = (BYTE) GpColor::GetRedARGB(BackARGB);
    g[1] = (BYTE) GpColor::GetGreenARGB(BackARGB);
    b[1] = (BYTE) GpColor::GetBlueARGB(BackARGB);

    a[2] = (a[0] + 3*a[1]) >> 2;
    r[2] = (r[0] + 3*r[1]) >> 2;
    g[2] = (g[0] + 3*g[1]) >> 2;
    b[2] = (b[0] + 3*b[1]) >> 2;
    AverageARGB = GpColor::MakeARGB((BYTE) a[2], (BYTE) r[2],
                        (BYTE) g[2], (BYTE) b[2]);

    // Antialiase diagonal hatches.
    if(hatchBrush->DeviceBrush.Style == HatchStyleForwardDiagonal ||
        hatchBrush->DeviceBrush.Style == HatchStyleBackwardDiagonal ||
        hatchBrush->DeviceBrush.Style == HatchStyleDiagonalCross)
    {
        REAL temp;

        // occupied = (2*sqrt(2) - 1)/2

        REAL occupied = TOREAL(0.914213562);

        if(a[0] != 255 || a[1] != 255)
        {
            temp = TOREAL(occupied*(a[0] - a[1]) + a[1]);
            a[0] = (BYTE) temp;
        }
        temp = TOREAL(occupied*(r[0] - r[1]) + r[1]);
        if(temp > 255)
            r[0] = 255;
        else
            r[0] = (BYTE) temp;
        temp = TOREAL(occupied*(g[0] - g[1]) + g[1]);
        if(temp > 255)
            g[0] = 255;
        else
            g[0] = (BYTE) temp;
        temp = TOREAL(occupied*(b[0] - b[1]) + b[1]);
        if(temp > 255)
            b[0] = 255;
        else
            b[0] = (BYTE) temp;
        ForeARGB = GpColor::MakeARGB((BYTE) a[0], (BYTE) r[0],
                            (BYTE) g[0], (BYTE) b[0]);
    }

    for(INT i = 0; i < 8; i++)
    {
        for(INT j= 0; j < 8; j++)
        {
            Data[i][j] = hatchBrush->DeviceBrush.Data[i][j];
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a hatch brush
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   04/15/1999 ikkof
*
\**************************************************************************/

GpStatus
DpOutputHatchSpan::OutputSpan(
    INT y,
    INT xMin,
    INT xMax   // xMax is exclusive
    )
{
    ARGB    argb;
    INT     width  = xMax - xMin;
    ARGB*   buffer = Scan->NextBuffer(xMin, y, width);

    INT yMod = (y - m_BrushOriginY) & 0x7;

    for(INT x = xMin; x < xMax; x++)
    {
        INT xMod = (x - m_BrushOriginX) & 0x7;
        INT value = Data[yMod][xMod];
        if(value == 255)
            *buffer++ = ForeARGB;
        else if(value == 0)
            *buffer++ = BackARGB;
        else
            *buffer++ = AverageARGB;    // for antialising.
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster with a hatch brush
*   Is called by the rasterizer.  This is a special version which stretches
*   up the size of the hatch span to device resolution.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   2/20/1 - ericvan
*
\**************************************************************************/

GpStatus
DpOutputStretchedHatchSpan::OutputSpan(
    INT y,
    INT xMin,
    INT xMax   // xMax is exclusive
    )
{
    ARGB    argb;
    INT     width  = xMax - xMin;
    ARGB*   buffer = Scan->NextBuffer(xMin, y, width);

    INT yMod = (y - m_BrushOriginY) % (8*ScaleFactor);
        
    for(INT x = xMin; x < xMax; x++)
    {
        INT xMod = (x - m_BrushOriginX) % (8*ScaleFactor);
        INT value = Data[yMod/ScaleFactor][xMod/ScaleFactor];
        if(value == 255)
            *buffer++ = ForeARGB;
        else if(value == 0)
            *buffer++ = BackARGB;
        else
            *buffer++ = AverageARGB;    // for antialising.
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\sowritermw.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module name:
*
*   The "WriteRMW" scan operation.
*
* Abstract:
*
*   See Gdiplus\Specs\ScanOperation.doc for an overview.
*
*   This module implements scan operations for writing to the final destination
*   when we've done the 'RMW optimization' (see SOReadRMW.cpp).
*
*   We use ReadRMW in some cases when we do a SrcOver alpha-blend operation.
*   When a pixel to be blended has 0 alpha, this means that the destination
*   pixel will be unchanged. The ReadRMW operation skips reading the pixel,
*   so the WriteRMW operation must skip writing to it (to avoid writing
*   garbage).
*
* Revision History:
*
*   12/10/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

// SHOULDCOPY* returns FALSE if the specified alpha value is 
// completely transparent.

#define SHOULDCOPY_sRGB(x)   ((x) != 0)
#define SHOULDCOPY_sRGB64(x) ((x) != 0)

// Helper macros for declaring 'alpha', a pointer to the
// first alpha component in the blending scan.

#define DECLARE_ALPHA_sRGB \
    const BYTE *alpha = \
        static_cast<const BYTE *>(otherParams->BlendingScan) + 3;
    
#define DECLARE_ALPHA_sRGB64 \
    const INT16 *alpha = \
        static_cast<const INT16 *>(otherParams->BlendingScan) + 3;

/**************************************************************************\
*
* Operation Description:
*
*   ReadRMW: Copy all pixels where the corresponding pixel in
*            otherParams->BlendingScan is not completely transparent
*            (i.e. alpha is not 0.)
*
* Arguments:
*
*   dst         - The destination scan
*   src         - The source scan
*   count       - The length of the scan, in pixels
*   otherParams - Additional data (we use BlendingScan).
*
* Return Value:
*
*   None
*
* History:
*
*   12/10/1999 agodfrey
*       Created it.
*
\**************************************************************************/

// 8bpp, for sRGB

VOID FASTCALL
ScanOperation::WriteRMW_8_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_ALPHA_sRGB
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    INT align = (INT) ((-((LONG_PTR) d)) & 0x3);
    align = min(count, align);
    
    count -= align;
    
    while (align)
    {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            *d = *s;
        }
                                        
        d++;
        s++;
        alpha += 4;
        align--;
    }

    // Now go through the aligned dword loop:

    while (count >= 4)
    {
        ASSERT((((ULONG_PTR) d) & 0x3) == 0);
    
        int mask = 0;
        if (SHOULDCOPY_sRGB(*alpha))
        {
            mask = 1;
        }
        if (SHOULDCOPY_sRGB(*(alpha+4)))
        {
            mask |= 2;
        }
        if (SHOULDCOPY_sRGB(*(alpha+8)))
        {
            mask |= 4;
        }
        if (SHOULDCOPY_sRGB(*(alpha+12)))
        {
            mask |= 8;
        }
        
        if (mask == 15)
        {
            // Do a dword write.

            *((UINT32*) d) = *((UNALIGNED UINT32*) s);
        } 
        else
        {
            int idx = 0;

            while (mask)
            {
                if (mask & 1)
                {
                    *(d + idx) = *(s + idx);
                }
                idx ++;
                mask >>= 1;
            }
        }
        
        d += 4;
        s += 4;
        alpha += 16;
        count -= 4;
    }

    // Handle the last few pixels:

    while (count)
    {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            *d = *s;
        }
                                        
        d++;
        s++;
        alpha += 4;
        count--;
    }
}

// 8bpp, for sRGB64

VOID FASTCALL
ScanOperation::WriteRMW_8_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_ALPHA_sRGB64
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    INT align = (INT) ((-((LONG_PTR) d)) & 0x3);
    align = min(count, align);
    
    count -= align;
    
    while (align)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *d = *s;
        }
                                        
        d++;
        s++;
        alpha += 4;
        align--;
    }

    // Now go through the aligned dword loop:

    while (count >= 4)
    {
        ASSERT((((ULONG_PTR) d) & 0x3) == 0);
    
        int mask = 0;
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            mask = 1;
        }
        if (SHOULDCOPY_sRGB64(*(alpha+4)))
        {
            mask |= 2;
        }
        if (SHOULDCOPY_sRGB64(*(alpha+8)))
        {
            mask |= 4;
        }
        if (SHOULDCOPY_sRGB64(*(alpha+12)))
        {
            mask |= 8;
        }
        
        if (mask == 15)
        {
            // Do a dword write.

            *((UINT32*) d) = *((UNALIGNED UINT32*) s);
        } 
        else
        {
            int idx = 0;

            while (mask)
            {
                if (mask & 1)
                {
                    *(d + idx) = *(s + idx);
                }
                idx ++;
                mask >>= 1;
            }
        }
        
        d += 4;
        s += 4;
        alpha += 16;
        count -= 4;
    }
    
    // Handle the last few pixels:

    while (count)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *d = *s;
        }
                                        
        d++;
        s++;
        alpha += 4;
        count--;
    }
}

// 16bpp, for sRGB

VOID FASTCALL
ScanOperation::WriteRMW_16_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT16, UINT16)
    DECLARE_ALPHA_sRGB
    
    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    if (((ULONG_PTR) d) & 0x2)
    {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            *(d) = *(s);
        }
                                        
        d++;
        s++;
        alpha += 4;
        count--;
    }

    // Now go through the aligned dword loop:

    while ((count -= 2) >= 0)
    {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            if (SHOULDCOPY_sRGB(*(alpha + 4)))
            {
                // Both pixels have partial alpha, so do a dword read:

                *((UINT32*) d) = *((UNALIGNED UINT32*) s);
            }
            else
            {
                // Only the first pixel has partial alpha, so do a word read:

                *(d) = *(s);
            }
        }
        else if (SHOULDCOPY_sRGB(*(alpha + 4)))
        {
            // Only the second pixel has partial alpha, so do a word read:

            *(d + 1) = *(s + 1);
        }

        d += 2;
        s += 2;
        alpha += 8;
    }

    // Handle the end alignment:

    if (count & 1)
    {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            *(d) = *(s);
        }
    }
}

// 16bpp, for sRGB64

VOID FASTCALL
ScanOperation::WriteRMW_16_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT16, UINT16)
    DECLARE_ALPHA_sRGB64

    // We want to get dword alignment for our copies, so handle the
    // initial partial dword, if there is one:

    if (((ULONG_PTR) d) & 0x2)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *(d) = *(s);
        }
                                        
        d++;
        s++;
        alpha += 4;
        count--;
    }

    // Now go through the aligned dword loop:

    while ((count -= 2) >= 0)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            if (SHOULDCOPY_sRGB64(*(alpha + 4)))
            {
                // Both pixels have partial alpha, so do a dword read:

                *((UINT32*) d) = *((UNALIGNED UINT32*) s);
            }
            else
            {
                // Only the first pixel has partial alpha, so do a word read:

                *(d) = *(s);
            }
        }
        else if (SHOULDCOPY_sRGB64(*(alpha + 4)))
        {
            // Only the second pixel has partial alpha, so do a word read:

            *(d + 1) = *(s + 1);
        }

        d += 2;
        s += 2;
        alpha += 8;
    }

    // Handle the end alignment:

    if (count & 1)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *(d) = *(s);
        }
    }
}

// 24bpp, for sRGB

VOID FASTCALL
ScanOperation::WriteRMW_24_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_ALPHA_sRGB

    ASSERT(count>0);

    do {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            // Doing byte per byte writes are much faster than finding
            //  runs and doing DWORD copies.
            *(d)     = *(s);
            *(d + 1) = *(s + 1);
            *(d + 2) = *(s + 2);
        }
        d += 3;
        s += 3;
        alpha += 4;
    } while (--count != 0);
}

// 24bpp, for sRGB64

VOID FASTCALL
ScanOperation::WriteRMW_24_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(BYTE, BYTE)
    DECLARE_ALPHA_sRGB64

    ASSERT(count>0);

    do {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            // Doing byte per byte writes are much faster than finding
            //  runs and doing DWORD copies.
            *(d)     = *(s);
            *(d + 1) = *(s + 1);
            *(d + 2) = *(s + 2);
        }
        d += 3;
        s += 3;
        alpha += 4;
    } while (--count != 0);
}

// 32bpp, for sRGB

VOID FASTCALL
ScanOperation::WriteRMW_32_sRGB(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT32, UINT32)
    DECLARE_ALPHA_sRGB
    
    while (count--)
    {
        if (SHOULDCOPY_sRGB(*alpha))
        {
            *d = *s;
        }
        
        d++;
        s++;
        alpha += 4;
    }
}

// 32bpp, for sRGB64

VOID FASTCALL
ScanOperation::WriteRMW_32_sRGB64(
    VOID *dst,
    const VOID *src,
    INT count,
    const OtherParams *otherParams
    )
{
    DEFINE_POINTERS(UINT32, UINT32)
    DECLARE_ALPHA_sRGB64
    
    while (count--)
    {
        if (SHOULDCOPY_sRGB64(*alpha))
        {
            *d = *s;
        }
        
        d++;
        s++;
        alpha += 4;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\critsec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   critsec.cpp
*
* Abstract:
*
*   Critical Section object for protecting LoadLibrary calls
*
* Revision History:
*
*   3/17/2000 asecchia
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

CRITICAL_SECTION LoadLibraryCriticalSection::critSec;
BOOL             LoadLibraryCriticalSection::initialized= FALSE;

CRITICAL_SECTION GpMallocTrackingCriticalSection::critSec;
INT GpMallocTrackingCriticalSection::refCount = 0;

CRITICAL_SECTION GdiplusStartupCriticalSection::critSec;
BOOL             GdiplusStartupCriticalSection::initialized = FALSE;

CRITICAL_SECTION BackgroundThreadCriticalSection::critSec;
BOOL             BackgroundThreadCriticalSection::initialized = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\vgahash.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   VGA color hash table
*
* Abstract:
*
*   This module maintains a hash table which holds the 20 VGA colors
*   (this includes the 4 which can be modified.)
*   The 8bpp halftone code, for example, needs to detect these colors
*   so that it doesn't halftone them.
*
* Notes:
*
*   The collision algorithm is designed to place very little
*   burden on the lookup code. It'll produce bad performance when there
*   are many collisions - which is fine since we expect only
*   a few collisions at most.
*
* Created:
*
*   04/06/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include "precomp.hpp"

// The hash table. VgaColorHash is the actual hash table. It is
// initialized from VgaColorHashInit, and then the 4 magic colors are added.
//
// An entry has the following layout:
//
// Bits 0-23:  The RGB color
// Bits 24-29: The palette index for that color. This is an index into
//             our logical palette (HTColorPalette).
// Bit 30:     FALSE if the entry is empty, TRUE if it is occupied.
// Bit 31:     Used for collisions - if this is TRUE, the lookup function
//             should continue to the next entry.

ARGB VgaColorHash[VGA_HASH_SIZE];
static ARGB VgaColorHashInit[VGA_HASH_SIZE] = {
    0x40000000, 0x00000000, 0x00000000, 0x00000000,
    0x44000080, 0x00000000, 0x00000000, 0x500000ff,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x42008000, 0x00000000, 0x00000000, 0x00000000,
    0x46008080, 0x00000000, 0x00000000, 0x00000000,
    0x5200ffff, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x4e00ff00,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x41800000, 0x00000000, 0x00000000, 0x00000000,
    0x45800080, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x43808000, 0x00000000, 0x00000000, 0x00000000,
    0x4c808080, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x4fffff00, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x53ffffff,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x51ff00ff, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x47c0c0c0, 0x4dff0000
};

/**************************************************************************
*
* Function Description:
*
*   Finds an entry in the table.
*
* Arguments:
*
*   color - the color to find
*
* Return Value:
*
*   The index corresponding to that color, or 0xff if not found.
*
* Notes:
*
*   I don't expect performance-critical code to use this -
*   e.g. HalftoneToScreen_sRGB_8_216 needs to do this inline -
*   but it's useful for other code.
*
* Created:
*
*   04/08/2000 agodfrey
*      Created it.
*
**************************************************************************/

BYTE 
VGAHashLookup(
    COLORREF color
    )
{
    UINT hashKey = VGAHashColor(
        GetRValue(color),
        GetGValue(color),
        GetBValue(color)
        );

    ARGB rgbColor = (GetRValue(color) << 16) |
        (GetGValue(color) << 8) |
        GetBValue(color);
        
    UINT tblEntry;
    
    do
    {
        tblEntry = VgaColorHash[hashKey];
        
        if (((tblEntry ^ rgbColor) & 0xffffff) == 0)
        {
            return (tblEntry >> 24) & 0x3f;
        }
        
        if (static_cast<INT>(tblEntry) >= 0)
        {
            break;
        }
        
        hashKey++;
        hashKey &= (1 << VGA_HASH_BITS) - 1;
    } while (1);
            
    return 0xff;
}

/**************************************************************************
*
* Function Description:
*
*   Adds an entry to the hash table. If the same color is already in
*   the table, adds nothing.
*
* Arguments:
*
*   color - the color to add
*   index - the palette index of the color
*
* Return Value:
*
*   NONE
*
* Created:
*
*   04/06/2000 agodfrey
*      Created it.
*
**************************************************************************/

VOID 
VGAHashAddEntry(
    COLORREF color,
    INT index
    )
{
    ASSERT ((index >= 0) & (index < 0x40));
    
    if (VGAHashLookup(color) != 0xff)
    {
        return;
    }
    
    UINT hashKey = VGAHashColor(
        GetRValue(color),
        GetGValue(color),
        GetBValue(color)
        );

    ARGB rgbColor = (GetRValue(color) << 16) |
        (GetGValue(color) << 8) |
        GetBValue(color);
   
    // Find an empty location
        
    while (VgaColorHash[hashKey] & 0x40000000)
    {
        // Set the high bit of each occupied location we hit, so that
        // the lookup code will find the value we're about to add.
        
        VgaColorHash[hashKey] |= 0x80000000;
        hashKey++;
        if (hashKey == VGA_HASH_SIZE)
        {
            hashKey = 0;
        }
    }
    
    // Store the new entry
    
    VgaColorHash[hashKey] = (rgbColor & 0xffffff) | (index << 24) | 0x40000000;
}

/**************************************************************************
*
* Function Description:
*
*   Reinitializes the hash table, and adds the given 4 magic colors.
*
* Arguments:
*
*   magicColors - the 4 magic colors
*
* Return Value:
*
*   NONE
*
* Created:
*
*   04/06/2000 agodfrey
*      Created it.
*
**************************************************************************/

VOID 
VGAHashRebuildTable(
    COLORREF *magicColors
    )
{
    GpMemcpy(VgaColorHash, VgaColorHashInit, sizeof(VgaColorHashInit));
    VGAHashAddEntry(magicColors[0], 8);
    VGAHashAddEntry(magicColors[1], 9);
    VGAHashAddEntry(magicColors[2], 10);
    VGAHashAddEntry(magicColors[3], 11);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\render\vgahash.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   VGA color hash table
*
* Abstract:
*
*   This module maintains a hash table which holds the 20 VGA colors
*   (this includes the 4 which can be modified.)
*   The 8bpp halftone code, for example, needs to detect these colors
*   so that it doesn't halftone them.
*
* Created:
*
*   04/06/2000 agodfrey
*      Created it.
*
**************************************************************************/

#ifndef _VGAHASH_HPP
#define _VGAHASH_HPP

#define VGA_HASH_BITS 7
#define VGA_HASH_SIZE (1 << VGA_HASH_BITS)

extern ARGB VgaColorHash[VGA_HASH_SIZE];

VOID VGAHashRebuildTable(COLORREF *magicColors);

/**************************************************************************
*
* Function Description:
*
*   Hashes an RGB color
*
* Arguments:
*
*   r, g, b - the red, green and blue components of the color
*
* Return Value:
*
*   The hash table value
*
* Created:
*
*   04/06/2000 agodfrey
*      Created it.
*
**************************************************************************/

__forceinline UINT
VGAHashColor(
    UINT r, 
    UINT g, 
    UINT b
    )
{
    UINT hashKey = (r >> 1) ^ (g >> 3) ^ (b >> 5);
    
    ASSERT(hashKey < VGA_HASH_SIZE);
    return hashKey;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\basetypes.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   BaseTypes.hpp
*
* Abstract:
*
*   Basic types used by GDI+ implementation
*
* Revision History:
*
*   12/01/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _BASETYPES_HPP
#define _BASETYPES_HPP

#ifdef _X86_
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif

//
// TODO: Remove the 'Gp' prefix from all these classes
// TODO: What is a GlyphPos? Why is it a base type?
// 

namespace GpRuntime
{

//--------------------------------------------------------------------------
// Forward declarations of various internal classes
//--------------------------------------------------------------------------

typedef double REALD;

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class GpSize
{
public:

    // Default constructor

    GpSize()
    {
        // NOTE: Size is uninitialized by default.
        // Specicifically, it's not initialized to 0,0.
    }

    // Construct a Size object using the specified
    // x- and y- dimensions.

    GpSize(INT width, INT height)
    {
        Width = width;
        Height = height;
    }

public:

    // The fields are public here.

    INT Width;
    INT Height;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class GpPoint
{
public:

    // Default constructor

    GpPoint()
    {
    }

    // Construct a Point object using the specified
    // x- and y- coordinates.

    GpPoint(INT x, INT y)
    {
        X = x;
        Y = y;
    }

public:

    INT X;
    INT Y;
};

class GpPointD
{
public:

    // Default constructor

    GpPointD()
    {
    }

    // Construct a Point object using the specified
    // x- and y- coordinates.

    GpPointD(REALD x, REALD y)
    {
        X = x;
        Y = y;
    }

public:

    REALD X;
    REALD Y;
};

class GpPoint3F
{
public:

    // Default constructor

    GpPoint3F()
    {
    }

    // Construct a Point object using the specified
    // x- and y- coordinates.

    GpPoint3F(REAL x, REAL y, REAL z)
    {
        X = x;
        Y = y;
        Z = z;
    }

public:

    REAL X;
    REAL Y;
    REAL Z;
};

class GpPoint3D
{
public:

    // Default constructor

    GpPoint3D()
    {
    }

    // Construct a Point object using the specified
    // x- and y- coordinates.

    GpPoint3D(REALD x, REALD y, REALD z)
    {
        X = x;
        Y = y;
        Z = z;
    }

public:

    REALD X;
    REALD Y;
    REALD Z;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class GpRect
{
public:

    // Default constructor

    GpRect()
    {
    }

    // Construct a Rect object using the specified
    // location and size.

    GpRect(INT x, INT y, INT width, INT height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    GpRect(const GpPoint& location, const GpSize& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    // Determine if the rectangle is empty

    BOOL IsEmpty() const
    {
        return (Width <= 0) || (Height <= 0);
    }

    // Return the left, top, right, and bottom
    // coordinates of the rectangle

    INT GetLeft() const
    {
        return X;
    }

    INT GetTop() const
    {
        return Y;
    }

    INT GetRight() const
    {
        return X+Width;
    }

    INT GetBottom() const
    {
        return Y+Height;
    }

    // Determine if the specified rect intersects with the
    // current rect object.

    BOOL IntersectsWith(const GpRect& rect)
    {
        return (GetLeft()   < rect.GetRight()  &&
                GetTop()    < rect.GetBottom() &&
                GetRight()  > rect.GetLeft()   &&
                GetBottom() > rect.GetTop());
    }

    // Intersect the current rect with the specified object

    BOOL Intersect(const GpRect& rect)
    {
        return IntersectRect(*this, *this, rect);
    }

    // Intersect rect a and b and save the result into c
    // Notice that c may be the same object as a or b.
    // !!! Consider moving out-of-line

    static BOOL IntersectRect(GpRect& c, const GpRect& a, const GpRect& b)
    {
        INT right = min(a.GetRight(), b.GetRight());
        INT bottom = min(a.GetBottom(), b.GetBottom());
        INT left = max(a.GetLeft(), b.GetLeft());
        INT top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmpty();
    }

public:

    INT X;
    INT Y;
    INT Width;
    INT Height;
};

//--------------------------------------------------------------------------
// Represents a 32-bit ARGB color in AARRGGBB format
//--------------------------------------------------------------------------

class GpColor 
{
public:

    GpColor() 
    {
        Argb = Color::Black;
    }

    GpColor(BYTE r, BYTE g, BYTE b) 
    {
        Argb = MakeARGB(255, r, g, b);
    }

    GpColor(BYTE a, BYTE r, BYTE g, BYTE b) 
    {
        Argb = MakeARGB(a, r, g, b);
    }

    GpColor(ARGB argb)
    {
        Argb = argb;
    }

    // Retrieve ARGB values

    ARGB GetValue() const
    {
        return Argb;
    }

    VOID SetValue(IN ARGB argb)
    {
        Argb = argb;
    }

    // Extract A, R, G, B components

    BYTE GetAlpha() const
    {
        return (BYTE) (Argb >> AlphaShift);
    }

    BYTE GetRed() const
    {
        return (BYTE) (Argb >> RedShift);
    }

    BYTE GetGreen() const
    {
        return (BYTE) (Argb >> GreenShift);
    }

    BYTE GetBlue() const
    {
        return (BYTE) (Argb >> BlueShift);
    }

    // Return premultiplied ARGB values

    ARGB GetPremultipliedValue() const
    {
        return ConvertToPremultiplied(Argb);
    }

    // Determine if the color is completely opaque

    BOOL IsOpaque() const
    {
        return (Argb & AlphaMask) == AlphaMask;
    }

    // Determine if the two colors are the same

    BOOL IsEqual(const GpColor & color) const
    {
        return (Argb == color.Argb);
    }


    VOID SetColor(ARGB argb)
    {
        this->Argb = argb;
    }

    COLORREF ToCOLORREF() const
    {
        return RGB(GetRed(), GetGreen(), GetBlue());
    }

    VOID BlendOpaqueWithWhite()
    {
        UINT32 alpha = this->GetAlpha();
        if (alpha == 0) 
        {
            this->Argb = 0xFFFFFFFF;
        }
        else if (alpha != 255)
        {
            UINT32 multA = 255 - alpha;
        
            UINT32 D1_000000FF = 0xFF;
            UINT32 D2_0000FFFF = D1_000000FF * multA + 0x00000080;
            UINT32 D3_000000FF = (D2_0000FFFF & 0x0000FF00) >> 8;
            UINT32 D4_0000FF00 = (D2_0000FFFF + D3_000000FF) & 0x0000FF00;
        
            UINT32 alphaContrib = D4_0000FF00 >> 8 |
                                  D4_0000FF00 << 8 |
                                  D4_0000FF00;
        
            this->Argb = 0xFF000000 | (this->Argb + alphaContrib);
        }
    }

    // Shift count and bit mask for A, R, G, B components
    enum
    {
        AlphaShift  = 24,
        RedShift    = 16,
        GreenShift  = 8,
        BlueShift   = 0
    };

    enum
    {
        AlphaMask   = 0xff000000,
        RedMask     = 0x00ff0000,
        GreenMask   = 0x0000ff00,
        BlueMask    = 0x000000ff
    };

    // Assemble A, R, G, B values into a 32-bit integer
    static ARGB MakeARGB(IN BYTE a,
                         IN BYTE r,
                         IN BYTE g,
                         IN BYTE b)
    {
        return (((ARGB) (b) <<  BlueShift) |
                ((ARGB) (g) << GreenShift) |
                ((ARGB) (r) <<   RedShift) |
                ((ARGB) (a) << AlphaShift));
    }

    // Convert an ARGB value to premultiplied form

    static ARGB ConvertToPremultiplied(ARGB argb)
    {
        UINT alpha = (argb & AlphaMask) >> AlphaShift;

        if (alpha == 0xff)
        {
            // fully opaque - don't need to do anything
        }
        else if (alpha == 0)
        {
            // fully transparent

            argb = 0;
        }
        else
        {
            // translucent
            // Approximate 1/255 by 257/65536:

            UINT red = ((argb & RedMask) >> RedShift) * alpha + 0x80;
            UINT green = ((argb & GreenMask) >> GreenShift) * alpha + 0x80;
            UINT blue = ((argb & BlueMask) >> BlueShift) * alpha + 0x80;

            argb = MakeARGB((BYTE) alpha,
                            (BYTE) ((red + (red >> 8)) >> 8),
                            (BYTE) ((green + (green >> 8)) >> 8),
                            (BYTE) ((blue + (blue >> 8)) >> 8));
        }

        return(argb);
    }

    // This is a variation of the above which is useful for
    // antialiasing. It takes the argb value plus an additional
    // alpha value (0-255) which is to multiply the alpha in the
    // color before converting to premultiplied. In the antialiasing
    // case, this extra alpha value is the coverage.

    static ARGB PremultiplyWithCoverage(ARGB argb, BYTE coverage)
    {
        UINT alpha = (argb & AlphaMask) >> AlphaShift;

        alpha = alpha*coverage + 0x80;
        alpha = ((alpha + (alpha >> 8)) >> 8);

        // translucent
        // Approximate 1/255 by 257/65536:

        UINT red = ((argb & RedMask) >> RedShift) * alpha + 0x80;
        UINT green = ((argb & GreenMask) >> GreenShift) * alpha + 0x80;
        UINT blue = ((argb & BlueMask) >> BlueShift) * alpha + 0x80;

        argb = MakeARGB((BYTE) alpha,
                        (BYTE) ((red + (red >> 8)) >> 8),
                        (BYTE) ((green + (green >> 8)) >> 8),
                        (BYTE) ((blue + (blue >> 8)) >> 8));

        return(argb);
    }

    static ARGB MultiplyCoverage(ARGB argb, BYTE coverage)
    {
        UINT alpha = (argb & AlphaMask) >> AlphaShift;

        alpha = alpha*coverage + 0x80;
        alpha = ((alpha + (alpha >> 8)) >> 8);

        // translucent
        // Approximate 1/255 by 257/65536:

        UINT red = ((argb & RedMask) >> RedShift) * coverage + 0x80;
        UINT green = ((argb & GreenMask) >> GreenShift) * coverage + 0x80;
        UINT blue = ((argb & BlueMask) >> BlueShift) * coverage + 0x80;

        argb = MakeARGB((BYTE) alpha,
                        (BYTE) ((red + (red >> 8)) >> 8),
                        (BYTE) ((green + (green >> 8)) >> 8),
                        (BYTE) ((blue + (blue >> 8)) >> 8));

        return(argb);
    }

    static INT GetAlphaARGB(ARGB argb)
    {
        return ((argb & AlphaMask) >> AlphaShift);
    }

    static INT GetRedARGB(ARGB argb)
    {
        return ((argb & RedMask) >> RedShift);
    }

    static INT GetGreenARGB(ARGB argb)
    {
        return ((argb & GreenMask) >> GreenShift);
    }

    static INT GetBlueARGB(ARGB argb)
    {
        return ((argb & BlueMask) >> BlueShift);
    }

private:

    ARGB Argb;

};

// Union for converting between ARGB and 4 separate BYTE channel values.

union GpColorConverter 
{
    ARGB argb;
    struct {
        BYTE b;
        BYTE g;
        BYTE r;
        BYTE a;
    } Channel;
};

// 32 bits per channel floating point color value.

class GpFColor128 
{
    public:
    
    REAL b;
    REAL g;
    REAL r;
    REAL a;
};


class GpGlyphPos
{
public:
    GpGlyphPos(int x0=0, int y0=0, int cx=0, int cy=0, BYTE* bts=NULL)
    :   Left(x0), Top(y0), Width(cx), Height(cy), BitsOrPath((PVOID) bts), bTempBits(FALSE), bIsBits(TRUE)
    {}

    inline INT         GetLeft(void) const         { return Left; }
    inline INT         GetTop(void) const          { return Top; }
    inline INT         GetWidth(void) const        { return Width; }
    inline INT         GetHeight(void) const       { return Height; }
    
    
    void        SetLeft(INT l)              { Left = l; }
    void        SetTop(INT t)               { Top = t; }
    void        SetWidth(INT w)             { Width = w; }
    void        SetHeight(INT h)            { Height = h; }

    BYTE * GetBits(void) const         
    { 
        if (bIsBits)
            return (BYTE *) BitsOrPath;

        return (BYTE *) NULL;
    }

    PVOID GetPath(void) const
    { 
        if (!bIsBits)
            return BitsOrPath; 
        else
            return (PVOID) NULL; 
    }

    void SetPath(PVOID path=NULL)     
    { 
        BitsOrPath = path; 
        bIsBits = FALSE;
    }
    
    void SetBits(BYTE* bts=NULL)     
    { 
        BitsOrPath = (PVOID) bts; 
        bIsBits = TRUE;
    }

    void SetTempBits(BYTE* bts=NULL) 
    { 
        BitsOrPath = (PVOID) bts;

        if (bts)
        {
            bTempBits = TRUE;
        }
    }

    BYTE * GetTempBits()
    {
        if (bTempBits)
            return (BYTE *) BitsOrPath;
        return NULL;
    }                                         

private:
    INT     Left;
    INT     Top;
    INT     Width;
    INT     Height;
    BOOL    bTempBits;
    BOOL    bIsBits;
    PVOID   BitsOrPath;
};

}

#endif // !_BASETYPES_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\autopointers.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   AutoPointers smart pointer classes library.
*
* Abstract:
*
*   Implements AutoArray and AutoPointer smart pointer classes.
*
* Notes:
*
*   To avoid cleanup code in our functions we need to use smart pointer classes
*   for holding allocation results. These classes are roughly similar to std::auto_ptr,
*   although there are differences regarding ownership, operator&, defensive code etc.
*
* Revision History:
*
*   07/18/2000 mleonov
*       Created it.
*
\**************************************************************************/

#ifndef __AUTOPOINTERS_HPP_
#define __AUTOPOINTERS_HPP_

// The following 2 classes are very similar, except that:
// AutoPointer uses operator delete and provides operator->
// AutoArray uses operator delete[] and provides operator[]





/////   AutoArray - Pointer to array of items with automatic freeing
//
//      This class is used for storing arrays allocated using new [].
//      For example:
//
//      {
//          AutoArray<BYTE> buffer(new BYTE[count]);
//          if (!buffer)
//              return OutOfMemory;
//          buffer[0] = 0;
//          DoSomething(buffer.Get());
//          // buffer is automatically deallocated
//      }

template<class T>
class AutoArray
{
    typedef AutoArray<T>    self;
public:
    // This constructor is made explicit so that compiler
    // doesn't create implicit temporaries of type AutoArray<T>
    explicit AutoArray(T * source = 0) : Pointer(source) {}

    // Copy constructor and assignment operators need to ensure that
    // pointer is freed only once
    AutoArray(self & rhs) : Pointer(rhs.Release()) {}

    self & operator=(self & rhs)
    {
        SafeAssign(rhs.Release());
        return *this;
    }

    // Safe assignment for regular pointer
    self & operator=(T * rhs)
    {
        SafeAssign(rhs);
        return *this;
    }

    // Destructor is the whole point of having this class
    ~AutoArray()
    {
        Clear();
    }

    // This operator is for functions which allocate pointer and return it using T **
    T ** operator&()
    {
        Clear();
        Pointer = 0;
        return &Pointer;
    }

    // The following 2 operators are for checks for NULL
    operator BOOL() const
    {
        return (Pointer != 0);
    }

    BOOL operator!() const
    {
        return !Pointer;
    }

// We disallow implicit conversion to pointer because it's dangerous,
// for example we don't want people do explicitly delete underlying pointer
//    operator T* () const { return Pointer; }

    T & operator*() const
    {
        AssertNotEmpty();
        return *Get();
    }

    // Make indexing work the same way as for built-in arrays
    template <typename INDEXTYPE>
    T & operator[](INDEXTYPE ndx) const
    {
        AssertNotEmpty();
        return *(Get() + ndx);
    }

    // Obtain the underlying pointer
    T * Get() const
    {
        return Pointer;
    }

    // Obtain the underlying pointer and release ownership,
    // normally this is used to safely return the pointer from a function
    // and let caller take care of deallocation
    T * Release()
    {
        T * tmp = Pointer;
        Pointer = 0;
        return tmp;
    }

private:
    // Note that one should always assign a new value to Pointer after calling Clear()
    void Clear()
    {
        delete[] Pointer;
    }

    void SafeAssign(T * rhs)
    {
        // We don't want to have 2 smart pointers pointing to the same object
        // as it will result in double free
        ASSERT(!(Pointer != NULL && Pointer == rhs));

        Clear();
        Pointer = rhs;
    }

    void AssertNotEmpty() const
    {
        ASSERT(Get() != 0);
    }

    T *     Pointer;    // underlying pointer
}; // class AutoArray




/////   AutoPointer - Pointer to single item with automatic freeing
//
//      This class is used for storing objects allocated using new.
//      For example:
//
//      {
//          AutoPointer<OBJECT> object(new OBJECT);
//          if (!object)
//              return OutOfMemory;
//          object->Method();
//          DoSomething(object.Get());
//          // object is automatically deallocated
//      }

template<class T>
class AutoPointer
{
    typedef AutoPointer<T>  self;
public:
    // This constructor is made explicit so that compiler
    // doesn't create implicit temporaries of type AutoPointer<T>
    explicit AutoPointer(T * source = 0) : Pointer(source) {}

    // Copy constructor and assignment operators need to ensure that
    // pointer is freed only once
    AutoPointer(self & rhs) : Pointer(rhs.Release()) {}

    self & operator=(self & rhs)
    {
        SafeAssign(rhs.Release());
        return *this;
    }

    // Safe assignment for regular pointer
    self & operator=(T * rhs)
    {
        SafeAssign(rhs);
        return *this;
    }

    // Destructor is the whole point of having this class
    ~AutoPointer()
    {
        Clear();
    }

    // This operator is for functions which allocate pointer and return it using T **
    T ** operator&()
    {
        Clear();
        Pointer = 0;
        return &Pointer;
    }

    // The following 2 operators are for checks for NULL
    operator BOOL() const
    {
        return (Pointer != 0);
    }

    BOOL operator!() const
    {
        return !Pointer;
    }

// We disallow implicit conversion to pointer because it's dangerous,
// for example we don't want people do explicitly delete underlying pointer
//    operator T* () const { return Pointer; }

    T & operator*() const
    {
        AssertNotEmpty();
        return *Get();
    }

    // Allow method calls using -> notation
    T * operator->() const
    {
        AssertNotEmpty();
        return Get();
    }

    // Obtain the underlying pointer
    T * Get() const
    {
        return Pointer;
    }

    // Obtain the underlying pointer and release ownership,
    // normally this is used to safely return the pointer from a function
    // and let caller take care of deallocation
    T * Release()
    {
        T * tmp = Pointer;
        Pointer = 0;
        return tmp;
    }

private:
    // Note that one should always assign a new value to Pointer after calling Clear()
    void Clear()
    {
        delete Pointer;
    }

    void SafeAssign(T * rhs)
    {
        // We don't want to have 2 smart pointers pointing to the same object
        // as it will result in double free
        ASSERT(!(Pointer != NULL && Pointer == rhs));

        Clear();
        Pointer = rhs;
    }

    void AssertNotEmpty() const
    {
        ASSERT(Get() != 0);
    }

    T *     Pointer;    // underlying pointer
}; // class AutoPointer






/////   AutoBuffer - Pointer to array of items with stack alloc and automatic freeing
//
//      This class is used for creating buffers.
//      For example:
//
//      {
//          AutoBuffer<BYTE, 100> buffer(count);
//          if (!buffer)
//              return OutOfMemory;
//          buffer[0] = 0;
//          DoSomething(buffer.Get());
//          // buffer is automatically deallocated
//      }
//
//      Creates an array of count BYTEs. Reserves 100 bytes of stack space.
//      If count <= 100, the reserved stack space is used for the buffer, else
//      teh space is allocated on the heap.

template<class T, INT StackSize>
class AutoBuffer
{
public:
    // This constructor is made explicit so that compiler
    // doesn't create implicit temporaries of type AutoArray<T>
    explicit AutoBuffer(INT requestedSize = -1)
    :   Size    (requestedSize),    // Allocated lazily if > StackSize
        Pointer (StackBuffer)       // Pointer is never NULL
    {
        if (requestedSize > StackSize)
        {
            // Stack buffer is not big enough
            SetSize(requestedSize);
        }
    }

    void Clear()
    {
        if (Pointer != StackBuffer)
        {
            delete [] Pointer;
        }
        Pointer = StackBuffer;
        Size = -1;
    }

    void SetSize(INT size)
    {
        // Fast case if existing buffer is big enough

        if (size < Size  ||  size < StackSize)
        {
            // Use existing buffer, whether it is the stack buffer or whether
            // it is allocated separately.
            Size = size;
            return;
        }


        if (Pointer != StackBuffer)
        {
            // Exisiting buffer is not big enough
            delete [] Pointer;
            Pointer = StackBuffer;
        }

        Size = size;

        if (Size > StackSize)
        {
            // Attempt to allocate a buffer bigger than stacksize.
            // This doesn't have to succeed. (If it fails it leaves
            // Size and Pointer in the defined 'unallocated' state.)
            T *newBuffer = new T[Size];
            if (newBuffer != NULL)
            {
                Pointer = newBuffer;
            }
            else
            {
                // Cannot handle requested size
                Size = -1;  // Uninitialised
            }
        }
    }


    ~AutoBuffer()
    {
        Clear();
    }

    // The following 2 operators check whether the buffer needs allocating

    operator BOOL()
    {
        return initialized();
    }

    BOOL operator!()
    {
        return !initialized();
    }

// We disallow implicit conversion to pointer because it's dangerous,
// for example we don't want people do explicitly delete underlying pointer
//    operator T* () const  { return Pointer; }
//    T & operator*() const { AssertNotEmpty(); return *Get(); }

    // Provide index checked array lookup
    template <typename INDEXTYPE>
    T & operator[](INDEXTYPE ndx)
    {
        ASSERT(ndx >= 0  &&  ndx < Size);
        return *(Pointer + ndx);
    }

    // Obtain the underlying pointer
    T * Get()
    {
        return Pointer;
    }


private:

    BOOL initialized()
    {
        return Size >= 0  &&  (Size <= StackSize  ||  Pointer != StackBuffer);
    }

    // Possible states:
    //
    //                          |    Size <= StackSize   |   Size > StackSize
    //                          |    -----------------   |   ----------------
    //                          |                        |
    //   Pointer == StackBuffer | Buffer up to StackSize | Allocation failed
    //   ---------------------- | is available.          |
    //                          |                        |
    //                          |                        |
    //   Pointer != StackBuffer | Dynamic buffer was     | Heap buffer available
    //   ---------------------- | previously allocated   | sufficient for Size.
    //                          | since when SetSize has |
    //                          | reduced required size. |
    //
    //   Note that when SetSize reduces the required size after a heap buffer
    //   has already been allocated, the spare buffer space is NOT released.
    //   The client may call Clear() to guarantee freeing any heap buffer.
    //
    //   If uninitialized, or if cleared, Size is recorded internally as -1,
    //   and BOOL tests return false. SetSize(0) is valid, always succeeds, and
    //   causes BOOL tests to return TRUE.

    INT Size;                       // Requested size
    T * Pointer;                    // Underlying pointer

    // Note: be sure to keep the following buffer pointer size aligned.
    T StackBuffer[StackSize];       // Note: prior pointer causes alignment

}; // class AutoBuffer

class AutoLock
{
    CRITICAL_SECTION &  CriticalSection;
public:
    AutoLock(CRITICAL_SECTION & cs) : CriticalSection(cs)
    {
        ::EnterCriticalSection(&CriticalSection);
    }
    ~AutoLock()
    {
        ::LeaveCriticalSection(&CriticalSection);
    }
};

#endif // __AUTOPOINTERS_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\debug.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   Debugging macros
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   09/07/1999 agodfrey
*       Moved from Engine\Common
*   02/07/2000 agodfrey
*       Made more of it private (for bug #35561).
*       Changed the output function to add "\n" automatically.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

#if DBG

// Global debug level

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_RIP     4

extern INT GpDebugLevel;

///////////////////////////// DEPRECATED STUFF ///////////////////////////////

// Raw output function. Emits debug messages. Its direct use is depracated.
// It's useful for private debugging, though.

ULONG _cdecl DbgPrint(CHAR*, ...);

// Strip the directory prefix from a filename

const CHAR*
StripDirPrefix(
    const CHAR* filename
    );

// Use of DBGMSG is depracated - it's supplied only because driverd3d.cpp uses
// it.

#define DBGMSG(level, prefix, msg)       \
        {                                \
            if (GpDebugLevel <= (level)) \
            {                            \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefix(__FILE__), __LINE__); \
                DbgPrint msg;            \
            }                            \
        }

///////////////////////////// PRIVATE STUFF //////////////////////////////////

// Just leave this function alone. You don't want to call it yourself. Trust me.
CHAR * _cdecl GpParseDebugString(CHAR* format, ...);

// Ditto for this one.
VOID _cdecl GpLogDebugEvent(INT level, CHAR *file, UINT line, CHAR *message);

#define LOG_DEBUG_EVENT(level, msg)                                  \
    {                                                                \
        if (GpDebugLevel <= (level))                                 \
        {                                                            \
            CHAR *debugOutput = GpParseDebugString msg;              \
            GpLogDebugEvent(level, __FILE__, __LINE__, debugOutput); \
        }                                                            \
    }

//////////////////////////////// THE GOOD STUFF //////////////////////////////

// These macros are used for debugging. They expand to
// whitespace on a free build.
//
// GpDebugLevel
//  Global variable which holds the current debug level. You can use it to
//  control the quantity of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify that a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify that a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// ONCE(code block)
//  Use this to make a code block execute only once per run.
//  Useful for cutting down on spew.
//  e.g.:
//      ONCE(WARNING(("Invalid arguments")));
//
// Usage:
//
//  These macros require extra parentheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer; ignoring it."));
//      ASSERTMSG(x > 0, ("x is less than 0"));
//
//  Each call to an output function is treated as a separate event -
//  if you want to build up a message, e.g. in a loop, build it up in a
//  string, and then call the output function.
//
//  This is because we don't always just output the string to the debugger -
//  when we link statically, we may send the output to a user-defined handler.
//
//  Don't put a trailing \n on the message. If the output is sent to the
//  debugger, the output function will add the \n itself.

#define VERBOSE(msg) LOG_DEBUG_EVENT(DBG_VERBOSE, msg)
#define TERSE(msg) LOG_DEBUG_EVENT(DBG_TERSE, msg)
#define WARNING(msg) LOG_DEBUG_EVENT(DBG_WARNING, msg)

// SAVE_WARNING must be identical to WARNING
#define SAVE_WARNING(msg) LOG_DEBUG_EVENT(DBG_WARNING, msg)

// same as WARNING, but doesn't require extra set of ()'s for single string
#define WARNING1(msg) LOG_DEBUG_EVENT(DBG_WARNING, (msg))
#define RIP(msg) LOG_DEBUG_EVENT(DBG_RIP, msg)

#define ASSERT(cond)   \
    {                  \
        if (! (cond))  \
        {              \
            RIP(("Assertion failure: %s", #cond)); \
        }              \
    }

#define ASSERTMSG(cond, msg) \
    {                        \
        if (! (cond))        \
        {                    \
            RIP(msg);        \
        }                    \
    }

#define ONCE(codeblock)      \
    {                        \
        static int doneOnce; \
        if (!doneOnce)       \
        {                    \
            { codeblock ; }  \
            doneOnce=1;      \
        }                    \
    }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define DBGMSG(level, prefix, msg) {}
#define VERBOSE(msg) {}
#define TERSE(msg) {}
#define WARNING(msg) {}
#define SAVE_WARNING(msg) {}
#define WARNING1(msg) {}

#define RIP(msg) {}
#define ASSERT(cond) {}
#define ASSERTMSG(cond, msg) {}

#define ONCE(codeblock) {}

#endif // !DBG

// IF_NOT_OK_WARN_AND_RETURN(statusValue)
// This macro is used when you want to return early in case of a failure
// and spit out a debug warning.
// 
// Originally we had an ASSERT instead of WARNING, but this prevented test
// from running automation on checked build
// 
// from David Brown:
//      I got fed up writing this little block again and again all over the
//      place.
//
//      Looking at all the places that needed it I found I was often missing
//      the ASSERT, and sometimes doing the ASSERT but missing the return.
//
//      Futhermore when written in full, this block takes more space than the
//      code around it making it difficult to see the wood for the trees.
//
//      Although I generally avoid macros because thay make code less
//      obvious, I believe this one makes it safer in the long run.

#define IF_NOT_OK_WARN_AND_RETURN(a)  \
    if ((a) != Ok)                             \
    {                                          \
        WARNING(("Status != Ok"));             \
        return a;                              \
    }

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\debug.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Debugging routines
*
* Revision History:
*
*   09/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

namespace Globals
{
    DebugEventProc UserDebugEventProc = NULL;
};

#if DBG

// GpDebugLevel is used to control the amount/severity of debugging messages
// that are actually output.

INT GpDebugLevel = DBG_TERSE;

/**************************************************************************\
*
* Function Description:
*
*   Removes the path portion of a pathname
*
* Arguments:
*
*   [IN] str - pathname to strip
*
* Return Value:
*
*   A pointer to the filename portion of the pathname
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

const CHAR*
StripDirPrefix(
    const CHAR* str
    )

{
    const CHAR* p;

    p = strrchr(str, '\\');
    return p ? p+1 : str;
}

const int maxInputStringSize = 1024;

/**************************************************************************\
*
* Function Description:
*
*   Outputs to the debugger
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   Zero. This is to conform to NTDLL's definition of DbgPrint.
*
* Notes:
*
*   There will be no output if a debugger is not connected.
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

ULONG _cdecl
DbgPrint(
    CHAR* format,
    ...
    )

{
    va_list arglist;
    va_start(arglist, format);
    
    char buf[maxInputStringSize];
    
    _vsnprintf(buf, maxInputStringSize, format, arglist);
    buf[maxInputStringSize-1]=0;
        
    OutputDebugStringA(buf);
    
    va_end(arglist);
    return 0;
}

// If we can't allocate memory for the debug string, we'll use this buffer
// in desperation. It's not thread-safe. I *did* say 'desperation'.

static CHAR desperationBuffer[maxInputStringSize];

/**************************************************************************\
*
* Function Description:
*
*   Creates a new string, and sprintf's to it.
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   The probably-newly-allocated string result.
*
* Notes:
*
*   This function is not intended for general use. It guards against memory
*   failure by using a global buffer. So, while the caller is responsible
*   for freeing the memory, the caller must also check for that buffer.
*   i.e. we only want DbgEmitMessage to call this.
*
*   It's also only mostly thread-safe, because if we run out of memory,
*   we'll use that global buffer in a non-protected way.
*
*   This is the only solution I could find so that I could move most of the
*   implementation details out of the header file. The root cause is that
*   macros don't handle multiple arguments natively, so we have to pass
*   the printf arguments as a single macro argument (in parentheses).
*   Which means, the function that consumes those arguments can have no
*   other arguments.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it. Finally, I've found a way to get debug implementation
*       details out of the headers.
*
\**************************************************************************/

CHAR * _cdecl
GpParseDebugString(
    CHAR* format,
    ...
    )
{
    va_list arglist;
    va_start(arglist, format);
    
    // Don't use GpMalloc here so that we can use ASSERT and WARNING in 
    // our memory allocation routines.

    char *newBuf = static_cast<char *>(LocalAlloc(LMEM_FIXED, maxInputStringSize));
    if (!newBuf)
    {
        newBuf = desperationBuffer;
    }
    
    _vsnprintf(newBuf, maxInputStringSize, format, arglist);
    
    // Nuke the last byte, because MSDN isn't clear on what _vsnprintf does
    // in that case.
    
    newBuf[maxInputStringSize-1]=0;
        
    va_end(arglist);
    return newBuf;
}

/**************************************************************************\
*
* Function Description:
*
*   Processes a debug event. Frees the message string.
*
* Arguments:
*
* level   - The debug level of the event 
* file    - Should be __FILE__
* line    - Should be __LINE__
* message - The debug message.
*
* Notes:
*
*   You don't want to call this directly. That would be error-prone. 
*   Use ASSERT, WARNING, etc.
*
*   Depending on the debug level, an identifying prefix will be output.
*
*   If the debug level is DBG_RIP, will suspend execution (e.g. by
*   hitting a breakpoint.)
*
* Note on the "debug event" callback:
*
*   We optionally pass WARNINGs and ASSERTs to a reporting function
*   provided by the user, instead of to the debugger.
*   (e.g. their function may pop up a dialog or throw an exception).
*   Lesser events will still be sent to the debugger.
*
* History:
*
*   02/01/2000 agodfrey
*       Created it.
*
\**************************************************************************/

VOID _cdecl 
GpLogDebugEvent(
    INT level, 
    CHAR *file, 
    UINT line,
    CHAR *message
    )
{
    // We may want to add things to the passed-in message. So we need
    // a temporary buffer
    
    const int maxOutputStringSize = maxInputStringSize + 100;
    CHAR tempBuffer[maxOutputStringSize+1];
    
    // MSDN's _vsnprintf doc isn't clear on this, so just in case:
    tempBuffer[maxOutputStringSize] = 0;

    INT callbackEventType = -1;
    
    CHAR *prefix = "";
    
    if (GpDebugLevel <= (level))
    {
        switch (level)
        {
        case DBG_WARNING:
            prefix = "WRN ";
            if (Globals::UserDebugEventProc)
            {
                callbackEventType = DebugEventLevelWarning;
            }    
            break;
            
        case DBG_RIP:
            prefix = "RIP ";
            if (Globals::UserDebugEventProc)
            {
                callbackEventType = DebugEventLevelFatal;
            }    
            break;
        }
        
        // The convention is that we append the trailing \n, not the caller.
        // Two reasons:
        // 1) Callers tend to forget it.
        // 2) More importantly, it encourages the caller to think of each
        //    call as a separate event. This is important in some cases - e.g.
        //    when the user's "debug event" callback produces a popup for 
        //    each event.

        _snprintf(
            tempBuffer, 
            maxOutputStringSize, 
            "%s%s(%d): %s\n",
            prefix,
            StripDirPrefix(file),
            line,
            message
            );
        
        if (callbackEventType >= 0)
        {
            // Wrap the following call in an exception handler in case the
            // initial component who set the debug event proc uninitializes
            // on another thread, resulting in UserDebugEventProc being set
            // to NULL.

            __try
            {
                Globals::UserDebugEventProc((DebugEventLevel) callbackEventType, tempBuffer);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                OutputDebugStringA(tempBuffer);
            }
        }
        else
        {
            OutputDebugStringA(tempBuffer);
        }
    }
    
    // Free the message buffer
    
    if (message != desperationBuffer)
    {
        LocalFree(message);
    }
    
    // Force a breakpoint, if it's warranted.
    
    if ((GpDebugLevel <= DBG_RIP) && (level == DBG_RIP) && (callbackEventType < 0))
    {
        DebugBreak();
    }
}
    
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\critsec.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   critsec.hpp
*
* Abstract:
*
*   Critical Section object for protecting LoadLibrary calls
*
* Revision History:
*
*   3/17/2000 asecchia
*       Created it.
*
\**************************************************************************/

#ifndef _CRITSEC_HPP
#define _CRITSEC_HPP

// !!! [agodfrey]: We should establish a ranking of critical sections and
// assert that it doesn't get inverted. 

// Here's a start: 
//
// GdiplusStartupCriticalSection
//     BackgroundThreadCriticalSection
//
// (e.g. to acquire both BackgroundThreadCriticalSection and 
//       GdiplusStartupCriticalSection, acquire GdiplusStartupCriticalSection
//       first, and release it last.)


// This is a CriticalSection Proxy designed to 
// automatically acquire the critical section 
// when the instance is created and release 
// it when it goes out of scope.

class LoadLibraryCriticalSection
{
public:

    static VOID InitializeCriticalSection()
    {
        __try
        {
            ::InitializeCriticalSection(&critSec);
        }
        __except(EXCEPTION_CONTINUE_SEARCH)
        {
        }
        // If we throw then initialized will be false;
        // It's the caller's responsability to ensure that the throw is caught
        initialized = TRUE;
    }

    static VOID DeleteCriticalSection()
    {
        if (initialized)
        {
            ::DeleteCriticalSection(&critSec);
            initialized = FALSE;
        }
    }

    LoadLibraryCriticalSection()
    {
        ASSERT(initialized);
        EnterCriticalSection(&critSec);
    }

    ~LoadLibraryCriticalSection()
    {
        ASSERT(initialized);
        LeaveCriticalSection(&critSec);
    }

private:
    static CRITICAL_SECTION critSec;
    static BOOL initialized;
};

// This is a CriticalSection Proxy used for GdiplusStartup and GdiplusShutdown.

class GdiplusStartupCriticalSection
{
public:

    static VOID InitializeCriticalSection()
    {
        __try
        {
            ::InitializeCriticalSection(&critSec);
        }
        __except(EXCEPTION_CONTINUE_SEARCH)
        {
        }

        // If we throw then initialized will be false;
        // It's the caller's responsability to ensure that the throw is caught
        initialized = TRUE;
    }

    static VOID DeleteCriticalSection()
    {
        if (initialized)
        {
            ::DeleteCriticalSection(&critSec);
            initialized = FALSE;
        }
    }

    GdiplusStartupCriticalSection()
    {
        ASSERT(initialized);
        EnterCriticalSection(&critSec);
    }

    ~GdiplusStartupCriticalSection()
    {
        ASSERT(initialized);
        LeaveCriticalSection(&critSec);
    }

private:
    static CRITICAL_SECTION critSec;
    static BOOL initialized;
};

// [agodfrey] This is a CriticalSection Proxy used for globals touched
// by the background thread. We can't use GdiplusStartupCriticalSection for
// these, because (at least as things are now) the background thread can't 
// acquire GdiplusStartupCriticalSection.
//
// If it did, we could deadlock when we wait for the background thread to
// finish.

class BackgroundThreadCriticalSection
{
public:

    static VOID InitializeCriticalSection()
    {
        __try
        {
            ::InitializeCriticalSection(&critSec);
        }
        __except(EXCEPTION_CONTINUE_SEARCH)
        {
        }

        // If we throw then initialized will be false;
        // It's the caller's responsability to ensure that the throw is caught
        initialized = TRUE;
    }

    static VOID DeleteCriticalSection()
    {
        if (initialized)
        {
            ::DeleteCriticalSection(&critSec);
            initialized = FALSE;
        }
    }
    
    BackgroundThreadCriticalSection()
    {
        ASSERT(initialized);
        EnterCriticalSection(&critSec);
    }

    ~BackgroundThreadCriticalSection()
    {
        ASSERT(initialized);
        LeaveCriticalSection(&critSec);
    }

private:
    static CRITICAL_SECTION critSec;
    static BOOL initialized;
};

// This is a CriticalSection Proxy designed to 
// automatically acquire the critical section 
// when the instance is created and release 
// it when it goes out of scope.

// NB: this critical section should only be used for the malloc tracking
// code. If you use it for anything else, then you should probably make sure you
// don't allocate or free memory under this critsec.

class GpMallocTrackingCriticalSection
{
public:

    static VOID InitializeCriticalSection()
    {
        // Only call InitializeCriticalSection if this is the first
        // time we're calling this code.

        // Note: this refCount thing is not actually thread safe, but
        // we only call this from our dllinit function so we should be
        // ok.

        // The refcount can tell us if the critical section is initialized

        if(refCount==0)
        {
            __try
            {
                ::InitializeCriticalSection(&critSec);
            }
            __except(EXCEPTION_CONTINUE_SEARCH)
            {
            }
        }

        refCount++;
    }

    static VOID DeleteCriticalSection()
    {
        // Decrement the refCount. If it hits zero, 
        // delete the critical section.

        refCount--;

        // If the refCount is ever negative that means we're being called
        // to delete the critical section without ever having initialized it.

        #if DBG
        if(refCount<0)
        {
            // !!! [asecchia] don't know if deleting an uninitialized critical
            // section is bad or not. This could happen if we failed 
            // initialization somewhere and we're trying to clean up
            // afterward.

            WARNING(("Trying to delete the GpMallocTrackingCriticalSection without initializing it first"));
        }
        #endif

        if(refCount==0)
        {
            ::DeleteCriticalSection(&critSec);
        }
    }

    GpMallocTrackingCriticalSection()
    {
        // Entering the critical section without first having called
        // InitializeCriticalSection will cause a crash.
        
        ASSERT(refCount>0);
        
        EnterCriticalSection(&critSec);
    }

    ~GpMallocTrackingCriticalSection()
    {
        // Leaving the critical section without first having called 
        // InitializeCriticalSection will cause a crash.
        
        ASSERT(refCount>0);

        LeaveCriticalSection(&critSec);
    }

private:
    static CRITICAL_SECTION critSec;

    // This critical section is initialized in imaging.dll and gdiplus.dll.
    // The gdiplus initialization code initializes the imaging module. 
    // To avoid initializing and deleting this critical section more 
    // than once, we refcount it.

    // !!! [agodfrey]: Now that we've eliminated imaging.dll, I don't think
    //     we need this refcount.
    
    static INT refCount;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\fix.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Fix.hpp
*
* Abstract:
*
*   Fixed Point types, defines, and methods
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/

#ifndef _FIX_HPP
#define _FIX_HPP

typedef INT FIX4;       // 28.4 fixed point value
typedef INT FIX16;      // 16.16 fixed point value

// constants for working with 28.4 fixed point values
#define FIX4_SHIFT  4
#define FIX4_PRECISION  4
#define FIX4_ONE        (1 << FIX4_PRECISION)
#define FIX4_HALF       (1 << (FIX4_PRECISION-1))
#define FIX4_MASK       (FIX4_ONE - 1)


enum
{
    FIX16_SHIFT = 16,
    FIX16_ONE = 1 << FIX16_SHIFT,
    FIX16_HALF = 1 << (FIX16_SHIFT - 1),
    FIX16_MASK = FIX16_ONE - 1
};

inline INT
GpFix16Floor(
    FIX16        fixedValue
    )
{
    return fixedValue >> FIX16_SHIFT;
}

inline INT
GpFix16Ceiling(
    FIX16        fixedValue
    )
{
    return (fixedValue + FIX16_MASK) >> FIX16_SHIFT;
}

inline INT
GpFix16Round(FIX16 fixedValue)
{
    // Add half and truncate down towards negative infinity.
    return (fixedValue + FIX16_HALF) >> FIX16_SHIFT;
}

inline FIX16
GpRealToFix16(
    REAL        realValue
    )
{
    return GpRound(realValue * FIX16_ONE);
}

/**************************************************************************\
*
* Function Description:
*
*   Take the ceiling of a fixed-pt value, without doing overflow checking
*
* Arguments:
*
*   [IN] fixedValue - 28.4 Fixed Point value
*
* Return Value:
*
*   INT - The integer ceiling (32.0) of the fixed point value
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/

inline INT
GpFix4Ceiling(
    FIX4        fixedValue
    )
{
    return (fixedValue + FIX4_MASK) >> FIX4_PRECISION;
}

inline INT
GpFix4Floor(
    FIX4        fixedValue
    )
{
    return fixedValue >> FIX4_PRECISION;
}

inline INT
GpFix4Round(
    FIX4        fixedValue
    )
{
    // Add half and truncate down towards negative infinity.

    return (fixedValue + FIX4_HALF) >> FIX4_PRECISION;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert a real, floating point value to a 28.4 fixed-point value,
*   without doing overflow checking
*
* Arguments:
*
*   [IN] r         - Real class to make rounding faster
*   [IN] realValue - the real value to convert
*
* Return Value:
*
*   FIX4 - The 28.4 fixed point value
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
inline FIX4
GpRealToFix4(
    REAL        realValue
    )
{
    return GpRound(realValue * FIX4_ONE);
}

inline REAL
FIX4TOREAL(
    FIX4    fix
    )
{
    return (((REAL)fix)/16);
}

class PointFix4
{
public:
    FIX4    X;
    FIX4    Y;
    
    VOID Set(REAL x, REAL y)
    {
        X = GpRealToFix4(x);
        Y = GpRealToFix4(y);
    }
};

//--------------------------------------------------------------------------
// The following are simple functions to check if a number is within range
// of fixed point types.
//--------------------------------------------------------------------------

#define FIXED16_INT_MAX ( (1 << 15) - 1)
#define FIXED16_INT_MIN (-(1 << 15))

#define FIXED4_INT_MAX ( (1 << 27) - 1)
#define FIXED4_INT_MIN (-(1 << 27))

inline BOOL GpValidFixed16(REAL x)
{
    return (x >= FIXED16_INT_MIN) && (x <= FIXED16_INT_MAX);
}

inline BOOL GpValidFixed4(REAL x)
{
    return (x >= FIXED4_INT_MIN) && (x <= FIXED4_INT_MAX);
}

inline BOOL GpValidFixed16(INT x)
{
    return (x >= FIXED16_INT_MIN) && (x <= FIXED16_INT_MAX);
}

inline BOOL GpValidFixed4(INT x)
{
    return (x >= FIXED4_INT_MIN) && (x <= FIXED4_INT_MAX);
}


/**************************************************************************\
*
* Function Description:
*
*   This function multiplies two 32bit integers into a 64 bit value, and
*   shifts the result to the right by 16 bits.  We provide a hand
*   optimized assembly version on x86 to avoid out of line calls.
*
*   This has the effect of multiplying two 16.16 fixed point numbers and
*   returning a 16.16 fixed point result.
*
* Arguments:
*
*     a - first 32bit integer to multiply
*     b - second 32bit integer to multiply
*
* History:
*   04/16/2000 asecchia   created it.
*
\**************************************************************************/

#ifdef _X86_

__inline INT
Int32x32Mod16(
        INT a,
        INT b
        )
{
    __asm
    {
        mov eax, b
        imul a
        shrd eax, edx, 16
    }
}

#else

__inline INT
Int32x32Mod16(
        INT a,
        INT b
        )
{
    return ((INT) Int64ShraMod32(Int32x32To64(a, b), 16));
}

#endif


/**************************************************************************\
*
* Function Description:
*
*   This function takes two input numbers treated as 16.16. They are multiplied
*   together to give an internal 32.32 fixed point representation. The 
*   fractional bits are then rounded to the nearest whole number and the
*   result is returned as a BYTE. 
*
*   This is particularly useful for color channel computation requiring 16 
*   bits of fractional precision.
*
* Arguments:
*
*     a - first 32bit integer to multiply
*     b - second 32bit integer to multiply
*
* History:
*   12/20/2000 asecchia   created it.
*
\**************************************************************************/

#ifdef _X86_

__inline BYTE
Fix16MulRoundToByte(DWORD a, DWORD b)
{
    __asm
    {
        mov eax, b
        mul a
        add eax, 0x80000000   // FIX32 half
        adc edx, 0            // carry
        mov eax, edx          // ret dl
    }
}

#else

__inline BYTE
Fix16MulRoundToByte(DWORD a, DWORD b)
{
    return (BYTE)GpFix16Round(Int32x32Mod16(a, b));
}

#endif



#endif // _FIX_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\enums.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   GDI+ private enumsruntime
*
* Abstract:
*
*   Enums moved from sdkinc because we don't want them public.
*
* Revision History:
*
*   2/15/2k ericvan
*       Created it.
*
\**************************************************************************/

#include "..\..\sdkinc\gdiplusenums.h"

enum EnumerationType
{
    LinesAndBeziers = 0,
    Flattened       = 1,
    Widened         = 2
};

const UINT MAX_TEXT_CONTRAST_VALUE = 12;
const UINT DEFAULT_TEXT_CONTRAST = 4;


// UnitWorld and UnitDisplay are NOT valid as a srcUnit
inline BOOL
SrcUnitIsValid(
    Unit        unit
    )
{
    return ((unit >= UnitPixel) && (unit <= UnitMillimeter));
}

inline BOOL
MetafileFrameUnitIsValid(
    MetafileFrameUnit   frameUnit
    )
{
    return ((frameUnit >= MetafileFrameUnitPixel) && (frameUnit <= MetafileFrameUnitGdi));
}

inline BOOL
WrapModeIsValid(
    WrapMode    mode
    )
{
    return ((mode >= WrapModeTile) && (mode <= WrapModeClamp));
}

inline BOOL
CombineModeIsValid(
    CombineMode         combineMode
    )
{
    return ((combineMode >= CombineModeReplace) &&
            (combineMode <= CombineModeComplement));
}

inline BOOL
MatrixOrderIsValid(
    MatrixOrder     order
    )
{
    return ((order == MatrixOrderPrepend) || (order == MatrixOrderAppend));
}

inline BOOL
EmfTypeIsValid(
    EmfType     type
    )
{
    return ((type >= EmfTypeEmfOnly) && (type <= EmfTypeEmfPlusDual));
}

inline BOOL
ColorAdjustTypeIsValid(
    ColorAdjustType     type
    )
{
    return ((type >= ColorAdjustTypeDefault) && (type < ColorAdjustTypeCount));
}

#if 0
GpStatus
WINGDIPAPI
GdipCreateRectGradient(
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    ARGB* colors,
    GpWrapMode wrapMode,
    GpRectGradient **rectgrad
    )
{
    CheckParameter(rectgrad && colors);

    GpRectF rect(x, y, width, height);

    GpColor gpcolor[4];

    gpcolor[0].SetColor(colors[0]);
    gpcolor[1].SetColor(colors[1]);
    gpcolor[2].SetColor(colors[2]);
    gpcolor[3].SetColor(colors[3]);

    *rectgrad = new GpRectGradient(rect, gpcolor, wrapMode);

    if (CheckValid(*rectgrad))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateRectGradientI(
    INT x,
    INT y,
    INT width,
    INT height,
    ARGB* colors,
    GpWrapMode wrapMode,
    GpRectGradient **rectgrad
    )
{
     return GdipCreateRectGradient(TOREAL(x),
                                   TOREAL(y),
                                   TOREAL(width),
                                   TOREAL(height),
                                   colors,
                                   wrapMode,
                                   rectgrad);
}

GpStatus
WINGDIPAPI
GdipGetRectGradientColor(
    GpRectGradient *brush,
    ARGB* colors
    )
{
    CheckParameter(colors);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor gpcolor[4];

    brush->GetColors(gpcolor);

    colors[0] = gpcolor[0].GetValue();
    colors[1] = gpcolor[1].GetValue();
    colors[2] = gpcolor[2].GetValue();
    colors[3] = gpcolor[3].GetValue();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetRectGradientColor(
    GpRectGradient *brush,
    ARGB* colors
    )
{
    CheckParameter(colors);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor gpcolor[4];

    gpcolor[0].SetColor(colors[0]);
    gpcolor[1].SetColor(colors[1]);
    gpcolor[2].SetColor(colors[2]);
    gpcolor[3].SetColor(colors[3]);

    brush->SetColors(gpcolor);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientRect(
    GpRectGradient *brush,
    GpRectF *rect
    )
{
    CheckParameter(rect);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->GetRect(*rect);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientRectI(
    GpRectGradient *brush,
    GpRect *rect
    )
{
    CheckParameter(rect);

    GpRectF rectF;

    GpStatus status = GdipGetRectGradientRect(brush, &rectF);

    if (status == Ok)
    {
        FPUStateSaver fpuState;

        rect->X = GpRound(rectF.X);
        rect->Y = GpRound(rectF.Y);
        rect->Width = GpRound(rectF.Width);
        rect->Height = GpRound(rectF.Height);
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientBlendCountH(
    GpRectGradient *brush,
    INT *count
    )
{
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetHorizontalBlendCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientBlendH(
    GpRectGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetHorizontalBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipSetRectGradientBlendH(
    GpRectGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetHorizontalBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipGetRectGradientBlendCountV(
    GpRectGradient *brush,
    INT *count
    )
{
    CheckParameter(count > 0);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetVerticalBlendCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientBlendV(
    GpRectGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetVerticalBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipSetRectGradientBlendV(
    GpRectGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetVerticalBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipSetRectGradientWrapMode(
    GpRectGradient *brush,
    GpWrapMode wrapmode
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetWrapMode(wrapmode);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientWrapMode(
    GpRectGradient *brush,
    GpWrapMode *wrapmode
    )
{
    CheckParameter(wrapmode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *wrapmode = (GpWrapMode)brush->GetWrapMode();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetRectGradientTransform(
    GpRectGradient *brush,
    GpMatrix *matrix
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    brush->SetTransform(*matrix);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRectGradientTransform(
    GpRectGradient *brush,
    GpMatrix *matrix
    )
{
   CheckParameterValid(brush);
   CheckObjectBusy(brush);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   brush->GetTransform(matrix);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateRadialBrush(
    GpRectF *gprect,
    ARGB centercol,
    ARGB boundarycol,
    GpWrapMode wrapmode,
    GpRadialGradient **radgrad
    )
{
    CheckParameter(radgrad && gprect);

    GpColor center(centercol);
    GpColor boundary(boundarycol);

    *radgrad = new GpRadialGradient(*gprect, center, boundary, wrapmode);

    if (CheckValid(*radgrad))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateRadialBrushI(
    GpRect *gprect,
    ARGB centercol,
    ARGB boundarycol,
    GpWrapMode wrapmode,
    GpRadialGradient **radgrad
    )
{
    CheckParameter(gprect);

    GpRectF rectF(TOREAL(gprect->X),
                  TOREAL(gprect->Y),
                  TOREAL(gprect->Width),
                  TOREAL(gprect->Height));

    return GdipCreateRadialBrush(&rectF,
                                 centercol,
                                 boundarycol,
                                 wrapmode,
                                 radgrad);
}

GpStatus
WINGDIPAPI
GdipSetRadialCenterColor(
    GpRadialGradient *brush,
    ARGB argb
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor center(argb);

    brush->SetCenterColor(center);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetRadialBoundaryColor(
    GpRadialGradient *brush,
    ARGB argb
    )
{
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   GpColor boundary(argb);

   brush->SetBoundaryColor(boundary);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialCenterColor(
    GpRadialGradient *brush,
    ARGB *argb
    )
{
   CheckParameter(argb);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   GpColor center = brush->GetCenterColor();

   *argb = center.GetValue();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialBoundaryColor(
    GpRadialGradient *brush,
    ARGB *argb
    )
{
   CheckParameter(argb);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   GpColor boundary = brush->GetBoundaryColor();

   *argb = boundary.GetValue();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialRect(
    GpRadialGradient *brush,
    GpRectF *rect
    )
{
   CheckParameter(rect);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   brush->GetRect(*rect);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialRectI(
    GpRadialGradient *brush,
    GpRect *rect
    )
{
   CheckParameter(rect);

   GpRectF rectF;

   GpStatus status = GdipGetRadialRect(brush, &rectF);

   if (status == Ok)
   {
       FPUStateSaver fpuState;

       rect->X = GpRound(rectF.X);
       rect->Y = GpRound(rectF.Y);
       rect->Width = GpRound(rectF.Width);
       rect->Height = GpRound(rectF.Height);
   }

   return status;
}

GpStatus
WINGDIPAPI
GdipGetRadialBlendCount(
    GpRadialGradient *brush,
    INT *count
    )
{
   CheckParameter(count);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   *count = brush->GetBlendCount();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialBlend(
    GpRadialGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
   CheckParameter(blend);
   CheckParameter(positions);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   return brush->GetBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipSetRadialBlend(
    GpRadialGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
   CheckParameter(blend);
   CheckParameter(positions);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   return brush->SetBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipGetRadialPresetBlendCount(
    GpRadialGradient *brush,
    INT *count
    )
{
   CheckParameter(count);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   *count = brush->GetPresetBlendCount();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialPresetBlend(
    GpRadialGradient *brush,
    ARGB *blend,
    REAL *blendPositions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    StackBuffer buffer;

    GpColor* gpcolors = (GpColor*) buffer.GetBuffer(count*sizeof(GpColor));
    
    if(!gpcolors) return OutOfMemory;

    if (gpcolors)
    {
        GpStatus status = brush->GetPresetBlend(gpcolors, blendPositions, count);

        for(INT i = 0; i < count; i++)
        {
            blend[i] = gpcolors[i].GetValue();
        }

        return status;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetRadialPresetBlend(
    GpRadialGradient *brush,
    ARGB *blend,
    REAL* blendPositions, INT count    )
{
    CheckParameter(blend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    StackBuffer buffer;

    GpColor* gpcolors = (GpColor*) buffer.GetBuffer(count*sizeof(GpColor));

    if(!gpcolors) return OutOfMemory;
    
    if (gpcolors)
    {
        for(INT i = 0; i < count; i++)
        {
            gpcolors[i].SetColor(blend[i]);
        }

        GpStatus status = brush->SetPresetBlend(gpcolors, blendPositions, count);

        return status;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetRadialSigmaBlend(
    GpRadialGradient *brush,
    REAL focus,
    REAL scale
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetSigmaBlend(focus, scale);
}

GpStatus
WINGDIPAPI
GdipSetRadialLinearBlend(
    GpRadialGradient *brush,
    REAL focus,
    REAL scale
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetLinearBlend(focus, scale);
}

GpStatus
WINGDIPAPI
GdipSetRadialWrapMode(
    GpRadialGradient *brush,
    GpWrapMode wrapmode
    )
{
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   brush->SetWrapMode(wrapmode);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialWrapMode(
    GpRadialGradient *brush,
    GpWrapMode *wrapmode
    )
{
   CheckParameter(wrapmode);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   *wrapmode = (GpWrapMode)brush->GetWrapMode();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetRadialTransform(
    GpRadialGradient *brush,
    GpMatrix *matrix
    )
{
   CheckParameterValid(brush);
   CheckObjectBusy(brush);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   brush->SetTransform(*matrix);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRadialTransform(
    GpRadialGradient *brush,
    GpMatrix *matrix
    )
{
   CheckParameterValid(brush);
   CheckObjectBusy(brush);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   brush->GetTransform(matrix);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateTriangleGradient(
    GpPointF* points,
    ARGB* colors,
    GpWrapMode wrapMode,
    GpTriangleGradient **trigrad
    )
{
    CheckParameter(points && trigrad && colors);

    GpColor gpcolor[3];

    gpcolor[0].SetColor(colors[0]);
    gpcolor[1].SetColor(colors[1]);
    gpcolor[2].SetColor(colors[2]);

    *trigrad = new GpTriangleGradient(points, gpcolor, wrapMode);

    if (CheckValid(*trigrad))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateTriangleGradientI(
    GpPoint* points,
    ARGB* colors,
    GpWrapMode wrapMode,
    GpTriangleGradient **trigrad
    )
{
    CheckParameter(points);

    GpPointF pointsF[3];

    pointsF[0].X = TOREAL(points[0].X);
    pointsF[0].Y = TOREAL(points[0].Y);
    pointsF[1].X = TOREAL(points[1].X);
    pointsF[1].Y = TOREAL(points[1].Y);
    pointsF[2].X = TOREAL(points[2].X);
    pointsF[2].Y = TOREAL(points[2].Y);

    return GdipCreateTriangleGradient(&pointsF[0], colors, wrapMode, trigrad);
}

GpStatus
GdipGetTriangleGradientColor(
    GpTriangleGradient *brush,
    ARGB* colors
    )
{
    CheckParameter(colors);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor gpcolor[3];

    brush->GetColors(gpcolor);

    colors[0] = gpcolor[0].GetValue();
    colors[1] = gpcolor[1].GetValue();
    colors[2] = gpcolor[2].GetValue();

    return Ok;
}

GpStatus
GdipSetTriangleGradientColor(
    GpTriangleGradient *brush,
    ARGB* colors
    )
{
    CheckParameter(colors);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor gpcolor[3];

    gpcolor[0].SetColor(colors[0]);
    gpcolor[1].SetColor(colors[1]);
    gpcolor[2].SetColor(colors[2]);

    brush->SetColors(gpcolor);

    return Ok;
}

GpStatus
GdipGetTriangleGradientTriangle(
    GpTriangleGradient *brush,
    GpPointF* points
    )
{
    CheckParameter(points);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->GetTriangle(points);

    return Ok;
}

GpStatus
GdipGetTriangleGradientTriangleI(
    GpTriangleGradient *brush,
    GpPoint* points
    )
{
    CheckParameter(points);

    GpPointF pointsF[3];

    GpStatus status = GdipGetTriangleGradientTriangle(brush, &pointsF[0]);

    if (status == Ok)
    {
        FPUStateSaver fpuState;

        points[0].X = GpRound(pointsF[0].X);
        points[0].Y = GpRound(pointsF[0].Y);
        points[1].X = GpRound(pointsF[1].X);
        points[1].Y = GpRound(pointsF[1].Y);
        points[2].X = GpRound(pointsF[2].X);
        points[2].Y = GpRound(pointsF[2].Y);
    }

    return status;
}

GpStatus
GdipSetTriangleGradientTriangle(
    GpTriangleGradient *brush,
    GpPointF* points
    )
{
    CheckParameter(points);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetTriangle(points);

    return Ok;
}

GpStatus
GdipSetTriangleGradientTriangleI(
    GpTriangleGradient *brush,
    GpPoint* points
    )
{
    CheckParameter(points);

    GpPointF pointsF[3];

    pointsF[0].X = TOREAL(points[0].X);
    pointsF[0].Y = TOREAL(points[0].Y);
    pointsF[1].X = TOREAL(points[1].X);
    pointsF[1].Y = TOREAL(points[1].Y);
    pointsF[2].X = TOREAL(points[2].X);
    pointsF[2].Y = TOREAL(points[2].Y);

    return GdipSetTriangleGradientTriangle(brush, &pointsF[0]);
}

GpStatus
GdipGetTriangleGradientRect(
    GpTriangleGradient *brush,
    GpRectF *rect
    )
{
    CheckParameter(rect);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->GetRect(*rect);

    return Ok;
}

GpStatus
GdipGetTriangleGradientRectI(
    GpTriangleGradient *brush,
    GpRect *rect
    )
{
    CheckParameter(rect);

    GpRectF rectf;

    GpStatus status = GdipGetTriangleGradientRect(brush, &rectf);

    if (status == Ok)
    {
        FPUStateSaver fpuState;

        rect->X = GpRound(rectf.X);
        rect->Y = GpRound(rectf.Y);
        rect->Width = GpRound(rectf.Width);
        rect->Height = GpRound(rectf.Height);
    }

    return status;
}

GpStatus
GdipGetTriangleGradientBlendCount0(
    GpTriangleGradient *brush,
    INT *count
    )
{
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetBlendCount0();

    return Ok;
}

GpStatus
GdipGetTriangleGradientBlend0(
    GpTriangleGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetBlend0(blend, positions, count);
}

GpStatus
GdipSetTriangleGradientBlend0(
    GpTriangleGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetBlend0(blend, positions, count);
}

GpStatus
GdipGetTriangleGradientBlendCount1(
    GpTriangleGradient *brush,
    INT *count
    )
{
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetBlendCount1();

    return Ok;
}

GpStatus
GdipGetTriangleGradientBlend1(
    GpTriangleGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetBlend1(blend, positions, count);
}

GpStatus
GdipSetTriangleGradientBlend1(
    GpTriangleGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetBlend1(blend, positions, count);
}

GpStatus
GdipGetTriangleGradientBlendCount2(
    GpTriangleGradient *brush,
    INT *count
    )
{
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetBlendCount2();

    return Ok;
}

GpStatus
GdipGetTriangleGradientBlend2(
    GpTriangleGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetBlend2(blend, positions, count);
}

GpStatus
GdipSetTriangleGradientBlend2(
    GpTriangleGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetBlend2(blend, positions, count);
}

GpStatus
GdipGetTriangleGradientWrapMode(
    GpTriangleGradient *brush,
    GpWrapMode *wrapmode
    )
{
    CheckParameter(wrapmode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *wrapmode = (GpWrapMode)brush->GetWrapMode();

    return Ok;
}

GpStatus
GdipSetTriangleGradientWrapMode(
    GpTriangleGradient *brush,
    GpWrapMode wrapmode
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetWrapMode(wrapmode);

    return Ok;
}

GpStatus
GdipGetTriangleGradientTransform(
    GpTriangleGradient *brush,
    GpMatrix *matrix
    )
{
   CheckParameterValid(brush);
   CheckObjectBusy(brush);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   brush->GetTransform(matrix);

   return Ok;
}

GpStatus
GdipSetTriangleGradientTransform(
    GpTriangleGradient *brush,
    GpMatrix *matrix
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    brush->SetTransform(*matrix);

    return Ok;
}

// For reference in V2

/**
 * Represent line texture objects
 */
class LineTexture
{
public:
    friend class Pen;

    /**
     * Create a new line texture object
     */
    // !! Take Image* instead?
    LineTexture(const Bitmap* bitmap, 
                REAL length)
    {
        GpLineTexture *lineTexture = NULL;

        lastResult = DllExports::GdipCreateLineTexture((GpBitmap*)
                                                          bitmap->nativeImage,
                                                          length,
                                                          0,
                                                          &lineTexture);
        SetNativeLineTexture(lineTexture);
    }

    LineTexture(const Bitmap* bitmap, 
                REAL length, 
                REAL offset)
    {
        GpLineTexture *lineTexture = NULL;
        
        lastResult = DllExports::GdipCreateLineTexture((GpBitmap*)
                                                          bitmap->nativeImage,
                                                          length,
                                                          offset,
                                                          &lineTexture);
        SetNativeLineTexture(lineTexture);
    }

    LineTexture* Clone() const
    {
        GpLineTexture *cloneLineTexture = NULL;

        SetStatus(DllExports::GdipCloneLineTexture(nativeLineTexture,
                                                         &cloneLineTexture));

        return new LineTexture(cloneLineTexture, lastResult);
    }

    /**
     * Dispose of resources associated with the line texture
     */
    ~LineTexture()
    {
        DllExports::GdipDeleteLineTexture(nativeLineTexture);
    }

    /**
     * Get line texture attributes
     */
    Bitmap* GetBitmap() const
    {
        SetStatus(NotImplemented);

        return NULL;
    }

    REAL GetLength() const
    {
        REAL len = 0;

        SetStatus(DllExports::GdipGetLineTextureLength(nativeLineTexture,
                                                         &len));
        return len;
    }

    REAL GetOffset() const
    {
        REAL offset = 0;

        SetStatus(DllExports::GdipGetLineTextureOffset(nativeLineTexture, 
                                                         &offset));
        return offset;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:
    LineTexture(GpLineTexture* lineTexture, Status status)
    {
        lastResult = status;
        SetNativeLineTexture(lineTexture);
    }

    VOID SetNativeLineTexture(GpLineTexture *lineTexture)
    {
        nativeLineTexture = lineTexture;
    }
    
    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

private:
    /*
     * handle to native line texture object
     */

    GpLineTexture* nativeLineTexture;
    mutable Status lastResult;
};

//--------------------------------------------------------------------------
// Represent triangular gradient brush object
//--------------------------------------------------------------------------

class TriangleGradientBrush : public Brush
{
public:
    friend class Pen;

    // Constructors

    TriangleGradientBrush(
                         const PointF* points,
                         const Color* colors,
                         WrapMode wrapMode = WrapModeClamp)
    {
        ARGB argb[3];

        argb[0] = colors[0].GetValue();
        argb[1] = colors[1].GetValue();
        argb[2] = colors[2].GetValue();

        GpTriangleGradient *brush = NULL;

        lastResult = DllExports::GdipCreateTriangleGradient(
                                                           points, argb, 
                                                           wrapMode, &brush);
        SetNativeBrush(brush);
    }

    TriangleGradientBrush(
                         const Point* points,
                         const Color* colors,
                         WrapMode wrapMode = WrapModeClamp)
    {
        ARGB argb[3];

        argb[0] = colors[0].GetValue();
        argb[1] = colors[1].GetValue();
        argb[2] = colors[2].GetValue();

        GpTriangleGradient *brush = NULL;

        lastResult = DllExports::GdipCreateTriangleGradientI(
                                                            points, argb, 
                                                            wrapMode, &brush);
        SetNativeBrush(brush);
    }

    // Get/set colors

    Status GetColors(Color colors[]) const
    {
        ARGB argb[3];

        SetStatus(DllExports::GdipGetTriangleGradientColor(
                                                          (GpTriangleGradient*) nativeBrush, argb));

        if (lastResult == Ok)
        {
            // use bitwise copy operator for Color copy
            colors[0] = Color(argb[0]);
            colors[1] = Color(argb[1]);
            colors[2] = Color(argb[2]);
        }

        return lastResult;
    }

    Status SetColors(Color colors[])
    {
        ARGB argb[3];

        argb[0] = colors[0].GetValue();
        argb[1] = colors[1].GetValue();
        argb[2] = colors[2].GetValue();

        return SetStatus(DllExports::GdipSetTriangleGradientColor(
                                                                 (GpTriangleGradient*)nativeBrush, argb));
    }

    // Get/set triangle

    Status GetTriangle(PointF* points) const
    {
        return SetStatus(DllExports::GdipGetTriangleGradientTriangle(
                                                                    (GpTriangleGradient*)nativeBrush, points));
    }

    Status GetTriangle(Point* points) const
    {
        return SetStatus(DllExports::GdipGetTriangleGradientTriangleI(
                                                                     (GpTriangleGradient*)nativeBrush, points));
    }

    Status SetTriangle(PointF* points)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientTriangle(
                                                                    (GpTriangleGradient*)nativeBrush, points));
    }

    Status SetTriangle(Point* points)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientTriangleI(
                                                                     (GpTriangleGradient*)nativeBrush, points));
    }

    Status GetRectangle(RectF& rect) const
    {
        return SetStatus(DllExports::GdipGetTriangleGradientRect(
                                                                (GpTriangleGradient*)nativeBrush, &rect));
    }

    Status GetRectangle(Rect& rect) const
    {
        return SetStatus(DllExports::GdipGetTriangleGradientRectI(
                                                                 (GpTriangleGradient*)nativeBrush, &rect));
    }

    // Get/set blend factors
    //
    // If the blendFactors.length = 1, then it's treated
    // as the falloff parameter. Otherwise, it's the array
    // of blend factors.

    // NOTE: Differing semantics from COM+ version where we return
    // an array containing the implicit length value.

    INT GetBlendCount0() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetTriangleGradientBlendCount0(
                                                                (GpTriangleGradient*) nativeBrush, &count));

        return count;
    }

    Status GetBlend0(REAL** blendFactors, REAL** blendPositions, INT count) const
    {
        if (!blendFactors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);

        *blendFactors = new REAL[count];
        *blendPositions = new REAL[count];

        if (!*blendFactors || !*blendPositions)
        {
            if (*blendFactors)
                delete[] *blendFactors;
            if (*blendPositions)
                delete[] *blendPositions;
            
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetTriangleGradientBlend0(
                                                                  (GpTriangleGradient*)nativeBrush,
                                                                  *blendFactors, *blendPositions, count));

        if (status != Ok) 
        {
            delete[] *blendFactors;
            *blendFactors = NULL;
            delete[] *blendPositions;
            *blendPositions = NULL;
        }

        return status;
    }

    Status SetBlend0(REAL* blendFactors, REAL* blendPositions, INT count)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientBlend0(
                                                                  (GpTriangleGradient*)nativeBrush,
                                                                  blendFactors, blendPositions, count));
    }

    INT GetBlendCount1() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetTriangleGradientBlendCount1(
                                                                (GpTriangleGradient*) nativeBrush, &count));

        return count;
    }

    Status GetBlend1(REAL** blendFactors, REAL** blendPositions, INT count) const 
    {
        if (!blendFactors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);

        *blendFactors = new REAL[count];
        *blendPositions = new REAL[count];

        if (!*blendFactors || !*blendPositions)
        {
            if (*blendFactors)
                delete[] *blendFactors;
            if (*blendPositions)
                delete[] *blendPositions;

            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetTriangleGradientBlend1(
                                                                  (GpTriangleGradient*)nativeBrush,
                                                                  *blendFactors, *blendPositions, count));
        if (status != Ok) 
        {
            delete[] *blendFactors;
            *blendFactors = NULL;
            delete[] *blendPositions;
            *blendPositions = NULL;
        }
    
        return status;
    }

    Status SetBlend1(REAL* blendFactors, REAL* blendPositions, INT count)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientBlend1(
                                                                  (GpTriangleGradient*)nativeBrush,
                                                                  blendFactors, blendPositions, count));
    }

    INT GetBlendCount2() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetTriangleGradientBlendCount2(
                                                                (GpTriangleGradient*) nativeBrush, &count));

        return count;
    }

    Status GetBlend2(REAL** blendFactors, REAL** blendPositions, INT count) const
    {
        if (!blendFactors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);

        *blendFactors = new REAL[count];
        *blendPositions = new REAL[count];

        if (!*blendFactors || !*blendPositions)
        {
            if (*blendFactors)
                delete[] *blendFactors;
            if (*blendPositions)
                delete[] *blendPositions;
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetTriangleGradientBlend2(
                                                                  (GpTriangleGradient*)nativeBrush,
                                                                  *blendFactors, *blendPositions, count));
    
        if (status != Ok) 
        {
            delete[] *blendFactors;
            *blendFactors = NULL;
            delete[] *blendPositions;
            *blendPositions = NULL;
        }

        return status;
    }

    Status SetBlend2(REAL* blendFactors, REAL* blendPositions, INT count)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientBlend2(
                                                                  (GpTriangleGradient*)nativeBrush,
                                                                  blendFactors, blendPositions, count));
    }

    // Check the opacity of this brush element.

    /**
     * Get/set brush transform
     */
    Status GetTransform(Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetTriangleGradientTransform(
                                                                     (GpTriangleGradient*) nativeBrush, matrix->nativeMatrix));
    }

    Status SetTransform(const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientTransform(
                                                                     (GpTriangleGradient*) nativeBrush, matrix->nativeMatrix));
    }


    /**
     * Get/set brush wrapping mode
     */
    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetTriangleGradientWrapMode(
                                                             (GpTriangleGradient*) nativeBrush, &wrapMode));

        return wrapMode;
    }

    Status SetWrapMode(WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetTriangleGradientWrapMode(
                                                                    (GpTriangleGradient*) nativeBrush, wrapMode));
    }

protected:

    TriangleGradientBrush()
    {
    }
};

//--------------------------------------------------------------------------
// Represent rectangular gradient brush object
//--------------------------------------------------------------------------
class RectangleGradientBrush : public Brush
{
public:
    friend class Pen;

    // Constructors

    RectangleGradientBrush(const RectF& rect, 
                           const Color* colors,
                           WrapMode wrapMode = WrapModeTile)
    {
        ARGB argb[4];

        argb[0] = colors[0].GetValue();
        argb[1] = colors[1].GetValue();
        argb[2] = colors[2].GetValue();
        argb[3] = colors[3].GetValue();

        GpRectGradient *brush = NULL;

        lastResult = DllExports::GdipCreateRectGradient(rect.X, 
                                                        rect.Y,
                                                        rect.Width,
                                                        rect.Height,
                                                        argb, 
                                                        wrapMode, 
                                                        &brush);
        SetNativeBrush(brush);
    }

    // integer version
    RectangleGradientBrush(const Rect& rect, 
                           const Color* colors,
                           WrapMode wrapMode = WrapModeTile)
    {
        ARGB argb[4];

        argb[0] = colors[0].GetValue();
        argb[1] = colors[1].GetValue();
        argb[2] = colors[2].GetValue();
        argb[3] = colors[3].GetValue();

        GpRectGradient *brush = NULL;

        lastResult = DllExports::GdipCreateRectGradientI(rect.X, 
                                                         rect.Y,
                                                         rect.Width,
                                                         rect.Height,
                                                         argb, 
                                                         wrapMode, 
                                                         &brush);
        SetNativeBrush(brush);
    }

    // Get/set colors

    Status SetColors(const Color colors[])
    {
        ARGB argb[4];

        argb[0] = colors[0].GetValue();
        argb[1] = colors[1].GetValue();
        argb[2] = colors[2].GetValue();
        argb[3] = colors[3].GetValue();

        return SetStatus(DllExports::GdipSetRectGradientColor(
                                                             (GpRectGradient*)nativeBrush,
                                                             argb));
    }

    Status GetColors(Color colors[]) const
    {
        ARGB argb[4];

        SetStatus(DllExports::GdipGetRectGradientColor((GpRectGradient*)
                                                       nativeBrush, 
                                                       argb));

        if (lastResult == Ok)
        {
            // use bitwise copy operator for Color copy
            colors[0] = Color(argb[0]);
            colors[1] = Color(argb[1]);
            colors[2] = Color(argb[2]);
            colors[3] = Color(argb[3]);
        }

        return lastResult;
    }


    Status GetRectangle(RectF& rect) const
    {
        return SetStatus(DllExports::GdipGetRectGradientRect((GpRectGradient*)nativeBrush,
                                                             &rect));
    }

    Status GetRectangle(Rect& rect) const
    {
        return SetStatus(DllExports::GdipGetRectGradientRectI((GpRectGradient*)nativeBrush,
                                                              &rect));
    }

    // Get/set blend factors
    //
    // If the blendFactors.length = 1, then it's treated
    // as the falloff parameter. Otherwise, it's the array
    // of blend factors.

    // NOTE: Differing semantics from COM+ version where we return
    // an array containing the implicit length value.

    INT GetHorizontalBlendCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetRectGradientBlendCountH((GpRectGradient*)
                                                             nativeBrush,
                                                             &count));
        return count;
    }

    Status GetHorizontalBlend(REAL** blendFactors, REAL** blendPositions, INT count) const
    {
        if (!blendFactors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);

        *blendFactors = new REAL[count];
        *blendPositions = new REAL[count];

        if (!*blendFactors || !*blendPositions)
        {
            if (*blendFactors)
                delete *blendFactors;
            if (*blendPositions)
                delete *blendPositions;
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetRectGradientBlendH((GpRectGradient*)nativeBrush,
                                                               *blendFactors, *blendPositions, count));
    
        if (status != Ok) 
        {
            delete[] *blendFactors;
            *blendFactors = NULL;
            delete[] *blendPositions;
            *blendPositions = NULL;
        }

        return status;
    }

    Status SetHorizontalBlend(const REAL* blendFactors, const REAL* blendPositions, INT count)
    {
        return SetStatus(DllExports::GdipSetRectGradientBlendH((GpRectGradient*)nativeBrush,
                                                               blendFactors, blendPositions, count));
    }

    INT GetVerticalBlendCount() const 
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetRectGradientBlendCountV((GpRectGradient*)
                                                             nativeBrush,
                                                             &count));
        return count;
    }

    Status GetVerticalBlend(REAL** blendFactors, REAL** blendPositions, INT count) const
    {
        if (!blendFactors || !blendPositions || count <= 0)
            return SetStatus(OutOfMemory);

        *blendFactors = new REAL[count];
        *blendPositions = new REAL[count];

        if (!*blendFactors || !*blendPositions)
        {
            if (*blendFactors)
                delete[] *blendFactors;
            if (*blendPositions)
                delete[] *blendPositions;
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetRectGradientBlendV((GpRectGradient*)nativeBrush,
                                                               *blendFactors, *blendPositions, count));
    
        if (status != Ok) 
        {
            delete[] *blendFactors;
            *blendFactors = NULL;
            delete[] *blendPositions;
            *blendPositions = NULL;
        }

        return status;
    }

    Status SetVerticalBlend(const REAL* blendFactors, const REAL* blendPositions, INT count)
    {
        return SetStatus(DllExports::GdipSetRectGradientBlendV((GpRectGradient*)nativeBrush,
                                                               blendFactors, blendPositions, count));
    }

    // Check the opacity of this brush element.

    /**
     * Set/get brush transform
     */
    Status SetTransform(const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetRectGradientTransform((GpRectGradient*)
                                                                  nativeBrush, 
                                                                  matrix->nativeMatrix));
    }

    Status GetTransform(Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetRectGradientTransform((GpRectGradient*)
                                                                  nativeBrush, 
                                                                  matrix->nativeMatrix));
    }

    /**
     * Set/get brush wrapping mode
     */
    Status SetWrapMode(WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetRectGradientWrapMode((GpRectGradient*)
                                                                 nativeBrush, 
                                                                 wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetRectGradientWrapMode((GpRectGradient*)
                                                          nativeBrush, 
                                                          &wrapMode));

        return wrapMode;
    }

protected:

    RectangleGradientBrush()
    {
    }
};

class RadialGradientBrush : public Brush
{
public:
    friend class Pen;

    RadialGradientBrush(
                       const RectF& rect,
                       const Color& centerColor,
                       const Color& boundaryColor,
                       WrapMode wrapMode = WrapModeClamp
                       )
    {
        GpRadialGradient *brush = NULL;

        lastResult = DllExports::GdipCreateRadialBrush(&rect, 
                                                       centerColor.GetValue(),
                                                       boundaryColor.GetValue(),
                                                       wrapMode, &brush);

        SetNativeBrush(brush);
    }

    RadialGradientBrush(
                       const Rect& rect,
                       const Color& centerColor,
                       const Color& boundaryColor,
                       WrapMode wrapMode = WrapModeClamp
                       )
    {
        GpRadialGradient *brush = NULL;

        lastResult = DllExports::GdipCreateRadialBrushI(&rect, 
                                                        centerColor.GetValue(),
                                                        boundaryColor.GetValue(),
                                                        wrapMode, &brush);

        SetNativeBrush(brush);
    }
    // Get/set color attributes

    Status SetCenterColor(const Color& color)
    {
        return SetStatus(DllExports::GdipSetRadialCenterColor((GpRadialGradient*)nativeBrush,
                                                              color.GetValue()));
    }

    Status SetBoundaryColor(const Color& color)
    {
        return SetStatus(DllExports::GdipSetRadialBoundaryColor((GpRadialGradient*)nativeBrush, 
                                                                color.GetValue()));
    }

    Status GetCenterColor(Color& centerColor)
    {
        ARGB argb;

        SetStatus(DllExports::GdipGetRadialCenterColor((GpRadialGradient*)
                                                       nativeBrush, &argb));

        centerColor = Color(argb);

        return lastResult;
    }

    Status GetBoundaryColor(Color& boundaryColor)
    {
        ARGB argb = 0;

        SetStatus(DllExports::GdipGetRadialBoundaryColor((GpRadialGradient*)
                                                         nativeBrush, &argb));

        boundaryColor = Color(argb);

        return lastResult;
    }

    Status GetRectangle(RectF& rect) const
    {
        return SetStatus(DllExports::GdipGetRadialRect(
                                                      (GpRadialGradient*)nativeBrush, &rect));
    }

    Status GetRectangle(Rect& rect) const
    {
        return SetStatus(DllExports::GdipGetRadialRectI(
                                                       (GpRadialGradient*)nativeBrush, &rect));
    }

    // !!!  This diverges from COM+ implemention in that we give 
    // them all blend values instead of upto 'count' of them.

    Status SetBlend(const REAL* blendFactors, const REAL* blendPositions, INT count)
    {
        return SetStatus(DllExports::GdipSetRadialBlend((GpRadialGradient*)
                                                        nativeBrush,
                                                        blendFactors,
                                                        blendPositions,
                                                        count));
    }

    INT GetBlendCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetRadialBlendCount((GpRadialGradient*)
                                                      nativeBrush,
                                                      &count));

        return count;
    }

    Status GetBlend(REAL** blendFactors, REAL** blendPositions, INT count) const 
    {
        if (!blendFactors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);
        
        *blendFactors = new REAL[count];
        *blendPositions = new REAL[count];

        if (!*blendFactors || !*blendPositions)
        {
            if (*blendFactors)
                delete[] *blendFactors;
            if (*blendPositions)
                delete[] *blendPositions;
            
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetRadialBlend((GpRadialGradient*)nativeBrush,
                                                                 *blendFactors,
                                                                 *blendPositions,
                                                                 count));
        if (status != Ok)
        {
            delete[] *blendFactors;
            *blendFactors = NULL;
            delete[] *blendPositions;
            *blendPositions = NULL;
        }
    
        return status;
    }

    INT GetPresetBlendCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetRadialPresetBlendCount((GpRadialGradient*)
                                                            nativeBrush,
                                                            &count));

        return count;
    }

    Status SetPresetBlend(const Color* presetColors,
                          const REAL* blendPositions, INT count)
    {
        if (!presetColors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);
        
        ARGB* argbs = (ARGB*) malloc(count*sizeof(ARGB));
        
        if (argbs)
        {
            for (INT i = 0; i < count; i++)
            {
                argbs[i] = presetColors[i].GetValue();
            }

            Status status = SetStatus(DllExports::GdipSetRadialPresetBlend(
                                                                          (GpRadialGradient*) nativeBrush,
                                                                          argbs,
                                                                          blendPositions,
                                                                          count));
            free(argbs);
            return status;
        } 
        else
        {
            return SetStatus(OutOfMemory);
        }
    }

    Status GetPresetBlend(Color** presetColors, REAL** blendPositions, INT count) const 
    {
        if (!presetColors || !blendPositions || count <= 0)
            return SetStatus(InvalidParameter);

        *presetColors = new Color[count];
        *blendPositions = new REAL[count];
        
        ARGB* argbs = (ARGB*) malloc(count*sizeof(ARGB));

        if (!*presetColors || !*blendPositions || !argbs)
        {
            if (*presetColors)
                delete[] *presetColors;
            if (*blendPositions)
                delete[] *blendPositions;
            free(argbs);

            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetRadialPresetBlend(
                                                                        (GpRadialGradient*)nativeBrush,
                                                                        argbs,
                                                                        *blendPositions,
                                                                        count));
        if (status == Ok) 
        {
           for (INT i = 0; i < count; i++)
           {
              *presetColors[i] = Color(argbs[i]);
           }
        }
        else
        {
           delete[] *presetColors;
           *presetColors = NULL;
           delete[] *blendPositions;
           *blendPositions = NULL;
        }

        free(argbs);

        return status;
    }

    Status SetSigmaBlend(REAL focus, REAL scale = 1.0)
    {
        return SetStatus(DllExports::GdipSetRadialSigmaBlend(
                                                            (GpRadialGradient*)nativeBrush, focus, scale));
    }

    Status SetLinearBlend(REAL focus, REAL scale = 1.0)
    {
        return SetStatus(DllExports::GdipSetRadialLinearBlend(
                                                             (GpRadialGradient*)nativeBrush, focus, scale));
    }

    /**
     * Set/get brush transform
     */
    Status SetTransform(const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetRadialTransform((GpRadialGradient*)nativeBrush, 
                                                            matrix->nativeMatrix));
    }

    Status GetTransform(Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetRadialTransform((GpRadialGradient*)nativeBrush, 
                                                            matrix->nativeMatrix));
    }

    /**
     * Set/get brush wrapping mode
     */
    Status SetWrapMode(WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetRadialWrapMode((GpRadialGradient*)nativeBrush, 
                                                           wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetRadialWrapMode((GpRadialGradient*)
                                                    nativeBrush, 
                                                    &wrapMode));

        return wrapMode;
    }

protected:

    RadialGradientBrush()
    {
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\mem.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   GDI+ memory allocation functions
*
* Abstract:
*
*   This module provides GpMalloc, GpRealloc and GpFree.
*
* Notes:
*
*   Office provides their own versions of these functions.
*
* Created:
*
*   07/08/1999 agodfrey
*
\**************************************************************************/

#include "precomp.hpp"

namespace GpRuntime
{
HANDLE GpMemHeap = NULL;
};

#if GPMEM_ALLOC_CHK

#if GPMEM_FAULT_INJECTION
#include <time.h>
#include <stdlib.h>
#endif

// Get the definition of Globals::CaptureStackBackTraceFunction

#include "..\common\common.hpp"

                  
// Size of the start and end memory guards (DWORDS)
// Probably should be QWORD aligned (even number).

const unsigned int GPMEM_GUARD_START = 0x10;
const unsigned int GPMEM_GUARD_END   = 0x10;
const unsigned int GPMEM_GS = GPMEM_GUARD_START*sizeof(DWORD);
const unsigned int GPMEM_GE = GPMEM_GUARD_END*sizeof(DWORD);

const unsigned char GPMEM_FILL_ALLOC = 0xbf;
const unsigned char GPMEM_FILL_GS    = 0xac;
const unsigned char GPMEM_FILL_GE    = 0xfe;
const unsigned char GPMEM_FILL_FREE  = 0x73;

#define GPMEM_ALLOC_TRACKING 1
#define GPMEM_ALLOC_FILL     1

enum AllocTrackHeaderFlags
{
    MemoryAllocated     = 0x00000001,
    MemoryFreed         = 0x00000002,     // useful in catching double frees
    APIAllocation       = 0x00000004
};
// Head of every tracked allocation.


// From <ntrtl.h> - 
// #define MAX_STACK_DEPTH 32                  
// Therefore we define our stack trace size to be 32 entries.
// Number of Stack Frames stash away on every allocation.

// Bear in mind that every allocation will have 4xGPMEM_STACKSIZE bytes 
// additional overhead. (8xGPMEM_STACKSIZE on ptr64 machines)

#define GPMEM_STACKSIZE 32


struct AllocTrackHeader {
  struct  AllocTrackHeader *flink;
  struct  AllocTrackHeader *blink;
  DWORD   size;
  PVOID   caller_address[GPMEM_STACKSIZE];
  DWORD   flags;
#if GPMEM_ALLOC_CHK_LIST
  char    *callerFileName;
  INT     callerLineNumber;
#endif
  DWORD   tag;
  DWORD   padding;       // padding to keep 8 byte alignment
};

#define GPMEM_OVERHEAD (GPMEM_GS + GPMEM_GE + sizeof(AllocTrackHeader))

// Head of double linked list of tracked memory allocations.

AllocTrackHeader *gpmemAllocList=NULL;

// An allocation fails if rand() < gpmemDefFailRate (gpmemInitFailRate for
// gdiplus initialization code.
// set to RAND_MAX/2 if you want 50% failure rate, 0 if you want no failures.
//
// The system starts off failing allocations at a rate specified by
// gpmemInitFailRate. Once GpDoneInitializeAllocFailureMode() is called,
// allocations are failed at the rate specified by gpmemDefFailRate().
// This is so that dll initialization code can have a different fail rate
// to regular code.

int gpmemInitFailRate = 0;
int gpmemDefFailRate = 0;

// This would give a failure rate of 25%
// int gpmemDefFailRate = (RAND_MAX/4)

BOOL gpmemDoneInitialization = FALSE;

// Some statistics
struct AllocTrackStats {
  // Totals over the entire run

  long CumulativeAllocations;   // The number of calls to GpMalloc or GpRealloc
  long CumulativeMemorySize;    // Cumulative total of allocated memory
  long CumulativeReallocs;      // The number of calls to GpRealloc
  long ForcedFailures;
  long AllocationFailures;

  // Current values

  long OutstandingAllocations;  // The number of allocation requests
  long OutstandingMemorySize;   // The amount of memory currently allocated

  // Maxima of the 'Outstanding' values

  long MaxAllocations;          // The maximum of OutstandingAllocations
  long MaxMemorySize;           // The maximum of OutstandingMemorySize

  void Allocated(long size)
  {
      size -= GPMEM_OVERHEAD;

      CumulativeMemorySize += size;
      OutstandingMemorySize += size;
      if (OutstandingMemorySize > MaxMemorySize)
      {
          MaxMemorySize = OutstandingMemorySize;
      }
      CumulativeAllocations++;
      OutstandingAllocations++;
      if (OutstandingAllocations > MaxAllocations)
      {
          MaxAllocations = OutstandingAllocations;
      }
  }

  void Freed(long size)
  {
      size -= GPMEM_OVERHEAD;

      OutstandingMemorySize -= size;
      OutstandingAllocations--;
  }
};

AllocTrackStats gpmemAllocTotal = {0};


// Hash Table for tracking memory allocations sorted by callsite.
// This table stores some total memory usage statistics for each
// callsite.
// Turn this on by setting GPMEM_DEBUG_SORT 1

#define GPMEM_DEBUG_SORT 0
#if GPMEM_DEBUG_SORT

struct HashMem {
  long callsite;
  long size;
  long count;
};

// It is very important that this hash size be larger than the number of
// possible callsites for GpMalloc.
//
// Set HASHSIZE to some big prime number.

#define HASHSIZE 1069
HashMem HashTable[HASHSIZE];

// Hashing algorithm.
long Hash(long cs) {
  long tmp = cs % HASHSIZE;
  long tmploop = tmp;
  while( (HashTable[tmp].callsite != 0) &&
         (HashTable[tmp].callsite != cs) ) {
    tmp++;
    if(tmp>=HASHSIZE) tmp=0;
    if(tmp==tmploop) return -1;
  }
  return tmp;
}
#endif

#endif



/**************************************************************************\
*
* Function Description:
*
*   Do we fail this memory allocation?
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/20/1999 asecchia
*       Created it.
*
\**************************************************************************/


#if GPMEM_ALLOC_CHK
BOOL GpFailMemoryAllocation() {
  #if GPMEM_FAULT_INJECTION
  int rndnum = rand();
  if(gpmemDoneInitialization)
  {
      if(rndnum<gpmemDefFailRate)
      {
          return TRUE;
      }
  }
  else
  {
    if(rndnum<gpmemInitFailRate)
    {
        return TRUE;
    }
  }
  #endif
  return FALSE;
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Initializes the random seed.
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/20/1999 asecchia
*       Created it.
*
\**************************************************************************/

void GpInitializeAllocFailures() {
  #if GPMEM_ALLOC_CHK
  #if GPMEM_FAULT_INJECTION
  srand((unsigned)time(NULL));
  #endif
  #endif
}


/**************************************************************************\
*
* Function Description:
*
*   Sets the flag indicating that we're done initialization code and
*   we're now into regular code. The memory failure mode changes based
*   on the value of this flag.
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/20/1999 asecchia
*       Created it.
*
\**************************************************************************/

void GpDoneInitializeAllocFailureMode() {
  #if GPMEM_ALLOC_CHK
  gpmemDoneInitialization=TRUE;
  #endif
}

void GpStartInitializeAllocFailureMode() {
  #if GPMEM_ALLOC_CHK
  gpmemDoneInitialization=FALSE;
  #endif
}


#if GPMEM_ALLOC_CHK_LIST
char *skipGdiPlus(char *s) {
    // Quick hack to return pointer just beyond 'gdiplus'

    INT i = 0;
    while (    s[i] != 0
           &&  (    s[i] != 'g' &&  s[i] != 'G'
                ||  CompareStringA(
                        LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                        s+i, 7,
                        "gdiplus", 7) != CSTR_EQUAL))
    {
        i++;
    }
    if (    CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, s+i, 7, "gdiplus", 7) == CSTR_EQUAL
        &&  s[i+7] != 0)
    {
        return s + i + 8;   // Skip over 'gdiplus/'
    }
    else
    {
        return s; // Didn't find gdiplus so return the whole string
    }
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Asserts that there are no memory leaks. Called just before process
*   termination, the list of allocated memory blocks should be NULL indicating
*   that all allocated memory was properly disposed. Any memory that relies on
*   process termination to clean up is leaked and provision should be made
*   for appropriate cleanup.
*
* Notes:
*
*   Designed only to be called during shutdown, because it doesn't acquire
*   GpMallocTrackingCriticalSection. 
*
*   This is because, during shutdown, the critsec has not necessarily been
*   initialized. It's safe during shutdown because shutdown itself is
*   expected to be single-threaded.
*
* Todo after we ship:
*
*   NTRAID#NTBUG9-411495-2001/06/06-agodfrey
*   The refcount is legacy anyway, and the "single-threaded shutdown" thing
*   may need to be changed. We should initialize all our global critsecs
*   in DllMain, so that we can rely on them during startup/shutdown.
*
*   Once we've done that, this function can have the "shutdown only"
*   restriction removed - by making it once again acquire 
*   GpMallocTrackingCriticalSection.
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/19/1999 asecchia
*       Created it.
*
\**************************************************************************/

void GpAssertShutdownNoMemoryLeaks()
{
  #if GPMEM_ALLOC_CHK


  #if GPMEM_ALLOC_CHK_LIST

  // Report up to 100 leaked headers

  if (gpmemAllocList)
  {
      INT i=0; INT j=0;
      AllocTrackHeader *header = gpmemAllocList;
      while (header  && j < 100)
      {
          if (i % 20 == 0)  // Title every so often
          {
              WARNING(("Address- --Size-- API TAG  -Caller- -Line- File"));
          }

          // Drop everything up to 'gdiplus' off the filename string

          char  str[200];
          char *tagStr;

          tagStr = (char *) &header->tag;

          lstrcpynA(str, skipGdiPlus(header->callerFileName), 200);

          WARNING((
              "%p %8d %-3.3s %c%c%c%c %p %6d %s",
              header,
              header->size,
              header->flags & APIAllocation ? "API" : "",
              tagStr[3], tagStr[2], tagStr[1], tagStr[0],
              header->caller_address,
              header->callerLineNumber,
              str
          ));
          header = header->flink;

          i++; j++;
      }
  }
  #endif


  ASSERTMSG(
      gpmemAllocList==NULL,
      ("Memory leaks detected.\n"
       "List header (gdiplus!gpmemAllocList) at %p\n"
       "Use: dt AllocTrackHeader [address] to display the memory block headers.\n"
       "Use: dds [AllocTrackHeader.caller_address] to display the allocation stack.",
      gpmemAllocList)
  );


  // Display the report stored in the Hash Table
  #if GPMEM_DEBUG_SORT
  for(int i=0; i<HASHSIZE; i++) {
    if(HashTable[i].callsite != 0) {
      WARNING(("%4d callsite %p size %8d count %8d", i, HashTable[i].callsite,
               HashTable[i].size, HashTable[i].count));
    }
  }
  #endif

  #endif
}

#if GPMEM_ALLOC_CHK_LIST
void
GpTagMalloc(void * mem, GpTag tag, int bApi)
{
    if(mem)
    {
        AllocTrackHeader *hdr = (AllocTrackHeader *)((char *) mem - sizeof(AllocTrackHeader) - GPMEM_GS);
        hdr->tag = (unsigned long) tag;
        if(bApi) hdr->flags |= APIAllocation;
    }
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Allocates a block of memory.
*
* Arguments:
*
*   [IN] size - number of bytes to allocate
*
* Return Value:
*
*   A pointer to the new block, or NULL on failure.
*
* History:
*
*   09/14/1999 asecchia
*       Added the checked build memory guard code.
*   07/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

/*
Here's the structure of the memory block allocated under GPMEM_ALLOC_CHK

|+AllocTrackHeader Two DWORDS - contains
|  |+flink
|  |  Pointer to the next memory allocation in the tracked allocation list
|  |+blink
|  |  Pointer to the previous memory allocation in the tracked allocation link
|
|+Guard Area
|  GPMEM_GUARD_START DWORDs filled with the gpmemGuardFill string.
|
|+Data Area
|  This is the location we return to the caller. It is pre-initialized to
|  the repeated DWORD value in gpmemAllocFillBlock (usually 0xbaadf00d)
|
|+Guard Area:
|  GPMEM_GUARD_END DWORDs filled with gpmemGuardFill string.

*/
#if GPMEM_ALLOC_CHK_LIST
extern "C" void *GpMallocDebug(size_t size, char *fileName, INT lineNumber)
#else
extern "C" void *GpMalloc(size_t size)
#endif
{
    // on checked builds we add headers to the allocation and hence, really
    // large requests will overflow 32bits and succeed a really small 
    // allocation. 
    // Also allocations of 2-4Gb usually indicate a sign extension problem in 
    // the caller when the size is computed. Note that size_t is UNSIGNED.
    // Instead of simply checking the high bit with an &, we check to see that
    // the size is < 0x7fffffff so that the check works on IA64 too - IA64
    // size_t is 64bit. Note that allocations of this size will fail in the
    // heap manager anyway. The caller should be using VirtualAlloc for stuff
    // that's really this big.
    
    ASSERT(size < 0x7fffffff);

    #if GPMEM_ALLOC_CHK
        // If we're playing with the tracking headers, we need to be thread safe.
        GpMallocTrackingCriticalSection critsecobj;

        //
        // Memory? _Real_ programmers don't need memory!
        //
        if(GpFailMemoryAllocation()) {
            gpmemAllocTotal.AllocationFailures++;
            gpmemAllocTotal.ForcedFailures++;
            return NULL;
        }

        //
        // Make the allocation request a multiple of a QWORD
        //
        if(size & (sizeof(DWORD)*2-1))
        {
          size = (size & ~(sizeof(DWORD)*2-1)) + sizeof(DWORD)*2;
        }

        size_t origsize = size;

        //
        // Allocate space for the FLink and BLink
        //
        size += sizeof(AllocTrackHeader);

        if(GPMEM_GUARD_START)
        {
          size += GPMEM_GS;
        }

        if(GPMEM_GUARD_END)
        {
          size += GPMEM_GE;
        }

        void *tmpalloc = HeapAlloc(GpMemHeap, GPMEMHEAPFLAGS, size);

        if(!tmpalloc)
        {
            gpmemAllocTotal.AllocationFailures++;
            return NULL;
        }

        ASSERTMSG(HeapSize(GpMemHeap, GPMEMHEAPFLAGS, tmpalloc) >= size,
                  ("GpMalloc() allocated %d, but requested %d bytes",
                   HeapSize(GpMemHeap, GPMEMHEAPFLAGS, tmpalloc), size));

        // Add the per-callsite allocation statistics
        #if GPMEM_DEBUG_SORT
        long hidx = Hash(calleraddr);
        if(hidx>=0) {
            HashTable[hidx].callsite = calleraddr;
            HashTable[hidx].size += size-GPMEM_OVERHEAD;
            HashTable[hidx].count ++;
        } else {
          WARNING(("Hash Table too small - increase HASHSIZE"));
        }
        #endif

        gpmemAllocTotal.Allocated(size);
    #else
        //
        // This is the only piece of code that's executed if
        // GPMEM_ALLOC_CHK is turned off.
        //
        
        #if PROFILE_MEMORY_USAGE
        MC_LogAllocation(size);
        #endif
        
        return HeapAlloc(GpMemHeap, GPMEMHEAPFLAGS, size);
        
    #endif


    #if GPMEM_ALLOC_CHK
        //
        // Fill up the entire allocation with the value
        // set in GPMEM_FILL_ALLOC
        //
        if(GPMEM_ALLOC_FILL)
        {
            GpMemset((unsigned char *)tmpalloc + sizeof(AllocTrackHeader) + GPMEM_GS,
                     GPMEM_FILL_ALLOC,
                     origsize);
        }

        //
        // Fill up the start guard area - if we have one.
        //
        if(GPMEM_GUARD_START)
        {
            unsigned char *p = (unsigned char *)tmpalloc+sizeof(AllocTrackHeader);
            GpMemset(p, GPMEM_FILL_GS, GPMEM_GS);
        }

        //
        // Fill up the end guard area - if we have one.
        //
        if(GPMEM_GUARD_END)
        {
            unsigned char *p = (unsigned char *)tmpalloc+size-GPMEM_GE;
            GpMemset(p, GPMEM_FILL_GE, GPMEM_GE);
        }

        //
        // setup the double linked-list to track all pool allocations.
        //
        AllocTrackHeader *hdr = (AllocTrackHeader *)tmpalloc;
        hdr->size = size;
        

        // zero out any unused frame pointers.
        
        GpMemset(hdr->caller_address, 0, sizeof(ULONG_PTR)*GPMEM_STACKSIZE);        
        
        // Lets stash away the entire stack trace if we have a 
        // backtrace function.
        
        if(Globals::CaptureStackBackTraceFunction)
        {
            ULONG hash;                         // dummy hash 
            
            USHORT frames = Globals::CaptureStackBackTraceFunction(
                0,                              // don't skip any frames
                GPMEM_STACKSIZE,                // get this many frames
                (PVOID*)(hdr->caller_address),  // ... into here.
                &hash                          
            );
        }
        
        hdr->flags = MemoryAllocated;
        hdr->tag = 'unkn';

        #if GPMEM_ALLOC_CHK_LIST
        hdr->callerFileName = fileName;
        hdr->callerLineNumber = lineNumber;
        #endif

        if(GPMEM_ALLOC_TRACKING)
        {
            hdr->blink = NULL;
            hdr->flink = gpmemAllocList;
            if(gpmemAllocList)
            {
                gpmemAllocList->blink = (AllocTrackHeader *)tmpalloc;
            }
            gpmemAllocList = (AllocTrackHeader *)tmpalloc;
        }
        else
        {
            GpMemset(hdr, 0, sizeof(AllocTrackHeader));
        }

        //
        // Give them a pointer just after the guard bits.
        //
        return (char *)tmpalloc+sizeof(AllocTrackHeader)+GPMEM_GS;
    #endif
}

/**************************************************************************\
*
* Function Description:
*    Allocates memory for APIs. Used to track the memory with a separate
*    identifying flag so that API allocations can be distinguished from
*    internal allocations.
*    Used on debug builds.
*
* Arguments:
*    [IN] size - size to pass to GpMalloc
*
* Return Value:
*    Returns the memory with the appropriately hacked up caller address
*
* History:
*
*   4/30/2000 asecchia
*       Created it.
*
\**************************************************************************/

#if DBG

#if GPMEM_ALLOC_CHK

#if GPMEM_ALLOC_CHK_LIST
extern "C" void * __stdcall GpMallocAPIDebug(size_t size, char *fileName, INT lineNumber)
#else
extern "C" void *GpMallocAPI(size_t size)
#endif
{
    // If we're playing with the tracking headers, we need to be thread safe.
    GpMallocTrackingCriticalSection critsecobj;

    #if GPMEM_ALLOC_CHK_LIST
    void *p = GpMallocDebug(size, fileName, lineNumber);
    #else
    void *p = GpMalloc(size);
    #endif

    if(p)
    {
        AllocTrackHeader *hdr = (AllocTrackHeader *)(
            (unsigned char *)p-(GPMEM_GS+sizeof(AllocTrackHeader)));
        hdr->flags |= APIAllocation;
    }
    return p;
}

#else // !GPMEM_ALLOC_CHK

extern "C" void *GpMallocAPI(size_t size, unsigned int caddr)
{
    return GpMalloc(size);
}

#endif // !GPMEM_ALLOC_CHK
#endif // DBG

/**************************************************************************\
*
* Function Description:
*
*   Computes the original size of a memory block allocated under GPMEM_ALLOC_CHK
*
* Arguments:
*
*   [IN] p - current memory block
*
* Return Value:
*
*   size of the original request for a memory block (i.e. excluding guard
*   areas, headers, etc). The size returned is the DWORD aligned size - so it
*   may differ slighly from the original size requested.
*
* Notes:
*
*   Returns a size of zero if called with NULL
*   Only compiled under GPMEM_ALLOC_CHK
*
* History:
*
*   09/14/1999 asecchia
*       Created it.
*
\**************************************************************************/

#if GPMEM_ALLOC_CHK
extern "C" size_t GpSizeBlock(void *p)
{
  if(p)
  {
      // Find the beginning of the allocated block header.
      
      p = (char *)p-(GPMEM_GS+sizeof(AllocTrackHeader));
      
      ASSERT(
          HeapSize(GpMemHeap, GPMEMHEAPFLAGS, p) >= 
          ((AllocTrackHeader *)p)->size
      );
      
      // Compute the size of the allocated block's data area.
      
      return (((AllocTrackHeader *)p)->size -
              (GPMEM_GS+GPMEM_GE+sizeof(AllocTrackHeader)));
  }
  else
  {
      return 0;
  }
}
#else
// Non-debug build, just call HeapSize
#define GpSizeBlock(p) HeapSize(GpMemHeap, GPMEMHEAPFLAGS, p)
#endif


/**************************************************************************\
*
* Function Description:
*
*   Reallocates a memory block.
*
* Arguments:
*
*   [IN] memblock - current memory block
*   [IN] size - new allocation size
*
* Return Value:
*
*   A pointer to the new block, or NULL on failure.
*
* Notes:
*
*   If size is 0, frees the block.
*   If memblock is NULL, allocates a new block.
*   (If both, does nothing.)
*
*   LocalReAlloc only grows if it can expand the current allocation
*   - otherwise it fails.
*
* History:
*
*   09/14/1999 asecchia
*       Added the checked build memory guard code.
*   07/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

extern "C" void *GpRealloc(void *memblock, size_t size)
{
    #if GPMEM_ALLOC_CHK
    gpmemAllocTotal.CumulativeReallocs++;
    #endif

    // Free.
    
    if (!size)
    {
        if (memblock)
            GpFree(memblock);
        return NULL;
    }
    
    // Alloc.
    
    if (!memblock)
    {
        return GpMalloc(size);
    }

    // Realloc - Use GpMalloc/GpMemcpy/GpFree for debug so that the
    // extra buffers line up (would require duplicating the code
    // from the GpMalloc/GpFree functions otherwise
    
    #if GPMEM_ALLOC_CHK

    VOID *  p = GpMalloc(size);
    if (p != NULL)
    {
        size_t oldSize = GpSizeBlock(memblock);

        // Are we shrinking the block?
        
        if (oldSize > size)
        {
            oldSize = size;
        }
        
        GpMemcpy(p, memblock, oldSize);
        GpFree(memblock);
    }

    #else // !GPMEM_ALLOC_CHK

    #if PROFILE_MEMORY_USAGE
    MC_LogAllocation(size);
    #endif

    VOID *p = HeapReAlloc(GpMemHeap, GPMEMHEAPFLAGS, memblock, size);

    #endif // !GPMEM_ALLOC_CHK

    return p;
}

/**************************************************************************\
*
* Function Description:
*
*   Frees a block of memory.
*
* Arguments:
*
*   [IN] memblock - block to free
*
* Notes:
*
*   If memblock is NULL, does nothing.
*
* History:
*
*   09/14/1999 asecchia
*       Added the checked build memory guard code.
*   07/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

extern "C" void GpFree(void *memblock)
{
    // Do nothing if the pointer is NULL.
    
    if(memblock)
    {
        #if GPMEM_ALLOC_CHK
        // If we're playing with the tracking headers, we need to be thread safe.
        GpMallocTrackingCriticalSection critsecobj;

        memblock = (unsigned char *)memblock-(GPMEM_GS+sizeof(AllocTrackHeader));


        // Let's do the header stuff.

        AllocTrackHeader *hdr = (AllocTrackHeader *)memblock;
        DWORD size = hdr->size;
        gpmemAllocTotal.Freed(size);

        ASSERTMSG(
            (hdr->flags & MemoryAllocated) &&
            !(hdr->flags & MemoryFreed),
            ("GpFree() already freed memory %p (freed by GpFree())",
            memblock)
        );

        hdr->flags &= ~MemoryAllocated;
        hdr->flags |= MemoryFreed;

        ASSERTMSG(
            HeapSize(GpMemHeap, GPMEMHEAPFLAGS, memblock) >= hdr->size,
            (
                "GpFree() already freed memory %p (freed somewhere else?)"
                " local size=%d, size=%d",
                memblock,
                HeapSize(GpMemHeap, GPMEMHEAPFLAGS, memblock),
                hdr->size
            )
        );

        if(GPMEM_ALLOC_TRACKING)
        {
            // Useful on checked Win2k builds because they fill guard
            // area with 0xFEEEFEEE

            ASSERTMSG((hdr->flink == NULL) ||
                      ((DWORD)((ULONG_PTR)(hdr->flink->blink) & 0xFFFFFFFF) != 0xFEEEFEEE),
                      ("GpFree() updating forward link to freed page, header %p",
                       memblock));

            ASSERTMSG((hdr->blink == NULL) ||
                      ((DWORD)((ULONG_PTR)(hdr->blink->flink) & 0xFFFFFFFF) != 0xFEEEFEEE),
                      ("GpFree() updating backward link to freed page, header %p",
                       memblock));

            if(hdr->flink) hdr->flink->blink = hdr->blink;
            if(hdr->blink) hdr->blink->flink = hdr->flink;
            if(gpmemAllocList==memblock) gpmemAllocList = hdr->flink;
        }
        else
        {
            ASSERTMSG(hdr->flink==NULL, ("GpFree() corrupt header %p", memblock));
            ASSERTMSG(hdr->blink==NULL, ("GpFree() corrupt header %p", memblock));
        }

        int i;
        unsigned char *p;

        // Check the start guard area

        if(GPMEM_GUARD_START)
        {
            p = (unsigned char *)memblock+sizeof(AllocTrackHeader);
            for(i=0; i<GPMEM_GS; i++)
            {
                ASSERTMSG(*p==GPMEM_FILL_GS, ("GpFree() pre-guard area corrupt %p", memblock));
                p++;
            }
        }

        // Check the end guard area

        if(GPMEM_GUARD_END)
        {
            p = (unsigned char *)memblock+size-GPMEM_GE;
            for(i=0; i<GPMEM_GE; i++)
            {
                ASSERTMSG(*p==GPMEM_FILL_GE, ("GpFree() post-guard area corrupt %p", memblock));
                p++;
            }
        }

        // Now lets fill the entire block with something to prevent
        // use of free data.

        GpMemset(memblock, GPMEM_FILL_FREE, size);

        #endif
    
        // HeapFree may fail freeing a NULL pointer on Win98.

        BOOL ret = HeapFree(GpMemHeap, GPMEMHEAPFLAGS, memblock);

        ASSERTMSG(
            ret, (
                "HeapFree() failed at %p, GetLastError()=%08x",
                memblock,
                GetLastError()
            )
        );
    }
}


extern "C" void * __stdcall zcalloc(
    void *pvOpaque, 
    unsigned int c, 
    unsigned int cb
    )
{
    void *pv = GpMalloc(c * cb);
    if (pv != NULL)
        GpMemset(pv, 0, c * cb);
    return pv;
}

extern "C" void __stdcall zcfree(void *pvOpaque, void *pv)
{
    GpFree(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\mem.h ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Memory management functions
*
* Abstract:
*
*   Wrapper functions for memory management.
*   This file is C-includable.
*
* Revision History:
*
*   07/08/1999 agodfrey
*       Created it.
*   09/07/1999 agodfrey
*       Moved the code into Runtime\mem.h
*
\**************************************************************************/

#ifndef _MEM_H
#define _MEM_H

#include <malloc.h>
#include "tags.h"

#define GpMemset    memset
#define GpMemcpy    memcpy
#define GpMemcmp    memcmp


// Enable memory allocation checking only on the DBG build
#if DBG
#define GPMEM_ALLOC_CHK 1
#define GPMEM_ALLOC_CHK_LIST 1   // List leaked blocks in debug output
#endif


#ifdef __cplusplus

#define GPMEMHEAPINITIAL 32768 // 32K initial heap size
#define GPMEMHEAPLIMIT       0 // No limit
#define GPMEMHEAPFLAGS       0 // Our common Heap API flags

//--------------------------------------------------------------------------
// Building for native DLL
//--------------------------------------------------------------------------

// Our memory allocation functions.
//
// This file (only) is made C-includable so that we can use it in
// dropped C code.

extern "C" {
#endif

#if GPMEM_ALLOC_CHK_LIST
    void * __stdcall GpMallocDebug(size_t size, char *filename, int line);
    #define GpMalloc(size) GpMallocDebug(size, __FILE__, __LINE__)
    #if DBG
        void * __stdcall GpMallocAPIDebug(size_t size, char *fileName, int lineNumber);
        #define GpMallocAPI(size) GpMallocAPIDebug(size, __FILE__, __LINE__)
    #endif
    void GpTagMalloc(void * mem, GpTag tag, int bApi);
#else
    void * __stdcall GpMalloc( size_t size );
    #if DBG
        // This is used to track API allocations on the debug build.
        void * __stdcall GpMallocAPI( size_t size );
    #endif
    #define GpTagMalloc(x,y,z)
#endif

void * __stdcall GpRealloc( void *memblock, size_t size );
void __stdcall GpFree( void *memblock );

#ifdef __cplusplus
}

// Hook new and delete

#pragma optimize ( "t", on)

// Don't ask me why we need 'static' here. But we do - otherwise
// it generates out-of-line versions which cause a link clash with Office.

static inline void* __cdecl operator new(size_t size)
{
    return GpMalloc(size);
}

static inline void __cdecl operator delete(void* p)
{
    GpFree(p);
}

static inline void* __cdecl operator new[](size_t size)
{
    return GpMalloc(size);
}

static inline void __cdecl operator delete[](void* p)
{
    GpFree(p);
}

static inline void* __cdecl operator new(size_t size, GpTag tag, int bApi)
{
#if GPMEM_ALLOC_CHK_LIST
    void * mem = GpMalloc(size);
    GpTagMalloc(mem, tag, bApi);
    return mem;
#else
    return GpMalloc(size);
#endif
}

static inline void* __cdecl operator new[](size_t size, GpTag tag, int bApi)
{
#if GPMEM_ALLOC_CHK_LIST
    void * mem = GpMalloc(size);
    GpTagMalloc(mem, tag, bApi);
    return mem;
#else
    return GpMalloc(size);
#endif
}


#pragma optimize ("", on)

// TODO:
//
// Imaging code needs to hook to GpMalloc, GpFree etc.

#endif

/*
 * Assert that we didn't leak any memory.
 * Can only be called during shutdown.
 */
extern void GpAssertShutdownNoMemoryLeaks();

extern void GpInitializeAllocFailures();
extern void GpDoneInitializeAllocFailureMode();
extern void GpStartInitializeAllocFailureMode();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\osinfo.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   OS information
*
* Abstract:
*
*   Describes the OS that is running
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   09/08/1999 agodfrey
*       Moved to Runtime\OSInfo.hpp
*
\**************************************************************************/

#ifndef _OSINFO_HPP
#define _OSINFO_HPP

namespace GpRuntime
{

//--------------------------------------------------------------------------
// Global OS-related information
// This is initialized in GpRuntime::Initialize()
//--------------------------------------------------------------------------

class OSInfo
{
public:
    static DWORD VAllocChunk;
    static DWORD PageSize;
    static BOOL IsNT;
    static DWORD MajorVersion;
    static DWORD MinorVersion;
    static BOOL HasMMX;
private:
    static void Initialize();
    
    friend BOOL GpRuntime::Initialize();
};

}

#endif // !_OSINFO_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\osinfo.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   OS information
*
* Abstract:
*
*   Describes the OS that is running
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   09/08/1999 agodfrey
*       Moved to Runtime\OSInfo.cpp
*
\**************************************************************************/

#include "precomp.hpp"

namespace GpRuntime {

DWORD OSInfo::VAllocChunk;
DWORD OSInfo::PageSize;
DWORD OSInfo::MajorVersion;
DWORD OSInfo::MinorVersion;
BOOL OSInfo::IsNT;
BOOL OSInfo::HasMMX;

BOOL DetectMMXProcessor();

}

#ifdef _X86_

/**************************************************************************\
*
* Function Description:
*
*   Detect whether the processor supports MMX
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   TRUE if the processor supports MMX
*   FALSE otherwise
*
\**************************************************************************/

BOOL
GpRuntime::DetectMMXProcessor()
{
    // NT 4.0 and up provide an API to check for MMX support; this handles
    // floating-point emulation as well. We cannot implicitly reference this
    // function because it's not exported by Windows 95 or NT < 4.0, so we
    // must use GetProcAddress. Windows 98 and up do export the function, but
    // it's stubbed, so we must also do an OS version check:

    typedef BOOL (WINAPI *ISPROCESSORFEATUREPRESENTFUNCTION)(DWORD);
    ISPROCESSORFEATUREPRESENTFUNCTION IsProcessorFeaturePresentFunction = NULL;
    
    if ((OSInfo::IsNT) && (OSInfo::MajorVersion >= 4))
    {
        // LoadLibrary is not required since we're implicitly dependent on
        // kernel32.dll, so just use GetModuleHandle:
        
        HMODULE kernel32Handle = GetModuleHandle(TEXT("kernel32.dll"));

        if (kernel32Handle != NULL)
        {
            IsProcessorFeaturePresentFunction =
                (ISPROCESSORFEATUREPRESENTFUNCTION) GetProcAddress(
                    kernel32Handle, "IsProcessorFeaturePresent");
        }
    }

    BOOL hasMMX;

    if (IsProcessorFeaturePresentFunction != NULL)
    {
        hasMMX =
            IsProcessorFeaturePresentFunction(PF_MMX_INSTRUCTIONS_AVAILABLE);
    }
    else
    {
        hasMMX = FALSE;

        // IsProcessorFeaturePresent is unsupported on this OS, so we'll use
        // CPUID to check for MMX support.
        //
        // If CPUID is unsupported on this processor, we'll take the
        // exception. This will happen on most processors < Pentium, however
        // some 486 processors support CPUID.
        
        WARNING(("Executing processor detection; "
                 "benign first-change exception possible."));
        
        __try
        {
            DWORD features;

            // Get processor features using CPUID function 1:
            
            __asm
            {
                push eax
                push ebx
                push ecx
                push edx

                mov eax, 1
                cpuid
                mov features, edx

                pop edx
                pop ecx
                pop ebx
                pop eax
            }

            // If bit 23 is set, MMX technology is supported by this
            // processor, otherwise MMX is unsupported:
            
            if (features & (1 << 23))
            {
                // Try executing an MMX instruction to make sure
                // floating-point emulation is not on:
            
                __asm emms

                // If we made it this far, then MMX is available:

                hasMMX = TRUE;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // We should only be here if (1) the processor does not support
            // CPUID or (2) CPUID is supported, but floating-point emulation
            // is enabled.
        }
    }
    
    return hasMMX;
}

#else // !_X86_

#define DetectMMXProcessor() FALSE

#endif // !_X86_

/**************************************************************************\
*
* Function Description:
*
*   Static initialization function for OSInfo class.
*   Called by GpRuntime::Initialize()
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRuntime::OSInfo::Initialize()
{
    // Get VM information

    SYSTEM_INFO sysinfo;
    GetSystemInfo(&sysinfo);

    VAllocChunk = sysinfo.dwAllocationGranularity;
    PageSize = sysinfo.dwPageSize;

    // Get operating system version information

    OSVERSIONINFOA osver;
    osver.dwOSVersionInfoSize = sizeof(osver);

    if (GetVersionExA(&osver))
    {
        IsNT = (osver.dwPlatformId == VER_PLATFORM_WIN32_NT);
        MajorVersion = osver.dwMajorVersion;
        MinorVersion = osver.dwMinorVersion;
    }

    // Check to see if MMX is available

    HasMMX = DetectMMXProcessor();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\lockable.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Locking
*
* Abstract:
*
*   Lockable: A base class for lockable objects, which contains a lock.
*   Lock: Represents a held lock on an object (acquires and releases an
*         object's lock in its constructor and destructor).
*
* Revision History:
*
*   02/22/1999 davidx
*       Created it.
*   09/08/1999 agodfrey
*       Moved to Runtime\Lockable.hpp
*
\**************************************************************************/

#ifndef _LOCKABLE_HPP
#define _LOCKABLE_HPP

namespace GpRuntime 
{

//
// TODO: Remove the 'Gp' prefix from GpLockable and GpLock
//           
           
//--------------------------------------------------------------------------
// Base class for lockable API objects
//--------------------------------------------------------------------------

class GpLockable
{
    friend class GpLock;

public:

    GpLockable()
    {
        LockCount = -1;
    }

    ~GpLockable()
    {
        // Comment out to prevent Office crash.  3/14/00 -- ikkof
//        ASSERTMSG(LockCount == -1, ("~GpLock: non-zero lock count"));
    }

    LONG* GetLockCount()
    {
        return &LockCount;
    }

    BOOL IsLocked() const
    {
        return (LockCount != -1);
    }

    VOID Reset()
    {
        LockCount = -1;
    }
    
    // Copy constructor and assignment operator

    GpLockable(GpLockable & lockable)
    {
        LockCount = -1;
    }

    GpLockable &operator=(const GpLockable & lockable)
    {
        return *this;
    }

protected:

    LONG LockCount;             // number of locks, minus one
};

//--------------------------------------------------------------------------
// Class for locking API objects
// NOTE: These locks are not reentrant!
//--------------------------------------------------------------------------

class GpLock
{
public:

    GpLock(GpLockable* lockable)
    {
        // In flatapi, we sometimes need to check if an optional (NULL)
        // parameter is busy, which means we would pass NULL into this
        // constructor.  An optional parameter should not be considered locked. 
        if (lockable != NULL)
        {
            LockCount = &lockable->LockCount;

            // Note that it generates less code when we store the result
            // here than it is to convert to a BOOL here and store that.

            Result = InterlockedIncrement(LockCount);
        }
        else
        {
            Result = 0;
            LockCount = &Result;
        }
    }

    ~GpLock()
    {
        InterlockedDecrement(LockCount);
    }

    BOOL IsValid()  const
    {
        return (Result == 0);
    }

    BOOL LockFailed() const
    {
        return (Result != 0);
    }

    VOID MakePermanentLock()
    {
        // This is useful when deleting an object.  First, lock it, then 
        // leave it in a locked state.  Technically the memory will be released
        // and available for reuse, but the ObjectLock will still be left in
        // a locked state.

        LockCount = &Result;
    }

private:

    LONG Result;
    LONG *LockCount;
};

}

#endif // !_LOCKABLE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\precomp.hpp ===
#if DBG
#include <stdio.h>
#endif

#include "runtime.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\tags.h ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Tag enumerations
*
* Abstract:
*
*   This file is the central depot for the enumeration of all object tags.
*   This file is C-includable.
*
* Revision History:
*
*   08/21/2000 bhouse
*       Created it.
*
\**************************************************************************/

#ifndef _TAGSX_H
#define _TAGSX_H

#ifdef __cplusplus
extern "C" {
#endif

    typedef enum GpTag {
        GpPathTag           = 'gpth',
        GpIteratorTag       = 'iter'
    } GpTag;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\real.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Contains macros for helping with floating point arithmetic.
*
* History:
*
*   07/08/1999 agodfrey
*       Remove MSVCRT dependency.
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#ifndef _REAL_HPP_
#define _REAL_HPP_

// The following stuff is taken from Office code

/*****************************************************************************
    Intrinsic functions - it is essential that these be used because there is
    no library implementation.  Note that the intrinsic forms often have
    restricted behavior, e.g. the argument to a trignometric function must be
    less than 2^63 radians.
******************************************************************* JohnBo **/
#pragma intrinsic(sin, cos, tan)
#pragma intrinsic(atan, atan2)
#pragma intrinsic(sqrt)
#pragma intrinsic(log, log10, exp)
#pragma intrinsic(fabs)
#pragma intrinsic(fmod)

namespace GpRuntime 
{
/*
    [JohnBo]
    These in-line functions are required to force direct use of the
    instructions - without this the CI versions are used unless g optimization
    is switched on, with g optimization on the in-line function calls will be
    removed completely.
*/
#pragma optimize("g", on)
    inline double InlineSin(double x) { return sin(x); }
    inline double InlineCos(double x) { return cos(x); }
    inline double InlineTan(double x) { return tan(x); }
    inline double InlineATan(double x) { return atan(x); }
    inline double InlineATan2(double y, double x) { return atan2(y, x); }
    inline double InlineSqrt(double x) { return sqrt(x); }
    inline double InlineLog(double x) { return log(x); }
    inline double InlineLog10(double x) { return log10(x); }
    inline double InlineExp(double x) { return exp(x); }
/* Restore default optimization. */
#pragma optimize("", on)

    // Out-of-line math functions
    // pow: We implemented it ourselves
    // exp: Because the inline version is so long, the compiler won't
    //      inline it unless the original caller has 'generate fast code'
    //      set. Instead, we use an out-of-line version.
    double Pow(double, double);
    double Exp(double);
    
/*// Trying something:
inline double FPX86InlineFmod(double x, double y) { return fmod(x,y); }
#define fmod(x,y) FPX86InlineFmod(x,y)
*/
};

/* Force use of the in-line functions. */

#define sin(x) GpRuntime::InlineSin(x)
#define cos(x) GpRuntime::InlineCos(x)
#define tan(x) GpRuntime::InlineTan(x)
#define atan(x) GpRuntime::InlineATan(x)
#define atan2(y,x) GpRuntime::InlineATan2(y,x)
#define sqrt(x) GpRuntime::InlineSqrt(x)
#define log(x) GpRuntime::InlineLog(x)
#define log10(x) GpRuntime::InlineLog10(x)
#define exp(x) GpRuntime::Exp(x)

#define pow(x,y) GpRuntime::Pow(x,y)

/* Integer interfaces */
#pragma intrinsic(abs, labs)

// End of Office code

// Our pixel positioning uses 28.4 fixed point arithmetic and therefore 
// anything below the threshold of 1/32 should be irrelevant.
// Our choice of PIXEL_EPSILON is 1/64 which should give us correct pixel
// comparisons even in the event of accumulated floating point error.
#define PIXEL_EPSILON   0.015625f     // 1/64

#ifndef REAL_EPSILON
#define REAL_EPSILON    FLT_EPSILON
#endif

// This is for computing the complexity of matrices. When you compose matrices
// or scale them up by large factors, it's really easy to hit the REAL_EPSILON
// limits without actually affecting the transform in any noticable way.
// e.g. a matrix with a rotation of 1e-5 degrees is, for all practical purposes,
// not a rotation.
#define CPLX_EPSILON    (REAL_EPSILON*5000.0f)

// This is a tolerance error for the difference of each real coordinates.
// This leaves some acurracy to calculate tangent or normal for the two points.
#define POINTF_EPSILON  (REAL_EPSILON*5000.0f)


#define REALFMOD        fmodf
#define REALSQRT        sqrtf
#ifndef REALABS
#define REALABS         fabsf
#endif
#define REALSIN         sinf
#define REALCOS         cosf
#define REALATAN2       atan2f

// #define REAL_EPSILON    DBL_EPSILON
// #define REALFMOD        fmod
// #define REALSQRT        sqrt
// #define REALABS         fabs
// #define REALSIN         sin
// #define REALCOS         cos
// #define REALATAN2       atan2

// convert from unknown FLOAT type => REAL
#define TOREAL(x)       (static_cast<REAL>(x))

// defined separately for possibly future optimization LONG to REAL
#define LTOF(x)         (static_cast<REAL>(x))

// Return the positive integer remainder of a/b. b should not be zero.
// note that a % b will return a negative number 
// for a<0 xor b<0 which is not suitable for texture mapping
// or brush tiling.
// This macro computes the remainder of a/b
// correctly adjusted for tiling negative coordinates.

#define RemainderI(a, b)\
    ((a) >= 0 ? (a) % (b) : \
    (b) - 1 - ((-(a) - 1) % (b)))


// This definition assumes y > 0
inline REAL GpModF(REAL x, REAL y)
{
    if(x > 0)
    {
        return static_cast<REAL> (x - ((INT) (x/y))*y);
    }
    else if(x < 0)
    {
        REAL z;
        x = - x;
        z = static_cast<REAL> (x - ((INT) (x/y))*y);
        if(z > 0)
            z = y - z;

        return z;
    }
    else    // x == 0
        return 0.0;

/*    
//  This assumes fmod(x, y) = - fmod(-x, y) when x < 0.

    REAL z = REALFMOD(x, y);

    if(z >= 0)
        return z;
    else
        return y + z;
*/
}

#if defined(_X86_) && !defined(_COMPLUS_GDI)

    #define _USE_X86_ASSEMBLY

#else

    #undef  _USE_X86_ASSEMBLY

#endif

#if defined(_USE_X86_ASSEMBLY)

    #define FPU_STATE()                     \
        UINT32 cwSave;                      \
        UINT32 cwTemp;

    #define FPU_GET_STATE()                 \
        UINT32 cwSave = this->cwSave;       \
        UINT32 cwTemp = this->cwTemp;

    #define FPU_SAVE_STATE()                \
        this->cwSave = cwSave;              \
        this->cwTemp = cwTemp;

    #define FPU_SAVE_MODE()                 \
        UINT32 cwSave;                      \
        UINT32 cwTemp;                      \
                                            \
        __asm {                             \
            _asm fnstcw  WORD PTR cwSave    \
            _asm mov     eax, cwSave        \
            _asm mov     cwTemp, eax        \
        }                                   \
        this->cwSave = 
    
    #define FPU_RESTORE_MODE()              \
        __asm {                             \
            _asm fldcw   WORD PTR cwSave    \
        }
    
    #define FPU_RESTORE_MODE_NO_EXCEPTIONS()\
        __asm {                             \
            _asm fnclex                     \
            _asm fldcw   WORD PTR cwSave    \
        }
    
    #define FPU_CHOP_ON()                    \
        __asm {                              \
            _asm mov    eax, cwTemp          \
            _asm or     eax, 0x0c00          \
            _asm mov    cwTemp, eax          \
            _asm fldcw  WORD PTR cwTemp      \
        }
    
    #define FPU_ROUND_ON()                   \
        __asm {                              \
            _asm mov    eax, cwTemp          \
            _asm and    eax,0xf3ff           \
            _asm mov    cwTemp, eax          \
            _asm fldcw  WORD PTR cwTemp      \
        }
    
    #define FPU_ROUND_ON_PREC_HI()           \
        __asm {                              \
            _asm mov    eax, cwTemp          \
            _asm and    eax,0xf0ff           \
            _asm or     eax,0x0200           \
            _asm mov    cwTemp, eax          \
            _asm fldcw  WORD PTR cwTemp      \
        }
    
    #define FPU_PREC_LOW()                   \
        __asm {                              \
            _asm mov    eax, cwTemp          \
            _asm and    eax, 0xfcff          \
            _asm mov    cwTemp, eax          \
            _asm fldcw  WORD PTR cwTemp      \
        }
    
    #define FPU_PREC_LOW_MASK_EXCEPTIONS()   \
        __asm {                              \
            _asm mov    eax, cwTemp          \
            _asm and    eax, 0xfcff          \
            _asm or     eax, 0x3f            \
            _asm mov    cwTemp, eax          \
            _asm fldcw  WORD PTR cwTemp      \
        }
    
    #define FPU_CHOP_ON_PREC_LOW()          \
        __asm {                             \
            _asm mov    eax, cwTemp         \
            _asm or     eax, 0x0c00         \
            _asm and    eax, 0xfcff         \
            _asm mov    cwTemp, eax         \
            _asm fldcw  WORD PTR cwTemp     \
        }
    
    #define FPU_CHOP_OFF_PREC_HI()          \
        __asm {                             \
            _asm mov    eax, cwTemp         \
            _asm mov    ah, 2               \
            _asm mov    cwTemp, eax         \
            _asm fldcw  WORD PTR cwTemp     \
        }
    
    #define CHOP_ROUND_ON()     
    #define CHOP_ROUND_OFF()
    
    #if DBG
    #define ASSERT_CHOP_ROUND()         \
        {                               \
            WORD cw;                    \
            __asm {                     \
                __asm fnstcw cw         \
            }                           \
            ASSERT((cw & 0xc00) == 0xc00, "Chop round must be on"); \
        }
    #else
    #define ASSERT_CHOP_ROUND()
    #endif

#else // _USE_X86_ASSEMBLY

    #define FLT_TO_FIX_SCALE(value_in, scale) \
        ((INT)((REAL)(value_in) * scale))
    #define FLT_TO_UCHAR_SCALE(value_in, scale) \
        ((UCHAR)((INT)((REAL)(value_in) * scale)))
    #define UNSAFE_FLT_TO_FIX(value_in) \
        FLT_TO_FIX(value_in)
    
    #define FPU_SAVE_MODE()
    #define FPU_RESTORE_MODE()
    #define FPU_RESTORE_MODE_NO_EXCEPTIONS()
    #define FPU_CHOP_ON()
    #define FPU_ROUND_ON()
    #define FPU_ROUND_ON_PREC_HI()
    #define FPU_PREC_LOW()
    #define FPU_PREC_LOW_MASK_EXCEPTIONS()
    #define FPU_CHOP_ON_PREC_LOW()
    #define FPU_CHOP_OFF_PREC_HI()
    #define CHOP_ROUND_ON()
    #define CHOP_ROUND_OFF()
    #define ASSERT_CHOP_ROUND()

#endif  //_USE_X86_ASSEMBLY

#if defined(_USE_X86_ASSEMBLY)

    __inline INT __fastcall FLOOR(
        REAL a)
    {
        INT i;
    
        _asm {
            fld     a
            fistp   i
        }
    
        return i;
    }
    
    // Can cause overflow exceptions
    __inline INT __fastcall UNSAFE_FLOOR(
        REAL a)
    {
        INT l;
    
        _asm {
            fld     a
            fistp   l
        }
    
        return l;
    }
    
#else
    
    #define FLOOR(a) ((INT) floor(a))
    #define UNSAFE_FLOOR(a) ((INT) floor(a))
    
#endif    

//--------------------------------------------------------------------------
// Class for invoking 'floor' mode, and restoring it afterwards
//--------------------------------------------------------------------------

// These define the bits in the FPU control word that we care about.
// The high byte 0x0c is the rounding control and the low byte
// 0x3F is the exception mask flags.

#define FP_CTRL_MASK                0x0c3F    

// Set the rounding control and mask PE. DE is no longer masked because
// taking the exception can be helpful in finding bugs. However, we should
// probably turn on DE masking when we ship.

// Round Down
#define FP_CTRL_ROUNDDOWN           0x0400

// Mask PE only.
// Use this define to track down nasty FP bugs.
// #define FP_CTRL_MASKEDEXCEPTIONS    0x0020

// Mask all FP exceptions.

#define FP_CTRL_MASKEDEXCEPTIONS    0x003F

#define FP_CTRL_STATE              (FP_CTRL_ROUNDDOWN | FP_CTRL_MASKEDEXCEPTIONS)

class FPUStateSaver
{
private:

    UINT32 SavedState;

#if DBG
    // For AssertMode, we use SaveLevel to keep track
    // of the nesting level of FPUState. This is not thread safe.
    // At worst, that could cause spurious asserts; more likely it could
    // fail to catch some errors. To prevent the spurious asserts,
    // used interlocked instructions to modify it. To fix it properly,
    // we'd need to use per-thread storage.
    
    static LONG SaveLevel;
#endif    

public:

    FPUStateSaver()
    {
        // Here we set our thread's round mode to 'round down', and
        // save the old mode.  'Round to nearest' is actually the
        // default state for a process, but applications can set it
        // to whatever they like, and we should also respect and save
        // their preferred mode.

        #if defined(_USE_X86_ASSEMBLY)
        
            UINT32 tempState;
            UINT32 savedState;
    
            // clear the current exception state.
            // fnclex is a non-wait version of fclex - which means it clears
            // the exceptions without taking any pending unmasked exceptions.
            // We issue a fclex so that any unmasked exceptions are 
            // triggered immediately. This indicates a bug in the caller
            // of the API.
        
            _asm fclex
            
            // Save control word:
    
            _asm fnstcw  WORD PTR savedState
    
            this->SavedState = savedState;
    
            // Floor mode on & set up our prefered exception masks
    
            _asm mov     eax, savedState
            _asm and     eax, ~FP_CTRL_MASK
            _asm or      eax, FP_CTRL_STATE
            _asm mov     tempState, eax        
            _asm fldcw   WORD PTR tempState    

        #endif
        
        #if DBG
            InterlockedIncrement(&SaveLevel);
        #endif    
    }

    ~FPUStateSaver()
    {
        AssertMode();
        
        #if DBG
            InterlockedDecrement(&SaveLevel);
        #endif
        
        #if defined(_USE_X86_ASSEMBLY)

            UINT32 savedState = this->SavedState;

            // Clear the exception state.
            // Note: We issue the fwait and then an fnclex - which is equivalent
            // to the fclex instruction (9B DB E2) which causes us to 
            // immediately take any unmasked pending exceptions.
            // Because we clear the exception state on the way in, hitting 
            // an exception on this line means we generated an exception
            // in our code (or a call out to other code between the 
            // FPUStateSaver constructor and destructor nesting) which was 
            // pending and not handled.
            
            _asm fclex
    
            // Restore control word (rounding mode and exception masks):
    
            _asm fldcw   WORD PTR savedState    

        #endif
    }

    // AssertMode.
    //
    // AssertMode does nothing in Free builds, unless the FREE_BUILD_FP_BARRIER
    // define is set to 1. Debug builds always have FP barriers.
    // If exceptions are unmasked and you're getting delayed FP exceptions, 
    // turn on the FP barriers and add FPUStateSaver::AssertMode() calls 
    // bracketing all your calls. This will allow you to isolate the FP 
    // exception generator.
    
    #define FREE_BUILD_FP_BARRIER 0
    
    #if DBG
        static VOID AssertMode();
    #else
        static VOID AssertMode() 
        {
            #if defined(_USE_X86_ASSEMBLY)
            #if FREE_BUILD_FP_BARRIER
            _asm fwait
            #endif
            #endif
        }
    #endif

    //--------------------------------------------------------------------------
    // The following conversion routines are MUCH faster than the standard
    // C routines, because they assume that the FPU floating point state is
    // properly set.  
    //
    // However, because they assume that the FPU floating point state has been 
    // properly set, they can only be used if an instance of the 
    // 'FPUStateSaver' class is in scope.
    //--------------------------------------------------------------------------
    
    static INT Floor(REAL x)
    {
        AssertMode();
        return((INT) FLOOR(x));
    }
    static INT Trunc(REAL x)
    {
        AssertMode();
        return (x>=0) ? FLOOR(x) : -FLOOR(-x);
    }
    static INT Ceiling(REAL x)
    {
        AssertMode();
        return((INT) -FLOOR(-x));
    }
    static INT Round(REAL x)
    {
        AssertMode();
        return((INT) FLOOR((x) + TOREAL(0.5)));
    }

    // Saturation versions of the above conversion routines. Don't test for
    // equality to INT_MAX because, when converted to floating-point for the
    // comparison, the value is (INT_MAX + 1):

    #define SATURATE(op)                                      \
        static INT op##Sat(REAL x)                            \
        {                                                     \
            return (x >= INT_MIN) ? ((x < INT_MAX) ? op(x)    \
                                                   : INT_MAX) \
                                  : INT_MIN;                  \
        }

    SATURATE(Floor);
    SATURATE(Trunc);
    SATURATE(Ceiling);
    SATURATE(Round);

    #undef SATURATE
};


// FPUStateSandbox
//
// This object is designed to sandbox FPU unsafe code.
// For example, many badly written printer drivers on win9x codebases
// manipulate the FPU state without restoring it on exit. In order to 
// prevent code like that from hosing us, we wrap calls to potentially
// unsafe code (like driver escapes) in an FPUStateSandbox.
// 
// This will guarantee that after calling the unsafe code, the FPU state
// (rounding mode and exceptions) are reset to our preferred state.
// Because we assume that we're restoring to our preferred state, we 
// ASSERT on our preferred state being set on entry. This means that
// the sandbox must be declared inside some top level FPUStateSaver block.
// This condition is not strictly necessary and if there is a requirement
// for an FPUStateSandbox not contained inside an FPUStateSaver, this
// ASSERT can be removed. The sandbox saves the current state and restores
// it on exit, so it can operate outside of our preferred state if required.
//
// So far we've found a number of printer drivers on win9x codebase that
// require sandboxing - e.g. HP4500c pcl.
//
// Couple of caveats: This code is designed to wrap simple calls out of 
// GDI+ to the printer driver, such as Escape. It's not intended to be
// nested or for use with GDI+ code. However, nesting will work. In 
// particular you should not call FPUStateSaver functions inside of 
// an FPUStateSandbox unless you've acquired another nested FPUStateSaver.
// The only anticipated need for this is for sandboxing a callback function
// that calls into our API again. In this case it's ok, because all the 
// GDI+ calls will be wrapped by a nested FPUStateSaver acquired at the 
// API.
//
// NOTE: The ASSERTs in GpRound will not catch the scenario when they're
// called inside of a sandbox and not properly surrounded by a FPUStateSaver.
// GpRound may work incorrectly inside of a sandbox because the unsafe code
// could change the rounding mode. It could also generate exceptions.

class FPUStateSandbox
{
private:

    UINT32 SavedState;

public:

    FPUStateSandbox()
    {
        // it is assumed that this call is issued inside of an 
        // FPUStateSaver block, so that the CTRL word is set to
        // our preferred state.
        
        // Lets not do this ASSERT - turns out that it gets called on the device
        // destructor durning InternalGdiplusShutdown and we don't want to wrap
        // that with an FPUStateSaver.
        
        // FPUStateSaver::AssertMode();
        
        #if defined(_USE_X86_ASSEMBLY)
        
        UINT32 savedState;
        
        // We must protect the sandboxed code from clearing the exception
        // masks and taking an exception generated by GDI+.
        // We do this by issuing fclex - which takes any unmasked exceptions
        // and clears all of the exceptions after that (masked and unmasked)
        // giving the sandboxed code a clean slate.
        
        _asm fclex
        
        // Save control word:
        
        _asm fnstcw  WORD PTR savedState
        this->SavedState = savedState;
        
        #endif
    }

    ~FPUStateSandbox()
    {
        #if defined(_USE_X86_ASSEMBLY)
        
        UINT32 savedState = this->SavedState;
    
        // clear the current exception state.
        // fnclex is a non-wait version of fclex - which means it clears
        // the exceptions without taking any pending unmasked exceptions.
        // We issue an fnclex so that any unmasked exceptions are ignored.
        // This is designed to prevent the sandboxed code from blowing 
        // up in code outside of the sandbox.
            
        _asm fnclex
        
        // Restore control word (rounding mode and exception masks):

        _asm fldcw   WORD PTR savedState    
        
        #endif
    }
};



//--------------------------------------------------------------------------
// The following are simply handy versions that require less typing to
// use (i.e., 'GpFloor(x)' instead of 'FPUStateSaver::Floor(x)').  
//
// These functions require that a version of 'FPUStateSaver' has been 
// instantiated already for the current thread.
//--------------------------------------------------------------------------

inline INT GpFloor(REAL x) { return(FPUStateSaver::Floor(x)); }

inline INT GpTrunc(REAL x) { return(FPUStateSaver::Trunc(x)); }

inline INT GpCeiling(REAL x) { return(FPUStateSaver::Ceiling(x)); }

inline INT GpRound(REAL x) { return(FPUStateSaver::Round(x)); }

inline INT GpFloorSat(REAL x) { return(FPUStateSaver::FloorSat(x)); }

inline INT GpTruncSat(REAL x) { return(FPUStateSaver::TruncSat(x)); }

inline INT GpCeilingSat(REAL x) { return(FPUStateSaver::CeilingSat(x)); }

inline INT GpRoundSat(REAL x) { return(FPUStateSaver::RoundSat(x)); }


/**************************************************************************\
*
* Function Description:
*
*   Return TRUE if two points are close. Close is defined as near enough
*   that the rounding to 32bit float precision could have resulted in the
*   difference. We define an arbitrary number of allowed rounding errors (10).
*   We divide by b to normalize the difference. It doesn't matter which point
*   we divide by - if they're significantly different, we'll return true, and
*   if they're really close, then a==b (almost).
*
* Arguments:
*
*   a, b - input numbers to compare.
*
* Return Value:
*
*   TRUE if the numbers are close enough.
*
* Created:
*
*   12/11/2000 asecchia 
*
\**************************************************************************/

inline BOOL IsCloseReal(const REAL a, const REAL b)
{
    // if b == 0.0f we don't want to divide by zero. If this happens
    // it's sufficient to use 1.0 as the divisor because REAL_EPSILON
    // should be good enough to test if a number is close enough to zero.
    
    // NOTE: if b << a, this could cause an FP overflow. Currently we mask
    // these exceptions, but if we unmask them, we should probably check
    // the divide.
    
    // We assume we can generate an overflow exception without taking down
    // the system. We will still get the right results based on the FPU
    // default handling of the overflow.
    
    #if !(FP_CTRL_STATE & 0x8)
    
    // Ensure that anyone clearing the overflow mask comes and revisits this
    // assumption.
    
    #error #O exception cleared. Go check FP_CTRL_MASKEDEXCEPTIONS.
    
    #endif
    
    FPUStateSaver::AssertMode();
    
    return( REALABS( (a-b) / ((b==0.0f)?1.0f:b) ) < 10.0f*REAL_EPSILON );
}

inline BOOL IsClosePointF(const PointF &pt1, const PointF &pt2)
{
    return (
        IsCloseReal(pt1.X, pt2.X) && 
        IsCloseReal(pt1.Y, pt2.Y)
    );
}



#endif // !_REAL_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\runtime.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   GDI+ runtime initialization
*
* Abstract:
*
*   Initialization and uninitialization functions for the GDI+ run-time.
*
* Revision History:
*
*   09/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

HINSTANCE DllInstance;

/**************************************************************************\
*
* Function Description:
*
*   GDI+ run-time initialization function.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   FALSE if failure
*
\**************************************************************************/

BOOL
GpRuntime::Initialize()
{
    OSInfo::Initialize();
    if (!DllInstance)
        DllInstance = GetModuleHandleA(0);

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   GDI+ run-time cleanup function.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRuntime::Uninitialize()
{
}

/**************************************************************************\
*
* Function Description:
*
*   raise to an integer power (up to 
*
* Arguments:
*
*   exp - an integer exponent
*
* Return Value:
*
*   2^exp.  If exp >= 31, then return 2^31.
*
\**************************************************************************/

UINT
GpRuntime::Gppow2 (UINT exp)
{
    UINT maxexp = (sizeof(UINT)*8) - 1;
    UINT rv = 1;

    if (exp >= maxexp)
    {
        return (rv << maxexp); 
    }
    else
    {
        while (exp--)
        {
            rv <<= 1;
        }
    }
    return rv;
}


/**************************************************************************\
*
* Function Description:
*
*   raise to an integer power (up to 
*
* Arguments:
*
*   x - an integer value
*
* Return Value:
*
*   floor of log base 2 of x.  If x = 0, return 0.
*
\**************************************************************************/

UINT
GpRuntime::Gplog2 (UINT x)
{
    UINT rv = 0;
    x >>= 1;
    while (x)
    {
        rv++;
        x >>= 1;
    }
    return rv;
}

/**************************************************************************\
*
* Function Description:
*
*   Moves a block of memory. Handles overlapping cases.
*
* Arguments:
*
*   dest  - The destination buffer
*   src   - The source buffer
*   count - The number of bytes to copy
*
* Return Value:
*
*   dest
*
* Revision History:
*
*   10/22/1999 AGodfrey
*       Wrote it.
*
\******************************************************************************/
void *
GpRuntime::GpMemmove( 
    void *dest,
    const void *src, 
    size_t count )
{
    const BYTE *s = static_cast<const BYTE *>(src);
    BYTE *d = static_cast<BYTE *>(dest);
    
    // Test for the overlapping case we care about - dest is within the source
    // buffer. The other case is handled by the normal loop.
    
    if ((d > s) && (d < s + count))
    {
        d += count;
        s += count;
        while (count)
        {
            *--d = *--s;
            count--;
        }
    }
    else
    {
        while (count)
        {
            *d++ = *s++;
            count--;
        }    
    }        
    
    return dest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\real.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Floating point arithmetic support.
*
* History:
*
*   09/22/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#if DBG

// We need the definition of Globals::IsNt, but we don't want to include
// the whole of the ..\common\globals.hpp file.

namespace Globals
{
    extern BOOL IsNt;                   // Are we running on any version of NT?
}

VOID
FPUStateSaver::AssertMode(
    VOID
    )
{
    if (SaveLevel <= 0)
    {
        ASSERTMSG(0, ("FPU mode not set via FPUStateSaver class"));
    }
    
    #if defined(_USE_X86_ASSEMBLY)

    UINT32 tempState;
    
    // Issue a FP barrier. Take all pending exceptions now.
    
    _asm fwait
    
    // get the control word

    _asm fnstcw  WORD PTR tempState
    
    // ASSERT that the control word is still set to our prefered
    // rounding mode and exception mask.
    // If we take this ASSERT, there was an unauthorized change of 
    // the FPU rounding mode or exception mask settings between
    // the FPUStateSaver constructor and destructor.
    
    if(Globals::IsNt)
    {
        ASSERTMSG( 
            (tempState & FP_CTRL_MASK) == FP_CTRL_STATE,
            ("FPUStateSaver: Incorrect FPU Control Word")
        );
    }
    else
    {
        // On Win9x, many print drivers clear various exception masks
        // and at least one video driver (ATI) changed the rounding control.
        // While this could potentially cause rounding errors resulting in
        // slightly different rasterization, and/or spurious exceptions, the 
        // change required to fix this (wrapping all calls to GDI) is too 
        // large to risk. Instead, we downgrade the ASSERT on win9x to a 
        // WARNING. We have not seen one of these exceptions or rounding 
        // errors causing an actual rasterization error yet and will fix 
        // those as they occur.
        
        if((tempState & FP_CTRL_MASK) != FP_CTRL_STATE)
        {
            WARNING(("FPUStateSaver: Incorrect FPU Control Word"));
        }
    }
    
    #endif
}

LONG FPUStateSaver::SaveLevel = 0;

#endif

/**************************************************************************\
*
* Function Description:
*
*   Internal definition of MSVCRT's pow()
*
* Arguments:
*
*   x - base
*   y - exponent
*
* Return Value:
*
*   x^y
*
* Notes:
*
*   I purposefully didn't make our code use Office's implementation when
*   we do the Office build. I want to avoid needing a separate build for
*   Office if I can.
*
* Created:
*
*   10/19/1999 agodfrey
*       Stole it from Office's code (mso\gel\gelfx86.cpp)
*
\**************************************************************************/

double
GpRuntime::Pow(
    double x, 
    double y
)
{

#if defined(_USE_X86_ASSEMBLY)
    
    static const double fphalf = 0.5;
    static const double fpone = 1.0;

    if ( x == 0.0 )
    {
        if ( y > 0.0 )
        {
            return 0.0;
        }

        if (y == 0.0)
        {
            WARNING(("call Pow(x, y) with x=0.0 and y=0.0"));
            return 1.0; // sic
        }

        if ( y < 0.0 )
        {
            WARNING(("call Pow(x, y) with x=0.0 and y < 0.0"));

            // return INF to comply with MSDN. Since we don't have INF defined
            // in our header files, we use DBL_MAX which should be
            // sufficient.
            // !!!Todo[minliu], figure out how to return INF

            return DBL_MAX;
        }
    }// x == 0.0

    if (y == 0.0)
    {
        return 1.0;
    }

    __asm FLD QWORD PTR [y];   // becomes ST(1)
    __asm FLD QWORD PTR [x];   // becomes ST
    __asm FYL2X;               // ST := ST(1) * log2(ST)
    __asm FST QWORD PTR [x];

    /* Do this in C++ just to avoid all the messing around with the condition
        flags, keep x in ST(0) while doing this. */
    if (fabs(x) < fpone)
    {
        /* The power is in the range which F2XM1 can handle. */
        __asm F2XM1;                  // ST := 2^ST - 1
        __asm FADD QWORD PTR [fpone]; // ST := 2^mantissa
    }
    else
    {
        /* The power needs to be handled as a separate fractional and whole
            number part, as F2XM1 only handles fractions.  Note that we don't
            care about the rounding mode here - we just need to split x
            into two parts one of which is <1.0. */
        __asm FLD ST;                 // Duplicate ST
        __asm FRNDINT;                // Integral value in ST
        //NB: doc bug in the x86 manual, the following does ST(1):=ST(1)-ST
        __asm FSUB ST(1), ST;         // Fractional value in ST(1)
        __asm FXCH;                   // Factional value in ST
        __asm F2XM1;                  // ST := 2^ST - 1
        __asm FADD QWORD PTR [fpone]; // ST := 2^frac
        __asm FSCALE;                 // ST := 2^frac * 2^integral
        __asm FSTP ST(1);             // FSCALE does not pop anything
    }

    __asm FSTP QWORD PTR [x];
    return x;

#else

// No choice at the moment - we have to use the CRT. We'll watch what
// Office does when they start caring about IA64.

#undef pow
    return pow(x,y);

#endif
}

/**************************************************************************\
*
* Function Description:
*
*   Out-of-line version of exp()
*
* Arguments:
*
*   x - input value
*
* Return Value:
*
*   e^x
*
* Notes:
*
*   Because we compile 'optimize for size', the compiler refuses to inline
*   calls to exp() - because its implementation is quite long. So, we
*   make an out-of-line version by setting the optimizations correctly
*   here, and generating an inline version. Yes, I agree completely.
*
* Created:
*
*   10/20/1999 agodfrey
*       Wrote it.
*
\**************************************************************************/

#pragma optimize("gt", on)

double
GpRuntime::Exp(
    double x
)
{
#undef exp
    return exp(x);
}
#pragma optimize("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\unicode.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Unicode strings
*
* Abstract:
*
*   Functions and classes which deal with Unicode strings
*
* Revision History:
*
*   12/21/1998 davidx
*       Created it.
*   09/08/1999 agodfrey
*       Moved to Runtime\unicode.hpp, from Common\utils.cpp
*   10/20/1999 agodfrey
*       In order to remove MSVCRT dependencies, I cleaned this up. I
*       moved in Unicode functions that had appeared in Runtime.cpp,
*       then merged the many duplicates.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Returns the length of a Unicode string. A replacement for wcslen.
*
* Arguments:
*
*   str - The input string
*
* Return Value:
*
*   The length of the string.
*
* Revision History:
*
*   09/27/1999 DChinn
*       Wrote it.
*   10/20/1999 AGodfrey
*       Moved to Unicode.cpp
*
\******************************************************************************/
size_t
GpRuntime::UnicodeStringLength(
    const WCHAR *str
    )
{
    size_t strLength = 0;

    // calculate string length in characters
    while (*str++ != '\0')
    {
        strLength++;
    }
    return strLength;
}

/**************************************************************************\
*
* Function Description:
*
*   Appends a Unicode string. A replacement for wcscat.
*
* Arguments:
*
*   dest - Null-terminated destination string
*   src  - Null-terminated source string
*
* Notes:
* 
*   The function appends "src" to "dest" and terminates
*   the resulting string with a null character. The initial character of
*   "src" overwrites the terminating null character of "dest".
*   No overflow checking is performed when strings are copied or appended. The
*   behavior is undefined if the source and destination strings
*   overlap.
*
* Return Value:
*
*   The destination string (dest).
*
* Revision History:
*
*   10/14/1999 MinLiu
*       Wrote it.
*   10/20/1999 AGodfrey
*       Moved it to Unicode.cpp; merged it with the existing concatenation
*       functions.
*
\******************************************************************************/
WCHAR *
GpRuntime::UnicodeStringConcat(
    WCHAR* dest, 
    const WCHAR* src
    )
{
    //  Move to end of dest
    while (*dest != NULL)
        ++dest;
    
    while (*src != NULL)
        *dest++ = *src++;

    //  Terminate destination string
    *dest = NULL;
    
    return dest;
}

/**************************************************************************\
*
* Function Description:
*
*   Duplicates a Unicode string. A replacement for wcsdup.
*
* Arguments:
*
*   src - Null-terminated source string
*
* Notes:
* 
*   Beware - unlike the C wcsdup, this one uses GpMalloc to allocate
*   the memory. The caller must use GpFree to deallocate it.
*
* Return Value:
*
*   A pointer to newly-allocated memory containing a copy of the input
*   string. The caller is responsible for freeing the string (via GpFree.)
*
* Revision History:
*
*   09/27/1999 DChinn
*       Wrote it.
*   10/20/1999 AGodfrey
*       Moved to Unicode.cpp
*
\******************************************************************************/
WCHAR *
GpRuntime::UnicodeStringDuplicate (
    const WCHAR *src
    )
{
    DWORD byteSize;
    WCHAR *ret;

    if (src == NULL)
    {
        ret = NULL;
    }    
    else 
    {
        byteSize = sizeof(WCHAR) * (UnicodeStringLength (src) + 1);
        ret = static_cast<WCHAR *>(GpMalloc (byteSize));
        
        if (ret)
        {
            // do the string copy (src is assumed to be null-terminated)
            GpMemcpy (ret, src, byteSize);
        }
    }        

    return ret;
}

/**************************************************************************\
*
* Function Description:
*
*   Copies a Unicode string. A replacement for wcscpy.
*
* Arguments:
*
*   dest - The destination buffer
*   src  - Null-terminated source string
*
* Return Value:
*
*   None
*
* Revision History:
*
*   10/20/1999 AGodfrey
*       Moved to Unicode.cpp
*
\******************************************************************************/
void 
GpRuntime::UnicodeStringCopy(
    WCHAR* dest, 
    const WCHAR* src
    )
{
    while (*src != NULL)
        *dest++ = *src++;

    //  Terminate destination string
    *dest = NULL;
}


/**************************************************************************\
*
* Function Description:
*
*   Copies a specified number of characters of a Unicode string.
*   A replacement for wcsncpy.
*
* Arguments:
*
*   dest - The destination buffer
*   src  - Null-terminated source string
*   count - number of characters to copy
*
* Return Value:
*
*   None
*
* Revision History:
*
*   03/29/2000 DChinn
*       Wrote it.
*
\******************************************************************************/
void
GpRuntime::UnicodeStringCopyCount(
    WCHAR *dest,
    const WCHAR *src,
    size_t count)
{
    for (UINT i = 0; (i < count) && (*src != NULL); i++)
    {
        *dest++ = *src++;
    }
    // null-pad the remaining characters in dest
    for ( ; i < count; i++)
    {
        *dest++ = 0;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Converts a string to all upper case.
*
*   [dchinn]
*   NOTE: This is naively implemented. It compares a string of character
*         codes, not a string of Unicode characters. You can't rely on:
* 
*   1) Unicode equality. There are apparently different codes representing
*      identical characters; this function doesn't know about them.
*
* Arguments:
*
*   str1 - the first string (input)
*   str2 - the second string (output)
*   str1 and str2 may be the same pointer.
*
* Return Value:
*   none.
*
* Revision History:
*
*   03/24/2000 DChinn
*       Wrote it.
\**************************************************************************/

void 
GpRuntime::UnicodeStringToUpper(
    WCHAR* dest,
    WCHAR* src
    )
{
    WCHAR char1;
    ASSERT(dest && src);
    
    while (*src != NULL)
    {
        char1 = *src;

        // change lower case to uppercase before copying
        if ( (char1 >= L'a') && (char1 <= L'z') )
                char1 = char1 - L'a' + L'A';

        *dest = char1;

        dest++;
        src++;
    }
    //  Terminate destination string
    *dest = NULL;
}


/**************************************************************************\
*
* Function Description:
*
*   Searches from the end of a Unicode string for a character.
*   A replacement for wcsrchr.
*
* Arguments:
*
*   str - The string
*   ch  - The character to find
*
* Return Value:
*
*   A pointer into the source string at the location of the character,
*   or NULL if not found. 
*
* Revision History:
*
*   10/22/1999 AGodfrey
*       Wrote it.
*
\******************************************************************************/
WCHAR *
GpRuntime::UnicodeStringReverseSearch(
    const WCHAR* str, 
    WCHAR ch
    )
{
    ASSERT(str);
    
    const WCHAR *result = NULL;
    
    while (*str)
    {
        if (*str == ch)
        {
            result = str;
        }
        str++;
    }
    return const_cast<WCHAR *>(result);
}

/**************************************************************************\
*
* Function Description:
*
*   Compares two wide character strings
*
*   [agodfrey]
*   NOTE: This is naively implemented. It compares a string of character
*         codes, not a string of Unicode characters. You can't rely on:
* 
*   1) Unicode ordering. Alphabetical ordering isn't guaranteed.
*   2) Unicode equality. There are apparently different codes representing
*      identical characters; this function doesn't know about them.
*
* Arguments:
*
*   str1 - the first string
*   str2 - the second string
*
* Return Value:
*   -1:    str1  < str2
*    0:    str1 == str2
*    1:    str1  > str2
*
* Revision History:
*
*   ??/??/???? ??????
*       Wrote it.
*   10/20/1999 AGodfrey
*       Added comment about how this isn't a real Unicode compare.
*
\**************************************************************************/

INT 
GpRuntime::UnicodeStringCompare(
    const WCHAR* str1, 
    const WCHAR* str2
    )
{

    ASSERT(str1 && str2);
    
    while (*str1 != NULL && *str2 != NULL)
    {
        if (*str1 < *str2)
            return -1;
        else if (*str1 > *str2)
            return 1;
        str1++;
        str2++;
    }

    if (*str2 != NULL)
        return -1;

    if (*str1 != NULL)
        return 1;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Compares two wide character strings
*
*   [agodfrey]
*   NOTE: This is naively implemented. It compares a string of character
*         codes, not a string of Unicode characters. You can't rely on:
* 
*   1) Unicode ordering. Alphabetical ordering isn't guaranteed.
*   2) Unicode equality. There are apparently different codes representing
*      identical characters; this function doesn't know about them.
*
* Arguments:
*
*   str1 - the first string
*   str2 - the second string
*
* Return Value:
*   -1:    str1  < str2
*    0:    str1 == str2
*    1:    str1  > str2
*
* Revision History:
*
*   ??/??/???? ??????
*       Wrote it.
*   10/20/1999 AGodfrey
*       Added comment about how this isn't a real Unicode compare.
*
*   3/08/00 YungT  
*       Added for comparsion ignored case
\**************************************************************************/

INT 
GpRuntime::UnicodeStringCompareCI(
    const WCHAR* str1, 
    const WCHAR* str2
    )
{
    WCHAR char1, char2;
    ASSERT(str1 && str2);
    
    while (*str1 != NULL && *str2 != NULL)
    {
        char1 = *str1;
        char2 = *str2;

        /* change lower case to uppercase before doing the comparaison */
        if ( (char1 >= L'a') && (char1 <= L'z') )
                char1 = char1 - L'a' + L'A';

        if ( (char2 >= L'a') && (char2 <= L'z') )
                char2 = char2 - L'a' + L'A';

        if (char1 < char2)
            return -1;
        else if (char1 > char2)
            return 1;

        str1++;
        str2++;
    }

    if (*str2 != NULL)
        return -1;

    if (*str1 != NULL)
        return 1;

    return 0;
}


/**************************************************************************\
*
* Function Description:
*
*   Compares two wide character strings
*
*   [agodfrey]
*   NOTE: This is naively implemented. It compares a string of character
*         codes, not a string of Unicode characters. You can't rely on:
* 
*   1) Unicode ordering. Alphabetical ordering isn't guaranteed.
*   2) Unicode equality. There are apparently different codes representing
*      identical characters; this function doesn't know about them.
*
* Arguments:
*
*   str1 - the first string
*   str2 - the second string
*   count - Maximum number of characters to consider
*
* Return Value:
*   -1:    str1  < str2
*    0:    str1 == str2
*    1:    str1  > str2
*
* Revision History:
*
*   ??/??/???? ??????
*       Wrote it.
*   10/20/1999 AGodfrey
*       Added comment about how this isn't a real Unicode compare.
*
\**************************************************************************/

INT 
GpRuntime::UnicodeStringCompareCount(
    const WCHAR* str1, 
    const WCHAR* str2,
    size_t count 
    )
{
    ASSERT(str1 && str2);
    
    while (*str1 != NULL && *str2 != NULL  && count)
    {
        if (*str1 < *str2)
            return -1;
        else if (*str1 > *str2)
            return 1;
        str1++;
        str2++;
        count--;
    }

    if (!count)
    {
        return 0;
    }

    if (*str2 != NULL)
        return -1;

    if (*str1 != NULL)
        return 1;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Compares two wide character strings, sort of case-insensitively for US English characters only
*
*   [agodfrey]
*   NOTE: This is naively implemented. It compares a string of character
*         codes, not a string of Unicode characters. You can't rely on:
* 
*   1) Unicode ordering. Alphabetical ordering isn't guaranteed.
*   2) Unicode equality. There are apparently different codes representing
*      identical characters; this function doesn't know about them.
*   [claudebe]
*   unicode string compare considering only count characters
*
* Arguments:
*
*   str1 - the first string
*   str2 - the second string
*   count - Maximum number of characters to consider
*
* Return Value:
*   -1:    str1  < str2
*    0:    str1 == str2
*    1:    str1  > str2
*
* Revision History:
*
*   ??/??/???? ??????
*       Wrote it.
*   10/20/1999 AGodfrey
*       Added comment about how this isn't a real Unicode compare.
*   01/11/2000 ClaudeBe
*       case insensitive comparison that deal only with Upper\Lower case
*
\**************************************************************************/

INT 
GpRuntime::UnicodeStringCompareCICount(
    const WCHAR* str1, 
    const WCHAR* str2,
    size_t count 
    )
{
    WCHAR char1, char2;
    ASSERT(str1 && str2);
    
    while (*str1 != NULL && *str2 != NULL  && count)
    {
        char1 = *str1;
        char2 = *str2;
        /* change lower case to uppercase before doing the comparaison */
        if ( (char1 >= L'a') && (char1 <= L'z') )
                char1 = char1 - L'a' + L'A';

        if ( (char2 >= L'a') && (char2 <= L'z') )
                char2 = char2 - L'a' + L'A';

        if (char1 < char2)
            return -1;
        else if (char1 > char2)
            return 1;
        str1++;
        str2++;
        count--;
    }

    if (!count)
    {
        return 0;
    }

    if (*str2 != NULL)
        return -1;

    if (*str1 != NULL)
        return 1;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Compares two wide character strings, case-insensitively. To avoid
*   Unicode case issues, you specify both the upper and lower-case versions
*   of the string you want to compare against.
*
* Arguments:
*
*   str1:  the first string
*   str2u: the second string, in upper case
*   str2l: the second string, in lower case
*
* Notes:
*   str2u and str2l must be the same length.
*
* Return Value:
*
*   TRUE if the strings are equal, FALSE otherwise.
*
* Revision History:
*
*   10/22/1999 AGodfrey
*       Wrote it.
*
\**************************************************************************/

BOOL 
GpRuntime::UnicodeStringIIsEqual(
    const WCHAR* str1, 
    const WCHAR* str2u, 
    const WCHAR* str2l
    )
{
    ASSERT(str1 && str2u && str2l);
    
    while (*str1 && *str2u)
    {
        ASSERT(*str2l);
        
        if ((*str1 != *str2u) &&
            (*str1 != *str2l))
        {
            return FALSE;
        }
        str1++;
        str2u++;
        str2l++;
    }

    if (*str1)
    {
        return FALSE;
    }
    
    if (*str2u)
    {
        return FALSE;
    }
    
    ASSERT(!*str2l);

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Return a copy of the string as a NUL-terminated C string.
*   Caller should call GpFree on the returned pointer after
*   it finishes using the C string.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   See above.
*
\**************************************************************************/

WCHAR*
GpRuntime::GpString::GetCString() const
{
    WCHAR* s;

    if (Buf == NULL)
        s = NULL;
    else if (s = (WCHAR*) GpMalloc((Len+1)*sizeof(WCHAR)))
    {
        GpMemcpy(s, Buf, Len*sizeof(WCHAR));
        s[Len] = L'\0';
    }
    else
    {
        WARNING(("Out of memory in GpString::GetCString()"));
    }

    return s;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\runtime.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   GDI+ runtime
*
* Abstract:
*
*   Definitions for GDI+ run-time library functions.
*   We're not allowed to use the C runtime library in free builds.
*   The GDI+ run-time library provides alternative definitions for the
*   functions we need.
*
*   Users of the GDI+ run-time library must be sure to call
*   GpRuntime::Initialize() and GpRuntime::Uninitialize() appropriately.
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   09/07/1999 agodfrey
*       Moved to the Runtime directory.
*
\**************************************************************************/

#ifndef _RUNTIME_HPP
#define _RUNTIME_HPP

#include <windows.h>

// math.h is needed for prototypes of the intrinsic math functions
// float.h is needed for FLT_EPSILON

#include <math.h>
#include <float.h>
#include <limits.h>

// DllInstance is initialized by the DLL entry point, or failing that
// by GpRuntime::Initialize();

extern HINSTANCE DllInstance;

// Object tags are used, instead of a BOOL, to determine if the object is
// valid or not.  To be valid, the tag must be equal to the ObjectTag enum.
// For consistency, the Tag field should be the 1st field within the object.
// The last char of each tag must be a 1.  The 1 stands for Version 1.
// [We make it the last character so that it is less likely to be confused
//  with a pointer value (since most pointers are DWORD aligned).]
// This will (hopefully) enable us to distinguish between objects
// that were created by different versions of GDI+.  (Assuming of course
// that we remember to increment that number in the next release of GDI+).
// Please try to keep the object tags unique.
enum ObjectTag
{
    ObjectTagInvalid                = 'LIAF',   // Object in Invalid State

    // external objects
    ObjectTagBrush                  = 'urB1',
    ObjectTagPen                    = 'neP1',
    ObjectTagPath                   = 'htP1',
    ObjectTagRegion                 = 'ngR1',
    ObjectTagImage                  = 'gmI1',
    ObjectTagFont                   = 'tnF1',
    ObjectTagFontFamily             = 'aFF1',
    ObjectTagFontCollection         = 'oCF1',
    ObjectTagStringFormat           = 'rtS1',
    ObjectTagImageAttributes        = 'tAI1',
    ObjectTagCustomLineCap          = 'CLC1',
    ObjectCachedBitmap              = 'mBC1',
    ObjectTagGraphics               = 'arG1',
    ObjectTagMatrix                 = 'taM1',
    ObjectTagPathIterator           = 'IaP1',
    
    // internal objects
    ObjectTagDpBitmap               = 'mBd1',
    ObjectTagDpDriver               = 'rDd1',
    ObjectTagDpRegion               = 'gRd1',
    ObjectTagDpRegionBuilder        = 'BRd1',
    ObjectTagGpRectBuilder          = 'BRg1',
    ObjectTagGpYSpanBuilder         = 'BSg1',
    ObjectTagGpBezier               = 'zBg1',
    ObjectTagGpCubicBezierIterator  = 'IBC1',
    ObjectTagDevice                 = 'veD1',
    ObjectTagPathReconstructor      = 'cRP1',
    ObjectTagPathWidener            = 'dWP1',
    ObjectTagXPath                  = 'aPX1',
    ObjectTagXPathIterator          = 'IPX1',
    ObjectTagDecodedImage           = 'IeD1',
    ObjectTagK2_Tetrahedral         = 'T2K1',
    ObjectTagBitmapScaler           = 'cSB1',
    ObjectTagBmpDecoder             = 'DmB1',
    ObjectTagGifBuffer              = 'BfG1',
    ObjectTagGifOverflow            = 'OfG1',
    ObjectTagCmyk2Rgb               = 'R2C1',
    ObjectTagTiffCodec              = 'CfT1',
    ObjectTagConvertToGdi           = 'GvC1',
    ObjectTagOutputNativePostscript = 'sPO1',
    ObjectTagOutputGradientSpan     = 'SGO1',
    ObjectTagTriangleData           = 'DrT1',
    ObjectTagPaletteMap             = 'MaP1',
    ObjectTagScanBufferNative       = 'NBS1',
    ObjectTagAnsiStrFromUnicode     = 'UFA1',
    ObjectTagUnicodeStrFromAnsi     = 'AFU1',
    ObjectTagEmfPlusCommentStream   = 'SCE1',
    ObjectTagMetafileRecorder       = 'cRM1',
};

#if PROFILE_MEMORY_USAGE
#include "..\..\tools\memcounter\memcounter.h"
#endif

#include "mem.h"
#include "debug.h"

#include "..\..\sdkinc\GdiplusEnums.h"
#include "..\..\sdkinc\GdiplusTypes.h"
#include "..\..\sdkinc\GdiplusInit.h"
#include "..\..\sdkinc\GdiplusPixelFormats.h"
#include "..\..\sdkinc\GdiplusColor.h"
#include "..\..\sdkinc\GdiplusColorMatrix.h"
#include "..\..\sdkinc\GdiplusMetaHeader.h"
#include <objbase.h>
#include "..\..\sdkinc\GdiplusImaging.h"

#include "enums.hpp"

namespace GpRuntime {
    BOOL Initialize();
    void Uninitialize();
};

#include "BaseTypes.hpp"
#include "Lockable.hpp"
#include "Unicode.hpp"
#include "OSInfo.hpp"
#include "Real.hpp"
#include "fix.hpp"
#include "critsec.hpp"
#include "AutoPointers.hpp"

namespace GpRuntime {
    void *GpMemmove(void *dest, const void *src, size_t count);
    UINT Gppow2 (UINT exp);
    UINT Gplog2 (UINT x);
    extern HANDLE GpMemHeap;
};

// TODO: One day when each of our modules has
//       its own namespace, remove this using directive.

using namespace GpRuntime;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\unicode.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Unicode strings
*
* Abstract:
*
*   Functions and classes which deal with Unicode strings
*
* Revision History:
*
*   02/22/1999 davidx
*       Created it.
*   09/08/1999 agodfrey
*       Moved to Runtime\unicode.hpp
*
\**************************************************************************/

#ifndef _UNICODE_HPP
#define _UNICODE_HPP

namespace GpRuntime
{
    
// These are replacements for some of the C runtime functions.

size_t  UnicodeStringLength(const WCHAR *str);
WCHAR * UnicodeStringDuplicate(const WCHAR *strSource);
INT     UnicodeStringCompare(const WCHAR *str1, const WCHAR *str2);
extern "C" INT     UnicodeStringCompareCI(const WCHAR *str1, const WCHAR *str2);
INT     UnicodeStringCompareCount(const WCHAR* str1, const WCHAR* str2, size_t count);
INT     UnicodeStringCompareCICount(const WCHAR* str1, const WCHAR* str2, size_t count);
void    UnicodeStringCopy(WCHAR *dest, const WCHAR *src);
void    UnicodeStringCopyCount(WCHAR *dest, const WCHAR *src, size_t count);
void    UnicodeStringToUpper(WCHAR* dest, WCHAR* src);
WCHAR * UnicodeStringConcat(WCHAR *dest, const WCHAR *src);
WCHAR * UnicodeStringReverseSearch(const WCHAR* str, WCHAR ch);
BOOL    UnicodeStringIIsEqual(
    const WCHAR* str1, 
    const WCHAR* str2u, 
    const WCHAR* str2l
    );

inline BOOL
UnicodeToAnsiStr(
    const WCHAR* unicodeStr,
    CHAR* ansiStr,
    INT ansiSize
    )
{
    return WideCharToMultiByte(
                CP_ACP,
                0,
                unicodeStr,
                -1,
                ansiStr,
                ansiSize,
                NULL,
                NULL) > 0;
}

class AnsiStrFromUnicode
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagAnsiStrFromUnicode : ObjectTagInvalid;
    }

public:

    AnsiStrFromUnicode(const WCHAR* unicodeStr)
    {
        if (unicodeStr == NULL)
        {
            SetValid(TRUE);
            ansiStr = NULL;
        }
        else
        {
            SetValid(UnicodeToAnsiStr(unicodeStr, buf, MAX_PATH));
            ansiStr = IsValid() ? buf : NULL;
        }
    }

    ~AnsiStrFromUnicode()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagAnsiStrFromUnicode) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid AnsiStrFromUnicode");
        }
    #endif

        return (Tag == ObjectTagAnsiStrFromUnicode);
    }

    operator CHAR*()
    {
        return ansiStr;
    }

private:

    CHAR* ansiStr;
    CHAR buf[MAX_PATH];
};

inline BOOL
AnsiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
    )
{
    return MultiByteToWideChar(
                CP_ACP,
                0,
                ansiStr,
                -1,
                unicodeStr,
                unicodeSize) > 0;
}

class UnicodeStrFromAnsi
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagUnicodeStrFromAnsi : ObjectTagInvalid;
    }

public:

    UnicodeStrFromAnsi(const CHAR* ansiStr)
    {
        if (ansiStr == NULL)
        {
            SetValid(TRUE);
            unicodeStr = NULL;
        }
        else
        {
            SetValid(AnsiToUnicodeStr(ansiStr, buf, MAX_PATH));
            unicodeStr = IsValid() ? buf : NULL;
        }
    }

    ~UnicodeStrFromAnsi()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagUnicodeStrFromAnsi) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid UnicodeStrFromAnsi");
        }
    #endif

        return (Tag == ObjectTagUnicodeStrFromAnsi);
    }

    operator WCHAR*()
    {
        return unicodeStr;
    }

private:

    WCHAR* unicodeStr;
    WCHAR buf[MAX_PATH];
};

//--------------------------------------------------------------------------
// Represent a simple immutable Unicode string object used internally
// by GDI+ implementation. A string is represented by pieces of
// information:
//  - pointer to the character buffer
//  - number of characters in the string
//
// [agodfrey] Ack! Yet another string class. I'm just moving it here
// to be with its mates. It came from BaseTypes.hpp.
//--------------------------------------------------------------------------

class GpString
{
public:

    // NOTE:
    //  We're not making a copy of the characters here. Instead,
    //  we simply remember the character pointer. We assume the
    //  caller will ensure the input pointer's lifetime is longer
    //  than that of the newly constructed GpString object.

    GpString(const WCHAR* str, UINT len)
    {
        Buf = str;
        Len = len;
    }

    GpString(const WCHAR* str)
    {
        Buf = str;
        Len = UnicodeStringLength(str);
    }

    BOOL IsNull() const
    {
        return Buf == NULL;
    }

    const WCHAR* GetBuf() const
    {
        return Buf;
    }

    UINT GetLen() const
    {
        return Len;
    }

    // Return a copy of the string as a NUL-terminated C string.
    // Caller should call GpFree on the returned pointer after
    // it finishes using the C string.

    WCHAR* GetCString() const;

protected:

    const WCHAR* Buf;
    UINT Len;
};

}


#endif // !_UNICODE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\staticlib\staticflatapi.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   StaticFlatApi.cpp
*
* Abstract:
*
*   Flat GDI+ API wrappers for the static lib
*
* Revision History:
*
*   3/23/2000 dcurtis
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "StaticFlat.h"

#if DBG
#include <mmsystem.h>
#endif


// GillesK
// Forward declaration of GdipGetWinMetaFileBitsStub which is in
// gpmf3216
#ifdef __cplusplus
extern "C" {
#endif

//--------------------------------------------------------------------------
//  CheckParameter(p)
//
//     If p evaluates to FALSE, then we currently assert.  In future,
//     we can simply return an invalid parameter status which throws
//     an exception.
//
//  CheckObjectBusy(p)
//
//     Not implemented.  Bails out if object is currently being used.
//
//--------------------------------------------------------------------------
//
// !!!: Only include NULL & IsValid checks in checked builds?
//
// !!!: Instead of deleting object, call a Dispose() method, so far
//       only Bitmap supports this.
//
// !!!: Lock Matrix objects, what about color?

#define CheckParameter(cond) \
            if (! (cond)) \
                return InvalidParameter;

#define CheckParameterValid(obj) \
            if (!obj || !(obj->IsValid())) \
                return InvalidParameter;

#define CheckObjectBusy(obj) \
      GpLock lock##obj(obj->GetObjectLock()); \
      if (!(lock##obj).IsValid()) \
            return ObjectBusy;

#define CheckFontParameter(font) \
            if (!(font) || !((font)->IsValid())) \
                return InvalidParameter;


#ifdef __cplusplus
} // end of extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\office\mem.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   GDI+ memory allocation functions
*
* Abstract:
*
*   This module is the Office counterpart of runtime\standalone\mem.cpp which
*   provides GpMalloc, GpRealloc and GpFree.
*
*   We use it to provide the stubs for memory management debugging functions
*   that we don't use in office. These stubs prevent compilation errors and
*   serve to keep the header files cleaner.
*
* Notes:
*
*   Office provides their own versions of these functions, so they're not
*   included here.
*
* Created:
*
*   09/19/1999 asecchia
*
\**************************************************************************/

#include "precomp.hpp"

// these guys need to be defined, but they're going to be compiled away.
void GpInitializeAllocFailures() {}
void GpDoneInitializeAllocFailureMode() {}
void GpStartInitializeAllocFailureMode() {}
void GpAssertMemoryLeaks() {}



#if DBG

// We don't track anything if we're building for the office static lib.

#if GPMEM_ALLOC_CHK_LIST

#undef GpMalloc
extern "C" void *GpMalloc(size_t size);

extern "C" void *GpMallocAPIDebug(size_t size, unsigned int caddr, char *fileName, INT lineNumber)
{
    return GpMalloc(size);
}

extern "C" void *GpMallocDebug(size_t size, char *fileName, INT lineNumber)
{

    return GpMalloc(size);
}

#else

extern "C" void * GpMallocAPI( size_t size, unsigned int caddr )
{
    return GpMalloc(size);
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\staticlib\precomp.hpp ===
#include "..\Runtime\Runtime.hpp"
#include "..\Common\Common.hpp"
#include "..\Flat\gpverp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\runtime\standalone\mem.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   GDI+ memory allocation functions
*
* Abstract:
*
*   This module provides GpMalloc, GpRealloc and GpFree.
*
* Notes:
*
*   Office provides their own versions of these functions.
*
* Created:
*
*   07/08/1999 agodfrey
*
\**************************************************************************/

#include "precomp.hpp"



#if GPMEM_ALLOC_CHK

#include <time.h>
#include <stdlib.h>

// Size of the start and end memory guards (DWORDS)
// Probably should be QWORD aligned (even number).

const unsigned int GPMEM_GUARD_START = 0x10;
const unsigned int GPMEM_GUARD_END   = 0x10;
const unsigned int GPMEM_GS = GPMEM_GUARD_START*sizeof(DWORD);
const unsigned int GPMEM_GE = GPMEM_GUARD_END*sizeof(DWORD);

const unsigned char GPMEM_FILL_ALLOC = 0xbf;
const unsigned char GPMEM_FILL_GS    = 0xac;
const unsigned char GPMEM_FILL_GE    = 0xfe;
const unsigned char GPMEM_FILL_FREE  = 0x73;

#define GPMEM_ALLOC_TRACKING 1
#define GPMEM_ALLOC_FILL     1

enum AllocTrackHeaderFlags
{
    MemoryAllocated     = 0x00000001,
    MemoryFreed         = 0x00000002,     // useful in catching double frees
    APIAllocation       = 0x00000004
};
// Head of every tracked allocation.

struct AllocTrackHeader {
  struct AllocTrackHeader *flink;
  struct AllocTrackHeader *blink;
  DWORD  size;
  DWORD  caller_address;
  DWORD  flags;
#if GPMEM_ALLOC_CHK_LIST
  char  *callerFileName;
  INT    callerLineNumber;
#endif
};

#define GPMEM_OVERHEAD (GPMEM_GS + GPMEM_GE + sizeof(AllocTrackHeader))

// Head of double linked list of tracked memory allocations.

AllocTrackHeader *gpmemAllocList=NULL;

// An allocation fails if rand() < gpmemDefFailRate (gpmemInitFailRate for
// gdiplus initialization code.
// set to RAND_MAX/2 if you want 50% failure rate, 0 if you want no failures.
//
// The system starts off failing allocations at a rate specified by
// gpmemInitFailRate. Once GpDoneInitializeAllocFailureMode() is called,
// allocations are failed at the rate specified by gpmemDefFailRate().
// This is so that dll initialization code can have a different fail rate
// to regular code.

int gpmemInitFailRate = 0;
int gpmemDefFailRate = 0;

// This would give a failure rate of 25%
// int gpmemDefFailRate = (RAND_MAX/4)

BOOL gpmemDoneInitialization = FALSE;

// Some statistics
struct AllocTrackStats {
  // Totals over the entire run

  long CumulativeAllocations;   // The number of calls to GpMalloc or GpRealloc
  long CumulativeMemorySize;    // Cumulative total of allocated memory
  long CumulativeReallocs;      // The number of calls to GpRealloc
  long ForcedFailures;
  long AllocationFailures;

  // Current values

  long OutstandingAllocations;  // The number of allocation requests
  long OutstandingMemorySize;   // The amount of memory currently allocated

  // Maxima of the 'Outstanding' values

  long MaxAllocations;          // The maximum of OutstandingAllocations
  long MaxMemorySize;           // The maximum of OutstandingMemorySize

  void Allocated(long size)
  {
      size -= GPMEM_OVERHEAD;

      CumulativeMemorySize += size;
      OutstandingMemorySize += size;
      if (OutstandingMemorySize > MaxMemorySize)
      {
          MaxMemorySize = OutstandingMemorySize;
      }
      CumulativeAllocations++;
      OutstandingAllocations++;
      if (OutstandingAllocations > MaxAllocations)
      {
          MaxAllocations = OutstandingAllocations;
      }
  }

  void Freed(long size)
  {
      size -= GPMEM_OVERHEAD;

      OutstandingMemorySize -= size;
      OutstandingAllocations--;
  }
};

AllocTrackStats gpmemAllocTotal = {0};


// Hash Table for tracking memory allocations sorted by callsite.
// This table stores some total memory usage statistics for each
// callsite.
// Turn this on by setting GPMEM_DEBUG_SORT 1

#define GPMEM_DEBUG_SORT 0
#if GPMEM_DEBUG_SORT

struct HashMem {
  long callsite;
  long size;
  long count;
};

// It is very important that this hash size be larger than the number of
// possible callsites for GpMalloc.
//
// Set HASHSIZE to some big prime number.

#define HASHSIZE 1069
HashMem HashTable[HASHSIZE];

// Hashing algorithm.
long Hash(long cs) {
  long tmp = cs % HASHSIZE;
  long tmploop = tmp;
  while( (HashTable[tmp].callsite != 0) &&
         (HashTable[tmp].callsite != cs) ) {
    tmp++;
    if(tmp>=HASHSIZE) tmp=0;
    if(tmp==tmploop) return -1;
  }
  return tmp;
}
#endif

#endif



/**************************************************************************\
*
* Function Description:
*
*   Do we fail this memory allocation?
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/20/1999 asecchia
*       Created it.
*
\**************************************************************************/


#if GPMEM_ALLOC_CHK
BOOL GpFailMemoryAllocation() {
  int rndnum = rand();
  if(gpmemDoneInitialization)
  {
      if(rndnum<gpmemDefFailRate)
      {
          return TRUE;
      }
  }
  else
  {
    if(rndnum<gpmemInitFailRate)
    {
        return TRUE;
    }
  }
  return FALSE;
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Initializes the random seed.
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/20/1999 asecchia
*       Created it.
*
\**************************************************************************/

void GpInitializeAllocFailures() {
  #if GPMEM_ALLOC_CHK
  srand((unsigned)time(NULL));
  #endif
}


/**************************************************************************\
*
* Function Description:
*
*   Sets the flag indicating that we're done initialization code and
*   we're now into regular code. The memory failure mode changes based
*   on the value of this flag.
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/20/1999 asecchia
*       Created it.
*
\**************************************************************************/

void GpDoneInitializeAllocFailureMode() {
  #if GPMEM_ALLOC_CHK
  gpmemDoneInitialization=TRUE;
  #endif
}

void GpStartInitializeAllocFailureMode() {
  #if GPMEM_ALLOC_CHK
  gpmemDoneInitialization=FALSE;
  #endif
}




/**************************************************************************\
*
* Function Description:
*
*   Asserts that there are no memory leaks. Called just before process
*   termination, the list of allocated memory blocks should be NULL indicating
*   that all allocated memory was properly disposed. Any memory that relies on
*   process termination to clean up is leaked and provision should be made
*   for appropriate cleanup.
*
* Arguments: [NONE]
* Return Value: [NONE]
*
* History:
*
*   09/19/1999 asecchia
*       Created it.
*
\**************************************************************************/


#if GPMEM_ALLOC_CHK_LIST
char *skipGdiPlus(char *s) {
    // Quick hack to return pointer just beyond 'gdiplus'

    INT i = 0;
    while (    s[i] != 0
           &&  (    s[i] != 'g' &&  s[i] != 'G'
                ||  CompareStringA(
                        LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                        s+i, 7,
                        "gdiplus", 7) != CSTR_EQUAL))
    {
        i++;
    }
    if (    CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, s+i, 7, "gdiplus", 7) == CSTR_EQUAL
        &&  s[i+7] != 0)
    {
        return s + i + 8;   // Skip over 'gdiplus/'
    }
    else
    {
        return s; // Didn't find gdiplus so return the whole string
    }
}
#endif


void GpAssertMemoryLeaks() {
  #if GPMEM_ALLOC_CHK
  // If we're playing with the tracking headers, we need to be thread safe.
  GpMallocTrackingCriticalSection critsecobj;


  #if GPMEM_ALLOC_CHK_LIST

  // Report up to 100 leaked headers

  if (gpmemAllocList)
  {
      INT i=0; INT j=0;
      AllocTrackHeader *header = gpmemAllocList;
      while (header  && j < 100)
      {
          if (i % 20 == 0)  // Title every so often
          {
              WARNING(("Address- --Size-- API -Caller- -Line- File"));
          }

          // Drop everything up to 'gdiplus' off the filename string

          char str[200];
          lstrcpynA(str, skipGdiPlus(header->callerFileName), 200);

          WARNING((
              "%p %8d %-3.3s %p %6d %s",
              header,
              header->size,
              header->flags & APIAllocation ? "API" : "",
              header->caller_address,
              header->callerLineNumber,
              str
          ));
          header = header->flink;

          i++; j++;
      }
  }
  #endif


  ASSERTMSG(gpmemAllocList==NULL,
           ("Memory leaks detected. Use !gpexts.dmh 0x%p to dump header",
            gpmemAllocList));


  // Display the report stored in the Hash Table
  #if GPMEM_DEBUG_SORT
  for(int i=0; i<HASHSIZE; i++) {
    if(HashTable[i].callsite != 0) {
      WARNING(("%4d callsite %p size %8d count %8d", i, HashTable[i].callsite,
               HashTable[i].size, HashTable[i].count));
    }
  }
  #endif

  #endif
}




/**************************************************************************\
*
* Function Description:
*
*   Allocates a block of memory.
*
* Arguments:
*
*   [IN] size - number of bytes to allocate
*
* Return Value:
*
*   A pointer to the new block, or NULL on failure.
*
* History:
*
*   09/14/1999 asecchia
*       Added the checked build memory guard code.
*   07/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

/*
Here's the structure of the memory block allocated under GPMEM_ALLOC_CHK

|+AllocTrackHeader Two DWORDS - contains
|  |+flink
|  |  Pointer to the next memory allocation in the tracked allocation list
|  |+blink
|  |  Pointer to the previous memory allocation in the tracked allocation link
|
|+Guard Area
|  GPMEM_GUARD_START DWORDs filled with the gpmemGuardFill string.
|
|+Data Area
|  This is the location we return to the caller. It is pre-initialized to
|  the repeated DWORD value in gpmemAllocFillBlock (usually 0xbaadf00d)
|
|+Guard Area:
|  GPMEM_GUARD_END DWORDs filled with gpmemGuardFill string.

*/


#if GPMEM_ALLOC_CHK_LIST
extern "C" void *GpMallocDebug(size_t size, char *fileName, INT lineNumber)
#else
extern "C" void *GpMalloc(size_t size)
#endif
{

    #if GPMEM_ALLOC_CHK
        // If we're playing with the tracking headers, we need to be thread safe.
        GpMallocTrackingCriticalSection critsecobj;

        // Lets stash the caller address in the header block for future
        // reference.
        // this code needs to be at the beginning of the function so that
        // ebp hasn't been modified yet.
        DWORD calleraddr=0;
        #if defined(_X86_)
        _asm{
          mov eax, DWORD PTR [ebp+4]
          mov calleraddr, eax
        }
        #endif

        //
        // Memory? _Real_ programmers don't need memory!
        //
        if(GpFailMemoryAllocation()) {
            gpmemAllocTotal.AllocationFailures++;
            gpmemAllocTotal.ForcedFailures++;
            return NULL;
        }

        //
        // Make the allocation request a multiple of a QWORD
        //
        if(size & (sizeof(DWORD)*2-1))
        {
          size = (size & ~(sizeof(DWORD)*2-1)) + sizeof(DWORD)*2;
        }

        size_t origsize = size;

        //
        // Allocate space for the FLink and BLink
        //
        size += sizeof(AllocTrackHeader);

        if(GPMEM_GUARD_START)
        {
          size += GPMEM_GS;
        }

        if(GPMEM_GUARD_END)
        {
          size += GPMEM_GE;
        }

        void *tmpalloc = LocalAlloc(LMEM_FIXED, size);
        if(!tmpalloc)
        {
            gpmemAllocTotal.AllocationFailures++;
            return NULL;
        }

        ASSERTMSG(LocalSize(tmpalloc) >= size,
                  ("GpMalloc() allocated %d, but requested %d bytes",
                   LocalSize(tmpalloc), size));

        // Add the per-callsite allocation statistics
        #if GPMEM_DEBUG_SORT
        long hidx = Hash(calleraddr);
        if(hidx>=0) {
            HashTable[hidx].callsite = calleraddr;
            HashTable[hidx].size += size-GPMEM_OVERHEAD;
            HashTable[hidx].count ++;
        } else {
          WARNING(("Hash Table too small - increase HASHSIZE"));
        }
        #endif

        gpmemAllocTotal.Allocated(size);
    #else
        //
        // This is the only piece of code that's executed if
        // GPMEM_ALLOC_CHK is turned off.
        //
        return LocalAlloc(LMEM_FIXED, size);
    #endif


    #if GPMEM_ALLOC_CHK
        //
        // Fill up the entire allocation with the value
        // set in GPMEM_FILL_ALLOC
        //
        if(GPMEM_ALLOC_FILL)
        {
            GpMemset((unsigned char *)tmpalloc + sizeof(AllocTrackHeader) + GPMEM_GS,
                     GPMEM_FILL_ALLOC,
                     origsize);
        }

        //
        // Fill up the start guard area - if we have one.
        //
        if(GPMEM_GUARD_START)
        {
            unsigned char *p = (unsigned char *)tmpalloc+sizeof(AllocTrackHeader);
            GpMemset(p, GPMEM_FILL_GS, GPMEM_GS);
        }

        //
        // Fill up the end guard area - if we have one.
        //
        if(GPMEM_GUARD_END)
        {
            unsigned char *p = (unsigned char *)tmpalloc+size-GPMEM_GE;
            GpMemset(p, GPMEM_FILL_GE, GPMEM_GE);
        }

        //
        // setup the double linked-list to track all pool allocations.
        //
        AllocTrackHeader *hdr = (AllocTrackHeader *)tmpalloc;
        hdr->size = size;
        hdr->caller_address = calleraddr;
        hdr->flags = MemoryAllocated;

        #if GPMEM_ALLOC_CHK_LIST
        hdr->callerFileName = fileName;
        hdr->callerLineNumber = lineNumber;
        #endif

        if(GPMEM_ALLOC_TRACKING)
        {
            hdr->blink = NULL;
            hdr->flink = gpmemAllocList;
            if(gpmemAllocList)
            {
                gpmemAllocList->blink = (AllocTrackHeader *)tmpalloc;
            }
            gpmemAllocList = (AllocTrackHeader *)tmpalloc;
        }
        else
        {
            GpMemset(hdr, 0, sizeof(AllocTrackHeader));
        }

        //
        // Give them a pointer just after the guard bits.
        //
        return (char *)tmpalloc+sizeof(AllocTrackHeader)+GPMEM_GS;
    #endif
}

/**************************************************************************\
*
* Function Description:
*    Allocates memory for routines that allocate on behalf of someone else
*    Used on debug builds to set the correct caller address.
*
* Arguments:
*    [IN] size - size to pass to GpMalloc
*    [IN] caddr - address of the caller
*
* Return Value:
*    Returns the memory with the appropriately hacked up caller address
*
* History:
*
*   12/08/1999 asecchia
*       Created it.
*
\**************************************************************************/

#if GPMEM_ALLOC_CHK
extern "C" void *GpMallocC(size_t size, DWORD caddr)
{
    // If we're playing with the tracking headers, we need to be thread safe.
    GpMallocTrackingCriticalSection critsecobj;

    void *p = GpMalloc(size);
    if(p)
    {
        AllocTrackHeader *hdr = (AllocTrackHeader *)(
            (unsigned char *)p-(GPMEM_GS+sizeof(AllocTrackHeader)));
        hdr->caller_address = caddr;
    }
    return p;
}
#endif

/**************************************************************************\
*
* Function Description:
*    Allocates memory for APIs. Used to track the memory with a separate
*    identifying flag so that API allocations can be distinguished from
*    internal allocations.
*    Used on debug builds.
*
* Arguments:
*    [IN] size - size to pass to GpMalloc
*
* Return Value:
*    Returns the memory with the appropriately hacked up caller address
*
* History:
*
*   4/30/2000 asecchia
*       Created it.
*
\**************************************************************************/

#if DBG
#if GPMEM_ALLOC_CHK

#if GPMEM_ALLOC_CHK_LIST
extern "C" void * __stdcall GpMallocAPIDebug(size_t size, unsigned int caddr, char *fileName, INT lineNumber)
#else
extern "C" void *GpMallocAPI(size_t size, unsigned int caddr)
#endif
{
    // If we're playing with the tracking headers, we need to be thread safe.
    GpMallocTrackingCriticalSection critsecobj;

    #if GPMEM_ALLOC_CHK_LIST
    void *p = GpMallocDebug(size, fileName, lineNumber);
    #else
    void *p = GpMalloc(size);
    #endif

    if(p)
    {
        AllocTrackHeader *hdr = (AllocTrackHeader *)(
            (unsigned char *)p-(GPMEM_GS+sizeof(AllocTrackHeader)));
        hdr->flags |= APIAllocation;
        hdr->caller_address = caddr;
    }
    return p;
}

#else

extern "C" void *GpMallocAPI(size_t size, DWORD caddr)
{
    return GpMalloc(size);
}

#endif
#endif

/**************************************************************************\
*
* Function Description:
*
*   Computes the original size of a memory block allocated under GPMEM_ALLOC_CHK
*
* Arguments:
*
*   [IN] p - current memory block
*
* Return Value:
*
*   size of the original request for a memory block (i.e. excluding guard
*   areas, headers, etc). The size returned is the DWORD aligned size - so it
*   may differ slighly from the original size requested.
*
* Notes:
*
*   Returns a size of zero if called with NULL
*   Only compiled under GPMEM_ALLOC_CHK
*
* History:
*
*   09/14/1999 asecchia
*       Created it.
*
\**************************************************************************/

#if GPMEM_ALLOC_CHK
extern "C" size_t GpSizeBlock(void *p)
{
  if(p)
  {
      // Find the beginning of the allocated block header.
      p = (char *)p-(GPMEM_GS+sizeof(AllocTrackHeader));
      // Compute the size of the allocated block's data area.
      return (((AllocTrackHeader *)p)->size -
              (GPMEM_GS+GPMEM_GE+sizeof(AllocTrackHeader)));
  }
  else
  {
      return 0;
  }
}
#else
// Non-debug build, just call LocalSize
#define GpSizeBlock(p) LocalSize(p)
#endif


/**************************************************************************\
*
* Function Description:
*
*   Reallocates a memory block.
*
* Arguments:
*
*   [IN] memblock - current memory block
*   [IN] size - new allocation size
*
* Return Value:
*
*   A pointer to the new block, or NULL on failure.
*
* Notes:
*
*   If size is 0, frees the block.
*   If memblock is NULL, allocates a new block.
*   (If both, does nothing.)
*
*   LocalReAlloc only grows if it can expand the current allocation
*   - otherwise it fails.
*
* History:
*
*   09/14/1999 asecchia
*       Added the checked build memory guard code.
*   07/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

// Hack up GpMalloc for debug version of GpRealloc
#if GPMEM_ALLOC_CHK
    #define GpMallocForRealloc(a) GpMallocC(a, calleraddr)
#else
    #define GpMallocForRealloc(a) GpMalloc(a)
#endif

extern "C" void *GpRealloc(void *memblock, size_t size)
{
    #if GPMEM_ALLOC_CHK
    gpmemAllocTotal.CumulativeReallocs++;

    // Lets stash the caller address in the header block for future
    // reference.
    // this code needs to be at the beginning of the function so that
    // ebp hasn't been modified yet.
    DWORD calleraddr=0;
    #if defined(_X86_)
    _asm {
      mov eax, DWORD PTR [ebp+4]
      mov calleraddr, eax
    }
    #endif
    #endif

    if (!size)
    {
        GpFree(memblock);
        return NULL;
    }
    if (!memblock)
    {
        return GpMallocForRealloc(size);
    }
    VOID *  p = GpMallocForRealloc(size);
    if (p != NULL)
    {
        size_t oldSize = GpSizeBlock(memblock);

        if (oldSize > size)
        {
            oldSize = size;
        }
        GpMemcpy(p, memblock, oldSize);
        GpFree(memblock);
    }
    return p;
}

// UnHack GpMalloc
#undef GpMalloc
/**************************************************************************\
*
* Function Description:
*
*   Frees a block of memory.
*
* Arguments:
*
*   [IN] memblock - block to free
*
* Notes:
*
*   If memblock is NULL, does nothing.
*
* History:
*
*   09/14/1999 asecchia
*       Added the checked build memory guard code.
*   07/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

extern "C" void GpFree(void *memblock)
{
    #if GPMEM_ALLOC_CHK
        // If we're playing with the tracking headers, we need to be thread safe.
        GpMallocTrackingCriticalSection critsecobj;

        if(memblock)
        {
            memblock = (unsigned char *)memblock-(GPMEM_GS+sizeof(AllocTrackHeader));


            // Let's do the header stuff.

            AllocTrackHeader *hdr = (AllocTrackHeader *)memblock;
            DWORD size = hdr->size;
            gpmemAllocTotal.Freed(size);

            ASSERTMSG((hdr->flags & MemoryAllocated) &&
                      !(hdr->flags & MemoryFreed),
                      ("GpFree() already freed memory %p (freed by GpFree())",
                       memblock));

            hdr->flags &= ~MemoryAllocated;
            hdr->flags |= MemoryFreed;

            ASSERTMSG(LocalSize(memblock) >= hdr->size,
                      ("GpFree() already freed memory %p (freed somewhere else?)"
                       " local size=%d, size=%d",
                       memblock,
                       LocalSize(memblock),
                       hdr->size));

            if(GPMEM_ALLOC_TRACKING)
            {
                // Useful on checked Win2k builds because they fill guard
                // area with 0xFEEEFEEE

                ASSERTMSG((hdr->flink == NULL) ||
                          ((DWORD)((ULONG_PTR)(hdr->flink->blink) & 0xFFFFFFFF) != 0xFEEEFEEE),
                          ("GpFree() updating forward link to freed page, header %p",
                           memblock));

                ASSERTMSG((hdr->blink == NULL) ||
                          ((DWORD)((ULONG_PTR)(hdr->blink->flink) & 0xFFFFFFFF) != 0xFEEEFEEE),
                          ("GpFree() updating backward link to freed page, header %p",
                           memblock));

                if(hdr->flink) hdr->flink->blink = hdr->blink;
                if(hdr->blink) hdr->blink->flink = hdr->flink;
                if(gpmemAllocList==memblock) gpmemAllocList = hdr->flink;
            }
            else
            {
                ASSERTMSG(hdr->flink==NULL, ("GpFree() corrupt header %p", memblock));
                ASSERTMSG(hdr->blink==NULL, ("GpFree() corrupt header %p", memblock));
            }

            int i;
            unsigned char *p;

            // Check the start guard area

            if(GPMEM_GUARD_START)
            {
                p = (unsigned char *)memblock+sizeof(AllocTrackHeader);
                for(i=0; i<GPMEM_GS; i++)
                {
                    ASSERTMSG(*p==GPMEM_FILL_GS, ("GpFree() pre-guard area corrupt %p", memblock));
                    p++;
                }
            }

            // Check the end guard area

            if(GPMEM_GUARD_END)
            {
                p = (unsigned char *)memblock+size-GPMEM_GE;
                for(i=0; i<GPMEM_GE; i++)
                {
                    ASSERTMSG(*p==GPMEM_FILL_GE, ("GpFree() post-guard area corrupt %p", memblock));
                    p++;
                }
            }

            // Now lets fill the entire block with something to prevent
            // use of free data.

            GpMemset(memblock, GPMEM_FILL_FREE, size);
        }

    #endif

    // LocalFree handles memblock==NULL (according to MSDN.)

    HLOCAL ret = LocalFree(memblock);
    ASSERTMSG(ret == NULL, ("LocalFree() failed at %p, GetLastError()=%08x",
                            memblock,
                            GetLastError()));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\staticlib\staticflat.h ===
/**************************************************************************\
*
* Copyright (c) 2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   StaticFlat.h
*
* Abstract:
*
*   Flat GDI+ API wrappers for the static lib
*
* Revision History:
*
*   3/23/2000 dcurtis
*       Created it.
*
\**************************************************************************/

#ifndef _STATICFLAT_H
#define _STATICFLAT_H

#define WINGDIPAPI __stdcall

// currently, only C++ wrapper API's force const.

#ifdef _GDIPLUS_H
#define GDIPCONST const
#else
#define GDIPCONST
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif

#endif // !_STATICFLAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\sources.inc ===
!include ..\..\..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\bidianalysis.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   Unicode Bidirectional character analysis
*
* Abstract:
*
*   Implements Unicode version 3.0 Bidirectional algorithm
*
* Notes:
*
*   - The only API that should be expored is UnicodeBidiAnalyze().
*     The rest are all helper functions.
*
* Revision History:
*
*   02/25/2000 Mohamed Sadek [msadek]
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#define EMBEDDING_LEVEL_INVALID     62
#define PARAGRAPH_TERMINATOR_LEVEL  0xFF
#define POSITION_INVALID            -1

#define IS_STRONG_CLASS(x)      (CharacterProperties[0][(x)])
#define IS_STRONG_OR_NUMBER(x)  (CharacterProperties[1][(x)])
#define IS_FIXED_CLASS(x)       (CharacterProperties[2][(x)])
#define IS_FINAL_CLASS(x)       (CharacterProperties[3][(x)])
#define IS_NUMBER_CLASS(x)      (CharacterProperties[4][(x)])
#define IS_VALID_INDEX_CLASS(x) (CharacterProperties[5][(x)])
#ifndef MAX
    #define MAX(x,y)            (((x) > (y)) ? (x) : (y))
#endif
#ifndef MIN
    #define MIN(x,y)            (((x) < (y)) ? (x) : (y))
#endif

#define LSHIFTU64(x,y)          (((UINT64)(x)) << (y))
#define SET_BIT(x,y)            (((UINT64)(x)) |= LSHIFTU64(1,y))
#define RESET_BIT(x,y)          (((UINT64)(x)) &= ~LSHIFTU64(1,y))
#define IS_BIT_SET(x,y)         (((UINT64)(x)) & LSHIFTU64(1,y))

#define F FALSE
#define T TRUE
BOOL CharacterProperties[][CLASS_MAX - 1] =
{
                     // L   R   AN  EN  AL  ES  CS  ET  NSM BN  N   B   LRE LRO RLE RLO PDF S   WS  ON
   /*STRONG*/           T,  T,  F,  F,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,
   /*STRONG/NUMBER*/    T,  T,  T,  T,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,
   /*FIXED*/            T,  T,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,
   /*FINAL*/            T,  T,  T,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,
   /*NUMBER*/           F,  F,  T,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,
   /*VALID INDEX*/      T,  T,  T,  T,  T,  T,  T,  T,  T,  T,  T,  F,  F,  F,  F,  F,  F,  F,  F,  F,
};

// Paragraph base directionality

enum GpBaseLevel
{
    BaseLevelLeft = 0,
    BaseLevelRight = 1
};


// Bidirectional override classification

enum GpOverrideClass
{
    OverrideClassNeutral,
    OverrideClassLeft,
    OverrideClassRight
};

// Neutrals and Weeks finite state machine actions
// Note that action names are not so accurate as some of
// the actions are used in other contexts.

enum GpStateMachineAction
{
    ST_ST,      // Strong followed by strong
    ST_ET,      // ET followed by Strong
    ST_NUMSEP,  // Number followed by sperator follwed by strong
    ST_N,       // Neutral followed by strong
    SEP_ST,     // Strong followed by sperator
    CS_NUM,     // Number followed by CS
    SEP_ET,     // ET followed by sperator
    SEP_NUMSEP, // Number follwed by sperator follwed by number
    SEP_N,      // Neutral followed by sperator
    ES_AN,      // Arabic Number followed by European sperator
    ET_ET,      // European terminator follwed by a sperator
    ET_NUMSEP,  // Number followed by sperator followed by ET
    ET_EN,      // European number follwed by European terminator
    ET_N,       // Neutral followed by European Terminator
    NUM_NUMSEP, // Number followed by sperator followed by number
    NUM_NUM,    // Number followed by number
    EN_L,       // Left followed by EN
    EN_AL,      // AL followed by EN
    EN_ET,      // ET followed by EN
    EN_N,       // Neutral followed by EN
    BN_ST,      // ST followed by BN
    NSM_ST,     // ST followed by NSM
    NSM_ET,     // ET followed by NSM
    N_ST,       // ST followed by neutral
    N_ET,       // ET followed by neutral
};

// Neutrals and Weeks finite state machine states

enum GpStateMachineState
{
    S_L,        // Left character
    S_AL,       // Arabic letter
    S_R,        // Right character
    S_AN,       // Arabic number
    S_EN,       // European number
    S_ET,       // Europen terminator
    S_ANfCS,    // Arabic number followed by common sperator
    S_ENfCS,    // European number followed by common sperator
    S_N,        // Neutral character
};

GpStateMachineAction Action[][11] =
{
    //          L          R          AN          EN          AL         ES          CS          ET         NSM         BN        N
    /*S_L*/     ST_ST,     ST_ST,     ST_ST,      EN_L,       ST_ST,     SEP_ST,     SEP_ST,     CS_NUM,    NSM_ST,     BN_ST,    N_ST,
    /*S_AL*/    ST_ST,     ST_ST,     ST_ST,      EN_AL,      ST_ST,     SEP_ST,     SEP_ST,     CS_NUM,    NSM_ST,     BN_ST,    N_ST,
    /*S_R*/     ST_ST,     ST_ST,     ST_ST,      ST_ST,      ST_ST,     SEP_ST,     SEP_ST,     CS_NUM,    NSM_ST,     BN_ST,    N_ST,
    /*S_AN*/    ST_ST,     ST_ST,     ST_ST,      NUM_NUM,    ST_ST,     ES_AN,      CS_NUM,     CS_NUM,    NSM_ST,     BN_ST,    N_ST,
    /*S_EN*/    ST_ST,     ST_ST,     ST_ST,      NUM_NUM,    ST_ST,     CS_NUM,     CS_NUM,     ET_EN,     NSM_ST,     BN_ST,    N_ST,
    /*S_ET*/    ST_ET,     ST_ET,     ST_ET,      EN_ET,      ST_ET,     SEP_ET,     SEP_ET,     ET_ET,     NSM_ET,     BN_ST,    N_ET,
    /*S_ANfCS*/ ST_NUMSEP, ST_NUMSEP, NUM_NUMSEP, ST_NUMSEP,  ST_NUMSEP, SEP_NUMSEP, SEP_NUMSEP, ET_NUMSEP, SEP_NUMSEP, BN_ST,    N_ST,
    /*S_ENfCS*/ ST_NUMSEP, ST_NUMSEP, ST_NUMSEP,  NUM_NUMSEP, ST_NUMSEP, SEP_NUMSEP, SEP_NUMSEP, ET_NUMSEP, SEP_NUMSEP, BN_ST,    N_ST,
    /*S_N*/     ST_N,      ST_N,      ST_N,       EN_N,       ST_N,      SEP_N,      SEP_N,      ET_N,      NSM_ET,     BN_ST,    N_ET
};

GpStateMachineState NextState[][11] =
{
    //          L          R          AN          EN          AL         ES          CS          ET         NSM         BN       N
    /*S_L*/     S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_N,        S_ET,      S_L,        S_L,     S_N,
    /*S_AL*/    S_L,       S_R,       S_AN,       S_AN,       S_AL,      S_N,        S_N,        S_ET,      S_AL,       S_AL,    S_N,
    /*S_R*/     S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_N,        S_ET,      S_R,        S_R,     S_N,
    /*S_AN*/    S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_ANfCS,    S_ET,      S_AN,       S_AN,    S_N,
    /*S_EN*/    S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_ENfCS,    S_ENfCS,    S_EN,      S_EN,       S_EN,    S_N,
    /*S_ET*/    S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_N,        S_ET,      S_ET,       S_ET,    S_N,
    /*S_ANfCS*/ S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_N,        S_ET,      S_N,        S_ANfCS, S_N,
    /*S_ENfCS*/ S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_N,        S_ET,      S_N,        S_ENfCS, S_N,
    /*S_N*/     S_L,       S_R,       S_AN,       S_EN,       S_AL,      S_N,        S_N,        S_ET,      S_N,        S_N,     S_N,
};

BYTE ImplictPush [][4] =
{
    //        L,  R,  AN, EN

    /*even*/  0,  1,  2,  2,
    /*odd*/   1,  0,  1,  1,

};

/**************************************************************************\
*
* Function Description:
*
*   GpBiDiStack::Init()
*
*   Initializes the stack with inital value
*
* Arguments:
*
*    [IN] initialStack :
*         Represntation of the initial stack as 64 bit array
*
* Return Value:
*
*   TRUE if successful, otherwize FALSE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

BOOL
GpBiDiStack::Init (
    UINT64 initialStack                       // [IN]
    )
{
    BYTE    currentStackLevel = GetMaximumLevel(initialStack);
    BYTE    minimumStackLevel = GetMinimumLevel(initialStack);

    if((currentStackLevel >= EMBEDDING_LEVEL_INVALID) ||
      (minimumStackLevel < 0))
    {
        return FALSE;
    }
    m_Stack = initialStack;
    m_CurrentStackLevel = currentStackLevel;

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   GpBiDiStack::Push()
*
*   Pushs the stack with the new value which must be the current value
*   plus either one or two.
*
* Arguments:
*
*    [IN] pushToGreaterEven :
*         Specifies if the stack should be push to the next greater odd
*         or even level.
*
* Return Value:
*
*   FALSE if overflow occured, otherwize TRUE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

BOOL
GpBiDiStack::Push(
    BOOL pushToGreaterEven                    // [IN]
    )
{
    BYTE newMaximumLevel = pushToGreaterEven ? GreaterEven(m_CurrentStackLevel) :
                           GreaterOdd(m_CurrentStackLevel);

    if(newMaximumLevel >= EMBEDDING_LEVEL_INVALID)
    {
        return FALSE;
    }
    SET_BIT(m_Stack, newMaximumLevel);
    m_CurrentStackLevel = newMaximumLevel;

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   GpBiDiStack::Pop()
*
*   Pushs the stack with the new value which must be the current value
*   plus either one or two.
*
* Arguments:
*
*    NONE
*
* Return Value:
*
*   FALSE if underflow occured, otherwize TRUE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

BOOL
GpBiDiStack::Pop()
{
    BYTE newMaximumLevel;
    if(0 == m_CurrentStackLevel ||
        ((1 == m_CurrentStackLevel) && !(m_Stack & 1)))
    {
        return FALSE;
    }
    newMaximumLevel = IS_BIT_SET(m_Stack, (m_CurrentStackLevel -1)) ?
                      (BYTE)(m_CurrentStackLevel - 1) : (BYTE)(m_CurrentStackLevel - 2);

    RESET_BIT(m_Stack, m_CurrentStackLevel);
    m_CurrentStackLevel = newMaximumLevel;

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   GpBiDiStack::GetMaximumLevel()
*
*   Gets the stack maximum level.
*
* Arguments:
*
*    [IN] stack:
*         Represntation of the stack as 64 bit array.
*
* Return Value:
*
*   Stack maximum level.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

BYTE
GpBiDiStack::GetMaximumLevel(
    UINT64 stack                              // [IN]
    )
{
    BYTE maximumLevel = 0 ;

    for(INT counter = ((sizeof(UINT64) * 8) -1); counter >= 0; counter--)
    {
        if(IS_BIT_SET(stack, counter))
        {
            maximumLevel = (BYTE)counter;
            break;
        }
    }

    return maximumLevel;
}

/**************************************************************************\
*
* Function Description:
*
*   GpBiDiStack::GetMinimumLevel()
*
*   Gets the stack minimum level.
*
* Arguments:
*
*    [IN] stack:
*         Represntation of the stack as 64 bit array.
*
* Return Value:
*
*   Stack minimum level.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

BYTE
GpBiDiStack::GetMinimumLevel(
    UINT64 stack                              // [IN]
    )
{
    BYTE minimumLevel = 0xFF ;
    for (INT counter =0; counter < sizeof(UINT64); counter++)
    {
        if(IS_BIT_SET(stack, counter))
        {
            minimumLevel = (BYTE)counter;
            break;
        }
    }

    return minimumLevel;
}

/**************************************************************************\
*
* Function Description:
*
*   ResolveImplictLevels()
*
*   As the name describes.
*
* Arguments:
*
*    [IN] characterClass:
*         Array containing character classifications.
*
*    [IN] string:
*         Array containing character string.
*         used to get information about original classification
*
*    [IN] runLength:
*         Length of array passed.
*
*    [IN / OUT] levels:
*         Array containing character character levels.
*
* Return Value:
*
*    NONE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/
VOID
ResolveImplictLevels(
    const GpCharacterClass *characterClass,   // [IN]
    const WCHAR            *string,           // [IN]
    INT                     runLength,        // [IN]
    BYTE                   *levels            // [IN / OUT]

)
{
    if((NULL == characterClass) || (0 == runLength) || (NULL == levels))
    {
        return;
    }

    BOOL PreviousIsSSorPS = FALSE;
    BOOL ResetLevel       = FALSE;
    DoubleWideCharMappedString dwchString(string, runLength);

    for (INT counter = runLength -1; counter >= 0; counter--)
    {
        // We should only be getting a final class here.
        // We should have catched this earlier but anyway...

        ASSERTMSG(IS_FINAL_CLASS(characterClass[counter]),
        ("Cannot have unresolved classes during implict levels resolution"));




        if((S == s_aDirClassFromCharClass[CharClassFromCh(dwchString[counter])]) ||
           (B == s_aDirClassFromCharClass[CharClassFromCh(dwchString[counter])]))
        {
            PreviousIsSSorPS = TRUE;
            ResetLevel = TRUE;
        }
        else if((WS == s_aDirClassFromCharClass[CharClassFromCh(dwchString[counter])]) &&
                PreviousIsSSorPS)
        {
            ResetLevel = TRUE;
        }
        else
        {
            PreviousIsSSorPS = FALSE;
            ResetLevel = FALSE;
        }

        if(IS_FINAL_CLASS(characterClass[counter]) && !ResetLevel)
        {
            levels[counter] = (BYTE)((ImplictPush[ODD(levels[counter])][characterClass[counter]]) + levels[counter]);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GetFirstStrongCharacter()
*
*   Finds the first character before the first paragraph terminator.
*   That is strong (L, R or AL)
*
* Arguments:
*
*    [IN] string:
*         Array containing characters to be searched.
*
*    [IN] runLength:
*         Length of array passed.
*
*    [OUT] strongClass:
*         Classification of the strong character found(if any).
*
* Return Value:
*
*    TRUE if successful, otherwize FALSE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

BOOL
GetFirstStrongCharacter(
    const WCHAR      *string,                 // [IN]
    INT               stringLength,           // [IN]
    GpCharacterClass *strongClass             // [OUT]
    )
{
    GpCharacterClass currentClass = CLASS_INVALID;
    DoubleWideCharMappedString dwchString(string, stringLength);

    for(INT counter = 0; counter < stringLength; counter++)
    {
        currentClass = s_aDirClassFromCharClass[CharClassFromCh(dwchString[counter])];

        if(IS_STRONG_CLASS(currentClass) || (B == currentClass))
        {
            break;
        }
    }
    if(IS_STRONG_CLASS(currentClass))
    {
        *strongClass = currentClass;
        return TRUE;
    }
    return FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   ChangeType()
*
*   Changes the classification type of a string.
*
*
* Arguments:
*
*    [IN / OUT] characterClass:
*         Array containing character classifications.
*
*    [IN] count:
*         Length of array passed.
*
*    [IN] newClass:
*         New classification to change to.
*
* Return Value:
*
*    NONE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

VOID
ChangeType(
    GpCharacterClass       *characterClass,   // [IN / OUT]
    INT                     count,            // [IN]
    GpCharacterClass        newClass          // [IN]
)
{
    if((NULL == characterClass) || (0 == count))
    {
        return;
    }

    for(INT counter = 0; counter < count; counter++)
    {
        // We should never be changing a fixed type here

        ASSERTMSG(!IS_FIXED_CLASS(characterClass[counter]),
                 ("Changing class of a fixed class"));
        characterClass[counter] = newClass;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   ResolveNeutrals()
*
*   As the name describes.
*
*
* Arguments:
*
*    [IN / OUT] characterClass:
*         Array containing character classifications.
*
*    [IN] count:
*         Length of array passed.
*
*    [IN] startClass:
*         Classification of the last strong character preceding
*         the neutrals run.
*
*    [IN] startClass:
*         Classification of the first strong character following
*         the neutrals run.
*
*    [IN] runLevel:
*         Current run level to be used in case of conflict.
*
* Return Value:
*
*    NONE.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

VOID
ResolveNeutrals(
    GpCharacterClass       *characterClass,   // [IN / OUT]
    INT                     count,            // [IN]
    GpCharacterClass        startClass,       // [IN]
    GpCharacterClass        endClass,         // [IN]
    BYTE                    runLevel          // [IN]
)
{
    GpCharacterClass        startType;
    GpCharacterClass        endType;
    GpCharacterClass        resolutionType;

    if((NULL == characterClass) || (0 == count))
    {
        return;
    }

    ASSERTMSG((IS_STRONG_OR_NUMBER(startClass)) || (AL == startClass),
             ("Cannot use non strong type to resolve neutrals"));

    ASSERTMSG(IS_STRONG_OR_NUMBER(endClass),
             ("Cannot use non strong type to resolve neutrals"));

    startType =  ((EN == startClass) || (AN == startClass) || (AL == startClass)) ? R : startClass;
    endType =  ((EN == endClass) || (AN == endClass) || (AL == endClass)) ? R : endClass;

    if(startType == endType)
    {
        resolutionType = startType;
    }
    else
    {
        resolutionType = ODD(runLevel) ? R : L;
    }

    for(INT counter = 0; counter < count; counter++)
    {
        // We should never be changing a fixed type here

        ASSERTMSG(!IS_FIXED_CLASS(characterClass[counter]),
                 ("Resolving fixed class as being neutral: %i",
                  characterClass[counter]));

        characterClass[counter] = resolutionType;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   ResolveNeutralAndWeak()
*
*   As the name describes.
*
*
* Arguments:
*
*    [IN / OUT] characterClass:
*         Array containing character classifications.
*
*    [IN] runLength:
*         Length of array passed.
*
*    [IN] sor:
*         Classification of the last strong character preceding
*         the neutrals run.
*
*    [IN] eor:
*         Classification of the first strong character following
*         the neutrals run.
*
*    [IN] runLevel:
*         Current run level.
*
*    [IN] ,[OPTIONAL] stateIn :
*         Provides state information when continuing from a previous call
*
*    [OUT] ,[OPTIONAL] stateOut :
*         A pointer to BiDiAnalysisState structure to save sate
*         information for a possible upcoming call
*
*    [IN] ,[OPTIONAL] previousStrongIsArabic :
*         Assume that we have an AL as the last strong character in the pervious run
*         Should affect only EN -> AN rule
*
* Return Value:
*
*    If 'incompleteRun', the length of the run minus the number of characters
*    at the end of the run that could not be resolved (as they requires a
*    look ahead. Otherwise, the length of array passed.
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

INT
ResolveNeutralAndWeak(
    GpCharacterClass        *CharacterClass,        // [IN / OUT]
    INT                      runLength,             // [IN]
    GpCharacterClass         sor,                   // [IN]
    GpCharacterClass         eor,                   // [IN]
    BYTE                     runLevel,              // [IN]
    const BidiAnalysisState *stateIn,               // [IN], [OPTIONAL]
    BidiAnalysisState       *stateOut,              // [OUT], [OPTIONAL]
    BOOL                     previousStrongIsArabic // [IN], OPTIONAL
)
{
    INT                      startOfNeutrals = POSITION_INVALID;
    INT                      startOfDelayed = POSITION_INVALID;
    GpCharacterClass         lastClass = CLASS_INVALID;
    GpCharacterClass         lastStrongClass = CLASS_INVALID;
    GpCharacterClass         lastNumericClass = CLASS_INVALID;
    GpCharacterClass         startingClass = CLASS_INVALID;
    GpCharacterClass         currentClass = CLASS_INVALID;
    GpStateMachineState      state;
    BOOL                     previousClassIsArabic = FALSE;
    BOOL                     ArabicNumberAfterLeft = FALSE;
    INT                      lengthResolved = 0;

    if(NULL == CharacterClass || 0 == runLength)
    {
        return 0;
    }

    if(stateIn)
    {
        lastStrongClass = (GpCharacterClass)stateIn->LastFinalCharacterType;
        if(CLASS_INVALID != stateIn->LastNumericCharacterType)
        {
            lastNumericClass = startingClass =
                               lastClass =
                               (GpCharacterClass)stateIn->LastNumericCharacterType;
        }
        else
        {
            startingClass = lastClass = lastStrongClass;
        }

    }
    else if(previousStrongIsArabic)
    {
        startingClass = AL;
        lastClass = lastStrongClass = sor;
        previousClassIsArabic = TRUE;
    }
    else
    {
        startingClass = lastClass = lastStrongClass = sor;
    }
    switch(startingClass)
    {
    case R:
        state = S_R;
        break;

    case AL:
        state = S_AL;
        break;

    case EN:
        state = S_EN;
        break;

    case AN:
        state = S_AN;
        break;

    case L:
    default:
        state = S_L;
    }


    // We have two types of classes that needs delayed resolution:
    // Neutrals and other classes such as CS, ES, ET, BN, NSM that needs look ahead.
    // We keep a separate pointer for the start of neutrals and another pointer
    // for the those other classes (if needed since its resolution might be delayed).
    // Also, we need the last strong class for neutral resolution and the last
    // general class (that is not BN or MSM) for NSM resolution.

    // The simple idea of all actions is that we always resolve neutrals starting
    // from 'startOfNeutrals' and when we are sure about delayed weak type
    // resolution, we resolve it starting from 'startOfDelayed' else we point by
    // 'startOfNeutrals' as resolve it as neutral.

    for(INT counter = 0; counter < runLength; counter++)
    {
        currentClass = CharacterClass[counter];

        // We index action and next state table by class.
        // If we got a calss that should have been resolved already or a bogus
        // value, return what we were able to resolve so far.

        if(!IS_VALID_INDEX_CLASS(currentClass))
        {
            return lengthResolved;
        }
        GpStateMachineAction action = Action[state][currentClass];

        // Need to record last numeric type so that when
        // we continue from a previous call, we can correctly resolve something
        // like L AN at the end of the first call and EN at the start of the
        // next call.

        if(IS_NUMBER_CLASS(currentClass))
        {
            lastNumericClass = currentClass;
        }

        // If we have previousClassIsArabic flag set, we need its eefect to
        // last only till the first strong character in the run.

        if(IS_STRONG_CLASS(currentClass))
        {
            previousClassIsArabic = FALSE;
        }
        switch(action)
        {
        case ST_ST:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                      ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if(AL == currentClass)
            {
                CharacterClass[counter] = R;
            }
            if(POSITION_INVALID != startOfDelayed)
            {
                startOfNeutrals = startOfDelayed;
                ResolveNeutrals(CharacterClass + startOfNeutrals,
                                counter -  startOfNeutrals,
                                ArabicNumberAfterLeft ? AN : lastStrongClass,
                                CharacterClass[counter],
                                runLevel);
                startOfNeutrals = startOfDelayed = POSITION_INVALID;
            }
            if((AN != currentClass) || ((AN == currentClass) && (lastStrongClass == R)))
            {
                lastStrongClass = currentClass;
            }
            if((AN == currentClass) && (lastStrongClass == L))
            {
                ArabicNumberAfterLeft = TRUE;
            }
            else
            {
                ArabicNumberAfterLeft = FALSE;
            }
            lastClass = currentClass;
            break;

        case ST_ET:
            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));

            if(POSITION_INVALID == startOfNeutrals)
            {
               startOfNeutrals =  startOfDelayed;
            }
            if(AL == currentClass)
            {
                CharacterClass[counter] = R;
            }
            ResolveNeutrals(CharacterClass + startOfNeutrals,
                            counter -  startOfNeutrals,
                            ArabicNumberAfterLeft ? AN : lastStrongClass,
                            CharacterClass[counter],
                            runLevel);
            startOfNeutrals = startOfDelayed = POSITION_INVALID;

            if((AN != currentClass) || ((AN == currentClass) && (lastStrongClass == R)))
            {
                lastStrongClass = currentClass;
            }
            if((AN == currentClass) && (lastStrongClass == L))
            {
                ArabicNumberAfterLeft = TRUE;
            }
            else
            {
                ArabicNumberAfterLeft = FALSE;
            }
            lastClass = currentClass;
            break;

        case ST_NUMSEP:
            {
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));
            BOOL processed = FALSE;

            if(AL == currentClass)
            {
                CharacterClass[counter] = R;
            }
            if(((AL == lastStrongClass) || previousClassIsArabic) && ((EN == currentClass) || (AN == currentClass)))
            {
                CharacterClass[counter] = AN;
                BOOL commonSeparator = TRUE;
                INT  commonSeparatorCount = 0;

                for(int i = startOfDelayed; i < counter; i++)
                {
                    if((CS != *(CharacterClass + i)) && (BN != *(CharacterClass + i)))
                    {
                        commonSeparator=FALSE;
                        break;
                    }
                    if(CS == *(CharacterClass + i))
                    {
                        commonSeparatorCount++;
                    }

                }
                if(commonSeparator && (1 == commonSeparatorCount))
                {
                    ChangeType(CharacterClass + startOfDelayed,
                               counter -  startOfDelayed,
                               CharacterClass[counter]);
                    processed = TRUE;
                }
            }
            else if((L == lastStrongClass) && (EN == currentClass))
            {
                CharacterClass[counter] = L;
            }
            if(!processed)
            {
                startOfNeutrals =  startOfDelayed;

                ResolveNeutrals(CharacterClass + startOfNeutrals,
                                counter -  startOfNeutrals,
                                ArabicNumberAfterLeft ? AN : lastStrongClass,
                                CharacterClass[counter],
                                runLevel);
            }

            startOfNeutrals = startOfDelayed = POSITION_INVALID;

            if((AN != currentClass) || ((AN == currentClass) && (lastStrongClass == R)))
            {
                if(!(((L == lastStrongClass) || (AL == lastStrongClass)) && (EN == currentClass)))
                {
                    lastStrongClass = currentClass;
                }
            }
            if((AN == currentClass) && (lastStrongClass == L))
            {
                ArabicNumberAfterLeft = TRUE;
            }
            else
            {
                ArabicNumberAfterLeft = FALSE;
            }
            
            lastClass = currentClass;
            if (CharacterClass[counter] == AN)
            {
                currentClass = AN;
            }
            }

            break;

        case ST_N:
            ASSERTMSG(POSITION_INVALID != startOfNeutrals,
                     ("Must have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if(AL == currentClass)
            {
                CharacterClass[counter] = R;
            }
            ResolveNeutrals(CharacterClass + startOfNeutrals,
                            counter -  startOfNeutrals,
                            ArabicNumberAfterLeft ? AN : lastStrongClass,
                            CharacterClass[counter],
                            runLevel);
            startOfNeutrals = startOfDelayed = POSITION_INVALID;

            if((AN != currentClass) || ((AN == currentClass) && (lastStrongClass == R)))
            {
                lastStrongClass = currentClass;
            }
            if((AN == currentClass) && (lastStrongClass == L))
            {
                ArabicNumberAfterLeft = TRUE;
            }
            else
            {
                ArabicNumberAfterLeft = FALSE;
            }
            lastClass = currentClass;


            break;

        case EN_N:
            ASSERTMSG(POSITION_INVALID != startOfNeutrals,
                     ("Must have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if((AL == lastStrongClass) || previousClassIsArabic)
            {
                CharacterClass[counter] = AN;
                currentClass            = AN; 
            }
            else if(L == lastStrongClass)
            {
                CharacterClass[counter] = L;
            }
            ResolveNeutrals(CharacterClass + startOfNeutrals,
                            counter -  startOfNeutrals,
                            ArabicNumberAfterLeft ? AN : lastStrongClass,
                            CharacterClass[counter],
                            runLevel);
            startOfNeutrals = startOfDelayed = POSITION_INVALID;
            ArabicNumberAfterLeft = FALSE;

            lastClass = currentClass;
            break;

        case SEP_ST:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if(POSITION_INVALID != startOfDelayed)
            {
                startOfNeutrals = startOfDelayed;
                startOfDelayed = POSITION_INVALID;
            }
            else
            {
                startOfNeutrals = counter;
            }
            lastClass = currentClass;
            break;

        case CS_NUM:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if(POSITION_INVALID == startOfDelayed)
            {
                startOfDelayed = counter;
            }
            lastClass = currentClass;
            break;

        case SEP_ET:
            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));

            if(POSITION_INVALID == startOfNeutrals)
            {
                startOfNeutrals = startOfDelayed;
            }
            startOfDelayed = POSITION_INVALID;
            lastClass = N;
            break;

        case SEP_NUMSEP:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));

            startOfNeutrals = startOfDelayed;
            startOfDelayed = POSITION_INVALID;
            lastClass = N;
            break;

        case SEP_N:
            ASSERTMSG(POSITION_INVALID != startOfNeutrals,
                     ("Must have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            startOfDelayed = POSITION_INVALID;
            break;

        case ES_AN:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if(POSITION_INVALID != startOfDelayed)
            {
                startOfNeutrals = startOfDelayed;
                startOfDelayed = POSITION_INVALID;
            }
            else
            {
                startOfNeutrals = counter;
            }
            lastClass = N;
            break;

        case ET_ET:
            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));
            ASSERTMSG(ET == lastClass,
                     ("Last class must be ET. State: %i, Class: %i",
                      state,currentClass));
            break;

        case ET_NUMSEP:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));

            startOfNeutrals = startOfDelayed;
            startOfDelayed = counter;
            lastClass = currentClass;
            break;

        case ET_EN:
            if(POSITION_INVALID == startOfDelayed)
            {
                startOfDelayed = counter;
            }
            if(!((AL == lastStrongClass) || previousClassIsArabic))
            {
                if(L == lastStrongClass)
                {
                    CharacterClass[counter] = L;
                }
                else
                {
                    CharacterClass[counter] = EN;
                }
                ChangeType(CharacterClass + startOfDelayed,
                           counter -  startOfDelayed,
                           CharacterClass[counter]);
            startOfDelayed = POSITION_INVALID;
            }
            lastClass = EN;

            // According to the rules W4, W5, and W6 If we have a sequence EN ET ES EN 
            // we should treat ES as ON
            
            if ( counter<runLength-1        && 
                (CharacterClass[counter+1] == ES ||
                 CharacterClass[counter+1] == CS ))
            {
                CharacterClass[counter+1]  = N;
            }
            
            break;

        case ET_N:
            ASSERTMSG(POSITION_INVALID != startOfNeutrals,
                     ("Must have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            if(POSITION_INVALID == startOfDelayed)
            {
                startOfDelayed = counter;
            }
            lastClass = currentClass;
            break;

        case NUM_NUMSEP:
            ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

            ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));

            if((AL == lastStrongClass) || previousClassIsArabic || ArabicNumberAfterLeft)
            {
                CharacterClass[counter] = AN;
            }
            else if(L == lastStrongClass)
            {
                CharacterClass[counter] = L;
            }
            else
            {

                lastStrongClass = currentClass;
            }
            ChangeType(CharacterClass + startOfDelayed,
                        counter -  startOfDelayed,
                        CharacterClass[counter]);

            startOfDelayed = POSITION_INVALID;
            lastClass = currentClass;
            break;

       case EN_L:
           ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

           if(L == lastStrongClass)
           {
               CharacterClass[counter] = L;
           }
           if(POSITION_INVALID != startOfDelayed)
           {
               startOfNeutrals = startOfDelayed;
               ResolveNeutrals(CharacterClass + startOfNeutrals,
                               counter -  startOfNeutrals,
                               ArabicNumberAfterLeft ? AN : lastStrongClass,
                               CharacterClass[counter],
                               runLevel);
               startOfNeutrals = startOfDelayed = POSITION_INVALID;
           }
           lastClass = currentClass;

           break;

       case NUM_NUM:
           ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

           if((AL == lastStrongClass) || previousClassIsArabic)
           {
               CharacterClass[counter] = AN;
               currentClass            = AN;
           }
           else if(L == lastStrongClass)
           {
               CharacterClass[counter] = L;

           }

           if(POSITION_INVALID != startOfDelayed)
           {
               startOfNeutrals = startOfDelayed;
               ResolveNeutrals(CharacterClass + startOfNeutrals,
                               counter -  startOfNeutrals,
                               ArabicNumberAfterLeft ? AN : lastStrongClass,
                               CharacterClass[counter],
                               runLevel);
               startOfNeutrals = startOfDelayed = POSITION_INVALID;
           }

           if((AN == currentClass) && (lastStrongClass == L))
           {
               ArabicNumberAfterLeft = TRUE;
           }
           else
           {
               ArabicNumberAfterLeft = FALSE;
           }
           lastClass = currentClass;

           break;

       case EN_AL:
           ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                     ("Cannot have unresolved neutrals. State: %i, Class: %i",
                      state,currentClass));

           CharacterClass[counter] = AN;
           if(POSITION_INVALID != startOfDelayed)
           {
               startOfNeutrals = startOfDelayed;
               ResolveNeutrals(CharacterClass + startOfNeutrals,
                               counter -  startOfNeutrals,
                               ArabicNumberAfterLeft ? AN : lastStrongClass,
                               CharacterClass[counter],
                               runLevel);
               startOfNeutrals = startOfDelayed = POSITION_INVALID;
           }
           lastClass = AN;
           break;

       case EN_ET:
           ASSERTMSG(POSITION_INVALID != startOfDelayed,
                     ("Must have delayed weak classes. State: %i, Class: %i",
                      state,currentClass));

           if((AL == lastStrongClass) || previousClassIsArabic)
           {
               CharacterClass[counter] = AN;
               currentClass = AN;

               if(POSITION_INVALID == startOfNeutrals)
               {
                   ResolveNeutrals(CharacterClass + startOfDelayed,
                                   counter -  startOfDelayed,
                                   ArabicNumberAfterLeft ? AN : lastStrongClass,
                                   CharacterClass[counter],
                                   runLevel);
               }
               else
               {
                   ResolveNeutrals(CharacterClass + startOfNeutrals,
                                   counter -  startOfNeutrals,
                                   ArabicNumberAfterLeft ? AN : lastStrongClass,
                                   CharacterClass[counter],
                                   runLevel);
               }
           }
           else if(L == lastStrongClass)
           {
               CharacterClass[counter] = L;

               ChangeType(CharacterClass + startOfDelayed,
                          counter -  startOfDelayed,
                          CharacterClass[counter]);

               if(POSITION_INVALID != startOfNeutrals)
               {
                   ResolveNeutrals(CharacterClass + startOfNeutrals,
                                   startOfDelayed -  startOfNeutrals,
                                   ArabicNumberAfterLeft ? AN : lastStrongClass,
                                   CharacterClass[counter],
                                   runLevel);
               }
               ArabicNumberAfterLeft = FALSE;
           }
           else
           {
               ChangeType(CharacterClass + startOfDelayed,
                          counter -  startOfDelayed,
                          EN);

               if(POSITION_INVALID != startOfNeutrals)
               {
                   ResolveNeutrals(CharacterClass + startOfNeutrals,
                                   startOfDelayed -  startOfNeutrals,
                                   ArabicNumberAfterLeft ? AN : lastStrongClass,
                                   currentClass,
                                   runLevel);
               }
           }
           startOfNeutrals = startOfDelayed = POSITION_INVALID;
           lastClass = currentClass;
           break;
       case BN_ST:
           if(POSITION_INVALID == startOfDelayed)
           {
               startOfDelayed = counter;
           }
           break;

       case NSM_ST:
           if(AL == lastStrongClass && POSITION_INVALID != startOfDelayed)
           {
               CharacterClass[counter] = lastClass;
           }
           else
           {
               if((AL == lastStrongClass))
               {
                   if(EN == lastClass)
                   {
                       CharacterClass[counter] = AN;
                   }
                   else if (AN != lastClass)
                   {
                       CharacterClass[counter] = R;
                   }
                   else
                   {
                       CharacterClass[counter] = ArabicNumberAfterLeft
                                                 || AN == lastClass ? AN : lastStrongClass;
                   }
               }
               else
               {
                   CharacterClass[counter] = ArabicNumberAfterLeft
                                             || AN == lastClass ? AN : EN == lastClass && lastStrongClass != L
                                              ? EN : lastStrongClass;
               }

               if(POSITION_INVALID != startOfDelayed)
               {
                   ChangeType(CharacterClass + startOfDelayed,
                              counter -  startOfDelayed,
                              CharacterClass[counter]);
                   startOfDelayed = POSITION_INVALID;

               }
           }           break;
       case NSM_ET:
           CharacterClass[counter] = lastClass;
           break;

       case N_ST:
           ASSERTMSG(POSITION_INVALID == startOfNeutrals,
                    ("Cannot have unresolved neutrals. State: %i, Class: %i",
                     state,currentClass));

           if(POSITION_INVALID != startOfDelayed)
           {
               startOfNeutrals = startOfDelayed;
               startOfDelayed = POSITION_INVALID;
           }
           else
           {
               startOfNeutrals = counter;
           }
           lastClass = currentClass;
           break;

       case N_ET:

           // Note that this state is used for N_N as well.

           if(POSITION_INVALID == startOfNeutrals)
           {
               if(POSITION_INVALID != startOfDelayed)
               {
                   startOfNeutrals = startOfDelayed;
               }
           }
           startOfDelayed = POSITION_INVALID;
           lastClass = currentClass;
           break;
        };

        // Fetch next state.

        state = NextState[state][currentClass];
        lengthResolved = POSITION_INVALID == MAX(startOfNeutrals, startOfDelayed) ?
                         counter + 1 :
                         ((POSITION_INVALID == MIN(startOfNeutrals, startOfDelayed)) ?
                         (MAX(startOfNeutrals, startOfDelayed)) :
                         (MIN(startOfNeutrals, startOfDelayed)));
    }


    // If the caller flagged this run as incomplete
    // return the maximun that we could resolve so far and the last strong (fixed)
    // class saved

    if(stateOut)
    {
        stateOut->LastFinalCharacterType = (BYTE)lastStrongClass;
        stateOut->LastNumericCharacterType = (BYTE)lastNumericClass;
        return lengthResolved;
    }

    // Else, resolve remaining neutrals or delayed classes.
    // Resolve as neutrals based on eor.

    else
    {

        if(lengthResolved != counter)
        ResolveNeutrals(CharacterClass + lengthResolved,
                        counter -  lengthResolved,
                        ArabicNumberAfterLeft ? AN : lastStrongClass,
                        eor,
                        runLevel);
        return counter;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   UnicodeBidiAnalyze()
*
*   Performs Unicode Bidirectional text analyis
*   The main entry point function for the algorithm.
*
*
* Arguments:
*
*    [IN  string:
*         Character string to be analyzed.
*
*    [IN] stringLength:
*         Length of string passed.
*
*    [IN] flags:
*         Various flags to control anaylsis behavior
*         See description of 'BidiAnalysisFlags'.
*
*    [IN / OUT] , [OPTIONAL] state:
*         'BidiAnalysisState' structure to save analysis information for a
*          possible next call (when used as output parameter) or to continue
*          analysis from a previous call (when used as input parameter).
*
*    [IN] runLevel:
*         Current run level.
*
*    [OUT] levels:
*         ponter to an array to receive resolved levels
*         have a paragraph terminator following it.
*
*    [OUT] [OPTIONAL] lengthAnalyzed:
*         Conditionally optional pointer to integerto receive the number
*         of characters analyzed.
*
* Return Value:
*
*    Ok, if the analysis completed successfully. Otherwise, error status code.
*
*    Notes:
*         lengthAnalyzed: (optional) returns the number of characters that were
*         unambiguously resolved. This value may be less than the string
*         less if the BidiBufferNotComplete flag was passed, and for example
*         if the input string terminated on neutral (non-directed)
*         characters.
*         The lengthAnalyzed output parameter must be passed if the
*         BidiBufferNotComplete flag has been set.
*         If the BidiBufferNotComplete flag is not set, the whole string will
*         always be analyzed.
*
*
* Created:
*
*   02/25/2000 Mohamed Sadek [msadek]
*
\**************************************************************************/

Status WINGDIPAPI
UnicodeBidiAnalyze(
    const WCHAR       *string,                // [IN]
    INT                stringLength,          // [IN]
    BidiAnalysisFlags  flags,                 // [IN]
    BidiAnalysisState *state,                 // [IN / OUT] , [OPTIONAL]
    BYTE              *levels,                // [OUT] [OPTIONAL]
    INT               *lengthAnalyzed         // [OUT]
    )
{

    
    GpCharacterClass  *characterClass;
    INT               *runLimits;
    INT                runCount = 0;
    Status             result = Ok;
    BidiAnalysisState *stateIn = NULL;
    BidiAnalysisState *stateOut = NULL;
    GpBiDiStack        levelsStack;
    UINT64             overrideStatus;
    GpOverrideClass    overrideClass;
    INT                stackOverflow;
    BYTE               baseLevel;
    BYTE               lastRunLevel;
    BYTE               lastNonBnLevel;
    INT                counter;
    INT                lengthUnresolved = 0;
    INT                codepoint;
    INT                controlStack = 0;

    // Verifying input parameters.

    if((NULL == string) || (0 >= stringLength) ||
        ((BidiContinueAnalysis <= flags) && (NULL == state)) ||
        (NULL == levels) ||
        ((flags & BidiBufferNotComplete) && (NULL == lengthAnalyzed)))
    {
        return InvalidParameter;
    }

    // If the last character in the string is a paragraph terminator,
    // we can analyze the whole string, No need to use state parameter
    // for output

    codepoint = string[stringLength -1];

    if((stringLength > 1) && ((string[stringLength -2] & 0xFC00 ) == 0xD800) && ((string[stringLength - 1] & 0xFC00) == 0xDC00))
    {
       codepoint = 0x10000 + (((string[stringLength -2] & 0x3ff) << 10) | (string[stringLength - 1] & 0x3ff));
    }

    if((flags & BidiBufferNotComplete) &&
        (B != s_aDirClassFromCharClass[CharClassFromCh(codepoint)]))
    {
        stateOut = state;

    }

    if(flags & BidiContinueAnalysis)
    {
        // We will use the 'state' parameter as output.
        // let's copy the content of it first
        if(stateOut)
        {
            stateIn = new BidiAnalysisState;
            if(!stateIn)
            {
                return OutOfMemory;
            }
            else
            {
                memcpy(stateIn, state, sizeof(BidiAnalysisState));
            }
        }

        // Else, simply make sateIn points to 'state" parameter.
        else
        {
            stateIn = state;
        }
    }

    characterClass = new GpCharacterClass[stringLength];
    if (characterClass == NULL)
    {
        return OutOfMemory;
    }

    DoubleWideCharMappedString dwchString(string, stringLength);

    // for the worst case of all paragraph terminators string.

    runLimits = new INT[stringLength];

    if (NULL == runLimits)
    {
        delete characterClass;
        return OutOfMemory;
    }

    if(stateIn)
    {
        if(!levelsStack.Init(stateIn->LevelsStack))
        {
            result = InvalidParameter;
            goto Cleanup;
        }
        baseLevel = levelsStack.GetStackBottom();
        stackOverflow = stateIn->StackOverflow;
        overrideStatus = stateIn->OverrideStatus;
        overrideClass = (IS_BIT_SET(overrideStatus, baseLevel)) ? (ODD(baseLevel) ?
                         OverrideClassRight : OverrideClassLeft): OverrideClassNeutral;
    }
    else
    {
        baseLevel = BaseLevelLeft;

        if(flags & BidiParagraphDirectionAsFirstStrong)
        {
            // Find strong character in the first paragraph
            // This might cause a complete pass over the input string
            // but we must get it before we start.

            GpCharacterClass firstStrong = CLASS_INVALID;

            if(GetFirstStrongCharacter(string, stringLength, &firstStrong))
            {
                if(L != firstStrong)
                {
                    baseLevel = BaseLevelRight;
                }
            }

        }
        else if(flags & BidiParagraphDirectioRightToLeft)
        {
            baseLevel = BaseLevelRight;
        }

        levelsStack.Init(baseLevel + 1);
        stackOverflow = 0;
        // Initialize to neutral
        overrideStatus = 0;
        overrideClass = OverrideClassNeutral;
    }

    // Get character classifications.
    // Resolve explicit embedding levels.
    // Record run limits (either due to a level change or due to new paragraph)

    lastNonBnLevel = baseLevel;
    for(counter = 0; counter < stringLength; counter++)
    {

        GpCharacterClass currentClass = characterClass[counter] = s_aDirClassFromCharClass[CharClassFromCh(dwchString[counter])];

        if (dwchString[counter] == WCH_IGNORABLE && counter > 0)
        {
            characterClass[counter] = characterClass[counter-1];
            levels[counter] = levels[counter - 1];
            continue;
        }

        levels[counter] = levelsStack.GetCurrentLevel();

        switch(currentClass)
        {
        case B:
            // mark output level array with a special mark
            // to seperate between paragraphs

            levels[counter] = PARAGRAPH_TERMINATOR_LEVEL;
            runLimits[runCount] = counter;
            if (counter != stringLength-1)
            {
                runCount++;
            }
            levelsStack.Init(baseLevel + 1);
            overrideStatus = 0;
            overrideClass =  OverrideClassNeutral;
            stackOverflow = 0;
            controlStack = 0;

            // Fall through

        // We keep our Unicode classification table stictly following Unicode
        // regarding neutral types (B, S, WS, ON), change all to generic N.

        case S:
        case WS:
        case ON:
            characterClass[counter] = N;
            
            if (counter>0 && characterClass[counter-1]==BN)
            {
                if (levels[counter-1] < levels[counter])
                {
                    levels[counter-1] = levels[counter];
                }
            }
            controlStack = 0;
            
            break;

        case LRE:
        case RLE:
            characterClass[counter] = BN;

            // If we overflowed the stack, keep track of this in order to know when you hit
            // a PDF if you should pop or not.

            if(!levelsStack.Push(currentClass == LRE ? TRUE : FALSE))
            {
              stackOverflow++;
            }
            else
            {
                runLimits[runCount] = counter;
                if (counter != stringLength-1)
                {
                    runCount++;
                }
                controlStack++;
            }
            overrideClass =  OverrideClassNeutral;

            levels[counter] = lastNonBnLevel;

            break;

        case LRO:
        case RLO:
            characterClass[counter] = BN;
            if(!levelsStack.Push(currentClass == LRO ? TRUE : FALSE))
            {
              stackOverflow++;
            }
            else
            {
                // Set the matching bit of 'overrideStatus' to one
                // in order to know when you pop if you're in override state or not.

                SET_BIT(overrideStatus, levelsStack.GetCurrentLevel());
                overrideClass = (currentClass == LRO) ? OverrideClassLeft :
                                                        OverrideClassRight;
                runLimits[runCount] = counter;
                if (counter != stringLength-1)
                {
                    runCount++;
                }
                controlStack++;
            }
            
            levels[counter] = lastNonBnLevel;
            break;

        case PDF:
            characterClass[counter] = BN;
            if(stackOverflow)
            {
                stackOverflow--;
            }
            else
            {
                if (levelsStack.Pop())
                {
                    INT newLevel = levelsStack.GetCurrentLevel();

                    // Override state being left or right is determined
                    // from the new level being even or odd.

                    overrideClass = (IS_BIT_SET(overrideStatus, newLevel)) ? (ODD(newLevel) ?
                                    OverrideClassRight : OverrideClassLeft): OverrideClassNeutral;

                    if (controlStack > 0)
                    {
                        ASSERT(runCount > 0);
                        runCount--;
                        controlStack--;
                    }
                    else
                    {
                        runLimits[runCount] = counter;
                        if (counter != stringLength-1)
                        {
                            runCount++;
                        }
                    }
                }
                
            }
            
            levels[counter] = lastNonBnLevel;
            
            break;

        default:
            controlStack = 0;
 
            if(OverrideClassNeutral != overrideClass)
            {
                characterClass[counter] = (OverrideClassLeft == overrideClass) ?
                                          L : R;
            }

            if (counter>0 && characterClass[counter-1]==BN)
            {
                if (levels[counter-1] < levels[counter])
                {
                    levels[counter-1] = levels[counter];
                }
            }
        }
        
        lastNonBnLevel = levels[counter];
    }

    runCount++;

    if(stateOut)
    {
        stateOut->LevelsStack = levelsStack.GetData();
        stateOut->OverrideStatus = overrideStatus;
        stateOut->StackOverflow = stackOverflow;
    }

    // Resolve neutral and weak types.
    // Resolve implict levels.


    // The lastRunLevel will hold the level of last processed run to be used
    // to determine the sor of the next run. we can't depend on the level array
    // because it can be changed in case of numerics. so level of the numerics
    // will be increased by one or two.
    
    lastRunLevel = baseLevel;

    for(counter = 0; counter < runCount; counter++)
    {
        GpCharacterClass   sor;
        GpCharacterClass   eor;

        INT runStart =  (0 == counter) ? 0 : runLimits[counter - 1] + 1;

        // If the level transition was due to a new paragraph
        // we don't want pass the paragraph terminator position.

        INT offset = (counter != (runCount - 1)) ?
                     ((levels[runLimits[counter]] == PARAGRAPH_TERMINATOR_LEVEL) ?
                     1 : 0) :
                     0;
        INT runLength = (counter == (runCount - 1)) ?
                        (stringLength - runStart) - offset:
                        (runLimits[counter] - runStart) + 1 - offset;

        // See if we need to provide state information from a previous call
        // or need to save it for a possible next call

        BOOL incompleteRun = ((runCount - 1) == counter) && (flags & BidiBufferNotComplete)
                             && stateOut;
        BOOL continuingAnalysis = (0 == counter) && (stateIn);

        INT runLengthResolved;

        // First run or a run after paragraph terminator.

        if ((0 == counter) ||
            (PARAGRAPH_TERMINATOR_LEVEL == levels[runLimits[counter -1]]))
        {
            sor = ODD(MAX(baseLevel, levels[runStart])) ? R : L;
        }
        else
        {
            sor = ODD(MAX(lastRunLevel, levels[runStart])) ?
                  R : L;
        }
        
        lastRunLevel = levels[runStart];

        // Last run or a run just before paragraph terminator.

        if( ((runCount - 1) == counter) ||
            (PARAGRAPH_TERMINATOR_LEVEL == levels[runLimits[counter]]))
        {
            eor = ODD(MAX(levels[runStart], baseLevel)) ? R : L;
        }
        else
        {
            // we will try to get first run which doesn't have just one  
            // control char like LRE,RLE,... and so on
            INT runNumber = counter+1;
            while ( runNumber<runCount - 1 &&
                    runLimits[runNumber]-runLimits[runNumber-1]==1 &&
                    characterClass[runLimits[runNumber]] == BN)
            {
                runNumber++;
            }
            
            eor = ODD(MAX(levels[runStart], levels[runLimits[runNumber-1] + 1])) ?
                  R : L;

        }

        // If it is a continuation from a previous call, set sor
        // to the last stron type saved in the input state parameter.

        runLengthResolved = ResolveNeutralAndWeak(characterClass + runStart,
                                                  runLength,
                                                  sor,
                                                  eor,
                                                  levels[runStart],
                                                  continuingAnalysis ? stateIn:
                                                  NULL,
                                                  incompleteRun ? stateOut:
                                                  NULL,
                                                  ((0 == counter) && !stateIn) ?
                                                  flags & BidiPreviousStrongIsArabic:
                                                  FALSE);
        if(!incompleteRun)
        {
            // If we in a complete run, we should be able to resolve everything
            // unless we passed a corrupted data

            ASSERTMSG(runLengthResolved == runLength,
                     ("Failed to resolve neutrals and weaks. Run#: %i,",
                      counter));
        }
        else
        {
            lengthUnresolved = runLength - runLengthResolved;
        }

        // Resolve implict levels.
        // Also, takes care of Rule L1 (segment separators, paragraph separator,
        // white spaces at the end of the line.

        ResolveImplictLevels(characterClass + runStart,
                             string + runStart,
                             runLength,
                             levels + runStart);

    }
Cleanup:
    if (stateOut && stateIn)
    {
        delete stateIn;
    }
    delete characterClass;
    delete runLimits;

    *lengthAnalyzed = stringLength - lengthUnresolved;
    return result;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\bidianalysis.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Header file for BiDiAnalysis.cpp
*
* Revision History:
*
*   02/25/2000 Mohamed Sadek [msadek]
*       Created it.
*
\**************************************************************************/

#ifndef _BIDI_ANALYSIS_HPP
#define _BIDI_ANALYSIS_HPP
#ifdef __cplusplus
extern "C" {
#endif

#define ODD(x) ((x) & 1)


// Implementation of a Bidirectionl embedding stack

class GpBiDiStack
{
private:
    UINT64 m_Stack;
    BYTE   m_CurrentStackLevel;
    
public:
    GpBiDiStack() {m_CurrentStackLevel = 0;}
    BOOL   Init (UINT64 initialStack);
    BOOL   Push(BOOL pushToGreaterEven);
    BOOL   Pop();
    BYTE   GetStackBottom() {return GetMinimumLevel(m_Stack);}
    BYTE   GetCurrentLevel() {return m_CurrentStackLevel;}
    UINT64 GetData() {return m_Stack;}
private:
    BYTE   GetMaximumLevel(UINT64 stack);
    BYTE   GetMinimumLevel(UINT64 stack);
    BYTE   GreaterEven(BYTE level) {return ODD(level) ? (BYTE)(level + 1) : (BYTE)(level + 2);}
    BYTE   GreaterOdd(BYTE level) {return ODD(level) ? (BYTE)(level + 2) : (BYTE)(level + 1);}
};


// Bidirectional character classification
// Be careful about order as it is used for indexing.


extern "C" const GpCharacterClass s_aDirClassFromCharClass[];

/////   BidiAnalysisFlags
//
//      BidiParagraphDirectionRightToLeft: Right to left paragraph. Paragraph
//          direction defaults to left-to-right.
//          Ignored if BidiContinueAnalysis flag also set.
//
//      BidiParagraphDirectionAsFirstStrong: Paragragraph direction determined
//          by scanning for the first strongly directed character. If no
//          strongly directed characters are found, defaults to setting of
//          BidiParagraphDirectioRightToLeft flag.
//          Ignored if BidiContinueAnalysis flag also set.
//
//      BidiPreviousStrongIsArabic: Parse numbers as if the paragraph
//          were preceeded by an Arabic letter.
//          Ignored if BidiContinueAnalysis flag also set.
//
//      BidiContinueAnalysis: This analysis is a continuation. The 'state'
//          parameter to UnicodeBidiAnalysis provides the state at the
//          end of the previously analysed block.
//          This flag causes the BidiParagraphDirectioRightToLeft,
//          BidiParagraphDirectionAsFirstStrong, and
//          BidiPreviousStrongIsArabic flags to be ignored: there value is
//          obtained from the state structure.
//
//      BidiBufferNotComplete: Indicates that the buffer passed may not
//          end on a paragraph boundary, and that futher calls to
//          UnicodeBidiAnalysis will be made to pass subsequent buffers and
//          thereby resolve trailing neutral characters. If the
//          BidiBufferNotComplete flag is set, the 'state' and
//          'lengthAnalyzed' parameters must be supplied to
//          UnicodeBidiAnalyze.
//
//



enum BidiAnalysisFlags 
{
    BidiParagraphDirectioRightToLeft      = 0x01,
    BidiParagraphDirectionAsFirstStrong   = 0x02,
    BidiPreviousStrongIsArabic            = 0x04,
    BidiContinueAnalysis                  = 0x08,
    BidiBufferNotComplete                 = 0x10
};

struct BidiAnalysisState 
{
    UINT64    LevelsStack;
    UINT64    OverrideStatus;
    BYTE      LastFinalCharacterType;
    BYTE      LastNumericCharacterType;
    INT       StackOverflow;
};

/////   UnicodeBidiAnalyze
//
//      lengthAnalyzed: (optional) returns the number of characters that were
//          unambiguously resolved. This value may be less than the string
//          less if the BidiBufferNotComplete flag was passed, and for example
//          if the input string terminated on neutral (non-directed)
//          characters.
//          The lengthAnalyzed output parameter must be passed if the
//          BidiBufferNotComplete flag has been set.
//          If the BidiBufferNotComplete flag is not set, the whole string will
//          always be analyzed.

Status WINGDIPAPI UnicodeBidiAnalyze(
    const WCHAR       *string,
    INT                stringLength,
    BidiAnalysisFlags  flags,
    BidiAnalysisState *state,
    BYTE              *levels,
    INT               *lengthAnalyzed
    );
#ifdef __cplusplus
}
#endif
#endif // _BIDI_ANALYSIS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\break.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   Character breaking classes
*
* Revision History:
*
*   03/14/2000  Worachai Chaoweeraprasit (wchao)
*       Created it.
*
\**************************************************************************/


#ifndef _BREAK_HPP_
#define _BREAK_HPP_




//  Character context type
enum BreakType
{
    BreakWord     = 0,
    BreakCluster  = 1
};



class Break
{
public:
    Break() :
        Attributes  (NULL)
    {}

    Break(
        SCRIPT_LOGATTR  *breakAttributes,
        INT             length
    )
    {
        Attributes = (SCRIPT_LOGATTR *)GpMalloc(sizeof(SCRIPT_LOGATTR) * length);

        if (Attributes)
        {
            GpMemcpy (Attributes, breakAttributes, sizeof(SCRIPT_LOGATTR) * length);
        }
    }

    ~Break()
    {
        if (Attributes)
        {
            GpFree(Attributes);
        }
    }


    //  Querying functions

    BOOL IsWordBreak (INT position)
    {
        return     (Attributes[position].fCharStop && Attributes[position].fWordStop)
                || Attributes[position].fWhiteSpace;
    }

    BOOL IsClusterBreak (INT position)
    {
        return     Attributes[position].fCharStop
                || Attributes[position].fWhiteSpace;
    }

private:
    SCRIPT_LOGATTR  *Attributes;    // Array of break attributes
};


#endif  // _BREAK_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\builtline.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Full text imager implementation
*
* Revision History:
*
*   06/16/1999 dbrown
*       Created it.
*
*   06/12/2000 Worachai Chaoweeraprasit (wchao)
*       Trimming, querying and ellipsis
*
\**************************************************************************/



#include "precomp.hpp"


/////   BuiltLine
//
//      Creates a built line using LIne Services


BuiltLine::BuiltLine (
    ols             *lineServicesOwner,         // [IN] Line Services context
    INT             stringIndex,                // [IN] string start index
    LSCP            lineServicesStartIndex,     // [IN] Line Services string start index
    StringTrimming  trimming,                   // [IN] how to end the line
    BuiltLine       *previousLine,              // [IN] previous line
    BOOL            forceEllipsis               // [IN] enforce trim ellipsis?
)
:   LsLine                      (NULL),
    LsContext                   (NULL),
    LsStartIndex                (lineServicesStartIndex),
    StartIndex                  (stringIndex),
    LsCharacterCount            (0),
    CharacterCount              (0),
    Ascent                      (0),
    Descent                     (0),
    LineLength                  (0),
    BreakRecord                 (NULL),
    BreakRecordCount            (0),
    LeftOrTopMargin             (0),
    RightOrBottomMargin         (0),
    MaxSublineCount             (0),
    Trimming                    (StringTrimmingNone),
    AlignmentOffset             (0),
    EllipsisPointOffset         (0),
    LeftOrTopGlyphEdge          (0),
    LastVisibleRun              (NULL),
    DisplayPlacements           (NULL),
    DisplayBaselineAdjust       (0),
    Status                      (GenericError)
{
    Imager = lineServicesOwner->GetImager();

    LsContext = lineServicesOwner->GetLsContext();

    // Get useful formatting options

    Imager->BuildRunsUpToAndIncluding(lineServicesStartIndex);

    const GpStringFormat *format = SpanRider<const GpStringFormat*>(&Imager->FormatVector)[stringIndex];

    REAL idealEm = Imager->SizeVector.GetDefault() * Imager->WorldToIdeal;

    INT  formatFlags;

    if (format)
    {
        LeftOrTopMargin     = GpRound(idealEm * format->GetLeadingMargin());
        RightOrBottomMargin = GpRound(idealEm * format->GetTrailingMargin());
        formatFlags         = format->GetFormatFlags();
    }
    else
    {
        LeftOrTopMargin     = GpRound(idealEm * DefaultMargin);
        RightOrBottomMargin = GpRound(idealEm * DefaultMargin);
        formatFlags         = DefaultFormatFlags;
    }


    // Establish overall layour rectangle line length including margins

    INT lineLengthLimit = GpRound(Imager->LineLengthLimit * Imager->WorldToIdeal);


    // Determine formatting width limit

    INT formattingWidth;

    if (   lineLengthLimit <= 0
        || (   formatFlags & StringFormatFlagsNoWrap
            && trimming == StringTrimmingNone))
    {
        formattingWidth = INFINITE_LINELIMIT; // Effectively unlimited.
    }
    else
    {
        formattingWidth = lineLengthLimit - (LeftOrTopMargin + RightOrBottomMargin);
        //TERSE(("Width: %x\n", width));

        if (formattingWidth <= 0)
        {
            // What to do?
            formattingWidth = 0;
        }
    }


    //  Create the line

    Status = CreateLine (
                stringIndex,
                formattingWidth,
                trimming,
                formatFlags,
                forceEllipsis,
                previousLine
             );

    if (Status != Ok)
    {
        return;
    }

    ASSERT(   CharacterCount <= 0
           || StartIndex + CharacterCount >= Imager->Length
           || (Imager->String[StartIndex + CharacterCount - 1] & 0xFC00) != 0xD800
           || (Imager->String[StartIndex + CharacterCount] & 0xFC00) != 0xDC00);


    INT lineLengthPlusMargins = LineLength + LeftOrTopMargin + RightOrBottomMargin;


    // Establish alignment offset

    StringAlignment physicalAlignment = StringAlignmentNear;  // After appying RTL effect

    if (format)
    {
        physicalAlignment = format->GetPhysicalAlignment();
    }


    // Apply physical alignment generating AlignmentOffset - the distance
    // from the origin of the formatting rectangle to the leading end of the
    // line.

    if (physicalAlignment != StringAlignmentNear)
    {
        if (lineLengthLimit > 0)
        {
            // Align within rectangle
            AlignmentOffset = lineLengthLimit - lineLengthPlusMargins;
        }
        else
        {
            // Align around origin
            AlignmentOffset = -lineLengthPlusMargins;
        }

        if (physicalAlignment == StringAlignmentCenter)
        {
            AlignmentOffset /= 2;
        }
    }

    // Record line edges before adjusting AlignmentOffset for RTL.

    LeftOrTopGlyphEdge = AlignmentOffset + LeftOrTopMargin;


    // AlignmentOffset is currently the offset from the origin of the
    // formatting rectangle to the left end of the whole line, including
    // margins.

    // The offset needs to be adjusted over the margin. Additionally
    // for an RTL paragraph the offset is to the right end.

    if (    formatFlags & StringFormatFlagsDirectionVertical
        ||  !(formatFlags & StringFormatFlagsDirectionRightToLeft))
    {
        AlignmentOffset += LeftOrTopMargin;
    }
    else
    {
        AlignmentOffset += LineLength + LeftOrTopMargin;
    }

    Status = Ok;
}




/////   CreateLine
//
//      All stuffs concerning text in a line should be here instead of in the
//      BuiltLine's constructor. The idea is to separate the text line from
//      line decorations like margins or alignment.
//

GpStatus BuiltLine::CreateLine (
    INT             stringIndex,            // [IN] string start position
    INT             lineLengthLimit,        // [IN] line length limit (excluding margins)
    StringTrimming  trimming,               // [IN] string trimming
    INT             formatFlags,            // [IN] format flags
    BOOL            forceEllipsis,          // [IN] enforce trim ellipsis?
    BuiltLine       *previousLine           // [IN] previous line
)
{
    INT formattingWidth = lineLengthLimit;

    if (trimming == StringTrimmingEllipsisPath)
    {
        //  Built the whole paragraph up in one line, so we know how to shrink it
        //  to fit in the line limit boundary.

        formattingWidth = INFINITE_LINELIMIT;
    }


    GpStatus    status;
    LSLINFO     lineInfo;
    BREAKREC    brkRecords[MAX_BREAKRECORD];
    DWORD       brkCount;


    status = CreateLineCore (
        formattingWidth,
        trimming,
        previousLine,
        MAX_BREAKRECORD,
        brkRecords,
        &brkCount,
        &lineInfo
    );

    if (status != Ok)
    {
        return status;
    }


    //  Trimming requested is not always the trimming done.
    //  We record the trimming being done for the line.

    switch (trimming)
    {
        case StringTrimmingWord :
        case StringTrimmingCharacter :
        {
            if (lineInfo.endr != endrEndPara)
            {
                Trimming = trimming;
            }
            break;
        }

        case StringTrimmingEllipsisWord :
        case StringTrimmingEllipsisCharacter:
        {
            if (   forceEllipsis
                || lineInfo.endr != endrEndPara)
            {
                GpStatus status = RecreateLineEllipsis (
                    stringIndex,
                    lineLengthLimit,
                    trimming,
                    formatFlags,
                    &lineInfo,
                    previousLine,
                    &Trimming,
                    &lineInfo
                );

                if (status != Ok)
                {
                    return status;
                }
            }
            break;
        }
    }

    if(   Trimming != StringTrimmingNone
       && Trimming != StringTrimmingEllipsisPath)
    {
        //  By definition, trimming at the end would mean the text continues
        //  thus, no traling spaces to be displayed (410525).
        
        formatFlags &= ~StringFormatFlagsMeasureTrailingSpaces;
    }

    if (   brkCount > 0
        && lineInfo.endr != endrEndPara
        && Trimming == StringTrimmingNone)
    {

        //  No need to cache break records for the last line
        //  of paragraph as it's supposed to be balance. This
        //  including lines with trimming as we know such line
        //  spans to the nearest paragraph mark.


        BreakRecord = new BREAKREC [brkCount];

        if (!BreakRecord)
        {
            return OutOfMemory;
        }

        BreakRecordCount = brkCount;
        GpMemcpy (BreakRecord, brkRecords, sizeof(BREAKREC) * brkCount);
    }


    Ascent      = lineInfo.dvpAscent;
    Descent     = lineInfo.dvpDescent;

    if (lineInfo.dvpMultiLineHeight == dvHeightIgnore)
    {
        // Paragraph is empty. We have to work out the line spacing ourselves.

        const GpFontFamily *family = SpanRider<const GpFontFamily *>(&Imager->FamilyVector)
                                     [stringIndex];
        INT                 style  = SpanRider<INT>(&Imager->StyleVector)
                                     [stringIndex];
        REAL                emSize = SpanRider<REAL>(&Imager->SizeVector)
                                     [stringIndex];
        const GpFontFace   *face   = family->GetFace(style);

        if (!face)
        {
            return FontStyleNotFound;
        }

        REAL fontToIdeal = (emSize / face->GetDesignEmHeight()) * Imager->WorldToIdeal;

        LineSpacing = GpRound(float(   face->GetDesignLineSpacing()
                                    *  fontToIdeal));;
    }
    else
    {
        LineSpacing = lineInfo.dvpMultiLineHeight;
    }


    CheckUpdateLineLength (formatFlags & StringFormatFlagsMeasureTrailingSpaces);

    CheckUpdateCharacterCount(
        stringIndex,
        lineInfo.cpLim
    );

    return Ok;
}




GpStatus BuiltLine::CreateLineCore (
    INT             formattingWidth,        // [IN] formatting boundary
    StringTrimming  trimming,               // [IN] trimming type
    BuiltLine       *previousLine,          // [IN] previous line
    UINT            maxBrkCount,            // [IN] maximum number of break records
    BREAKREC        *brkRecords,            // [OUT] break records
    DWORD           *brkCount,              // [OUT] break record count
    LSLINFO         *lineInfo               // [OUT] line information
)
{
    //  Line ends with line break opportunity?

    Imager->TruncateLine =    trimming == StringTrimmingCharacter
                           || trimming == StringTrimmingEllipsisCharacter;


    LSERR lserror = LsCreateLine(
        LsContext,
        LsStartIndex,
        formattingWidth,
        (previousLine ? previousLine->GetBreakRecord() : NULL),
        (previousLine ? previousLine->GetBreakRecordCount() : 0),
        maxBrkCount,
        brkRecords,
        brkCount,
        lineInfo,
        &LsLine
    );

    if (lserror != lserrNone)
    {
        TERSE (("line creation fails - lserror: %d\n", lserror));
        return GenericError;
    }

    MaxSublineCount  = lineInfo->nDepthFormatLineMax;
    LsCharacterCount = lineInfo->cpLim - LsStartIndex;

    return Ok;
}




GpStatus BuiltLine::RecreateLineEllipsis (
    INT             stringIndex,            // [IN] line start index
    INT             lineLengthLimit,        // [IN] line length limit
    StringTrimming  trimmingRequested,      // [IN] kind of trimming requested
    INT             formatFlags,            // [IN] format flags
    LSLINFO         *lineInfoOriginal,      // [IN] original line's properties
    BuiltLine       *previousLine,          // [IN] previous line
    StringTrimming  *trimmingDone,          // [OUT] kind of trimming implemented
    LSLINFO         *lineInfoNew            // [OUT] new line properties
)
{
    StringTrimming  trimming = trimmingRequested;

    ASSERT (   trimming == StringTrimmingEllipsisWord
            || trimming == StringTrimmingEllipsisCharacter);


    GpStatus status = Ok;

    const EllipsisInfo *ellipsis = Imager->GetEllipsisInfo();

    if (!ellipsis)
    {
        return OutOfMemory;
    }

    if (ellipsis->Width > lineLengthLimit / 2)
    {
        switch (trimming)
        {
            case StringTrimmingEllipsisWord :
                trimming = StringTrimmingWord;
                break;

            case StringTrimmingEllipsisCharacter :
                trimming = StringTrimmingCharacter;
                break;
        }
    }
    else
    {
        LsDestroyLine(LsContext, LsLine);

        BREAKREC    brkRecords[MAX_BREAKRECORD];
        DWORD       brkCount;

        status = CreateLineCore (
            lineLengthLimit - ellipsis->Width,
            trimming,
            previousLine,
            MAX_BREAKRECORD,
            brkRecords,
            &brkCount,
            lineInfoNew
        );

        if (status != Ok)
        {
            return status;
        }

        CheckUpdateCharacterCount(
            stringIndex,
            lineInfoNew->cpLim
        );
        

        //  By definition, trimming at the end would mean the text continues
        //  thus, no traling spaces to be displayed (410525).

        CheckUpdateLineLength (0);

        //  Append ellipsis at the end,
        //  we need to increase the line length by ellipsis size.

        EllipsisPointOffset = LineLength;
        LineLength += ellipsis->Width;
    }

    //  what we've done.

    *trimmingDone = trimming;

    return status;
}




GpStatus BuiltLine::TrimText (
    INT         stringOffset,           // [IN] string offset from line start
    INT         stringLength,           // [IN] string length
    INT         size,                   // [IN] string size in ideal unit
    INT         sizeLimit,              // [IN] maximum possible string size
    LSQSUBINFO  *sublines,              // [IN] LS sublines
    INT         maxSublineCount,        // [IN] valid subline count
    INT         ellipsisLength,         // [IN] character length of ellipsis string
    INT         *trimmedLength,         // [IN/OUT] number of character being trimmed out
    BOOL        leadingTrim             // [IN] TRUE - trim from the first character onward
)
{
    ASSERT (sublines && trimmedLength);

    GpStatus status = Ok;

    INT length = stringOffset;
    INT trimmed = 0;
    INT delta = 0;      // the difference because of snapping

    if (leadingTrim)
    {
        while (   trimmed < stringLength
               && (   size > sizeLimit
                   || trimmed < ellipsisLength))
        {
            trimmed++;
            length++;

            status = CalculateStringSize (
                length,
                sublines,
                maxSublineCount,
                SnapForward,
                &size,
                &delta
            );

            if (status != Ok)
            {
                return status;
            }

            size = LineLength - size;

            length  += delta;
            trimmed += delta;
        }
    }
    else
    {
        length += stringLength;

        while (   trimmed < stringLength
               && (   size > sizeLimit
                   || trimmed < ellipsisLength))
        {
            trimmed++;
            length--;

            status = CalculateStringSize (
                length,
                sublines,
                maxSublineCount,
                SnapBackward,
                &size,
                &delta
            );

            if (status != Ok)
            {
                return status;
            }

            length  += delta;
            trimmed += abs(delta);
        }
        
        if (Imager->GetFormatHotkeyPrefix() != HotkeyPrefixNone)
        {
            //  If we process hotkey, we cant leave 0xffff visible but orphaned
            //  outside the trimmed text, though it may appear to be a standalone 
            //  cluster now. Because clusters may change after replacing ellipsis 
            //  chars to hidden out some text.
            //
            //  When this trimmed text is eventually be hidden out. For LS, that
            //  means we're asking them to split the 0xffff apart from its hotkey 
            //  character. When that happens, in most cases, we are intentionally
            //  breaking a cluster. (wchao, #366190)

            const WCHAR *string = &Imager->String[StartIndex + stringOffset];
            
            while (   trimmed < stringLength
                   && string[stringLength - trimmed - 1] == WCH_IGNORABLE)
            {
                trimmed++;
            }
        }
    }

    *trimmedLength += trimmed;  // Note: this is an in/out param !
    return status;
}




/////   Path ellipsis
//
//      Scan through the whole line finding the character range to be omitted by ellipsis.
//      Since the presence of ellipsis affects bidi layout, we eventually need to update
//      the character backing store with ellipsis. Note that cp won't change, the rest of
//      the omitted text will only be hidden out.
//

GpStatus BuiltLine::UpdateContentWithPathEllipsis (
    EllipsisInfo    *ellipsis,          // [IN] ellipsis info
    INT             lineLengthLimit,    // [IN] line length limit including margins
    BOOL            *contentChanged     // [IN/OUT] content changed?
)
{
    //  exclude margins

    lineLengthLimit -= (LeftOrTopMargin + RightOrBottomMargin);


    if (lineLengthLimit <= ellipsis->Width)
    {
        //  do nothing, the line has no room to fill any text

        return Ok;
    }


    GpStatus status = Ok;

    INT fixedOffset;

    for (fixedOffset = CharacterCount - 1; fixedOffset > 0; fixedOffset--)
    {
        if (Imager->String[StartIndex + fixedOffset] == '\\')
        {
            break;
        }
    }


    if (LineLength > lineLengthLimit)
    {
        ASSERT (MaxSublineCount > 0);

        AutoArray<LSQSUBINFO> sublines(new LSQSUBINFO [MaxSublineCount]);

        if (!sublines)
        {
            return OutOfMemory;
        }


        INT fixedSize       = 0;
        INT variedSize      = 0;

        status = CalculateStringSize (
            fixedOffset,
            sublines.Get(),
            MaxSublineCount,
            SnapNone,   // need not snap, we know it's bounded
            &variedSize
        );

        if (status != Ok)
        {
            return status;
        }

        fixedSize = LineLength - variedSize;
        INT remaining = lineLengthLimit - fixedSize - ellipsis->Width;

        INT ellipsisLength = ellipsis->GlyphCount;
        INT trimmed = 0;


        if (remaining <= 0)
        {
            //  Fixed text is longer than the line limit
            //
            //  Reduce the back half of fixed text so it fits within the back half of the line
            //  before start reducing remaining text. The idea is to place ellipsis half way
            //  in the line regardless how the final text may eventually look like.

            INT delta = 0;

            fixedOffset = CharacterCount / 2;

            status = CalculateStringSize (
                fixedOffset,
                sublines.Get(),
                MaxSublineCount,
                SnapForward,
                &variedSize,
                &delta
            );

            if (status != Ok)
            {
                return status;
            }

            fixedOffset += delta;
            fixedSize = LineLength - variedSize;

            INT halfLineLengthLimit = (lineLengthLimit - ellipsis->Width) / 2;

            status = TrimText (
                fixedOffset,
                CharacterCount - fixedOffset,
                fixedSize,
                halfLineLengthLimit,
                sublines.Get(),
                MaxSublineCount,
                ellipsisLength,
                &trimmed,
                TRUE    // leading characters off!
            );

            if (status != Ok)
            {
                return status;
            }

            //  Now move fixed offse to the right place and
            //  recalculate remaining space

            fixedOffset += trimmed;
            remaining = lineLengthLimit - halfLineLengthLimit - ellipsis->Width;
        }


        //  Fit the rest into the remaining space

        ASSERT(remaining > 0);

        status = TrimText (
            0,
            fixedOffset - trimmed,
            variedSize,
            remaining,
            sublines.Get(),
            MaxSublineCount,
            ellipsisLength,
            &trimmed
        );

        if (status != Ok)
        {
            return status;
        }

        if (   trimmed <= fixedOffset
            && trimmed >= ellipsisLength)
        {
            //  Place ellipsis in front of fixed text

            for (INT i = ellipsisLength; i > 0; i--)
            {
                Imager->String[StartIndex + fixedOffset - i] = ellipsis->String[ellipsisLength - i];
                *contentChanged = TRUE;
            }

            //  Hide the rest

            if (trimmed > ellipsisLength)
            {
                //  Place dot up to the first character being trimmed,
                //  the idea is to have the whole trimmed text becomes
                //  a series of neutral characters

                for (INT i = fixedOffset - ellipsisLength - 1; i >= fixedOffset - trimmed; i--)
                {
                    Imager->String[StartIndex + i] = '.';
                }

                if (   Imager->GetFormatHotkeyPrefix() != HotkeyPrefixNone
                    && StartIndex > 0 
                    && fixedOffset - trimmed == 0)
                {
                    //  If the line is trimmed up to the first character, check
                    //  if the last characters of the previous line are hotkey
                    //  0xffff. If so, eat them up as well. 
                    //
                    //  The reason is that we should never leave 0xffff visible
                    //  but orphaned. We'll be rebuilding the line after we're done
                    //  hiding out part of text and that orphaned 0xffff will cause
                    //  LS to break the cluster in FetchRun (wchao, #360699).
                    
                    INT backing = StartIndex;
                    while (   backing > 0
                           && Imager->String[backing - 1] == WCH_IGNORABLE)
                    {
                        backing--;
                        trimmed++;
                    }
                }

                status = Imager->VisibilityVector.SetSpan(
                    StartIndex + fixedOffset - trimmed,
                    trimmed - ellipsisLength,
                    VisibilityHide
                );
                if (status != Ok)
                    return status;

                *contentChanged = TRUE;

                Trimming = StringTrimmingEllipsisPath;
            }
        }
    }

    return status;
}




GpStatus BuiltLine::CheckUpdateLineLength (
    BOOL    trailingSpacesIncluded, // [IN] including trailing spaces?
    BOOL    forceUpdate             // [IN] (optional) force updating?
)
{
    GpStatus status = Ok;

    if (   forceUpdate
        || !LineLength)
    {
        status = CalculateLineLength (
            trailingSpacesIncluded,
            &LineLength
        );
    }
    return status;
}




GpStatus BuiltLine::CheckUpdateCharacterCount(
    INT             stringIndex,                // [IN] line start string index
    LSCP            lineLimitIndex,             // [IN] Line Services line limit index
    BOOL            forceUpdate                 // [IN] (optional) force updating?
)
{
    GpStatus status = Ok;

    if (   forceUpdate
        || !CharacterCount)
    {
        status = CalculateCharacterCount (
            stringIndex,
            lineLimitIndex,
            &CharacterCount
        );
    }
    return status;
}





/////   GetUntrimmedCharacterCount
//
//      Because of trimming, the number of character built in the line
//      is not the same as the length of the span housing that line.
//      Span is good for indexing, so its length is untrimmed.
//

INT BuiltLine::GetUntrimmedCharacterCount (
    INT     stringOffset,           // [IN] line start string position
    INT     *lsLineStringLength     // [OUT] line span length in Line Services index
)
{
    INT length = GetDisplayableCharacterCount();

    if (lsLineStringLength)
    {
        *lsLineStringLength = GetLsDisplayableCharacterCount();
    }

    if (   IsTrimmed()
        && !IsEOP(Imager->String[stringOffset + length - 1]))
    {
        length += stringOffset;

        while (   length < Imager->Length
               && Imager->String[length] != WCH_LF)
        {
            length++;
        }

        if (length < Imager->Length)
        {
            length++;
        }

        if (lsLineStringLength)
        {
            *lsLineStringLength = Imager->LineServicesStringPosition(length)
                                  - LsStartIndex;
        }

        length -= stringOffset;
    }
    return length;
}








GpStatus BuiltLine::CalculateCharacterCount(
    INT             stringIndex,                // [IN] line start string index
    LSCP            lineLimitIndex,             // [IN] Line Services line limit index
    INT             *characterCount             // [OUT] (optional) updated character count
) const
{
    ASSERT (characterCount);

    LSCP lineServicesEndIndex = lineLimitIndex;

    SpanRider<PLSRUN> runRider(&Imager->RunVector);
    runRider.SetPosition(lineServicesEndIndex);

    while (   lineServicesEndIndex > LsStartIndex
           && (  !runRider.GetCurrentElement()
               || runRider.GetCurrentElement()->RunType != lsrun::RunText) )
    {
        if (runRider.GetCurrentElement())
        {
            runRider.SetPosition(runRider.GetCurrentSpanStart() - 1);
        }
        else
        {
            runRider.SetPosition(lineServicesEndIndex - 1);
        }

        lineServicesEndIndex = runRider.GetCurrentSpanStart();
        runRider.SetPosition(lineServicesEndIndex);
    }

    if (lineServicesEndIndex == lineLimitIndex)
    {
        *characterCount = lineServicesEndIndex - runRider.GetCurrentSpanStart() +
                          runRider.GetCurrentElement()->ImagerStringOffset -
                          stringIndex;
    }
    else
    {
        *characterCount = runRider.GetCurrentElement()->ImagerStringOffset +
                          runRider.GetUniformLength() -
                          stringIndex;
    }
    return Ok;
}




GpStatus BuiltLine::CalculateLineLength (
    BOOL    trailingSpacesIncluded,     // [IN] including trailing spaces?
    INT     *lineLength                 // [OUT] (optional) updated line length
) const
{
    ASSERT (lineLength);

    LONG    unused;
    LONG    startMainText;
    LONG    startTrailing;
    LONG    lineEnd;

    if (LsQueryLineDup(
            LsLine,
            &unused,            // !! offset to autonumbering text,
            &unused,            //    not used for now
            &startMainText,
            &startTrailing,
            &lineEnd
        ) != lserrNone)
    {
        ASSERT(FALSE);
        return GenericError;
    }

    if (trailingSpacesIncluded)
    {
        *lineLength = lineEnd - startMainText;
    }
    else
    {
        *lineLength = startTrailing - startMainText;
    }
    return Ok;
}





/////   Logical glyph placement
//
//
//      RecordDisplayPlacements
//
//          Called back from FullTextImager::DrawGlyphs for recording
//          processed glyph advance width per logical cluster. Logical
//          glyph placement is cached in BuiltLine and used by screen
//          selection region.
//
//
//      CheckDisplayPlacements
//
//          Cache logical glyph placements for the whole line during
//          screen selection region calculation. Query uses this info
//          to determine selection boundaries that match the actual display.
//


GpStatus BuiltLine::CheckDisplayPlacements() const
{
    if (!DisplayPlacements)
    {
        if (   Imager->Graphics
            && !Imager->GetMetaFileRecordingFlag())
        {

            //  Consult the rendering engine about the actual glyph logical
            //  placements only when not within the metafile recording.
            //  If the target device is metafile (no matter what playback
            //  mechanism it will be), we just return nominal placements.


            Imager->CurrentBuiltLine = this;
            Imager->RecordDisplayPlacementsOnly = TRUE;

            // Origin passed to draw must have correct X offset for leading and
            // trailing run detection to work.

            POINT origin;
            LogicalToXY (
                0,
                0,  // Would be linePointOffset + baselineOffset for drawing, not needed here.
                (INT*)&origin.x,
                (INT*)&origin.y
            );
            GpStatus status = Draw(&origin);

            Imager->RecordDisplayPlacementsOnly = FALSE;
            Imager->CurrentBuiltLine = NULL;


            if (status != Ok)
            {
                return status;
            }
        }

        if (!DisplayPlacements)
        {
            //  In a valid state but noone care to initialize it,
            //  this means we know we dont need it.

            DisplayPlacements = (INT *)PINVALID;
        }
    }
    return Ok;
}




/////   RecordDisplayPlacements
//
//      Called per each plsrun within the line, this function caches
//      the accumulated logical advance width of each character forming
//      a glyph cluster. The width cached is in text flow direction
//      so it's negative if the run flows in the opposite direction of
//      the paragraph direction.
//
//
//          string:             c1 c2 c3   c4
//                               \ | /   /   \
//          glyphs:              g1 g2   g4  g5
//                               |  |    |   |
//          glyphAdvances:       5  4    3   3
//
//          logicalAdvances:    3  3  3    6
//
//          what we cache:      3  6  9    15
//
//
//      Note: the accumulative advance we cache is not per line, it's per run.
//      It means the value of the last item of the cache array is not the total
//      size of the whole line, but the total size of only the last run of that line.


GpStatus BuiltLine::RecordDisplayPlacements(
    const GpTextItem    *textItem,              // [IN] text item
    UINT                stringOffset,           // [IN] string offset
    UINT                stringLength,           // [IN] string length
    GMAP                *glyphMap,              // [IN] character to glyph map
    const INT           *glyphAdvances,         // [IN] glyph advance widths in ideal unit
    INT                 glyphCount,             // [IN] glyph count
    INT                 originAdjust            // [IN] leading origin adjustment
) const
{
    ASSERT (stringLength > 0 && DisplayPlacements != PINVALID);

    if (!DisplayPlacements)
    {
        DisplayPlacements = new INT [CharacterCount];

        if (!DisplayPlacements)
        {
            DisplayPlacements = (INT *)PINVALID;
            return OutOfMemory;
        }

        GpMemset(DisplayPlacements, 0, sizeof(INT) * CharacterCount);
    }


    INT direction = Imager->GetParagraphEmbeddingLevel() == (textItem->Level & 1) ? 1 : -1;


    stringOffset -= StartIndex;     // string offset to start of run relative to line start

    UINT offset = 0;                // string offset relative to start of run
    UINT length = stringLength;     // run length so far


    // total logical advance width so far, begin with leading adjustment

    INT  advanceSoFar = originAdjust * direction;


    while (length > 0)
    {
        UINT advance = 1;

        while (   advance < length
               && glyphMap[offset + advance] == glyphMap[offset])
        {
            advance++;
        }


        INT glyphLimit =   advance == length
                         ? glyphCount
                         : glyphMap[offset + advance];


        INT logicalAdvance = 0;

        for (INT i = glyphMap[offset]; i < glyphLimit; i++)
        {
            logicalAdvance += glyphAdvances[i];
        }


        //  advance distance is relative to text flow direction
        logicalAdvance *= direction;


        INT fullSplit = logicalAdvance / advance;
        INT remaining = logicalAdvance % advance;


        for (UINT i = offset; i < offset + advance; i++)
        {
            //  divide total glyph advances evenly among characters
            //  forming the cluster.

            ASSERT(DisplayPlacements[stringOffset + i] == 0);

            advanceSoFar += fullSplit + (remaining-- ? direction : 0);
            DisplayPlacements[stringOffset + i] = advanceSoFar;
        }

        length  -= advance;
        offset  += advance;
    }

    ASSERT(offset == stringLength);

    return Ok;
}





/////   TranslateSubline
//
//      Extract character position out of Line Services subline structures.
//      All returning values are ideal unit in text flow (U) direction of the main
//      line except for the total size which is an absolute value in ideal unit.
//
//
//      CP to X :
//          TranslateSubline (
//              cp,
//              sublines,
//              sublineCount,
//              textCell,
//              sublineCount - 1,
//              &partStart,     // [OUT] part start
//              &partSize       // [OUT] part size
//          );
//          pointUV.u = partStart + partSize;
//
//      String size :
//          TranslateSubline (
//              cp,
//              sublines,
//              sublineCount,
//              textCell,
//              -1,
//              NULL,
//              NULL,
//              &delta,
//              &size           // absolute size of the string to given cp
//          );
//
//      Selection part (trail) :
//          TranslateSubline (
//              cp,
//              sublines,
//              sublineCount,
//              textCell,
//              partIndex,
//              &partStart,     // [OUT] part start
//              &partSize       // [OUT] part size
//          );
//

GpStatus BuiltLine::TranslateSubline(
    LSCP                lineServicesStringIndex,    // [IN] string index creating sublines
    const LSQSUBINFO    *sublines,                  // [IN] Line Services sublines
    INT                 sublineCount,               // [IN] number of sublines
    const LSTEXTCELL    *textCell,                  // [IN] text cell
    INT                 trailIndex,                 // [IN] trail in question
    UINT                snapMode,                   // [IN] trail end snap mode
    INT                 *trailStart,                // [OUT] trail start
    INT                 *trailSize,                 // [OUT] trail size
    INT                 *delta,                     // [OUT] (optional) number of characters moved by snapping
    INT                 *totalTrailSize             // [OUT] (optional) total absolute size of all trails
) const
{
    ASSERT (sublines && sublineCount > 0 && textCell);

    if (trailIndex >= sublineCount)
    {
        return InvalidParameter;
    }


    GpStatus status = Ok;
    INT start;
    INT size;


    if (trailIndex >= 0)
    {
        start = sublines[trailIndex].pointUvStartSubline.u;
        size  = sublines[trailIndex].pointUvStartRun.u -
                sublines[trailIndex].pointUvStartSubline.u;


        if (snapMode & SnapDisplay)
        {
            //  Caller asks for display-precision result,
            //  make sure the actual display positions are porperly cached

            status = CheckDisplayPlacements();
            IF_NOT_OK_WARN_AND_RETURN(status);

            if (DisplayPlacements == PINVALID)
            {
                //  The rendering engine confirms that it is fine to go ahead
                //  without this info. This happens in non-gridfitted modes or
                //  when path glyph is simulated.

                snapMode &= ~SnapDisplay;
            }
        }

        if (trailIndex == sublineCount - 1)
        {

            //  Last trail is tricky as it requires more calculations
            //  as we approach the target position.

            if (snapMode & SnapDisplay)
            {
                //  Calibrate cell start position to ensure accurate result
                //  for screen selection.

                INT runStringOffset = sublines[trailIndex].plsrun->ImagerStringOffset;
                INT cellStringOffset =    textCell->cpStartCell - sublines[trailIndex].cpFirstRun
                                        + runStringOffset;

                if (cellStringOffset > runStringOffset)
                {
                    size += DisplayPlacements[cellStringOffset - 1 - StartIndex];
                }
            }
            else
            {
                size += textCell->pointUvStartCell.u -
                        sublines[trailIndex].pointUvStartRun.u;
            }

            //  Now, calculate intra-cell distance

            LSCP advance = lineServicesStringIndex - textCell->cpStartCell;

            if (advance > 0)
            {
                switch (snapMode & ~SnapDisplay)
                {
                    case SnapForward:
                        advance = textCell->cCharsInCell;
                        break;

                    case SnapBackward:
                        advance = 0;
                        break;
                }

                if (advance > (LSCP)textCell->cCharsInCell)
                {
                    //  given string index is within the hidden text range,
                    //  size added up to the last visible character in cell.

                    advance = textCell->cCharsInCell;
                }

                //  trail from cell start,
                //  i.e. querying the position inside a ligature
                //
                //  -Note- dupCell is in direction of subline while trailSize
                //  is in direction of main line (first subline).

                if (sublines[trailIndex].lstflowSubline == sublines[0].lstflowSubline)
                {
                    size += MulDiv (
                        textCell->dupCell,
                        advance,
                        textCell->cCharsInCell
                    );
                }
                else
                {
                    size -= MulDiv (
                        textCell->dupCell,
                        advance,
                        textCell->cCharsInCell
                    );
                }
            }

            if (delta)
            {
                //  the difference btw what we ask and what LS actually gives
                //
                //  delta != 0 in one of these cases
                //    - cluster snapping was applied
                //    - the position we're asking is within a hidden range

                *delta = (textCell->cpStartCell + advance) - lineServicesStringIndex;

                if (   ((snapMode & SnapForward) && *delta < 0)
                    || ((snapMode & SnapBackward) && *delta > 0))
                {
                    //  Client only cares about the snapping delta not the real delta,
                    //  thus ignore negative delta for forward snapping and positive
                    //  delta for backing snapping (wchao, 322595)

                    *delta = 0;
                }
            }
        }

        *trailStart = start;
        *trailSize  = size;
    }

    if (totalTrailSize)
    {
        INT totalSize = 0;

        for (INT i = 0; i < sublineCount; i++)
        {
            status = TranslateSubline (
                lineServicesStringIndex,
                sublines,
                sublineCount,
                textCell,
                i,
                snapMode,
                &start,
                &size,
                delta
            );

            if (status != Ok)
            {
                return status;
            }

            totalSize += abs(size);
        }

        *totalTrailSize = totalSize;
    }

    return status;
}




/////   String size
//
//      Calculate total size occupied by a string starting at the line's first character
//      position to the given string position.
//
//      Note that in BiDi scenario, the size calculated is the sum of all selection parts
//      produced by selecting a given character range.
//

GpStatus BuiltLine::CalculateStringSize (
    INT             stringOffset,           // [IN] offset to the cp relative to line start
    LSQSUBINFO      *sublines,              // [IN] Line Services sublines
    INT             maxSublineCount,        // [IN] max number of sublines
    UINT            snapMode,               // [IN] snap mode within text cell
    INT             *totalSize,             // [OUT] absolute string size
    INT             *delta                  // [OUT] (optional) delta character length after snapping
) const
{
    //  Map Line Services character position

    LSCP lineServicesStringIndex = Imager->LineServicesStringPosition (
        this,
        stringOffset
    );

    if (lineServicesStringIndex == LsStartIndex)
    {
        *totalSize = 0;
        return Ok;
    }

    GpStatus    status = Ok;
    LSTEXTCELL  textCell;
    ULONG       sublineCount = 0;

    if (LsQueryLineCpPpoint(
            LsLine,
            lineServicesStringIndex,
            maxSublineCount,
            sublines,
            &sublineCount,
            &textCell
        ) == lserrNone)
    {
        status = TranslateSubline (
                    lineServicesStringIndex,
                    sublines,
                    sublineCount,
                    &textCell,
                    -1,
                    snapMode,
                    NULL,
                    NULL,
                    delta,
                    totalSize
                 );
    }
    else
    {
        status = GenericError;
    }

    ASSERT(status == Ok);
    return status;
}




GpStatus BuiltLine::UpdateTrailRegion (
    GpRegion    *region,
    INT         linePointOffset,
    INT         trailStart,
    INT         trailSize,
    CombineMode combineMode
) const
{
    if (   !trailStart
        && !trailSize
        && combineMode != CombineModeIntersect)
    {
        return Ok;
    }


    INT x1, y1;
    INT x2, y2;

    //  rectangle start point

    LogicalToXY(
        trailStart,
        linePointOffset,
        &x1,
        &y1
    );

    //  rectangle end point

    LogicalToXY(
        trailStart + trailSize,
        linePointOffset + Ascent + Descent,
        &x2,
        &y2
    );

    //  !! workaround combine region bug !!

    if (x2 - x1 < 0)
    {
        INT xi = x1;
        x1 = x2;
        x2 = xi;
    }

    if (y2 - y1 < 0)
    {
        INT yi = y1;
        y1 = y2;
        y2 = yi;
    }

    RectF trailBox (
        TOREAL(x1 / Imager->WorldToIdeal) + Imager->ImagerOrigin.X,
        TOREAL(y1 / Imager->WorldToIdeal) + Imager->ImagerOrigin.Y,
        TOREAL((x2 - x1) / Imager->WorldToIdeal),
        TOREAL((y2 - y1) / Imager->WorldToIdeal)
    );

    return region->Combine(&trailBox, combineMode);
}




/////   Compute the insertion trail and update the given selection region
//
//      Trail is a mark left by dragging an insertion point to a given cp.
//      In bidi context, a trail contains multiple trail parts. If the given cp
//      is at the end-of-line position, the trail covers the whole line.

GpStatus BuiltLine::GetInsertionTrailRegion (
    INT             linePointOffset,    // [IN] line logical point offset
    INT             stringOffset,       // [IN] offset to the cp relative to line start
    UINT            maxTrailCount,      // [IN] maximum number of trail part
    LSQSUBINFO      *sublines,          // [IN] subline array
    GpRegion        *region             // [OUT] output trail region
) const
{
    ASSERT(region && sublines);

    if (stringOffset <= 0)
    {
        return Ok;
    }

    //  Because of trailing white spaces, the number of character
    //  in a line is limited to the last visible character

    INT characterCount =  !(Imager->GetFormatFlags() & StringFormatFlagsMeasureTrailingSpaces) && LastVisibleRun
                        ? LastVisibleRun->ImagerStringOffset + LastVisibleRun->CharacterCount - StartIndex
                        : CharacterCount;


    if (stringOffset >= characterCount)
    {
        //  Query pass the last character of the line,
        //  give out the whole line extent

        return UpdateTrailRegion(
            region,
            linePointOffset,
            0,
            LineLength,
            CombineModeXor
        );
    }


    //  Backing up til the preceding character of the insertion point is
    //  not a hotkey control (0xffff). We want to include the hotkey as part of 
    //  the selection of the character it underlines.
    
    while (   stringOffset > 0
           && Imager->String[StartIndex + stringOffset - 1] == WCH_IGNORABLE)
    {
        stringOffset--;
    }

    if (!stringOffset)
    {
        return Ok;
    }
    

    LSCP lineServicesStringPosition = Imager->LineServicesStringPosition (
        this,
        stringOffset
    );


    GpStatus    status = Ok;
    LSTEXTCELL  textCell;
    UINT        trailCount = 0;

    LSERR lserr = LsQueryLineCpPpoint(
        LsLine,
        lineServicesStringPosition,
        maxTrailCount,
        sublines,
        (ULONG *)&trailCount,
        &textCell
    );

    if (lserr != lserrNone)
    {
        return GenericError;
    }

    for (UINT i = 0; i < trailCount; i++)
    {
        INT trailStart;
        INT trailSize;

        status = TranslateSubline (
            lineServicesStringPosition,
            sublines,
            trailCount,
            &textCell,
            i,
            SnapDisplay,
            &trailStart,
            &trailSize
        );

        if (status != Ok)
        {
            return status;
        }

        status = UpdateTrailRegion(
            region,
            linePointOffset,
            trailStart,
            trailSize,
            CombineModeXor
        );
    }

    return status;
}





/////   Generate a result region covering all parts of text selection within a single line
//
//      In case of multiple line selection, caller obtain the single line region and combine
//      them to form a bigger one, which covers all text selection.
//
//      If insertion point is passed instead of selection. It returns the region covering
//      from start of the line to the insertion point.
//

GpStatus BuiltLine::GetSelectionTrailRegion (
    INT             linePointOffset,    // [IN] line logical point offset
    INT             stringOffset,       // [IN] offset to the cp relative to line start
    INT             length,             // [IN] selection length
    GpRegion        *region             // [OUT] selection region
) const
{
    if (!region)
    {
        return InvalidParameter;
    }

#if DBG
    SpanRider<BuiltLine *> lineRider(&Imager->BuiltLineVector);
    lineRider.SetPosition(StartIndex + stringOffset);
    ASSERT (StartIndex == (INT)lineRider.GetCurrentSpanStart());
#endif

    AutoArray<LSQSUBINFO> sublines(new LSQSUBINFO [MaxSublineCount]);

    if (!sublines)
    {
        return OutOfMemory;
    }


    //  Make sure display information is cached

    GpStatus status = CheckDisplayPlacements();
    IF_NOT_OK_WARN_AND_RETURN(status);


    //  The maxmium number of trail parts is never greater than
    //  the maximum of sublines.

    status = GetInsertionTrailRegion (
        linePointOffset,
        stringOffset,
        MaxSublineCount,
        sublines.Get(),
        region
    );

    if (status == Ok && length)
    {
        //  It is a selection not an insertion point

        status = GetInsertionTrailRegion (
            linePointOffset,
            stringOffset + length,
            MaxSublineCount,
            sublines.Get(),
            region
        );

        if (status == Ok)
        {

            //  What we have at this point is a series of discrete selection
            //  boxes derived from LS subline structures which snaps to the
            //  nominal position at edges.
            //
            //  Working out the right edges at subline level is too complex
            //  as subline contains multiple and most of the time partial runs
            //  with given cp in LSCP.
            //
            //  A more reliable and easier to understand approach is to handle the
            //  whole region at once after all sublines have been interpreted, making
            //  them snap to the right display boundaries pre-calculated by our
            //  drawing code. This can result in either shrinking or growing the
            //  region depending on directionality of leading/trailing adjustment
            //  of runs at edges.


            INT     blockLevel = Imager->GetParagraphEmbeddingLevel();
            lsrun   *first;

            status = Imager->GetTextRun (
                LsStartIndex,
                &first
            );
            IF_NOT_OK_WARN_AND_RETURN(status);


            INT leading  = 0;   //  line leading adjustment
            INT trailing = 0;   //  line trailing adjustment


            if (first)
            {
                INT stringAtLeading;
                INT stringAtTrailing;


                if (blockLevel == (first->Item.Level & 1))
                {
                    leading  += first->Adjust.Leading;
                    trailing += first->Adjust.Trailing;

                    stringAtLeading  = first->ImagerStringOffset;
                    stringAtTrailing = stringAtLeading + first->CharacterCount;
                }
                else
                {
                    leading  -= first->Adjust.Trailing;
                    trailing -= first->Adjust.Leading;

                    stringAtTrailing = first->ImagerStringOffset;
                    stringAtLeading  = stringAtTrailing + first->CharacterCount;
                }


                if (leading)
                {
                    //  Include/exclude line leading spaces

                    status = UpdateTrailRegion(
                        region,
                        linePointOffset,
                        0,
                        leading,
                        (
                            // Only include when we know the edge is being selected
                            leading < 0
                         && stringAtLeading - StartIndex >= stringOffset
                         && stringAtLeading - StartIndex <= stringOffset + length
                        )
                        ? CombineModeUnion
                        : CombineModeExclude
                    );
                    IF_NOT_OK_WARN_AND_RETURN(status);
                }


                if (LastVisibleRun && first != LastVisibleRun)
                {
                    if (blockLevel == (LastVisibleRun->Item.Level & 1))
                    {
                        trailing += LastVisibleRun->Adjust.Trailing;

                        stringAtTrailing =   LastVisibleRun->ImagerStringOffset
                                           + LastVisibleRun->CharacterCount;
                    }
                    else
                    {
                        trailing -= LastVisibleRun->Adjust.Leading;

                        stringAtTrailing = LastVisibleRun->ImagerStringOffset;
                    }
                }


                if (trailing)
                {
                    //  Include/exclude line trailing spaces

                    status = UpdateTrailRegion(
                        region,
                        linePointOffset,
                        LineLength,
                        trailing,
                        (
                             // Only include when we know the edge is being selected
                             trailing > 0
                          && stringAtTrailing - StartIndex >= stringOffset
                          && stringAtTrailing - StartIndex <= stringOffset + length
                        )
                        ? CombineModeUnion
                        : CombineModeExclude
                    );
                }
            }
        }
    }

    return status;
}




void BuiltLine::GetBaselineOffset(
    INT     *nominalBaseline,   // [OUT] logical distance to nominal baseline
    INT     *baselineAdjustment // [OUT] adjustment to the display baseline
) const
{
    if (     Imager->IsFormatVertical()
        &&  !Imager->IsFormatRightToLeft())
    {
        *nominalBaseline = GetDescent();
        *baselineAdjustment = Imager->DefaultFontGridFitBaselineAdjustment;

        // Adjust the bottom margin slightly to make room for hinting
        // as long as we have the left/right margins enabled - Version 2
        // should expose this as an independent value!

        const GpStringFormat *format = Imager->FormatVector.GetDefault();

        if (!format || format->GetLeadingMargin() != 0.0f)
        {
            // This offset is in ideal units, adjust the offset accordingly
            // for vertical text.
            *baselineAdjustment += GpRound(2048.0f * DefaultBottomMargin);
        }
    }
    else
    {
        *nominalBaseline = GetAscent();
        
        if (Imager->IsFormatVertical())
        {
            *baselineAdjustment = -Imager->DefaultFontGridFitBaselineAdjustment;
        }
        else
        {
            *baselineAdjustment = Imager->DefaultFontGridFitBaselineAdjustment;
        }
    }
}
   



void BuiltLine::SetDisplayBaseline(
    const PointF    *original,  // [IN] original baseline, absolute position in world unit
    const PointF    *current    // [IN] new baseline, absolute position in world unit
) const
{
    if (!DisplayBaselineAdjust)
    {
        INT originalOffset = 
            Imager->IsFormatVertical() ? 
            GpRound((original->X - Imager->ImagerOrigin.X) * Imager->WorldToIdeal) :
            GpRound((original->Y - Imager->ImagerOrigin.Y) * Imager->WorldToIdeal) ;
            
        INT currentOffset = 
            Imager->IsFormatVertical() ? 
            GpRound((current->X - Imager->ImagerOrigin.X) * Imager->WorldToIdeal) :
            GpRound((current->Y - Imager->ImagerOrigin.Y) * Imager->WorldToIdeal) ;

        DisplayBaselineAdjust += currentOffset - originalOffset;
    }
}




/////   Map logical offsets to XY TextImager's relative position
//
//      entry   textPointOffset - distance from LS start of line to point
//                                in line, positive in LS du sense.
//              linePointOffset - distance from origin into imager in
//                                paragraph flow direction.


void BuiltLine::LogicalToXY (
    IN  INT  textPointOffset,    // text flow distance (LS u)
    IN  INT  linePointOffset,    // line flow distance (LS v)
    OUT INT  *x,                 // horizontal offset  (LS x)
    OUT INT  *y                  // vertical offset    (LS y)
) const
{
    // linePointOffset represents the offset of the leading long edge of the
    // target line from the leading long edge of the first line.

    StringAlignment lineAlignment = Imager->GetFormatLineAlign();

    if (lineAlignment != StringAlignmentNear)
    {
        INT textDepth       = GpRound(Imager->TextDepth      * Imager->WorldToIdeal);
        INT textDepthLimit  = GpRound(Imager->TextDepthLimit * Imager->WorldToIdeal);

        switch (lineAlignment)
        {
            case StringAlignmentCenter: linePointOffset += (textDepthLimit - textDepth) / 2; break;
            case StringAlignmentFar:    linePointOffset += textDepthLimit - textDepth;       break;
        }
    }



    if (Imager->IsFormatVertical())
    {
        if (Imager->IsFormatRightToLeft())
        {
            // Vertical, lines advance from right to left
            *x =   GpRound(Imager->Width * Imager->WorldToIdeal)
                 - linePointOffset;
            *y = AlignmentOffset + textPointOffset;
        }
        else
        {
            // Vertical, lines advance from left to right
            *x = linePointOffset;
            *y = AlignmentOffset + textPointOffset;
        }
    }
    else
    {
        if (Imager->IsFormatRightToLeft())
        {
            // RTL horizontal. textPointOffset runs left from line origin.
            *x = AlignmentOffset - textPointOffset;
            *y = linePointOffset;
        }
        else
        {
            // Normal case. Text horizontal, origin at left
            *x = AlignmentOffset + textPointOffset;
            *y = linePointOffset;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\digitsubstitution.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Header file for DigitSubstitution.cpp
*
* Revision History:
*
*   05/30/2000 Mohamed Sadek [msadek]
*       Created it.
*
\**************************************************************************/

extern enum ItemScript;

#define IsDBCSCodePage(acp)  ((acp) == 932 || \
                              (acp) == 936 || \
                              (acp) == 949 || \
                              (acp) == 950 )


const ItemScript GetDigitSubstitutionsScript(GpStringDigitSubstitute substitute, LANGID language);
LANGID GetUserLanguageID();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\digitsubstitution.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   DigitSubstitution.cpp
*
* Abstract:
*
*   Implements digit substitution logic.
*
* Notes:
*
* Revision History:
*
*   05/30/2000 Mohamed Sadek [msadek]
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

enum GpStringUserDigitSubstitute
{
    StringUserDigitSubstituteContext    = 0,
    StringUserDigitSubstituteNone       = 1,
    StringUserDigitSubstituteNational   = 2
};

GpStringUserDigitSubstitute UserDigitSubstitute;
LCID UserLocale;

const ItemScript LanguageToDigitScript[] = {
/*  00 NEUTRAL             */  ScriptLatinNumber,
/*  01 ARABIC              */  ScriptArabicNum,
/*  02 BULGARIAN           */  ScriptLatinNumber,
/*  03 CATALAN             */  ScriptLatinNumber,
/*  04 CHINESE             */  ScriptLatinNumber,
/*  05 CZECH               */  ScriptLatinNumber,
/*  06 DANISH              */  ScriptLatinNumber,
/*  07 GERMAN              */  ScriptLatinNumber,
/*  08 GREEK               */  ScriptLatinNumber,
/*  09 ENGLISH             */  ScriptLatinNumber,
/*  0a SPANISH             */  ScriptLatinNumber,
/*  0b FINNISH             */  ScriptLatinNumber,
/*  0c FRENCH              */  ScriptLatinNumber,
/*  0d HEBREW              */  ScriptLatinNumber,
/*  0e HUNGARIAN           */  ScriptLatinNumber,
/*  0f ICELANDIC           */  ScriptLatinNumber,
/*  10 ITALIAN             */  ScriptLatinNumber,
/*  11 JAPANESE            */  ScriptLatinNumber,
/*  12 KOREAN              */  ScriptLatinNumber,
/*  13 DUTCH               */  ScriptLatinNumber,
/*  14 NORWEGIAN           */  ScriptLatinNumber,
/*  15 POLISH              */  ScriptLatinNumber,
/*  16 PORTUGUESE          */  ScriptLatinNumber,
/*  17 RHAETOROMANIC       */  ScriptLatinNumber,
/*  18 ROMANIAN            */  ScriptLatinNumber,
/*  19 RUSSIAN             */  ScriptLatinNumber,
/*  1a CROATIAN/SERBIAN    */  ScriptLatinNumber,
/*  1b SLOVAK              */  ScriptLatinNumber,
/*  1c ALBANIAN            */  ScriptLatinNumber,
/*  1d SWEDISH             */  ScriptLatinNumber,
/*  1e THAI                */  ScriptThaiNum,
/*  1f TURKISH             */  ScriptLatinNumber,
/*  20 URDU                */  ScriptUrduNum,
/*  21 INDONESIAN          */  ScriptLatinNumber,
/*  22 UKRAINIAN           */  ScriptLatinNumber,
/*  23 BELARUSIAN          */  ScriptLatinNumber,
/*  24 SLOVENIAN           */  ScriptLatinNumber,
/*  25 ESTONIAN            */  ScriptLatinNumber,
/*  26 LATVIAN             */  ScriptLatinNumber,
/*  27 LITHUANIAN          */  ScriptLatinNumber,
/*  28 TAJIK               */  ScriptLatinNumber,
/*  29 FARSI               */  ScriptFarsiNum,
/*  2a VIETNAMESE          */  ScriptLatinNumber,
/*  2b ARMENIAN            */  ScriptLatinNumber,
/*  2c AZERI               */  ScriptLatinNumber,
/*  2d BASQUE              */  ScriptLatinNumber,
/*  2e SORBIAN             */  ScriptLatinNumber,
/*  2f MACEDONIAN          */  ScriptLatinNumber,
/*  30 SUTU                */  ScriptLatinNumber,
/*  31 TSONGA              */  ScriptLatinNumber,
/*  32 TSWANT              */  ScriptLatinNumber,
/*  33 VENDA               */  ScriptLatinNumber,
/*  34 XHOSA               */  ScriptLatinNumber,
/*  35 ZULU                */  ScriptLatinNumber,
/*  36 AFRIKAANS           */  ScriptLatinNumber,
/*  37 GEORGIAN            */  ScriptLatinNumber,
/*  38 FAEROESE            */  ScriptLatinNumber,
/*  39 HINDI               */  ScriptHindiNum,
/*  3a MALTESE             */  ScriptLatinNumber,
/*  3b SAMI                */  ScriptLatinNumber,
/*  3c GAELIC              */  ScriptLatinNumber,
/*  3d YIDDISH             */  ScriptLatinNumber,
/*  3e MALAY               */  ScriptLatinNumber,
/*  3f KAZAK               */  ScriptLatinNumber,
/*  40 KIRGHIZ             */  ScriptLatinNumber,
/*  41 SWAHILI             */  ScriptLatinNumber,
/*  42 TURKMEN             */  ScriptLatinNumber,
/*  43 UZBEK               */  ScriptLatinNumber,
/*  44 TATAR               */  ScriptLatinNumber,
/*  45 BENGALI             */  ScriptBengaliNum,
/*  46 GURMUKHI/PUNJABI    */  ScriptGurmukhiNum,
/*  47 GUJARATI            */  ScriptGujaratiNum,
/*  48 ORIYA               */  ScriptOriyaNum,
/*  49 TAMIL               */  ScriptTamilNum,
/*  4A TELUGU              */  ScriptTeluguNum,
/*  4B KANNADA             */  ScriptKannadaNum,
/*  4C MALAYALAM           */  ScriptMalayalamNum,
/*  4d ASSAMESE            */  ScriptBengaliNum,
/*  4e MARATHI             */  ScriptHindiNum,
/*  4f SANSKRIT            */  ScriptHindiNum,
/*  50 MONGOLIAN           */  ScriptMongolianNum,
/*  51 TIBETAN             */  ScriptTibetanNum,
/*  52 WELCH               */  ScriptLatinNumber,
/*  53 KHMER               */  ScriptKhmerNum,
/*  54 LAO                 */  ScriptLaoNum,
/*  55 BURMESE             */  ScriptLatinNumber,
/*  56 GALLEGO             */  ScriptLatinNumber,
/*  57 KONKANI             */  ScriptHindiNum,
/*  58 MANIPURI            */  ScriptBengaliNum,
/*  59 SINDHI              */  ScriptGurmukhiNum,
/*  5a SYRIAC              */  ScriptLatinNumber,
/*  5b SINHALESE           */  ScriptLatinNumber,
/*  5c CHEROKEE            */  ScriptLatinNumber,
/*  5d CANADIAN            */  ScriptLatinNumber,
/*  5e ETHIOPIC            */  ScriptLatinNumber,
/*  5f TAMAZIGHT           */  ScriptArabicNum,
/*  60 KASHMIRI            */  ScriptUrduNum,
/*  61 NEPALI              */  ScriptHindiNum,
/*  62 FRISIAN             */  ScriptLatinNumber,
/*  63 PASHTO              */  ScriptUrduNum,
/*  64 FILIPINO            */  ScriptLatinNumber,
/*  65 THAANA/MALDIVIAN    */  ScriptLatinNumber,
/*  66 EDO                 */  ScriptLatinNumber,
/*  67 FULFULDE            */  ScriptLatinNumber,
/*  68 HAUSA               */  ScriptLatinNumber,
/*  69 IBIBIO              */  ScriptLatinNumber,
/*  6a YORUBA              */  ScriptLatinNumber,
/*  6b                     */  ScriptLatinNumber,
/*  6c                     */  ScriptLatinNumber,
/*  6d                     */  ScriptLatinNumber,
/*  6e                     */  ScriptLatinNumber,
/*  6f                     */  ScriptLatinNumber,
/*  70 IGBO                */  ScriptLatinNumber,
/*  71 KANURI              */  ScriptLatinNumber,
/*  72 OROMO               */  ScriptLatinNumber,
/*  73 TIGRIGNA            */  ScriptLatinNumber,
/*  74 GUARANI             */  ScriptLatinNumber,
/*  75 HAWAIIAN            */  ScriptLatinNumber,
/*  76 LATIN               */  ScriptLatinNumber,
/*  77 SOMOLI              */  ScriptLatinNumber,
/*  78 YI                  */  ScriptLatinNumber
};

/**************************************************************************\
*
* Function Description:
*   this function check for the digit substitution according to the 
*   giving language and return the numeric script matches this language.
*   it also create and maintain the cache from the system.
*
* Arguments:
*   language [in] the language to check for digit substitution.
*
* Return Value:
*   the numeric script for that language or ScriptNone for no substitution
*
* Created:
*   originaly created by msadek and modified by tarekms to fit in the 
*   new design
*
\**************************************************************************/
const ItemScript GetNationalDigitScript(LANGID language)
{
    if(Globals::NationalDigitCache == NULL)
    {
        Globals::NationalDigitCache = new IntMap<BYTE>;
        if (!Globals::NationalDigitCache || Globals::NationalDigitCache->GetStatus() != Ok)
        {
            delete Globals::NationalDigitCache, Globals::NationalDigitCache = 0;
            return ScriptNone;
        }
    }
    
    switch(Globals::NationalDigitCache->Lookup(language))
    {
        case 0xff:
            // checked before and not digit substitutions needed
            return ScriptNone;

        case 0x01:
            // checked before and should be mapped to Traditional
            if(PRIMARYLANGID(language) > (ARRAY_SIZE(LanguageToDigitScript)-1))
            {
                return ScriptNone;
            }
            
            if (languageDigits[LanguageToDigitScript[PRIMARYLANGID(language)]][0] == 0)
            {
                return ScriptNone;
            }
            else
            {
                return LanguageToDigitScript[PRIMARYLANGID(language)];
            }

        case 0x00:
            // never visited before, have to fetch it from registry.
            LCID locale = MAKELCID(language, SORT_DEFAULT);
            WCHAR digits[20];
            DWORD   bufferCount;
            if(!IsValidLocale(locale, LCID_INSTALLED))
            {
                Globals::NationalDigitCache->Insert(language, 0xff);
                return ScriptNone;
            }

            BOOL isThereSubstitution = FALSE;
            if (Globals::IsNt)
            {
                bufferCount = GetLocaleInfoW(locale,
                                             LOCALE_SNATIVEDIGITS,
                                             digits, 20);
                isThereSubstitution = (bufferCount>1 && (digits[1] != 0x0031));
            }
            else
            {
                // GetLocaleInfoW fails on Windows 9x. and we cannot depend on 
                // GetLocalInfoA because it returns Ansi output which wouldn't help
                // So we hard coded the information from the file:
                // %sdxroot%\base\win32\winnls\data\other\locale.txt
                
                switch (locale)
                {
                    case 0x0401:           // Arabic   - Saudi Arabia
                    case 0x0801:           // Arabic   - Iraq
                    case 0x0c01:           // Arabic   - Egypt
                    case 0x2001:           // Arabic   - Oman
                    case 0x2401:           // Arabic   - Yemen
                    case 0x2801:           // Arabic   - Syria
                    case 0x2c01:           // Arabic   - Jordan
                    case 0x3001:           // Arabic   - Lebanon
                    case 0x3401:           // Arabic   - Kuwait
                    case 0x3801:           // Arabic   - U.A.E.
                    case 0x3c01:           // Arabic   - Bahrain
                    case 0x4001:           // Arabic   - Qatar
                    case 0x041e:           // Thai     - Thailand
                    case 0x0420:           // Urdu     - Pakistan
                    case 0x0429:           // Farsi    - Iran
                    case 0x0446:           // Punjabi  - India (Gurmukhi Script)
                    case 0x0447:           // Gujarati - India (Gujarati Script)
                    case 0x044a:           // Telugu   - India (Telugu Script)
                    case 0x044b:           // Kannada  - India (Kannada Script)
                    case 0x044e:           // Marathi  - India
                    case 0x044f:           // Sanskrit - India
                    case 0x0457:           // Konkani  - India
                        isThereSubstitution = TRUE;
                        break;
                    default:
                        isThereSubstitution = FALSE;
                        break;
                }
            }

            if (isThereSubstitution)
            {
                if(PRIMARYLANGID(language) > (ARRAY_SIZE(LanguageToDigitScript)-1))
                {
                    Globals::NationalDigitCache->Insert(language, 0xff);
                    return ScriptNone;
                }
                Globals::NationalDigitCache->Insert(language, 0x01);

                if (languageDigits[LanguageToDigitScript[PRIMARYLANGID(language)]][0] == 0)
                {
                    return ScriptNone;
                }
                else
                {
                    return LanguageToDigitScript[PRIMARYLANGID(language)];
                }
            }
            else
            {
                Globals::NationalDigitCache->Insert(language, 0xff);
                return ScriptNone;
            }
    }
    return ScriptNone;
}

/**************************************************************************\
*
* Function Description:
*   it gets the suitable numeric script for digit substitution 
*
* Arguments:
*   substitute  [in] the type of the substitution.
*   language    [in] the language to check for digit substitution.
*
* Return Value:
*   the numeric script for that language or ScriptNone for no substitution
*
* Created:
*   originaly created by msadek and modified by tarekms to fit in the 
*   new design
*
\**************************************************************************/

const ItemScript GetDigitSubstitutionsScript(GpStringDigitSubstitute substitute, LANGID language)
{
    if (LANG_NEUTRAL == PRIMARYLANGID(language))
    {
        switch(SUBLANGID(language))
        {
            case SUBLANG_SYS_DEFAULT:
                language = LANGIDFROMLCID(ConvertDefaultLocale(LOCALE_SYSTEM_DEFAULT));
            break;

            case  SUBLANG_DEFAULT:
                language = LANGIDFROMLCID(ConvertDefaultLocale(LOCALE_USER_DEFAULT));
            break;
            
            case SUBLANG_NEUTRAL:
            default : // treat anything else as user English.
                language = LANG_ENGLISH;
        }
    }
    
    if(StringDigitSubstituteNone == substitute
        || (LANG_ENGLISH == PRIMARYLANGID(language)
        && StringDigitSubstituteUser != substitute))
    {
        return ScriptNone;
    }
    
    switch(substitute)
    {
        case StringDigitSubstituteTraditional:

            if(PRIMARYLANGID(language) > (ARRAY_SIZE(LanguageToDigitScript)-1))
            {
                return ScriptNone;
            }

            if ( languageDigits[LanguageToDigitScript[PRIMARYLANGID(language)]][0] == 0)
            {
                return ScriptNone;
            }
            else
            {
                return LanguageToDigitScript[PRIMARYLANGID(language)];
            }

        case StringDigitSubstituteNational:

            return GetNationalDigitScript(language);

        case StringDigitSubstituteUser:

            LANGID userLanguage = GetUserLanguageID();

            switch (UserDigitSubstitute)
            {
                case StringUserDigitSubstituteContext:
                    if ((PRIMARYLANGID(userLanguage) != LANG_ARABIC)
                        && (PRIMARYLANGID(userLanguage) != LANG_FARSI))
                    {
                        return ScriptNone;
                    }
                    return ScriptContextNum;

                case StringUserDigitSubstituteNone:
                    return ScriptNone;

                case StringUserDigitSubstituteNational:
                    return GetNationalDigitScript(userLanguage);
            }
    }
    return ScriptNone;
}


LANGID GetUserLanguageID()
{
    if(Globals::UserDigitSubstituteInvalid)
    {
        WCHAR digits[20];
        DWORD bufferCount = 0;
        UserLocale = ConvertDefaultLocale(LOCALE_USER_DEFAULT);

        // LOCALE_IDIGITSUBSTITUTION is not defined on Windows 9x platforms
        // also GetLocaleInfoW is fail on Windows 9x so we avoid calling it
        // just in case it might return undefined result.
        
        if (Globals::IsNt)
        {
            bufferCount = GetLocaleInfoW(UserLocale,
                                LOCALE_IDIGITSUBSTITUTION,
                                digits, 20);
        }
        
        if (bufferCount == 0)
        {
            // Not on NT, or no such LC type, so read HKCU\Control Panel\International\NumShape
            DWORD   dwType;
            long    rc;             // Registry return code
            HKEY    hKey;           // Registry key
            if (RegOpenKeyExA(HKEY_CURRENT_USER,
                            "Control Panel\\International",
                            0, KEY_READ, &hKey) == ERROR_SUCCESS)
            {
                digits[0] = 0;
                if ((rc = RegQueryValueExA(hKey,
                                "NumShape",
                                NULL,
                                &dwType,
                                (BYTE*)digits,
                                &bufferCount) != ERROR_SUCCESS))
                { 
                    bufferCount = 0;
                }
                RegCloseKey(hKey);
            }
        }
                     
        switch(digits[0])
        {
            case 0x0032:
                UserDigitSubstitute = StringUserDigitSubstituteNational;
                break;
                        
            case 0x0031:
                UserDigitSubstitute = StringUserDigitSubstituteNone;
                break;
                     
            case 0x0030:
                default:
                UserDigitSubstitute = StringUserDigitSubstituteContext;
        }

        Globals::UserDigitSubstituteInvalid = FALSE;
    }

    return LANGIDFROMLCID(UserLocale);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\builtline.hpp ===
#ifndef _BUILTLINE_HPP
#define _BUILTLINE_HPP



class EllipsisInfo;



/////   BuiltLine
//
//      Contains the PLSLINE line information pointer.
//
//      Contains line position information.
//
//      Always belongs to a context.
//
//      Values are in line services ideal units.


class BuiltLine
{

public:

    enum
    {
        INFINITE_LINELIMIT  = 0x1000000,    // Unlimited line break boundary
        MAX_BREAKRECORD     = 61            // possible maximum level allowed in Unicode 3.0
    };


    BuiltLine()
    :   Imager                  (NULL),
        LsLine                  (NULL),
        LsContext               (NULL),
        LsStartIndex            (0),
        StartIndex              (0),
        LsCharacterCount        (0),
        CharacterCount          (0),
        Ascent                  (0),
        Descent                 (0),
        LineSpacing             (0),
        LineLength              (0),
        BreakRecord             (NULL),
        BreakRecordCount        (0),
        LeftOrTopMargin         (0),
        RightOrBottomMargin     (0),
        MaxSublineCount         (0),
        Trimming                (StringTrimmingNone),
        AlignmentOffset         (0),
        EllipsisPointOffset     (0),
        LeftOrTopGlyphEdge      (0),
        LastVisibleRun          (NULL),
        DisplayPlacements       ((INT *)PINVALID),
        DisplayBaselineAdjust   (0),
        Status                  (WrongState) // Should never be used constructed like this
    {}


    // This constructor does all the work of building the line

    BuiltLine(
        ols             *lineServicesOwner,          // [IN] Line Services context
        INT              stringIndex,                // [IN] string start index
        LSCP             lineServicesStartIndex,     // [IN] Line Services string start index
        StringTrimming   trimming,                   // [IN] how to end the line
        BuiltLine       *previousLine,               // [IN] previous line
        BOOL             forceEllipsis = FALSE       // [IN] enforce trim ellipsis?
    );


    ~BuiltLine()
    {
        if (LsLine)
        {
            LsDestroyLine(LsContext, LsLine);
        }

        if (BreakRecord)
        {
            delete [] BreakRecord;
        }

        if (   DisplayPlacements
            && DisplayPlacements != PINVALID)
        {
            delete [] DisplayPlacements;
        }
    }


    GpStatus Draw(const POINT *lineOrigin) const
    {
        // lineOrigin is in Line Services ideal coordinates

        if (LsDisplayLine(LsLine, lineOrigin, 1, NULL) == lserrNone)
        {
            return Ok;
        }
        else
        {
            return GenericError;
        }
    }


    bool operator== (INT right) const // This comparison only for NULL tests
    {
        ASSERT(right == 0);
        return LsLine == NULL;
    }

    INT GetAscent()                 const {return Ascent;}
    INT GetDescent()                const {return Descent;}
    INT GetLineSpacing()            const {return LineSpacing;}
    INT GetLineLength()             const {return LineLength;}
    INT GetAlignmentOffset()        const {return AlignmentOffset;}
    INT GetLeftOrTopMargin()        const {return LeftOrTopMargin;}
    INT GetRightOrBottomMargin()    const {return RightOrBottomMargin;}
    INT GetLeftOrTopGlyphEdge()     const {return LeftOrTopGlyphEdge;}


    //  Break records

    BREAKREC *GetBreakRecord()       const {return BreakRecord;}
    ULONG     GetBreakRecordCount()  const {return BreakRecordCount;}


    //  Character count

    INT GetLsStartIndex()                   const {return LsStartIndex;}
    INT GetDisplayableCharacterCount()      const {return CharacterCount;}
    INT GetLsDisplayableCharacterCount()    const {return LsCharacterCount;}



    INT GetUntrimmedCharacterCount (
        INT     stringOffset,               // [IN] line start string position
        INT     *lsLineStringLength = NULL  // [OUT] line span length in Line Services index
    );




    //  CPtoX

    GpStatus GetSelectionTrailRegion (
        INT             linePointOffset,    // [IN] line logical point offset
        INT             stringOffset,       // [IN] offset to the cp relative to line start
        INT             length,             // [IN] selection length
        GpRegion        *region             // [OUT] selection region
    ) const;



    //  Trimming

    GpStatus UpdateContentWithPathEllipsis (
        EllipsisInfo    *ellipsis,          // [IN] ellipsis info
        INT             lineLengthLimit,    // [IN] line length limit including margins
        BOOL            *contentChanged     // [IN/OUT] content changed?
    );


    BOOL IsTrimmed() const
    {
        //  Path ellipsis is not considered a trimmed line.
        //  We just hide part of it with ellipsis.

        return     Trimming != StringTrimmingNone
                && Trimming != StringTrimmingEllipsisPath;
    }

    BOOL IsEllipsis() const
    {
        return     Trimming == StringTrimmingEllipsisCharacter
                || Trimming == StringTrimmingEllipsisWord
                || Trimming == StringTrimmingEllipsisPath;
    }

    INT GetEllipsisOffset() const { return EllipsisPointOffset; }


    void SetTrimming(StringTrimming trimming)
    {
        Trimming = trimming;
    }


    /////   Coordinate mapping
    //
    //

    void LogicalToXY (
        INT   textPointOffset,    // [IN] text flow distance (LS u)
        INT   linePointOffset,    // [IN] line flow distance (LS v)
        INT  *x,                  // [OUT] horizontal offset (LS x)
        INT  *y                   // [OUT] vertical offset   (LS y)
    ) const;




    /////   Logical glyph placement
    //
    //      Called back from FullTextImager::DrawGlyphs for recording
    //      processed glyph advance width per logical cluster. Logical
    //      glyph placement is cached in BuiltLine and used by screen
    //      selection region.
    //

    GpStatus RecordDisplayPlacements(
        const GpTextItem    *textItem,              // [IN] text item
        UINT                stringOffset,           // [IN] string offset
        UINT                stringLength,           // [IN] string length
        GMAP                *glyphMap,              // [IN] character to glyph map
        const INT           *glyphAdvances,         // [IN] glyph advance widths in ideal unit
        INT                 glyphCount,             // [IN] glyph count
        INT                 originAdjust            // [IN] leading origin adjustment
    ) const;




    void UpdateLastVisibleRun(lsrun *run) const
    {
        if (   run
            && run->RunType == lsrun::RunText
            && run != LastVisibleRun
            && (   !LastVisibleRun
                || run->ImagerStringOffset >= LastVisibleRun->ImagerStringOffset))
        {
            LastVisibleRun = run;
        }
    }


    void GetBaselineOffset(
        INT     *nominalBaseline,   // [OUT] logical distance to nominal baseline
        INT     *baselineAdjustment // [OUT] adjustment to the display baseline
    ) const;


    void SetDisplayBaseline(
        const PointF    *original,  // [IN] original baseline, absolute position in world unit
        const PointF    *current    // [IN] new baseline, absolute position in world unit
    ) const;


    INT GetDisplayBaselineAdjust() const { return DisplayBaselineAdjust; }
    

    GpStatus GetStatus() const
    {
        return Status;
    }


private:


    /////   Line creation
    //

    GpStatus CreateLine (
        INT             stringIndex,            // [IN] string start position
        INT             lineLengthLimit,        // [IN] line length limit (excluding margins)
        StringTrimming  trimming,               // [IN] string trimming
        INT             formatFlags,            // [IN] format flags
        BOOL            forceEllipsis,          // [IN] enforce trim ellipsis?
        BuiltLine       *previousLine           // [IN] previous line
    );


    GpStatus CreateLineCore (
        INT             formattingWidth,        // [IN] formatting boundary
        StringTrimming  trimming,               // [IN] trimming type
        BuiltLine       *previousLine,          // [IN] previous line
        UINT            maxBrkCount,            // [IN] maximum number of break records
        BREAKREC        *brkRecords,            // [OUT] break records
        DWORD           *brkCount,              // [OUT] break record count
        LSLINFO         *lineInfo               // [OUT] line information
    );


    GpStatus RecreateLineEllipsis (
        INT             stringIndex,            // [IN] line start index
        INT             lineLengthLimit,        // [IN] line length limit
        StringTrimming  trimmingRequested,      // [IN] kind of trimming requested
        INT             formatFlags,            // [IN] format flags
        LSLINFO         *lineInfoOriginal,      // [IN] original line's properties
        BuiltLine       *previousLine,          // [IN] previous line
        StringTrimming  *trimmingDone,          // [OUT] kind of trimming implemented
        LSLINFO         *lineInfoNew            // [OUT] new line properties
    );



    /////   Querying
    //


    enum
    {
        SnapNone            = 0,    // average final position per character length within the cell
        SnapBackward        = 1,    // snap backward to the leading edge of the cell
        SnapForward         = 2,    // snap forward to the trailing edge of the cell
        SnapDisplay         = 0x10  // snap to display grid (on-screen selection)
    };


    GpStatus TranslateSubline(
        LSCP                lineServicesStringIndex,    // [IN] string index creating sublines
        const LSQSUBINFO    *sublines,                  // [IN] Line Services sublines
        INT                 sublineCount,               // [IN] number of sublines
        const LSTEXTCELL    *textCell,                  // [IN] text cell
        INT                 trailIndex,                 // [IN] trail in question
        UINT                snapMode,                   // [IN] trail end snap mode
        INT                 *trailStart,                // [OUT] trail start
        INT                 *trailSize,                 // [OUT] trail size
        INT                 *delta = NULL,              // [OUT] (optional) character length delta after snapping
        INT                 *totalTrailSize = NULL      // [OUT] (optional) total absolute size of all trails
    ) const;


    GpStatus CalculateStringSize (
        INT             stringOffset,           // [IN] offset to the cp relative to line start
        LSQSUBINFO      *sublines,              // [IN] Line Services sublines
        INT             maxSublineCount,        // [IN] max number of sublines
        UINT            snapMode,               // [IN] snap mode within text cell
        INT             *totalSize,             // [OUT] absolute string size
        INT             *delta = NULL           // [OUT] (optional) delta character length after snapping
    ) const;


    GpStatus GetInsertionTrailRegion (
        INT             linePointOffset,    // [IN] line logical point offset
        INT             stringOffset,       // [IN] offset to the cp relative to line start
        UINT            maxTrailCount,      // [IN] maximum number of trail part
        LSQSUBINFO      *sublines,          // [IN] subline array
        GpRegion        *region             // [OUT] output trail region
    ) const;


    GpStatus CalculateLineLength (
        BOOL    trailingSpacesIncluded,     // [IN] including trailing spaces?
        INT     *lineLength                 // [OUT] (optional) updated line length
    ) const;


    GpStatus CalculateCharacterCount(
        INT             stringIndex,                // [IN] line start string index
        LSCP            lineLimitIndex,             // [IN] Line Services line limit index
        INT             *characterCount             // [OUT] (optional) updated character count
    ) const;



    GpStatus CheckDisplayPlacements() const;




    /////   Backing store update
    //

    GpStatus CheckUpdateLineLength (
        BOOL    trailingSpacesIncluded, // [IN] including trailing spaces?
        BOOL    forceUpdate = FALSE     // [IN] (optional) force updating?
    );


    GpStatus CheckUpdateCharacterCount(
        INT             stringIndex,                // [IN] line start string index
        LSCP            lineLimitIndex,             // [IN] Line Services line limit index
        BOOL            forceUpdate = FALSE         // [IN] (optional) force updating?
    );



    /////   Trimming support
    //

    GpStatus TrimText (
        INT         stringOffset,           // [IN] string offset from line start
        INT         stringLength,           // [IN] string length
        INT         size,                   // [IN] string size in ideal unit
        INT         sizeLimit,              // [IN] maximum possible string size
        LSQSUBINFO  *sublines,              // [IN] LS sublines
        INT         maxSublineCount,        // [IN] valid subline count
        INT         ellipsisLength,         // [IN] character length of ellipsis string
        INT         *trimmedLength,         // [IN/OUT] number of character being trimmed out
        BOOL        leadingTrim = FALSE     // [IN] TRUE - trim from the first character onward
    );



    /////   Incremental selection region update
    //

    GpStatus UpdateTrailRegion (
        GpRegion    *region,
        INT         linePointOffset,
        INT         trailStart,
        INT         trailSize,
        CombineMode combineMode
    ) const;




    PLSLINE          LsLine;
    PLSC             LsContext;              // Used only when calling LsDestroyLine
    FullTextImager  *Imager;                 // Owning text imager

    LSCP             LsStartIndex;           // First Line Services character position
    INT              StartIndex;             // Actual first character position
    INT              LsCharacterCount;       // In Line Services character position
    INT              CharacterCount;         // Actual character count in string positions
    INT              Ascent;
    INT              Descent;
    INT              LineSpacing;
    INT              LineLength;             // In ideal units
    BREAKREC        *BreakRecord;            // Pointer to the break records
    ULONG            BreakRecordCount;       // number of break records produced
    INT              LeftOrTopMargin;        // In ideal units
    INT              RightOrBottomMargin;    // In ideal units
    ULONG            MaxSublineCount;        // Number of sublines
    StringTrimming   Trimming;               // String trimming

    INT              AlignmentOffset;        // Offset from left edge of rectangle to leading edge of line, right positive
    INT              EllipsisPointOffset;    // point offset to line's trailing ellipsis

    INT              LeftOrTopGlyphEdge;     // offset to the near edge of the line

    mutable lsrun   *LastVisibleRun;         // last visible run (updated by display engine)
    mutable INT     *DisplayPlacements;      // logical glyph placement array indexed by imager string offset

    mutable INT      DisplayBaselineAdjust;  // baseline adjustment to snap full pixel in grid-fitted display

    GpStatus         Status;
};


#endif // _BUILTLINE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\cmap.cpp ===
////    CMAP - Truetype CMAP font table loader
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//



#include "precomp.hpp"




///     Interprets Truetype CMAP tables for platform 3 (Windows),
//      encodings 0 (symbol), 1 (unicode) and 10 (UTF-16).
//
//      Supports formats 4 (Segment mapping to delta values)
//      and 12 (Segmented coverage (32 bit)).




////    MapGlyph - Interpret Truetype CMAP type 4 range details
//
//      Implements format 4 of the TrueType cmap table - 'Segment
//      mapping to delta values' described in chapter 2 of the 'TrueType
//      1.0 Font Files Rev. 1.66' document.


__inline UINT16 MapGlyph(
    INT p,                  // Page      (Highbyte of character code)
    INT c,                  // Character (Low byte of unicode code)
    INT s,                  // Segment
    UINT16 *idRangeOffset,
    UINT16 *startCount,
    UINT16 *idDelta,
    BYTE   *glyphTable,
    INT    glyphTableLength
)
{
    UINT16   g;
    UINT16  *pg;
    WORD    wc;

    wc = p<<8 | c;

    if (wc >= 0xffff) {

        // Don't map U+0FFFF as some fonts (Pristina) don't map it
        // correctly and cause an AV in a subsequent lookup.

        return 0;
    }

    BYTE *glyphTableLimit = glyphTable + glyphTableLength;

    if (idRangeOffset[s])
    {
        pg =    idRangeOffset[s]/2
             +  (wc - startCount[s])
             +  &idRangeOffset[s];

        if (   pg < (UINT16*)glyphTable 
            || pg > (UINT16*)glyphTableLimit - 1)
        {
            //TRACEMSG(("Assertion failure: Invalid address generated in CMap table for U+%4x", wc));
            g = 0;
        }
        else
        {
            g = *pg;
        }


        if (g)
        {
            g += idDelta[s];
        }
    }
    else
    {
        g = wc + idDelta[s];
    }

    //TRACE(FONT, ("MapGlyph: idRangeOffset[s]/2 + &idRangeOffset[s]) + (wc-startCount[s] = %x",
    //              idRangeOffset[s]/2 + &idRangeOffset[s] + (wc-startCount[s])));
    //TRACE(FONT, ("........  Segment %d start %x range %x delta %x, wchar %x -> glyph %x",
    //             s, startCount[s], idRangeOffset[s], idDelta[s], wc, g));

    return g;
}


////    ReadCmap4
//
//      Builds a cmap IntMap from a type 4 cmap


struct Cmap4header {
    UINT16  format;
    UINT16  length;
    UINT16  version;
    UINT16  segCountX2;
    UINT16  searchRange;
    UINT16  entrySelector;
    UINT16  rangeShift;
};




static
GpStatus ReadCmap4(
    BYTE           *glyphTable,
    INT             glyphTableLength,
    IntMap<UINT16> *cmap
)
{
    if(glyphTableLength < sizeof(Cmap4header))
    {
        return NotTrueTypeFont;
    }

    GpStatus status = Ok;
    // Flip the entire glyph table - it's all 16 bit words

    FlipWords(glyphTable, glyphTableLength/2);

    // Extract tables pointers and control variables from header

    Cmap4header *header = (Cmap4header*) glyphTable;

    UINT16 segCount = header->segCountX2 / 2;

    UINT16 *endCount      = (UINT16*) (header+1);
    UINT16 *startCount    = endCount      + segCount + 1;
    UINT16 *idDelta       = startCount    + segCount;
    UINT16 *idRangeOffset = idDelta       + segCount;
    UINT16 *glyphIdArray  = idRangeOffset + segCount;

    if(     glyphIdArray < (UINT16*)glyphTable
        ||  glyphIdArray > (UINT16*)(glyphTable + glyphTableLength))
    {
        return NotTrueTypeFont;
    }

    // Loop through the segments mapping glyphs

    INT i,p,c;

    for (i=0; i<segCount; i++)
    {
        INT start = startCount[i];

        // The search algorithm defined in the TrueType font file
        // specification for format 4 says 'You search for the first endcode
        // that is greater than or equal to the character code you want to
        // map'. A side effect of this is that we need to ignore codepoints
        // from the StartCount up to and including the EndCount of the
        // previous segment. Although you might not expect the StartCount of
        // a sgement to be less than the EndCount of the previous segment,
        // it does happen (Arial Unicode MS), presumably to help in the
        // arithmetic of the lookup.

        if (i  &&  start < endCount[i-1])
        {
            start = endCount[i-1] + 1;
        }

        p = HIBYTE(start);     // First page in segment
        c = LOBYTE(start);     // First character in page

        while (p < endCount[i] >> 8)
        {
            while (c<256)
            {
                status = cmap->Insert((p<<8) + c, MapGlyph(p, c, i, idRangeOffset, startCount, idDelta, glyphTable, glyphTableLength));
                if (status != Ok)
                    return status;
                c++;
            }
            c = 0;
            p++;
        }

        // Last page in segment

        while (c <= (endCount[i] & 255))
        {
            status = cmap->Insert((p<<8) + c, MapGlyph(p, c, i, idRangeOffset, startCount, idDelta, glyphTable, glyphTableLength));
            if (status != Ok)
                return status;
            c++;
        }
    }
    return status;
}

static
GpStatus ReadLegacyCmap4(
    BYTE           *glyphTable,
    INT             glyphTableLength,
    IntMap<UINT16> *cmap,
    UINT            codePage
)
{
    if(glyphTableLength < sizeof(Cmap4header))
    {
        return NotTrueTypeFont;
    }

    GpStatus status = Ok;
    // Flip the entire glyph table - it's all 16 bit words

    FlipWords(glyphTable, glyphTableLength/2);

    // Extract tables pointers and control variables from header

    Cmap4header *header = (Cmap4header*) glyphTable;

    UINT16 segCount = header->segCountX2 / 2;

    UINT16 *endCount      = (UINT16*) (header+1);
    UINT16 *startCount    = endCount      + segCount + 1;
    UINT16 *idDelta       = startCount    + segCount;
    UINT16 *idRangeOffset = idDelta       + segCount;
    UINT16 *glyphIdArray  = idRangeOffset + segCount;

    if(     glyphIdArray < (UINT16*)glyphTable
        ||  glyphIdArray > (UINT16*)(glyphTable + glyphTableLength))
    {
        return NotTrueTypeFont;
    }

    // Loop through the segments mapping glyphs

    INT i,p,c;

    for (i=0; i<segCount; i++)
    {
        INT start = startCount[i];

        // The search algorithm defined in the TrueType font file
        // specification for format 4 says 'You search for the first endcode
        // that is greater than or equal to the character code you want to
        // map'. A side effect of this is that we need to ignore codepoints
        // from the StartCount up to and including the EndCount of the
        // previous segment. Although you might not expect the StartCount of
        // a sgement to be less than the EndCount of the previous segment,
        // it does happen (Arial Unicode MS), presumably to help in the
        // arithmetic of the lookup.

        if (i  &&  start < endCount[i-1])
        {
            start = endCount[i-1] + 1;
        }

        p = HIBYTE(start);     // First page in segment
        c = LOBYTE(start);     // First character in page

        while (p < endCount[i] >> 8)
        {
            while (c<256)
            {
                WCHAR wch[2];
                WORD  mb = (WORD) (c<<8) + (WORD) p;
                INT cb = p ? 2 : 1;

                if (MultiByteToWideChar(codePage, 0, &((LPSTR)&mb)[2-cb], cb, &wch[0], 2))
                {
                    status = cmap->Insert(wch[0], MapGlyph(p, c, i, idRangeOffset, startCount, idDelta, glyphTable, glyphTableLength));
                    if (status != Ok)
                        return status;
                }

                c++;
            }
            c = 0;
            p++;
        }

        // Last page in segment

        while (c <= (endCount[i] & 255))
        {
            WCHAR wch[2];
            WORD  mb = (WORD) (c<<8) + (WORD) p;
            INT cb = p ? 2 : 1;

            if (MultiByteToWideChar(codePage, 0, &((LPSTR)&mb)[2-cb], cb, &wch[0], 2))
            {
               status = cmap->Insert(wch[0], MapGlyph(p, c, i, idRangeOffset, startCount, idDelta, glyphTable, glyphTableLength));
               if (status != Ok)
                   return status;
            }
            c++;
        }
    }
    return status;
}







////    ReadCmap12
//
//      Builds a cmap IntMap from a type 12 cmap


struct Cmap12header {
    UINT16  format0;
    UINT16  format1;
    UINT32  length;
    UINT32  language;
    UINT32  groupCount;
};

struct Cmap12group {
    UINT32  startCharCode;
    UINT32  endCharCode;
    UINT32  startGlyphCode;
};


static
GpStatus ReadCmap12(
    BYTE           *glyphTable,
    UINT            glyphTableLength,
    IntMap<UINT16> *cmap
)
{
    if(glyphTableLength < sizeof(Cmap12header))
    {
        return NotTrueTypeFont;
    }

    GpStatus status = Ok;
    UNALIGNED Cmap12header *header = (UNALIGNED Cmap12header*) glyphTable;

    FlipWords(header, 2);
    FlipDWords(&header->length, 3);

    ASSERT(header->format0 == 12);

    if(     header->length > glyphTableLength
        ||  header->groupCount * sizeof(Cmap12group) + sizeof(Cmap12header) > header->length)
    {
        return NotTrueTypeFont;
    }

    UNALIGNED Cmap12group *group = (UNALIGNED Cmap12group*)(header+1);

    FlipDWords(&group->startCharCode, 3*header->groupCount);


    // Iterate through groups filling in cmap table

    UINT  i, j;

    for (i=0; i < header->groupCount; i++) {

        for (j  = group[i].startCharCode;
             j <= group[i].endCharCode;
             j++)
        {
            status = cmap->Insert(j, group[i].startGlyphCode + j - group[i].startCharCode);
            if (status != Ok)
                return status;
        }
    }
    return status;
}


static
GpStatus ReadLegacyCmap12(
    BYTE           *glyphTable,
    UINT            glyphTableLength,
    IntMap<UINT16> *cmap,
    UINT            codePage
)
{
    if(glyphTableLength < sizeof(Cmap12header))
    {
        return NotTrueTypeFont;
    }

    GpStatus status = Ok;
    Cmap12header *header = (Cmap12header*) glyphTable;

    FlipWords(header, 2);
    FlipDWords(&header->length, 3);

    ASSERT(header->format0 == 12);

    if(     header->length > glyphTableLength
        ||  header->groupCount * sizeof(Cmap12group) + sizeof(Cmap12header) > header->length)
    {
        return NotTrueTypeFont;
    }

    UNALIGNED Cmap12group *group = (UNALIGNED Cmap12group*)(header+1);

    FlipDWords(&group->startCharCode, 3*header->groupCount);


    // Iterate through groups filling in cmap table

    UINT  i, j;

    for (i=0; i < header->groupCount; i++) {

        for (j  = group[i].startCharCode;
             j <= group[i].endCharCode;
             j++)
        {
            WCHAR wch[2];
            WORD  mb = (WORD) j;
            INT cb = LOBYTE(mb) ? 2 : 1;

            if (MultiByteToWideChar(codePage, 0, &((LPSTR)&mb)[2-cb], cb, &wch[0], 2))
            {
                status = cmap->Insert(wch[0], group[i].startGlyphCode + j - group[i].startCharCode);
                if (status != Ok)
                    return status;
            }
        }
    }
    return status;
}



#define BE_UINT16(pj)                                \
    (                                                \
        ((USHORT)(((PBYTE)(pj))[0]) << 8) |          \
        (USHORT)(((PBYTE)(pj))[1])                   \
    )

typedef struct _subHeader
{
    UINT16  firstCode;
    UINT16  entryCount;
    INT16   idDelta;
    UINT16  idRangeOffset;
} subHeader;

struct Cmap2header {
    UINT16      format;
    UINT16      length;
    UINT16      language;
    UINT16      subHeaderKeys[256];
    subHeader   firstSubHeader;
};

static
GpStatus ReadCmap2(
    BYTE           *glyphTable,
    UINT            glyphTableLength,
    IntMap<UINT16> *cmap,
    UINT            codePage
)
{
    if(glyphTableLength < sizeof(Cmap2header))
    {
        return NotTrueTypeFont;
    }

    GpStatus status = Ok;
    Cmap2header* header = (Cmap2header*)glyphTable;

    UINT16    *pui16SubHeaderKeys = &header->subHeaderKeys[0];
    subHeader *pSubHeaderArray    = (subHeader *)&header->firstSubHeader;
    BYTE      *glyphTableLimit    = glyphTable + glyphTableLength;

    UINT16     ii , jj;


// Process single-byte char

    for( ii = 0 ; ii < 256 ; ii ++ )
    {
        UINT16 entryCount, firstCode, idDelta, idRangeOffset;
        subHeader *CurrentSubHeader;
        UINT16 *pui16GlyphArray;
        UINT16 hGlyph;

        jj = BE_UINT16( &pui16SubHeaderKeys[ii] );

        if( jj != 0 ) continue;

        CurrentSubHeader = pSubHeaderArray;

        firstCode     = BE_UINT16(&(CurrentSubHeader->firstCode));
        entryCount    = BE_UINT16(&(CurrentSubHeader->entryCount));
        idDelta       = BE_UINT16(&(CurrentSubHeader->idDelta));
        idRangeOffset = BE_UINT16(&(CurrentSubHeader->idRangeOffset));

        pui16GlyphArray = (UINT16 *)((PBYTE)&(CurrentSubHeader->idRangeOffset) +
                                     idRangeOffset);

        if(     &pui16GlyphArray[ii-firstCode] < (UINT16*)glyphTable
            ||  &pui16GlyphArray[ii-firstCode] > (UINT16*)glyphTableLimit - 1)
        {
            hGlyph = 0;
        }
        else
        {
            hGlyph = (UINT16)BE_UINT16(&pui16GlyphArray[ii-firstCode]);
        }

        if( hGlyph == 0 ) continue;

        status = cmap->Insert(ii, hGlyph);
        if (status != Ok)
            return status;
    }

    // Process double-byte char

    for( ii = 0 ; ii < 256 ; ii ++ )
    {
        UINT16 entryCount, firstCode, idDelta, idRangeOffset;
        subHeader *CurrentSubHeader;
        UINT16 *pui16GlyphArray;

        jj = BE_UINT16( &pui16SubHeaderKeys[ii] );

        if( jj == 0 ) continue;

        CurrentSubHeader = (subHeader *)((PBYTE)pSubHeaderArray + jj);
        if(CurrentSubHeader > (subHeader*)glyphTableLimit - 1)
        {
            return NotTrueTypeFont;
        }

        firstCode     = BE_UINT16(&(CurrentSubHeader->firstCode));
        entryCount    = BE_UINT16(&(CurrentSubHeader->entryCount));
        idDelta       = BE_UINT16(&(CurrentSubHeader->idDelta));
        idRangeOffset = BE_UINT16(&(CurrentSubHeader->idRangeOffset));

        pui16GlyphArray = (UINT16 *)((PBYTE)&(CurrentSubHeader->idRangeOffset) +
                                     idRangeOffset);


        for( jj = firstCode ; jj < firstCode + entryCount ; jj++ )
        {
            UINT16 hGlyph;

            if(     &pui16GlyphArray[ii-firstCode] < (UINT16*)glyphTable
                ||  &pui16GlyphArray[ii-firstCode] > (UINT16*)glyphTableLimit - 1)
            {
                hGlyph = 0;
            }
            else
            {
                hGlyph = (UINT16)(BE_UINT16(&pui16GlyphArray[jj-firstCode]));
            }

            if( hGlyph == 0 ) continue;

            WCHAR wch[2];
            WORD  mb = (WORD) (jj<<8) + (WORD) ii;

            if (MultiByteToWideChar(codePage, 0, (LPSTR) &mb, 2, &wch[0], 2))
            {
                status = cmap->Insert(wch[0], hGlyph + idDelta);
                if (status != Ok)
                    return status;
            }
        }
    }
    return status;
}


////    ReadCmap
//
//      Scans the font cmap table page by page filling in all except missing
//      glyphs in the cmap table.


struct cmapHeader {
    UINT16 version;
    UINT16 encodingCount;
};

struct subtableEntry {
    UINT16 platform;
    UINT16 encoding;
    UINT32 offset;
};


GpStatus ReadCmap(
    BYTE           *cmapTable,
    INT             cmapLength,
    IntMap<UINT16> *cmap,
    BOOL *          bSymbol
)
{
    if(cmapLength < sizeof(cmapHeader))
    {
        return NotTrueTypeFont;
    }

    GpStatus status = Ok;
    // Scan the cmap tables looking for symbol, Unicode or UCS-4 encodings

    BYTE  *glyphTable = NULL;

    // Glyph table types in priority - always choose a higher type over a
    // lower one.

    enum {
        unknown  = 0,
        symbol   = 1,    // up to 2^8  characters ay U+F000
        shiftjis = 2,    // up to 2^16 characters
        gb       = 3,    // up to 2^16 characters
        big5     = 4,    // up to 2^16 characters
        wansung  = 5,    // up to 2^16 characters
        unicode  = 6,    // up to 2^16 characters
        ucs4     = 7     // up to 2^32 characters
    } glyphTableType = unknown;

    cmapHeader *header = (cmapHeader*) cmapTable;
    subtableEntry *subtable = (subtableEntry *) (header+1);

    FlipWords(&header->version, 2);

    if( cmapLength
        <       (INT)(sizeof(cmapHeader)
            +   header->encodingCount * sizeof(subtableEntry)))
    {
        return NotTrueTypeFont;
    }

    UINT acp = GetACP();

    for (INT i=0; i<header->encodingCount; i++)
    {
        FlipWords(&subtable->platform, 2);
        FlipDWords(&subtable->offset, 1);

        // TRACE(FONT, ("Platform %d, Encoding %d, Offset %ld", subtable->platform, subtable->encoding, subtable->offset);

        if (    subtable->platform == 3
            &&  subtable->encoding == 0
            &&  glyphTableType < symbol)
        {
            glyphTableType = symbol;
            glyphTable = cmapTable + subtable->offset;
            *bSymbol = TRUE;
        }
        else if (    subtable->platform == 3
                 &&  subtable->encoding == 1
                 &&  glyphTableType < unicode)
        {
            glyphTableType = unicode;
            glyphTable = cmapTable + subtable->offset;
            *bSymbol = FALSE;
        }
        else if (    subtable->platform == 3
                 &&  subtable->encoding == 2
                 &&  glyphTableType < shiftjis)
        {
            if (Globals::IsNt || acp == 932)
            {
                glyphTableType = shiftjis;
                glyphTable = cmapTable + subtable->offset;
                acp = 932;
                *bSymbol = FALSE;
            }
        }
        else if (    subtable->platform == 3
                 &&  subtable->encoding == 3
                 &&  glyphTableType < gb)
        {
            if (Globals::IsNt || acp == 936)
            {
                glyphTableType = gb;
                glyphTable = cmapTable + subtable->offset;
                acp = 936;
                *bSymbol = FALSE;
            }
        }
        else if (    subtable->platform == 3
                 &&  subtable->encoding == 4
                 &&  glyphTableType < big5)
        {
            if (Globals::IsNt || acp == 950)
            {
                glyphTableType = big5;
                glyphTable = cmapTable + subtable->offset;
                acp = 950;
                *bSymbol = FALSE;
            }
        }
        else if (    subtable->platform == 3
                 &&  subtable->encoding == 5
                 &&  glyphTableType < wansung)
        {
            if (Globals::IsNt || acp == 949)
            {
                glyphTableType = wansung;
                glyphTable = cmapTable + subtable->offset;
                acp = 949;
                *bSymbol = FALSE;
            }
        }
        else if (    subtable->platform == 3
                 &&  subtable->encoding == 10
                 &&  glyphTableType < ucs4)
        {
            glyphTableType = ucs4;
            glyphTable = cmapTable + subtable->offset;
            *bSymbol = FALSE;
        }

        subtable++;
    }


    #if DBG
        // const char* sTableType[4] = {"unknown", "symbol", "Unicode", "UCS-4"};
        //TRACE(FONT, ("Using %s character to glyph index mapping table", sTableType[glyphTableType]));
    #endif

    // Process format 4 or 12 tables.

    if(     !glyphTable
        ||  glyphTable < cmapTable
        ||  glyphTable > cmapTable + cmapLength)
    {
        return NotTrueTypeFont;
    }

    INT glyphTableLength;

    switch(glyphTableType)
    {
        case unknown:
            break;
        case symbol:
        case unicode:
        case ucs4:

            glyphTableLength = cmapLength - (INT)(glyphTable - cmapTable);

            if (*(UINT16*)glyphTable == 0x400)
                status = ReadCmap4(glyphTable, glyphTableLength, cmap);
            else if (*(UINT16*)glyphTable == 0xC00)
                status = ReadCmap12(glyphTable, glyphTableLength, cmap);
            break;
        case shiftjis:
        case gb:
        case big5:
        case wansung:
            glyphTableLength = cmapLength - (INT)(glyphTable - cmapTable);

            UINT16 testIt = *(UINT16*) glyphTable;

            if (testIt == 0x400)
                status = ReadLegacyCmap4(glyphTable, glyphTableLength, cmap, acp);
            else if (testIt == 0xC00)
                status = ReadLegacyCmap12(glyphTable, glyphTableLength, cmap, acp);
            else if (testIt == 0x200)
                status = ReadCmap2(glyphTable, glyphTableLength, cmap, acp);
            break;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\fasttext.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   FastTextImager.cpp
*
* Abstract:
*
*   Text measurement and display for the common case
*
*
* Created:
*
*   23 Oct 2000
*
\**************************************************************************/



#include "precomp.hpp"


/////   CountLength
//
//      Determine the length of a string by searching for the zero terminator.


static void CountLength(
    const WCHAR *string,
    INT          *length
)
{
    INT i = 0;
    while (string[i])
    {
        i++;
    }
    *length = i;
}



/////   ScanForGlyph
//
//

static inline INT ScanForGlyph(
    const UINT16  *glyphs,
    INT            glyphCount,
    UINT16         glyph
)
{
    INT i=0;
    while (i < glyphCount && glyphs[i] != glyph)
    {
        i++;
    }
    return i;
}



static INT SumWidths(
    const UINT16 *widths,
    INT           widthCount
)
{
    INT sum = 0;
    INT i   = 0;
    while (i < widthCount)
    {
        sum += widths[i];
        i++;
    }
    return sum;
}



//  Note: Only handle one hotkey which is a common case
//  for menu item. If we found more than one, we'll let
//  fulltext handle it.

GpStatus FastTextImager::RemoveHotkeys()
{
    // Remove hotkey codepoints by moving subsequent glyph indeces back down
    // and decrementing GlyphCount.
    // '&' is the hardcoded hotkey marker.

    INT i = 0;

    // Find the first '&'. Maybe there are none.

    while (    i < Length
           &&  String[i] != '&')
    {
        i++;
    }

    if (i >= Length)
    {
        // No hotkeys to handle.
        return Ok;
    }
    else if (i == Length-1)
    {
        // Last character is hotkey marker. Just ignore it.
        GlyphCount--;
    }
    else
    {
        // Hide the glyph by moving subsequent glyphs back over this one.

        if (String[i+1] != '&')
            HotkeyPosition = i;

        INT j=i+1;

        while (j < GlyphCount)
        {
            // Copy marked glyph down one (even if it is another '&').

            Glyphs[i] = Glyphs[j];
            i++;
            j++;

            // Copy subsequent glyphs down until the end, or the next hotkey marker

            while (j < GlyphCount
                   &&  String[j] != '&')
            {
                Glyphs[i] = Glyphs[j];
                i++;
                j++;
            }

            if (j < GlyphCount)
            {
                // We hit another hotkey marker,
                // wont handle it.
                return NotImplemented;
            }
        }

        GlyphCount = i;
    }
    return Ok;
}







/////   FastAdjustGlyphPositionsProportional
//
//      Since this is the fast case, there are many things it is not designed
//      to handle.
//
//      It does handle:
//
//      o  Generate glyph advance width array in device coordinates
//      o  No adjustment of leading or trailing spaces
//      o  Even spacing
//      o  Major adjustment in inter-word space, remaining adjustment
//            in inter-character space
//
//
//      There's 3 types of glyph:
//
//      o  Blanks.  We want all blanks to have the same width, and impose a
//         minimum blank width to ensure words remain distinct.
//
//      o  Last character of a word. We can't adjust the hinted width of the
//         last character of a word because it sets the point at which the
//         subsequent blank (or right margin) begins.
//
//      o  First characters of each word. Adjusting the width of the other
//         changes the inter-glyph spacing. We only do this if we cannot
//         make all our changes in the blank width.


void FastTextImager::FastAdjustGlyphPositionsProportional(
    IN   const INT       *hintedWidth,            // 28.4  device
    OUT  INT             *x,                      // 28.4  device Initial x
    OUT  IntStackBuffer  &dx,                     // 32.0  device Glyph advances
    OUT  const UINT16   **displayGlyphs,          // First displayable glyph
    OUT  INT             *displayGlyphCount,
    OUT  INT             *leadingBlankCount
)
{
    INT desiredOffset     = 0;   // 16.16 offset from left end
    INT wholePixelOffset  = 0;   // 16.16 fractional part zero


    // Identify leading and trailing blanks

    INT leadingBlanks = 0;
    while (leadingBlanks < GlyphCount && Glyphs[leadingBlanks] == BlankGlyph)
    {
        leadingBlanks++;
    }

    INT trailingBlanks = 0;
    while (leadingBlanks + trailingBlanks < GlyphCount &&
        Glyphs[GlyphCount-1-trailingBlanks] == BlankGlyph)
    {
        trailingBlanks++;
    }


    // Measure nominal and hinted widths, and count internal blanks

    INT internalBlanks = 0;
    INT totalNominal   = 0;    // 32.0 design
    INT totalHinted    = 0;    // 28.4 device
    INT blanksHinted   = 0;    // 28.4 device
    INT blanksNominal  = 0;    // 32.0 design

    INT i = leadingBlanks;
    while (i < GlyphCount-trailingBlanks)
    {
        if (Glyphs[i] == BlankGlyph)
        {
            internalBlanks++;
            blanksHinted  += hintedWidth[i];
            blanksNominal += NominalWidths[i];
        }
        else
        {
            totalNominal += NominalWidths[i];

            // Note: totalHinted is 28.4, so the overall device length of the text
            // cannot exceed 2**28 (over 250,000,000). Glyph adjustment code should
            // not be used in such large scale cases - it is intended for smaller
            // font sizes and lower resolutions, rarely exceeding 8 inches at 200
            // dpi (i.e. 16000). The available resolution is therefore larger than
            // the common worst case by a factor of 15,000.

            ASSERT(totalHinted + hintedWidth[i] >= totalHinted);    // Check overflow
            totalHinted  += hintedWidth[i];
        }

        i++;
    }

    totalHinted  += blanksHinted;
    totalNominal += blanksNominal;


    // From here on work with just the displayable gylphs.
    // 'displayGlyphs' is just a pointer to teh first nonblank glyph.

    *leadingBlankCount = leadingBlanks;
    *displayGlyphs     = Glyphs.Get() + leadingBlanks;
    *displayGlyphCount = GlyphCount - leadingBlanks - trailingBlanks;
    *x = (NominalWidths[0] * NominalToBaselineScale * leadingBlanks) / 4096;


    // Determine the damage - how much adjustment is required in 32.0 device units.

    INT adjustment = INT((((INT64(totalNominal) * NominalToBaselineScale)/4096) - totalHinted + 8) / 16);


    // Allow for small differences between hinted and nominal widths
    // without adjusting inter-glyph spacing.

    INT nonJustifiedAdjustment = 0;     // 32.0 device

    if (adjustment < 0)
    {
        // Allow overflow into margins
        // [e.g. 316851]

        nonJustifiedAdjustment = max(adjustment, -OverflowAvailable);
    }
    else if (adjustment > 0)
    {
        nonJustifiedAdjustment = static_cast<INT>(min(adjustment, (NominalToBaselineScale*(INT64)DesignEmHeight) >> 16));
    }


    if (nonJustifiedAdjustment)
    {
        // Maintain visual alignment

        switch (Alignment)
        {
        case StringAlignmentCenter:
            LeftOffset += nonJustifiedAdjustment  / (WorldToDeviceX * 2);
            break;

        case StringAlignmentFar:
            LeftOffset += nonJustifiedAdjustment  / (WorldToDeviceX);
            break;
        }
    }


    // Determine remaining inter-glyph adjustment

    adjustment -= nonJustifiedAdjustment;


    if (    adjustment == 0
        ||  *displayGlyphCount <= 1)
    {
        // WARNING(("No glyph adjustment required"));

        // Can use hinted widths directly

        INT deviceOffset28p4 = 0;
        INT deviceOffset32p0 = 0;

        for (INT i=0; i<*displayGlyphCount; i++)
        {
            deviceOffset28p4  += hintedWidth[i+leadingBlanks];
            INT nextOffset32p0 = (deviceOffset28p4 + 8) >> 4;
            dx[i]              = nextOffset32p0 - deviceOffset32p0;
            deviceOffset32p0   = nextOffset32p0;
        }
    }
    else
    {
        // Determine how much whitespace is required according to design metrics

        INT deviceWhitespace = INT((blanksNominal * INT64(NominalToBaselineScale) + 32768) / 65536);

        // Guarantee not to reduce whitespace to less than 1/6 em (rounded up to whole pixels)
        INT minimumBlankPixels = (NominalToBaselineScale*DesignEmHeight + 5*65536) / (6*65536);
        INT minimumDeviceWhitespace = MAX(internalBlanks*minimumBlankPixels,
                                          deviceWhitespace/2);

        // We would rather not change inter-character spacing.
        // Adjust only blank widths if blanks would not be reduced below
        // minimumBlankPixels or increased above twice their nominal width.


        if (    adjustment     <=  deviceWhitespace
            &&  adjustment     >=  -(deviceWhitespace-minimumDeviceWhitespace)
            &&  internalBlanks > 0)
        {
            // WARNING(("Glyph adjustment in spaces only"));

            // Adjustment expands spaces to no more than twice their nominal
            // size and no less than half their nominal size.

            // Apply all adjustment to spaces. Determine ajusted 24.8 blank
            // width.

            INT deviceOffset24p8 = 0;
            INT deviceOffset32p0 = 0;

            const UINT16 *glyphs     = *displayGlyphs;
            INT           glyphCount = *displayGlyphCount;
            INT           blankWidth = (blanksHinted*16 + adjustment*256) / internalBlanks;
            const INT    *hinted     = hintedWidth+leadingBlanks;

            for (INT i=0; i<glyphCount; i++)
            {
                if (glyphs[i] == BlankGlyph)
                {
                    deviceOffset24p8 += blankWidth;
                }
                else
                {
                    deviceOffset24p8 += hinted[i] * 16;
                }
                INT nextOffset32p0 = (deviceOffset24p8 + 128) >> 8;
                dx[i]              = nextOffset32p0 - deviceOffset32p0;
                deviceOffset32p0   = nextOffset32p0;
            }
        }
        else
        {
            // WARNING(("Glyph adjustment in spaces and between Glyphs"));

            // Adjustment requires changes to the width of all but the last
            // glyph of each word.

            INT interCharacterAdjustment = adjustment; // 32.0

            INT blankWidth; // 32.0
            if (internalBlanks)
            {
                if (adjustment < 0)
                {
                    blankWidth = minimumBlankPixels;
                }
                else
                {
                    blankWidth = deviceWhitespace * 2 / internalBlanks;
                }
                interCharacterAdjustment -= blankWidth * internalBlanks - blanksHinted/16;
            }
            else
            {
                blankWidth = 0;
            }

            // blankWidth - Required width for each blank
            // interCharacterAdjustment - adjustment to share between all

            // Count number of blank runs (not the same as number of blank glyphs)

            INT i=0;
            INT blankRuns = 0;

            while (i < *displayGlyphCount)
            {
                if ((*displayGlyphs)[i] == BlankGlyph)
                {
                    i++;
                    while (    i < *displayGlyphCount
                           &&  (*displayGlyphs)[i] == BlankGlyph)
                    {
                        i++;
                    }
                    blankRuns++;
                }
                else
                {
                    while (    i < *displayGlyphCount
                           &&  (*displayGlyphs)[i] != BlankGlyph)
                    {
                        i++;
                    }
                }
            }

            // Establish number of adjustment points between non-blanks.
            //
            // Adjustment can happen only between non-blanks, i.e. not in blank
            // runs, nor in the character immediateley before a blank run or
            // the last character in the line.

            INT interCharacterJunctions =    *displayGlyphCount
                                          -  internalBlanks
                                          -  blankRuns
                                          -  1;


            // Prepare adjustment control variables

            #ifdef evenDistribution
                // Even distribution makes wordslook uneven
                INT OnePixelChangeEvery; // 16.16
                INT delta; // -1 or +1

                if (interCharacterAdjustment == 0)
                {
                    OnePixelChangeEvery = (interCharacterJunctions+1) * 65536; // 16.16
                    delta=0;
                }
                else
                {
                    OnePixelChangeEvery =    interCharacterJunctions * 65536
                                          /  interCharacterAdjustment; // 16.16
                    if (OnePixelChangeEvery < 0)
                    {
                        OnePixelChangeEvery = - OnePixelChangeEvery;
                        delta = -1;
                    }
                    else
                    {
                        delta = 1;
                    }
                }
                INT gapOffset = OnePixelChangeEvery / 2; // 16.16
            #else
                // When there's a remainder, apply it all at the end of the line
                // Advantage - all words are even. Disadvantage - end of line looks heavy.

                INT extraPixelsAfter;  // Position after which to start applying extraDelta
                INT extraDelta;
                INT perJunctionDelta;

                if (interCharacterJunctions <= 0)
                {
                    // There are no words of more than one character

                    // We have no chice except to make all adjustment happen in the blanks

                    if (internalBlanks <= 0)
                    {
                        // No blanks, no inter-character junctions
                        // This must be a single glyph
                        // So we're stuck. It will have to be too wide.
                    }
                    else
                    {
                        // Distribute remaining adjustment between blanks

                        blankWidth += interCharacterAdjustment / internalBlanks;
                    }

                    extraPixelsAfter = 0;
                    extraDelta = 0;
                    perJunctionDelta = 0;
                }
                else
                {
                    perJunctionDelta = interCharacterAdjustment / interCharacterJunctions;
                    if (interCharacterAdjustment < 0)
                    {
                        extraPixelsAfter =    interCharacterJunctions
                                           +  interCharacterAdjustment % interCharacterJunctions;
                        extraDelta  = -1;
                    }
                    else if (interCharacterAdjustment > 0)
                    {
                        extraPixelsAfter =    interCharacterJunctions
                                           -  interCharacterAdjustment % interCharacterJunctions;
                        extraDelta = 1;
                    }
                    else
                    {
                        extraPixelsAfter = interCharacterJunctions;
                        extraDelta = 0;
                    }
                }

                INT junctionCount = 0;
            #endif


            // Adjustment FSM

            BOOL prevCharacterBlank = (*displayGlyphs)[0] == BlankGlyph ? TRUE : FALSE;
            for (INT i=1; i<= *displayGlyphCount; i++)
            {
                if (prevCharacterBlank)
                {
                    // Previous character was blank - easy!

                    dx[i-1] = blankWidth;
                }
                else
                {
                    // Previous character nonblank

                    if (    i >= *displayGlyphCount
                        ||  (*displayGlyphs)[i] == BlankGlyph)
                    {
                        // the previous nonblank preceeded a blank or margin
                        dx[i-1] = hintedWidth[i-1+leadingBlanks] / 16;
                    }
                    else
                    {
                        // the previous nonblank is adjustable
                        // How many extra pixels to add at this gap?

                        #ifdef evenDistribution
                            // Even distribution makes words look uneven
                            INT extra = gapOffset / OnePixelChangeEvery;

                            dx[i-1] = hintedWidth[i-1+leadingBlanks] / 16 + extra * delta;
                            gapOffset += 65536 - extra * OnePixelChangeEvery;
                        #else
                            // When there's a remainder, apply it all at the end of the line
                            // Advantage - all words are even. Disadvantage - end of line looks heavy.
                            dx[i-1] =    hintedWidth[i-1+leadingBlanks] / 16
                                      +  perJunctionDelta
                                      +  (junctionCount >= extraPixelsAfter ? extraDelta : 0);
                            junctionCount++;

                        #endif
                    }
                }

                if (i < *displayGlyphCount)
                {
                    prevCharacterBlank = (*displayGlyphs)[i] == BlankGlyph ? TRUE : FALSE;
                }
            }
        }
    }
}





void
FastTextImager::GetWorldTextRectangleOrigin(
    PointF &origin
)
{
    origin.X = LayoutRectangle.X;
    origin.Y = LayoutRectangle.Y;

    REAL textWidth = TotalWorldAdvance + LeftMargin + RightMargin;

    switch(Alignment)
    {
    case StringAlignmentCenter:
        origin.X += (LayoutRectangle.Width - textWidth) / 2;
        break;

    case StringAlignmentFar:
        origin.X += LayoutRectangle.Width - textWidth;
        break;
    }

    if (Format)
    {
        StringAlignment lineAlignment = Format->GetLineAlign();

        switch(lineAlignment)
        {
        case StringAlignmentCenter:
            origin.Y += (LayoutRectangle.Height - CellHeight) / 2;
            break;
        case StringAlignmentFar:
            origin.Y += LayoutRectangle.Height - CellHeight;
            break;
        }
    }
}






void
FastTextImager::GetDeviceBaselineOrigin(
    IN   GpFaceRealization  &faceRealization,
    OUT  PointF             &origin
)
{
    GetWorldTextRectangleOrigin(origin);

    origin.X += LeftMargin + LeftOffset;

    ASSERT(!faceRealization.IsPathFont());

    if (WorldToDeviceY > 0.0f)
    {
        origin.Y -= faceRealization.GetYMin() / WorldToDeviceY;
    }
    else
    {
        origin.Y -= faceRealization.GetYMax() / WorldToDeviceY;
    }
    WorldToDevice.Transform(&origin, 1);
}






GpStatus
FastTextImager::FastDrawGlyphsNominal(
    GpFaceRealization  &faceRealization
)
{
    AutoBuffer<PointF, FAST_TEXT_PREALLOCATED_CHARACTERS> origins(GlyphCount);

    GetDeviceBaselineOrigin(faceRealization, origins[0]);

    for (INT i=1; i<GlyphCount; i++)
    {
        origins[i].X = origins[i-1].X + TOREAL(NominalWidths[i-1] * NominalToBaselineScale) / 65536;
        origins[i].Y = origins[0].Y;
    }

    GpStatus status = Graphics->DrawPlacedGlyphs(
        &faceRealization,
        Brush,
        FormatFlags &  StringFormatFlagsPrivateNoGDI ? DG_NOGDI : 0,
        String,
        Length,
        FALSE,
        Glyphs.Get(),
        NULL,
        origins.Get(),
        GlyphCount,
        ScriptLatin,
        FALSE   // sideways
    );

    if (status != Ok)
    {
        return status;
    }


    if (Style & (FontStyleUnderline | FontStyleStrikeout))
    {
        REAL lineLength = 0.0;

        for (INT i = 0; i < GlyphCount; i++)
        {
            lineLength += TOREAL(NominalWidths[i] * NominalToBaselineScale) / 65536;
        }

        status = DrawFontStyleLine(
            &origins[0],
            lineLength,
            Style
        );
        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    if (   !(Style & FontStyleUnderline)
        && HotkeyPosition >= 0  && Format && Format->GetHotkeyPrefix() == HotkeyPrefixShow)
    {
        // Draw the underline under the marked key

        status = DrawFontStyleLine(
            &origins[HotkeyPosition],
            TOREAL(NominalWidths[HotkeyPosition] * NominalToBaselineScale) / 65536,
            FontStyleUnderline
        );
        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    return Ok;
}



GpStatus
FastTextImager::DrawFontStyleLine(
    const PointF    *baselineOrigin,    // base line origin in device unit
    REAL            baselineLength,     // base line length in device unit
    INT             style               // font styles
)
{
    //  Invert transform to world unit

    PointF  starting(*baselineOrigin);
    PointF  ending(baselineOrigin->X + baselineLength, baselineOrigin->Y);

    GpMatrix deviceToWorld;
    Graphics->GetDeviceToWorldTransform(&deviceToWorld);
    deviceToWorld.Transform(&starting);
    deviceToWorld.Transform(&ending);

    // fasttext wont process vertical or text w/ any transform except scaling
    ASSERT(starting.Y == ending.Y);

    return Graphics->DrawFontStyleLine(
        &starting,
        ending.X - starting.X,
        Face,
        Brush,
        FALSE,  // no vertical
        EmSize,
        style
    );
}




GpStatus
FastTextImager::FastDrawGlyphsGridFit(
    GpFaceRealization  &faceRealization
)
{
    // Get hinted advance widths for the glyph string

    IntStackBuffer hintedWidths(GlyphCount);

    GpStatus status = faceRealization.GetGlyphStringDeviceAdvanceVector(
        Glyphs.Get(),
        GlyphCount,
        FALSE,
        hintedWidths.Get()
    );

    if (status != Ok)
    {
        return status;
    }


    INT              x;                    // 28.4 offset for first display glyph
    const UINT16    *displayGlyphs;        // First glyph to display
    INT              displayGlyphCount;    // Number of Glyphs to display
    INT              leadingBlankCount;    // Number of leading blank glyphs
    IntStackBuffer   dx(GlyphCount);       // 32.0

    if (!dx)
    {
        return OutOfMemory;
    }

    FastAdjustGlyphPositionsProportional(
        hintedWidths.Get(),     // 28.4  device
       &x,                      // 28.4  device Initial x
        dx,                     // 32.0  device Glyph advances
       &displayGlyphs,          // First displayable glyph
       &displayGlyphCount,
       &leadingBlankCount
    );

    AutoBuffer<PointF, FAST_TEXT_PREALLOCATED_CHARACTERS> origins(GlyphCount);

    GetDeviceBaselineOrigin(faceRealization, origins[0]);

    //  Round glyph origin to full pixel
    origins[0].X = TOREAL(GpRound(origins[0].X));
    origins[0].X += TOREAL(x) / 16;

    for (INT i=1; i<displayGlyphCount; i++)
    {
        origins[i].X = origins[i-1].X + TOREAL(dx[i-1]);
        origins[i].Y = origins[0].Y;
    }

    status = Graphics->DrawPlacedGlyphs(
        &faceRealization,
        Brush,
        FormatFlags &  StringFormatFlagsPrivateNoGDI ? DG_NOGDI : 0,
        String,
        Length,
        FALSE,
        displayGlyphs,
        NULL,
        origins.Get(),
        displayGlyphCount,
        ScriptLatin,
        FALSE  // sideways
    );
    IF_NOT_OK_WARN_AND_RETURN(status);

    if (Style & (FontStyleUnderline | FontStyleStrikeout))
    {
        REAL lineLength = 0.0;

        for (INT i = 0; i < displayGlyphCount; i++)
        {
            lineLength += TOREAL(dx[i]);
        }

        status = DrawFontStyleLine(
            &origins[0],
            lineLength,
            Style
        );
        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    if (   !(Style & FontStyleUnderline)
        && HotkeyPosition - leadingBlankCount >= 0
        && HotkeyPosition - leadingBlankCount < displayGlyphCount
        && Format && Format->GetHotkeyPrefix() == HotkeyPrefixShow)
    {
        // Draw the underline under the marked key

        status = DrawFontStyleLine(
            &origins[HotkeyPosition - leadingBlankCount],
            TOREAL(dx[HotkeyPosition - leadingBlankCount]),
            FontStyleUnderline
        );
        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    return Ok;
}





/////   Initialize
//
//      Prepares everything common to DrawString and MeasureString.
//
//      Returns NotImplemented if this string cannot be handled by the fast imager.


GpStatus FastTextImager::Initialize(
    GpGraphics            *graphics,
    const WCHAR           *string,
    INT                    length,
    const RectF           &layoutRectangle,
    const GpFontFamily    *family,
    INT                    style,
    REAL                   emSize,  // In world units
    const GpStringFormat  *format,
    const GpBrush         *brush
)
{
    // Initialise parameter variables

    Graphics        = graphics;
    String          = string;
    Length          = length;
    LayoutRectangle = layoutRectangle;
    Family          = family;
    Style           = style;
    EmSize          = emSize;
    Format          = format;
    Brush           = brush;


    // Simple parameter validation

    // Extract world to device metrics coefficients.

    Graphics->GetWorldToDeviceTransform(&WorldToDevice);
    REAL m11 = WorldToDevice.GetM11();
    REAL m12 = WorldToDevice.GetM12();
    REAL m21 = WorldToDevice.GetM21();
    REAL m22 = WorldToDevice.GetM22();

    if (    m11 <= 0
        ||  m12 != 0
        ||  m21 != 0
        ||  m22 == 0)
    {
        // Must be no rotation, no shearing, and neither axis may
        // scale to zero. X axis scale must be positive, but
        // we do support differing x and y scale.
        return NotImplemented;
    }

    if (EmSize <= 0.0)
    {
        return InvalidParameter;
    }

    if (Graphics->Driver == Globals::MetaDriver)
        return NotImplemented;

    // Measure string if requested

    if (Length == -1)
    {
        CountLength(String, &Length);
    }


    if (Length == 0)
    {
        return Ok;  // Nothing to do.
    }


    // Generate derived variables

    // Establish left and right margins in world units, alignment and flags

    REAL tracking;  // Used only during initialisation

    StringTrimming trimming = DefaultTrimming;

    if (Format)
    {
        LeftMargin  = Format->GetLeadingMargin()  * EmSize;
        RightMargin = Format->GetTrailingMargin() * EmSize;
        Alignment   = Format->GetAlign();
        FormatFlags = Format->GetFormatFlags();
        tracking    = Format->GetTracking();

        // Certain flags are simply not supported by the fast text imager
        if ((FormatFlags & ( StringFormatFlagsDirectionRightToLeft
                          | StringFormatFlagsDirectionVertical
                          | StringFormatFlagsPrivateAlwaysUseFullImager))
            || Format->GetMeasurableCharacterRanges() > 0)
        {
            return NotImplemented;
        }

        Format->GetTrimming(&trimming);
    }
    else
    {
        LeftMargin  = DefaultMargin * EmSize;
        RightMargin = DefaultMargin * EmSize;
        Alignment   = StringAlignmentNear;
        FormatFlags = 0;
        tracking    = DefaultTracking;
    }


    // Determine line length limit. Note lineLengthLimit <= 0 implies
    // unlimited.

    LineLengthLimit = 0;   // Unlimited

    if (   !(FormatFlags & StringFormatFlagsNoWrap)
        || trimming != StringTrimmingNone)
    {
        if (FormatFlags & StringFormatFlagsDirectionVertical)
        {
            LineLengthLimit = LayoutRectangle.Height;
        }
        else
        {
            LineLengthLimit = LayoutRectangle.Width;
        }
    }


    // Establish font face that will be used (assuming no font fallback)

    Face = Family->GetFace(Style);

    if (!Face)
    {
        return InvalidParameter;
    }

    // Fonts with kerning, ligatures or opentype tables for simple horizontal
    // characters are not supported by the fast text imager

    if (Face->RequiresFullTextImager())
    {
        return NotImplemented;
    }



    // At this point we know that the font doesn't require us to distinguish
    // simple left to right scripts like Latin, greek or Ideographic.

    // Attempt to classify the string as a single simple item

    BOOL  digitSeen = FALSE;
    BOOL  complex   = FALSE;

    DetermineStringComplexity(String, Length, &complex, &digitSeen);


    if (    complex
        ||  (digitSeen && Format && Format->GetDigitScript()))
    {
        // Cannot handle this string as a single simple shaping engine run
        return NotImplemented;
    }

    BlankGlyph = Face->GetBlankGlyph();

    // Establish world to device and font to device scale factors along X axis

    DesignEmHeight           = Face->GetDesignEmHeight();
    WorldToDeviceX           = m11;  // We know m12 == 0 above.
    WorldToDeviceY           = m22;  // We know m12 == 0 above.
    REAL fontNominalToWorld  = TOREAL(EmSize) / TOREAL(DesignEmHeight);
    REAL fontScale           = fontNominalToWorld * WorldToDeviceX;

    FontTransform.SetMatrix(
        m11*fontNominalToWorld,  0,
        0,                       m22*fontNominalToWorld,
        0,                       0
    );

    CellHeight =    EmSize
                 *  (   Face->GetDesignCellAscent()
                     +  Face->GetDesignCellDescent())
                 /  DesignEmHeight;


    // Adjust the bottom margin slightly to make room for hinting
    // as long as we have the left/right margins enabled - Version 2
    // should expose this as an independent value!
    if (LeftMargin != 0.0f)
    {
        CellHeight += (EmSize * DefaultBottomMargin);
    }

    NominalToBaselineScale = GpRound(fontScale * 65536);

    if (NominalToBaselineScale > 65536)
    {
        // Our integer arithmetic might overflow. This limits our support
        // to font sizes less than the design em size. For Truetype this
        // is usually 2048 pixels, for example 186 pt Tahoma at 96dpi.

        return NotImplemented;
    }



    // Set space available for hinted width to expand into

    switch (Alignment)
    {
    case StringAlignmentNear:   OverflowAvailable = GpFloor(RightMargin * WorldToDeviceX);  break;
    case StringAlignmentCenter: OverflowAvailable = GpFloor(2 * min(LeftMargin, RightMargin) * WorldToDeviceX);  break;
    case StringAlignmentFar:    OverflowAvailable = GpFloor(LeftMargin * WorldToDeviceX);  break;
    }

    LeftOffset = 0.0f;


    TextRendering = Graphics->GetTextRenderingHintInternal();

    // At this point we know that the string can be displayed by a single
    // shaping engine without ligaturisation, kerning or complex script
    // shaping.

    // It may still turn out to have missing glyphs, or be too large
    // to fit on one line.

    HotkeyPosition = -1;

    //  Prepare the glyph and nominal width buffers, return NotImplemented if the
    //  string is not displayable with teh fat text imager.

    ASSERT(Length > 0);     // Client handles 0 length strings
    ASSERT(Face);

    // Preset output variables for empty string

    GlyphCount = 0;


    // Generate glyphs and check for font fallback requirement

    Glyphs.SetSize(Length);
    if (!Glyphs)
    {
        return OutOfMemory;
    }

    Face->GetCmap().LookupUnicode(
        String,
        Length,
        Glyphs.Get(),
        (UINT*)&GlyphCount,
        FALSE
    );

    ASSERT(GlyphCount == Length);  // No surrogates, chars to Glyphs are 1:1.



    /// Hotkey handling
    //
    //  Before looking for missing Glyphs, check for the presence of hotkeys
    //  in the source string and replace the corresponding Glyphs with FFFF.

    if (Format && Format->GetHotkeyPrefix())
    {
        if (RemoveHotkeys() != Ok)
        {
            return NotImplemented;
        }
    }

    if (GlyphCount <= 0)
    {
        return Ok;  // Hotkey handling left nothing to display
    }


    // Check there are no missing Glyphs

    if (    !(FormatFlags & StringFormatFlagsNoFontFallback)
        &&  !Face->IsSymbol())   // We don't fallback on the symbol fonts.
    {
        INT i = ScanForGlyph(Glyphs.Get(), GlyphCount, Face->GetMissingGlyph());

        if (i < GlyphCount)
        {
            // There is a missing glyph
            return NotImplemented;
        }
    }


    // We now have all the Glyphs needed to display the string
    // Obtain character advance widths in font nominal units

    NominalWidths.SetSize(GlyphCount);
    if (!NominalWidths)
    {
        return OutOfMemory;
    }


    // Establish nominal glyph advance widths

    Face->GetGlyphDesignAdvances(
        Glyphs.Get(),
        GlyphCount,
        Style,
        FALSE,  // not vertical
        tracking,
        NominalWidths.Get()
    );


    // Determine string length in world units

    INT totalAdvance = SumWidths(NominalWidths.Get(), GlyphCount);

    TotalWorldAdvance = (totalAdvance * EmSize) / DesignEmHeight;


    if (    LineLengthLimit > 0.0
        &&  TotalWorldAdvance + LeftMargin + RightMargin > LineLengthLimit)
    {
        // This output will need line breaking
        return NotImplemented;
    }


    //  Delete trailing spaces as required.
    //  (We do this here rather than earlier to make sure we don't bypass the
    //  full imager for special cases, and to alow the client to hotkey mark
    //  a trailing space.)

    if (!(FormatFlags & StringFormatFlagsMeasureTrailingSpaces))
    {
        while (GlyphCount > 0 && Glyphs[GlyphCount - 1] == BlankGlyph)
        {
            TotalWorldAdvance -=    NominalWidths[--GlyphCount] * EmSize
                                 /  DesignEmHeight;
        }
    }

    // We now have Glyphs and advance widths, and we know the text is all on
    // one line.

    return Ok;
}






GpStatus FastTextImager::DrawString()
{
    if (GlyphCount <= 0)
    {
        return Ok;  // No display required
    }


    // When rendering grid fitted glyphs, we need to adjust positions as
    // best we can to match nominal widths.


    // Establish face realization to obtain hinted glyph metrics

    GpFaceRealization faceRealization(
        Face,
        Style,
        &FontTransform,
        SizeF(Graphics->GetDpiX(), Graphics->GetDpiY()),
        TextRendering,
        FALSE,  // Try for bits
        FALSE,   // Not specifically cleartype compatible widths
        FALSE  // not sideways
    );

    GpStatus status = faceRealization.GetStatus();
    IF_NOT_OK_WARN_AND_RETURN(status);

    if (faceRealization.IsPathFont())
    {
        // we need to fall back to FullTextImager
        return NotImplemented;
    }

    //  FitBlackBox
    //
    //  We need to know whether any part of the glyph black boxes overhang the
    //  layout rectangle. Here we assume that characters are clipped to their
    //  cell height, and we check teh sidebearings.
    //
    //  With better access to the cache, this code could check the real glyph
    //  black boxes.


    if (!(FormatFlags & StringFormatFlagsNoFitBlackBox))
    {
        // Check for overhanging glyphs

        INT leadingSidebearing28p4;
        INT trailingSidebearing28p4;

        status = faceRealization.GetGlyphStringSidebearings(
            Glyphs.Get(),
            GlyphCount,
            FALSE,
            FALSE,
            &leadingSidebearing28p4,
            &trailingSidebearing28p4
        );
        IF_NOT_OK_WARN_AND_RETURN(status);


        if (    -leadingSidebearing28p4  > LeftMargin  * WorldToDeviceX * 16
            ||  -trailingSidebearing28p4 > RightMargin * WorldToDeviceX * 16)
        {
            return NotImplemented;
        }


        // Adjust margins by sidebearings to allow black pixels to reach up to
        // but not beyond clients formatting rectangle.


        switch (Alignment)
        {
        case StringAlignmentNear:
            OverflowAvailable = GpFloor(RightMargin * WorldToDeviceX) + (trailingSidebearing28p4 >> 4);
            break;

        case StringAlignmentCenter:
            OverflowAvailable = 2 * min(
                GpFloor(LeftMargin  * WorldToDeviceX) + (leadingSidebearing28p4 >> 4),
                GpFloor(RightMargin * WorldToDeviceX) + (trailingSidebearing28p4 >> 4)
            );
            break;

        case StringAlignmentFar:
            OverflowAvailable = GpFloor(LeftMargin * WorldToDeviceX) + (leadingSidebearing28p4 >> 4);
            break;
        }
    }



    //  Clipping:
    //
    //  We need to clip as requested by the client.
    //
    //  If the clients layout rectangle is tall enough for our cell height
    //  we need not clip vertically.
    //
    //  If we're fitting black box and we found an overhang, then we already
    //  fell back to the full imager, so we don't need to clip horizintally here
    //  unless the client set noFitBlackBox.
    //
    //  n - NoFitBlackBox active
    //  w - Nonzero layout rectangle width
    //  h - Nonzero layout rectangle height less than font cell height
    //
    //  n   w   h   CLipping required
    //  --- --- --- ------
    //  0   0   0   None
    //  0   0   1   Clip height
    //  0   1   0   none (width already limited by FitBlackBox)
    //  0   1   1   Clip height (width already limited by FitBlackBox)
    //  1   0   0   none
    //  1   0   1   Clip height
    //  1   1   0   Clip width
    //  1   1   1   Clip width and height




    GpRegion *previousClip  = NULL;
    BOOL      clipped       = FALSE;

    if (    !(FormatFlags & StringFormatFlagsNoClip)
        &&  (    LayoutRectangle.Width > 0
             ||  LayoutRectangle.Height > 0))
    {
        // Determine clipping rectangle, if any.

        PointF textOrigin;
        GetWorldTextRectangleOrigin(textOrigin);

        RectF clipRectangle(LayoutRectangle);

        if (clipRectangle.Width <= 0)
        {
            // Guarantee no horizontal clipping regardless of alignment
            clipRectangle.X     = textOrigin.X;
            clipRectangle.Width = TotalWorldAdvance + LeftMargin + RightMargin;
        }

        if (clipRectangle.Height <= 0)
        {
            // Guarantee no vertical clipping regardless of alignment
            clipRectangle.Y      = textOrigin.Y;
            clipRectangle.Height = CellHeight;
        }


        if (    FormatFlags & StringFormatFlagsNoFitBlackBox
            ||  clipRectangle.X > textOrigin.X
            ||  clipRectangle.GetRight() < textOrigin.X + TotalWorldAdvance + LeftMargin + RightMargin
            ||  clipRectangle.Y > textOrigin.Y
            ||  clipRectangle.GetBottom() < textOrigin.Y + CellHeight)
        {
            //  Preserve existing clipping and combine it with the new one if any

            if (!Graphics->IsClipEmpty())
            {
                previousClip = Graphics->GetClip();
            }

            Graphics->SetClip(clipRectangle, CombineModeIntersect);

            clipped = TRUE;

            // WARNING(("Clipping"));
        }
    }

    SetTextLinesAntialiasMode linesMode(Graphics, &faceRealization);
    if ((IsGridFittedTextRealizationMethod(TextRendering)) && !faceRealization.IsFixedPitch())
    {
        status = FastDrawGlyphsGridFit(faceRealization);
    }
    else
    {
        status = FastDrawGlyphsNominal(faceRealization);
    }


    if (clipped)
    {
        //  Restore clipping state if any
        if (previousClip)
        {
            Graphics->SetClip(previousClip, CombineModeReplace);
            delete previousClip;
        }
        else
        {
            Graphics->ResetClip();
        }
    }

    return status;
}






GpStatus FastTextImager::MeasureString(
    RectF *boundingBox,
    INT   *codepointsFitted,
    INT   *linesFilled
)
{
    ASSERT(GlyphCount >= 0);

    // Regardless of the displayed length, if we're using the fast imager, then
    // we fitted all the characters. (Length > GlyphCount when there are trailing spaces)

    if (codepointsFitted)
    {
        *codepointsFitted = Length;
    }

    if (linesFilled)
    {
        *linesFilled = 1;
    }


    // Return bounding box for (possibly empty) line

    PointF textOrigin;
    GetWorldTextRectangleOrigin(textOrigin);

    *boundingBox = RectF(textOrigin.X, textOrigin.Y, 0, 0);
    boundingBox->Width  = TotalWorldAdvance + LeftMargin + RightMargin;
    boundingBox->Height = CellHeight;

    if (!(FormatFlags & StringFormatFlagsNoClip))
    {
        if (   LayoutRectangle.Height > 0
            && boundingBox->Height > LayoutRectangle.Height)
        {
            boundingBox->Height = LayoutRectangle.Height;
        }

        if (   LayoutRectangle.Width > 0
            && boundingBox->Width > LayoutRectangle.Width)
        {
            boundingBox->X = LayoutRectangle.X;
            boundingBox->Width = LayoutRectangle.Width;
        }
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\driverstringimager.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   DriverStringImager.cpp
*
* Abstract:
*
*   Legacy text support. Provides basic glyphing - a subset of ExtTextOut.
*
* Notes:
*
*   No built in support for International text.
*   No built in support for surrogate codepoints.
*
*   The imager constructor does most of the work imaging the string.
*   It prepares the glyphs through CMAP and GSUB if necessary,  and
*   establishes their device positions.
*
*
* Created:
*
*   08/07/00 dbrown
*
\**************************************************************************/

#include "precomp.hpp"



/// VerticalAnalysis
//
//  Sets the Orientation span vector to 'ItemSideways' for characters that need
//  laying on their side, leaves it as zero for characters that remain
//  upright.
//
//  Returns TRUE if any sideways runs present in the text.

GpStatus DriverStringImager::VerticalAnalysis(BOOL * sideways)
{
    INT  runStart = 0;
    INT  state    = 0;   // 0 == upright,  1 == sideways
    *sideways = FALSE;


    // Find and mark sideways spans

    for (INT i=0; i<=GlyphCount; i++)
    {
        BYTE  chClass;

        if (i < GlyphCount)
        {
            const WCHAR ch = String[i];
            chClass = ScBaseToScFlags[SecondaryClassificationLookup[ch >> 8][ch & 0xFF]];
        }
        else
        {
            // Dummy terminator to force flush
            if (state == 0)
            {
                chClass = SecClassSA | SecClassSF;
            }
            else
            {
                chClass = 0;
            }
        }


        switch (state)
        {

        case 0: // upright
            if (    (chClass & (SecClassSA | SecClassSF))
                &&  (i < GlyphCount))
            {
                // begin sideways run
                runStart = i;
                state = 1;
                *sideways = TRUE;
            }
            break;

        case 1: // sideways
            if (!(chClass & (SecClassSA | SecClassSF)))
            {
                // Exit sideways run
                if (i > runStart)
                {
                    // Draw glyphs from runStart to i as sideways
                    GpStatus status = OrientationVector.SetSpan(runStart, i-runStart, ItemSideways);
                    if (status != Ok)
                        return status;
                }
                runStart = i;
                state = 0;
            }
            break;
        }
    }

    return Ok;
}






///// AddToPath - add glyphs to path
//
//


GpStatus DriverStringImager::AddToPath(
    GpPath                  *path,
    const UINT16            *glyphs,
    const PointF            *glyphOrigins,
    INT                      glyphCount,
    GpMatrix                *fontTransform,
    BOOL                     sideways
)
{
    GpStatus status = Ok;

    fontTransform->Scale(FontScale, FontScale);
    if (GlyphTransform)
    {
        fontTransform->Append(*GlyphTransform);
        fontTransform->RemoveTranslation();
    }

    // Build a face realization and prepare to adjust glyph placement

    const GpMatrix identity;

    GpFaceRealization faceRealization(
        Face,
        Font->GetStyle(),
        &identity,
        SizeF(150.0, 150.0),    // Arbitrary - we won't be hinting
        TextRenderingHintSingleBitPerPixel, // claudebe, do we want to allow for hinted or unhinted path ? // graphics->GetTextRenderingHint(),
        TRUE, /* bPath */
        TRUE, /* bCompatibleWidth */
        sideways
    );


    status = faceRealization.GetStatus();
    IF_NOT_OK_WARN_AND_RETURN(status);

    for (INT i = 0; i < glyphCount; ++i)
    {
        // Set marker at start of each logical character = cell = cluster

        path->SetMarker();

        // Add the path for the glyph itself

        GpGlyphPath *glyphPath = NULL;

        PointF sidewaysOffset;

        status = faceRealization.GetGlyphPath(
            *(glyphs+i),
            &glyphPath,
            &sidewaysOffset
        );
        IF_NOT_OK_WARN_AND_RETURN(status);


        PointF glyphOffset(OriginOffset);

        if (sideways)
        {
            fontTransform->VectorTransform(&sidewaysOffset);
            glyphOffset = glyphOffset - sidewaysOffset;
        }


        if (glyphPath)
        {
            status = path->AddGlyphPath(
                glyphPath,
                glyphOrigins[i].X + glyphOffset.X,
                glyphOrigins[i].Y + glyphOffset.Y,
                fontTransform
            );
            IF_NOT_OK_WARN_AND_RETURN(status);
        }
    }

    // Force marker following last glyph

    path->SetMarker();

    return status;
}



/// GenerateWorldOrigins
//
//  Builds the world origins array (or assigns it from Positions, when that
//  is available).


GpStatus DriverStringImager::GenerateWorldOrigins()
{
    if (WorldOrigins != NULL)
    {
        // World origins have already been calculated

        return Status;
    }

    if (!(Flags & DriverStringOptionsRealizedAdvance))
    {
        // Easy, the client already gave us world positions.
        WorldOrigins = Positions;
    }
    else
    {
        // Map device origins back to world origins

        WorldOriginBuffer.SetSize(GlyphCount);
        if (!WorldOriginBuffer)
        {
            return OutOfMemory;
        }

        memcpy(WorldOriginBuffer.Get(), DeviceOrigins.Get(), GlyphCount * sizeof(PointF));

        GpMatrix deviceToWorld(WorldToDevice);
        deviceToWorld.Invert();
        deviceToWorld.Transform(WorldOriginBuffer.Get(), GlyphCount);

        if (Flags & DriverStringOptionsVertical)
        {
            // Correct western baseline to center baseline

            for (INT i=0; i<GlyphCount; i++)
            {
                WorldOriginBuffer[i].X -= OriginOffset.X;
                WorldOriginBuffer[i].Y -= OriginOffset.Y;
            }
        }

        WorldOrigins = WorldOriginBuffer.Get();
    }

    return Ok;
}






/////  RecordEmfPlusDrawDriverString
//
//      Records EMF+ records describing DrawDriverString

GpStatus DriverStringImager::RecordEmfPlusDrawDriverString(
    const GpBrush   *brush
)
{
    Status = GenerateWorldOrigins();
    if (Status != Ok)
    {
        return Status;
    }

    // First measure the text bounding rectangle

    GpRectF boundingBox;

    Status = Measure(&boundingBox);
    if (Status != Ok)
    {
        // MeasureDriverString failed, we cannot continue

        Graphics->SetValid(FALSE);      // Prevent any more recording
        return Status;
    }


    // Transform bounding box to device coordinates

    GpRectF deviceBounds;

    TransformBounds(
        &WorldToDevice,
        boundingBox.X,
        boundingBox.Y,
        boundingBox.GetRight(),
        boundingBox.GetBottom(),
        &deviceBounds
    );


    // Finally record details in the EmfPlus metafile

    Status = Graphics->Metafile->RecordDrawDriverString(
        &deviceBounds,
        String ? String : Glyphs,
        GlyphCount,
        Font,
        brush,
        WorldOrigins,
        Flags & ~DriverStringOptionsRealizedAdvance,
        GlyphTransform
    );

    if (Status != Ok)
    {
        Graphics->SetValid(FALSE);      // Prevent any more recording
    }

    return Status;
}





/////   GetDriverStringGlyphOrigins
//
//      Establishes glyph origins for DriverString functions when the client
//      passes just the origin with DriverStringOptionsRealizedAdvance.
//
//      The firstGlyph and glyphCopunt parameters allow the client to obtain
//      glyph origins for a subrange of glyphs.

GpStatus DriverStringImager::GetDriverStringGlyphOrigins(
    IN   const GpFaceRealization  *faceRealization,
    IN   INT                       firstGlyph,
    IN   INT                       glyphCount,
    IN   BOOL                      sideways,
    IN   const GpMatrix           *fontTransform,
    IN   INT                       style,
    IN   const PointF             *positions,      // position(s) in world coords
    OUT  PointF                   *glyphOrigins,   // position(s) in device coords
    OUT  PointF                   *finalPosition   // position following final glyph
)
{
    FontTransform = fontTransform;
    Style = style;

    // FinalPosition is provided to return the position at the end of the string
    // to a caller that is implementing realized advance in multiple substrings.
    // FinalPosition is not supported other than in the realized advance case.

    ASSERT(!finalPosition || (Flags & DriverStringOptionsRealizedAdvance));


    // If the glyphs are to be rendered using their own widths, or if they are
    // to be rendered sideways, or in vertical progression we'll need the
    // x,y components of a unit vector along the transformed baseline
    // and the transformed ascender.

    double baselineScale = 0;
    double baselineDx    = 0;
    double baselineDy    = 0;
    double ascenderScale = 0;
    double ascenderDx    = 0;
    double ascenderDy    = 0;


    if (    Flags & DriverStringOptionsVertical
        ||  Flags & DriverStringOptionsRealizedAdvance
        ||  sideways)
    {
        // Calculate device dx,dy for font 0,1 and 1,0 vectors

        if (Flags & DriverStringOptionsVertical)
        {
            ascenderDx = fontTransform->GetM11();
            ascenderDy = fontTransform->GetM12();
            baselineDx = fontTransform->GetM21();
            baselineDy = fontTransform->GetM22();
        }
        else
        {
            baselineDx = fontTransform->GetM11();
            baselineDy = fontTransform->GetM12();
            ascenderDx = fontTransform->GetM21();
            ascenderDy = fontTransform->GetM22();
        }

        baselineScale = sqrt(baselineDx*baselineDx + baselineDy*baselineDy);
        baselineDx /= baselineScale;
        baselineDy /= baselineScale;

        ascenderScale = sqrt(ascenderDx*ascenderDx + ascenderDy*ascenderDy);
        ascenderDx /= ascenderScale;
        ascenderDy /= ascenderScale;
    }


    if (Flags & DriverStringOptionsRealizedAdvance)
    {
        // Get glyph baseline advances for this glyph subrange

        DeviceAdvances.SetSize(glyphCount);
        if (!DeviceAdvances)
        {
            WARNING(("DeviceAdvances not allocated - out of memory"));
            return OutOfMemory;
        }

        GpStatus status = faceRealization->GetGlyphStringDeviceAdvanceVector(
            Glyphs + firstGlyph,
            glyphCount,
            sideways,
            DeviceAdvances.Get()
        );
        IF_NOT_OK_WARN_AND_RETURN(status);


        // Generate realized advances

        glyphOrigins[0] = positions[0];
        if (Flags & DriverStringOptionsVertical)
        {
            glyphOrigins[0].X += OriginOffset.X;
            glyphOrigins[0].Y += OriginOffset.Y;
        }
        WorldToDevice.Transform(glyphOrigins, 1);


        // Accumulate advances

        for (INT i=0; i<glyphCount-1; i++)
        {
            glyphOrigins[i+1].X = glyphOrigins[i].X + TOREAL(baselineDx * DeviceAdvances[i]);
            glyphOrigins[i+1].Y = glyphOrigins[i].Y + TOREAL(baselineDy * DeviceAdvances[i]);
        }


        if (finalPosition)
        {
            finalPosition->X = glyphOrigins[glyphCount-1].X + TOREAL(baselineDx * DeviceAdvances[glyphCount-1]);
            finalPosition->Y = glyphOrigins[glyphCount-1].Y + TOREAL(baselineDy * DeviceAdvances[glyphCount-1]);
            GpMatrix deviceToWorld(WorldToDevice);
            deviceToWorld.Invert();
            deviceToWorld.Transform(finalPosition);
            if (Flags & DriverStringOptionsVertical)
            {
                finalPosition->X -= OriginOffset.X;
                finalPosition->Y -= OriginOffset.Y;
            }
        }
    }
    else
    {
        // Derive device origins directly from world origins

        for (INT i=0; i<glyphCount; i++)
        {
            glyphOrigins[i] = positions[i];
            if (Flags & DriverStringOptionsVertical)
            {
                glyphOrigins[i].X += OriginOffset.X;
                glyphOrigins[i].Y += OriginOffset.Y;
            }
            WorldToDevice.Transform(glyphOrigins+i);
        }
    }

    return Ok;
}





/////   DriverStringImager constructor
//
//      Performs most of the driver string processing.
//
//      Allocate private glyph buffer and do CMAP lookup (if DriverStringOptionsCmapLookup)
//      Do sideways glyph analysis (if DriverStringOptionsVertical)
//      Generate FaceRealization(s) (Both upright and sideways for vertical text)
//      Generate individual glyph origins (if not DriverStringOptionsRealizedAdvance)
//      Generate device glyph origins



DriverStringImager::DriverStringImager(
    const UINT16    *text,
    INT              glyphCount,
    const GpFont    *font,
    const PointF    *positions,
    INT              flags,
    GpGraphics      *graphics,
    const GpMatrix  *glyphTransform
) :
    String                      (NULL),
    Glyphs                      (NULL),
    GlyphCount                  (glyphCount),
    Font                        (font),
    Face                        (NULL),
    Positions                   (positions),
    Flags                       (flags),
    Graphics                    (graphics),
    GlyphTransform              (glyphTransform),
    Status                      (Ok),
    WorldOrigins                (NULL),
    OriginOffset                (PointF(0,0)),
    OrientationVector           (0),
    UprightFaceRealization      (NULL),
    SidewaysFaceRealization     (NULL),
    GlyphBuffer                 (NULL)
{
    if (GlyphCount == -1)
    {
        ASSERT(Flags & DriverStringOptionsCmapLookup);
        GlyphCount = UnicodeStringLength(text);
    }

    if (GlyphCount < 0)
    {
        Status = InvalidParameter;
        return;
    }

    if (GlyphCount == 0)
    {
        return;  // Nothing to do
    }

    Face = font->GetFace();
    if (!Face)
    {
        Status = InvalidParameter;
        return;
    }

    Graphics->GetWorldToDeviceTransform(&WorldToDevice);

    if (!WorldToDevice.IsInvertible())
    {
        ASSERT(WorldToDevice.IsInvertible());
        Status = InvalidParameter;    // Can't continue unless we can get
        return;                       // back from device to world coords.
    }


    // Build font realizations

    EmSize = font->GetEmSize();
    INT style  = font->GetStyle();

    if (Font->GetUnit() != UnitWorld)
    {
        EmSize *= Graphics->GetScaleForAlternatePageUnit(font->GetUnit());
    }

    if (EmSize <= 0.0)
    {
        Status = InvalidParameter;
        return;
    }


    // Choose an appropriate world to ideal scale

    WorldToIdeal = TOREAL(2048.0 / EmSize);


    // Establish font transformation

    FontScale = TOREAL(EmSize / Face->GetDesignEmHeight());

    GpMatrix fontTransform(
        WorldToDevice.GetM11(),
        WorldToDevice.GetM12(),
        WorldToDevice.GetM21(),
        WorldToDevice.GetM22(),
        0,
        0
    );
    fontTransform.Scale(FontScale, FontScale);

    if (GlyphTransform)
    {
        fontTransform.Prepend(*GlyphTransform);
    }


    // Check that the font transform matrix will leave fonts at a visible size

    {
        PointF oneOne(1.0,1.0);
        fontTransform.VectorTransform(&oneOne);
        INT faceEmHeight = Face->GetDesignEmHeight();

        // How high will an em be on the output device?

        if (    (faceEmHeight*faceEmHeight)
            *   (oneOne.X*oneOne.X + oneOne.Y*oneOne.Y)
            <   .01)
        {
            // Font would be < 1/10 of a pixel high
            GlyphCount = 0; // Treat same as an empty string
            Status = Ok;
            return; // Transform matrix could cause out of range values or divide by 0 errors
        }
    }


    // Determine offset from top center to top baseline in world units

    if (Flags & DriverStringOptionsVertical)
    {
        OriginOffset.X = (Face->GetDesignCellDescent() - Face->GetDesignCellAscent())
                         * FontScale
                         / 2.0f;
        if (GlyphTransform)
        {
            GlyphTransform->VectorTransform(&OriginOffset);
        }
    }


    GpMatrix uprightTransform(fontTransform);

    if (Flags & DriverStringOptionsVertical)
    {
        // Upright glyphs (e.g. English) will be rotated 90 degrees clockwise
        uprightTransform.Rotate(90);
    }

    UprightFaceRealization = new GpFaceRealization(
        Face,
        style,
        &uprightTransform,
        SizeF(Graphics->GetDpiX(), Graphics->GetDpiY()),
        Graphics->GetTextRenderingHintInternal(),
        FALSE, /* bPath */
        TRUE, /* bCompatibleWidth */
        FALSE  // not sideways
    );

    if (!UprightFaceRealization)
    {
        Status = OutOfMemory;
        return;
    }
    Status = UprightFaceRealization->GetStatus();
    if (Status != Ok)
        return;

    if (Flags & DriverStringOptionsLimitSubpixel)
        UprightFaceRealization->SetLimitSubpixel(TRUE);

    // Handle CMAP lookup and vertical analysis

    if (flags & DriverStringOptionsCmapLookup)
    {
        String = text;
        GlyphBuffer.SetSize(GlyphCount);
        if (!GlyphBuffer)
        {
            Status = OutOfMemory;
            return;
        }

        Face->GetCmap().LookupUnicode(text, GlyphCount, GlyphBuffer.Get(), NULL, TRUE);
        Glyphs = GlyphBuffer.Get();

        if (Flags & DriverStringOptionsVertical)
        {
            // Assume entire run is upright

            Status = OrientationVector.SetSpan(0, GlyphCount, 0);
            if (Status != Ok)
                return;

            if (!Face->IsSymbol())
            {
                BOOL sideways = FALSE;

                Status = VerticalAnalysis(&sideways);
                if (Status != Ok)
                    return;

                if (sideways)
                {
                    // Will need a sideways realization too

                    SidewaysFaceRealization = new GpFaceRealization(
                        Face,
                        style,
                        &fontTransform,
                        SizeF(Graphics->GetDpiX(), Graphics->GetDpiY()),
                        Graphics->GetTextRenderingHintInternal(),
                        FALSE, /* bPath */
                        TRUE, /* bCompatibleWidth */
                        TRUE  // sideways
                    );
                    if (!SidewaysFaceRealization)
                    {
                        Status = OutOfMemory;
                        return;
                    }
                    Status = SidewaysFaceRealization->GetStatus();
                    if (Status != Ok)
                        return;

                    if (Flags & DriverStringOptionsLimitSubpixel)
                        SidewaysFaceRealization->SetLimitSubpixel(TRUE);
                }
            }
        }
    }
    else
    {
        String = NULL;
        Glyphs = text;
    }


    // Generate individual glyph origins

    DeviceOrigins.SetSize(GlyphCount);
    if (!DeviceOrigins)
    {
        Status = OutOfMemory;
        return;
    }

    // Get glyph origins in device coordinates


    if (!SidewaysFaceRealization)
    {
        // Simple case - all glyphs are upright (though the text may be vertical)

        Status = GetDriverStringGlyphOrigins(
            UprightFaceRealization,
            0,
            GlyphCount,
            FALSE,                // Upright
            &fontTransform,
            style,
            Positions,
            DeviceOrigins.Get(),
            NULL                  // Don't need final position
        );
    }
    else
    {
        // Complex case - runs of upright and sideways glyphs

        SpanRider<BYTE> orientationRider(&OrientationVector);
        PointF runOrigin(Positions[0]);

        while (!orientationRider.AtEnd())
        {
            BOOL runSideways = orientationRider.GetCurrentElement();

            if (runSideways) {

                if (!GlyphBuffer) {

                    // We'll need a copy of the glyphs

                    GlyphBuffer.SetSize(GlyphCount);
                    if (!GlyphBuffer)
                    {
                        Status = OutOfMemory;
                        return;
                    }
                    memcpy(GlyphBuffer.Get(), Glyphs, GlyphCount * sizeof(UINT16));
                    Glyphs = GlyphBuffer.Get();
                }

                // Apply OpenType vertical glyph substitution to sideways glyphs

                ASSERT(orientationRider.GetCurrentSpan().Length <  65536);

                if (Face->GetVerticalSubstitutionOriginals() != NULL) {
                    SubstituteVerticalGlyphs(
                        GlyphBuffer.Get() + orientationRider.GetCurrentSpanStart(),
                        static_cast<UINT16>(orientationRider.GetCurrentSpan().Length),
                        Face->GetVerticalSubstitutionCount(),
                        Face->GetVerticalSubstitutionOriginals(),
                        Face->GetVerticalSubstitutionSubstitutions()
                    );
                }
            }


            // GetDriverStringGlyphOrigins handles both realized and user
            // supplied glyph positions. For realized positions we need to pass
            // the origin of each run and get back the final position for that
            // run. For User supplied positions we pass the appropriate slice
            // of the user supplied array.

            const PointF *positions;
            PointF       *finalPosition;


            if (Flags & DriverStringOptionsRealizedAdvance)
            {
                    positions     = &runOrigin;
                    finalPosition = &runOrigin; // Required origin for next run
            }
            else
            {
                    positions     = Positions + orientationRider.GetCurrentSpanStart();
                    finalPosition = NULL;  // Next run position determined by callers glyph positions
            }

            Status = GetDriverStringGlyphOrigins(
                runSideways ? SidewaysFaceRealization : UprightFaceRealization,
                orientationRider.GetCurrentSpanStart(),
                orientationRider.GetCurrentSpan().Length,
                runSideways,
                &fontTransform,
                style,
                positions,
                DeviceOrigins.Get() + orientationRider.GetCurrentSpanStart(),
                finalPosition
            );

            if (Status != Ok)
            {
                return;
            }

            orientationRider++;
        }
    }
}




/// DrawGlyphRange
//
//  Draws glyphs in the specified range at origins in the Position buffer

GpStatus DriverStringImager::DrawGlyphRange(
    const GpFaceRealization  *faceRealization,
    const GpBrush            *brush,
    INT                       first,
    INT                       length
)
{
    GpStatus status;
    BOOL sideways = (SpanRider<BYTE>(&OrientationVector)[first] != 0);

    // if we record to a Meta file and even the font is Path font, we need to record
    // the call as ExtTextOut not as PolyPolygon.

    SetTextLinesAntialiasMode linesMode(Graphics, faceRealization);

    if (faceRealization->IsPathFont() &&
        Graphics->Driver != Globals::MetaDriver)
    {
        // the font size is too big to be handled by bitmap, we need to use path
        GpPath path(FillModeWinding);
        GpLock lockGraphics(Graphics->GetObjectLock());

        status = GenerateWorldOrigins();
        IF_NOT_OK_WARN_AND_RETURN(status);

        GpMatrix fontTransform;

        BOOL vertical = (Flags & DriverStringOptionsVertical);

        if (sideways && !vertical)
        {
            //  Horizontal sideways, rotate -90 degree
            fontTransform.Rotate(-90);
        }
        if (!sideways && vertical)
        {
            //  Vertical upright, rotate 90 degree
            fontTransform.Rotate(90);
        }

        status = AddToPath(
            &path,
            Glyphs + first,
            WorldOrigins + first,
            length,
            &fontTransform,
            sideways
        );
        IF_NOT_OK_WARN_AND_RETURN(status);

        status = Graphics->FillPath(brush, &path);
    }
    else
    {
        // Draw glyphs on device surface

        INT drawFlags = 0;

        status = Graphics->DrawPlacedGlyphs(
            faceRealization,
            brush,
            drawFlags,
            String+first,
            length,
            FALSE,
            Glyphs+first,
            NULL,   // no mapping (it is 1 to 1)
            DeviceOrigins.Get()+first,
            length,
            ScriptNone,
            sideways
        );
    }

    IF_NOT_OK_WARN_AND_RETURN(status);

    // we disable underline/strikeout when RealizedAdvance is OFF
    // in future we would like to underline individual glyphs
    if ((Font->GetStyle() & (FontStyleUnderline | FontStyleStrikeout)) &&
        (Flags & DriverStringOptionsRealizedAdvance))
    {
        RectF   baseline;

        status = MeasureString(
            NULL,   // need no bounding box
            &baseline
        );

        IF_NOT_OK_WARN_AND_RETURN(status);

        status = Graphics->DrawFontStyleLine(
            &PointF(
                baseline.X,
                baseline.Y
            ),
            baseline.Width,
            Face,
            brush,
            Flags & DriverStringOptionsVertical,
            EmSize,
            Font->GetStyle(),
            GlyphTransform
        );
    }

    return status;
}






/////   Draw
//
//


GpStatus DriverStringImager::Draw(
    IN const GpBrush *brush
)
{
    if (    Status != Ok
        ||  GlyphCount <= 0)
    {
        return Status;
    }


    if (Graphics->IsRecording())
    {
        Status = RecordEmfPlusDrawDriverString(brush);

        if (    Status != Ok
            ||  !Graphics->DownLevel)
        {
            // Exit on error, or if we don't need to create downlevel records
            return Status;
        }
    }

    EmfPlusDisabler disableEmfPlus(&Graphics->Metafile);

    if (SidewaysFaceRealization)
    {
        // Complex case

        SpanRider<BYTE> orientationRider(&OrientationVector);

        while (!orientationRider.AtEnd())
        {
            Status = DrawGlyphRange(
                orientationRider.GetCurrentElement()
                    ? SidewaysFaceRealization
                    : UprightFaceRealization,
                brush,
                orientationRider.GetCurrentSpanStart(),
                orientationRider.GetCurrentSpan().Length
            );

            orientationRider++;
        }
    }
    else
    {
        // Simple case
        Status = DrawGlyphRange(
            UprightFaceRealization,
            brush,
            0,
            GlyphCount
        );
    }

    return Status;
}






/////   Measure
//
//


GpStatus DriverStringImager::Measure(
    OUT RectF   *boundingBox   // Overall bounding box of cells
)
{
    Status = MeasureString(
        boundingBox
    );

    IF_NOT_OK_WARN_AND_RETURN(Status);

    if (GlyphTransform)
    {
        if (Flags & DriverStringOptionsRealizedAdvance)
        {
            TransformBounds(
                GlyphTransform,
                boundingBox->X,
                boundingBox->Y,
                boundingBox->X + boundingBox->Width,
                boundingBox->Y + boundingBox->Height,
                boundingBox
            );
        }
    }
    return Status;
}




GpStatus DriverStringImager::MeasureString(
    OUT RectF   *boundingBox,       // Overall bounding box of cells
    OUT RectF   *baseline           // base line rectangle with 0 height
)
{
    if (    Status != Ok
        ||  GlyphCount <= 0)
    {
        memset(boundingBox, 0, sizeof(*boundingBox));
        return Status;
    }


    Status = GenerateWorldOrigins();
    if (Status != Ok)
    {
        return Status;
    }


    // Build cell boundaries one by one, and return overall bounding rectangle

    GpMatrix glyphInverseTransform;

    if (GlyphTransform  &&  GlyphTransform->IsInvertible())
    {
        glyphInverseTransform = *GlyphTransform;
        glyphInverseTransform.Invert();
    }

    PointF pt = WorldOrigins[0];
    if (Flags & DriverStringOptionsRealizedAdvance)
    {
        glyphInverseTransform.Transform(&pt, 1);
    }

    REAL minX = pt.X;
    REAL minY = pt.Y;
    REAL maxX = pt.X;
    REAL maxY = pt.Y;

    REAL designToWorld  = EmSize / Face->GetDesignEmHeight();
    REAL ascent         = Face->GetDesignCellAscent() * designToWorld;
    REAL descent        = Face->GetDesignCellDescent() * designToWorld;


    // Get glyph design widths

    AutoBuffer<UINT16, 32> designAdvances(GlyphCount);
    if (!designAdvances)
    {
        return OutOfMemory;
    }


    Face->GetGlyphDesignAdvances(
        Glyphs,
        GlyphCount,
        Font->GetStyle(),
        Flags & DriverStringOptionsVertical ? TRUE : FALSE,
        1.0,
        designAdvances.Get()
    );


    PointF baselineOrigin(pt);


    // Establish overall string bounds

    if (!(Flags & DriverStringOptionsVertical))
    {
        //  Easy case as all characters are upright.

        for (INT i=0; i<GlyphCount; i++)
        {
            if (Glyphs[i] != 0xffff)
            {
                pt = WorldOrigins[i];
                REAL glyphMinX = 0;
                REAL glyphMinY = -ascent;
                REAL glyphMaxX = designAdvances[i] * designToWorld;
                REAL glyphMaxY = descent;
                if (Flags & DriverStringOptionsRealizedAdvance)
                {
                    glyphInverseTransform.Transform(&pt, 1);
                    minX = min(minX, pt.X + glyphMinX);
                    minY = min(minY, pt.Y + glyphMinY);
                    maxX = max(maxX, pt.X + glyphMaxX);
                    maxY = max(maxY, pt.Y + glyphMaxY);
                }
                else
                {
                    RectF bbox;
                    TransformBounds(
                        GlyphTransform,
                        glyphMinX,
                        glyphMinY,
                        glyphMaxX,
                        glyphMaxY,
                        &bbox
                    );
                    bbox.X += pt.X;
                    bbox.Y += pt.Y;
                    minX = min(minX, bbox.X);
                    minY = min(minY, bbox.Y);
                    maxX = max(maxX, bbox.X + bbox.Width);
                    maxY = max(maxY, bbox.Y + bbox.Height);
                }

                baselineOrigin.Y = max(baselineOrigin.Y, pt.Y);
            }
        }

        if (baseline)
        {
            baseline->X      = baselineOrigin.X;
            baseline->Y      = baselineOrigin.Y;
            baseline->Width  = maxX - minX;
            baseline->Height = 0.0;
        }
    }
    else
    {
        //  Complex, there might be mixed sideway and upright items.

        AutoBuffer<UINT16, 32> designHmtxAdvances(GlyphCount);

        if (!designHmtxAdvances)
        {
            return OutOfMemory;
        }

        Face->GetGlyphDesignAdvances(
            Glyphs,
            GlyphCount,
            Font->GetStyle(),
            FALSE,  // hmtx
            1.0,
            designHmtxAdvances.Get()
        );


        SpanRider<BYTE> orientationRider(&OrientationVector);

        while (!orientationRider.AtEnd())
        {
            for (UINT i = 0; i < orientationRider.GetCurrentSpan().Length; i++)
            {
                INT j = i + orientationRider.GetCurrentSpanStart();

                if (Glyphs[j] != 0xffff)
                {
                    pt = WorldOrigins[j];
                    REAL glyphMinX;
                    REAL glyphMaxX;
                    if (orientationRider.GetCurrentElement())
                    {
                        //  Vertical sideways
                        glyphMinX = -(designHmtxAdvances[j] / 2) * designToWorld;
                        glyphMaxX = +(designHmtxAdvances[j] / 2) * designToWorld;
                    }
                    else
                    {
                        //  Vertical upright
                        glyphMinX = -(ascent + descent) / 2;
                        glyphMaxX = +(ascent + descent) / 2;
                    }
                    REAL glyphMinY = 0;
                    REAL glyphMaxY = +designHmtxAdvances[j] * designToWorld;
                    if (Flags & DriverStringOptionsRealizedAdvance)
                    {
                        glyphInverseTransform.Transform(&pt, 1);

                        minX = min(minX, pt.X + glyphMinX);
                        maxX = max(maxX, pt.X + glyphMaxX);
                        minY = min(minY, pt.Y + glyphMinY);
                        maxY = max(maxY, pt.Y + glyphMaxY);
                    }
                    else
                    {
                        RectF bbox;
                        TransformBounds(
                            GlyphTransform,
                            glyphMinX,
                            glyphMinY,
                            glyphMaxX,
                            glyphMaxY,
                            &bbox
                        );
                        bbox.X += pt.X;
                        bbox.Y += pt.Y;
                        minX = min(minX, bbox.X);
                        minY = min(minY, bbox.Y);
                        maxX = max(maxX, bbox.X + bbox.Width);
                        maxY = max(maxY, bbox.Y + bbox.Height);
                    }
                }
            }

            baselineOrigin.X = min(baselineOrigin.X, pt.X);
            baselineOrigin.Y = min(baselineOrigin.Y, minY);

            orientationRider++;     // advance to next item
        }


        if (baseline)
        {
            baseline->X      = baselineOrigin.X;
            baseline->Y      = baselineOrigin.Y;
            baseline->Width  = maxY - minY;
            baseline->Height = 0.0;

            //  The interesting question is where the baseline should be for
            //  vertical as we centered the FE glyphs horizontally. We want to make
            //  sure the underline position (derived by this baseline) dont
            //  fall out of the bounding box and at the same time dont overlap
            //  too much of a FE glyph.
            //
            //  One possible position is to make the baseline so that its underline
            //  left most pixel is exactly at the bounding box edge.

            baseline->X += max(0.0f, minX - baseline->X - Face->GetDesignUnderscorePosition() * designToWorld);
        }
    }

    if (boundingBox)
    {
        boundingBox->X      = minX;
        boundingBox->Y      = minY;
        boundingBox->Width  = maxX - minX;
        boundingBox->Height = maxY - minY;
    }

    return Status;
}

/////   DrawDriverString - Draw codepoints or glyphs for legacy compatability
//
//

GpStatus
GpGraphics::DrawDriverString(
    const UINT16     *text,
    INT               glyphCount,
    const GpFont     *font,
    const GpBrush    *brush,
    const PointF     *positions,
    INT               flags,
    const GpMatrix   *glyphTransform     // optional
)
{
    GpStatus status = CheckTextMode();
    if (status != Ok)
        return status;

    if (font->GetStyle() & (FontStyleUnderline | FontStyleStrikeout))
    {
        //  Underline/strikeout not supported (339798)
        return InvalidParameter;
    }

    DriverStringImager imager(
        text,
        glyphCount,
        font,
        positions,
        flags,
        this,
        glyphTransform
    );

    return imager.Draw(brush);
}


/////   MeasureDriverString - Measure codepoints or glyphs for legacy compatability
//
//  last parameter is used only if the flags have DriverStringOptionsRealizedAdvance or
//  DriverStringOptionsCompensateResolution.
//  and this parameter is added only for optimizing the calculations of the bounding
//  rectangle and getting the glyph origins in same time while recording DrawDriverString
//  in EMF+. otherwise it is defaulted to NULL

GpStatus
GpGraphics::MeasureDriverString(
    const UINT16     *text,
    INT               glyphCount,
    const GpFont     *font,
    const PointF     *positions,
    INT               flags,
    const GpMatrix   *glyphTransform,   // In  - Optional glyph transform
    RectF            *boundingBox       // Out - Overall bounding box of cells
)
{
    CalculateTextRenderingHintInternal();
    DriverStringImager imager(
        text,
        glyphCount,
        font,
        positions,
        flags,
        this,
        glyphTransform
    );

    return imager.Measure(boundingBox);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\flip.hpp ===
////    FlipWords and DWords - useful when processing Truetype tables
//
//      entry   pw/pdw - Pointer to initial word/double word
//              n      - Number of words or doublewords to flip


__inline void FlipWords(void *memPtr, INT n) {
    INT i;
    WORD *pw = (WORD*)memPtr;

    for (i=0; i<n; i++) {
        pw[i] = (pw[i] & 0x00ff) << 8 | pw[i] >> 8;
    }
}


__inline void FlipDWords(void *memPtr, INT n) {
    INT i;
    UNALIGNED DWORD *pdw = (UNALIGNED DWORD*) memPtr;

    for (i=0; i<n; i++) {
        pdw[i] =   (pdw[i] & 0x000000ff) << 24
                 | (pdw[i] & 0x0000ff00) <<  8
                 | (pdw[i] & 0x00ff0000) >>  8
                 | (pdw[i]             ) >> 24;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\fulltextimager.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Full text imager implementation
*
* Revision History:
*
*   06/16/1999 dbrown
*       Created it.
*
\**************************************************************************/


#include "precomp.hpp"




FullTextImager::FullTextImager (
    const WCHAR                 *string,
    INT                         length,
    REAL                        width,
    REAL                        height,
    const GpFontFamily          *family,
    INT                         style,
    REAL                        size,
    const GpStringFormat        *format,
    const GpBrush               *brush) :

    GpTextImager(),
    Width                       (width),
    Height                      (height),
    BrushVector                 (brush),
    FamilyVector                (family),
    StyleVector                 (style),
    SizeVector                  (size),
    FormatVector                (format),
    LanguageVector              (LANG_NEUTRAL),
    TextItemVector              (0),
    BreakVector                 (NULL),
    RunVector                   (NULL),
    ParagraphVector             (NULL),
    BuiltLineVector             (NULL),
    VisibilityVector            (VisibilityShow),
    RangeVector                 (0),
    LinesFilled                 (0),
    CodepointsFitted            (0),
    LeftOrTopLineEdge           (0x7fffffff),
    RightOrBottomLineEdge       (0x80000000),
    TextDepth                   (0),
    LineServicesOwner           (NULL),
    Status                      (Ok),
    RunRider                    (&RunVector),
    ParagraphRider              (&ParagraphVector),
    HighStringPosition          (0),
    HighLineServicesPosition    (0),
    Graphics                    (NULL),
    Path                        (NULL),
    Ellipsis                    (NULL),
    BreakClassFromCharClass     (BreakClassFromCharClassNarrow),
    DefaultFontGridFitBaselineAdjustment (0),
    Flags                       (0)
{
    ASSERT(MAX_SCRIPT_BITS >= ScriptMax);

    Dirty = TRUE;


    // Take local copy of client string

    String = (WCHAR*) GpMalloc(sizeof(WCHAR) * length);
    if (String)
    {
        memcpy(String, string, length * sizeof(WCHAR));
        Length = length;

        INT hotkeyOption = GetFormatHotkeyPrefix(format);

        if (hotkeyOption != HotkeyPrefixNone)
        {
            INT i = 0;
            while (i < Length)
            {
                if (String[i] == '&')
                {
                    String[i++] = WCH_IGNORABLE;

                    if (   hotkeyOption == HotkeyPrefixShow
                        && i < Length
                        && String[i] != '&')
                    {
                        HotkeyPrefix.Add(i - 1);
                    }
                }
                i++;
            }
        }
    }
    else
    {
        Status = OutOfMemory;
        Length = 0;
    }

    // Determine max length of each line and depth of accumulated lines

    if (    format
        &&  format->GetFormatFlags() & StringFormatFlagsDirectionVertical)
    {
        LineLengthLimit = Height;
        TextDepthLimit  = Width;
    }
    else
    {
        LineLengthLimit = Width;
        TextDepthLimit  = Height;
    }

    // Choose scale such that default font is 2048 units high.

    WorldToIdeal = float(2048.0 / size);


    //  Default incremental tab as big as four characters of default font
    //
    //  Incremental tab is the distance to be applied when tabs are encountered
    //  to the right of user-defined tabstops (see sample below).
    //
    //  (given - incremental tab: 5, t: user tabstop, x: text separated with tab)
    //
    //
    //          ----|----|----|----|----|----
    //                t    t
    //          xx    xx   xx xx   xx   xx
    //                        ^ (start applying incremental tab)

    DefaultIncrementalTab = GpRound(4 * size * WorldToIdeal);


    //  Determine what line break class table to be used.
    //
    //  There are quite a few characters that have ambiguous width depending on
    //  the context. If they are part of an Eastern Asian run, the user is expected
    //  to see the wide form and it should behave like a wide character concerning
    //  line breaking.
    //
    //  The disambiguation is somewhat heuristic. The language tag should really
    //  be used first. But we just dont have it around in V1. The temporary solution
    //  for now is to check if our main font supports any Far East codepages. Revisit
    //  this in V2.
    //
    //  (wchao, 01-03-2001)

    GpFontFace *fontFace = family->GetFace(style);

    if (fontFace)
    {
        static const UINT FarEastCodepages[] =
        {
            932, 936, 949, 950
        };

        INT codepageCount = sizeof(FarEastCodepages) / sizeof(FarEastCodepages[0]);

        for (INT i = 0; i < codepageCount; i++)
        {
            if (fontFace->IsCodePageSupported(FarEastCodepages[i]))
                break;
        }

        if (i < codepageCount)
        {
            //  The default font supports one of the Far East codepages.
            //  This resolves the line break classes to wide.

            BreakClassFromCharClass = BreakClassFromCharClassWide;
        }
    }
}


GpStatus FullTextImager::ReleaseVectors ()
{
    BuiltLineVector.Free();
    RunVector.Free();
    ParagraphVector.Free();
    BreakVector.Free();

    return Ok;
}


FullTextImager::~FullTextImager()
{
    //  Lines must be released before the builder
    //  since builder owns releasing it.
    //

    ReleaseVectors();

    if (String) {
         GpFree(String);
    }
    Length = 0;

    if (LineServicesOwner)
    {
        ols::ReleaseLineServicesOwner(&LineServicesOwner);
    }

    if (Ellipsis)
    {
        delete Ellipsis;
    }
}






/////   GetFallbackFontSize
//
//      Selects an appropriate size for the fallback font. Attempts a
//      compromise match of weight, legibility and clipping.
//
//      Never creates a fallback font of higher em size than original font.


void FullTextImager::GetFallbackFontSize(
    IN   const GpFontFace  *originalFace,
    IN   REAL               originalSize,   // em size
    IN   const GpFontFace  *fallbackFace,
    OUT  REAL              *fallbackSize,   // fallback em size
    OUT  REAL              *fallbackOffset  // fallback baseline offset (+=up)
)
{
    if (originalFace == fallbackFace)
    {
        // Special easy case can happen when fallback fails

        *fallbackSize   = originalSize;
        *fallbackOffset = 0;
        return;
    }



    REAL  originalAscender  = TOREAL(originalFace->GetDesignCellAscent()) /
                              TOREAL(originalFace->GetDesignEmHeight());
    REAL  originalDescender = TOREAL(originalFace->GetDesignCellDescent())/
                              TOREAL(originalFace->GetDesignEmHeight());

    REAL  fallbackAscender  = TOREAL(fallbackFace->GetDesignCellAscent()) /
                              TOREAL(fallbackFace->GetDesignEmHeight());
    REAL  fallbackDescender = TOREAL(fallbackFace->GetDesignCellDescent())/
                              TOREAL(fallbackFace->GetDesignEmHeight());


    // Default results

    *fallbackSize   = originalSize;
    *fallbackOffset = 0;

    // Early out handling

    if (    fallbackAscender  <= 0
        ||  fallbackDescender <= 0)
    {
        // We can't do anything if the fallback font is missing ascender or descender
        return;
    }


    // Start by generating a scale factor and baseline offset that places the
    // fallback font cell exactly over the original font cell


    REAL scale =    (originalAscender + originalDescender)
                 /  (fallbackAscender + fallbackDescender);


    REAL offset = originalDescender - fallbackDescender * scale;


    VERBOSE(("Fallback from %S, a%d%%, d%d%% to %S, a%d%%, d%d%%, scale %d%%, offset %d%%.",
        (BYTE*)(originalFace->pifi)+originalFace->pifi->dpwszFamilyName,
        INT(originalAscender * 100),
        INT(originalDescender * 100),
        (BYTE*)(fallbackFace->pifi)+fallbackFace->pifi->dpwszFamilyName,
        INT(fallbackAscender * 100),
        INT(fallbackDescender * 100),
        INT(scale * 100),
        INT((originalDescender - fallbackDescender) * 100)
    ));



    // We now have a scale factor and offset that size and place the fallback
    // cell directly over the original cell.
    //
    // This may not be ideal.
    //
    // If the em size is significantly reduced, the result may too small to be
    // legible.
    //
    // If the fallback font has no internal leading, the result may be
    // characters touching in subsequent lines.
    //
    // If the baseline offset is more than 10% of the em size, the characters
    // won't appear to be part of the same text.
    //
    // Note that applying these restrictions will lead to clipping of some high
    // and low marks. This is a compromise we cannot avoid.




    // Limit scale factor

    scale  = TOREAL(min(max(scale, 1.0), 1.10));

    // dbrown ToDo: To be compatible with Uniscirbe need to adjust scale
    // factor and offset limits according to emsize: at 8pt and below scale
    // should never be less than 1.0. At 12pt and above scale can drop to
    // 0.75.
    // However - I can't see how to do this in a device independant manner.
    // The client may not have requested the emSize in points.


    // Limit offset

    offset = 0; //TOREAL(min(max(offset, -0.04), 0.04));



    *fallbackSize   = originalSize * scale;
    *fallbackOffset = originalSize * offset;
}











/////   Bidirectional analysis
//
//      Runs the Unicode bidirectional algorithm, and updates the level
//      value in the GpTextItems.


GpStatus FullTextImager::BidirectionalAnalysis()
{
    AutoArray<BYTE> levels(new BYTE[Length]);

    if (!levels)
    {
        return OutOfMemory;
    }


    INT      bidiFlags      = 0;
    INT      lengthAnalyzed = 0;
    BYTE     baseLevel      = GetParagraphEmbeddingLevel();
    GpStatus status = Ok;


    if (baseLevel == 1)
    {
        bidiFlags = BidiParagraphDirectioRightToLeft;
        if (Globals::ACP == 1256  ||  PRIMARYLANGID(GetUserLanguageID()) == LANG_ARABIC)
        {
            bidiFlags |= BidiPreviousStrongIsArabic;
        }
    }

    status = UnicodeBidiAnalyze(
        String,
        Length,
        (BidiAnalysisFlags)bidiFlags,
        NULL,
        levels.Get(),
        &lengthAnalyzed
    );

    if (status != Ok)
    {
        return status;
    }

    ASSERT (lengthAnalyzed == Length);

    #define ValidLevel(l) (l == 255 ? baseLevel : l)

    #if DBG
        INT nesting = ValidLevel(levels[0]) - baseLevel;
    #endif


    // Merge levels and text items

    INT runStart = 0;
    SpanRider<GpTextItem> itemRider(&TextItemVector);


    while (runStart < lengthAnalyzed)
    {
        INT level = ValidLevel(levels[runStart]);

        itemRider.SetPosition(runStart);

        // Scan to first change in level or text item

        INT runEnd = runStart + 1;
        INT limit  = runStart + itemRider.GetUniformLength();
        if (limit > lengthAnalyzed)
        {
            limit = lengthAnalyzed;
        }

        while (    runEnd < limit
               &&  level == ValidLevel(levels[runEnd]))
        {
            runEnd++;
        }

        if (level != 0)
        {
            // Run level is different from default

            GpTextItem item = itemRider.GetCurrentElement();

            item.Level = level;

            status = itemRider.SetSpan(
                runStart,
                runEnd - runStart,
                item
            );
            if (status != Ok)
                return status;
        }

        #if DBG
            // CR/LF items must be at level zero

            itemRider.SetPosition(runStart);
            ASSERT(    String[runStart] != 0x0d
                   ||  itemRider.GetCurrentElement().Level == baseLevel);

            nesting +=    (runEnd == lengthAnalyzed
                          ? baseLevel
                          : ValidLevel(levels[runEnd]))
                       -  ValidLevel(levels[runStart]);
        #endif

        runStart = runEnd;
    }
    ASSERT (nesting == 0);  // keep the nesting level in check!

    return Ok;
}






/////   MirroredNumericAndVerticalAnalysis
//
//      Updates backing store for mirrored characters and digit substitution.
//
//      Breaks text items where required for glyph mirroring by transform,
//      for vertical glyphs remaining upright (sideways to the baseline),
//      and for numeric text requiring glyph substitution.
//
//      Notes:
//
//          Mirroring is not performed when metafiling
//          Mirroring is only performed for RTL rendering runs
//
//
//      Far Eastern text is allocated to vertical upright items, all other
//      text is allocated to vertical rotated items.
//
//      Vertical upright items use font vertical metrics to place the glyphs
//      the same way up as for horizontal text, but laid out vertically.
//
//      Vertical rotated items are the same as horizontal items, except that
//      the whole run is rotated clockwise 90 degrees.


GpStatus FullTextImager::MirroredNumericAndVerticalAnalysis(
    ItemScript numericScript
)
{
    SpanRider<GpTextItem> itemRider(&TextItemVector);

    INT mask = SecClassMS | SecClassMX;

    if (numericScript != ScriptNone)
    {
        mask |= SecClassEN | SecClassCS | SecClassET;
    }

    if (GetFormatFlags() & StringFormatFlagsDirectionVertical)
    {
        mask |= SecClassSA | SecClassSF;

        // Set ItemVertical flag on each item in a vertical text imager

        itemRider.SetPosition(0);
        while (!itemRider.AtEnd())
        {
            itemRider.GetCurrentElement().Flags |= ItemVertical;
            itemRider++;
        }
    }

    return SecondaryItemization(String, Length, numericScript, mask, GetParagraphEmbeddingLevel(),
                         GetMetaFileRecordingFlag(), &TextItemVector);
}






/////   CreateTextRuns
//
//      Create one or more runs for a given string. Multiple runs are
//      generated when font fallback is required.


GpStatus FullTextImager::CreateTextRuns(
    INT                 runLineServicesStart,
    INT                 runStringStart,
    INT                 runLength,
    const GpTextItem   &item,
    INT                 formatFlags,
    const GpFontFamily *family,
    INT                 style,
    REAL                size
)
{
    GpStatus status = Ok;

    const GpFontFace *face = family->GetFace(style);

    if (face == (GpFontFace *) NULL)
        return GenericError;

    while (runLength > 0)
    {
        // Start by glyphing the run

        GMAP    *glyphMap;
        UINT16  *glyphs;
        GPROP   *glyphProperties;
        INT      glyphCount;
        USHORT   engineState;


        status = face->GetShapingCache()->GetGlyphs(
            &item,
            String + runStringStart,
            runLength,
            formatFlags,
            GetFormatHotkeyPrefix() != HotkeyPrefixNone,
            &glyphMap,
            &glyphs,
            (SCRIPT_VISATTR**)&glyphProperties,
            &glyphCount,
            &engineState
        );
        if (status != Ok)
        {
            return status;
        }


        // Establish limit of valid clusters (clusters not containing
        // any missing glyphs).
        //
        // Establishes length in codepoints (validCodepoints) and glyphs
        // (validGlyphs).

        UINT16 missingGlyph = face->GetMissingGlyph();
        INT    validCodepoints;
        INT    nextValidCodepoints = runLength;
        INT    validGlyphs = 0;

        if ((formatFlags & StringFormatFlagsNoFontFallback) ||
             face->IsSymbol())
        {
            // Pretend there were no missing glyphs
            validCodepoints = runLength;
            validGlyphs     = glyphCount;
        }
        else
        {
            while (    validGlyphs <  glyphCount
                   &&  glyphs[validGlyphs] != missingGlyph)
            {
                validGlyphs++;
            }

            if (validGlyphs >= glyphCount)
            {
                validCodepoints = runLength;  // No missing glyphs
            }
            else
            {
                // Run forwards to find first character of cluster following that
                // containing the missing glyph, then back to the first codepoint
                // of the cluster containing the missing glyph.

                validCodepoints = 0;
                while (    validCodepoints < runLength
                       &&  glyphMap[validCodepoints] < validGlyphs)
                {
                    validCodepoints++;
                }

                nextValidCodepoints = validCodepoints;
                if (validCodepoints < runLength)
                {
                    while (   nextValidCodepoints < runLength
                           && glyphs[glyphMap[nextValidCodepoints]] == missingGlyph)
                    {
                        nextValidCodepoints++;
                    }
                }

                if (   validCodepoints == runLength
                    || glyphMap[validCodepoints] > validGlyphs)
                {
                    validCodepoints--;  // Last codepoint of cluster contain missing glyph

                    validGlyphs = glyphMap[validCodepoints]; // First glyph of cluster containing missing glyph

                    while (    validCodepoints > 0
                           &&  glyphMap[validCodepoints-1] == validGlyphs)
                    {
                        validCodepoints--;
                    }
                }
            }
        }


        if (validCodepoints > 0)
        {
            // Characters up to validCodepoints don't need fallback

            lsrun *run = new lsrun(
                lsrun::RunText,
                runStringStart,
                validCodepoints,
                item,
                formatFlags
            );
            if (!run)
            {
                return OutOfMemory;
            }

            ASSERT(validGlyphs > 0);

            run->Face            = face;
            run->EmSize          = size;
            run->GlyphCount      = validGlyphs;
            run->Glyphs          = glyphs;
            run->GlyphMap        = glyphMap;
            run->GlyphProperties = glyphProperties;
            run->EngineState     = engineState;

            status = RunVector.SetSpan(runLineServicesStart, validCodepoints, run);
            if (status != Ok)
                return status;

            // Account for amount glyphed

            runStringStart       += validCodepoints;
            runLineServicesStart += validCodepoints;
            runLength            -= validCodepoints;
        }
        else
        {
            // This run started with missing glyphs so the glyph buffers
            // returned by GetGlyphs won't be required.

            delete [] glyphs; glyphs = 0;
            delete [] glyphMap; glyphMap = 0;
            delete [] glyphProperties; glyphProperties = 0;

        }


        // We've created a run for any inital run of valid codepoints.
        // If there are more characters to glyph, the next characters
        // will require font fallback.


        if (runLength > 0)
        {
            // Create a fallback run

            const GpFontFace *newFace = NULL;
            INT               uniformLength;

            GpFamilyFallback *familyFallback = family->GetFamilyFallback();

            // it can be NULL if we failed to create the fallback.
            if (familyFallback)
            {
                ASSERT(nextValidCodepoints-validCodepoints>0);

                status = familyFallback->GetUniformFallbackFace(
                    String + runStringStart,
                    nextValidCodepoints-validCodepoints,
                    style,
                    item.Script,
                    &newFace,
                    &uniformLength
                );
                if (status != Ok)
                    return status;
            }
            else
            {
                uniformLength = runLength;
            }

            ASSERT(uniformLength > 0);
            if (uniformLength <= 0)
            {
                return GenericError;
            }

            if (newFace == NULL)
            {
                VERBOSE(("Font fallback failed to get a fallback face"));
                newFace = face;  // Reshape with original face.
            }

            // if the fallback failed to get new font face and we use the original font face
            // then we change the scipt id into ScriptNone (which is equal 0) we are going
            // to show the default glyph any way so we don't need the shaping overhead. also
            // it will be useful in case in Numbers shaping so we will show the Latin numbers
            // instead of the default glyphs.

            status = newFace->GetShapingCache()->GetGlyphs(
                newFace == face ? &GpTextItem(0) : &item,
                String + runStringStart,
                uniformLength,
                formatFlags,
                GetFormatHotkeyPrefix() != HotkeyPrefixNone,
                &glyphMap,
                &glyphs,
                (SCRIPT_VISATTR**)&glyphProperties,
                &glyphCount,
                &engineState
            );
            if (status != Ok)
            {
                return status;
            }

            lsrun *run = new lsrun(
                lsrun::RunText,
                runStringStart,
                uniformLength,
                item,
                formatFlags
            );
            if (!run)
            {
                return OutOfMemory;
            }

            ASSERT(glyphCount > 0);

            run->Face            = newFace;
            run->GlyphCount      = glyphCount;
            run->Glyphs          = glyphs;
            run->GlyphMap        = glyphMap;
            run->GlyphProperties = glyphProperties;
            run->EngineState     = engineState;

            GetFallbackFontSize(
                face,
                size,
                newFace,
                &run->EmSize,
                &run->BaselineOffset
            );

            status = RunVector.SetSpan(runLineServicesStart, uniformLength, run);
            if (status != Ok)
                return status;

            // Account for amount glyphed

            runStringStart       += uniformLength;
            runLineServicesStart += uniformLength;
            runLength            -= uniformLength;
        }

        // If any characters remain, we loop back for more glyphing and fallback.
    }

    return Ok;
}






/////   CreateLevelChangeRuns
//
//      Adds enough level change runs to the imager to account for the
//      specified delta.


GpStatus FullTextImager::CreateLevelChangeRuns(
    IN  INT                  levelChange,
    IN  INT                  runLineServicesStart,
    IN  INT                  runStringStart,
    IN  const GpFontFamily  *family,
    IN  REAL                 size,
    IN  INT                  style,
    OUT INT                 *lineServicesDelta
)
{
    GpStatus status = Ok;
    if (levelChange == 0)
    {
        *lineServicesDelta = 0;
    }
    else
    {
        for (INT i = 0; i < abs(levelChange); i++)
        {
            lsrun *run = new lsrun(
                levelChange > 0  ?  lsrun::RunLevelUp  :  lsrun::RunLevelDown,
                runStringStart,
                1,
                0,      // Null item
                0       // NULL format
            );

            if (!run)
            {
                *lineServicesDelta = i;
                return OutOfMemory;
            }

            //  LS treats reversal run as normal run. This means it'll call
            //  things like GetRunTextMetrics for reversal and expect something
            //  back from it.

            run->Face   = family->GetFace(style);  // Needed for LS GetRunTextMetrics callback
            run->EmSize = size;

            //  Too bad that Line Services couldn't take multiple reversals

            status = RunVector.SetSpan(runLineServicesStart+i, 1, run);
            if (status != Ok)
                return status;
        }

        *lineServicesDelta = abs(levelChange);
    }

    return status;
}






/////   BuildRunsFromTextItemsAndFormatting
//
//      Merges analysed text items with declarative formatting to generate
//      runs.


GpStatus FullTextImager::BuildRunsFromTextItemsAndFormatting(
    IN  INT  stringStart,
    IN  INT  lineServicesStart,
    IN  INT  lineServicesLimit,
    OUT INT *stringEnd,
    OUT INT *lineServicesEnd
)
{
    GpStatus status;

    SpanRider<GpTextItem>            itemRider(&TextItemVector);
    SpanRider<const GpFontFamily*>   familyRider(&FamilyVector);
    SpanRider<REAL>                  sizeRider(&SizeVector);
    SpanRider<INT>                   styleRider(&StyleVector);
    SpanRider<const GpStringFormat*> formatRider(&FormatVector);


    // Build runs until one includes limitLineServicesPosition

    INT runStringStart       = stringStart;
    INT runLineServicesStart = lineServicesStart;

    BOOL hotkeyEnabled = GetFormatHotkeyPrefix() != HotkeyPrefixNone;


    // Establish bidi level just before first run

    INT bidiLevel;

    if (runStringStart <= 0)
    {
        bidiLevel = GetParagraphEmbeddingLevel();
    }
    else
    {
        itemRider.SetPosition(runStringStart-1);
        bidiLevel = itemRider.GetCurrentElement().Level;
    }


    UINT runLength = 1;

    while (    runLineServicesStart <= lineServicesLimit
           &&  runLength > 0)
    {
        itemRider.SetPosition(runStringStart);
        familyRider.SetPosition(runStringStart);
        sizeRider.SetPosition(runStringStart);
        styleRider.SetPosition(runStringStart);
        formatRider.SetPosition(runStringStart);

        // !!! The following code establishes the length of the run
        //     as the distance to the nearest change.
        //     Note that in v2 this code should not break runs where
        //     underlining starts and stops, it therefore needs to
        //     calculate the style uniform length more carefully.

        runLength = Length - runStringStart;
        runLength = min(runLength, itemRider.GetUniformLength());
        runLength = min(runLength, familyRider.GetUniformLength());
        runLength = min(runLength, sizeRider.GetUniformLength());
        runLength = min(runLength, styleRider.GetUniformLength());
        runLength = min(runLength, formatRider.GetUniformLength());

        if (runLength > 0)
        {
            // Create new run. First insert LS reversals if required.

            if (itemRider.GetCurrentElement().Level != bidiLevel)
            {
                // Check that CR/LF runs are at level zero

                ASSERT(    String[runStringStart] != 0x0d
                       ||      itemRider.GetCurrentElement().Level
                           ==  GetParagraphEmbeddingLevel());


                // Insert level change run(s)

                INT lineServicesDelta;

                CreateLevelChangeRuns(
                    itemRider.GetCurrentElement().Level - bidiLevel,
                    runLineServicesStart,
                    runStringStart,
                    familyRider.GetCurrentElement(),
                    sizeRider.GetCurrentElement(),
                    styleRider.GetCurrentElement(),
                    &lineServicesDelta
                );

                bidiLevel = itemRider.GetCurrentElement().Level;
                runLineServicesStart += lineServicesDelta;
            }


            // Create text run.
            //
            // All glyphing is handled in CreateTextRuns.

            status = CreateTextRuns(
                runLineServicesStart,
                runStringStart,
                runLength,
                itemRider.GetCurrentElement(),
                formatRider.GetCurrentElement() ? formatRider.GetCurrentElement()->GetFormatFlags() : 0,
                familyRider.GetCurrentElement(),
                styleRider.GetCurrentElement(),
                sizeRider.GetCurrentElement()
            );
            if (status != Ok)
            {
                return status;
            }

            runLineServicesStart += runLength;
            runStringStart       += runLength;
        }
    }


    // Add a terminating CR/LF if necessary

    if (runLineServicesStart <= lineServicesLimit)
    {

        //  Paragraph mark must not be inside the reversal block.
        //  This is by design for Line Services.


        if (GetParagraphEmbeddingLevel() != bidiLevel)
        {
            // Insert level change run(s)

            INT lineServicesDelta;

            CreateLevelChangeRuns(
                GetParagraphEmbeddingLevel() - bidiLevel,
                runLineServicesStart,
                runStringStart,
                FamilyVector.GetDefault(),
                SizeVector.GetDefault(),
                StyleVector.GetDefault(),
                &lineServicesDelta
            );

            runLineServicesStart += lineServicesDelta;
        }


        //  Create end of paragraph run

        lsrun *run = new lsrun(
            lsrun::RunEndOfParagraph,
            runStringStart,
            2,      // Length
            0,      // Null item
            0       // NULL format
        );
        if (!run)
        {
            return OutOfMemory;
        }

        // Include nominal face and size for LS GetRunTextMetrics callback

        run->Face   = FamilyVector.GetDefault()->GetFace(StyleVector.GetDefault());
        run->EmSize = SizeVector.GetDefault();

        status = RunVector.SetSpan(runLineServicesStart, 2, run);
        if (status != Ok)
            return status;

        runLineServicesStart += 2;


        #if DBG

            //  Reversals sanity check!

            #if TRACEREVERSAL
                ItemVector.Dump();
                RunVector.Dump();
            #endif


            // Check runs and items match, that nesting returns to zero, and
            // that paragraph marks are at the paragraph embedding level.

            SpanRider<GpTextItem>  itemRider(&TextItemVector);
            SpanRider<PLSRUN>      runRider(&RunVector);

            INT nesting = 0;

            while (!runRider.AtEnd())
            {
                itemRider.SetPosition(runRider.GetCurrentElement()->ImagerStringOffset);

                switch (runRider.GetCurrentElement()->RunType)
                {
                case lsrun::RunLevelUp:
                    ASSERT (  itemRider.GetCurrentElement().Level
                            > itemRider.GetPrecedingElement().Level);
                    nesting++;
                    break;

                case lsrun::RunLevelDown:
                    ASSERT (  itemRider.GetCurrentElement().Level
                            < itemRider.GetPrecedingElement().Level);
                    nesting--;
                    break;

                case lsrun::RunText:
                    ASSERT(runRider.GetCurrentElement()->Item == itemRider.GetCurrentElement());
                    if (String[runRider.GetCurrentElement()->ImagerStringOffset] == 0x0d)
                    {
                        ASSERT(itemRider.GetCurrentElement().Level == GetParagraphEmbeddingLevel());
                    }
                    break;
                }

                runRider++;
            }

            ASSERT (nesting == 0);
        #endif  // DBG
    }


    // Done. Record how far we got.

    *lineServicesEnd = runLineServicesStart;
    *stringEnd       = runStringStart;

    return Ok;
}






/////   BuildRunsUpToAndIncluding
//
//      Algorithm
//
//      1. Itemization. Generates GpTextItems containing
//
//          GpTextItem:
//              Script
//              ScriptClass
//              Flags
//              Bidi level
//
//          Flags include:
//              Glyph transform Sideways (for vertical glyphs)
//              Glyph transform Mirrored (for mirrored chars with no suitable codepoint)
//              Glyph layout vertical    (for vertical text)
//
//          Stages:
//              a. Main itemization FSM (in itemize.cpp)
//              b. If bidi present, or RTL, do UnicodeBidiAnalysis
//              c. Mirrored, Numeric and Vertical item FSM.
//
//      2. Create runs by merging FontFamily, style, format etc. spans with
//         the text items. Reversal runs are inserted at bidi level changes.
//
//      3. During run creation, generate glyphs (GlyphRun)
//
//      4. During glyphing, apply fallback for missing glyphs.
//
//      Font fallback is performed during BuildRunsUpToAndIncluding. When
//      we return, fonts have been allocated to avoid (or minimize) the
//      the display of missing glyphs.


GpStatus FullTextImager::BuildRunsUpToAndIncluding(LSCP limitLineServicesPosition)
{
    GpStatus status;

    if (HighLineServicesPosition > limitLineServicesPosition)
    {
        return Ok;  // We've already covered enough for this call
    }


    if (HighLineServicesPosition == 0)
    {
        // !!! This should be incremental


        /// Itemization by script
        //
        //

        INT flags = 0;
        ItemizationFiniteStateMachine(
            String,
            Length,
            0,
            &TextItemVector,
            &flags
        );


        /// Bidirectional analysis
        //
        //

        BOOL bidi =     GetParagraphEmbeddingLevel() != 0
                    ||  flags & CHAR_FLAG_RTL;

        if (bidi)
        {
            BidirectionalAnalysis();
        }


        /// Digit substitution, mirrored and vertical glyphs
        //
        //  First get default format flags.

        StringDigitSubstitute digitSubstitution;
        LANGID                digitLanguage;
        INT                   formatFlags;

        const GpStringFormat *format = FormatVector.GetDefault();

        ItemScript numericScript = ScriptNone;

        if (format)
        {
            numericScript   = format->GetDigitScript();
            formatFlags     = format->GetFormatFlags();
        }
        else
        {
            formatFlags       = 0;
        }


        if (    bidi
            ||  (    flags & CHAR_FLAG_DIGIT
                 &&  numericScript != ScriptNone)
            ||  formatFlags & StringFormatFlagsDirectionVertical)
        {
            MirroredNumericAndVerticalAnalysis(numericScript);
        }
    }


    /// Generate runs from items and formatting spans
    //
    //  Includes glyphing.

    status = BuildRunsFromTextItemsAndFormatting(
        HighStringPosition,
        HighLineServicesPosition,
        limitLineServicesPosition,
        &HighStringPosition,
        &HighLineServicesPosition
    );
    if (status != Ok)
    {
        return status;
    }

    return Ok;
}






/////   Build all lines
//
//

GpStatus FullTextImager::BuildLines()
{
    GpStatus       status   = Ok;
    StringTrimming trimming = GetFormatTrimming();

    status = BuildAllLines(trimming);

    if (    status == Ok
        &&  trimming == StringTrimmingEllipsisPath)
    {
        BOOL contentChanged;

        status = UpdateContentWithPathEllipsis(&contentChanged);

        if (    status == Ok
            &&  contentChanged)
        {
            status = RebuildLines(trimming);
        }
    }
    return status;
}






GpStatus FullTextImager::RebuildLines(StringTrimming trimming)
{
    //  !! This should be done incrementally !!
    //
    //  This function should be removed when we have incremental line building.
    //  Only now that we have to rebuild the whole thing. (wchao)

    ReleaseVectors();

    //LevelVector.Reset(TRUE);
    TextItemVector.Reset(TRUE);

    Dirty = TRUE;

    HighStringPosition       =
    HighLineServicesPosition = 0;

    return BuildAllLines(trimming);
}



GpStatus FullTextImager::UpdateContentWithPathEllipsis(BOOL *contentChanged)
{
    *contentChanged = FALSE;

    const INT lineLengthLimit = GpRound(LineLengthLimit * WorldToIdeal);

    if (lineLengthLimit > 0)
    {
        EllipsisInfo *ellipsis = GetEllipsisInfo();

        if (!ellipsis)
        {
            return OutOfMemory;
        }

        INT stringStartIndex = 0;

        for (INT i = 0; i < LinesFilled; i++)
        {
            GpStatus status = BuiltLineVector[i].Element->UpdateContentWithPathEllipsis (
                ellipsis,
                lineLengthLimit,
                contentChanged
            );

            if (status != Ok)
            {
                return status;
            }

            stringStartIndex += BuiltLineVector[i].Length;
        }
    }
    return Ok;
}



GpStatus FullTextImager::BuildAllLines(StringTrimming trimming)
{
    GpStatus status = Ok;

    if (!Dirty)
    {
        return Ok;  // content is up-to-date and lines were built.
    }

    // Build lines

    if (LineServicesOwner == NULL)
    {
        LineServicesOwner = ols::GetLineServicesOwner(this);
    }


    INT  textDepth      = 0;    // In ideal units
    REAL textDepthLimit = TextDepthLimit * WorldToIdeal;

    INT  formatFlags = GetFormatFlags();

    REAL lineDepthMinAllowanceFactor = 0.0;     // assume no minimum allowance


    if (textDepthLimit > 0.0)
    {
        if (formatFlags & StringFormatFlagsLineLimit)
        {
            //  Only build full display line

            lineDepthMinAllowanceFactor = 1.0;
        }
        else if (trimming != StringTrimmingNone)
        {
            //  Trimming applied,
            //  build line with at least 1/4 of its height being able to display

            lineDepthMinAllowanceFactor = 0.25;
        }
    }


    //  No side trim if wordwrap

    StringTrimming sideTrimming = (formatFlags & StringFormatFlagsNoWrap) ? trimming : StringTrimmingNone;


    // !!! Build all lines from beginning for now

    INT stringOffset        = 0;    // string start index
    INT lsStringOffset      = 0;    // Line Services start index
    INT lineStringLength    = 0;    // actual line string length
    INT lsLineStringLength  = 0;    // actual line string length in LS index
    INT lineBuilt           = 0;
    INT displayable         = 0;


    //  Initialize bounding box edges (BuildLines may be called more than once)

    LeftOrTopLineEdge     = 0x7fffffff;
    RightOrBottomLineEdge = 0x80000000;


    BuiltLine *previousLine = NULL;
    BuiltLine *line;


    while (stringOffset < Length)
    {
        line = new BuiltLine(
                        LineServicesOwner,
                        stringOffset,
                        lsStringOffset,
                        sideTrimming,
                        previousLine
                   );

        if (!line)
        {
            return OutOfMemory;
        }

        status = line->GetStatus();
        if (status != Ok)
        {
            delete line;
            return status;
        }

        if (    lineDepthMinAllowanceFactor > 0.0
            &&  (   textDepthLimit - TOREAL(textDepth)
                 <  TOREAL(lineDepthMinAllowanceFactor * line->GetLineSpacing())))
        {
            //  Kill line with the displayable part smaller than the mininum allowance

            delete line;
            break;
        }

        textDepth += line->GetLineSpacing();

        displayable += line->GetDisplayableCharacterCount();

        lineStringLength = line->GetUntrimmedCharacterCount (
            stringOffset,
            &lsLineStringLength
        );

        status = BuiltLineVector.SetSpan(stringOffset, lineStringLength, line);
        if (status != Ok)
            return status;
        lineBuilt++;

        LeftOrTopLineEdge = min(LeftOrTopLineEdge,   line->GetLeftOrTopGlyphEdge()
                                                   - line->GetLeftOrTopMargin());

        RightOrBottomLineEdge = max(RightOrBottomLineEdge,   line->GetLeftOrTopGlyphEdge()
                                                           + line->GetLineLength()
                                                           + line->GetRightOrBottomMargin());

        stringOffset    += lineStringLength;
        lsStringOffset  += lsLineStringLength;

        previousLine = line;
    }


    if (   stringOffset < Length
        && !(formatFlags & StringFormatFlagsNoWrap)
        && trimming != StringTrimmingNone)
    {
        //  Trim text bottom end

        INT spanCount = BuiltLineVector.GetSpanCount();

        if (spanCount > 0)
        {
            line = (BuiltLine *)BuiltLineVector[spanCount - 1].Element;
            lineStringLength = BuiltLineVector[spanCount - 1].Length;


            //  backup number of character built during the last line
            displayable -= lineStringLength;


            ASSERT(line && stringOffset > 0);


            if (trimming == StringTrimmingWord)
            {
                //  Optimize for trim word. No need to rebuild the line,
                //  the last line already ended properly.

                if (!IsEOP(String[stringOffset - 1]))
                {
                    //  Move back to the beginning of line

                    stringOffset    -= lineStringLength;
                    lsStringOffset  = line->GetLsStartIndex();

                    line->SetTrimming(trimming);

                    lineStringLength = line->GetUntrimmedCharacterCount(stringOffset);

                    status = BuiltLineVector.SetSpan(stringOffset, lineStringLength, line);
                    if (status != Ok)
                        return status;
                }
            }
            else
            {
                //  Move back to the beginning of line

                stringOffset    -= lineStringLength;
                lsStringOffset  = line->GetLsStartIndex();

                //  Delete previously built last line

                status = BuiltLineVector.SetSpan(stringOffset, lineStringLength, NULL);
                delete line, line = 0;
                if (status != Ok)
                    return status;


                //  Rebuild the line,
                //  ignore all break opportunities if trimming character

                line = new BuiltLine(
                    LineServicesOwner,
                    stringOffset,
                    lsStringOffset,
                    trimming,
                    (BuiltLine *)(spanCount > 1 ? BuiltLineVector[spanCount - 2].Element : NULL),
                    TRUE        // enforce ellipsis
                );

                if (!line)
                {
                    return OutOfMemory;
                }

                status = line->GetStatus();
                if (status != Ok)
                {
                    delete line;
                    return status;
                }

                lineStringLength = line->GetUntrimmedCharacterCount(stringOffset);

                status = BuiltLineVector.SetSpan(stringOffset, lineStringLength, line);
                if (status != Ok)
                    return status;

                LeftOrTopLineEdge = min(LeftOrTopLineEdge,   line->GetLeftOrTopGlyphEdge()
                                                           - line->GetLeftOrTopMargin());

                RightOrBottomLineEdge = max(RightOrBottomLineEdge,   line->GetLeftOrTopGlyphEdge()
                                                                   + line->GetLineLength()
                                                                   + line->GetRightOrBottomMargin());
            }

            //  add up to last line's last visible character
            displayable += line->GetDisplayableCharacterCount();

            stringOffset += lineStringLength;
        }
    }

#if DBG
    INT validLines = BuiltLineVector.GetSpanCount();
    BuiltLine *defaultLine = BuiltLineVector.GetDefault();

    while (   validLines > 0
           && BuiltLineVector[validLines - 1].Element == defaultLine)
    {
        validLines--;
    }

    ASSERT (lineBuilt == validLines);
#endif

    TextDepth        = textDepth / WorldToIdeal;

    // Adjust the bottom margin slightly to make room for hinting
    // as long as we have the left/right margins enabled - Version 2
    // should expose this as an independent value!

    const GpStringFormat *format = FormatVector.GetDefault();

    if (!format || format->GetLeadingMargin() != 0.0f)
    {
        // Adjust the bottom margin slightly to make room for hinting...
        // Note that this will result in the Width of the bounding box
        // changing for Vertical text.
        TextDepth += SizeVector.GetDefault() * DefaultBottomMargin;
    }

    CodepointsFitted = displayable;
    LinesFilled      = lineBuilt;

    return status;
}






/////   Map to Line Services string position
//
//


LSCP FullTextImager::LineServicesStringPosition (
    INT stringIndex    // [IN] String index (offset from 0)
)
{
    ASSERT (stringIndex >= 0 && stringIndex <= Length);

    INT spanCount = TextItemVector.GetSpanCount();

    LSCP    lineServicesIndex = stringIndex;

    UINT    length    = 0;
    BYTE    lastLevel = GetParagraphEmbeddingLevel();

    for (INT i = 0; i < spanCount; i++)
    {
        lineServicesIndex += abs(TextItemVector[i].Element.Level - lastLevel);

        if (length + TextItemVector[i].Length >= (UINT)stringIndex)
        {
            break;
        }

        length    += TextItemVector[i].Length;
        lastLevel  = TextItemVector[i].Element.Level;
    }

    if (i == spanCount)
    {
        lineServicesIndex += abs(GetParagraphEmbeddingLevel() - lastLevel);
    }

    return lineServicesIndex;
}




GpStatus FullTextImager::GetTextRun(
    INT     lineServicesStringOffset,   // [IN] Line Services string offset
    PLSRUN  *textRun                    // [OUT] result text run
)
{
    //  Locate the nearest subsequent text run

    if (!RunRider.SetPosition(lineServicesStringOffset))
    {
        return InvalidParameter;
    }

    while (   RunRider.GetCurrentElement()
           && RunRider.GetCurrentElement()->RunType != lsrun::RunText)
    {
        RunRider++;
    }

    *textRun = RunRider.GetCurrentElement();
    return Ok;
}




LSCP FullTextImager::LineServicesStringPosition (
    const BuiltLine *line,          // [IN] line to query
    INT             stringOffset    // [IN] String offset relative to line start string position
)
{
    if (!line || stringOffset < 0)
    {
        //  Invalid parameter!
        return line->GetLsStartIndex();
    }

    UINT runPosition = line->GetLsStartIndex();
    UINT runLimit    = runPosition + line->GetLsDisplayableCharacterCount();
    INT  runLength   = 0;

    SpanRider<PLSRUN> runRider(&RunVector);
    runRider.SetPosition(runPosition);


    while (runPosition < runLimit)
    {
        if (runRider.GetCurrentElement()->RunType == lsrun::RunText)
        {
            runLength = (INT)runRider.GetUniformLength();
            if (   runLength < 0
                || stringOffset - runLength <= 0)
            {
                break;
            }
            stringOffset -= runLength;
        }

        runPosition += runRider.GetCurrentSpan().Length;
        runRider.SetPosition(runPosition);
    }

    ASSERT(   stringOffset >= 0
           && runRider.GetCurrentElement()
           && runRider.GetCurrentElement()->RunType == lsrun::RunText)

    return runPosition + stringOffset;
}





/////   RenderLine
//
//      Render one visible line. The line and the offset to its top are
//      determined by the caller.


GpStatus FullTextImager::RenderLine (
    const BuiltLine  *builtLine,       // [IN] line to be rendered
    INT               linePointOffset  // [IN] point offset to top of the line
                                       //      (in paragraph flow direction)
)
{
    //  Draw main line. Pass DrawLine the baseline origin asuming glyphs are
    //  unrotated, i.e. glyphs with their base on the baseline. We adjust for
    //  glyphs on their sides while responding to the Line Services callback.


    INT nominalBaseline;
    INT baselineAdjustment;

    builtLine->GetBaselineOffset(
        &nominalBaseline,
        &baselineAdjustment
    );

    POINT origin;
    builtLine->LogicalToXY (
        0,
        linePointOffset + nominalBaseline + baselineAdjustment,
        (INT*)&origin.x,
        (INT*)&origin.y
    );

    CurrentBuiltLine = builtLine;   // Global state required by LS callbacks.

    GpStatus status = builtLine->Draw(&origin);


    if (    status == Ok
        &&  builtLine->IsEllipsis()
        &&  GetEllipsisInfo())
    {
        EllipsisInfo *ellipsis = GetEllipsisInfo();


        //  Draw ellipsis

        builtLine->LogicalToXY (
            builtLine->GetEllipsisOffset(),
            linePointOffset + nominalBaseline + baselineAdjustment,
            (INT*)&origin.x,
            (INT*)&origin.y
        );

        status = DrawGlyphs (
            &ellipsis->Item,
            ellipsis->Face,
            ellipsis->EmSize,
            ellipsis->String,
            0,
            ellipsis->GlyphCount,
            FormatVector.GetDefault(),
            StyleVector.GetDefault(),
            GetFormatFlags(),
            ellipsis->Glyphs,
            ellipsis->GlyphMap,
            ellipsis->GlyphProperties,
            ellipsis->GlyphAdvances,
            ellipsis->GlyphOffsets,
            ellipsis->GlyphCount,
            &origin,
            ellipsis->Width
        );
    }

    CurrentBuiltLine = NULL;

    return status;
}






/////   Render
//
//      Render all visible lines. Calculates the offset of each line to be
//      displayed and passes each builtLine and offset in turn to RenderLine.


GpStatus FullTextImager::Render()
{
    if (LinesFilled <= 0)
    {
        return Ok;  // No lines: that's easy
    }


    // Establish offset from imager origin to top (near) edge of 1st line

    INT textDepth       = GpRound(TextDepth      * WorldToIdeal);
    INT textDepthLimit  = GpRound(TextDepthLimit * WorldToIdeal);


    // Establish limits of visibility


    INT firstVisibleLineOffset;
    INT lastVisibleLineLimit;


    if (textDepthLimit > 0)
    {
        // Display in rectangle

        switch (GetFormatLineAlign())
        {
        case StringAlignmentNear:   firstVisibleLineOffset = 0;                                break;
        case StringAlignmentCenter: firstVisibleLineOffset = (textDepth - textDepthLimit) / 2; break;
        case StringAlignmentFar:    firstVisibleLineOffset = textDepth - textDepthLimit;       break;
        }

        lastVisibleLineLimit = firstVisibleLineOffset + textDepthLimit;
    }
    else
    {
        // Display in infinite paragraph length area aligned to point

        firstVisibleLineOffset = 0;
        lastVisibleLineLimit   = textDepth;
    }

    if (!GetAvailableRanges())
    {
        //  No range detected, adjust baseline according to the realized metric.
        //  (More info about when range is presented, see comments in GetAvailableRanges)
        
        GpStatus status = CalculateDefaultFontGridFitBaselineAdjustment();
        IF_NOT_OK_WARN_AND_RETURN(status);
    }
    
    INT formatFlags = GetFormatFlags();

    SetTextLinesAntialiasMode linesMode(0, 0);
    if (Graphics)
    {
        INT               style     = StyleVector.GetDefault();
        const GpFontFace *face      = FamilyVector.GetDefault()->GetFace(style);

        if(!face)
        {
            return FontStyleNotFound;
        }

        REAL              emSize    = SizeVector.GetDefault();
        REAL              fontScale = emSize / TOREAL(face->GetDesignEmHeight());

        GpMatrix fontTransform;
        GetFontTransform(
            fontScale,
            formatFlags & StringFormatFlagsDirectionVertical,
            FALSE,  // not sideways
            FALSE,  // not mirrored
            FALSE,  // not path
            fontTransform
        );

        GpFaceRealization faceRealization(
            face,
            style,
            &fontTransform,
            SizeF(Graphics->GetDpiX(), Graphics->GetDpiY()),
            Graphics->GetTextRenderingHintInternal(),
            FALSE,  // not path
            FALSE,   // don't force compatible width
            FALSE  // not sideways
        );
        GpStatus status = faceRealization.GetStatus();
        IF_NOT_OK_WARN_AND_RETURN(status);

        linesMode.SetAAMode(Graphics, &faceRealization);
    }

    // Loop through lines until no more are visible

    SpanRider<const GpStringFormat*> formatRider(&FormatVector);

    UINT stringPosition  = 0;
    INT  lineIndex       = 0;
    INT  linePointOffset = 0;    // near long edge of line offset from first line

    while (lineIndex < LinesFilled)
    {
        // Get out if invisible and beyond last (partial) line of rectangle

        if (linePointOffset > lastVisibleLineLimit)
        {
            if (    !(formatFlags & StringFormatFlagsNoClip)
                ||  (formatFlags & StringFormatFlagsLineLimit))
            {
                break;
            }
        }

        const BuiltLine *builtLine = BuiltLineVector[lineIndex].Element;
        formatRider.SetPosition(stringPosition);

        // Is this line at least partly visible?

        if (    formatFlags & StringFormatFlagsNoClip
            ||  (   linePointOffset
                 +  builtLine->GetAscent()
                 +  builtLine->GetDescent()) >= firstVisibleLineOffset)
        {
            GpStatus status = RenderLine(
                builtLine,
                linePointOffset
            );
            if (status != Ok)
            {
                return status;
            }
        }

        linePointOffset += builtLine->GetLineSpacing();
        stringPosition  += BuiltLineVector[lineIndex].Length;
        lineIndex++;
    }

    return Ok;
}



//  Establish baseline adjustment required to correct for hinting of the
//  default font. (Fallback and other fonts will align with the default font)

GpStatus FullTextImager::CalculateDefaultFontGridFitBaselineAdjustment()
{
    if (    Graphics
        &&  IsGridFittedTextRealizationMethod(Graphics->GetTextRenderingHintInternal()))
    {
        // When rendering to a Graphics surface, correct the baseline position
        // to allow for any discrepancy between the hinted ascent of the main
        // text imager font and it's scaled nominal ascent.

        INT               style     = StyleVector.GetDefault();
        const GpFontFace *face      = FamilyVector.GetDefault()->GetFace(style);

        if(!face)
        {
            return FontStyleNotFound;
        }

        REAL              emSize    = SizeVector.GetDefault();
        REAL              fontScale = emSize / TOREAL(face->GetDesignEmHeight());

        GpMatrix fontTransform;
        GetFontTransform(
            fontScale,
            GetFormatFlags() & StringFormatFlagsDirectionVertical,    // *
            FALSE,  // not sideways
            FALSE,  // not mirrored
            FALSE,  // not path
            fontTransform
        );


        // For angles other than 0, 90, 180, 270 there is no hinting.
        // For these angles either both m11 & m22 are zero, or both
        // m12 & m21 are zero.

        REAL m21 = fontTransform.GetM21();
        REAL m22 = fontTransform.GetM22();

        GpFaceRealization faceRealization(
            face,
            style,
            &fontTransform,
            SizeF(Graphics->GetDpiX(), Graphics->GetDpiY()),
            Graphics->GetTextRenderingHintInternal(),
            FALSE,  // not path
            FALSE,   // don't force compatible width
            FALSE  // not sideways
        );
        GpStatus status = faceRealization.GetStatus();
        IF_NOT_OK_WARN_AND_RETURN(status);

        if (    !(    faceRealization.IsHorizontalTransform()
                  ||  faceRealization.IsVerticalTransform())
            ||  faceRealization.IsPathFont())
        {
            // There is no hinting with transformations that rotate axes, or
            // for path forendering.
            DefaultFontGridFitBaselineAdjustment = 0;
        }
        else
        {
            INT hintedAscentDevice;
            REAL fontAscenderToDevice;

            if (faceRealization.IsHorizontalTransform())
            {
                // 0 or 180 degrees rotation
                fontAscenderToDevice = m22;
                if (m22 > 0.0f)
                {
                    // No rotation, Glyph not flipped along y axis
                    hintedAscentDevice = -faceRealization.GetYMin();
                }
                else
                {
                    // Glyph flipped along y axis
                    hintedAscentDevice = -faceRealization.GetYMax();
                }
            }
            else
            {
                ASSERT(faceRealization.IsVerticalTransform());
                // 90 or 270 degree rotation
                fontAscenderToDevice = m21;
                if (m21 > 0.0f)
                {
                    // No rotation, Glyph not flipped along x axis
                    hintedAscentDevice = -faceRealization.GetXMin();
                }
                else
                {
                    // Glyph flipped along x axis
                    hintedAscentDevice = -faceRealization.GetXMax();
                }
            }

            INT UnhintedAscentDevice = GpRound(face->GetDesignCellAscent() * fontAscenderToDevice);

            DefaultFontGridFitBaselineAdjustment = GpRound(TOREAL(
                   (hintedAscentDevice - UnhintedAscentDevice) / fontAscenderToDevice
                *  fontScale       // font to world
                *  WorldToIdeal));
        }
    }
    return Ok;
}



void FullTextImager::GetFontTransform(
    IN   REAL               fontScale,
    IN   BOOL               vertical,
    IN   BOOL               sideways,
    IN   BOOL               mirror,
    IN   BOOL               forcePath,
    OUT  GpMatrix&          fontTransform
)
{
    ASSERT(Graphics || Path);


    if (Graphics && !forcePath)
    {
        // Start with device scale for Graphics case
        Graphics->GetWorldToDeviceTransform(&fontTransform);
    }
    else
    {
        // Start with identity matrix for Path case
        fontTransform.Reset();
    }


    fontTransform.Scale(fontScale, fontScale);


    if (mirror)
    {
        fontTransform.Scale(-1.0, 1.0);
    }


    // Add approriate rotation for sideways and vertical cases:
    //
    // vertical                rotate(90.0)
    // sideways                rotate(-90.0)
    // vertical and sideways   glyphs remain upright

    if (vertical)
    {
        if (!sideways)
        {
            fontTransform.Rotate(90.0);
        }
    }
    else if (sideways)
    {
        fontTransform.Rotate(-90.0);
    }
}



GpStatus FullTextImager::DrawGlyphs(
    const GpTextItem        *textItem,          // [IN] text item
    const GpFontFace        *fontFace,          // [IN] font face
    REAL                    emSize,             // [IN] requested em size (world unit)
    const WCHAR             *string,            // [IN] (optional) source string (null means imager's string)
    INT                     stringOffset,       // [IN] string offset relative to given string
    UINT                    stringLength,       // [IN] number of characters in the run string
    const GpStringFormat    *format,            // [IN] stringformat
    const INT               style,              // [IN] default font style
    INT                     formatFlags,        // [IN] formatting flags
    const UINT16            *glyphs,            // [IN] glyph index array
    GMAP                    *glyphMap,          // [IN] string to glyphs mapping
    const UINT16            *glyphProperties,   // [IN] glyph properties array
    const INT               *glyphAdvances,     // [IN] glyph advance width array
    const Point             *glyphOffsets,      // [IN] glyph offset array
    UINT                    glyphCount,         // [IN] number of glyphs
    const POINT             *pointOrigin,       // [IN] drawing origin (at baseline)
    INT                     totalWidth,         // [IN] glyphs total width
    lsrun::Adjustment       *displayAdjust      // [OUT] (optional) display adjustment at edges
)
{
    GpStatus status = Ok;

    const BOOL paragraphRtl    = formatFlags & StringFormatFlagsDirectionRightToLeft;
    const BOOL renderRtl       = textItem->Level & 1;
    const BOOL renderVertical  = textItem->Flags & ItemVertical;
    const BOOL glyphsMirrored  = textItem->Flags & ItemMirror;
    const INT  lineLengthLimit = GpRound(LineLengthLimit * WorldToIdeal);

    if (!string)
    {
        string = String;
    }

    if (displayAdjust)
    {
        displayAdjust->Leading =
        displayAdjust->Trailing = 0;
    }

    REAL fontScale = emSize / TOREAL(fontFace->GetDesignEmHeight());

    GpMatrix fontTransform;
    GetFontTransform(
        fontScale,
        renderVertical,
        textItem->Flags & ItemSideways,
        glyphsMirrored,
        FALSE, // don't force path yet
        fontTransform
    );

    if (Graphics)
    {
        GpFaceRealization faceRealization(
            fontFace,
            style,
            &fontTransform,
            SizeF(Graphics->GetDpiX(), Graphics->GetDpiY()),
            Graphics->GetTextRenderingHintInternal(),
            FALSE, // bPath
            FALSE,  // bCompatibleWidth
            textItem->Flags & ItemSideways
        );
        status = faceRealization.GetStatus();
        IF_NOT_OK_WARN_AND_RETURN(status);

        // if we record to a Meta file and even the font is Path font, we need to record 
        // the call as ExtTextOut not as PolyPolygon.

        if (!faceRealization.IsPathFont() || Graphics->Driver == Globals::MetaDriver)
        {
            /* the rasterizer is able to render the font */

            StringAlignment align;

            if (format)
            {
                align = format->GetPhysicalAlignment();
            }
            else
            {
                align = StringAlignmentNear;
            }


            PointF origin(
                ImagerOrigin.X + pointOrigin->x / WorldToIdeal,
                ImagerOrigin.Y + pointOrigin->y / WorldToIdeal
            );


            // Does this run abut either end of the line?

            INT alignmentOffset = CurrentBuiltLine->GetAlignmentOffset();
            INT lineLength      = CurrentBuiltLine->GetLineLength();

            // Establish top/left offset of run

            INT runLeftOrTopOffset;      // Left edge of formatting rectangle to left edge of run

            if (renderVertical)
            {
                runLeftOrTopOffset = pointOrigin->y;
            }
            else
            {
                runLeftOrTopOffset = pointOrigin->x;

                // Correct out by one errors in the way Line Services reports
                // run pixel positions where there is a conflict of run and
                // paragraph direction.

                if (renderRtl  &&  !paragraphRtl)
                {
                    // Line services is out by one in a direction conflict
                    runLeftOrTopOffset++;
                }
                else if (paragraphRtl  &&  !renderRtl)
                {
                    // Line services is out by one in a direction conflict
                    runLeftOrTopOffset--;
                }


                // In an RTL run Line Services reports the origin as the eight end.

                if (renderRtl)
                {
                    runLeftOrTopOffset -= totalWidth;
                }
            }


            // Derive leading and/or trailing margin available for this run

            INT  runLeadingMargin  = 0;
            INT  runTrailingMargin = 0;
            BOOL runLeadingEdge    = FALSE;
            BOOL runTrailingEdge   = FALSE;

            const INT runRightOrBottomOffset  =   runLeftOrTopOffset + totalWidth;
            const INT lineLeftOrTopOffset     =   CurrentBuiltLine->GetLeftOrTopGlyphEdge();
            const INT lineRightOrBottomOffset =   lineLeftOrTopOffset
                                                + CurrentBuiltLine->GetLineLength();

            if (renderVertical  ||  !renderRtl)
            {
                // Leading edge at the top or left.
                if (runLeftOrTopOffset <= lineLeftOrTopOffset)
                {
                    runLeadingEdge   = TRUE;
                    runLeadingMargin = CurrentBuiltLine->GetLeftOrTopMargin();
                }

                if (runRightOrBottomOffset >= lineRightOrBottomOffset)
                {
                    runTrailingEdge   = TRUE;
                    runTrailingMargin = CurrentBuiltLine->GetRightOrBottomMargin();
                }
            }
            else
            {
                // Leading edge is at the right.
                if (runRightOrBottomOffset >= lineRightOrBottomOffset)
                {
                    runLeadingEdge   = TRUE;
                    runLeadingMargin = CurrentBuiltLine->GetRightOrBottomMargin();
                }

                if (runLeftOrTopOffset <= lineLeftOrTopOffset)
                {
                    runTrailingEdge   = TRUE;
                    runTrailingMargin = CurrentBuiltLine->GetLeftOrTopMargin();
                }
            }


            // Convert advance vector and glyph offsets to glyph positions
            GlyphImager glyphImager;
            GpMatrix worldToDevice;
            Graphics->GetWorldToDeviceTransform(&worldToDevice);

            status = glyphImager.Initialize(
                &faceRealization,
                &worldToDevice,
                WorldToIdeal,
                emSize,
                glyphCount,
                glyphs,
                textItem,
                format,
                runLeadingMargin,
                runTrailingMargin,
                runLeadingEdge,
                runTrailingEdge,
                string,
                stringOffset,
                stringLength,
                glyphProperties,
                glyphAdvances,
                glyphOffsets,
                glyphMap,
                (format && GetAvailableRanges(format)) ? &RangeVector : NULL,
                renderRtl
            );
            IF_NOT_OK_WARN_AND_RETURN(status);


            const INT   *adjustedGlyphAdvances;
            INT         originAdjust;
            INT         trailingAdjust;


            if (RecordDisplayPlacementsOnly)
            {
                if (glyphImager.IsAdjusted())
                {
                    status = glyphImager.GetAdjustedGlyphAdvances(
                        &PointF(
                            ImagerOrigin.X + pointOrigin->x / WorldToIdeal,
                            ImagerOrigin.Y + pointOrigin->y / WorldToIdeal
                        ),
                        &adjustedGlyphAdvances,
                        &originAdjust,
                        &trailingAdjust
                    );
                    IF_NOT_OK_WARN_AND_RETURN(status);

                    status = CurrentBuiltLine->RecordDisplayPlacements(
                        textItem,
                        stringOffset,
                        stringLength,
                        glyphMap,
                        adjustedGlyphAdvances,
                        glyphCount,
                        originAdjust
                    );
                    IF_NOT_OK_WARN_AND_RETURN(status);

                    if (displayAdjust)
                    {
                        displayAdjust->Leading = runLeadingEdge ? originAdjust : 0;
                        displayAdjust->Trailing = runTrailingEdge ? trailingAdjust : 0;
                    }
                }
            }
            else
            {
                PointF cellOrigin;
                PointF baseline(
                    ImagerOrigin.X + pointOrigin->x / WorldToIdeal,
                    ImagerOrigin.Y + pointOrigin->y / WorldToIdeal
                );

                status = glyphImager.DrawGlyphs(
                    baseline,
                    &BrushVector,
                    Graphics,
                    &cellOrigin,
                    &adjustedGlyphAdvances
                );
                IF_NOT_OK_WARN_AND_RETURN(status);


                CurrentBuiltLine->SetDisplayBaseline(
                    &baseline,
                    &cellOrigin
                );


                BOOL drawHotkey = (   GetFormatHotkeyPrefix() == HotkeyPrefixShow
                                   && HotkeyPrefix.GetCount() > 0);

                if (   drawHotkey
                    || (style & (FontStyleUnderline | FontStyleStrikeout)))
                {
                    //  Need edge adjustment for underline/strikethrough

                    status = glyphImager.GetAdjustedGlyphAdvances(
                        NULL,   // dont snap full pixel for underline position
                        &adjustedGlyphAdvances,
                        &originAdjust,
                        &trailingAdjust
                    );

                    if (drawHotkey)
                    {
                        status = DrawHotkeyUnderline(
                            textItem,
                            fontFace,
                            &cellOrigin,
                            emSize,
                            stringOffset,
                            stringLength,
                            glyphCount,
                            glyphMap,
                            adjustedGlyphAdvances,
                            runTrailingEdge ? trailingAdjust : 0
                        );
                        IF_NOT_OK_WARN_AND_RETURN(status);
                    }

                    if (displayAdjust)
                    {
                        displayAdjust->Leading = runLeadingEdge ? originAdjust : 0;
                        displayAdjust->Trailing = runTrailingEdge ? trailingAdjust : 0;
                    }
                }
            }

            return status;
        }

        if (RecordDisplayPlacementsOnly)
        {
            //  This is a graphic output with path simulation,
            //  we're not interested in caching the glyph placement
            //  in this case. The font is big and we're safe to
            //  go with nominal advance width.

            return Ok;
        }

        GetFontTransform(
            fontScale,
            renderVertical,
            textItem->Flags & ItemSideways,
            glyphsMirrored,
            TRUE, // we want path
            fontTransform
        );
    }

    // AddPathGlyphs or we are falling back here because the font size is too big for the rasterizer

    GpPath * path;
    AutoPointer<GpLock> lockGraphics;
    AutoPointer<GpPath> localPath;

    if (Path == NULL)
    {
        localPath = new GpPath(FillModeWinding);
        path = localPath.Get();
        if (path == NULL)
            return OutOfMemory;

        lockGraphics = new GpLock(Graphics->GetObjectLock());
        if (lockGraphics == NULL)
            return OutOfMemory;
    }
    else
    {
        path = Path;
    }

    // !!! Need to loop through brushes individually


    // Build a face realization and prepare to adjust glyph placement
    GpMatrix identity;


    // For complex script fonts that join, tracking will break apart the
    // glyph unless we stretch them here. Stretch glyphs along their
    // baseline by the tracking factor.

    REAL tracking = 1.0;
    if (format)
    {
        tracking = format->GetTracking();
        if (tracking != 1.0f)
        {
            identity.Scale(tracking, 1.0);
        }
    }

    GpFaceRealization faceRealization(
        fontFace,
        style,
        &identity,
        SizeF(150.0, 150.0),    // Arbitrary - we won't be hinting
        TextRenderingHintSingleBitPerPixel, // claudebe, do we want to allow for hinted or unhinted path ? // graphics->GetTextRenderingHint(),
        TRUE, /* bPath */
        FALSE, /* bCompatibleWidth */
        textItem->Flags & ItemSideways
    );
    status = faceRealization.GetStatus();
    IF_NOT_OK_WARN_AND_RETURN(status);


    // Add glyphs to path

    // Establish factor from world coordinates to ideal (line services units)
    // taking vertical and right to left progress into account.

    REAL worldToIdealBaseline = WorldToIdeal;
    REAL worldToIdealAscender = WorldToIdeal;

    if (renderRtl)
    {
        // Glyphs advance to the left
        worldToIdealBaseline = -WorldToIdeal;
    }

    if (!renderVertical)
    {
        // Ascender offsets are downward
        worldToIdealAscender = -WorldToIdeal;
    }

    PointF glyphOrigin(
        ImagerOrigin.X + pointOrigin->x / WorldToIdeal,
        ImagerOrigin.Y + pointOrigin->y / WorldToIdeal
    );

    PointF origin = glyphOrigin;

    for (INT i = 0; i < (INT)glyphCount; ++i)
    {
        // Set marker at start of each logical character = cell = cluster

       if ((Path != NULL) && (((SCRIPT_VISATTR*)glyphProperties)[i].fClusterStart))
        {
            Path->SetMarker();
        }


        // Establish glyph offset, if any.

        PointF glyphOffset(0.0, 0.0);

        if (    glyphOffsets[i].X != 0
            ||  glyphOffsets[i].Y != 0)
        {
            // Apply combining character offset

            if (renderVertical)
            {
                glyphOffset.Y = glyphOffsets[i].X / worldToIdealBaseline;
                glyphOffset.X = glyphOffsets[i].Y / worldToIdealAscender;
            }
            else
            {
                // offset Y grows negative in the direction of paragraph flow

                glyphOffset.X = glyphOffsets[i].X / worldToIdealBaseline;
                glyphOffset.Y = glyphOffsets[i].Y / worldToIdealAscender;
            }
        }


        // Add the path for the glyph itself


        GpGlyphPath *glyphPath = NULL;
        PointF       sidewaysOrigin;

        status = faceRealization.GetGlyphPath(
            *(glyphs+i),
            &glyphPath,
            &sidewaysOrigin
        );
        IF_NOT_OK_WARN_AND_RETURN(status);

        if (renderRtl)
        {
            // Update reverse text path positon

            if (renderVertical)
            {
                //  glyph origin starts at the left edge
                glyphOrigin.Y += glyphAdvances[i] / worldToIdealBaseline;
            }
            else
            {
                //  glyph origin starts at the top edge
                glyphOrigin.X += glyphAdvances[i] / worldToIdealBaseline;
            }
        }

        if (textItem->Flags & ItemSideways)
        {
            fontTransform.VectorTransform(&sidewaysOrigin);
            glyphOffset = glyphOffset - sidewaysOrigin;
        }

        if (glyphPath != NULL)
        {
            status = path->AddGlyphPath(
                glyphPath,
                glyphOrigin.X + glyphOffset.X,
                glyphOrigin.Y + glyphOffset.Y,
                &fontTransform
            );
            IF_NOT_OK_WARN_AND_RETURN(status);
        }

        // Update forward path position

        if (!renderRtl)
        {
            // Update forward text path positon
            if (renderVertical)
            {
                glyphOrigin.Y += glyphAdvances[i] / worldToIdealBaseline;
            }
            else
            {
                glyphOrigin.X += glyphAdvances[i] / worldToIdealBaseline;
            }
        }
    }

    if (   GetFormatHotkeyPrefix() == HotkeyPrefixShow
        && HotkeyPrefix.GetCount() > 0)
    {
        status = DrawHotkeyUnderline(
            textItem,
            fontFace,
            &origin,
            emSize,
            stringOffset,
            stringLength,
            glyphCount,
            glyphMap,
            glyphAdvances,
            0
        );

        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    if (Path == NULL)
    {
        // !!! Need to loop through brushes individually

        status = Graphics->FillPath(BrushVector.GetDefault(), path);
        IF_NOT_OK_WARN_AND_RETURN(status);
    }
    else
    {
        // Force marker following last glyph
        Path->SetMarker();
    }
    return status;
}





/////   Hotkey underline
//
//      Draw underline at each hotkey position according to its
//      current brush within the run being displayed.
//
//      Underline is drawn for the whole cluster even when the hotkey
//      prefix is not exactly at the cluster start position.
//

GpStatus FullTextImager::DrawHotkeyUnderline(
    const GpTextItem        *textItem,          // [IN] text item
    const GpFontFace        *fontFace,          // [IN] font face
    const PointF            *origin,            // [IN] origin at leading edge & baseline (in world unit)
    REAL                    emSize,             // [IN] em size (in world unit)
    UINT                    stringOffset,       // [IN] string offset
    UINT                    stringLength,       // [IN] string length
    UINT                    glyphCount,         // [IN] glyph count
    const GMAP              *glyphMap,          // [IN] glyph map
    const INT               *glyphAdvances,     // [IN] glyph advance width (ideal unit)
    INT                     trailingAdjust      // [IN] adjust for last glyph's advance width
)
{
    const REAL fontToWorld = emSize / TOREAL(fontFace->GetDesignEmHeight());
    const REAL penPos   = fontFace->GetDesignUnderscorePosition() * fontToWorld; // negative down from the baseline
    REAL penWidth = fontFace->GetDesignUnderscoreSize() * fontToWorld;
    if (Graphics)
        penWidth = Graphics->GetDevicePenWidth(penWidth);

    GpStatus status = Ok;

    for (INT hk = 0; status == Ok && hk < HotkeyPrefix.GetCount(); hk++)
    {
        UINT hkOffset = HotkeyPrefix[hk] + 1;   // character next to the prefix

        if (   hkOffset >= stringOffset
            && hkOffset <  stringOffset + stringLength)
        {
            //  determine the length of hotkey underline

            UINT hkLength = hkOffset - stringOffset;
            UINT igl = glyphMap[hkLength];  // first glyph being underlined

            hkLength++;

            while (hkLength < stringLength && glyphMap[hkLength] == igl)
            {
                hkLength++;
            }

            UINT iglLimit = hkLength < stringLength ? glyphMap[hkLength] : glyphCount;


            INT start  = 0; // ideal offset to start of underline
            INT length = 0; // ideal length of underline

            for (UINT i = 0; i < igl; i++)
            {
                start += glyphAdvances[i];
            }

            for (UINT i = igl; i < iglLimit ; i++)
            {
                length += glyphAdvances[i];
            }

            if (iglLimit == glyphCount)
            {
                //  Adjust for run's trailing spaces

                length += trailingAdjust;
            }


            //  draw it!

            if (Graphics)
            {
                PointF lineStart;
                PointF lineEnd;


                //  Graphics rendering

                if (textItem->Flags & ItemVertical)
                {
                    if (textItem->Level & 1)
                    {
                        //  RTL run in vertical line

                        lineStart.X = origin->X + penPos;
                        lineStart.Y = origin->Y - (start + length) / WorldToIdeal;
                        lineEnd.X   = origin->X + penPos;
                        lineEnd.Y   = origin->Y - start / WorldToIdeal;
                    }
                    else
                    {
                        //  LTR run in vertical line

                        lineStart.X = origin->X + penPos;
                        lineStart.Y = origin->Y + start / WorldToIdeal;
                        lineEnd.X   = origin->X + penPos;
                        lineEnd.Y   = origin->Y + (start + length) / WorldToIdeal;
                    }
                }
                else
                {
                    if (textItem->Level & 1)
                    {
                        //  RTL run in horizontal line

                        lineStart.X = origin->X - (start + length) / WorldToIdeal;
                        lineStart.Y = origin->Y - penPos;
                        lineEnd.X   = origin->X - start / WorldToIdeal;
                        lineEnd.Y   = origin->Y - penPos;
                    }
                    else
                    {
                        //  LTR run in horizontal line

                        lineStart.X = origin->X + start / WorldToIdeal;
                        lineStart.Y = origin->Y - penPos;
                        lineEnd.X   = origin->X + (start + length) / WorldToIdeal;
                        lineEnd.Y   = origin->Y - penPos;
                    }
                }

                SpanRider<const GpBrush *> brushRider(&BrushVector);
                brushRider.SetPosition(hkOffset);

                status = Graphics->DrawLine(
                    &GpPen(brushRider.GetCurrentElement(), penWidth, UnitPixel),
                    lineStart.X,
                    lineStart.Y,
                    lineEnd.X,
                    lineEnd.Y
                );
            }
            else
            {
                //  Path rendering

                ASSERT(Path);

                RectF lineRect;

                if (textItem->Flags & ItemVertical)
                {
                    if (textItem->Level & 1)
                    {
                        //  RTL run in vertical line

                        lineRect.X      = origin->X + penPos - penWidth / 2;
                        lineRect.Y      = origin->Y - (start + length) / WorldToIdeal;
                        lineRect.Width  = penWidth;
                        lineRect.Height = length / WorldToIdeal;
                    }
                    else
                    {
                        //  LTR run in vertical line

                        lineRect.X      = origin->X + penPos - penWidth / 2;
                        lineRect.Y      = origin->Y + start / WorldToIdeal;
                        lineRect.Width  = penWidth;
                        lineRect.Height = length / WorldToIdeal;
                    }
                }
                else
                {
                    if (textItem->Level & 1)
                    {
                        //  RTL run in horizontal line

                        lineRect.X      = origin->X - (start + length) / WorldToIdeal;
                        lineRect.Y      = origin->Y - penPos - penWidth / 2;
                        lineRect.Width  = length / WorldToIdeal;
                        lineRect.Height = penWidth;
                    }
                    else
                    {
                        //  LTR run in horizontal line

                        lineRect.X      = origin->X + start / WorldToIdeal;
                        lineRect.Y      = origin->Y - penPos - penWidth / 2;
                        lineRect.Width  = length / WorldToIdeal;
                        lineRect.Height = penWidth;
                    }
                }

                status = Path->AddRect(
                    RectF(
                        lineRect.X,
                        lineRect.Y,
                        lineRect.Width,
                        lineRect.Height
                    )
                );
            }
        }
    }
    return status;
}





GpStatus FullTextImager::Draw(
    GpGraphics   *graphics,
    const PointF *origin
)
{
    GpStatus status;

    status = BuildLines();

    if (status != Ok)
    {
        return status;
    }

    Graphics = graphics;

    memcpy(&ImagerOrigin, origin, sizeof(ImagerOrigin));

    GpRegion *previousClip  = NULL;

    BOOL applyClip =
            !(GetFormatFlags() & StringFormatFlagsNoClip)
        &&  Width
        &&  Height;

    if (applyClip)
    {
        //  Preserve existing clipping and combine it with the new one if any
        if (!graphics->IsClipEmpty())
        {
            previousClip = graphics->GetClip();
        }

        RectF clippingRect(origin->X, origin->Y, Width, Height);
        graphics->SetClip(clippingRect, CombineModeIntersect);
    }

    status = Render();

    if (applyClip)
    {
        //  Restore clipping state if any
        if (previousClip)
        {
            graphics->SetClip(previousClip, CombineModeReplace);
            delete previousClip;
        }
        else
        {
            graphics->ResetClip();
        }
    }

    if (status != Ok)
    {
        return status;
    }

    Graphics = NULL;
    memset(&ImagerOrigin, 0, sizeof(ImagerOrigin));

    return Ok;
}




GpStatus FullTextImager::AddToPath(
    GpPath       *path,
    const PointF *origin
)
{
    GpStatus status;

    status = BuildLines();

    if (status != Ok)
    {
        return status;
    }

    Path = path;
    memcpy(&ImagerOrigin, origin, sizeof(ImagerOrigin));

    status = Render();

    if (status != Ok)
    {
        return status;
    }

    Path = NULL;
    memset(&ImagerOrigin, 0, sizeof(ImagerOrigin));

    return Ok;
}






GpStatus FullTextImager::Measure(
    GpGraphics *graphics,
    REAL       *nearGlyphEdge,
    REAL       *farGlyphEdge,
    REAL       *textDepth,
    INT        *codepointsFitted,
    INT        *linesFilled
)
{
    GpStatus status;

    status = BuildLines();

    if (status != Ok)
    {
        return status;
    }


    *nearGlyphEdge = LeftOrTopLineEdge     / WorldToIdeal;
    *farGlyphEdge  = RightOrBottomLineEdge / WorldToIdeal;

    *textDepth = TextDepth;

    if (codepointsFitted) *codepointsFitted = CodepointsFitted;
    if (linesFilled)      *linesFilled      = LinesFilled;

    return Ok;
}


GpStatus FullTextImager::MeasureRangeRegion(
    INT           firstCharacterIndex,
    INT           characterCount,
    const PointF *origin,
    GpRegion     *region
)
{
    if (!region || !region->IsValid())
    {
        return InvalidParameter;
    }

    region->SetEmpty();


    if (!characterCount)
    {
        //  return empty region
        return Ok;
    }
    else if (characterCount < 0)
    {
        firstCharacterIndex += characterCount;
        characterCount = -characterCount;
    }

    if (   firstCharacterIndex < 0
        || firstCharacterIndex > Length
        || firstCharacterIndex + characterCount > Length)
    {
        return InvalidParameter;
    }


    if (LinesFilled <= 0)
    {
        return Ok;
    }


    GpMemcpy(&ImagerOrigin, origin, sizeof(PointF));


    INT lastCharacterIndex  = firstCharacterIndex + characterCount - 1;
    INT lineFirstIndex      = 0; // line start char index
    INT linePointOffset     = 0; // line start position

    ASSERT (   firstCharacterIndex >= 0
            && firstCharacterIndex <= lastCharacterIndex);


    GpStatus status = Ok;
    

    for (INT i = 0; i < LinesFilled; i++)
    {
        const BuiltLine *line = BuiltLineVector[i].Element;
        INT lineLastIndex = lineFirstIndex + BuiltLineVector[i].Length - 1;


        if (lineLastIndex >= firstCharacterIndex)
        {
            if (lineFirstIndex > lastCharacterIndex)
            {
                //  We're done.
                break;
            }
            
            INT nominalBaseline;
            INT baselineAdjustment; // adjustment to nominal baseline
    
            line->GetBaselineOffset(
                &nominalBaseline,
                &baselineAdjustment
            );

            //  The line is either at the first, the last or the middle of
            //  the selection.

            INT selectionFirstIndex = max(firstCharacterIndex, lineFirstIndex);
            INT selectionLastIndex  = min(lastCharacterIndex, lineLastIndex);

            status = line->GetSelectionTrailRegion(
                linePointOffset + baselineAdjustment,
                selectionFirstIndex - lineFirstIndex,
                selectionLastIndex - selectionFirstIndex + 1,
                region
            );

            if (status != Ok)
            {
                return GenericError;
            }
        }

        //  Advance to the next line

        lineFirstIndex  += BuiltLineVector[i].Length;
        linePointOffset += line->GetLineSpacing();
    }

    return status;
}




GpStatus FullTextImager::MeasureRanges (
    GpGraphics      *graphics,
    const PointF    *origin,
    GpRegion        **regions
)
{
    if (!FormatVector.GetDefault())
    {
        return InvalidParameter;
    }

    GpStatus status = BuildLines();

    if (status != Ok)
    {
        return status;
    }

    Graphics = graphics;

    if (   Graphics
        && !GetMetaFileRecordingFlag())
    {
        //  If the range is being measured against real device, not metafile,
        //  we need to take the baseline adjustment into account. On the other
        //  hand if this is done for a metafile, it needs to be in nominal distance
        //  both height and width (nominal width is done in lower level)
        
        status = CalculateDefaultFontGridFitBaselineAdjustment();
        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    const GpStringFormat *format = FormatVector.GetDefault();

    CharacterRange *ranges;
    INT rangeCount = format->GetMeasurableCharacterRanges(&ranges);


    RectF clipRect(origin->X, origin->Y, Width, Height);
    BOOL clipped = !(format->GetFormatFlags() & StringFormatFlagsNoClip);


    for (INT i = 0; i < rangeCount; i++)
    {
        GpLock lockRegion(regions[i]->GetObjectLock());

        if (!lockRegion.IsValid())
        {
            return ObjectBusy;
        }

        status = MeasureRangeRegion (
            ranges[i].First,
            ranges[i].Length,
            origin,
            regions[i]
        );

        if (status != Ok)
        {
            return status;
        }

        if (clipped)
        {
            // we have a clipping so we need to make sure we didn't get out
            // of the layout box

            regions[i]->Combine(&clipRect, CombineModeIntersect);
        }
    }
    return status;
}




INT FullTextImager::GetAvailableRanges(const GpStringFormat *format)
{
    if (!format)
    {
        format = FormatVector.GetDefault();

        if (!format)
        {
            return 0;
        }
    }

    if (   !InvalidRanges
        && !RangeVector.GetSpanCount()
        && (   GetMetaFileRecordingFlag()
            || format->GetFormatFlags() & StringFormatFlagsPrivateFormatPersisted))
    {

        //  Construct range vector from string format either during
        //  recording for downlevel playback or during playback of
        //  DrawString EMF+ record. Otherwise, dont process ranges at
        //  all (even if it exists in string format).


        CharacterRange *ranges = NULL;
        INT rangeCount = format->GetMeasurableCharacterRanges(&ranges);

        for (INT i = 0; i < rangeCount; i++)
        {
            INT first   = ranges[i].First;
            INT length  = ranges[i].Length;

            if (length < 0)
            {
                first += length;
                length = -length;
            }

            if (   first < 0
                || first > Length
                || first + length > Length)
            {
                //  Invalid range being set by client,
                //  ignore all ranges being collected so far

                RangeVector.Reset();
                break;
            }

            RangeVector.OrSpan(
                first,
                length,
                (UINT32)(1 << i)
            );
        }

        #if DBG_RANGEDUMP
        RangeVector.Dump();
        #endif

        if (!RangeVector.GetSpanCount())
        {
            //  No valid range being collected or invalid range found,
            //  dont bother process any of them any more.

            InvalidRanges = TRUE;
        }
    }
    return RangeVector.GetSpanCount();
}




GpStatus FullTextImager::GetTabStops (
    INT     stringOffset,
    INT     *countTabStops,
    LSTBD   **tabStops,
    INT     *incrementalTab
)
{
    SpanRider<const GpStringFormat *>   formatRider(&FormatVector);
    formatRider.SetPosition(stringOffset);

    const GpStringFormat *format = formatRider.GetCurrentElement();

    *incrementalTab = DefaultIncrementalTab;    // incremental tab as imager's default
    *tabStops       = NULL;
    *countTabStops  = 0;


    if (format)
    {
        REAL    firstTabOffset;
        REAL    *tabAdvance;

        INT     count = format->GetTabStops(
                            &firstTabOffset,
                            &tabAdvance
                        );

        if (tabAdvance && count > 0)
        {
            REAL    advance = firstTabOffset;
            LSTBD   tbd;

            GpMemset (&tbd, 0, sizeof(LSTBD));
            tbd.lskt = lsktLeft;

            TabArray.Reset();

            for (INT i = 0; i < count; i++)
            {
                advance += tabAdvance[i];
                tbd.ua = GpRoundSat(advance * WorldToIdeal);

                TabArray.Add (tbd);
            }

            *tabStops       = TabArray.GetDataBuffer();
            *countTabStops  = i;

            // no incremental tab as the last user tabstop
            *incrementalTab = GpRound(tabAdvance[count - 1] * WorldToIdeal);
        }
        else
        {
            // incremental tab as user-defined first tab offset
            *incrementalTab = GpRound(firstTabOffset * WorldToIdeal);
        }
    }
    return Ok;
}





/////   Thai Breaking function
//
//      Because of the lack of dictionary resource required to perform
//      Thai word breaking in static lib, we need to ask Uniscribe to
//      perform the task instead.
//
//      The global pointer holding the breaking function can be changed
//      once for process lifetime. It needs not to be serialized as all
//      text call is protected by the global text critical section.
//      !! Revisit this code if assumption changes !!
//
//      wchao (11-09-2000)



extern "C"
{

typedef HRESULT (WINAPI FN_SCRIPTBREAK) (
    const WCHAR             *string,    // [IN] input string
    INT                     length,     // [IN] string length
    const SCRIPT_ANALYSIS   *analysis,  // [IN] Uniscribe script analysis
    SCRIPT_LOGATTR          *breaks     // [OUT] break result buffer size of string length
);


typedef HRESULT (WINAPI FN_SCRIPTITEMIZE) (
    const WCHAR             *string,        // [IN] input string
    INT                     length,         // [IN] string length
    INT                     maxItems,       // [IN] maximum possible items
    const SCRIPT_CONTROL    *scriptControl, // [IN] control structure
    const SCRIPT_STATE      *scriptState,   // [IN] starting state
    SCRIPT_ITEM             *items,         // [OUT] items
    INT                     *itemCount      // [OUT] number of item produced
);



FN_SCRIPTBREAK  *GdipThaiBreakingFunction = GdipThaiBreakingFunctionInitializer;
FN_SCRIPTBREAK  *GdipScriptBreak  = NULL;   // Uniscribe ScriptBreak API
INT             ScriptThaiUsp = 0;          // Uniscribe has a different script ID for Thai



#define MAX_MSO_PATH    256     // make sure it's sufficient

const WCHAR UspDllName[] = L"usp10.dll";
const CHAR UspDllNameA[] =  "usp10.dll";

#if DBG
//#define DBG_DLL 1
#ifdef DBG_DLL
const WCHAR MsoDllName[] = L"c:\\program files\\common files\\microsoft shared debug\\office10\\msod.dll";
const CHAR MsoDllNameA[] =  "c:\\program files\\common files\\microsoft shared debug\\office10\\msod.dll";
#else
const WCHAR MsoDllName[] = L"msod.dll";
const CHAR MsoDllNameA[] =  "msod.dll";
#endif
#else
const WCHAR MsoDllName[] = L"mso.dll";
const CHAR MsoDllNameA[] =  "mso.dll";
#endif



HRESULT WINAPI GdipThaiBreakingFunctionInGdiplus(
    const WCHAR             *string,    // [IN] input string
    INT                     length,     // [IN] string length
    const SCRIPT_ANALYSIS   *analysis,  // [IN] Uniscribe script analysis
    SCRIPT_LOGATTR          *breaks     // [OUT] break result buffer size of string length
)
{
    ASSERT (analysis->eScript == ScriptThai);

    return ThaiBreak(
        string,
        length,
        analysis,
        breaks
    );
}


HRESULT WINAPI GdipThaiBreakingFunctionInUniscribe(
    const WCHAR             *string,    // [IN] input string
    INT                     length,     // [IN] string length
    const SCRIPT_ANALYSIS   *analysis,  // [IN] Uniscribe script analysis
    SCRIPT_LOGATTR          *breaks     // [OUT] break result buffer size of string length
)
{
    ASSERT(ScriptThaiUsp != 0);

    ScriptAnalysis uspAnalysis(&GpTextItem((ItemScript)ScriptThaiUsp, 0), 0, 0);

    return GdipScriptBreak(
        string,
        length,
        &uspAnalysis.Sa,
        breaks
    );
}



HRESULT WINAPI GdipThaiBreakingFunctionInitializer(
    const WCHAR             *string,    // [IN] input string
    INT                     length,     // [IN] string length
    const SCRIPT_ANALYSIS   *analysis,  // [IN] Uniscribe script analysis
    SCRIPT_LOGATTR          *breaks     // [OUT] break result buffer size of string length
)
{
    HRSRC mainResource = FindResourceA((HMODULE)DllInstance, "SIAMMAIN", "SIAMDB");

    if (mainResource)
    {
        //  Main dictionary resource available,
        //  we're capable of doing it ourself.

        GdipThaiBreakingFunction = GdipThaiBreakingFunctionInGdiplus;
    }
    else
    {
        //  No resource available, search for Uniscribe in the process.
        //  Load it up if necessary.

        GdipThaiBreakingFunction = SimpleBreak;     // assume default

        HMODULE moduleUsp = NULL;

        if (Globals::IsNt)
        {

            moduleUsp = LoadLibrary(UspDllName);

            if (!moduleUsp)
            {
                //  Fail to load the system version of Uniscribe,
                //  try loading the private version from MSO directory.

#ifdef DBG_DLL
                HMODULE moduleMso = LoadLibrary(MsoDllName);
#else
                HMODULE moduleMso = GetModuleHandle(MsoDllName);
#endif

                if (moduleMso)
                {
                    AutoArray<WCHAR> pathString(new WCHAR [MAX_MSO_PATH]);

                    if (pathString)
                    {
                        WCHAR *fullPathString = pathString.Get();

                        UINT pathLength = GetModuleFileName(
                            moduleMso,
                            fullPathString,
                            MAX_MSO_PATH
                        );

                        if (pathLength)
                        {
                            while (pathLength > 0 && fullPathString[pathLength - 1] != '\\')
                            {
                                pathLength--;
                            }

                            INT uspDllNameLength = 0;

                            while (UspDllName[uspDllNameLength])
                            {
                                uspDllNameLength++;
                            }

                            if (pathLength + uspDllNameLength < MAX_MSO_PATH)
                            {
                                GpMemcpy(
                                    &fullPathString[pathLength],
                                    UspDllName,
                                    sizeof(WCHAR) * uspDllNameLength
                                );

                                fullPathString[pathLength + uspDllNameLength] = 0;

                                moduleUsp = LoadLibrary(fullPathString);
                            }
                        }
                    }
#ifdef DBG_DLL
                    FreeLibrary(moduleMso);
#endif
                }
            }
        }
        else
        {
            HMODULE moduleUsp = LoadLibraryA(UspDllNameA);

            if (!moduleUsp)
            {
                //  Fail to load the system version of Uniscribe,
                //  try loading the private version from MSO directory.

#ifdef DBG_DLL
                HMODULE moduleMso = LoadLibraryA(MsoDllNameA);
#else
                HMODULE moduleMso = GetModuleHandleA(MsoDllNameA);
#endif
                if (moduleMso)
                {
                    AutoArray<CHAR> pathString(new CHAR [MAX_MSO_PATH]);

                    if (pathString)
                    {
                        CHAR *fullPathString = pathString.Get();

                        UINT pathLength = GetModuleFileNameA(
                            moduleMso,
                            fullPathString,
                            MAX_MSO_PATH
                        );

                        if (pathLength)
                        {
                            while (pathLength > 0 && fullPathString[pathLength - 1] != '\\')
                            {
                                pathLength--;
                            }

                            INT uspDllNameLength = 0;

                            while (UspDllNameA[uspDllNameLength])
                            {
                                uspDllNameLength++;
                            }

                            if (pathLength + uspDllNameLength < MAX_MSO_PATH)
                            {
                                GpMemcpy(
                                    &fullPathString[pathLength],
                                    UspDllNameA,
                                    sizeof(CHAR) * uspDllNameLength
                                );

                                fullPathString[pathLength + uspDllNameLength] = 0;

                                moduleUsp = LoadLibraryA(fullPathString);
                            }
                        }
                    }
#ifdef DBG_DLL
                    FreeLibrary(moduleMso);
#endif
                }
            }
        }
        if (moduleUsp)
        {
            //  Locate Uniscribe ScriptBreak API

            GdipScriptBreak = (FN_SCRIPTBREAK *)GetProcAddress(
                moduleUsp,
                "ScriptBreak"
            );

            FN_SCRIPTITEMIZE *scriptItemize = (FN_SCRIPTITEMIZE *)GetProcAddress(
                moduleUsp,
                "ScriptItemize"
            );

            HRESULT hr = E_FAIL;

            if (   scriptItemize
                && GdipScriptBreak)
            {
                //  Figure out the proper Thai script ID to be used

                SCRIPT_ITEM items[2];
                INT itemCount = 0;

                hr = scriptItemize(
                    L"\x0e01",  // first Thai consonant
                    1,          // string length
                    2,          // string length + sentinel
                    NULL,       // script control
                    NULL,       // script state
                    items,
                    &itemCount
                );

                if (SUCCEEDED(hr))
                {
                    ScriptThaiUsp = items[0].a.eScript;

                    GdipThaiBreakingFunction = GdipThaiBreakingFunctionInUniscribe;
                    Globals::UniscribeDllModule = moduleUsp;    // remember to release
                }
            }

            if (FAILED(hr))
            {
                //  Uniscribe is corrupted! Very unlikely

                ASSERT(FALSE);
                FreeLibrary(moduleUsp); // release it here
            }
        }
    }

    ASSERT(GdipThaiBreakingFunction != GdipThaiBreakingFunctionInitializer);

    return GdipThaiBreakingFunction(
        string,
        length,
        analysis,
        breaks
    );
}

}   // extern "C"




////    Get character properties for complex script run
//
//      Analyze the content and determine if the character at given position starts
//      a character context either a word or cluster. Cache the result in span for
//      better performance.
//
//      Assuming maximum 12 characters for a word,
//      we're giving the algorithm at least 5 preceding and 5 succeeding surrounding words.
//

#define APPROX_MAX_WORDSIZE         12
#define APPROX_MAX_PRECEDING        60
#define APPROX_MAX_SUCCEEDING       60

#define IsDelimiter(c)              (BOOL)(c == 0x20 || c == 13 || c == 10)

GpStatus FullTextImager::GetCharacterProperties (
    ItemScript  script,             // [IN] Script id
    LSCP        position,           // [IN] Line Services character position
    BOOL        *isWordStart,       // [OUT] Is it a start of word?
    BOOL        *isWordLast,        // [OUT] Is it the word's last character?
    BOOL        *isClusterStart     // [OUT] (optional) Is it at a cluster boundary?
)
{
    if (!isWordStart || !isWordLast)
    {
        return InvalidParameter;
    }


    *isWordLast = *isWordStart = FALSE;

    GpStatus status = Ok;

    SpanRider<PLSRUN> runRider(&RunVector);
    runRider.SetPosition(position);

    ASSERT (runRider.GetCurrentElement()->RunType == lsrun::RunText);


    //  Map Line Services position to actual string position

    INT stringPosition =   position
                         - runRider.GetCurrentSpanStart()
                         + runRider.GetCurrentElement()->ImagerStringOffset;



    //  Check if we already cached the result

    SpanRider<Break*> breakRider(&BreakVector);
    breakRider.SetPosition(stringPosition);

    if (breakRider.GetCurrentElement())
    {
        //  Found it!

        *isWordStart = breakRider.GetCurrentElement()->IsWordBreak(
                            stringPosition - breakRider.GetCurrentSpanStart()
                       );

        if (   !*isWordStart
            && stringPosition < Length - 1
            && CharacterAttributes[CharClassFromCh(String[stringPosition + 1])].Script == script)
        {
            UINT32 stringOffset = stringPosition + 1 - breakRider.GetCurrentSpanStart();

            *isWordLast =    stringOffset >= breakRider.GetUniformLength()
                          || breakRider.GetCurrentElement()->IsWordBreak(stringOffset);
        }

        if (isClusterStart)
        {
            *isClusterStart = breakRider.GetCurrentElement()->IsClusterBreak(
                                    stringPosition - breakRider.GetCurrentSpanStart()
                              );
        }
        return Ok;
    }


    //  Collect enough surrounding text to resolve context boundary

    INT  startPosition  = stringPosition;
    INT  limit          = max (breakRider.GetCurrentSpanStart(),
                               (UINT)(max(0, stringPosition - APPROX_MAX_PRECEDING - 1)));


    //  Skip all the preceding delimiters
    //  (we should never start at a delimiter, however a little protection does not kill.)
    while (   startPosition > limit
           && IsDelimiter(String[startPosition - 1]))
    {
        startPosition--;
    }

    //  Span backward until reaching a delimiter or script boundary
    while (   startPosition > limit
           && !IsDelimiter(String[startPosition - 1])
           && CharacterAttributes[CharClassFromCh(String[startPosition - 1])].Script == script)
    {
        startPosition--;
    }

    //  See if the start position ends at delimiter or script boundary.
    BOOL stableStart = (   startPosition > limit
                        || limit == (INT)breakRider.GetCurrentSpanStart());


    INT endPosition = stringPosition;
    limit = min (Length, endPosition + APPROX_MAX_SUCCEEDING);

    if ((INT)breakRider.GetCurrentSpan().Length > 0)
    {
        limit = min ((UINT)limit, breakRider.GetCurrentSpanStart() + breakRider.GetCurrentSpan().Length);
    }

    //  Skip all succeeding delimiters
    while (   endPosition < limit
           && IsDelimiter(String[endPosition]))
    {
        endPosition++;
    }

    //  Span foreward until reaching a delimiter or script boundary
    while (   endPosition < limit
           && !IsDelimiter(String[endPosition])
           && CharacterAttributes[CharClassFromCh(String[endPosition])].Script == script)
    {
        endPosition++;
    }

    //  See if the end position ends at delimiter or script boundary.
    BOOL stableEnd = (   endPosition < limit
                      || limit == Length
                      || breakRider.GetUniformLength() < APPROX_MAX_SUCCEEDING);



    //  At least we should have a span of 1 character which is the one we start with
    ASSERT(endPosition > startPosition);


    AutoArray<SCRIPT_LOGATTR> breaks(new SCRIPT_LOGATTR [endPosition - startPosition]);

    if (!breaks)
    {
        return OutOfMemory;
    }


    HRESULT hr = S_OK;

    ScriptAnalysis analysis(&GpTextItem(script, 0), 0, 0);

    switch (script)
    {
        case ScriptThai:

            //  call Thai word break engine

            hr = GdipThaiBreakingFunction(
                &String[startPosition],
                endPosition - startPosition,
                &analysis.Sa,
                breaks.Get()
            );
            break;

        default:

            hr = SimpleBreak(
                &String[startPosition],
                endPosition - startPosition,
                &analysis.Sa,
                breaks.Get()
            );
    }


    if (FAILED(hr))
    {
        TERSE(("breaking function fails - HRESULT: %x\n", hr));
        return hr == E_OUTOFMEMORY ? OutOfMemory : Win32Error;
    }


    //  Cache a stable range of breaking result

    INT  kill;
    INT  newPosition;

    if (!stableEnd)
    {
        //  Stabilize the end by eliminating the last 2 words

        kill = 3;
        newPosition = endPosition - 1;

        while (newPosition > startPosition)
        {
            if (breaks[newPosition - startPosition].fWordStop)
            {
                if (!--kill)
                {
                    break;
                }
            }
            newPosition--;
        }

        if (newPosition > startPosition)
        {
            endPosition = newPosition;
        }
    }

    newPosition = startPosition;

    if (!stableStart)
    {
        //  Stabilize the beginning by eliminating the first 2 words

        kill = 3;

        while (newPosition < endPosition)
        {
            if (breaks[newPosition - startPosition].fWordStop)
            {
                if (!--kill)
                {
                    break;
                }
            }
            newPosition++;
        }
    }

    if (endPosition > newPosition)
    {
        //  Got the stable range, cache it in vector

        Break *breakRecord = new Break(
            &breaks[newPosition - startPosition],
            endPosition - newPosition
        );

        if (!breakRecord)
        {
            return OutOfMemory;
        }

        #if DBG
        //  Check overlapped range
        breakRider.SetPosition(newPosition);
        ASSERT (!breakRider.GetCurrentElement());
        breakRider.SetPosition(endPosition - 1);
        ASSERT (!breakRider.GetCurrentElement());
        #endif

        status = breakRider.SetSpan(
            newPosition,
            endPosition - newPosition,
            breakRecord
        );

        if (status != Ok)
        {
            delete breakRecord;
            return status;
        }
    }

    //  Reposition break pointer
    breakRider.SetPosition(stringPosition);

    if (breakRider.GetCurrentElement())
    {
        *isWordStart = breakRider.GetCurrentElement()->IsWordBreak(
                            stringPosition - breakRider.GetCurrentSpanStart()
                       );

        if (   !*isWordStart
            && stringPosition < Length - 1
            && CharacterAttributes[CharClassFromCh(String[stringPosition + 1])].Script == script)
        {
            UINT32 stringOffset = stringPosition + 1 - breakRider.GetCurrentSpanStart();

            *isWordLast =    stringOffset >= breakRider.GetUniformLength()
                          || breakRider.GetCurrentElement()->IsWordBreak(stringOffset);
        }

        if (isClusterStart)
        {
            *isClusterStart = breakRider.GetCurrentElement()->IsClusterBreak(
                                    stringPosition - breakRider.GetCurrentSpanStart()
                              );
        }
    }

    return status;
}




/////   Constructing ellipsis
//

EllipsisInfo::EllipsisInfo(
    const GpFontFace    *fontFace,
    REAL                emSize,
    INT                 style,
    double              designToIdeal,
    INT                 formatFlags
) :
    Face                (fontFace),
    EmSize              (emSize),
    Item                (0),
    FormatFlags         (formatFlags)
{
    const IntMap<UINT16> *cmap = &fontFace->GetCmap();


    //  First try horizontal ellipsis

    String[0]   = 0x2026;
    Glyphs[0]   = cmap->Lookup(String[0]);
    GlyphCount  = 1;

    UINT16 firstGlyph = Glyphs[0];

    if (firstGlyph != fontFace->GetMissingGlyph())
    {
        if (formatFlags & StringFormatFlagsDirectionVertical)
        {
            Item.Flags |= ItemVertical;

            //  see if 'vert' feature is presented and supplies a
            //  vertical form alternative for the ellipsis.

            SubstituteVerticalGlyphs(
                &firstGlyph,
                1,
                fontFace->GetVerticalSubstitutionCount(),
                fontFace->GetVerticalSubstitutionOriginals(),
                fontFace->GetVerticalSubstitutionSubstitutions()
            );

            if (firstGlyph != Glyphs[0])
            {
                //  Glyph has changed by 'vert' feature,
                //  we now know it's a sideway's.

                Glyphs[0] = firstGlyph;
                Item.Flags |= ItemSideways;
            }
            else
            {
                //  The glyph's vertical form is not presented (either 'vert'
                //  feature is not there or not supported), we cannot use
                //  this codepoint, fallback to three dots.

                firstGlyph = fontFace->GetMissingGlyph();
            }
        }
    }

    if (firstGlyph == fontFace->GetMissingGlyph())
    {
        //  If not available, try three dots (...)

        for (INT i = 0; i < MAX_ELLIPSIS; i++)
        {
            String[i] = '.';
            Glyphs[i] = cmap->Lookup(String[i]);
        }
        GlyphCount = i;
    }


    Item.Script = ScriptLatin;  // assume simple script

    if (formatFlags & StringFormatFlagsDirectionVertical)
    {
        Item.Flags |= ItemVertical;
    }
    else
    {
        if (formatFlags & StringFormatFlagsDirectionRightToLeft)
        {
            Item.Level = 1;
        }
    }

    SCRIPT_VISATTR glyphProperties = { SCRIPT_JUSTIFY_CHARACTER, 1, 0, 0, 0, 0 };

    Width = 0;

    fontFace->GetGlyphDesignAdvancesIdeal(
        Glyphs,
        GlyphCount,
        style,
        FALSE, // !!! vertical
        TOREAL(designToIdeal),
        1.0,
        GlyphAdvances
    );

    for (INT i = 0; i < GlyphCount; i++)
    {
        GlyphMap[i]         = (UINT16)i;

        GlyphProperties[i]  = ((UINT16 *)&glyphProperties)[0];
        GlyphOffsets[i].X   = 0;
        GlyphOffsets[i].Y   = 0;

        Width               += GlyphAdvances[i];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\glyphplacement.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   glyphPlacement.cpp
*
* Abstract:
*
*   Implements glyph measurement and justification for graphicsText
*
* Created:
*
*   17th April 2000 dbrown
*
\**************************************************************************/


#include "precomp.hpp"


/////   Coordinate systems
//
//      The following coordinate systems are used:
//
//      World coordinates (REAL) - the coordinate system used by client
//      applications and passed to most Graphics APIs (for example
//      DrawLine). Text is always purely vertical or purely horizontal in
//      world coordinates. Fonts constructed with emSize specified in
//      alternate units are first converted to world units by calling
//      GetScaleForAlternatePageUnit.
//
//      Device coordinates (REAL) - Coordinates used on the device surface.
//      World coordinates are transformed to device coordinates using the
//      Graphics.Context.WorldToDevice.Transform function. REAL device
//      coordinates may have non-integral values when addressing sub-pixels.
//
//      Font nominal coordinates (INT) - (aka deign units) coordinates used to
//      define a scalable font independant of scaled size.
//      GpFontFace.GetDesignEmHeight is the emSize of a font in nominal units.
//      Nominal coordinates are always a pure scale factor of world units with
//      no shear. For horizontal text there there is no rotation between
//      nominal and world coordinates. For vertical text, most non Far East
//      script characters are rotated by 90 degrees.
//
//      Ideal coordinates (INT) - world coordinates mapped to integers by
//      a pure scale factor for use in Line Services, OpenType services and
//      Uniscribe shaping engine interfaces. The scale factor is usually
//      2048 divided by the emSize of the default font in a text imager.


/////   Transforms
//
//      WorldToDevice - stored in a Graphics. May include scaling,
//      shearing and/or translation.
//
//      WorldToIdeal - stored in a text imager while the imager is attached
//      to a Graphics. A pure scale factor, usually 2048 divided by the emSize
//      of the imager default font.
//
//      FontTransform - stored in a FaceRealization. Maps font nominal units
//      to device coordinates, May include scaling, shearing and rotation, but
//      not translation.


/////   Common buffer parameters
//
//      glyphAdvance - per-glyph advance widths stored in ideal units measured
//      along the text baseline.
//
//      glyphOffset - combining character offsets stored in ideal units
//      measured along and perpendicular to the baseline. The glyphOffset
//      buffer is required by Line Services, OpenType services and the
//      complex script shaping engines, but may somethimes be bypassed for
//      simple scripts.
//
//      glyphOrigins - per glyph device coordinates of the glyph origin (the
//      initial point on the baseline of the glyhps advance vector).
//      Represented as PointF. Non integer values represent sub pixel
//      positions.


/////   Glyph positioning functions
//
//
//      DrawPlacedGlyphs - Builds glyphPos array and passes it to the device driver.
//          ALL text device output output eventually comes through here.
//
//      GetDeviceGlyphOriginsNominal
//          Used when there's no hinting to be accounted for.
//          Places glyph on device using nominal metrics passed in glyphAdvances
//          and glyphOffsets.
//
//      GetDeviceGlyphOriginsAdjusted
//          Used to adjust for the difference between nominal and hinted metrics
//          Generates glyph origins in device units, and adjusts the width of spaces
//          to achieve the totalRequiredIdealAdvance parameter.
//          !!! Need to add support for kashida and inter-glyph justification.
//
//      GetRealizedGlyphPlacement
//          Used to obtain hinted advance metrics along the baseline.
//          !!! Needs to be updated to call complex script shaping engines.
//
//      GetFontTransformForAlternateResolution
//          Used during XMF playback.
//          Generates a font transform to match a font that was recorded at
//          a different resolution.
//
//      MeasureGlyphsAtAlternateResolution
//          Used during XMF playback.
//          Measures glyphs passed to DrawDriverString as if they were to be rendered
//          at the original XMF recording resolution.






/////   GlyphPlacementToGlyphOrigins
//
//      Convert glyph placement in ideal units to glyph origins in device
//      units.
//
//      Note: Bidi shaping engines produces glyph positioning info
//      in the way that it'll be drawn visually. The penpoint of the
//      mark is relative to the glyph on its left, not the glyph of
//      its base consonant.

GpStatus GlyphImager::GlyphPlacementToGlyphOrigins(
    const PointF   *origin,         // In  - cell origin in world units
    GpGraphics     *graphics,
    PointF         *glyphOrigins    // Out - device units
)
{
    ASSERT(Glyphs  &&  GlyphCount);

    const INT   *glyphAdvances;
    const Point *glyphOffsets;


    if (Adjusted)
    {
        glyphAdvances = AdjustedAdvances.Get();
        glyphOffsets  = AdjustedOffsets.Get();
    }
    else
    {
        glyphAdvances = NominalAdvances;
        glyphOffsets  = NominalOffsets;
    }


    // Implement advance vector

    REAL x = origin->X;
    REAL y = origin->Y;


    if (TextItem->Flags & ItemVertical)
    {
        if (TextItem->Level & 1)
        {
            // Vertical, characters progress bottom to top
            for (INT i = 0; i < GlyphCount; i++)
            {
                glyphOrigins[i].X = x;
                glyphOrigins[i].Y = y;
                y -= TOREAL(glyphAdvances[i] / WorldToIdeal);
            }
        }
        else
        {
            // Vertical, characters progress top to bottom
            for (INT i = 0; i < GlyphCount; i++)
            {
                glyphOrigins[i].X = x;
                glyphOrigins[i].Y = y;
                y += TOREAL(glyphAdvances[i] / WorldToIdeal);
            }
        }
    }
    else if (TextItem->Level & 1)
    {
        for (INT i = 0; i < GlyphCount; i++)
        {
            glyphOrigins[i].X = x;
            glyphOrigins[i].Y = y;
            x -= TOREAL(glyphAdvances[i] / WorldToIdeal);
        }
    }
    else
    {
        for (INT i = 0; i < GlyphCount; i++)
        {
            glyphOrigins[i].X = x;
            glyphOrigins[i].Y = y;
            x += TOREAL(glyphAdvances[i] / WorldToIdeal);
        }
    }


    // Handle RTL glyphs
    //
    // In RTL rendering, the origin calculated so far is the right edge of the
    // baseline - we need to subtract the hinted glyph width so that we pass the
    // renderer the left end.

    GpStatus status = Ok;

    if (   (TextItem->Level & 1)
        && !(TextItem->Flags & ItemMirror))
    {
        // Compensate glyph origin for glyph lying on it's side or rendered RTL

        AutoBuffer<INT,32> idealAdvances(GlyphCount);
        if (!idealAdvances)
        {
            return OutOfMemory;
        }

        status = FaceRealization->GetGlyphStringIdealAdvanceVector(
            Glyphs,
            GlyphCount,
            DeviceToIdealBaseline,
            FALSE,
            idealAdvances.Get()
        );
        IF_NOT_OK_WARN_AND_RETURN(status);

        // Adjust origins from right end to left end of hinted baseline
        // (Marks are already calculated to the left end)

        const SCRIPT_VISATTR *properties = (const SCRIPT_VISATTR*) GlyphProperties;

        for (INT i=0; i<GlyphCount; i++)
        {
            if (!properties[i].fDiacritic)
            {
                if (TextItem->Flags & ItemVertical)
                {
                    glyphOrigins[i].Y -= TOREAL(idealAdvances[i] / WorldToIdeal);
                }
                else
                {
                    glyphOrigins[i].X -= TOREAL(idealAdvances[i] / WorldToIdeal);
                }
            }
        }
    }


    // Implement glyph offsets, if any

    if (glyphOffsets)
    {
        if (TextItem->Flags & ItemVertical)
        {
            for (INT i = 0; i < GlyphCount; i++)
            {
                glyphOrigins[i].X += glyphOffsets[i].Y / WorldToIdeal;
                glyphOrigins[i].Y += glyphOffsets[i].X / WorldToIdeal;
            }
        }
        else if (TextItem->Level & 1)
        {
            for (INT i = 0; i < GlyphCount; i++)
            {
                glyphOrigins[i].X -= glyphOffsets[i].X / WorldToIdeal;
                glyphOrigins[i].Y -= glyphOffsets[i].Y / WorldToIdeal;
            }
        }
        else
        {
            for (INT i = 0; i < GlyphCount; i++)
            {
                glyphOrigins[i].X += glyphOffsets[i].X / WorldToIdeal;
                glyphOrigins[i].Y -= glyphOffsets[i].Y / WorldToIdeal;
            }
        }
    }


    // Map to device units

    WorldToDevice->Transform(glyphOrigins, GlyphCount);
    return Ok;
}




/////   AdjustGlyphAdvances
//
//      Adjusted hinted glyph placement to match a required total nominal
//      width.



//  A tiny agent to collect amount of adjustment needed to revert
//  trailing whitespaces added by glyph adjustment algorithm. The
//  adjustment value grows positive in text flow direction of run.
//
//  The idea is to have the collector being independent from the
//  algorithm as much as possible.
//

namespace
{

class TrailingAdjustCollector
{
public:
    TrailingAdjustCollector(BOOL setTrailingAdjust, INT * trailingAdjust, INT * lastNonBlankGlyphHintedWidth)
        :   SetTrailingAdjust(setTrailingAdjust),
            TrailingAdjust(trailingAdjust),
            LastNonBlankGlyphHintedWidth(lastNonBlankGlyphHintedWidth),
            CollectedAdjust(0)
    {}

    ~TrailingAdjustCollector()
    {
        *LastNonBlankGlyphHintedWidth += CollectedAdjust;
        if (SetTrailingAdjust)
        {
            *TrailingAdjust = -CollectedAdjust;
        }
    }

    void operator+=(INT delta)
    {
        CollectedAdjust += delta;
    }

    void operator-=(INT delta)
    {
        CollectedAdjust -= delta;
    }

private:
    BOOL    SetTrailingAdjust;
    INT     CollectedAdjust;
    INT *   TrailingAdjust;
    INT *   LastNonBlankGlyphHintedWidth;
}; // class TrailingAdjustCollector

} // namespace

GpStatus GlyphImager::AdjustGlyphAdvances(
    INT    runGlyphOffset,
    INT    runGlyphLimit,
    BOOL   leadingEdge,
    BOOL   trailingEdge
)
{
    const INT    *nominalWidths = NominalAdvances        + runGlyphOffset;
    INT          *hintedWidths  = AdjustedAdvances.Get() + runGlyphOffset;
    const UINT16 *glyphs        = Glyphs                 + runGlyphOffset;
    INT           glyphCount    = runGlyphLimit          - runGlyphOffset;

    ASSERT(glyphCount>0);

    const UINT16 blankGlyph = Face->GetBlankGlyph();
    INT    blankWidth = GpRound(   (   Face->GetDesignAdvance().Lookup(blankGlyph)
                                    *  EmSize
                                    *  WorldToIdeal)
                                /  Face->GetDesignEmHeight());


    // Leading and trailing blanks are set to their nominal width

    INT leadingBlanks = 0;
    while (leadingBlanks < glyphCount
           && glyphs[leadingBlanks] == blankGlyph
           && hintedWidths[leadingBlanks] != 0
           )
    {
        hintedWidths[leadingBlanks] = blankWidth;
        leadingBlanks++;
    }

    INT trailingBlanks = 0;
    while (leadingBlanks + trailingBlanks < glyphCount
           && glyphs[glyphCount-1-trailingBlanks] == blankGlyph
           && hintedWidths[glyphCount-1-trailingBlanks] != 0
           )
    {
        hintedWidths[glyphCount-1-trailingBlanks] = blankWidth;
        trailingBlanks++;
    }


    // From here on in, ignore leading and trailing blanks

    glyphs        += leadingBlanks;
    nominalWidths += leadingBlanks;
    hintedWidths  += leadingBlanks;
    glyphCount    -= leadingBlanks + trailingBlanks;


    // Collect trailing white spaces caused by adjustment (if any)
    // at the end of the operation

    TrailingAdjustCollector collector(
        trailingEdge,   // TRUE only for the last sub-run of the line
        &TrailingAdjust,
        &hintedWidths[glyphCount - 1]
    );


    if (glyphCount <= 1)
    {
        // If there is just one glyph, then there is no algorithm, just give
        // it its nominal width, and we're done.
        if (glyphCount == 1)
        {
            hintedWidths[0] = nominalWidths[0];
        }
        return Ok;
    }


    // Count the leading and trailing blanks as part of the margins.
    //
    // Where there is a leading/trailing blank we don't have to guarantee
    // falling exactly on the end point. We signal this be treating these
    // like external edges. (External edges are adjustable according to
    // alignement, e.g. in left aligned text only the left edge is required
    // to match its nominal position, the right edge can be moved as a result
    // of hinted/nominal differences.

    if (leadingBlanks)
    {
        RunLeadingMargin += leadingBlanks * blankWidth;
    }

    // Note: we cannot take advantage of trailing blanks as margin space
    // because line services often includes trailing blanks that reach beyond
    // the formatting rectangle.
    //
    // if (trailingBlanks)
    // {
    //     RunTrailingMargin += trailingBlanks * blankWidth;
    // }


    // We have more than one glyph, and the glyph at each end is non-blank
    // implies there are at least 2 non-blank glyphs.

    // Measure total nominal and hinted widths, and count internal blanks

    INT internalBlanks = 0;
    INT totalNominal   = 0;    // 32.0 ideal
    INT totalHinted    = 0;    // 32.0 ideal
    INT blanksHinted   = 0;    // 32.0 ideal
    INT blanksNominal  = 0;    // 32.0 ideal
    INT clusterCount   = 0;    // Number of base glyphs (neither space nor diacritic)

    const SCRIPT_VISATTR *properties = (const SCRIPT_VISATTR*) GlyphProperties + runGlyphOffset + leadingBlanks;

    for (INT i = 0; i < glyphCount; ++i)
    {
        if (    glyphs[i] == blankGlyph
            &&  hintedWidths[i] != 0)
        {
            internalBlanks++;
            blanksHinted  += hintedWidths[i];
            blanksNominal += nominalWidths[i];
        }
        else
        {
            totalHinted  += hintedWidths[i];
            totalNominal += nominalWidths[i];
            if (!properties[i].fDiacritic)
            {
                clusterCount++;
            }
        }
    }

    totalHinted  += blanksHinted;
    totalNominal += blanksNominal;

    // WARNING(("AdjustGlyphAdvances: Nominal %d, hinted %d", totalNominal, totalHinted));


    /// Determine adjustment strategy
    //
    //  The difference between totalNominal and totalHinted is the amount to
    //  correct for hinting.
    //
    //  In the general case we rejustify runs to match their nominal width. We
    //  do this with a combination of changes to the spaces in the run, and if
    //  necessary to the inter character gaps in the run.
    //
    //  The client tells us whether either end of the run is adjacent to a
    //  margin by passing the runLeadingEdge and runTrailingEdge flags, and if
    //  adjacent the size of the margin in the runLeadingMargin and runTrailingMargin
    //  parameters.
    //
    //  When the non-aligned end of a run is adjacent to a margin we relax the
    //  rules and allow that end to not reach the nominal position: if the
    //  hinted run is short, we leave it short. If the hinted run is long we
    //  allow it to expand into the margin, if any.
    //
    //  TextItem->Script may disallow expansion (Arabic, Indic), or require
    //  diacritics to be maintained in position.
    //
    //  Goals
    //
    //     o   Use spaces before using inter-character justification
    //     o   Use any margin space that is required to aligned
    //     o   Handle leading combining characters (achieved with fitBlackBox)
    //
    //  Logic
    //     1.  Calculate adjustment required for hinting
    //           adjustment = totalNominal - totalHinted.
    //     2.  Consider any extra adjustment required for fitBlackBox
    //           and record OriginAdjust if required.
    //     3.  Early out for for total adjustment zero
    //     4.  Early out for single cluster: centre the hinted extent over the
    //           nominal extent.
    //     5.  Calculate expansion space available at end(s) away from
    //         alignment. Include all of any leading or trailing blanks and
    //         all of any margin. If there is space available at either or both
    //         ends, use up as much overall adjustment there as possible, and
    //         update OriginAdjust as appropriate.
    //     6.  Early out for remaining adjustment zero.
    //     7.  Allocate as much remaining adjustment as possible to internal
    //         blanks, but don't more than double their size or reduce them
    //         below 1/6 em unless there are no inter-cluster junctions.
    //     8.  Early out for all remaining adjustment in blanks: adjust
    //         blanks and exit.
    //     9.  Divide remaining adjustment amongst inter-cluster junctions.
    //
    //



    // Determine the damage - how much adjustment is required in 32.0 ideal units

    INT adjustment = totalNominal - totalHinted;

    //  'adjustment' is the amount by which the hinted widths need to be
    //  increased in order to match the nominal (layout) widths. For a glyph
    //  string that needs compressing 'adjustment' is negative.


    BOOL paragraphRTL =       (FormatFlags & StringFormatFlagsDirectionRightToLeft)
                         &&  !(FormatFlags & StringFormatFlagsDirectionVertical);

    StringAlignment runRelativeAlignment = Align;

    if ((RenderRTL ? 1 : 0) != paragraphRTL)
    {
        // run alignment is opposite of paragraph alignment
        switch (Align)
        {
        case StringAlignmentNear: runRelativeAlignment = StringAlignmentFar;  break;
        case StringAlignmentFar:  runRelativeAlignment = StringAlignmentNear; break;
        }
    }


    // Allow for fitBlackBox

    if (    !(FormatFlags & StringFormatFlagsNoFitBlackBox)
        &&  (leadingEdge || trailingEdge))
    {
        INT leadingOverhang         = 0;
        INT trailingOverhang        = 0;
        INT leadingSidebearing28p4  = 0;
        INT trailingSidebearing28p4 = 0;

        GpStatus status = FaceRealization->GetGlyphStringSidebearings(
            glyphs,
            glyphCount,
            TextItem->Flags & ItemSideways,
            TextItem->Level & 1,
            &leadingSidebearing28p4,
            &trailingSidebearing28p4
        );
        IF_NOT_OK_WARN_AND_RETURN(status);


        if (leadingEdge)
        {
            INT leadingSidebearing = GpRound(leadingSidebearing28p4  * DeviceToIdealBaseline / 16);
            if (leadingSidebearing < 0)
            {
                // There is overhang. Reduce the margin space appropriately.
                RunLeadingMargin += leadingSidebearing;
                if (RunLeadingMargin < 0)
                {
                    // Anything more than the available margin must add to the
                    // adjustment.
                    adjustment   += RunLeadingMargin;
                    OriginAdjust -= RunLeadingMargin;
                    RunLeadingMargin = 0;
                }
            }
            else if (    leadingSidebearing > 0
                     &&  adjustment < 0
                     &&  runRelativeAlignment != StringAlignmentNear)
            {
                // Need to compress text - take advantage of initial whitespace
                // in first glyph.
                adjustment += leadingSidebearing;
                OriginAdjust -= leadingSidebearing;
            }
        }

        if (trailingEdge)
        {
            INT trailingSidebearing = GpRound(trailingSidebearing28p4 * DeviceToIdealBaseline / 16);
            if (trailingSidebearing < 0)
            {
                // There is overhang. Reduce the margin space appropriately.
                RunTrailingMargin += trailingSidebearing;
                if (RunTrailingMargin < 0)
                {
                    // Anything more than the available margin must add to the
                    // adjustment.
                    adjustment    += RunTrailingMargin;
                    RunTrailingMargin = 0;
                }
            }
            else if (    trailingSidebearing > 0
                     &&  adjustment < 0
                     &&  runRelativeAlignment != StringAlignmentFar)
            {
                // Need to compress text - take advantage of final whitespace
                // in last glyph.
                adjustment += trailingSidebearing;
            }
        }
    }


    if (adjustment == 0)
    {
        //WARNING(("Hinted glyph adjustment: No adjustment required"));
        return Ok;
    }

    if (clusterCount + internalBlanks <= 1)
    {
        //WARNING(("Hinted glyph adjustment: No adjustment because single cluster"));
        // Center the cluster and give up
        OriginAdjust += adjustment/2;
        collector += adjustment - adjustment/2;
        return Ok;
    }


    // Attempt to handle adjustment in margins

    INT emIdeal = GpRound(EmSize * WorldToIdeal);

    switch (runRelativeAlignment)
    {
    case StringAlignmentNear:
        if (trailingEdge)
        {
            if (adjustment >= -RunTrailingMargin)
            {
                if (adjustment < emIdeal)
                {
                    // Adjustment would neither write beyond margin, nore leave
                    // more than an extra em of whitespace: allow it
                    //WARNING(("Hinted glyph adjustment: all in trailing margin"));
                    collector += adjustment;
                    return Ok;
                }
                else
                {
                    // Adjustment would leave more than an Em of whitespace in
                    // the far margin.
                    // Reduce required expansion by an Em, leaving the rest for
                    // real expansion.
                    adjustment -= emIdeal;
                    collector += emIdeal;
                }
            }
            else
            {
                // Expand into the margin
                adjustment += RunTrailingMargin;
                collector -= RunTrailingMargin;
            }
        }
        break;

    case StringAlignmentCenter:
    {
        if (leadingEdge && trailingEdge)
        {
            INT availableMargin = min(RunLeadingMargin, RunTrailingMargin) * 2;
            if (adjustment >= -availableMargin)
            {
                OriginAdjust += adjustment/2;
                collector += adjustment - adjustment/2;
                //WARNING(("Hinted glyph adjustment: in both margins"));
                return Ok;
            }
            else
            {
                // Use up available margin
                adjustment -= availableMargin;
                OriginAdjust += availableMargin/2;
                collector += availableMargin - availableMargin/2;
            }
        }
        break;
    }

    case StringAlignmentFar:
        if (leadingEdge)
        {
            if (adjustment >= -RunLeadingMargin)
            {
                if (adjustment < emIdeal)
                {
                    // Adjustment would neither write beyond margin, nore leave
                    // more than an extra em of whitespace: allow it
                    //WARNING(("Hinted glyph adjustment: all in trailing margin"));
                    OriginAdjust += adjustment;
                    return Ok;
                }
                else
                {
                    // Adjustment would leave more than an Em of whitespace in
                    // the near margin.
                    // Reduce required expansion by an Em, leaving the rest for
                    // real expansion.
                    adjustment -= emIdeal;
                    OriginAdjust += emIdeal;
                }
            }
            else
            {
                // Use the leading margin
                adjustment += RunLeadingMargin;
                OriginAdjust -= RunLeadingMargin;
            }
        }
    }


    // Determine how much whitespace is required according to design metrics
    // Guarantee not to reduce whitespace to less than 1/6 em (rounded up to whole pixels)

    INT minimumBlankPixels      = GpRound(EmSize * WorldToIdeal / 6);
    INT minimumDeviceWhitespace = MAX(internalBlanks*minimumBlankPixels, blanksNominal/2);

    // Use internal blanks to account for remaining adjustment if it wouldn't
    // change their size too much, or if expansion of joining script characters
    // would otherwise be required.

    if (    internalBlanks > 0
        &&  (        adjustment <=  blanksNominal
                 &&  adjustment >=  -(blanksNominal-minimumDeviceWhitespace)
            ||       adjustment > 0
                 &&  IsScriptConnected()
            )
       )
    {
        //WARNING(("Hinted glyph adjustment: in internal spaces"));

        // Ajdustment expands spaces to no more than twice their nominal size
        // and no less than half their nominal size.

        // Apply all adjustment to spaces

        blankWidth =    (blanksHinted + adjustment + internalBlanks/2)
                     /  internalBlanks;

        for (INT i=0; i<glyphCount; i++)
        {
            if (    glyphs[i] == blankGlyph
                &&  hintedWidths[i] != 0)
            {
                hintedWidths[i] = blankWidth;
            }
        }

        return Ok;
    }


    if (adjustment > 0 && IsScriptConnected())
    {
        // The only remaining justification method is intercharacter spacing,
        // but the adjustment requires opening the character spacing and this
        // script is one that cannot be expanded without breaking
        // the joining line between characters.

        // The best we can do is center this run

        OriginAdjust += adjustment/2;
        collector += adjustment - adjustment/2;

        return Ok;
    }


    // Adjustment will require inter-cluster justification

    //WARNING(("Hinted glyph adjustment: intercluster"));

    // Adjustment requires changes to the width of all but the last
    // glyph of each word.

    INT interClusterAdjustment = adjustment;

    if (internalBlanks)
    {
        if (adjustment < 0)
        {
            blankWidth = minimumBlankPixels;
        }
        else
        {
            blankWidth = blanksNominal * 2 / internalBlanks;
        }
        interClusterAdjustment -= blankWidth * internalBlanks - blanksHinted;
    }
    else
    {
        blankWidth = 0;
    }

    // blankWidth - Required width for each blank
    // interClusterAdjustment - adjustment to share between all

    // Count number of blank runs (not the same as number of blank glyphs)

    i=0;
    INT blankRuns = 0;

    while (i < glyphCount)
    {
        if (    glyphs[i] == blankGlyph
            &&  hintedWidths[i] != 0)
        {
            i++;
            while (    i < glyphCount
                   &&  glyphs[i] == blankGlyph
                   &&  hintedWidths[i] != 0)
            {
                i++;
            }
            blankRuns++;
        }
        else
        {
            while (    i < glyphCount
                   &&  (    glyphs[i] != blankGlyph
                        ||  hintedWidths[i] == 0))
            {
                i++;
            }
        }
    }

    // Establish number of adjustment points between non-blanks.
    //
    // Adjustment can happen only between clusters, i.e. not in blank
    // runs, nor in the cluster immediately before a blank run or
    // the last cluster in the line.

    INT interClusterJunctions =      clusterCount
                                  -  blankRuns
                                  -  1;


    // Prepare adjustment control variables

    // When there's a remainder, apply it all at the end of the line
    // Advantage - all words are even. Disadvantage - end of line looks heavy.

    INT perJunctionDelta;
    INT extraPixelLimit;
    INT pixelWidth = GpRound(DeviceToIdealBaseline);

    if (interClusterJunctions <= 0)
    {
        // There are no words of more than one cluster

        // Since we know there are at least 2 nonblank clusters,
        // this means there must be at least one blank somewhere.

        ASSERT(internalBlanks > 0);

        // We have no chice except to make all adjustment happen in the blanks

        blankWidth += (interClusterAdjustment + internalBlanks/2) / internalBlanks;
        perJunctionDelta = 0;
        extraPixelLimit  = 0;
    }
    else if (pixelWidth < 1)
    {
        // Pixels are smaller tham one ideal unit in size, which implies that
        // glyphs are over 4000 pixels high. In this case all glyphs get the
        // same adjustment and we dont bother with extra pixels for some glyphs.

        perJunctionDelta = interClusterAdjustment / interClusterJunctions;
        extraPixelLimit = 0;
    }
    else
    {
        // Every intercharacter junction gets a fixed adjustment that is
        // whole multiple of the pixel width, additionally a number of
        // initial intercharacter junctions receive an addition pixel
        // width adjustment.

        INT pixelInterClusterAdjustment = interClusterAdjustment / pixelWidth;
        INT pixelPerJunctionDelta       = pixelInterClusterAdjustment / interClusterJunctions;
        INT remainder                   =    interClusterAdjustment
                                          -  pixelPerJunctionDelta * interClusterJunctions * pixelWidth;
        INT pixelRemainder = (remainder - pixelWidth/2) / pixelWidth; // Round down to avoid 1 pixel overflow

        if (pixelRemainder >= 0)
        {
            // Start with an extra pixel until remainder are used up
            perJunctionDelta = GpRound((pixelPerJunctionDelta) * DeviceToIdealBaseline);
            extraPixelLimit = pixelRemainder;
        }
        else
        {
            // Initial junctions take per pixel delta, the rest per pixel delta -1
            // Using the same algorithm as for expansion, the the per junction delta
            // one less than it should be and use the extra pixel handling.
            perJunctionDelta = GpRound((pixelPerJunctionDelta-1) * DeviceToIdealBaseline);
            extraPixelLimit = interClusterJunctions + pixelRemainder;
        }
    }


    //  Adjustment FSM
    //
    //  perJunctionDelta  - amount to adjust every inter-character junction
    //  extraPixelLimit   - number of junctions to receive an extra pixe of adjustment
    //  pixelWidth        - amount of adjustment that spaces one pixel

    BOOL prevCharacterBlank = glyphs[0] == blankGlyph  &&  hintedWidths[0] != 0;
    for (INT i=1; i<= glyphCount; i++)
    {
        if (prevCharacterBlank)
        {
            // Previous character was blank - easy!

            hintedWidths[i-1] = blankWidth;
        }
        else
        {
            // Previous character nonblank

            // skip over diacritics. We never change the width of a glyph before
            // a diacritic, only the width of the last diacritic in a run of
            // diacritics.
            while (    i < glyphCount
                   &&  properties[i].fDiacritic)
            {
                i++;
            }

            if (    i >= glyphCount
                ||  (    glyphs[i] == blankGlyph
                     &&  hintedWidths[i] != 0))
            {
                // The previous nonblank preceeded a blank or margin
                // No change - use the hinted width
            }
            else
            {
                // The previous nonblank is adjustable
                hintedWidths[i-1] +=    perJunctionDelta
                                     +  (extraPixelLimit-- > 0 ? pixelWidth : 0);
            }
        }

        if (i < glyphCount)
        {
            prevCharacterBlank = glyphs[i] == blankGlyph  &&  hintedWidths[i] != 0;
        }
    }

    return Ok;
}





/////   Public GlyphImager methods
//
//


/////   Initialise
//
//

GpStatus GlyphImager::Initialize(
    IN  const GpFaceRealization *faceRealization,
    IN  const GpMatrix          *worldToDevice,
    IN  REAL                     worldToIdeal,
    IN  REAL                     emSize,
    IN  INT                      glyphCount,
    IN  const UINT16            *glyphs,
    IN  const GpTextItem        *textItem,
    IN  const GpStringFormat    *format,
    IN  INT                      runLeadingMargin,
    IN  INT                      runTrailingMargin,
    IN  BOOL                     runLeadingEdge,       // This run at leading edge of line
    IN  BOOL                     runTrailingEdge,      // This run at trailing edge of line
    IN  const WCHAR             *string,
    IN  INT                      stringOffset,
    IN  INT                      stringLength,
    IN  const UINT16            *glyphProperties,   // glyph properties array
    IN  const INT               *glyphAdvances,     // glyph advance width array
    IN  const Point             *glyphOffsets,      // glyph offset array
    IN  const UINT16            *glyphMap,
    IN  SpanVector<UINT32>      *rangeVector,       // optional
    IN  BOOL                     renderRTL
)
{
    Face              = faceRealization->GetFontFace();
    FaceRealization   = faceRealization;
    WorldToDevice     = worldToDevice;
    WorldToIdeal      = worldToIdeal;
    EmSize            = emSize;
    GlyphCount        = glyphCount;
    Glyphs            = glyphs;
    NominalAdvances   = glyphAdvances;
    NominalOffsets    = glyphOffsets;
    GlyphProperties   = glyphProperties;
    GlyphMap          = glyphMap;
    TextItem          = textItem;
    Format            = format;
    Adjusted          = FALSE;
    RunLeadingMargin  = runLeadingMargin;
    RunTrailingMargin = runTrailingMargin;
    RangeVector       = rangeVector;
    String            = string;
    StringOffset      = stringOffset;
    StringLength      = stringLength;
    RenderRTL         = renderRTL;
    OriginAdjust      = 0;
    TrailingAdjust    = 0;
    InitializedOk     = FALSE;

    if (format)
    {
        FormatFlags = format->GetFormatFlags();
        Align       = format->GetAlign();
    }
    else
    {
        FormatFlags = 0;
        Align       = StringAlignmentNear;
    }


    // Establish device unit to ideal unit scale factor

    REAL m1;
    REAL m2;

    if (   (textItem->Flags & ItemVertical)
        && !(textItem->Flags & ItemSideways))
    {
        m1 = WorldToDevice->GetM21();
        m2 = WorldToDevice->GetM22();
    }
    else
    {
        m1 = WorldToDevice->GetM11();
        m2 = WorldToDevice->GetM12();
    }

    REAL d = m1*m1 + m2*m2;

    if (d > 0)
    {
        DeviceToIdealBaseline = WorldToIdeal / REALSQRT(d);
    }
    else
    {
        DeviceToIdealBaseline = 0;
    }

    // Early out if:
    //
    // Client forced nominal advance with private testing flag
    // Unhinted, not continuous script, and there are margins (for glyph overhangs)

    if (    (FormatFlags & StringFormatFlagsPrivateUseNominalAdvance)
        ||  !IsScriptConnected()
            && (FaceRealization->IsFixedPitch()
                || (!IsGridFittedTextRealizationMethod(FaceRealization->RealizationMethod())
                       && runLeadingMargin >= 0
                       && runTrailingMargin >= 0
                   )
               )
       )
    {
        // No adjustment required: place Glyphs using nominal advance widths
        InitializedOk = TRUE;
        return Ok;
    }



    //// Determine amount of adjustment required

    // If we're not hinting, start with the nominal widths, otherwise
    // call the rasterizer to obtain hinted widths.

    AdjustedAdvances.SetSize(GlyphCount);
    AdjustedOffsets.SetSize(GlyphCount);

    if (    !AdjustedAdvances
        ||  !AdjustedOffsets)
    {
        return OutOfMemory;
    }

    GpStatus status = Ok;

    if (!IsGridFittedTextRealizationMethod(FaceRealization->RealizationMethod()) && !IsScriptConnected())
    {
        // Realized == nominal, so we don't need to invoke the rasterizer
        // (we only get here if we need to adjust for fitBlackBox)

        GpMemcpy(AdjustedAdvances.Get(), NominalAdvances, glyphCount * sizeof(INT));
        if (glyphOffsets)
        {
            GpMemcpy(AdjustedOffsets.Get(), NominalOffsets, glyphCount * sizeof(GOFFSET));
        }
    }
    else
    {
        status = Face->GetShapingCache()->GetRealizedGlyphPlacement(
            TextItem,
            Glyphs,
            (SCRIPT_VISATTR *)glyphProperties,
            glyphCount,
            FormatFlags,
            WorldToDevice,
            WorldToIdeal,
            EmSize,
            FaceRealization,
            AdjustedAdvances.Get(),
            NominalOffsets ? reinterpret_cast<GOFFSET*>(AdjustedOffsets.Get()) : NULL,
            NULL                    // no total advance required
        );
        IF_NOT_OK_WARN_AND_RETURN(status);
    }


    // Adjust hinted advances to sum the same as the nominal placements
    // including implementation of fitBlackBox.

    if (RangeVector)
    {
        SpanRider<UINT32> rangeRider(RangeVector);

        INT runStringOffset = stringOffset;
        INT runGlyphOffset  = 0;

        while (runGlyphOffset < GlyphCount)
        {
            rangeRider.SetPosition(runStringOffset);
            INT runStringLimit;
            if (rangeRider.AtEnd())
            {
                runStringLimit = stringLength;
            }
            else
            {
                runStringLimit = runStringOffset + rangeRider.GetUniformLength();
            }

            INT runGlyphLimit;

            if (runStringLimit < stringLength)
            {
                runGlyphLimit = glyphMap[runStringLimit];
                while (    runGlyphLimit < GlyphCount
                       &&  (    runGlyphLimit < runGlyphOffset
                            ||  reinterpret_cast<const SCRIPT_VISATTR*>(glyphProperties+runGlyphLimit)->fDiacritic))
                {
                    runGlyphLimit++;
                }
            }
            else
            {
                runGlyphLimit = GlyphCount;
            }


            // Adjust between runGlyphOffset and runGlyphLimit.
            // Note, if the client specifies multiple ranges inside a cluster,
            // some glyph runs will be empty.

            if (runGlyphLimit > runGlyphOffset)
            {
                status = AdjustGlyphAdvances(
                    runGlyphOffset,
                    runGlyphLimit,
                    runGlyphOffset <= 0 ? runLeadingEdge : FALSE,
                    runGlyphLimit  >= GlyphCount ? runTrailingEdge : FALSE
                );
                IF_NOT_OK_WARN_AND_RETURN(status);
            }

            runGlyphOffset  = runGlyphLimit;
            runStringOffset = runStringLimit;
        }
    }
    else
    {
        // Adjust entire run as one
        status = AdjustGlyphAdvances(
            0,
            GlyphCount,
            runLeadingEdge,
            runTrailingEdge
        );
        IF_NOT_OK_WARN_AND_RETURN(status);
    }


    //#if DBG
    //    INT totalNominal = 0;
    //    INT adjustedHinted = 0;
    //    for (INT i = 0; i < GlyphCount; ++i)
    //    {
    //        totalNominal   += NominalAdvances[i];
    //        adjustedHinted += AdjustedAdvances[i];
    //    }
    //    WARNING(("Nominal %d, adjusted hinted %d, delta %d",
    //             totalNominal, adjustedHinted, adjustedHinted-totalNominal));
    //#endif


    Adjusted      = TRUE;
    InitializedOk = TRUE;
    return Ok;
}




GpStatus GlyphImager::GetAdjustedGlyphAdvances(
    IN  const PointF    *origin,
    OUT const INT       **adjustedGlyphAdvances,
    OUT INT             *originAdjust,
    OUT INT             *trailingAdjust
)
{
    if (!InitializedOk)
    {
        return WrongState;
    }

    if (Adjusted)
    {
        if (origin)
        {
            PointF  cellOrigin;
            GetDisplayCellOrigin(*origin, &cellOrigin);

            if (FormatFlags & StringFormatFlagsDirectionVertical)
            {
                *originAdjust = OriginAdjust;
            }
            else
            {
                INT axisOriginAdjust = GpRound((cellOrigin.X - origin->X) * WorldToIdeal);
                *originAdjust = RenderRTL ? -axisOriginAdjust : axisOriginAdjust;
            }
        }
        else
        {
            *originAdjust = OriginAdjust;
        }

        *adjustedGlyphAdvances = AdjustedAdvances.Get();
        *trailingAdjust        = TrailingAdjust;
    }
    else
    {
        *adjustedGlyphAdvances = NominalAdvances;
        *originAdjust          =
        *trailingAdjust        = 0;
    }

    return Ok;
}




void GlyphImager::GetDisplayCellOrigin(
    IN  const PointF    &origin,        // baseline origin in world units
    OUT PointF          *cellOrigin     // adjusted display origin in world units
)
{
    // Convert ideal advances to glyph origins

    *cellOrigin = origin;

    INT axisOriginAdjust = RenderRTL ? -OriginAdjust : OriginAdjust;

    if (OriginAdjust != 0)
    {
        // OriginAdjust is the delta to the leading edge of the string.
        // Apply it to cellOrigin. cellOrigin is in world units.

        if (FormatFlags & StringFormatFlagsDirectionVertical)
        {
            cellOrigin->Y += axisOriginAdjust / WorldToIdeal;
        }
        else
        {
            cellOrigin->X += axisOriginAdjust / WorldToIdeal;
        }
    }

    if (Adjusted && WorldToDevice->IsTranslateScale())
    {

        // Since in some grid fit cases the glyphAdvances array will have fractional
        // pixel advances, glyph display will snap some leftward and some rightward.
        // We snap the origin here to a whole pixel in order to obtain repeatable
        // position display independant of glyph position, and so that in the
        // common justification case where ony a few pixels are removed from the
        // whole string, the pixel removal happens away from the first few glyphs.

        // The cellOrigin is in world units so to round it to the whole pixel we need to convert
        // it to device units (multiply cellOrigin->X by WorldToDevice->GetM11() for x scaling and 
        // myltiply cellOrigin->Y  by WorldToDevice->GetM22() for y scaling).
        // then round it to the whole pixel and then revert it back to world unit through dividing 
        // by the same value we already multiplied by.
        // Note that we know there is no rotation or shear involved as this codepath is only
        // active when the facerealization reports gridfitting.

        if (WorldToDevice->GetM11()!=0)
        {
            cellOrigin->X = TOREAL(GpRound(cellOrigin->X * WorldToDevice->GetM11())) / 
                                                            WorldToDevice->GetM11();
        }

        if (WorldToDevice->GetM22()!=0)
        {
            cellOrigin->Y = TOREAL(GpRound(cellOrigin->Y * WorldToDevice->GetM22())) / 
                                                            WorldToDevice->GetM22();
        }
    }
}
   




GpStatus
GlyphImager::DrawGlyphs(
    IN  const PointF               &origin,       // in world units
    IN  SpanVector<const GpBrush*> *brushVector,
    IN  GpGraphics                 *graphics,
    OUT PointF                     *cellOrigin,
    OUT const INT                  **adjustedGlyphAdvances
)
{
    if (!InitializedOk)
    {
        return WrongState;
    }

    GetDisplayCellOrigin(origin, cellOrigin);

    AutoBuffer<PointF, 32> glyphOrigins(GlyphCount);

    GpStatus status = GlyphPlacementToGlyphOrigins(
        cellOrigin,
        graphics,
        glyphOrigins.Get()
    );
    IF_NOT_OK_WARN_AND_RETURN(status);


    //  Loop through all possible different brushes,
    //  render each brush separately.

    SpanRider<const GpBrush*> brushRider(brushVector);
    brushRider.SetPosition(StringOffset);

    INT runStringOffset = 0;
    while (runStringOffset < StringLength)
    {
        INT brushLength = min(brushRider.GetUniformLength(),
                              static_cast<UINT>(StringLength - runStringOffset));

        INT runGlyphOffset = GlyphMap[runStringOffset];
        INT runGlyphCount  =    (   runStringOffset + brushLength < StringLength
                                 ?  GlyphMap[runStringOffset + brushLength]
                                 :  GlyphCount)
                             -  runGlyphOffset;

        INT drawFlags = 0;
        if (    FormatFlags & StringFormatFlagsPrivateNoGDI
            ||  TextItem->Flags & ItemSideways)
        {
            drawFlags |= DG_NOGDI;
        }

        status = graphics->DrawPlacedGlyphs(
            FaceRealization,
            brushRider.GetCurrentElement(),
            drawFlags,
            String + StringOffset + runStringOffset,
            brushLength,
            RenderRTL,
            Glyphs + runGlyphOffset,
            GlyphMap + runStringOffset,
            glyphOrigins.Get() + runGlyphOffset,
            runGlyphCount,
            TextItem->Script,
            (TextItem->Flags & ItemSideways)
        );
        IF_NOT_OK_WARN_AND_RETURN(status);

        runStringOffset += brushLength;
        brushRider.SetPosition(StringOffset + runStringOffset);
    }

    *adjustedGlyphAdvances = Adjusted ? AdjustedAdvances.Get() : NominalAdvances;

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\hmtx.cpp ===
////    HMTX - Truetype hmtx font table loader
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//



#include "precomp.hpp"




///     Interprets Truetype HMTX tables to extract design advance widths




////    ReadMtx - Get design widths from hmtx or vmtx table
//
//      The Hmtx contains numberOfHMetrics repetitions of longMetric
//      followed by numGlyphs-numberOfHMetrics repetitions of a UINT16.
//
//      The longHorMetrics corresponds to glyphs that vary in width,
//      and the UINT16s provide left sidebearings for fixed advance
//      width glyphs (whose advance widths comes from the last longMetric)


struct LongMetric {
    UINT16 advanceWidth;
    INT16  lsb;             // Left side bearing
};

GpStatus ReadMtx(
    BYTE           *mtx,
    UINT            mtxLength,
    INT             numGlyphs,
    INT             numberOfLongMetrics,
    IntMap<UINT16> *designAdvance
)
{
    // All entries in the mtx are 16 bit, so flip them all to Intel byte
    // order before we start.

    FlipWords(mtx, mtxLength/2);

    if (   numberOfLongMetrics               * sizeof(LongMetric)
        +  (numGlyphs - numberOfLongMetrics) * sizeof(INT16)
        >  mtxLength)
    {
        return Ok;
    }

    if (numberOfLongMetrics < 1)
    {
        return Ok;
    }


    GpStatus status = Ok;

    // Handle longMetric entries

    LongMetric *longMetric = (LongMetric*) mtx;

    INT i;
    for (i=0; i<numberOfLongMetrics && status == Ok; i++)
    {
        status = designAdvance->Insert(i, longMetric->advanceWidth);
        longMetric++;
    }


    // Fill in remaining entries with advance width from last longMetric entry

    UINT16 fixedAdvance = (--longMetric)->advanceWidth;

    for (i=numberOfLongMetrics; i<numGlyphs && status == Ok; i++)
    {
        status = designAdvance->Insert(i, fixedAdvance);
    }
    return status;
}




GpStatus ReadMtxSidebearing(
    BYTE           *mtx,
    UINT            mtxLength,
    INT             numGlyphs,
    INT             numberOfLongMetrics,
    IntMap<UINT16> *sidebearing
)
{
    // All entries in the mtx are 16 bit, so flip them all to Intel byte
    // order before we start.

    FlipWords(mtx, mtxLength/2);

    ASSERT(  numberOfLongMetrics               * sizeof(LongMetric)
           + (numGlyphs - numberOfLongMetrics) * sizeof(INT16)
           <= mtxLength);

    ASSERT(numberOfLongMetrics >= 1);   // Even a fixed pitch font must have one
                                        // to provide the fixed advance width

    if (   numberOfLongMetrics               * sizeof(LongMetric)
        +  (numGlyphs - numberOfLongMetrics) * sizeof(INT16)
        >  mtxLength)
    {
        return Ok;
    }

    if (numberOfLongMetrics < 1)
    {
        return Ok;
    }

    GpStatus status = Ok;
    // Handle longMetric entries

    LongMetric *longMetric = (LongMetric*) mtx;

    INT i;
    for (i=0; i<numberOfLongMetrics && status == Ok; i++)
    {
        status = sidebearing->Insert(i, longMetric->lsb);
        longMetric++;
    }


    // Fill in remaining entries

    INT16 *lsb = (INT16*) longMetric;

    for (i=numberOfLongMetrics; i<numGlyphs && status == Ok; i++)
    {
        status = sidebearing->Insert(i, lsb[i-numberOfLongMetrics]);
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\imager.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Text imager implementation
*
* Revision History:
*
*   06/16/1999 dbrown
*       Created it.
*
\**************************************************************************/


#include "precomp.hpp"






/////   NewTextImager
//
//      Analyses the clients requirements, and chooses between the simple
//      text imager and the full text imager.
//
//      If the returned status is not Ok, then all allocated memory has been
//      released.
//
//      !v2 - the decision to use a simple or full text imager cannot be made
//      until formatting is required, since the client may make format or
//      content changes after the initial construction and before calling
//      measurement or rendering functionality.


GpStatus newTextImager(
    const WCHAR           *string,
    INT                    length,
    REAL                   width,
    REAL                   height,
    const GpFontFamily    *family,
    INT                    style,
    REAL                   fontSize,    // In world units
    const GpStringFormat  *format,
    const GpBrush         *brush,
    GpTextImager         **imager,
    BOOL                   singleUse    // Enables use of simple formatter when no format passed
)
{
    GpStatus status;

    // Establish string length

    if (length == -1)
    {
        length = 0;
        while (string[length])
        {
            length++;
        }
    }

    if (length < 0)
    {
        return InvalidParameter;
    }
    else if (length == 0)
    {
        *imager = new EmptyTextImager;
        if (!*imager)
            return OutOfMemory;
        return Ok;
    }


    // Determine line length limit

    REAL lineLengthLimit;

    if (format && format->GetFormatFlags() & StringFormatFlagsDirectionVertical)
    {
        lineLengthLimit = height;
    }
    else
    {
        lineLengthLimit = width;
    }


    if (lineLengthLimit < 0)
    {
        *imager = new EmptyTextImager;
        if (!*imager)
            return OutOfMemory;
        return Ok;
    }

    // Establish font face that will be used if no fallback is required

    GpFontFace *face = family->GetFace(style);

    if (!face)
    {
        return InvalidParameter;
    }


    // Certain flags are simply not supported by the simple text imager
    // Fonts with kerning, ligatures or opentype tables for simple horizontal
    // characters are not supported by the simple text imager

    INT64 formatFlags = format ? format->GetFormatFlags() : 0;

    *imager = new FullTextImager(
        string,
        length,
        width,
        height,
        family,
        style,
        fontSize,
        format,
        brush
    );
    if (!*imager)
        return OutOfMemory;
    status = (*imager)->GetStatus();
    if (status != Ok)
    {
        delete *imager;
        *imager = NULL;
    }
    return status;
}




void GpTextImager::CleanupTextImager()
{
    ols::deleteFreeLineServicesOwners();
}








void DetermineStringComplexity(
    const UINT16 *string,
    INT           length,
    BOOL         *complex,
    BOOL         *digitSeen
)
{
    INT     i = 0;
    INT flags = 0;

    while (i < length)
    {
        INT ch = string[i++];

        // Don't worry about surrogate pairs in this test: all surrogate
        // WCHAR values are flagged as NOTSIMPLE.

        UINT_PTR cl = (UINT_PTR)(pccUnicodeClass[ch >> 8]);

        if (cl >= CHAR_CLASS_MAX) // It's a pointer to more details
        {
            cl = ((CHAR_CLASS*)cl)[ch & 0xFF];
        }

        flags |= CharacterAttributes[cl].Flags;
    }

    *digitSeen = flags & CHAR_FLAG_DIGIT     ? TRUE : FALSE;
    *complex   = flags & CHAR_FLAG_NOTSIMPLE ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\imager.hpp ===
#ifndef _IMAGER_HPP
#define _IMAGER_HPP






/////   EmptyTextImager
//
//      Provides text imager functions when the text is empty

class EmptyTextImager : public GpTextImager
{
public:
    EmptyTextImager() : GpTextImager() {}

    ~EmptyTextImager() {}

    virtual GpStatus Draw(GpGraphics *graphics, const PointF *origin)
    {
        return Ok;
    }

    virtual GpStatus AddToPath(GpPath *path, const PointF *origin)
    {
        return Ok;
    }

    virtual GpStatus Measure(
        GpGraphics *graphics,
        REAL *nearGlyphEdge,
        REAL *farGlyphEdge,
        REAL *textDepth,
        INT *codepointsFitted,
        INT *linesFilled
    )
    {
        *nearGlyphEdge    = 0;
        *farGlyphEdge     = 0;
        *textDepth        = 0;

        if (codepointsFitted)
            *codepointsFitted = 0;

        if (linesFilled)
            *linesFilled = 0;

        return Ok;
    }

    virtual GpStatus MeasureRanges(
        GpGraphics      *graphics,
        const PointF    *origin,
        GpRegion        **regions
    )
    {
        return Ok;
    }

    virtual Status GetStatus() const
    {
        return Ok;
    }
};



/*
///     SimpleTextImager
//
//      Provides text imager functions when the text is simple and all on
//      one line.
//
//      The client has already generated glyphs and widths by the time
//      it creates the imager, so the constructor takes these buffers
//      as parameters.

class SimpleTextImager : public GpTextImager
{
public:
    SimpleTextImager(
        const WCHAR          *string,
        INT                   length,
        REAL                  width,
        REAL                  height,
        REAL                  leftMargin,
        REAL                  rightMargin,
        const GpFontFamily   *family,
        const GpFontFace     *face,
        INT                   style,
        REAL                  emSize,
        const GpStringFormat *format,
        const GpBrush        *brush,
        GINDEX               *glyphs,
        UINT                  glyphCount,
        UINT16               *designAdvances,
        REAL                  totalWorldAdvance
    ) :
        GpTextImager(),
        String             (string),
        Length             (length),
        Width              (width),
        Height             (height),
        LeftMargin         (leftMargin),
        RightMargin        (rightMargin),
        Family             (family),
        Face               (face),
        Style              (style),
        EmSize             (emSize),
        Format             (format),
        Brush              (brush),
        Glyphs             (glyphs),
        GlyphCount         (glyphCount),
        GlyphAdvances      (NULL),
        TotalWorldAdvance  (totalWorldAdvance),
        Status             (Ok)
    {
        GlyphAdvances = new INT[GlyphCount];

        if (!GlyphAdvances)
        {
            Status = OutOfMemory;
            return;
        }

        WorldToIdeal        = TOREAL(2048.0 / emSize);
        REAL designEmHeight = face->GetDesignEmHeight();

        for (UINT i=0; i<glyphCount; i++)
        {
            GlyphAdvances[i] = GpRound(   designAdvances[i] * emSize * WorldToIdeal
                                       /  designEmHeight);
        }
    }

    ~SimpleTextImager()
    {
        delete [] Glyphs;
        if (GlyphAdvances)
        {
            delete [] GlyphAdvances;
        }
    }

    virtual GpStatus Draw(GpGraphics *graphics, const PointF *origin);

    virtual GpStatus AddToPath(GpPath *path, const PointF *origin);

    virtual GpStatus Measure(
        GpGraphics *graphics,
        REAL       *nearGlyphEdge,
        REAL       *farGlyphEdge,
        REAL       *textDepth,
        INT        *codepointsFitted,
        INT        *linesFilled
    );

#ifndef DCR_REMOVE_OLD_174340
    virtual GpStatus MeasureRegion(
        INT           firstCharacterIndex,
        INT           characterCount,
        const PointF *origin,
        GpRegion     *region
    );
#endif

    virtual GpStatus MeasureRanges(
        GpGraphics      *graphics,
        const PointF    *origin,
        GpRegion        **regions
    );

    virtual Status GetStatus() const {return Status;}

private:

    GpStatus MeasureRangeRegion(
        INT           firstCharacterIndex,
        INT           characterCount,
        const PointF *origin,
        GpRegion     *region
    );


    const WCHAR          *String;
    INT                   Length;
    REAL                  Width;        // Including margins
    REAL                  Height;
    REAL                  LeftMargin;
    REAL                  RightMargin;
    const GpFontFamily   *Family;
    const GpFontFace     *Face;
    INT                   Style;
    REAL                  EmSize;
    const GpStringFormat *Format;
    const GpBrush        *Brush;
    GINDEX               *Glyphs;
    UINT                  GlyphCount;
    INT                  *GlyphAdvances;
    GpStatus              Status;
    REAL                  WorldToIdeal;
    REAL                  TotalWorldAdvance;
};


*/


class EllipsisInfo
{
public:

    EllipsisInfo(
        const GpFontFace    *fontFace,
        REAL                emSize,
        INT                 style,
        double              designToIdeal,
        INT                 formatFlags
    );

    enum
    {
        MAX_ELLIPSIS = 3
    };

    WCHAR               String[MAX_ELLIPSIS];
    UINT16              Glyphs[MAX_ELLIPSIS];
    UINT16              GlyphMap[MAX_ELLIPSIS];
    UINT16              GlyphProperties[MAX_ELLIPSIS];
    INT                 GlyphAdvances[MAX_ELLIPSIS];
    Point               GlyphOffsets[MAX_ELLIPSIS];
    INT                 GlyphCount;

    INT                 Width;

    const GpFontFace    *Face;
    REAL                EmSize;
    GpTextItem          Item;
    INT                 FormatFlags;
};




//  Thai word breaking API initializer

extern "C" HRESULT WINAPI GdipThaiBreakingFunctionInitializer(
    const WCHAR             *string,    // [IN] input string
    INT                     length,     // [IN] string length
    const SCRIPT_ANALYSIS   *analysis,  // [IN] Uniscribe script analysis
    SCRIPT_LOGATTR          *breaks     // [OUT] break result buffer size of string length
);




/////   Visibility
//
//

enum Visibility
{
    VisibilityShow  = 0,
    VisibilityHide  = 1
};





/////   FullTextImager
//
//      This imager handles all TextImager functionality but has
//      more setup time and oiverhead than the FastTextImager.


class FullTextImager : public GpTextImager
{
friend class BuiltLine;
friend class GlyphImager;

public:

    FullTextImager(
        const WCHAR          *string,
        INT                   length,
        REAL                  width,
        REAL                  height,
        const GpFontFamily   *family,
        INT                   style,
        REAL                  size,
        const GpStringFormat *format,
        const GpBrush        *brush
    );

    virtual ~FullTextImager();

    virtual GpStatus Draw(GpGraphics *graphics, const PointF *origin);

    virtual GpStatus AddToPath(GpPath *path, const PointF *origin);

    virtual GpStatus Measure(
        GpGraphics *graphics,
        REAL       *nearGlyphEdge,
        REAL       *farGlyphEdge,
        REAL       *textDepth,
        INT        *codepointsFitted,
        INT        *linesFilled
    );

    virtual GpStatus MeasureRanges(
        GpGraphics      *graphics,
        const PointF    *origin,
        GpRegion        **regions
    );

    INT            GetLength() const {return Length;}
    virtual Status GetStatus() const {return Status;}

    GpStatus SetFamily(
        const GpFontFamily *family,
        INT                 first,
        INT                 length
    )
    {
        return FamilyVector.SetSpan(first, length, family);
    }

    GpStatus SetStyle(
        INT style,
        INT first,
        INT length
    )
    {
        return StyleVector.SetSpan(first, length, style);
    }

    GpStatus SetSize(
        REAL size,
        INT  first,
        INT  length
    )
    {
        return SizeVector.SetSpan(first, length, size);
    }

    GpStatus SetFormat(
        const GpStringFormat *format,
        INT                   first,
        INT                   length
    )
    {
        return FormatVector.SetSpan(first, length, format);
    }

    GpStatus SetBrush(
        const GpBrush *brush,
        INT            first,
        INT            length
    )
    {
        GpStatus status = BrushVector.SetSpan(first, length, brush);
        #if DBG
        BrushVector.Dump();
        #endif
        return status;
    }


    EllipsisInfo *GetEllipsisInfo ()
    {
        if (!Ellipsis)
        {
            const GpFontFace *fontFace = FamilyVector.GetDefault()->GetFace(
                                            StyleVector.GetDefault()
                                         );

            if(!fontFace)
            {
                return NULL;
            }

            REAL emSize = SizeVector.GetDefault();

            double designToIdeal = (emSize * WorldToIdeal) / fontFace->GetDesignEmHeight();

            Ellipsis = new EllipsisInfo (
                            fontFace,
                            emSize,
                            StyleVector.GetDefault(),
                            designToIdeal,
                            GetFormatFlags()
                       );
        }
        return Ellipsis;
    }


private:

    GpStatus Status;

    WCHAR *String;
    INT    Length;

    // Imager dimensions in world units. When no size is specified for the
    // imager these values are zero.

    REAL   Width;               // Horizontal size in world units
    REAL   Height;              // Vertical size

    REAL   LineLengthLimit;     // Max allowable length of each text line
    REAL   TextDepthLimit;      // Max depth of accumulated lines


    /// WorldToIdeal - Line Services ideal resolution scale factor
    //
    //  Factor from world units to line services ideal units for this imager.
    //
    //  Line Services works with integers. This scale factor converts world
    //  units to integers such that the Line Services ideal units cover the
    //  length and depth of the imager.
    //
    //  If the imager is defined with a width and height, max(width,height)
    //  determines the scale factor. If the imager has no width and height,
    //  the scale factor is determined to allow up to 65,536 lines at this
    //  font height. (Since positions are 32 bit, this gives a placement
    //  grid of 1/65536 of character height).
    //
    //  !!! Is 65536 lines per imager and resolution 1/65536 of a line the
    //      right compromise?
    //
    //  Line Services coordinates are relative to the origin of the
    //  formatting area.
    //
    //  WorldToIdeal is a pure scale factor. There is no rotation or shearing
    //  involved. All values in ideal coordinates are relative to the
    //  origin of the text imager.

    REAL WorldToIdeal;

    // Client specified formatting spans (indexed by string offsets)

    SpanVector<const GpBrush*>        BrushVector;
    SpanVector<const GpFontFamily*>   FamilyVector;
    SpanVector<INT>                   StyleVector;
    SpanVector<REAL>                  SizeVector;
    SpanVector<const GpStringFormat*> FormatVector;
    SpanVector<UINT16>                LanguageVector;
    SpanVector<Paragraph*>            ParagraphVector;

    // Internal formatting spans (indexed by string offsets)

    SpanVector<GpTextItem>            TextItemVector;
    SpanVector<Break*>                BreakVector;
    SpanVector<BuiltLine*>            BuiltLineVector;
    SpanVector<INT>                   VisibilityVector;
    SpanVector<UINT32>                RangeVector;


    // Spans indexed by Line Services positions. Line Services sees text
    // with reversal barackets inserted at bidirectional level changes.

    SpanVector<PLSRUN>     RunVector;

    SpanRider<PLSRUN>      RunRider;
    SpanRider<Paragraph*>  ParagraphRider;

    // Partial build status. These variables track how far the run and
    // paragraph building process has progressed, and will increase through
    // the line building process.

    INT  HighLineServicesPosition;
    INT  HighStringPosition;

    // Completion status - these variables are only valid when all lines are
    // fully built.

    INT     LinesFilled;
    UINT32  CodepointsFitted;
    INT     LeftOrTopLineEdge;
    INT     RightOrBottomLineEdge;
    REAL    TextDepth;

    // Line services context - a line service context is only attached during
    // the line building process. At all other times this variable is NULL.

    ols *LineServicesOwner;

    //  Presentation handling - These variables are NULL at all times except
    //  during line display. During line display one, but not both of Graphics
    //  and Path will be set.

    GpGraphics *Graphics;
    GpPath     *Path;
    PointF      ImagerOrigin;    // In world coordinates
    INT         DefaultFontGridFitBaselineAdjustment;

    // The following BuiltLine pointer is set only during rendering. It is
    // used by the DrawGlyphs callback to determine the extent of the line
    // currently being displayed.

    const BuiltLine *CurrentBuiltLine;


    // Ellipsis display information

    EllipsisInfo    *Ellipsis;


    // Character class (partition) to breaking class mapping table
    //
    // This table can be initialized to either Narrow or Wide mapping
    // table defined in linebreakclass.cxx depend on the font being
    // used. We use "Wide" table for FE-dominant font.

    const unsigned short *BreakClassFromCharClass;


    // Itemization and run building

    GpStatus BidirectionalAnalysis();

    GpStatus MirroredNumericAndVerticalAnalysis(
        ItemScript numericScript
    );

    GpStatus BuildRunsFromTextItemsAndFormatting(
        IN  INT   stringStart,
        IN  INT   lineServiceStart,
        IN  INT   lineServicesLimit,
        OUT INT  *stringEnd,
        OUT INT  *lineServicesEnd
    );

    GpStatus FullTextImager::CreateLevelChangeRuns(
        IN  INT                  levelChange,
        IN  INT                  runLineServicesStart,
        IN  INT                  runStringStart,
        IN  const GpFontFamily  *family,
        IN  REAL                 size,
        IN  INT                  style,
        OUT INT                 *lineServicesDelta
    );

    GpStatus CreateTextRuns(
        INT                 runLineServicesStart,
        INT                 runStringStart,
        INT                 runLength,
        const GpTextItem   &item,
        INT                 formatFlags,
        const GpFontFamily *family,
        INT                 style,
        REAL                size
    );


    void GetFallbackFontSize(
        IN   const GpFontFace  *originalFace,
        IN   REAL               originalSize,   // em size
        IN   const GpFontFace  *fallbackFace,
        OUT  REAL              *fallbackSize,   // fallback em size
        OUT  REAL              *fallbackOffset  // fallback baseline offset (+=up)
    );


    void GetFontTransform(
        IN   REAL       fontScale,
        IN   BOOL       vertical,
        IN   BOOL       sideways,
        IN   BOOL       mirror,
        IN   BOOL       forcePath,
        OUT  GpMatrix&  fontTransform
    );


    GpStatus BuildRunsUpToAndIncluding(LSCP lineServicesPosition);

    GpStatus CheckInsertLevelChanges (
        SpanRider<BYTE>                 *levelRider,                // [IN] level rider at the string position
        SpanRider<const GpFontFamily *> *familyRider,               // [IN] font family rider at the string position
        SpanRider<INT>                  *styleRider,                // [IN] style rider at the string position
        SpanRider<REAL>                 *sizeRider,                 // [IN] size rider at the string position
        INT                              lineServicesPosition,      // [IN] correspondent Line Services position
        INT                             *newLineServicesPosition    // [OUT] new Line Services position if changed
    );


    GpStatus ReleaseVectors();

    GpStatus Itemize();
    GpStatus Render();

    GpStatus BuildLines();
    GpStatus BuildAllLines(StringTrimming trimming);
    GpStatus RebuildLines(StringTrimming trimming);

    GpStatus UpdateContentWithPathEllipsis(BOOL *contentChanged);


    GpStatus RenderLine (
        const BuiltLine    *builtLine,        // [IN] line to be rendered
        INT                 linePointOffset   // [IN] point offset to top of the line (in paragraph flow direction)
    );


    GpStatus MeasureRangeRegion(
        INT           firstCharacterIndex,
        INT           characterCount,
        const PointF *origin,
        GpRegion     *region
    );


    struct lsrun::Adjustment;

    GpStatus DrawGlyphs (
        const GpTextItem        *textItem,          // [IN] text item
        const GpFontFace        *fontFace,          // [IN] font face
        REAL                    emSize,             // [IN] requested em size (world unit)
        const WCHAR             *string,            // [IN] (optional) source string (null means imager's string)
        INT                     stringOffset,       // [IN] string offset relative to given string
        UINT                    stringLength,       // [IN] number of characters in the run string
        const GpStringFormat    *format,            // [IN] stringformat
        const INT               style,              // [IN] default font style
        INT                     formatFlags,        // [IN] formatting flags
        const UINT16            *glyphs,            // [IN] glyph index array
        GMAP                    *glyphMap,          // [IN] string to glyphs mapping
        const UINT16            *glyphProperties,   // [IN] glyph properties array
        const INT               *glyphAdvances,     // [IN] glyph advance width array
        const Point             *glyphOffsets,      // [IN] glyph offset array
        UINT                    glyphCount,         // [IN] number of glyphs
        const POINT             *pointOrigin,       // [IN] drawing origin (at baseline)
        INT                     totalWidth,         // [IN] glyphs total width
        lsrun::Adjustment       *adjust = NULL      // [OUT] (optional) display adjustment at edges
    );


    GpStatus GetCharacterProperties (
        ItemScript  script,                 // [IN] Script id
        LSCP        position,               // [IN] Line Services character position
        BOOL        *isWordStart,           // [OUT] Is it a start of word?
        BOOL        *isWordLast,            // [OUT] Is it the word's last character?
        BOOL        *isClusterStart = NULL  // [OUT] (optional) Is it at a cluster boundary?
    );



    /////   CP mapping
    //
    //

    LSCP LineServicesStringPosition (
        INT stringOffset    // [IN] String offset from 0
    );


    LSCP LineServicesStringPosition (
        const BuiltLine *line,          // [IN] line to query
        INT             stringOffset    // [IN] String offset relative to line start string position
    );


    GpStatus GetTextRun(
        INT     lineServicesStringOffset,   // [IN] Line Services string offset
        PLSRUN  *textRun                    // [OUT] result text run
    );



    INT             DefaultIncrementalTab;  // Default incremental tab
    Vector<LSTBD>   TabArray;               // Temporary buffer for user-defined tab stops
    Vector<UINT>    HotkeyPrefix;           // Position of hotkey prefix character


    // Tab functions

    GpStatus GetTabStops (
        INT     stringOffset,
        INT     *count,
        LSTBD   **tabStops,
        INT     *defaultTab
    );



    // Alignment

    StringAlignment GetFormatLineAlign(const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        return format ? format->GetLineAlign() : StringAlignmentNear;
    }


    StringAlignment GetFormatAlign(const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        return format ? format->GetAlign() : StringAlignmentNear;
    }


    // Hotkey options

    INT GetFormatHotkeyPrefix (const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        return format ? format->GetHotkeyPrefix() : HotkeyPrefixNone;
    }


    // Trimming

    StringTrimming GetFormatTrimming (const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        StringTrimming trimming = DefaultTrimming;

        if (format)
        {
            format->GetTrimming(&trimming);
        }
        return trimming;
    }



    // Utility functions

    BOOL IsFormatVertical(const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        return      format
                &&  (   format->GetFormatFlags()
                     &  StringFormatFlagsDirectionVertical);
    }

    BOOL IsFormatRightToLeft(const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        return     format
               &&  (format->GetFormatFlags()
                    &  StringFormatFlagsDirectionRightToLeft);
    }

    BOOL IsFormatNoGDI(const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }

        return     format
               &&  (format->GetFormatFlags()
                    &  StringFormatFlagsPrivateNoGDI);
    }

    INT GetFormatFlags(const GpStringFormat *format = NULL)
    {
        if (!format)
        {
            format = FormatVector.GetDefault();
        }
        return  format ? format->GetFormatFlags() : DefaultFormatFlags;
    }


    BYTE GetParagraphEmbeddingLevel()
    {
        const GpStringFormat *format = FormatVector.GetDefault();

        if (!format)
        {
            return 0;
        }

        INT formatFlags = format->GetFormatFlags();

        if (    formatFlags & StringFormatFlagsDirectionRightToLeft
            &&  !(formatFlags & StringFormatFlagsDirectionVertical))
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }


    INT GetAvailableRanges(const GpStringFormat *format = NULL);
    GpStatus CalculateDefaultFontGridFitBaselineAdjustment();



    GpStatus DrawHotkeyUnderline(
        const GpTextItem        *textItem,          // [IN] text item
        const GpFontFace        *fontFace,          // [IN] font face
        const PointF            *origin,            // [IN] origin at leading edge & baseline (in world unit)
        REAL                    emSize,             // [IN] em size (in world unit)
        UINT                    stringOffset,       // [IN] string offset
        UINT                    stringLength,       // [IN] string length
        UINT                    glyphCount,         // [IN] glyph count
        const GMAP              *glyphMap,          // [IN] glyph map
        const INT               *glyphAdvances,     // [IN] glyph advance width (ideal unit)
        INT                     trailingAdjust      // [IN] adjust for last glyph's advance width
    );


    union
    {
        struct
        {
            UINT    Dirty                               :1; // Has content changed since last update?
            UINT    TruncateLine                        :1; // ignore line breaking rule
            UINT    RecordDisplayPlacementsOnly         :1; // record glyph placement at rendering time
            UINT    InvalidRanges                       :1; // ignore character ranges
        };
        UINT Flags;
    };


public:

    // Line services callbacks.

    //  LS reversal implementation little back door!

    static LSERR (WINAPI GdipLscbkReverseGetInfo)(
        POLS        ols,                    // [IN] text imager instance
        LSCP        position,               // [IN] run character position
        PLSRUN      run,                    // [IN] run
        BOOL        *dontBreakAround,       // [OUT] should reverse chunk be broken around?
        BOOL        *suppressTrailingSpaces // [OUT] suppress trailing spaces?
    );



    // From LSCBK.H

    static void* (WINAPI GdipLscbkNewPtr)(POLS, DWORD);
    static void  (WINAPI GdipLscbkDisposePtr)(POLS, void*);
    static void* (WINAPI GdipLscbkReallocPtr)(POLS, void*, DWORD);


    static LSERR (WINAPI GdipLscbkFetchRun)(POLS, LSCP, LPCWSTR*, DWORD*, BOOL*, PLSCHP,
                                            PLSRUN*);
    /* FetchRun:
     *  pols (IN):
     *  cp (IN):
     *  &lpwchRun (OUT): run of characters.
     *  &cchRun (OUT): number of characters in run
     *  &fHidden (OUT) : hidden run?
     *  &lsChp (OUT): char properties of run
     *  &plsrun (OUT): abstract representation of run properties
     */

    static LSERR (WINAPI GdipLscbkGetAutoNumberInfo)(POLS, LSKALIGN*, PLSCHP, PLSRUN*,
                                                     WCHAR*, PLSCHP, PLSRUN*, BOOL*,
                                                     long*, long*);

    /* GetAutoNumberInfo:
     *  pols (IN):
     *  &lskalAnm (OUT):
     *  &lschpAnm (OUT): lschp for Anm
     *  &plsrunAnm (OUT): plsrun for Anm
     *  &wchAdd (OUT): character to add (Nil is treated as none)
     *  &lschpWch (OUT): lschp for added char
     *  &plsrunWch (OUT): plsrun for added char
     *  &fWord95Model(OUT):
     *  &duaSpaceAnm(OUT):  relevant iff fWord95Model
     *  &duaWidthAnm(OUT):  relevant iff fWord95Model
     */

    static LSERR (WINAPI GdipLscbkGetNumericSeparators)(POLS, PLSRUN, WCHAR*,WCHAR*);
    /* GetNumericSeparators:
     *  pols (IN):
     *  plsrun (IN): run pointer as returned from FetchRun
     *  &wchDecimal (OUT): decimal separator for this run.
     *  &wchThousands (OUT): thousands separator for this run
     */

    static LSERR (WINAPI GdipLscbkCheckForDigit)(POLS, PLSRUN, WCHAR, BOOL*);
    /* GetNumericSeparators:
     *  pols (IN):
     *  plsrun (IN): run pointer as returned from FetchRun
     *  wch (IN): character to check
     *  &fIsDigit (OUT): this character is digit
     */

    static LSERR (WINAPI GdipLscbkFetchPap)(POLS, LSCP, PLSPAP);
    /* FetchPap:
     *  pols (IN):
     *  cp (IN): an arbitrary cp value inside the paragraph
     *  &lsPap (OUT): Paragraph properties.
     */

    static LSERR (WINAPI GdipLscbkFetchTabs)(POLS, LSCP, PLSTABS, BOOL*, long*, WCHAR*);
    /* FetchTabs:
     *  pols (IN):
     *  cp (IN): an arbitrary cp value inside the paragraph
     *  &lstabs (OUT): tabs array
     *  &fHangingTab (OUT): there is hanging tab
     *  &duaHangingTab (OUT): dua of hanging tab
     *  &wchHangingTabLeader (OUT): leader of hanging tab
     */

    static LSERR (WINAPI GdipLscbkGetBreakThroughTab)(POLS, long, long, long*);
    /* GetBreakThroughTab:
     *  pols (IN):
     *  uaRightMargin (IN): right margin for breaking
     *  uaTabPos (IN): breakthrough tab position
     *  uaRightMarginNew (OUT): new right margin
     */

    static LSERR (WINAPI GdipLscbkFGetLastLineJustification)(POLS, LSKJUST, LSKALIGN,
                                                             ENDRES, BOOL*, LSKALIGN*);
    /* FGetLastLineJustification:
     *  pols (IN):
     *  lskj (IN): kind of justification for the paragraph
     *  lskal (IN): kind of alignment for the paragraph
     *  endr (IN): result of formatting
     *  &fJustifyLastLine (OUT): should last line be fully justified
     *  &lskalLine (OUT): kind of alignment for this line
     */

    static LSERR (WINAPI GdipLscbkCheckParaBoundaries)(POLS, LSCP, LSCP, BOOL*);
    /* CheckParaBoundaries:
     *  pols (IN):
     *  cpOld (IN):
     *  cpNew (IN):
     *  &fChanged (OUT): "Dangerous" change between paragraph properties.
     */

    static LSERR (WINAPI GdipLscbkGetRunCharWidths)(POLS, PLSRUN,
                                                    LSDEVICE, LPCWSTR,
                                                    DWORD, long, LSTFLOW,
                                                    int*,long*,long*);
    /* GetRunCharWidths:
     *  pols (IN):
     *  plsrun (IN):
     *  lsDeviceID (IN): presentation or reference
     *  lpwchRun (IN): run of characters
     *  cwchRun (IN): number of characters in run
     *  du (IN): available space for characters
     *  kTFlow (IN): text direction and orientation
     *  rgDu (OUT): widths of characters
     *  &duRun (OUT): sum of widths in rgDx[0] to rgDu[limDx-1]
     *  &limDu (OUT): number of widths fetched
     */

    static LSERR (WINAPI GdipLscbkCheckRunKernability)(POLS, PLSRUN,PLSRUN, BOOL*);
    /* CheckRunKernability:
     *  pols (IN):
     *  plsrunLeft (IN): 1st of pair of adjacent runs
     *  plsrunRight (IN): 2nd of pair of adjacent runs
     *  &fKernable (OUT) : if TRUE, Line Service may kern between these runs
     */

    static LSERR (WINAPI GdipLscbkGetRunCharKerning)(POLS, PLSRUN,
                                                     LSDEVICE, LPCWSTR,
                                                     DWORD, LSTFLOW, int*);
    /* GetRunCharKerning:
     *  pols (IN):
     *  plsrun (IN):
     *  lsDeviceID (IN): presentation or reference
     *  lpwchRun (IN): run of characters
     *  cwchRun (IN): number of characters in run
     *  kTFlow (IN): text direction and orientation
     *  rgDu (OUT): widths of characters
     */

    static LSERR (WINAPI GdipLscbkGetRunTextMetrics)(POLS, PLSRUN,
                                                     LSDEVICE, LSTFLOW, PLSTXM);
    /* GetRunTextMetrics:
     *  pols (IN):
     *  plsrun (IN):
     *  deviceID (IN):  presentation, reference, or absolute
     *  kTFlow (IN): text direction and orientation
     *  &lsTxMet (OUT): Text metrics
     */

    static LSERR (WINAPI GdipLscbkGetRunUnderlineInfo)(POLS, PLSRUN, PCHEIGHTS, LSTFLOW,
                                                       PLSULINFO);
    /* GetRunUnderlineInfo:
     *  pols (IN):
     *  plsrun (IN):
     *  heightsPres (IN):
     *  kTFlow (IN): text direction and orientation
     *  &lsUlInfo (OUT): Underline information
     */

    static LSERR (WINAPI GdipLscbkGetRunStrikethroughInfo)(POLS, PLSRUN, PCHEIGHTS,
                                                           LSTFLOW, PLSSTINFO);
    /* GetRunStrikethroughInfo:
     *  pols (IN):
     *  plsrun (IN):
     *  heightsPres (IN):
     *  kTFlow (IN): text direction and orientation
     *  &lsStInfo (OUT): Strikethrough information
     */

    static LSERR (WINAPI GdipLscbkGetBorderInfo)(POLS, PLSRUN, LSTFLOW, long*, long*);
    /* GetBorderInfo:
     *  pols (IN):
     *  plsrun (IN):
     *  kTFlow (IN): text direction and orientation
     *  &durBorder (OUT): Width of the border on the reference device
     *  &dupBorder (OUT): Width of the border on the presentation device
     */


    static LSERR (WINAPI GdipLscbkReleaseRun)(POLS, PLSRUN);
    /* ReleaseRun:
     *  pols (IN):
     *  plsrun (IN): run to be released, from GetRun() or FetchRun()
     */

    static LSERR (WINAPI GdipLscbkHyphenate)(POLS, PCLSHYPH, LSCP, LSCP, PLSHYPH);
    /* Hyphenate:
     *  pols (IN):
     *  &lsHyphLast (IN): last hyphenation found. kysr==kysrNil means "none"
     *  cpBeginWord (IN): 1st cp in word which exceeds column
     *  cpExceed (IN): 1st which exceeds column, in this word
     *  &lsHyph (OUT): hyphenation results. kysr==kysrNil means "none"
     */

    static LSERR (WINAPI GdipLscbkGetHyphenInfo)(POLS, PLSRUN, DWORD*, WCHAR*);
    /* GetHyphenInfo:
     *  pols (IN):
     *  plsrun (IN):
     *  kysr (OUT)    Ysr type - see "lskysr.h"
     *  wchYsr (OUT)  Character code of YSR
    */

    static LSERR (WINAPI GdipLscbkDrawUnderline)(POLS, PLSRUN, UINT,
                                                 const POINT*, DWORD, DWORD, LSTFLOW,
                                                 UINT, const RECT*);
    /* DrawUnderline:
     *  pols (IN):
     *  plsrun (IN): run to use for the underlining
     *  kUlbase (IN): underline kind
     *  pptStart (IN): starting position (top left)
     *  dupUL (IN): underline width
     *  dvpUL (IN) : underline thickness
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN) : display mode - opaque, transparent
     *  prcClip (IN) : clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkDrawStrikethrough)(POLS, PLSRUN, UINT,
                                                     const POINT*, DWORD, DWORD, LSTFLOW,
                                                     UINT, const RECT*);
    /* DrawStrikethrough:
     *  pols (IN):
     *  plsrun (IN): the run for the strikethrough
     *  kStbase (IN): strikethrough kind
     *  pptStart (IN): starting position (top left)
     *  dupSt (IN): strikethrough width
     *  dvpSt (IN) : strikethrough thickness
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN) : display mode - opaque, transparent
     *  prcClip (IN) : clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkDrawBorder)(POLS, PLSRUN, const POINT*, PCHEIGHTS,
                                              PCHEIGHTS, PCHEIGHTS, PCHEIGHTS, long,
                                              long, LSTFLOW, UINT, const RECT*);

    /* DrawBorder:
     *  pols (IN):
     *  plsrun (IN): plsrun of the first bordered run
     *  pptStart (IN): starting point for the border
     *  pheightsLineFull (IN): height of the line including SpaceBefore & SpaceAfter
     *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
     *  pheightsSubline (IN): height of subline
     *  pheightsRuns (IN): height of collected runs to be bordered
     *  dupBorder (IN): width of one border
     *  dupRunsInclBorders (IN): width of collected runs
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN) : display mode - opaque, transparent
     *  prcClip (IN) : clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkDrawUnderlineAsText)(POLS, PLSRUN, const POINT*,
                                                       long, LSTFLOW, UINT, const RECT*);
    /* DrawUnderlineAsText:
     *  pols (IN):
     *  plsrun (IN): run to use for the underlining
     *  pptStart (IN): starting pen position
     *  dupLine (IN): length of UL
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN) : display mode - opaque, transparent
     *  prcClip (IN) : clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkFInterruptUnderline)(POLS, PLSRUN, LSCP, PLSRUN, LSCP,
                                                       BOOL*);
    /* FInterruptUnderline:
     *  pols (IN):
     *  plsrunFirst (IN): run pointer for the previous run
     *  cpLastFirst (IN): cp of the last character of the previous run
     *  plsrunSecond (IN): run pointer for the current run
     *  cpStartSecond (IN): cp of the first character of the current run
     *  &fInterruptUnderline (OUT): do you want to interrupt drawing of the underline between these runs
     */

    static LSERR (WINAPI GdipLscbkFInterruptShade)(POLS, PLSRUN, PLSRUN, BOOL*);
    /* FInterruptShade:
     *  pols (IN):
     *  plsrunFirst (IN): run pointer for the previous run
     *  plsrunSecond (IN): run pointer for the current run
     *  &fInterruptShade (OUT): do you want to interrupt shading between these runs
     */

    static LSERR (WINAPI GdipLscbkFInterruptBorder)(POLS, PLSRUN, PLSRUN, BOOL*);
    /* FInterruptBorder:
     *  pols (IN):
     *  plsrunFirst (IN): run pointer for the previous run
     *  plsrunSecond (IN): run pointer for the current run
     *  &fInterruptBorder (OUT): do you want to interrupt border between these runs
     */


    static LSERR (WINAPI GdipLscbkShadeRectangle)(POLS, PLSRUN, const POINT*, PCHEIGHTS,
                                                  PCHEIGHTS, PCHEIGHTS, PCHEIGHTS,
                                                  PCHEIGHTS, long, long, LSTFLOW, UINT,
                                                  const RECT*);

    /* ShadeRectangle:
     *  pols (IN):
     *  plsrun (IN): plsrun of the first shaded run
     *  pptStart (IN): starting point for the shading rectangle
     *  pheightsLineWithAddSpace(IN): height of the line including SpaceBefore & SpaceAfter (main baseline,
     *                      lstflow of main line)
     *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
     *  pheightsSubline (IN): height of subline (local baseline, lstflow of subline)
     *  pheightsRunsExclTrail (IN): height of collected runs to be shaded excluding
     *                                  trailing spaces area (local baseline, lstflow of subline)
     *  pheightsRunsInclTrail (IN): height of collected runs to be shaded including
     *                                  trailing spaces area (local baseline, lstflow of subline)
     *  dupRunsExclTrail (IN): width of collected runs excluding trailing spaces area
     *  dupRunsInclTrail (IN): width of collected runs including trailing spaces area
     *  kTFlow (IN): text direction and orientation of subline
     *  kDisp (IN) : display mode - opaque, transparent
     *  prcClip (IN) : clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkDrawTextRun)(POLS, PLSRUN, BOOL, BOOL, const POINT*,
                                               LPCWSTR, const int*, DWORD, LSTFLOW, UINT,
                                               const POINT*, PCHEIGHTS, long, long,
                                               const RECT*);
    /* DrawTextRun:
     *  pols (IN):
     *  plsrun (IN):
     *  fStrikeout (IN) :
     *  fUnderline (IN) :
     *  pptText (IN): starting point for the text output
     *  lpwchRun (IN): run of characters
     *  rgDupRun (IN): widths of characters
     *  cwchRun (IN): number of characters in run
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN): display mode - opaque, transparent
     *  pptRun (IN): starting point of the run
     *  heightsPres (IN): presentation heights for this run
     *  dupRun (IN): presentation width for this run
     *  dupLimUnderline (IN): underlining limit
     *  pRectClip (IN): clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkDrawSplatLine)(POLS, enum lsksplat, LSCP, const POINT*,
                                                 PCHEIGHTS, PCHEIGHTS, PCHEIGHTS, long,
                                                 LSTFLOW, UINT, const RECT*);
    /* DrawSplatLine:
     *  pols (IN):
     *  ksplat (IN): See definitions in lsksplat.h
     *  cpSplat (IN): location of the break character which caused the splat.
     *  pptSplatLine (IN) : starting position of the splat line
     *  pheightsLineFull (IN): height of the line including SpaceBefore & SpaceAfter
     *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
     *  pheightsSubline (IN): height of subline
     *  dup (IN): distance to right margin
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN): display mode - opaque, transparent
     *  &rcClip (IN) : clipping rectangle
     */


/* Advanced typography enabling API's */

    /* Glyph enabling */

    static LSERR (WINAPI GdipLscbkFInterruptShaping)(POLS, LSTFLOW, PLSRUN, PLSRUN,
                                                     BOOL*);
    /* FInterruptShaping:
     *  pols (IN):
     *  kTFlow (IN): text direction and orientation
     *  plsrunFirst (IN): run pointer for the previous run
     *  plsrunSecond (IN): run pointer for the current run
     *  &fInterruptShaping (OUT): do you want to interrupt character shaping between these runs
    */

    static LSERR (WINAPI GdipLscbkGetGlyphs)(POLS, PLSRUN, LPCWSTR, DWORD, LSTFLOW,
                                             PGMAP, PGINDEX*, PGPROP*, DWORD*);
    /* GetGlyphs:
     *  pols (IN):
     *  plsrun (IN): run pointer of the first run
     *  pwch (IN): pointer to the string of character codes
     *  cwch (IN): number of characters to be shaped
     *  kTFlow (IN): text direction and orientation
     *  rgGmap (OUT): parallel to the char codes mapping wch->glyph info
     *  &rgGindex (OUT): array of output glyph indices
     *  &rgGprop (OUT): array of output glyph properties
     *  &cgindex (OUT): number of output glyph indices
     */

    static LSERR (WINAPI GdipLscbkGetGlyphPositions)(POLS, PLSRUN, LSDEVICE, LPWSTR,
                                                     PCGMAP, DWORD, PCGINDEX, PCGPROP,
                                                     DWORD, LSTFLOW, int*, PGOFFSET);
    /* GetGlyphPositions:
     *  pols (IN):
     *  plsrun (IN): run pointer of the first run
     *  lsDeviceID (IN): presentation or reference
     *  pwch (IN): pointer to the string of character codes
     *  pgmap (IN): array of wch->glyph mapping
     *  cwch (IN): number of characters to be shaped
     *  rgGindex (IN): array of glyph indices
     *  rgGprop (IN): array of glyph properties
     *  cgindex (IN): number glyph indices
     *  kTFlow (IN): text direction and orientation
     *  rgDu (OUT): array of widths of glyphs
     *  rgGoffset (OUT): array of offsets of glyphs
     */

    static LSERR (WINAPI GdipLscbkResetRunContents)(POLS, PLSRUN, LSCP, LSDCP, LSCP,
                                                    LSDCP);
    /* ResetRunContents:
     *  pols (IN):
     *  plsrun (IN): run pointer as returned from FetchRun
     *  cpFirstOld (IN): cpFirst before shaping
     *  dcpOld (IN): dcp before shaping
     *  cpFirstNew (IN): cpFirst after shaping
     *  dcpNew (IN): dcp after shaping
     */

    static LSERR (WINAPI GdipLscbkDrawGlyphs)(POLS, PLSRUN, BOOL, BOOL, PCGINDEX,
                                              const int*, const int*, PGOFFSET, PGPROP,
                                              PCEXPTYPE, DWORD, LSTFLOW, UINT,
                                              const POINT*, PCHEIGHTS, long, long,
                                              const RECT*);
    /* DrawGlyphs:
     *  pols (IN):
     *  plsrun (IN): run pointer of the first run
     *  fStrikeout (IN) :
     *  fUnderline (IN) :
     *  pglyph (IN): array of glyph indices
     *  rgDu (IN): array of widths of glyphs
     *  rgDuBeforeJust (IN): array of widths of glyphs before justification
     *  rgGoffset (IN): array of offsets of glyphs
     *  rgGprop (IN): array of glyph properties
     *  rgExpType (IN): array of glyph expansion types
     *  cglyph (IN): number glyph indices
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN): display mode - opaque, transparent
     *  pptRun (IN): starting point of the run
     *  heightsPres (IN): presentation heights for this run
     *  dupRun (IN): presentation width for this run
     *  dupLimUnderline (IN): underlining limit
     *  pRectClip (IN): clipping rectangle
     */

    /* Glyph justification */

    static LSERR (WINAPI GdipLscbkGetGlyphExpansionInfo)(POLS, PLSRUN, LSDEVICE, LPCWSTR,
                                                         PCGMAP, DWORD, PCGINDEX,
                                                         PCGPROP, DWORD, LSTFLOW, BOOL,
                                                         PEXPTYPE, LSEXPINFO*);
    /* GetGlyphExpansionInfo:
     *  pols (IN):
     *  plsrun (IN): run pointer of the first run
     *  lsDeviceID (IN): presentation or reference
     *  pwch (IN): pointer to the string of character codes
     *  rggmap (IN): array of wchar->glyph mapping
     *  cwch (IN): number of characters to be shaped
     *  rgglyph (IN): array of glyph indices
     *  rgProp (IN): array of glyph properties
     *  cglyph (IN): number glyph indices
     *  kTFlow (IN): text direction and orientation
     *  fLastTextChunkOnLine (IN): Last text chunk on line?
     *  rgExpType (OUT): array of glyph expansion types
     *  rgexpinfo (OUT): array of glyph expansion info
     */

    static LSERR (WINAPI GdipLscbkGetGlyphExpansionInkInfo)(POLS, PLSRUN, LSDEVICE,
                                                            GINDEX, GPROP, LSTFLOW,
                                                            DWORD, long*);
    /* GetGlyphExpansionInkInfo:
     *  pols (IN):
     *  plsrun (IN): run pointer of the first run
     *  lsDeviceID (IN): presentation or reference
     *  gindex (IN): glyph index
     *  gprop (IN): glyph properties
     *  kTFlow (IN): text direction and orientation
     *  cAddInkDiscrete (IN): number of discrete values (minus 1, because maximum is already known)
     *  rgDu (OUT): array of discrete values
     */

    /* FarEast realted typograpy issues */

    static LSERR (WINAPI GdipLscbkGetEms)(POLS, PLSRUN, LSTFLOW, PLSEMS);
    /* GetEms:
     *  pols (IN):
     *  plsrun (IN): run pointer as returned from FetchRun
     *  kTFlow (IN): text direction and orientation
     *  &lsems (OUT): different fractions of EM in appropriate pixels
     */

    static LSERR (WINAPI GdipLscbkPunctStartLine)(POLS, PLSRUN, MWCLS, WCHAR, LSACT*);
    /* PunctStartLine:
     *  pols (IN):
     *  plsrun (IN): run pointer for the char
     *  mwcls (IN): mod width class for the char
     *  wch (IN): char
     *  &lsact (OUT): action on the first char on the line
     */

    static LSERR (WINAPI GdipLscbkModWidthOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
                                                 LSACT*);
    /* ModWidthOnRun:
     *  pols (IN):
     *  plsrunFirst (IN): run pointer for the first char
     *  wchFirst (IN): first char
     *  plsrunSecond (IN): run pointer for the second char
     *  wchSecond (IN): second char
     *  &lsact (OUT): action on the last char in 1st run
     */

    static LSERR (WINAPI GdipLscbkModWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN,
                                                 WCHAR, LSACT*);
    /* ModWidthSpace:
     *  pols (IN):
     *  plsrunCur (IN): run pointer for the current run
     *  plsrunPrev (IN): run pointer for the previous char
     *  wchPrev (IN): previous char
     *  plsrunNext (IN): run pointer for the next char
     *  wchNext (IN): next char
     *  &lsact (OUT): action on space's width
     */

    static LSERR (WINAPI GdipLscbkCompOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
                                             LSPRACT*);
    /* CompOnRun:
     *  pols (IN):
     *  plsrunFirst (IN): run pointer for the first char
     *  wchFirst (IN): first char
     *  plsrunSecond (IN): run pointer for the second char
     *  wchSecond (IN): second char
     *  &lspract (OUT): prioritized action on the last char in 1st run
     */

    static LSERR (WINAPI GdipLscbkCompWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN,
                                                  WCHAR, LSPRACT*);
    /* CompWidthSpace:
     *  pols (IN):
     *  plsrunCur (IN): run pointer for the current run
     *  plsrunPrev (IN): run pointer for the previous char
     *  wchPrev (IN): previous char
     *  plsrunNext (IN): run pointer for the next char
     *  wchNext (IN): next char
     *  &lspract (OUT): prioritized action on space's width
     */


    static LSERR (WINAPI GdipLscbkExpOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
                                            LSACT*);
    /* ExpOnRun:
     *  pols (IN):
     *  plsrunFirst (IN): run pointer for the first char
     *  wchFirst (IN): first char
     *  plsrunSecond (IN): run pointer for the second char
     *  wchSecond (IN): second char
     *  &lsact (OUT): action on the last run char from 1st run
     */

    static LSERR (WINAPI GdipLscbkExpWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN,
                                                 WCHAR, LSACT*);
    /* ExpWidthSpace:
     *  pols (IN):
     *  plsrunCur (IN): run pointer for the current run
     *  plsrunPrev (IN): run pointer for the previous char
     *  wchPrev (IN): previous char
     *  plsrunNext (IN): run pointer for the next char
     *  wchNext (IN): next char
     *  &lsact (OUT): action on space's width
     */

    static LSERR (WINAPI GdipLscbkGetModWidthClasses)(POLS, PLSRUN, const WCHAR*, DWORD,
                                                      MWCLS*);
    /* GetModWidthClasses:
     *  pols (IN):
     *  plsrun (IN): run pointer for the characters
     *  rgwch (IN): array of characters
     *  cwch (IN): number of characters in the rgwch array
     *  rgmwcls(OUT): array of ModWidthClass's for chars from the rgwch array
     */

    static LSERR (WINAPI GdipLscbkGetBreakingClasses)(POLS, PLSRUN, LSCP, WCHAR, BRKCLS*,
                                                      BRKCLS*);
    /* GetBreakingClasses:
     *  pols (IN):
     *  plsrun (IN): run pointer for the char
     *  cp (IN): cp of the character
     *  wch (IN): character
     *  &brkclsFirst (OUT): breaking class for this char as the leading one in a pair
     *  &brkclsSecond (OUT): breaking class for this char as the following one in a pair
     */

    static LSERR (WINAPI GdipLscbkFTruncateBefore)(POLS, PLSRUN, LSCP, WCHAR, long,
                                                   PLSRUN, LSCP, WCHAR, long, long,
                                                   BOOL*);
    /* FTruncateBefore:
     *  pols (IN):
     *  plsrunCur (IN): plsrun of the current character
     *  cpCur (IN): cp of truncation char
     *  wchCur (IN): truncation character
     *  durCur (IN): width of truncation character
     *  plsrunPrev (IN): plsrun of the previous character
     *  cpPrev (IN): cp of the previous character
     *  wchPrev (IN): previous character
     *  durPrev (IN): width of truncation character
     *  durCut (IN): width from the RM until the end of the current character
     *  &fTruncateBefore (OUT): truncation point is before this character
     *          (if it exceeds RM)
     */

    static LSERR (WINAPI GdipLscbkCanBreakBeforeChar)(POLS, BRKCLS, BRKCOND*);
    /* CanBreakBeforeChar:
     *  pols (IN):
     *  brkcls (IN): breaking class for the char as the following one in a pair
     *  &brktxtBefore (OUT): break condition before the character
     */

    static LSERR (WINAPI GdipLscbkCanBreakAfterChar)(POLS, BRKCLS, BRKCOND*);
    /* CanBreakAfterChar:
     *  pols (IN):
     *  brkcls (IN): breaking class for the char as the leading one in a pair
     *  &brktxtAfter (OUT): break text condition after the character
     */


    static LSERR (WINAPI GdipLscbkFHangingPunct)(POLS, PLSRUN, MWCLS, WCHAR, BOOL*);
    /* FHangingPunct:
     *  pols (IN):
     *  plsrun (IN): run pointer for the char
     *  mwcls (IN): mod width class of this char
     *  wch (IN): character
     *  &fHangingPunct (OUT): can be pushed to the right margin?
     */

    static LSERR (WINAPI GdipLscbkGetSnapGrid)(POLS, WCHAR*, PLSRUN*, LSCP*, DWORD,
                                               BOOL*, DWORD*);
    /* GetGridInfo:
     *  pols (IN):
     *  rgwch (IN): array of characters
     *  rgplsrun (IN): array of corresponding plsrun's
     *  rgcp (IN): array of corresponding cp's
     *  iwch (IN): number of characters
     *  rgfSnap (OUT): array of fSnap flags for all characters
     *  pwGridNumber (OUT): number of grid points on the line
     */

    static LSERR (WINAPI GdipLscbkDrawEffects)(POLS, PLSRUN, UINT, const POINT*, LPCWSTR,
                                               const int*, const int*, DWORD, LSTFLOW,
                                               UINT, PCHEIGHTS, long, long, const RECT*);
    /* DrawTextRun:
     *  pols (IN):
     *  plsrun (IN):
     *  EffectsFlags (IN): set of client defined special effects bits
     *  ppt (IN): output location
     *  lpwchRun (IN): run of characters
     *  rgDupRun (IN): widths of characters
     *  rgDupLeftCut (IN): dup cut from the left side of the char
     *  cwchRun (IN): number of characters in run
     *  kTFlow (IN): text direction and orientation
     *  kDisp (IN): display mode - opaque, transparent
     *  heightsPres (IN): presentation heights for this run
     *  dupRun (IN): presentation width for this run
     *  dupLimUnderline (IN): underlining limit
     *  pRectClip (IN): clipping rectangle
     */

    static LSERR (WINAPI GdipLscbkFCancelHangingPunct)(POLS, LSCP, LSCP, WCHAR, MWCLS,
                                                       BOOL*);

    /* FCancelHangingPunct:
     *  pols (IN):
     *  cpLim (IN): cpLim of the line
     *  cpLastAdjustable (IN): cp of the last adjustable character on the line
     *  wch (IN): last character
     *  mwcls (IN): mod width class of this char
     *  pfCancelHangingPunct (OUT): cancel hanging punctuation?
    */

    static LSERR (WINAPI GdipLscbkModifyCompAtLastChar)(POLS, LSCP, LSCP, WCHAR, MWCLS, long, long, long*);

    /* ModifyCompAtLastChar:
     *  pols (IN):
     *  cpLim (IN): cpLim of the line
     *  cpLastAdjustable (IN): cp of the last adjustable character on the line
     *  wch (IN): last character
     *  mwcls (IN): mod width class of this char
     *  durCompLastRight (IN): suggested compression on the right side
     *  durCompLastLeft (IN): suggested compression on the left side
     *  pdurCahngeComp (OUT): change compression amount on the last char
    */

    /* Enumeration callbacks */

    static LSERR (WINAPI GdipLscbkEnumText)(POLS, PLSRUN, LSCP, LSDCP, LPCWSTR, DWORD,
                                            LSTFLOW, BOOL, BOOL, const POINT*, PCHEIGHTS,
                                            long, BOOL, long*);
    /* EnumText:
     *  pols (IN):
     *  plsrun (IN): from DNODE
     *  cpFirst (IN): from DNODE
     *  dcp (IN): from DNODE
     *  rgwch(IN): array of characters
     *  cwch(IN): number of characters
     *  lstflow (IN): text flow
     *  fReverseOrder (IN): enumerate in reverse order
     *  fGeometryProvided (IN):
     *  pptStart (IN): starting position, iff fGeometryProvided
     *  pheightsPres(IN): from DNODE, relevant iff fGeometryProvided
     *  dupRun(IN): from DNODE, relevant iff fGeometryProvided
     *  fCharWidthProvided (IN):
     *  rgdup(IN): array of character widths, iff fCharWidthProvided
    */

    static LSERR (WINAPI GdipLscbkEnumTab)(POLS, PLSRUN, LSCP, LPCWSTR, WCHAR, LSTFLOW,
                                           BOOL, BOOL, const POINT*, PCHEIGHTS, long);
    /* EnumTab:
     *  pols (IN):
     *  plsrun (IN): from DNODE
     *  cpFirst (IN): from DNODE
     *  rgwch(IN): Pointer to one Tab character
     *  wchTabLeader (IN): tab leader
     *  lstflow (IN): text flow
     *  fReverseOrder (IN): enumerate in reverse order
     *  fGeometryProvided (IN):
     *  pptStart (IN): starting position, iff fGeometryProvided
     *  pheightsPres(IN): from DNODE, relevant iff fGeometryProvided
     *  dupRun(IN): from DNODE, relevant iff fGeometryProvided
    */

    static LSERR (WINAPI GdipLscbkEnumPen)(POLS, BOOL, LSTFLOW, BOOL, BOOL, const POINT*,
                                           long, long);
    /* EnumPen:
     *  pols (IN):
     *  fBorder (IN):
     *  lstflow (IN): text flow
     *  fReverseOrder (IN): enumerate in reverse order
     *  fGeometryProvided (IN):
     *  pptStart (IN): starting position, iff fGeometryProvided
     *  dup(IN): from DNODE iff fGeometryProvided
     *  dvp(IN): from DNODE iff fGeometryProvided
    */

    /* Objects bundling */

    static LSERR (WINAPI GdipLscbkGetObjectHandlerInfo)(POLS, DWORD, void*);
    /* GetObjectHandlerInfo:
     *  pols (IN):
     *  idObj (IN): id of the object handler
     *  pObjectInfo (OUT): initialization information of the specified object
    */


    /* Debugging APIs */
    static void (WINAPI GdipLscbkAssertFailed)(char*, char*, int);




    // From LSIMETH.H

    static LSERR (WINAPI GdipLscbkCreateILSObj)(POLS, PLSC,  PCLSCBK, DWORD, PILSOBJ*);
    /* CreateILSObj
     *  pols (IN):
     *  plsc (IN): LS context
     *  plscbk (IN): callbacks
     *  idObj (IN): id of the object
     *  &pilsobj (OUT): object ilsobj
    */

    static LSERR (WINAPI GdipLscbkDestroyILSObj)(PILSOBJ);
    /* DestroyILSObj
     *  pilsobj (IN): object ilsobj
    */

    static LSERR (WINAPI GdipLscbkSetDoc)(PILSOBJ, PCLSDOCINF);
    /* SetDoc
     *  pilsobj (IN): object ilsobj
     *  lsdocinf (IN): initialization data at document level
    */

    static LSERR (WINAPI GdipLscbkCreateLNObj)(PCILSOBJ, PLNOBJ*);
    /* CreateLNObj
     *  pilsobj (IN): object ilsobj
     *  &plnobj (OUT): object lnobj
    */

    static LSERR (WINAPI GdipLscbkDestroyLNObj)(PLNOBJ);
    /* DestroyLNObj
     *  plnobj (OUT): object lnobj
    */

    static LSERR (WINAPI GdipLscbkFmt)(PLNOBJ, PCFMTIN, FMTRES*);
    /* Fmt
     *  plnobj (IN): object lnobj
     *  pfmtin (IN): formatting input
     *  &fmtres (OUT): formatting result
    */

    static LSERR (WINAPI GdipLscbkFmtResume)(PLNOBJ, const BREAKREC*, DWORD, PCFMTIN,
                                             FMTRES*);
    /* FmtResume
     *  plnobj (IN): object lnobj
     *  rgBreakRecord (IN): array of break records
     *  nBreakRecord (IN): size of the break records array
     *  pfmtin (IN): formatting input
     *  &fmtres (OUT): formatting result
    */

    static LSERR (WINAPI GdipLscbkGetModWidthPrecedingChar)(PDOBJ, PLSRUN, PLSRUN,
                                                            PCHEIGHTS, WCHAR, MWCLS,
                                                            long*);
    /* GetModWidthPrecedingChar
     *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the preceding char
     *  heightsRef (IN): height info about character
     *  wchar (IN): preceding character
     *  mwcls (IN): ModWidth class of preceding character
     *  &durChange (OUT): amount by which width of the preceding char is to be changed
    */

    static LSERR (WINAPI GdipLscbkGetModWidthFollowingChar)(PDOBJ, PLSRUN, PLSRUN,
                                                            PCHEIGHTS, WCHAR, MWCLS,
                                                            long*);
    /* GetModWidthPrecedingChar
     *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the following char
     *  heightsRef (IN): height info about character
     *  wchar (IN): following character
     *  mwcls (IN): ModWidth class of the following character
     *  &durChange (OUT): amount by which width of the following char is to be changed
    */

    static LSERR (WINAPI GdipLscbkTruncateChunk)(PCLOCCHNK, PPOSICHNK);
    /* Truncate
     *  plocchnk (IN): locchnk to truncate
     *  posichnk (OUT): truncation point
    */

    static LSERR (WINAPI GdipLscbkFindPrevBreakChunk)(PCLOCCHNK, PCPOSICHNK, BRKCOND,
                                                      PBRKOUT);
    /* FindPrevBreakChunk
     *  plocchnk (IN): locchnk to break
     *  pposichnk (IN): place to start looking for break
     *  brkcond (IN): recommmendation about the break after chunk
     *  &brkout (OUT): results of breaking
    */

    static LSERR (WINAPI GdipLscbkFindNextBreakChunk)(PCLOCCHNK, PCPOSICHNK, BRKCOND,
                                                      PBRKOUT);
    /* FindNextBreakChunk
     *  plocchnk (IN): locchnk to break
     *  pposichnk (IN): place to start looking for break
     *  brkcond (IN): recommmendation about the break before chunk
     *  &brkout (OUT): results of breaking
    */

    static LSERR (WINAPI GdipLscbkForceBreakChunk)(PCLOCCHNK, PCPOSICHNK, PBRKOUT);
    /* ForceBreakChunk
     *  plocchnk (IN): locchnk to break
     *  pposichnk (IN): place to start looking for break
     *  &brkout (OUT): results of breaking
    */

    static LSERR (WINAPI GdipLscbkSetBreak)(PDOBJ, BRKKIND, DWORD, BREAKREC*, DWORD*);
    /* SetBreak
     *  pdobj (IN): dobj which is broken
     *  brkkind (IN): Previous/Next/Force/Imposed was chosen
     *  nBreakRecord (IN): size of array
     *  rgBreakRecord (OUT): array of break records
     *  nActualBreakRecord (OUT): actual number of used elements in array
    */

    static LSERR (WINAPI GdipLscbkGetSpecialEffectsInside)(PDOBJ, UINT*);
    /* GetSpecialEffects
     *  pdobj (IN): dobj
     *  &EffectsFlags (OUT): Special effects inside of this object
    */

    static LSERR (WINAPI GdipLscbkFExpandWithPrecedingChar)(PDOBJ, PLSRUN, PLSRUN, WCHAR,
                                                            MWCLS, BOOL*);
    /* FExpandWithPrecedingChar
     *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the preceding char
     *  wchar (IN): preceding character
     *  mwcls (IN): ModWidth class of preceding character
     *  &fExpand (OUT): expand preceding character?
    */

    static LSERR (WINAPI GdipLscbkFExpandWithFollowingChar)(PDOBJ, PLSRUN, PLSRUN, WCHAR,
                                                            MWCLS, BOOL*);
    /* FExpandWithFollowingChar
     *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the following char
     *  wchar (IN): following character
     *  mwcls (IN): ModWidth class of the following character
     *  &fExpand (OUT): expand object?
    */
    static LSERR (WINAPI GdipLscbkCalcPresentation)(PDOBJ, long, LSKJUST, BOOL);
    /* CalcPresentation
     *  pdobj (IN): dobj
     *  dup (IN): dup of dobj
     *  lskj (IN): current justification mode
     *  fLastVisibleOnLine (IN): this object is last visible object on line
    */

    static LSERR (WINAPI GdipLscbkQueryPointPcp)(PDOBJ, PCPOINTUV, PCLSQIN, PLSQOUT);
    /* QueryPointPcp
     *  pdobj (IN): dobj to query
     *  ppointuvQuery (IN): query point (uQuery,vQuery)
     *  plsqin (IN): query input
     *  plsqout (OUT): query output
    */

    static LSERR (WINAPI GdipLscbkQueryCpPpoint)(PDOBJ, LSDCP, PCLSQIN, PLSQOUT);
    /* QueryCpPpoint
     *  pdobj (IN): dobj to query
     *  dcp (IN):  dcp for the query
     *  plsqin (IN): query input
     *  plsqout (OUT): query output
    */

    static LSERR (WINAPI GdipLscbkEnum)(PDOBJ, PLSRUN, PCLSCHP, LSCP, LSDCP, LSTFLOW,
                                        BOOL, BOOL, const POINT*, PCHEIGHTS, long);
    /* Enum object
     *  pdobj (IN): dobj to enumerate
     *  plsrun (IN): from DNODE
     *  plschp (IN): from DNODE
     *  cpFirst (IN): from DNODE
     *  dcp (IN): from DNODE
     *  lstflow (IN): text flow
     *  fReverseOrder (IN): enumerate in reverse order
     *  fGeometryNeeded (IN):
     *  pptStart (IN): starting position, iff fGeometryNeeded
     *  pheightsPres(IN): from DNODE, relevant iff fGeometryNeeded
     *  dupRun(IN): from DNODE, relevant iff fGeometryNeeded
    */

    static LSERR (WINAPI GdipLscbkDisplay)(PDOBJ, PCDISPIN);
    /* Display
     *  pdobj (IN): dobj to display
     *  pdispin (IN): input display info
    */

    static LSERR (WINAPI GdipLscbkDestroyDObj)(PDOBJ);
    /* DestroyDObj
     *  pdobj (IN): dobj to destroy
    */

};




Status ItemizationFiniteStateMachine(
    IN  const WCHAR            *string,
    IN  INT                     length,
    IN  INT                     state,      // Initial state
    OUT SpanVector<GpTextItem> *textItemSpanVector,
    OUT INT                    *flags       // Combined flags of all items
);


GpStatus SecondaryItemization(
    IN    const WCHAR            *string,
    IN    INT                     length,
    IN    ItemScript              numericScript,
    IN    INT                     mask,
    IN    BYTE                    defaultLevel,
    IN    BOOL                    isMetaRecording,
    OUT   SpanVector<GpTextItem> *textItemSpanVector  // InOut
);



//  Kinsoku breaking rules

UINT GetKinsokuClass(WCHAR character);
BOOL CanBreakKinsokuClass(UINT class1, UINT class2);






/////   DriverStringImager
//
//      Supports DriverString APIs


class DriverStringImager
{
public:

    DriverStringImager(
        const UINT16    *text,
        INT              glyphCount,
        const GpFont    *font,
        const PointF    *positions,
        INT              flags,
        GpGraphics      *graphics,
        const GpMatrix  *matrix
    );

    ~DriverStringImager()
    {
        if (UprightFaceRealization)  delete UprightFaceRealization;
        if (SidewaysFaceRealization) delete SidewaysFaceRealization;
    }

    virtual GpStatus GetStatus() const { return Status; }

    GpStatus Draw(
        IN const GpBrush *brush
    );

    GpStatus Measure(
        OUT RectF   *boundingBox   // Overall bounding box of cells
    );

    /////   GetDriverStringGlyphOrigins
    //
    //      Establishes glyph origins for DriverString functions when the client
    //      passes just the origin with DriverStringOptionsRealizedAdvance.

    GpStatus
    GetDriverStringGlyphOrigins(
        IN   const GpFaceRealization  *faceRealization,
        IN   INT                       firstGlyph,
        IN   INT                       glyphCount,
        IN   BOOL                      sideways,
        IN   const GpMatrix           *fontTransform,
        IN   INT                       style,
        IN   const PointF             *positions,      // position(s) in world coords
        OUT  PointF                   *glyphOrigins,   // position(s) in device coords
        OUT  PointF                   *finalPosition   // position following final glyph
    );


private:

    GpStatus MeasureString(
        OUT RectF   *boundingBox,       // Overall bounding box of cells
        OUT RectF   *baseline = NULL    // base line rectangle with 0 height
    );

    GpStatus RecordEmfPlusDrawDriverString(
        const GpBrush   *brush
    );

    GpStatus GenerateWorldOrigins();


    GpStatus VerticalAnalysis(BOOL * sidewaysRunPresent);

    GpStatus DrawGlyphRange(
        const GpFaceRealization *faceRealization,
        const GpBrush           *brush,
        INT                      first,
        INT                      length
    );

    GpStatus AddToPath(
        GpPath                  *path,
        const UINT16            *glyphs,
        const PointF            *glyphOrigins,
        INT                      glyphCount,
        GpMatrix                *fontTransform,
        BOOL                     sideways
    );



    /// Buffer usage
    //
    //  WorldOrigins
    //
    //  Points either to client position array, or to internal WorldOriginBuffer.
    //  Contains glyph advance vector origins in world coordinates.
    //  For horizontal layout the advance vector is along the horizontal baseline.
    //  For vertical layout the advance vector is down the center of the glyph.
    //  Usage:
    //     Recording metafiles
    //     Origin for measuring
    //     Origin for AddToPath
    //
    //
    //  WorldOriginBuffer
    //
    //  Allocated when client does not provide individual glyph positions.
    //  Generated by transformation from device origins.
    //
    //
    //  DeviceOrigins
    //
    //  Glyph advance vector origins in device coordinates.
    //  For horizontal layout the advance vector is along the horizontal baseline.
    //  For vertical layout the advance vector is along the vertical baseline.
    //  The vertical baseline is the baseline that rotated Western text sits on.


    const UINT16           *String;
    const UINT16           *Glyphs;             // const because the glyphs may be the input string
    AutoBuffer<UINT16,32>   GlyphBuffer;
    AutoBuffer<PointF,32>   DeviceOrigins;      //
    AutoBuffer<PointF,32>   WorldOriginBuffer;
    const PointF           *WorldOrigins;
    PointF                  OriginOffset;       // From client origin to rasterizer origin
    INT                     GlyphCount;
    const GpFont           *Font;
    const GpFontFace       *Face;
    const PointF           *Positions;
    INT                     Flags;
    GpGraphics             *Graphics;
    const GpMatrix         *GlyphTransform;
    GpMatrix                WorldToDevice;
    GpStatus                Status;
    SpanVector<BYTE>        OrientationVector;
    REAL                    EmSize;
    REAL                    WorldToIdeal;
    REAL                    FontScale;
    GpFaceRealization      *UprightFaceRealization;
    GpFaceRealization      *SidewaysFaceRealization;

    REAL                    PixelsPerEm;
    const GpMatrix         *FontTransform;
    INT                     Style;
    SizeF                   Dpi;
    AutoBuffer<REAL,32>     DeviceAdvances;
};

#endif // _IMAGER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\glyphplacement.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   glyphPlacement.hpp
*
* Abstract:
*
*   Implements glyph measurement and justification for graphicsText
*
* Created:
*
*   17th April 2000 dbrown
*
\**************************************************************************/


#ifndef _GLYPHPLACEMENT_HPP
#define _GLYPHPLACEMENT_HPP

struct tagGOFFSET;
typedef struct tagGOFFSET GOFFSET;

class GlyphImager
{
public:

    GpStatus Initialize(
        IN  const GpFaceRealization *faceRealization,
        IN  const GpMatrix          *worldToDevice,
        IN  REAL                     worldToIdeal,
        IN  REAL                     emSize,
        IN  INT                      glyphCount,
        IN  const UINT16            *glyphs,
        IN  const GpTextItem        *textItem,
        IN  const GpStringFormat    *format,
        IN  INT                      runLeadingMargin,
        IN  INT                      runTrailingMargin,
        IN  BOOL                     runLeadingEdge,       // This run at leading edge of line
        IN  BOOL                     runTrailingEdge,      // This run at trailing edge of line
        IN  const WCHAR             *string,
        IN  INT                      stringOffset,
        IN  INT                      stringLength,
        IN  const UINT16            *glyphProperties,   // glyph properties array
        IN  const INT               *glyphAdvances,     // glyph advance width array
        IN  const Point             *glyphOffsets,      // glyph offset array
        IN  const UINT16            *glyphMap,
        IN  SpanVector<UINT32>      *rangeVector,       // optional
        IN  BOOL                     renderRTL
    );


    GpStatus GetAdjustedGlyphAdvances(
        IN  const PointF    *origin,
        OUT const INT       **adjustedGlyphAdvances,
        OUT INT             *originAdjust,
        OUT INT             *trailingAdjust
    );


    GpStatus DrawGlyphs(
        IN  const PointF                &origin,       // in world units
        IN  SpanVector<const GpBrush*>  *brushVector,
        IN  GpGraphics                  *graphics,
        OUT PointF                      *cellOrigin,
        OUT const INT                  **adjustedGlyphAdvances
    );


    BOOL IsAdjusted() const
    {
        return Adjusted;
    }


private:
    BOOL IsScriptConnected() const
    {
        return TextItem->Script == ScriptArabic
           ||  TextItem->Script == ScriptSyriac
           ||  TextItem->Script == ScriptThaana
           ||  TextItem->Script == ScriptDevanagari;
    }

    GpStatus GlyphPlacementToGlyphOrigins(
        IN  const PointF   *origin,         // first cell origin
        IN  GpGraphics     *graphics,
        OUT PointF         *glyphOrigins    // device units
    );


    GpStatus FitMargins();

    GpStatus AdjustGlyphAdvances(
        INT    runGlyphOffset,
        INT    runGlyphLimit,
        INT    LeftMargin,
        INT    RightMargin
    );
    

    void GetDisplayCellOrigin(
        IN  const PointF    &origin,        // baseline origin in world units
        OUT PointF          *cellOrigin     // adjusted display origin in world units
    );




    // member variables

    const GpFontFace         *Face;
    const GpFaceRealization  *FaceRealization;
    const GpMatrix           *WorldToDevice;
    REAL                      WorldToIdeal;
    REAL                      EmSize;
    INT                       GlyphCount;
    const UINT16             *Glyphs;
    const INT                *NominalAdvances;
    const Point              *NominalOffsets;
    const UINT16             *GlyphMap;
    const UINT16             *GlyphProperties;
    const GpTextItem         *TextItem;
    const GpStringFormat     *Format;
    INT                       FormatFlags;
    GpStringAlignment         Align;
    INT                       RunLeadingMargin;
    INT                       RunTrailingMargin;
    REAL                      DeviceToIdealBaseline;
    BOOL                      Adjusted;             // If False, use nominal widths
    AutoBuffer<INT, 32>       AdjustedAdvances;
    AutoBuffer<Point, 32>     AdjustedOffsets;
    INT                       OriginAdjust;
    INT                       TrailingAdjust;       // adjustment for trailing whitespaces
    SpanVector<UINT32>       *RangeVector;
    const WCHAR              *String;
    INT                       StringOffset;         // String offset at start of run
    INT                       StringLength;
    BOOL                      RenderRTL;
    BOOL                      InitializedOk;
};


#endif // defined _GLYPHPLACEMENT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\lineservicesowner.cpp ===
/////   LineServicesOwner
//
//      Encapsulates an LSC and includes temporary buffers.


#include "precomp.hpp"



static const LSDEVRES Resolutions = {1440,1440,1440,1440};



//  Some global variables

const WCHAR ObjectTerminatorString[] = { WCH_OBJECTTERMINATOR };




/////   Linebreaking types
//
//      This table is constructed according to linebreakclass.cxx generated linebreak behavior table.
//      We assume break-CJK mode is ON. So break type 3 is the same as 2 and break type 4 is as 0.
//      (see comments in linebreakclass.cxx). =wchao, 5/15/2000=

static const LSBRK LineBreakType[5] =
{
    {1, 1},     // 0 - Break pair always
    {0, 0},     // 1 - Never break pair
    {0, 1},     // 2 - Break pair only if there're spaces in between
    {0, 1},     // 3 - (for now, same as 2)
    {1, 1}      // 4 - (for now, same as 0)
};




/////   Character configuration
//
//      Control characters used by Line Services.
//

const LSTXTCFG CharacterConfiguration =
{
    LINELENGTHHINT,
    WCH_UNDEF,                  // wchUndef
    WCH_NULL,                   // wchNull
    WCH_SPACE,                  // wchSpace
    WCH_UNDEF,                  // wchHyphen - !! we dont support hard-hyphen
    WCH_TAB,                    // wchTab
    WCH_CR,                     // wchEndPara1
    WCH_LF,                     // wchEndPara2
    WCH_PARASEPERATOR,          // wchAltEndPara
    WCH_LINEBREAK,              // wchEndLineInPara
    WCH_UNDEF,                  // wchColumnBreak
    WCH_UNDEF,                  // wchSectionBreak
    WCH_UNDEF,                  // wchPageBreak
    WCH_NONBREAKSPACE,          // wchNonBreakSpace
    WCH_NONBREAKHYPHEN,         // wchNonBreakHyphen
    WCH_NONREQHYPHEN,           // wchNonReqHyphen
    WCH_EMDASH,                 // wchEmDash
    WCH_ENDASH,                 // wchEnDash
    WCH_EMSPACE,                // wchEmSpace
    WCH_ENSPACE,                // wchEnSpace
    WCH_NARROWSPACE,            // wchNarrowSpace
    WCH_UNDEF,                  // wchOptBreak
    WCH_ZWNBSP,                 // wchNoBreak
    WCH_FESPACE,                // wchFESpace
    WCH_ZWJ,                    // wchJoiner
    WCH_ZWNJ,                   // wchNonJoiner
    WCH_UNDEF,                  // wchToReplace
    WCH_UNDEF,                  // wchReplace
    WCH_UNDEF,                  // wchVisiNull
    WCH_VISIPARASEPARATOR,      // wchVisiAltEndPara
    WCH_SPACE,                  // wchVisiEndLineInPara
    WCH_VISIPARASEPARATOR,      // wchVisiEndPara
    WCH_UNDEF,                  // wchVisiSpace
    WCH_UNDEF,                  // wchVisiNonBreakSpace
    WCH_UNDEF,                  // wchVisiNonBreakHyphe
    WCH_UNDEF,                  // wchVisiNonReqHyphen
    WCH_UNDEF,                  // wchVisiTab
    WCH_UNDEF,                  // wchVisiEmSpace
    WCH_UNDEF,                  // wchVisiEnSpace
    WCH_UNDEF,                  // wchVisiNarrowSpace
    WCH_UNDEF,                  // wchVisiOptBreak
    WCH_UNDEF,                  // wchVisiNoBreak
    WCH_UNDEF,                  // wchVisiFESpace
    WCH_OBJECTTERMINATOR,
    WCH_UNDEF,                  // wchPad
};





/////   LineServicesOwner constructor
//
//


extern const LSCBK GdipLineServicesCallbacks;

ols::ols()
:   LsContext       (NULL),
    Imager          (NULL),
    NextOwner       (NULL),
    Status          (GenericError)
{

    // Initialize context

    LSCONTEXTINFO   context;
    LSIMETHODS      lsiMethods[OBJECTID_COUNT];


    context.version = 3;    // though currently ignored by LS...


    // Loading default reverse object interface method
    //

    if (LsGetReverseLsimethods (&lsiMethods[OBJECTID_REVERSE]) != lserrNone)
    {
        return;
    }


    context.cInstalledHandlers = OBJECTID_COUNT;
    context.pInstalledHandlers = &lsiMethods[0];

    context.pols  = this;
    context.lscbk = GdipLineServicesCallbacks;

    context.fDontReleaseRuns = TRUE;         // no run to release


    // Fill up text configuration
    //
    GpMemcpy (&context.lstxtcfg, &CharacterConfiguration, sizeof(LSTXTCFG));


    if (LsCreateContext(&context, &LsContext) != lserrNone)
    {
        return;
    }


    // Give Line Services a lookup table to determine how to break a pair of
    // characters to facilitate line breaking rules.
    //

    if (LsSetBreaking(
            LsContext,
            sizeof(LineBreakType) / sizeof(LineBreakType[0]),
            LineBreakType,
            BREAKCLASS_MAX,
            (const BYTE *)LineBreakBehavior
        ) != lserrNone)
    {
        return;
    }

    if (LsSetDoc(
            LsContext,
            TRUE,           // Yes, we will be displaying
            TRUE,           // Yes, reference and presentation are the same device
            &Resolutions    // All resolution are TWIPS
        ) != lserrNone)
    {
        return;
    }


    // Successful context creation

    Status = Ok;
}



static ols *FirstFreeLineServicesOwner = NULL;

ols *ols::GetLineServicesOwner(FullTextImager *imager)
{
    ols* owner;

    // !!! Critical section required

    if (FirstFreeLineServicesOwner != NULL)
    {
        owner = FirstFreeLineServicesOwner;
        FirstFreeLineServicesOwner = FirstFreeLineServicesOwner->NextOwner;
    }
    else
    {
        owner = new ols();
    }

    if (!owner)
    {
        return NULL;
    }

    owner->Imager    = imager;
    owner->NextOwner = NULL;

    return owner;
}



void ols::ReleaseLineServicesOwner(ols **owner)
{
    // !!! Needs critical section

    ASSERT(*owner);
    (*owner)->Imager = NULL;
    (*owner)->NextOwner = FirstFreeLineServicesOwner;
    FirstFreeLineServicesOwner = (*owner);
    *owner = NULL;
}

void ols::deleteFreeLineServicesOwners()
{
    ols* thisOls = FirstFreeLineServicesOwner;
    ols* nextOls;

    // !!! Needs critical section

    while (thisOls)
    {
        nextOls = thisOls->NextOwner;
        delete thisOls;
        thisOls = nextOls;
    }
    FirstFreeLineServicesOwner = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\item.hpp ===
#ifndef _ITEM_HPP
#define _ITEM_HPP




/////   TextItemizer - header for itemization
//
//


/////   Purpose
//
//      The item analyser identifies scripts in a Unicode string for the
//      following purposes
//
//      o  Identify appropriate shaping engines
//      o  Select OpenType behaviour
//      o  Assign combining characters to appropriate runs
//      o  Assign ZWJ, ZWNJ and ZWNBSP and adjacent characters to appropriate runs
//      o  Break out control characters
//      o  Track unicode mode selection ASS/ISS, NADS/NODS, AAFS/IAFS
//      o  Separate numbers from other text


/////   Performance
//
//      Full Unicode processing is so much more expensive than support of
//      plain western text that the itemizer is split into a fast track and a
//      full track.
//
//      The fast track itemizer can handle only simple Western text, and is
//      very fast. The full itemizer identifies all Unicode scripts and splits
//      out numbers. (??? Number split out may be disabled).


/////   Combining diacritical marks
//
//      Characters is the range U+0300 - U+036F can combine with any previous
//      base character. Their presence does not change the script of the
//      run in which they are found, but does turn off the 'Simple' flag in the
//      run properties.


/////   Complex script combining characters
//
//      Complex script combining characters may generally be applied only to
//      characters of the same script (however some Arabic comining marks are
//      applicable to Syriac script).
//
//      When a complex script combining character follows anything other than
//      a suitable base character, it is broken into a separate item, so the
//      most suitable shaping engine for that item will be employed.


/////   Punctuation, symbols, ...
//
//      Punctuation, spaces, symbols and other script ambiguous characters are
//      kept with the preceeding characters, with the exception that a zero
//      width joiner (ZWJ) attaches a single preceeding ambiguous character to
//      a subsequent complex script combining character.


/////   Control characters
//
//      Most control characters are separated out into separate ScriptControl
//      runs.
//
//      The following control characters do not break Script spans:
//
//      ZWJ    - zero width joiner
//      ZWNJ   - zero width non-joiner
//      ZWNBSP - zero width no-break space
//      SHY    - soft hyphen
//
//      When such a control exists between characters of different strong types,
//      it remains with the preceeding span, and the leading join flag of
//      the subsequent span is set appropriately.


/////   Numbers
//
//      Western numbers are itemized separately. Where appropriate a number
//      includes adjacent currency symbols, '/', '#', '+', '-', ',', '.' etc. as
//      defined by the Unicode bidirectional classification.


/////   Flags
//
//      The following flags are generated with each run
//
//          Combining  - item contains combining diacritical marks
//          ZeroWidth  - item contains ZWJ, ZWNJ, ZWNBSP etc.
//          Surrogate  - item contains surrogate codepoints
//          Digits     - item contains ASCII digits


enum ItemFlags
{
    ItemCombining = 0x01,
    ItemZeroWidth = 0x02,
    ItemDigits    = 0x04,

    // The following flags are generated during run construction

    ItemSideways  = 0x08,   // Rotate glyphs 270 degrees relative to baseline
    ItemMirror    = 0x10,   // Reflect glyphs in their central vertical axis
    ItemVertical  = 0x20    // Lay out glyphs along y instead of x axis
};


/////   State
//
//      The following state is generated with each run
//
//          DigitSubstitute   - state of Unicode NADS/NODS control characters
//          SymmetricSwapping - state of Unicode ASS/ISS control characters
//          ArabicFormShaping - state of Unicode AAFS/IAFS control characters
//          LeadingJoin       - item was preceeded by a ZWJ character


enum ItemState
{
    DigitSubstitute = 1,
    SymmetricSwap   = 2,
    ArabicFormShape = 4,
    LeadingJoin     = 8
};


/////   Scripts
//
//      Unicode itemization breaks Unicode strings into spans of the following
//      scripts.



enum ItemScript
{
    ScriptNone,          // (OTL)
    ScriptLatin,         // latn  All purely Latin spans containing no combining marks
    ScriptLatinNumber,   //       Sequence of digits, +, -, currency etc.
    ScriptGreek,         // grek
    ScriptCyrillic,      // cyrl
    ScriptArmenian,      // armn
    ScriptHebrew,        // hebr
    ScriptArabic,        // arab
    ScriptSyriac,        // syrc
    ScriptThaana,        // thaa
    ScriptDevanagari,    // deva
    ScriptBengali,       // beng
    ScriptGurmukhi,      // guru
    ScriptGujarati,      // gujr
    ScriptOriya,         // orya
    ScriptTamil,         // taml
    ScriptTelugu,        // telu
    ScriptKannada,       // knda
    ScriptMalayalam,     // mlym
    ScriptSinhala,       // sinh
    ScriptThai,          // thai
    ScriptLao,           // lao
    ScriptTibetan,       // tibt
    ScriptMyanmar,       // mymr
    ScriptGeorgian,      // geor
    ScriptEthiopic,      // ethi
    ScriptCherokee,      // cher
    ScriptCanadian,      // cans  Unified Canadian Aboriginal Syllabics
    ScriptOgham,         //
    ScriptRunic,         //
    ScriptKhmer,         // khmr
    ScriptMongolian,     // mong
    ScriptBraille,       //
    ScriptBopomofo,      // bopo
    ScriptIdeographic,   // hani  Includes ideographs in the surrogate range
    ScriptHangulJamo,    // jamo
    ScriptHangul,        // hang
    ScriptKana,
    ScriptHiragana,      // hira
    ScriptKatakana,      // kata
    ScriptHan,
    ScriptYi,            // yi
    ScriptPrivate,       //       Private use characters in the BMP or surrogate pages
    ScriptSurrogate,     //       Surrogate characters not otherwise classified
    ScriptControl,       //       Control characters other than ZWJ, ZWNJ, ZWNBSP

    // Scripts generated by secondary classification

    ScriptArabicNum,
    ScriptThaiNum,
    ScriptDevanagariNum,
    ScriptTamilNum,
    ScriptBengaliNum,
    ScriptGurmukhiNum,
    ScriptGujaratiNum,
    ScriptOriyaNum,
    ScriptTeluguNum,
    ScriptKannadaNum,
    ScriptMalayalamNum,
    ScriptTibetanNum,
    ScriptLaoNum,
    ScriptKhmerNum,
    ScriptMyanmarNum,
    ScriptMongolianNum,
    ScriptUrduNum,
    ScriptFarsiNum,
    ScriptHindiNum,
    ScriptContextNum,    // For Arabic/Farsi context digit substitution     

    ScriptMirror,        // Generated in classifier where symmetric swapping required

    ScriptMax            // (maximum boundary)
};



enum ItemScriptClass
{
    StrongClass,       // Alphabetic or other letters
    WeakClass,         // Whitespace, punctuation, symbols
    DigitClass,        // Digits
    SimpleMarkClass,   // Mark displayable by all engines
    ComplexMarkClass,  // Mark requiring specific shaping engine
    ControlClass,      // Control characters
    JoinerClass        // Specifically ZWJ
};



struct  CharacterAttribute {
    ItemScript               Script         :8;
    ItemScriptClass          ScriptClass    :8;
    INT                      Flags          :16;
};

// Character attribute flags

#define CHAR_FLAG_NOTSIMPLE    0x0080L   // Don't try to optimise with the simple imager
#define CHAR_FLAG_DIGIT        0x0100L   // U+0030 - U+0039 only
#define CHAR_FLAG_RTL          0x0200L
// #define CHAR_FLAG_FE           0x0400L  // Already defined as 2000 in USP_PRIV.HXX


extern CharacterAttribute CharacterAttributes[CHAR_CLASS_MAX];




class GpTextItem
{
public:
    GpTextItem(
        ItemScript script,
        INT        state,
        INT        flags = 0,
        BYTE       level = 0
    )
    :   Script (script),
        State  (state),
        Flags  (flags),
        Level  (level)
    {}

    GpTextItem()
    :   Script (ScriptNone),
        State  (0),
        Flags  (0),
        Level  (0)
    {}

    GpTextItem(INT i) :
        Script (ScriptNone),
        State  (0),
        Flags  (0),
        Level  (0)
    {
        ASSERT(i==0); // For NULL costruction only
    }

    GpTextItem& operator= (const GpTextItem &right)
    {
        Flags  = right.Flags;
        State  = right.State;
        Script = right.Script;
        Level  = right.Level;

        return *this;
    }

    bool operator== (const GpTextItem &right) const
    {
        return
                Script == right.Script
            &&  Flags  == right.Flags
            &&  State  == right.State
            &&  Level  == right.Level;
    }

    bool operator== (INT right) const
    {
        ASSERT(right==0);  // For comparison with NULL only
        return Script == ScriptNone;
    }

    ItemScript Script : 8;
    INT        Flags  : 8;
    INT        State  : 8;  // Unicode state flags
    BYTE       Level  : 8;  // Bidi level
};



#endif // _ITEM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\itemizer.cpp ===
////    Itemizer - Analyse Unicode into script sequences
//
//      David C Brown [dbrown] 27th November 1999.
//
//      Copyright (c) 1999-2000, Microsoft Corporation. All rights reserved.


#include "precomp.hpp"




/////   Unicode block classification
//
//      See also ftp://ftp.unicode.org/Public/UNIDATA/Blocks.txt
//
//      The following table maps unicode blocks to scripts.
//
//      Where the script column contains '-' characters in this range are
//      ambiguous in script and will be classified as part of the previous
//      run.
//
//      The script column shows the script of all or most of the characters in
//      the block. Many blocks contain script ambiguous characters, and some
//      blocks contain characters from multiple scripts.
//
//      Start End   Block Name                             Script
//      0000  007F  Basic Latin                            ScriptLatin
//      0080  00FF  Latin-1 Supplement                     ScriptLatin
//      0100  017F  Latin Extended-A                       ScriptLatin
//      0180  024F  Latin Extended-B                       ScriptLatin
//      0250  02AF  IPA Extensions                         ScriptLatin
//      02B0  02FF  Spacing Modifier Letters               ScriptLatin
//      0300  036F  Combining Diacritical Marks            -
//      0370  03FF  Greek                                  ScriptGreek
//      0400  04FF  Cyrillic                               ScriptCyrillic
//      0530  058F  Armenian                               ScriptArmenian
//      0590  05FF  Hebrew                                 ScriptHebrew
//      0600  06FF  Arabic                                 ScriptArabic
//      0700  074F  Syriac                                 ScriptSyriac
//      0780  07BF  Thaana                                 ScriptThaana
//      0900  097F  Devanagari                             ScriptDevanagari
//      0980  09FF  Bengali                                ScriptBengali
//      0A00  0A7F  Gurmukhi                               ScriptGurmukhi
//      0A80  0AFF  Gujarati                               ScriptGujarati
//      0B00  0B7F  Oriya                                  ScriptOriya
//      0B80  0BFF  Tamil                                  ScriptTamil
//      0C00  0C7F  Telugu                                 ScriptTelugu
//      0C80  0CFF  Kannada                                ScriptKannada
//      0D00  0D7F  Malayalam                              ScriptMalayalam
//      0D80  0DFF  Sinhala                                ScriptSinhala
//      0E00  0E7F  Thai                                   ScriptThai
//      0E80  0EFF  Lao                                    ScriptLao
//      0F00  0FFF  Tibetan                                ScriptTibetan
//      1000  109F  Myanmar                                ScriptMyanmar
//      10A0  10FF  Georgian                               ScriptGeorgian
//      1100  11FF  Hangul Jamo                            ScriptHangul Jamo
//      1200  137F  Ethiopic                               ScriptEthiopic
//      13A0  13FF  Cherokee                               ScriptCherokee
//      1400  167F  Unified Canadian Aboriginal Syllabics  ScriptCanadian
//      1680  169F  Ogham                                  ScriptOgham
//      16A0  16FF  Runic                                  ScriptRunic
//      1780  17FF  Khmer                                  ScriptKhmer
//      1800  18AF  Mongolian                              ScriptMongolian
//      1E00  1EFF  Latin Extended Additional              ScriptLatin
//      1F00  1FFF  Greek Extended                         ScriptGreek
//      2000  206F  General Punctuation                    Various inc ScriptControl
//      2070  209F  Superscripts and Subscripts            -
//      20A0  20CF  Currency Symbols                       -
//      20D0  20FF  Combining Marks for Symbols            -
//      2100  214F  Letterlike Symbols                     -
//      2150  218F  Number Forms                           -
//      2190  21FF  Arrows                                 -
//      2200  22FF  Mathematical Operators                 -
//      2300  23FF  Miscellaneous Technical                -
//      2400  243F  Control Pictures                       -
//      2440  245F  Optical Character Recognition          -
//      2460  24FF  Enclosed Alphanumerics                 -
//      2500  257F  Box Drawing                            -
//      2580  259F  Block Elements                         -
//      25A0  25FF  Geometric Shapes                       -
//      2600  26FF  Miscellaneous Symbols                  -
//      2700  27BF  Dingbats                               -
//      2800  28FF  Braille Patterns                       ScriptBraille
//      2E80  2EFF  CJK Radicals Supplement                ScriptIdeographic
//      2F00  2FDF  Kangxi Radicals                        ScriptIdeographic
//      2FF0  2FFF  Ideographic Description Characters     ScriptIdeographic
//      3000  303F  CJK Symbols and Punctuation            -
//      3040  309F  Hiragana                               ScriptIdeographic
//      30A0  30FF  Katakana                               ScriptIdeographic
//      3100  312F  Bopomofo                               ScriptIdeographic
//      3130  318F  Hangul Compatibility Jamo              ScriptIdeographic
//      3190  319F  Kanbun                                 ScriptIdeographic
//      31A0  31BF  Bopomofo Extended                      ScriptIdeographic
//      3200  32FF  Enclosed CJK Letters and Months        -
//      3300  33FF  CJK Compatibility                      ScriptIdeographic
//      3400  4DB5  CJK Unified Ideographs Extension A     ScriptIdeographic
//      4E00  9FFF  CJK Unified Ideographs                 ScriptIdeographic
//      A000  A48F  Yi Syllables                           ScriptIdeographic
//      A490  A4CF  Yi Radicals                            ScriptIdeographic
//      AC00  D7A3  Hangul Syllables                       ScriptIdeographic
//      D800  DB7F  High Surrogates                        ScriptSurrogate
//      DB80  DBFF  High Private Use Surrogates            ScriptSurrogate
//      DC00  DFFF  Low Surrogates                         ScriptSurrogate
//      E000  F8FF  Private Use                            ScriptPrivate
//      F900  FAFF  CJK Compatibility Ideographs           ScriptIdeographic
//      FB00  FB4F  Alphabetic Presentation Forms          -
//      FB50  FDFF  Arabic Presentation Forms-A            ScriptArabic
//      FE20  FE2F  Combining Half Marks                   ScriptCombining
//      FE30  FE4F  CJK Compatibility Forms                ScriptIdeographic
//      FE50  FE6F  Small Form Variants                    -
//      FE70  FEFE  Arabic Presentation Forms-B            ScriptArabic
//      FEFF  FEFF  Specials                               -
//      FF00  FFEF  Halfwidth and Fullwidth Forms          Various
//      FFF0  FFFD  Specials                               -


CharacterAttribute CharacterAttributes[CHAR_CLASS_MAX] = {
//                                                                Script              ScriptClass       Flags
/*  WOB_ - Open Brackets for inline-note (JIS 1 or 19)        */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NOPP - Open parenthesis (JIS 1)                           */  {ScriptLatin,       WeakClass,        0},
/*  NOPA - Open parenthesis (JIS 1)                           */  {ScriptLatin,       WeakClass,        0},
/*  NOPW - Open parenthesis (JIS 1)                           */  {ScriptLatin,       WeakClass,        0},
/*  HOP_ - Open parenthesis (JIS 1)                           */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOP_ - Open parenthesis (JIS 1)                           */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOP5 - Open parenthesis, Big 5 (JIS 1)                    */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NOQW - Open quotes (JIS 1)                                */  {ScriptLatin,       WeakClass,        0},
/*  AOQW - Open quotes (JIS 1)                                */  {ScriptLatin,       WeakClass,        0},
/*  WOQ_ - Open quotes (JIS 1)                                */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WCB_ - Close brackets for inline-note (JIS 2 or 20)       */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NCPP - Close parenthesis (JIS 2)                          */  {ScriptLatin,       WeakClass,        0},
/*  NCPA - Close parenthesis (JIS 2)                          */  {ScriptLatin,       WeakClass,        0},
/*  NCPW - Close parenthesis (JIS 2)                          */  {ScriptLatin,       WeakClass,        0},
/*  HCP_ - Close parenthesis (JIS 2)                          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WCP_ - Close parenthesis (JIS 2)                          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WCP5 - Close parenthesis, Big 5 (JIS 2)                   */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NCQW - Close quotes (JIS 2)                               */  {ScriptLatin,       WeakClass,        0},
/*  ACQW - Close quotes (JIS 2)                               */  {ScriptLatin,       WeakClass,        0},
/*  WCQ_ - Close quotes (JIS 2)                               */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  ARQW - Right single quotation mark (JIS 2)                */  {ScriptLatin,       WeakClass,        0},
/*  NCSA - Comma (JIS 2 or 15)                                */  {ScriptLatin,       WeakClass,        0},
/*  HCO_ - Comma (JIS 2 or 15)                                */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WC__ - Comma (JIS 2)                                      */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WCS_ - Comma (JIS 2)                                      */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WC5_ - Comma, Big 5 (JIS 2)                               */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WC5S - Comma, Big 5 (JIS 2)                               */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NKS_ - Kana sound marks (JIS 3)                           */  {ScriptKana,        StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WKSM - Kana sound marks (JIS 3)                           */  {ScriptKana,        WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WIM_ - Iteration marks (JIS 3)                            */  {ScriptIdeographic, StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NSSW - Symbols which can?t start a line (JIS 3)           */  {ScriptLatin,       WeakClass,        0},
/*  WSS_ - Symbols that can?t start a line (JIS 3)            */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WHIM - Hiragana iteration marks (JIS 3)                   */  {ScriptHiragana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WKIM - Katakana iteration marks (JIS 3)                   */  {ScriptKatakana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NKSL - Katakana that can?t start a line (JIS 3)           */  {ScriptKatakana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WKS_ - Katakana that can?t start a line (JIS 3)           */  {ScriptKatakana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WKSC - Katakana that can?t start a line (JIS 3)           */  {ScriptKatakana,    ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  WHS_ - Hiragana that can?t start a line (JIS 3)           */  {ScriptHiragana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NQFP - Question/Exclamation (JIS 4)                       */  {ScriptLatin,       WeakClass,        0},
/*  NQFA - Question/Exclamation (JIS 4)                       */  {ScriptLatin,       WeakClass,        0},
/*  WQE_ - Question/Exclamation (JIS 4)                       */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WQE5 - Question/Exclamation, Big 5 (JIS 4)                */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NKCC - Kana centered characters (JIS 5)                   */  {ScriptKana,        WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WKC_ - Kana centered characters (JIS 5)                   */  {ScriptKana,        WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NOCP - Other centered characters (JIS 5)                  */  {ScriptLatin,       WeakClass,        0},
/*  NOCA - Other centered characters (JIS 5)                  */  {ScriptLatin,       WeakClass,        0},
/*  NOCW - Other centered characters (JIS 5)                  */  {ScriptLatin,       WeakClass,        0},
/*  WOC_ - Other centered characters (JIS 5)                  */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOCS - Other centered characters (JIS 5)                  */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOC5 - Other centered characters, Big 5 (JIS 5)           */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOC6 - Other centered characters, Big 5 (JIS 5)           */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  AHPW - Hyphenation point (JIS 5)                          */  {ScriptLatin,       WeakClass,        0},
/*  NPEP - Period (JIS 6 or 15)                               */  {ScriptLatin,       WeakClass,        0},
/*  NPAR - Period (JIS 6 or 15)                               */  {ScriptLatin,       StrongClass,      0},
/*  HPE_ - Period (JIS 6 or 15)                               */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WPE_ - Period (JIS 6)                                     */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WPES - Period (JIS 6)                                     */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WPE5 - Period, Big 5 (JIS 6)                              */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NISW - Inseparable characters (JIS 7)                     */  {ScriptLatin,       WeakClass,        0},
/*  AISW - Inseparable characters (JIS 7)                     */  {ScriptLatin,       WeakClass,        0},
/*  NQCS - Glue characters (no JIS)                           */  {ScriptLatin,       StrongClass,      0},
/*  NQCW - Glue characters (no JIS)                           */  {ScriptControl,     JoinerClass,      CHAR_FLAG_NOTSIMPLE},
/*  NQCC - Glue characters (no JIS)                           */  {ScriptLatin,       SimpleMarkClass,  CHAR_FLAG_NOTSIMPLE},
/*  NPTA - Prefix currencies and symbols (JIS 8)              */  {ScriptLatin,       WeakClass,        0},
/*  NPNA - Prefix currencies and symbols (JIS 8)              */  {ScriptLatin,       WeakClass,        0},
/*  NPEW - Prefix currencies and symbols (JIS 8)              */  {ScriptLatin,       WeakClass,        0},
/*  NPEH - Prefix currencies and symbols (JIS 8)              */  {ScriptHebrew,      WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NPEV - Prefix currencies and symbols (JIS 8)              */  {ScriptLatin,       StrongClass,      0},
/*  APNW - Prefix currencies and symbols (JIS 8)              */  {ScriptLatin,       WeakClass,        0},
/*  HPEW - Prefix currencies and symbols (JIS 8)              */  {ScriptLatin,       WeakClass,        0},
/*  WPR_ - Prefix currencies and symbols (JIS 8)+B58          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NQEP - Postfix currencies and symbols (JIS 9)             */  {ScriptLatin,       WeakClass,        0},
/*  NQEW - Postfix currencies and symbols (JIS 9)             */  {ScriptLatin,       WeakClass,        0},
/*  NQNW - Postfix currencies and symbols (JIS 9)             */  {ScriptLatin,       WeakClass,        0},
/*  AQEW - Postfix currencies and symbols (JIS 9)             */  {ScriptLatin,       WeakClass,        0},
/*  AQNW - Postfix currencies and symbols (JIS 9)             */  {ScriptLatin,       WeakClass,        0},
/*  AQLW - Postfix currencies and symbols (JIS 9)             */  {ScriptLatin,       StrongClass,      0},
/*  WQO_ - Postfix currencies and symbols (JIS 9)             */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NSBL - Space(JIS 15 or 17)                                */  {ScriptLatin,       WeakClass,        0},
/*  WSP_ - Space (JIS 10)                                     */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WHI_ - Hiragana except small letters (JIS 11)             */  {ScriptHiragana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NKA_ - Katakana except small letters Ideographic (JIS 12) */  {ScriptKatakana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WKA_ - Katakana except small letters (JIS 12)             */  {ScriptKatakana,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  ASNW - Ambiguous symbols (JIS 12 or 18)                   */  {ScriptLatin,       WeakClass,        0},
/*  ASEW - Ambiguous symbols (JIS 12 or 18)                   */  {ScriptLatin,       WeakClass,        0},
/*  ASRN - Ambiguous symbols (JIS 12 or 18)                   */  {ScriptLatin,       StrongClass,      0},
/*  ASEN - Ambiguous symbols (JIS 12 or 18)                   */  {ScriptLatin,       StrongClass,      0},
/*  ALA_ - Ambiguous Latin (JIS 12 or 18)                     */  {ScriptLatin,       StrongClass,      0},
/*  AGR_ - Ambiguous Greek (JIS 12 or 18)                     */  {ScriptLatin,       StrongClass,      0},
/*  ACY_ - Ambiguous Cyrillic (JIS 12 or 18)                  */  {ScriptLatin,       StrongClass,      0},
/*  WID_ - Han Ideographs (JIS 12, 14S or 14D)                */  {ScriptHan,         StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WPUA - End user defined characters (JIS 12, 14S or 14D)   */  {ScriptPrivate,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NHG_ - Hangul Ideographs (JIS 12)                         */  {ScriptHangul,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WHG_ - Hangul Ideographs (JIS 12)                         */  {ScriptHangul,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WCI_ - Compatibility Ideographs (JIS 12)                  */  {ScriptIdeographic, StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NOI_ - Other Ideographs (JIS 12)                          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOI_ - Other Ideographs (JIS 12)                          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOIC - Other Ideographs (JIS 12)                          */  {ScriptIdeographic, ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  WOIL - Other Ideographs (JIS 12)                          */  {ScriptIdeographic, StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WOIS - Other Ideographs (JIS 12)                          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  WOIT - Other Ideographs (JIS 12)                          */  {ScriptIdeographic, WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NSEN - Superscript/Subscript/Attachments (JIS 13)         */  {ScriptLatin,       StrongClass,      0},
/*  NSET - Superscript/Subscript/Attachments (JIS 13)         */  {ScriptLatin,       WeakClass,        0},
/*  NSNW - Superscript/Subscript/Attachments (JIS 13)         */  {ScriptLatin,       WeakClass,        0},
/*  ASAN - Superscript/Subscript/Attachments (JIS 13)         */  {ScriptLatin,       StrongClass,      0},
/*  ASAE - Superscript/Subscript/Attachments (JIS 13)         */  {ScriptLatin,       StrongClass,      0},
/*  NDEA - Digits (JIS 15 or 18)                              */  {ScriptLatin,       DigitClass,       CHAR_FLAG_DIGIT},
/*  WD__ - Digits (JIS 15 or 18)                              */  {ScriptLatin,       StrongClass,      0},
/*  NLLA - Basic Latin (JIS 16 or 18)                         */  {ScriptLatin,       StrongClass,      0},
/*  WLA_ - Basic Latin (JIS 16 or 18)                         */  {ScriptIdeographic, StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NWBL - Word breaking Spaces (JIS 17)                      */  {ScriptLatin,       WeakClass,        0},
/*  NWZW - Word breaking Spaces (JIS 17)                      */  {ScriptControl,     JoinerClass,      CHAR_FLAG_NOTSIMPLE},
/*  NPLW - Punctuation in Text (JIS 18)                       */  {ScriptLatin,       StrongClass,      0},
/*  NPZW - Punctuation in Text (JIS 18)                       */  {ScriptControl,     JoinerClass,      CHAR_FLAG_NOTSIMPLE},
/*  NPF_ - Punctuation in Text (JIS 18)                       */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NPFL - Punctuation in Text (JIS 18)                       */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NPNW - Punctuation in Text (JIS 18)                       */  {ScriptLatin,       WeakClass,        0},
/*  APLW - Punctuation in text (JIS 12 or 18)                 */  {ScriptLatin,       StrongClass,      0},
/*  APCO - Punctuation in text (JIS 12 or 18)                 */  {ScriptLatin,       SimpleMarkClass,  CHAR_FLAG_NOTSIMPLE},
/*  ASYW - Soft Hyphen (JIS 12 or 18)                         */  {ScriptLatin,       WeakClass,        0},
/*  NHYP - Hyphen (JIS 18)                                    */  {ScriptLatin,       WeakClass,        0},
/*  NHYW - Hyphen (JIS 18)                                    */  {ScriptLatin,       WeakClass,        0},
/*  AHYW - Hyphen (JIS 12 or 18)                              */  {ScriptLatin,       WeakClass,        0},
/*  NAPA - Apostrophe (JIS 18)                                */  {ScriptLatin,       WeakClass,        0},
/*  NQMP - Quotation mark (JIS 18)                            */  {ScriptLatin,       WeakClass,        0},
/*  NSLS - Slash (JIS 18)                                     */  {ScriptLatin,       WeakClass,        0},
/*  NSF_ - Non space word break (JIS 18)                      */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NSBB - Non space word break (JIS 18)                      */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NSBS - Non space word break (JIS 18)                      */  {ScriptLatin,       WeakClass,        0},
/*  NLA_ - Latin (JIS 18)                                     */  {ScriptLatin,       StrongClass,      0},
/*  NLQ_ - Latin Punctuation in text (JIS 18)                 */  {ScriptLatin,       StrongClass,      0},
/*  NLQC - Latin Punctuation in text (JIS 18)                 */  {ScriptLatin,       StrongClass,      0},
/*  NLQN - Latin Punctuation in text (JIS 18)                 */  {ScriptLatin,       WeakClass,        0},
/*  ALQ_ - Latin Punctuation in text (JIS 12 or 18)           */  {ScriptLatin,       WeakClass,        0},
/*  ALQN - Latin Punctuation in text (JIS 12 or 18)           */  {ScriptLatin,       WeakClass,        0},
/*  NGR_ - Greek (JIS 18)                                     */  {ScriptGreek,       StrongClass,      0},
/*  NGRN - Greek (JIS 18)                                     */  {ScriptGreek,       WeakClass,        0},
/*  NGQ_ - Greek Punctuation in text (JIS 18)                 */  {ScriptGreek,       StrongClass,      0},
/*  NGQN - Greek Punctuation in text (JIS 18)                 */  {ScriptGreek,       StrongClass,      0},
/*  NCY_ - Cyrillic (JIS 18)                                  */  {ScriptCyrillic,    StrongClass,      0},
/*  NCYP - Cyrillic Punctuation in text (JIS 18)              */  {ScriptCyrillic,    StrongClass,      0},
/*  NCYC - Cyrillic Punctuation in text (JIS 18)              */  {ScriptCyrillic,    ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NAR_ - Armenian (JIS 18)                                  */  {ScriptArmenian,    StrongClass,      0},
/*  NAQL - Armenian Punctuation in text (JIS 18)              */  {ScriptArmenian,    StrongClass,      0},
/*  NAQN - Armenian Punctuation in text (JIS 18)              */  {ScriptArmenian,    StrongClass,      0},
/*  NHB_ - Hebrew (JIS 18)                                    */  {ScriptHebrew,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NHBC - Hebrew (JIS 18)                                    */  {ScriptHebrew,      ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NHBW - Hebrew (JIS 18)                                    */  {ScriptHebrew,      WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NHBR - Hebrew (JIS 18)                                    */  {ScriptHebrew,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NASR - Arabic (JIS 18)                                    */  {ScriptArabic,      WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NAAR - Arabic (JIS 18)                                    */  {ScriptArabic,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NAAC - Arabic (JIS 18)                                    */  {ScriptArabic,      ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NAAD - Arabic (JIS 18)                                    */  {ScriptArabic,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NAED - Arabic (JIS 18)                                    */  {ScriptArabic,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NANW - Arabic (JIS 18)                                    */  {ScriptArabic,      WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NAEW - Arabic (JIS 18)                                    */  {ScriptArabic,      WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NAAS - Arabic (JIS 18)                                    */  {ScriptLatin,       StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NHI_ - Devanagari (JIS 18)                                */  {ScriptDevanagari,  StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NHIN - Devanagari (JIS 18)                                */  {ScriptDevanagari,  StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NHIC - Devanagari (JIS 18)                                */  {ScriptDevanagari,  ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NHID - Devanagari (JIS 18)                                */  {ScriptDevanagari,  StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NBE_ - Bengali (JIS 18)                                   */  {ScriptBengali,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NBEC - Bengali (JIS 18)                                   */  {ScriptBengali,     ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NBED - Bengali (JIS 18)                                   */  {ScriptBengali,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NBET - Bengali (JIS 18)                                   */  {ScriptBengali,     WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NGM_ - Gurmukhi (JIS 18)                                  */  {ScriptGurmukhi,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NGMC - Gurmukhi (JIS 18)                                  */  {ScriptGurmukhi,    ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NGMD - Gurmukhi (JIS 18)                                  */  {ScriptGurmukhi,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NGJ_ - Gujarati (JIS 18)                                  */  {ScriptGujarati,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NGJC - Gujarati (JIS 18)                                  */  {ScriptGujarati,    ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NGJD - Gujarati (JIS 18)                                  */  {ScriptGujarati,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NOR_ - Oriya (JIS 18)                                     */  {ScriptOriya,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NORC - Oriya (JIS 18)                                     */  {ScriptOriya,       ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NORD - Oriya (JIS 18)                                     */  {ScriptOriya,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTA_ - Tamil (JIS 18)                                     */  {ScriptTamil,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTAC - Tamil (JIS 18)                                     */  {ScriptTamil,       ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NTAD - Tamil (JIS 18)                                     */  {ScriptTamil,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTE_ - Telugu (JIS 18)                                    */  {ScriptTelugu,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTEC - Telugu (JIS 18)                                    */  {ScriptTelugu,      ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NTED - Telugu (JIS 18)                                    */  {ScriptTelugu,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NKD_ - Kannada (JIS 18)                                   */  {ScriptKannada,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NKDC - Kannada (JIS 18)                                   */  {ScriptKannada,     ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NKDD - Kannada (JIS 18)                                   */  {ScriptKannada,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NMA_ - Malayalam (JIS 18)                                 */  {ScriptMalayalam,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NMAC - Malayalam (JIS 18)                                 */  {ScriptMalayalam,   ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NMAD - Malayalam (JIS 18)                                 */  {ScriptMalayalam,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTH_ - Thai (JIS 18)                                      */  {ScriptThai,        StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTHC - Thai (JIS 18)                                      */  {ScriptThai,        StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTHD - Thai (JIS 18)                                      */  {ScriptThai,        StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTHT - Thai (JIS 18)                                      */  {ScriptThai,        WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NLO_ - Lao (JIS 18)                                       */  {ScriptLao,         StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NLOC - Lao (JIS 18)                                       */  {ScriptLao,         ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NLOD - Lao (JIS 18)                                       */  {ScriptLao,         StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTI_ - Tibetan (JIS 18)                                   */  {ScriptTibetan,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTIC - Tibetan (JIS 18)                                   */  {ScriptTibetan,     ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NTID - Tibetan (JIS 18)                                   */  {ScriptTibetan,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTIN - Tibetan (JIS 18)                                   */  {ScriptTibetan,     WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NGE_ - Georgian (JIS 18)                                  */  {ScriptGeorgian,    StrongClass,      0},
/*  NGEQ - Georgian Punctuation in text (JIS 18)              */  {ScriptGeorgian,    StrongClass,      0},
/*  NBO_ - Bopomofo (JIS 18)                                  */  {ScriptBopomofo,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NBSP - No Break space (no JIS)                            */  {ScriptLatin,       WeakClass,        0},
/*  NBSS - No Break space (no JIS)                            */  {ScriptLatin,       WeakClass,        0},
/*  NOF_ - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NOBS - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NOEA - Other symbols (JIS 18)                             */  {ScriptLatin,       WeakClass,        0},
/*  NONA - Other symbols (JIS 18)                             */  {ScriptLatin,       WeakClass,        0},
/*  NONP - Other symbols (JIS 18)                             */  {ScriptLatin,       WeakClass,        0},
/*  NOEP - Other symbols (JIS 18)                             */  {ScriptLatin,       WeakClass,        0},
/*  NONW - Other symbols (JIS 18)                             */  {ScriptLatin,       StrongClass,      0},
/*  NOEW - Other symbols (JIS 18)                             */  {ScriptLatin,       WeakClass,        0},
/*  NOLW - Other symbols (JIS 18)                             */  {ScriptLatin,       StrongClass,      0},
/*  NOCO - Other symbols (JIS 18)                             */  {ScriptLatin,       SimpleMarkClass,  CHAR_FLAG_NOTSIMPLE},
/*  NOEN - Other symbols (JIS 18)                             */  {ScriptArabic,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NOBN - Other symbols (JIS 18)                             */  {ScriptLatin,       ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NSBN - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NOLE - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NORE - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NOPF - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NOLO - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NORO - Other symbols (JIS 18)                             */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NET_ - Ethiopic                                           */  {ScriptEthiopic,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NETP - Ethiopic                                           */  {ScriptEthiopic,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NETD - Ethiopic                                           */  {ScriptEthiopic,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NCA_ - Canadian Syllabics                                 */  {ScriptCanadian,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NCH_ - Cherokee                                           */  {ScriptCherokee,    StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WYI_ - Yi                                                 */  {ScriptYi,          StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WYIN - Yi                                                 */  {ScriptYi,          WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NBR_ - Braille                                            */  {ScriptBraille,     WeakClass,        0},
/*  NRU_ - Runic                                              */  {ScriptRunic,       StrongClass,      0},
/*  NOG_ - Ogham                                              */  {ScriptOgham,       StrongClass,      0},
/*  NOGS - Ogham                                              */  {ScriptLatin,       WeakClass,        0},
/*  NOGN - Ogham                                              */  {ScriptOgham,       WeakClass,        0},
/*  NSI_ - Sinhala                                            */  {ScriptSinhala,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NSIC - Sinhala                                            */  {ScriptSinhala,     ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NTN_ - Thaana                                             */  {ScriptThaana,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NTNC - Thaana                                             */  {ScriptThaana,      ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NKH_ - Khmer                                              */  {ScriptKhmer,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NKHC - Khmer                                              */  {ScriptKhmer,       ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NKHD - Khmer                                              */  {ScriptKhmer,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NKHT - Khmer                                              */  {ScriptKhmer,       WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NBU_ - Myanmar                                            */  {ScriptMyanmar,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NBUC - Myanmar                                            */  {ScriptMyanmar,     ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NBUD - Myanmar                                            */  {ScriptMyanmar,     StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NSY_ - Syriac                                             */  {ScriptSyriac,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NSYP - Syriac                                             */  {ScriptSyriac,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/*  NSYC - Syriac                                             */  {ScriptSyriac,      ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NSYW - Syriac                                             */  {ScriptControl,     JoinerClass,      CHAR_FLAG_NOTSIMPLE},
/*  NMO_ - Mongolian                                          */  {ScriptMongolian,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NMOC - Mongolian                                          */  {ScriptMongolian,   ComplexMarkClass, CHAR_FLAG_NOTSIMPLE},
/*  NMOD - Mongolian                                          */  {ScriptMongolian,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  NMOB - Mongolian                                          */  {ScriptControl,     ControlClass,     CHAR_FLAG_NOTSIMPLE},
/*  NMON - Mongolian                                          */  {ScriptMongolian,   WeakClass,        CHAR_FLAG_NOTSIMPLE},
/*  NHS_ - High Surrogate                                     */  {ScriptSurrogate,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  WHT_ - High Surrogate                                     */  {ScriptSurrogate,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  LS__ - Low Surrogate                                      */  {ScriptSurrogate,   StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  XNW_ - Unassigned                                         */  {ScriptLatin,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  XNWA - Unassigned                                         */  {ScriptArabic,      StrongClass,      CHAR_FLAG_NOTSIMPLE},
/*  XNWB - Unassigned                                         */  {ScriptControl,     JoinerClass,      CHAR_FLAG_NOTSIMPLE},

/* CHAR_GCP_R                                                 */  {ScriptLatin,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/* CHAR_GCP_EN                                                */  {ScriptLatin,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
/* CHAR_GCP_AN                                                */  {ScriptArabic,      StrongClass,      CHAR_FLAG_NOTSIMPLE | CHAR_FLAG_RTL},
/* CHAR_GCP_HN                                                */  {ScriptLatin,       StrongClass,      CHAR_FLAG_NOTSIMPLE},
};



















/////   Itemization finite state machine
//
//      States:
//
//          <all scripts>
//


Status ItemizationFiniteStateMachine(
    IN  const WCHAR            *string,
    IN  INT                     length,
    IN  INT                     state,      // Initial state
    OUT SpanVector<GpTextItem> *textItemSpanVector,
    OUT INT                    *flags       // Combined flags of all items
)
{
    GpStatus status = Ok;
    GpTextItem previousClass(
        ScriptLatin,
        state
    );

    INT  previousStart = 0;
    INT  i             = 0;

    *flags = 0;

    INT              ch;
    CHAR_CLASS       characterClass;
    ItemScriptClass  scriptClass;
    ItemScript       script;

    INT fastLimit = -1;
    DoubleWideCharMappedString dwchString(string, length);

    INT combinedFlags = 0;

    // Fast loop - handles only strongltr and weak class groups

    while (    i < length
           &&  fastLimit < 0)
    {
        ch             = dwchString[i];

        characterClass = CharClassFromCh(ch);
        scriptClass    = CharacterAttributes[characterClass].ScriptClass;
        combinedFlags |= CharacterAttributes[characterClass].Flags;

        switch (scriptClass)
        {
        case StrongClass:
            script = CharacterAttributes[characterClass].Script;
            if (previousClass.Script != script)
            {
                if (i > 0)
                {
                    status = textItemSpanVector->SetSpan(
                        previousStart,
                        i - previousStart,
                        previousClass
                    );
                    if (status != Ok)
                        return status;
                    previousStart = i;
               }
                previousClass.Script = script;
                previousClass.Flags  = 0;
           }
            break;

        case WeakClass:
            break;

        case DigitClass:
            previousClass.Flags |= ItemDigits;
            break;

        default:
            // Break out of fast loop.
            fastLimit = i;
            i = length;
            break;
       }

        i++;
   }


    if (fastLimit >= 0)
    {
        // Finish the job in the full loop

        INT  nextStart     = 0;
        INT  lastJoiner    = -1;
        INT  lastZWJ       = -1;
        INT  lastWeak      = -1;  // Position of last weak encountered

        i = fastLimit;

        if (i>0) {
            // Set lastWeak appropriately
            ch             = dwchString[i-1];

            characterClass = CharClassFromCh(ch);
            if (CharacterAttributes[characterClass].ScriptClass == WeakClass)
            {
                lastWeak = i-1;
           }
       }
        else
        {
            // Full loop starts at start of string
            previousStart = -1;
       }

        while (i < length)
        {
            ch             = dwchString[i];

            characterClass = CharClassFromCh(ch);
            scriptClass    = CharacterAttributes[characterClass].ScriptClass;
            script         = CharacterAttributes[characterClass].Script;
            combinedFlags |= CharacterAttributes[characterClass].Flags;


            // Process classes appropriately
            // Set nextStart if a new run is to be started

            if (    previousClass.Script == ScriptControl
                &&  script != ScriptControl)
            {
                nextStart = i;
           }
            else
            {
                switch (scriptClass)
                {
                case StrongClass:
                    if (previousClass.Script != script)
                    {
                        nextStart = i;
                   }
                    break;

                case WeakClass:
                    lastWeak = i;
                    break;

                case DigitClass:
                    previousClass.Flags |= ItemDigits;
                    break;

                case SimpleMarkClass:
                    previousClass.Flags |= ItemCombining;
                    break;

                case ComplexMarkClass:
                    if (    previousClass.Script != script
                        &&  (    previousClass.Script != ScriptSyriac
                             ||  script != ScriptArabic))
                    {
                        if (    lastJoiner == i-1   // Special case for weak,ZWJ,mark
                            &&  lastWeak   == i-2)
                        {
                            nextStart = lastWeak;
                            if (nextStart <= previousStart)
                            {
                                previousClass.Script = script;
                           }
                       }
                        else
                        {
                            nextStart = i;
                       }
                   }
                    break;

                case ControlClass:
                    if (previousClass.Script != ScriptControl)
                    {
                        nextStart = i;
                   }
                    break;

                case JoinerClass:
                    lastJoiner = i;
                    previousClass.Flags |= ItemZeroWidth;
                    if (ch == U_ZWJ)    // Zero width joiner
                    {
                        lastZWJ = i;
                   }
                    break;

                default:
                    if (previousClass.Script == ScriptControl)
                    {
                        nextStart = i;
                   }
               }
           }

            if (nextStart > previousStart)
            {
                if (previousStart >= 0)
                {
                    status = textItemSpanVector->SetSpan(
                        previousStart,
                        nextStart - previousStart,
                        previousClass
                    );
                    if (status != Ok)
                        return status;
               }
                previousClass.Script = script;
                *flags |= previousClass.Flags;
                previousClass.Flags = 0;
                previousStart = nextStart;

                if (lastZWJ == nextStart-1)
                {
                    previousClass.State |= LeadingJoin;
               }
                else
                {
                    previousClass.State &= ~LeadingJoin;
               }
           }

            i++;
       }
   }




    // Final item

    if (length > previousStart)
    {
        status = textItemSpanVector->SetSpan(
            previousStart,
            length - previousStart,
            previousClass
        );
   }

    *flags = combinedFlags;

    return status;
}






/////  SecondaryItemization
//
//      Itemizes for secondary classification requirements:
//
//      - Mirrored glyphs (in RTL runs only)
//      - Numerics (for digit substitution only)
//      - Auto sideways (for vertical run only)


enum SecondaryItemizationState {
    Sstart,
    SleadET,
    Snumeric,
    StrailCS,
    SmirSub,
    SmirXfm,
    Ssideways
};

enum SecondaryItemizationAction {
    SeNone = 0,
    SeMark,
    SePlain,
    SePlainToM,
    SeNum,
    SeNumToM,
    SeMirSub,
    SeMirXfm,
    SeSideways
};


SecondaryItemizationState NextState[7][7] = {
//                 Sstart     SleadET    Snumeric   StrailCS   SmirSub    SmirXfm    Ssideways
/*ScOther      */ {Sstart,    Sstart,    Sstart,    Sstart,    Sstart,    Sstart,    Sstart},
/*ScSideways   */ {Ssideways, Ssideways, Ssideways, Ssideways, Ssideways, Ssideways, Ssideways},
/*ScMirrorSubst*/ {SmirSub,   SmirSub,   SmirSub,   SmirSub,   SmirSub,   SmirSub,   SmirSub},
/*ScMirrorXfrom*/ {SmirXfm,   SmirXfm,   SmirXfm,   SmirXfm,   SmirXfm,   SmirXfm,   SmirXfm},
/*ScEN         */ {Snumeric,  Snumeric,  Snumeric,  Snumeric,  Snumeric,  Snumeric,  Snumeric},
/*ScCS         */ {Sstart,    Sstart,    StrailCS,  Sstart,    Sstart,    Sstart,    Sstart},
/*ScET         */ {SleadET,   SleadET,   Snumeric,  Sstart,    Sstart,    Sstart,    Sstart}
};

SecondaryItemizationAction NextAction[7][7] = {
//                 Sstart     SleadET    Snumeric   StrailCS   SmirSub    SmirXfm    Ssideways
/*ScOther      */ {SeNone,    SeNone,    SeNum,     SeNumToM,  SeMirSub,  SeMirXfm,  SeSideways},
/*ScSideways   */ {SePlain,   SePlain,   SeNum,     SeNumToM,  SeMirSub,  SeMirXfm,  SeNone},
/*ScMirrorSubst*/ {SePlain,   SePlain,   SeNum,     SeNumToM,  SeNone,    SeMirXfm,  SeSideways},
/*ScMirrorXfrom*/ {SePlain,   SePlain,   SeNum,     SeNumToM,  SeMirSub,  SeNone,    SeSideways},
/*ScEN         */ {SePlain,   SePlainToM,SeNone,    SeNone,    SeMirSub,  SeMirXfm,  SeSideways},
/*ScCS         */ {SeNone,    SeNone,    SeMark,    SeNumToM,  SeMirSub,  SeMirXfm,  SeSideways},
/*ScET         */ {SeMark,    SeNone,    SeNone,    SeNumToM,  SeMirSub,  SeMirXfm,  SeSideways}
};



//+----------------------------------------------------------------------------
//
//  SecondaryCharClass
//
//  Entry   ch - 32 bit Unicode codepoint for classification
//
//  Return  Character secondary classification
//
//-----------------------------------------------------------------------------

const BYTE SecondaryCharClass(INT ch)
{
    // either Unicode plane 0 or in surrogate range
    assert(ch <= 0x10FFFF);

    // Plane 0 codepoint
    if( ch <= 0xFFFF)
    {
        return SecondaryClassificationLookup[ch >> 8][ch & 0xFF];
    }
    else if((ch >= 0x020000) && (ch <= 0x03FFFF))
    {
        // Though, we don't have an official assignment here yet,
        // Uniscribe used to handle this area as CJK extension
        return ScNNFN; // FE upright character
    }
    else
    {
        // Currently, we don't have any plane1 or higher allocation.
        // Let's treat it as unassigned codepoint.
        return ScNNNN; // No special handling
    }
}




GpStatus SecondaryItemization(
    IN    const WCHAR            *string,
    IN    INT                     length,
    IN    ItemScript              numericScript,
    IN    INT                     mask,
    IN    BYTE                    defaultLevel,
    IN    BOOL                    isMetaRecording,
    OUT   SpanVector<GpTextItem> *textItemSpanVector  // InOut
)
{
    GpStatus status = Ok;
    INT   secondaryClass;
    INT   lastStrongCharacter = 0; // INT since we might be dealing with surrogate

    GpCharacterClass lastCharacterClass       = CLASS_INVALID;
    GpCharacterClass lastStrongCharacterClass = CLASS_INVALID;

    SpanRider<GpTextItem> itemRider(textItemSpanVector);

    INT mark = -1;

    SecondaryItemizationState state = Sstart;

    INT runStart = 0;
    INT charIndex = 0;

    // We need to index to the end of the string + 1 so that
    // the end-state is set properly...
    while(charIndex <= length)
    {
        // start out with the code-point as the wchar - we might
        // have to make this a surrogate code-point from 2 wchars
        int c = 0;
        BOOL fSurrogate = FALSE; // we will need to increment after the run...
        
        if (charIndex < length)
        {
            // Don't index past the end of the string...
            c = string[charIndex];

            // Check for a high surrogate...
            if (c >= 0xD800 && c < 0xDC00)
            {
                if (charIndex+1 < length)
                {
                    WCHAR wcNext = string[charIndex+1];

                    if (wcNext >= 0xDC00 && wcNext < 0xE000)
                    {
                        // Translate this to the proper surrogate codepoint!
                        c = (((c & 0x3FF) << 10) | (wcNext & 0x3FF)) + 0x10000;

                        fSurrogate = TRUE;
                    }
                }

                // If the fSurrogate flag is not set at this point, then the
                // character will be treated as an independent run. Non-paired
                // surrogates are run-breaks.
            }

            BYTE baseClass = SecondaryCharClass(c);
            secondaryClass = ScFlagsToScFE[ScBaseToScFlags[baseClass] & mask];
            
            if (numericScript == ScriptContextNum)
            {
                // we get the overhead only if we have context numeric mode
                lastCharacterClass = s_aDirClassFromCharClass[CharClassFromCh(c)];

                if (AL == lastCharacterClass || R == lastCharacterClass || L == lastCharacterClass)
                {
                    lastStrongCharacterClass = lastCharacterClass;
                    lastStrongCharacter      = c;
                }
            }
        }
        else
        {
            // Force end state
            secondaryClass = ScOther;
        }

        SecondaryItemizationState  nextState = NextState[secondaryClass][state];
        SecondaryItemizationAction action    = NextAction[secondaryClass][state];

        if (action)
        {
            INT runLimit  = 0;
            INT flags     = 0;
            INT setScript = 0;

            switch (action)
            {
            case SeMark:      mark = charIndex;                                break;
            case SePlain:     runStart = charIndex;                            break;
            case SePlainToM:  runStart = mark;                                 break;
            case SeNum:       runLimit = charIndex; setScript = numericScript; break;
            case SeNumToM:    runLimit = mark;      setScript = numericScript; break;
            case SeMirSub:    runLimit = charIndex; setScript = ScriptMirror;  break;
            case SeMirXfm:    runLimit = charIndex; flags     = ItemMirror;    break;
            case SeSideways:  runLimit = charIndex; flags     = ItemSideways;  break;
            }

            if (runLimit > 0)
            {
                while (runStart < runLimit)
                {
                    itemRider.SetPosition(runStart);

                    UINT uniformLength = itemRider.GetUniformLength();

                    INT limit = (uniformLength < (UINT) (runLimit - runStart))
                                ? runStart + uniformLength
                                : runLimit;

                    GpTextItem item = itemRider.GetCurrentElement();

                    if ((item.Level & 1) == 0 || isMetaRecording) // Don't mirror in LTR runs or Meta file recording
                    {
                        flags &= ~ItemMirror;
                        if (setScript == ScriptMirror)
                        {
                            setScript = 0;
                        }
                    }

                    if (setScript)
                    {
                        if (setScript != ScriptContextNum)
                        {
                            item.Script = (ItemScript)setScript;
                        }
                        else 
                        {
                            if ((lastStrongCharacterClass == CLASS_INVALID && defaultLevel==1) ||
                                (item.Script == ScriptArabic) ||
                                (lastStrongCharacter == 0x200F)) // RLM
                            {
                                item.Script = ScriptArabicNum;
                            }
                            // otherwise keep item.Script as it is.
                        }
                    }

                    if (flags)
                    {
                        item.Flags |= flags;
                    }

                    if (setScript | flags)
                    {
                        status = itemRider.SetSpan(runStart, limit-runStart, item);
                        if (status != Ok)
                            return status;
                    }

                    runStart = limit;
                }
            }
        }

        // If this was a surrogate, we need to increment past the low
        // surrogate value...
        if (fSurrogate)
            charIndex++;

        // Move on to the next character...
        charIndex++;

        state = nextState;
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\paragraph.hpp ===
#ifndef _PARAGRAPH_HPP
#define _PARAGRAPH_HPP


/////   Paragraph - Describes a paragraph in Line Services terms
//
//


struct Paragraph
{
    INT imagerStringOffset; // First char of para in imager terms
    INT imagerStringLimit;  // First char of next para in imager terms

};
#endif // _PARAGRAPH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\lineservicesowner.hpp ===
#ifndef _LINESERVICESCONTEXT_HPP
#define _LINESERVICESCONTEXT_HPP



//  Some external global variables

extern const WCHAR ObjectTerminatorString[];




//  Some constants

#define OBJECTID_REVERSE            0
#define OBJECTID_COUNT              1   // !! only support reversal for now

#define LINELENGTHHINT              70



//  Control characters used by Line Services

#define WCH_UNDEF                   0x0001          // wchUndef
#define WCH_NULL                    0x0000          // wchNull
#define WCH_SPACE                   0x0020          // wchSpace
#define WCH_HYPHEN                  0x002D          // wchHyphen
#define WCH_TAB                     0x0009          // wchTab
#define WCH_CR                      0x000D          // wchEndPara1
#define WCH_LF                      0x000A          // wchEndPara2
#define WCH_PARASEPERATOR           0x2029          // wchAltEndPara
#define WCH_LINEBREAK               0x0084          // wchEndLineInPara
#define WCH_NONBREAKSPACE           0x00A0          // wchNonBreakSpace
#define WCH_NONBREAKHYPHEN          0x2011          // wchNonBreakHyphen
#define WCH_NONREQHYPHEN            0x2010          // wchNonReqHyphen
#define WCH_EMDASH                  0x2014          // wchEmDash
#define WCH_ENDASH                  0x2013          // wchEnDash
#define WCH_EMSPACE                 0x2003          // wchEmSpace
#define WCH_ENSPACE                 0x2002          // wchEnSpace
#define WCH_NARROWSPACE             0x2009          // wchNarrowSpace
#define WCH_ZWNBSP                  0xFEFF          // wchNoBreak
#define WCH_FESPACE                 0x3000          // wchFESpace
#define WCH_ZWJ                     0x200D          // wchJoiner
#define WCH_ZWNJ                    0x200C          // wchNonJoiner
#define WCH_VISIPARASEPARATOR       0x00B6          // wchVisiEndPara

#define WCH_OBJECTTERMINATOR        0x009F          // object terminator



#define IsEOP(ch)   (BOOL)((ch) == WCH_CR || (ch) == WCH_LF)




/////   Line services context
//
//      Contains the PLSC context pointer.
//
//      Contains temporary buffers used suring glyphing and positioning
//      operations.
//
//      A pool of available contexts is mainitained.
//
//      The TextImager BuildLines function starts by obtaining a context and
//      linking it to the imager. The context is passed to Line Services for
//      all calls during the line building process.
//
//      The context is returned to the free pool when all lines are built.


struct ols  // Line services owner - type required by Line Services
{
public:
    ols();

    ~ols()
    {
        if (LsContext)
        {
            LsDestroyContext(LsContext);
        }
    }

    GpStatus GetStatus() {return Status;}

    static ols *GetLineServicesOwner(FullTextImager *imager);

    static void ReleaseLineServicesOwner(ols **owner);

    static void deleteFreeLineServicesOwners();

    FullTextImager *GetImager() {return Imager;}

    PLSC GetLsContext() {return LsContext;}

private:

    PLSC  LsContext;

    // At any one time, this context beongs either to a TextImager (Imager set
    // and NextContext NULL), or to the free list (Imager NULL, and NextCOntext
    // may be set).

    FullTextImager *Imager;     // Set only while attached to an imager
    ols            *NextOwner;  // Next in free owner pool

    GpStatus        Status;     // Creation status
};


#endif _LINESERVICESCONTEXT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\lineservicescallbacks.cpp ===
/////   LineServicesCallbacks
//
//

#include "precomp.hpp"




/////   LineServices callback functions
//
//      A set of callbacks that do the real work.
//


////    FetchRun
//
//      We return to Line Services the longest character run that is consistent
//      in those attributes that line services is interested in.
//
//      The changes that affect line services are:
//
//          UINT fUnderline
//          UINT fStrike
//          UINT fShade
//          UINT fBorder
//      Changes in vertical metrics.

LSERR WINAPI FullTextImager::GdipLscbkFetchRun(
    POLS      ols,            // [IN]  text imager instance
    LSCP      position,       // [IN]  position to fetch
    LPCWSTR   *string,        // [OUT] string of run
    DWORD     *length,        // [OUT] length of string
    BOOL      *isHidden,      // [OUT] Is this run hidden?
    PLSCHP    chp,            // [OUT] run's character properties
    PLSRUN    *run            // [OUT] fetched run
)
{
    FullTextImager *imager = ols->GetImager();
    GpStatus status = imager->BuildRunsUpToAndIncluding(position);
    if (status != Ok)
    {
        return lserrInvalidParameter;
    }

    if (!imager->RunRider.SetPosition(position))
    {
        return lserrInvalidParameter;
    }

    *run    = imager->RunRider.GetCurrentElement();
    *length = imager->RunRider.GetUniformLength();


    #if TRACERUNSPANS
        TERSE(("Fetch run String[%x] potentially run %x l %x\n",
            position,
            *run,
            *length
        ));
    #endif


    INT offsetIntoRun = position - imager->RunRider.GetCurrentSpanStart();


    *isHidden = FALSE;      // assume no hidden text

    GpMemset (chp, 0, sizeof(LSCHP));

    status = Ok;
    switch((*run)->RunType)
    {
        case lsrun::RunText:
        {
            if (offsetIntoRun == 0)
            {
                *string = imager->String + (*run)->ImagerStringOffset;
            }
            else
            {
                // We want our runs to match Line Services runs so that when Line
                // Services calls GetGlyphs, its strings will always be synchronised
                // with the start of our runs.
                //
                // Therefore, if this FetchRun does not start in the middle of one
                // of our runs, then we need to split our run.
                //
                // This strategy as recommended by Sergey Genkin 16th Dec 99.

                ASSERT(offsetIntoRun > 0);

                lsrun *previousRun = imager->RunRider.GetCurrentElement();
                ASSERT(previousRun == (*run));

                INT newRunLength = imager->RunRider.GetCurrentSpan().Length - offsetIntoRun;
                ASSERT(newRunLength > 0);

                // Split current run at new position.

                lsrun *newRun = new lsrun(*previousRun);

                if (!newRun)
                {
                    return lserrOutOfMemory;
                }

                newRun->ImagerStringOffset += offsetIntoRun;
                newRun->CharacterCount = newRunLength;


                #if TRACERUNSPANS
                    TERSE(("Splitting lsrun %x String[%x] l %x into %x and %x @ %x\n",
                        *run,
                        (*run)->ImagerStringOffset,
                        imager->RunRider.GetCurrentSpan().Length,
                        offsetIntoRun,
                        newRunLength,
                        newRun
                    ));
                #endif


                // Copy glyphs

                INT firstGlyph    = previousRun->GlyphMap[offsetIntoRun];
                INT newGlyphCount = previousRun->GlyphCount - firstGlyph;

                if (firstGlyph <= 0 || newGlyphCount <= 0)
                {
                    delete newRun;
                    return lserrInvalidRun;
                }

                newRun->GlyphCount      = newGlyphCount;
                previousRun->GlyphCount = firstGlyph;

                newRun->Glyphs          = new GINDEX[newGlyphCount];
                newRun->GlyphProperties = new GPROP[newGlyphCount];
                newRun->GlyphMap        = new GMAP[newRunLength];
                
                if (   !newRun->Glyphs
                    || !newRun->GlyphProperties
                    || !newRun->GlyphMap)
                {
                    delete newRun;
                    return lserrOutOfMemory;
                }

                memcpy(newRun->Glyphs,          previousRun->Glyphs + firstGlyph,          sizeof(GINDEX) * newGlyphCount);
                memcpy(newRun->GlyphProperties, previousRun->GlyphProperties + firstGlyph, sizeof(GPROP) * newGlyphCount);

                for (INT i=0; i<newRunLength; i++)
                {
                    newRun->GlyphMap[i] = previousRun->GlyphMap[i+offsetIntoRun] - firstGlyph;
                }

                previousRun->CharacterCount = offsetIntoRun;


                status = imager->RunRider.SetSpan(position, newRunLength, newRun);
                if (status != Ok)
                {
                    delete newRun;
                    return lserrOutOfMemory;
                }

                #if TRACERUNSPANS
                    TERSE(("SetSpan(position %x, length %x, run %x)  ",
                        position,
                        newRunLength,
                        newRun
                    ));
                    imager->RunVector.Dump();
                #endif

                *string = imager->String + newRun->ImagerStringOffset;
                *length = newRunLength;
                *run    = newRun;
            }

            //  Truncate for hidden text

            SpanRider<INT> visiRider(&imager->VisibilityVector);
            visiRider.SetPosition((*run)->ImagerStringOffset);

            *length = min(*length, visiRider.GetUniformLength());
            *isHidden = visiRider.GetCurrentElement() == VisibilityHide;

            break;
        }

        case lsrun::RunEndOfParagraph:
            *string =   L"\x0d\x0a"
                      + offsetIntoRun;
            break;

        case lsrun::RunLevelUp:
            chp->idObj  = OBJECTID_REVERSE;
            *string     = L" ";
            return lserrNone;

        case lsrun::RunLevelDown:
            chp->idObj  = idObjTextChp;
            *string     = ObjectTerminatorString;
            return lserrNone;

        case lsrun::RunLevelSeparator:
            // !!! Not implemented
            *string = NULL;
            break;
    }

    //  Set LS character properties
    //

    INT style = SpanRider<INT>(&imager->StyleVector)[(*run)->ImagerStringOffset];

    chp->idObj       = idObjTextChp;
    chp->fGlyphBased = (*run)->RunType == lsrun::RunText ? TRUE : FALSE;
    chp->fUnderline  = (style & FontStyleUnderline) ? TRUE : FALSE;
    chp->fStrike     = style & FontStyleStrikeout ? TRUE : FALSE;

    return lserrNone;
}



LSERR WINAPI FullTextImager::GdipLscbkFetchTabs(
    POLS        ols,                // [IN] text imager instance
    LSCP        position,           // [IN] position within a paragraph to fetch
    PLSTABS     tab,                // [OUT] tab structre to be fetched
    BOOL        *hangingTab,        // [OUT] TRUE: there is hanging tab in tabs array
    long        *hangingTabWidth,   // [OUT] width of hanging tab
    WCHAR       *hangingTabLeadChar // [OUT] leading character of hanging tab
)
{
    FullTextImager  *imager = ols->GetImager();
    imager->RunRider.SetPosition(position);


    imager->GetTabStops (
        imager->RunRider.GetCurrentElement()->ImagerStringOffset,
        (INT *)&tab->iTabUserDefMac,
        &tab->pTab,
        (INT *)&tab->duaIncrementalTab
    );


    // No hanging tab

    *hangingTab         = FALSE;
    *hangingTabWidth    =
    *hangingTabLeadChar = 0;

    return lserrNone;
}



LSERR WINAPI FullTextImager::GdipLscbkGetBreakThroughTab(
    POLS        ols,                // [IN] text imager instance
    long        rightMagin,         // [IN] right margin for breaking
    long        tabPosition,        // [IN] breakthrough tab position
    long        *newRightMargin     // [OUT] new right margin
)
{
    *newRightMargin = tabPosition;
    return lserrNone;
}



LSERR WINAPI FullTextImager::GdipLscbkFetchPap(
    POLS      ols,            // [IN] text imager instance
    LSCP      position,       // [IN] position to fetch
    PLSPAP    pap             // [OUT] paragraph properties
)
{
    #if TRACERUNSPANS
        TERSE(("FetchPap String[%x]\n"));
    #endif

    FullTextImager *imager = ols->GetImager();

    GpStatus status = imager->BuildRunsUpToAndIncluding(position);
    if (status != Ok)
    {
        return lserrInvalidParameter;
    }

    if (!imager->RunRider.SetPosition(position))
    {
        return lserrInvalidParameter;
    }

    GpMemset (pap, 0, sizeof(LSPAP));

    pap->cpFirst        = // LS doesnt really care where the paragraph starts
    pap->cpFirstContent = position;
    pap->lskeop         = lskeopEndPara12;
    pap->lskal          = lskalLeft;  // We do all alignment ourselves


    //  Apply linebreak rules for breaking classes.

    pap->grpf = fFmiApplyBreakingRules;


    if (imager->IsFormatVertical())
    {
        //  For underlining purpose, vertical text always has
        //  paragraph flowing west.

        pap->lstflow = lstflowSW;
    }
    else
    {
        //  We can have paragraphs with different reading order

        const GpStringFormat *format = SpanRider<const GpStringFormat *>(
            &imager->FormatVector)[imager->RunRider.GetCurrentElement()->ImagerStringOffset];

        pap->lstflow =    imager->IsFormatRightToLeft(format)
                       ?  lstflowWS
                       :  lstflowES;
    }
    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkFGetLastLineJustification (
    POLS         ols,                    // [IN] text imager instance
    LSKJUST      kJustification,         // [IN] kind of justification
    LSKALIGN     kAlignment,             // [IN] kind of alignment
    ENDRES       endr,                   // [IN] format result
    BOOL         *justifyLastLineOkay,   // [OUT] Should last line be fully justified?
    LSKALIGN     *kAlignmentLine         // [OUT] kind of justification of this line
)
{
    //  Just say no to justify last line
    //
    *justifyLastLineOkay = FALSE;
    *kAlignmentLine = kAlignment;
    return lserrNone;
}





////    Run management
//
//


LSERR WINAPI FullTextImager::GdipLscbkGetRunCharWidths(
    POLS      ols,            // [IN] text imager instance
    PLSRUN    run,            // [IN] run
    LSDEVICE  device,         // [IN] kind of device
    LPCWSTR   string,         // [IN] string of run
    DWORD     length,         // [IN] length of string
    long      maxWidth,       // [IN] maximum allowance of run's width
    LSTFLOW   flow,           // [IN] text flow
    int       *advance,       // [OUT] array of character's advance width
    long      *width,         // [OUT] run's total width
    long      *countAdvance   // [OUT] number of element of advance width array
)
{
    ASSERT(length > 0);

    UINT i;
    REAL fontToIdeal;

    #if TRACERUNSPANS
        WCHAR str[200];
        memcpy(str, string, min(200,length)*2);
        str[min(length,199)] = 0;
        TERSE(("GetRunCharWidths run %x, length %x, maxwidth %x: '%S'\n", run, length, maxWidth, str));
    #endif

    FullTextImager *imager = ols->GetImager();

    //  LS uses these values as a hint for run fetching.
    //
    //  Too small of return width causes over-fetching. Too great causes LS
    //  collapsing the line.
    //

    switch (run->RunType)
    {
    case lsrun::RunText:
        {
            fontToIdeal =     (run->EmSize / run->Face->GetDesignEmHeight())
                           *  imager->WorldToIdeal;

            const GpStringFormat *format = SpanRider<const GpStringFormat *>(&imager->FormatVector)[run->ImagerStringOffset];
            double tracking = format ? format->GetTracking() : DefaultTracking;

            run->Face->GetShapingCache()->GetRunCharWidths(
                &run->Item,
                SpanRider<INT>(&imager->StyleVector)[run->ImagerStringOffset],
                string,
                length,
                run->FormatFlags,
                TOREAL(fontToIdeal * tracking),
                maxWidth,
                advance,
                (INT *)width,
                (INT *)countAdvance
            );
        }
        break;


    default:
        // Not really text. Return 1/4 emHeight for each 'glyph'.

        /*
        INT dummyGlyphAdvance = GpRound(float(   (run->EmSize / 4)
                                              *  imager->WorldToIdeal));
        advance[0] = dummyGlyphAdvance;
        *width     = dummyGlyphAdvance;

        i = 1;
        while (    i < length
               &&  *width < maxWidth)
        {
            advance[i] = 0; //dummyGlyphAdvance;
            //*width    += dummyGlyphAdvance;
            i++;
        }

        *countAdvance = i;

        */

        GpMemset(advance, 0, sizeof(int) * length);
        *width = 0;
        *countAdvance = length;

        break;
    }

    return lserrNone;
}




LSERR WINAPI FullTextImager::GdipLscbkGetRunTextMetrics(
    POLS     ols,            // [IN] text imager instance
    PLSRUN   run,            // [IN] run
    LSDEVICE device,         // [IN] kind of device
    LSTFLOW  flow,           // [IN] text flow
    PLSTXM   metrics         // [OUT] font metrics of run
)
{
    #if TRACERUNSPANS
        TERSE(("GetRunTextMetrics run %x\n", run));
    #endif

    FullTextImager *imager = ols->GetImager();
    ASSERT (run && run->Face);

    // Return metrics based on requested font. Font fallback does not affect
    // metrics.

    const GpFontFamily *family = SpanRider<const GpFontFamily *>(&imager->FamilyVector)
                                 [run->ImagerStringOffset];
    INT                 style  = SpanRider<INT>(&imager->StyleVector)
                                 [run->ImagerStringOffset];
    REAL                emSize = SpanRider<REAL>(&imager->SizeVector)
                                 [run->ImagerStringOffset];
    const GpFontFace *face     = family->GetFace(style);

    if (!face)
    {
        return FontStyleNotFound;
    }

    REAL fontToIdeal = (emSize / face->GetDesignEmHeight()) * imager->WorldToIdeal;

    metrics->dvAscent          = GpRound(float(   face->GetDesignCellAscent()
                                               *  fontToIdeal));
    metrics->dvDescent         = GpRound(float(   face->GetDesignCellDescent()
                                               *  fontToIdeal));
    metrics->dvMultiLineHeight = GpRound(float(   face->GetDesignLineSpacing()
                                               *  fontToIdeal));;
    metrics->fMonospaced       = FALSE;

    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkGetRunUnderlineInfo (
    POLS       ols,                // [IN] text imager instance
    PLSRUN     run,                // [IN] run
    PCHEIGHTS  height,             // [IN] height of the run
    LSTFLOW    flow,               // [IN] text flow
    PLSULINFO  underline           // [OUT] underline information
)
{
    FullTextImager *imager = ols->GetImager();
    ASSERT (run && run->Face);

    REAL fontToIdeal =     (run->EmSize / run->Face->GetDesignEmHeight())
                        *  imager->WorldToIdeal;

    GpMemset (underline, 0, sizeof(LSULINFO));

    underline->cNumberOfLines = 1;

    underline->dvpFirstUnderlineOffset = GpRound(float(
        -run->Face->GetDesignUnderscorePosition() * fontToIdeal));

    underline->dvpFirstUnderlineSize = GpRound(float(
        run->Face->GetDesignUnderscoreSize() * fontToIdeal));

    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkGetRunStrikethroughInfo(
    POLS       ols,            // [IN] text imager instance
    PLSRUN     run,            // [IN] run
    PCHEIGHTS  height,         // [IN] height of the run
    LSTFLOW    flow,           // [IN] text flow
    PLSSTINFO  strikethrough   // [OUT] strikethrough information
)
{
    FullTextImager *imager = ols->GetImager();
    ASSERT (run && run->Face);

    REAL fontToIdeal =     (run->EmSize / run->Face->GetDesignEmHeight())
                        *  imager->WorldToIdeal;

    GpMemset(strikethrough, 0, sizeof(LSSTINFO));

    strikethrough->cNumberOfLines = 1;

    strikethrough->dvpLowerStrikethroughOffset = GpRound(float(
        run->Face->GetDesignStrikeoutPosition() * fontToIdeal));

    strikethrough->dvpLowerStrikethroughSize = GpRound(float(
        run->Face->GetDesignStrikeoutSize() * fontToIdeal));

    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkReleaseRun(
    POLS    ols,        // [IN] text imager instance
    PLSRUN  run         // [IN] run to be released
)
{
    // Nothing to be released.
    //

    return lserrNone;
}

////    Drawing
//
//


// workaround compiler bug (ntbug 312304)
#pragma optimize("", off)

LSERR WINAPI FullTextImager::GdipLscbkDrawUnderline(
    POLS         ols,                // [IN] text imager instance
    PLSRUN       run,                // [IN] run
    UINT         kUnderline,         // [IN] kind of underline
    const POINT  *pointStart,        // [IN] drawing start
    DWORD        lineLength,         // [IN] underline length
    DWORD        thickness,          // [IN] underline thickness
    LSTFLOW      flow,               // [IN] text flow
    UINT         modeDisplay,        // [IN] display mode
    const RECT   *rectClip           // [IN] clipping rectangle
)
{
    GpStatus status = Ok;
    FullTextImager *imager = ols->GetImager();

    //#if DBG
    //    WARNING(("DrawUnderline x %d, y %d, length %d", pointStart->x, pointStart->y, length));
    //#endif


    if (imager->RecordDisplayPlacementsOnly)
    {
        //  This is not an actual drawing
        return lserrNone;
    }


    PointF origin(
        TOREAL(pointStart->x), 
        TOREAL(pointStart->y)
    );
        
    BYTE runLevel = (run->Item.Level & 1);
    BOOL reverseLine;   // line being drawn from finish to start


    switch (flow)
    {
        //  Line Services tells us how to draw the line

        case lstflowWS:
        case lstflowNE:
        case lstflowNW:

            reverseLine = !runLevel;
            break;

        case lstflowES:
        case lstflowSE:
        case lstflowSW:
        default:

            reverseLine = runLevel;
    }

    INT  length = max((INT)lineLength, 0);
    BOOL vertical = imager->IsFormatVertical();
    REAL *textAxis = vertical ? &origin.Y : &origin.X;
    REAL *lineAxis = vertical ? &origin.X : &origin.Y;

    if (reverseLine)
    {
        //  line drawn from finish to start

        if (runLevel)
        {
            //  drawing from left to right or top to bottom
            *textAxis -= TOREAL(run->Adjust.Trailing);
        }
        else
        {
            //  drawing from right to left or bottom to top
            *textAxis -= TOREAL(length - run->Adjust.Leading);
        }
    }
    else
    {
        //  line drawn from start to finish

        if (runLevel)
        {
            //  drawing from right to left or bottom to top
            *textAxis -= TOREAL(length + run->Adjust.Trailing);
        }
        else
        {
            //  drawing from left to right or top to bottom
            *textAxis += TOREAL(run->Adjust.Leading);
        }
    }

    //  Adjust the line display position according to baseline adjustment.
    //  We want to draw an underline at the position relative to a baseline
    //  that snaps to full pixel in grid-fitted display. (wchao, #356546)

    if (!vertical)
    {
        //  Only adjust baseline for horizontal,
        //  let's leave vertical cases as is for now (wchao, 4-17-2001)
        
        *lineAxis += imager->CurrentBuiltLine->GetDisplayBaselineAdjust();
    }
    
    origin.X = imager->ImagerOrigin.X + origin.X / imager->WorldToIdeal;
    origin.Y = imager->ImagerOrigin.Y + origin.Y / imager->WorldToIdeal;


    length += run->Adjust.Trailing - run->Adjust.Leading;

    if (length <= 0)
    {
        //  Dont draw line w/ negative length
        return lserrNone;
    }


    REAL penWidth = thickness / imager->WorldToIdeal;
    if (imager->Graphics)
    {
        penWidth = imager->Graphics->GetDevicePenWidth(penWidth);

        const GpBrush* brush = SpanRider<const GpBrush*>(
            &imager->BrushVector)[run->ImagerStringOffset];

        PointF origins[2] = { origin, origin };
        if (vertical)
            origins[1].Y += length / imager->WorldToIdeal;
        else
            origins[1].X += length / imager->WorldToIdeal;

        status = imager->Graphics->DrawLines(
            &GpPen(brush, penWidth, UnitPixel),
            origins,
            2
        );
    }
    else
    {
        if (vertical)
        {
            status = imager->Path->AddRect(RectF(
                origin.X - penWidth / 2,
                origin.Y,
                penWidth,
                length / imager->WorldToIdeal
            ));
        }
        else
        {
            status = imager->Path->AddRect(RectF(
                origin.X,
                origin.Y - penWidth / 2,
                length / imager->WorldToIdeal,
                penWidth
            ));
        }
    }
    IF_NOT_OK_WARN_AND_RETURN(status);
    return lserrNone;
}



LSERR WINAPI FullTextImager::GdipLscbkDrawStrikethrough(
    POLS         ols,            // [IN] text imager instance
    PLSRUN       run,            // [IN] run
    UINT         kStrikethrough, // [IN] kind of strikethrough
    const POINT  *pointStart,    // [IN] drawing start
    DWORD        length,         // [IN] strikethrough length
    DWORD        thickness,      // [IN] strikethrough thickness
    LSTFLOW      flow,           // [IN] text flow
    UINT         modeDisplay,    // [IN] display mode
    const RECT   *rectClip       // [IN] clipping rectangle
)
{
    //  !! share code with underlining for now !!
    //

    return GdipLscbkDrawUnderline(
        ols,
        run,
        0,
        pointStart,
        length,
        thickness,
        flow,
        modeDisplay,
        rectClip
    );
}

#pragma optimize("", on)


LSERR WINAPI FullTextImager::GdipLscbkFInterruptUnderline(
    POLS       ols,                // [IN] text imager instance
    PLSRUN     first,              // [IN] first run
    LSCP       positionLastFirst,  // [IN] position of the last character of first run
    PLSRUN     second,             // [IN] second run
    LSCP       positionLastSecond, // [IN] position of the last character of second run
    BOOL       *interruptOK        // [OUT] Disconnect underlining between runs?
)
{
    // We need to use line services to calculate the height and thickness of
    // underlines, but we calculate the start and end positions ourselves based
    // on hinted glyph adjustment.
    //
    // Therefore we need DrawUnderline calls to correspond 1:1 with DrawGlyphs
    // calls. Per Victor Kozyrev Dec 6th 2000, returning TRUE here causes
    // LS to call DrawUnderline for each DrawGlyphs. Also guaranteed is that
    // DrawUnderline calls happen after the DrawGlyph calls they correspond to.

    *interruptOK = TRUE;
    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkDrawTextRun(
    POLS           ols,                    // [IN] text imager instance
    PLSRUN         run,                    // [IN] run
    BOOL           strikethroughOkay,      // [IN] Strikethrough the run?
    BOOL           underlineOkay,          // [IN] Underline the run?
    const POINT    *pointText,             // [IN] actual start point of run (untrimmed)
    LPCWSTR        string,                 // [IN] string of run
    const int      *advances,              // [IN] character advance width array
    DWORD          length,                 // [IN] length of string
    LSTFLOW        flow,                   // [IN] text flow
    UINT           modeDisplay,            // [IN] display mode
    const POINT    *pointRun,              // [IN] start point of run (trimmed)
    PCHEIGHTS      height,                 // [IN] run's presentation height
    long           totalWidth,             // [IN] run's presentation width
    long           widthUnderlining,       // [IN] underlining limit
    const RECT     *rectClip               // [IN] clipping rectangle
)
{
    //  Ideally we should have nothing to do with this callback since everything we
    //  have is glyph-based. However LS does call this callback to display things like
    //  hyphen or paragraph separator (which is given as a space character).
    //

    GpStatus status = Ok;

    if (   run->RunType == lsrun::RunText
        && run->Item.Script != ScriptControl)
    {
        AutoArray<Point> glyphOffsets(new Point[length]);
        if (!glyphOffsets)
            return lserrOutOfMemory;

        FullTextImager *imager = ols->GetImager();

        GpMemset ((BYTE *)glyphOffsets.Get(), 0, length * sizeof(GOFFSET));

        //  Drawing properties

        const GpStringFormat *format = SpanRider<const GpStringFormat *>(&imager->FormatVector)[run->ImagerStringOffset];
        INT                  style   = SpanRider<INT>(&imager->StyleVector)[run->ImagerStringOffset];

        POINT origin = *pointRun;
        origin.y = GpRound(origin.y + run->BaselineOffset * imager->WorldToIdeal);

        status = imager->DrawGlyphs (
            &run->Item,
            run->Face,
            run->EmSize,
            NULL,
            run->ImagerStringOffset,
            length,
            format,
            style,
            run->FormatFlags,
            run->Glyphs,
            run->GlyphMap,
            run->GlyphProperties,
            advances,
            glyphOffsets.Get(),
            length,
            &origin,
            totalWidth
        );
    }
    return status == Ok ? lserrNone : status;
}




LSERR WINAPI FullTextImager::GdipLscbkDrawGlyphs(
    POLS            ols,                    // [IN] text imager instance
    PLSRUN          run,                    // [IN] run
    BOOL            strikethroughOkay,      // [IN] Strikethrough the run?
    BOOL            underlineOkay,          // [IN] Underline the run?
    PCGINDEX        glyphs,                 // [IN] glyph index array
    const int      *glyphAdvances,          // [IN] glyph advance width array
    const int      *advanceBeforeJustify,   // [IN] array of glyph advance width before justification
    PGOFFSET        glyphOffsets,           // [IN] glyph offset array
    PGPROP          glyphProperties,        // [IN] glyph properties array
    PCEXPTYPE       glyphExpansionType,     // [IN] glyph expansion type array
    DWORD           glyphCount,             // [IN] number of element of glyph index array
    LSTFLOW         flow,                   // [IN] text flow
    UINT            modeDisplay,            // [IN] display mode
    const POINT    *pointRun,               // [IN] start point of run
    PCHEIGHTS       height,                 // [IN] run's presentation height
    long            totalWidth,             // [IN] run's presentation width
    long            widthUnderlining,       // [IN] underlining limit
    const RECT     *rectClip                // [IN] clipping rectangle
)
{
    FullTextImager *imager = ols->GetImager();

    ASSERT((INT)glyphCount <= run->GlyphCount);

    //  Drawing properties

    const GpStringFormat *format = SpanRider<const GpStringFormat *>(&imager->FormatVector)[run->ImagerStringOffset];
    INT                  style   = SpanRider<INT>(&imager->StyleVector)[run->ImagerStringOffset];

    POINT origin = *pointRun;
    origin.y = GpRound(origin.y + run->BaselineOffset * imager->WorldToIdeal);

    UINT characterCount = run->CharacterCount;

    if (glyphCount != (UINT)run->GlyphCount)
    {
        characterCount = 0;

        while (   characterCount < run->CharacterCount
               && run->GlyphMap[characterCount] < glyphCount)
        {
            characterCount++;
        }
    }


    //#if DBG
    //    WARNING(("DrawGlyphs x %d, y %d, totalWidth %d, widthUnderlining %d",
    //             pointRun->x, pointRun->y, totalWidth, widthUnderlining));
    //#endif

    imager->CurrentBuiltLine->UpdateLastVisibleRun(run);    // cache last run being displayed

    GpStatus status = imager->DrawGlyphs (
        &run->Item,
        run->Face,
        run->EmSize,
        NULL,
        run->ImagerStringOffset,
        characterCount,
        format,
        style,
        run->FormatFlags,
        glyphs,
        run->GlyphMap,
        glyphProperties,
        glyphAdvances,
        (Point *)glyphOffsets,
        glyphCount,
        &origin,
        totalWidth,
        &run->Adjust
    );

    return status == Ok ? lserrNone : status;
}






LSERR WINAPI FullTextImager::GdipLscbkFInterruptShaping(
    POLS     ols,                    // [IN] text imager instance
    LSTFLOW  flow,                   // [IN] text flow
    PLSRUN   first,                  // [IN] first run
    PLSRUN   second,                 // [IN] second run
    BOOL     *interruptShapingOkay)  // [OUT] Disconnect glyphs between runs?
{
    //  We've cached the glyph indices since we started build up runs.
    //  Besides the performance gain, we have the benefit of not having to
    //  deal with the complexity of multiple-run GetGlyphs calls and simply
    //  ignore this callback (wchao).

    *interruptShapingOkay = TRUE;

    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkGetGlyphs(
    POLS         ols,                // [IN] text imager instance
    PLSRUN       run,                // [IN] run
    LPCWSTR      string,             // [IN] string of run
    DWORD        length,             // [IN] length of string
    LSTFLOW      flow,               // [IN] text flow
    PGMAP        glyphMap,           // [OUT] glyph cluster mapping array
    PGINDEX      *glyphIndices,      // [OUT] pointer to glyph index array
    PGPROP       *glyphProperties,   // [OUT] pointer to glyph properties array
    DWORD        *countGlyph         // [OUT] number of element of glyph index array
)
{
    #if TRACERUNSPANS
        WCHAR str[200];
        memcpy(str, string, min(200,length)*2);
        str[min(length,199)] = 0;
        TERSE(("GetGlyphs run %x, length %x: '%S'\n", run, length, str));
    #endif

    ASSERT(ols->GetImager()->String[run->ImagerStringOffset] == string[0]);

    memcpy(glyphMap, run->GlyphMap, sizeof(GMAP) * length);


    //  Line Services may call for partial run.
    //  We need to make sure that we would never give too few glyphs. The
    //  orphan character with no correspondent glyph would assert.

    *countGlyph = run->GlyphMap[length - 1] + 1;

    while (   *countGlyph < (UINT)run->GlyphCount
           && !((SCRIPT_VISATTR *)run->GlyphProperties)[*countGlyph].fClusterStart)
    {
        (*countGlyph)++;
    }

    *glyphIndices    = run->Glyphs;
    *glyphProperties = run->GlyphProperties;

    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkGetGlyphPositions(
    POLS         ols,                // [IN] text imager instance
    PLSRUN       run,                // [IN] run
    LSDEVICE     device,             // [IN] device to place to
    LPWSTR       string,             // [IN] string of run
    PCGMAP       glyphMap,           // [IN] glyph cluster mapping array
    DWORD        length,             // [IN] length of string
    PCGINDEX     glyphIndices,       // [IN] glyph index array
    PCGPROP      glyphProperties,    // [IN] glyph properties array
    DWORD        countGlyph,         // [IN] number of element of glyph index array
    LSTFLOW      flow,               // [IN] text flow
    int          *glyphAdvance,      // [OUT] glyph advance width array
    PGOFFSET     glyphOffset         // [OUT] glyph offset array
)
{
    #if TRACERUNSPANS
        WCHAR str[200];
        memcpy(str, string, min(200,length)*2);
        str[min(length,199)] = 0;
        TERSE(("GetGlyphPositions run %x, length %x: '%S'\n", run, length, str));
    #endif

    FullTextImager *imager = ols->GetImager();

    double designToIdeal = run->EmSize * imager->WorldToIdeal
                           / run->Face->GetDesignEmHeight();

    const GpStringFormat *format = SpanRider<const GpStringFormat *>(&imager->FormatVector)[run->ImagerStringOffset];
    double tracking = format ? format->GetTracking() : DefaultTracking;

    run->Face->GetShapingCache()->GetGlyphPositions (
        &run->Item,
        (WORD *)glyphIndices,
        (SCRIPT_VISATTR *)glyphProperties,
        countGlyph,
        run->FormatFlags,
        NULL,                               // No real device
        SpanRider<INT>(&ols->GetImager()->StyleVector)[run->ImagerStringOffset],
        GpRound(TOREAL(designToIdeal * run->Face->GetDesignEmHeight())),
        GpRound(TOREAL(designToIdeal * run->Face->GetDesignEmHeight())),
        designToIdeal,
        TOREAL(tracking),
        glyphAdvance,
        glyphOffset,
        NULL,
        &run->EngineState
    );
    return lserrNone;
}



LSERR WINAPI FullTextImager::GdipLscbkResetRunContents(
    POLS      ols,                    // [IN] text imager instance
    PLSRUN    run,                    // [IN] run
    LSCP      positionBeforeShaping,  // [IN] first position of the run before shaping
    LSDCP     lengthBeforeShaping,    // [IN] length of the run before shaping
    LSCP      positionAfterShaping,   // [IN] first position of the run after shaping
    LSDCP     lengthAfterShaping      // [IN] length of the run after shaping
)
{
    //
    //  LS calls this function when a ligature extends across run boundaries.
    //  We dont have to do anything special here since we're not that sophisticate.
    //
    return lserrNone;
}





////    Line breaking
//
//

LSERR WINAPI FullTextImager::GdipLscbkGetBreakingClasses(
    POLS      ols,                      // [IN] text imager instance
    PLSRUN    run,                      // [IN] run
    LSCP      position,                 // [IN] position of the character
    WCHAR     wch,                      // [IN] character to return the class for
    BRKCLS    *breakClassAsLeading,     // [OUT] class if character is the leading in pair (break after)
    BRKCLS    *breakClassAsTrailing     // [OUT] class if character is the trailing in pair (break before)
)
{
    if (   ols->GetImager()->TruncateLine
        && wch != 0x20
        && (wch & 0xF800) != 0xD800)
    {
        //  In case of character trimming we dont apply word break rules,
        //  just break between any character pair using breakclass 0 "Break Always".

        *breakClassAsLeading  =
        *breakClassAsTrailing = 0;

        return lserrNone;
    }

    if (wch == WCH_IGNORABLE)
    {
        //  Special handling for 0xffff.
        //
        //  Classification of 0xffff is dynamic. It has the same classification
        //  as the first character found following it.
        
        ASSERT(run->RunType == lsrun::RunText);

        FullTextImager *imager = ols->GetImager();

        if (!imager->RunRider.SetPosition(position))
        {
            return lserrInvalidParameter;
        }

        UINT c = 1; // looking forward next char
        UINT i = position - imager->RunRider.GetCurrentSpanStart();
        
        while (   i + c < run->CharacterCount
               && (wch = imager->String[run->ImagerStringOffset + i + c]) == WCH_IGNORABLE)
        {
            c++;
        }

        if (wch != WCH_IGNORABLE)
        {
            position += c;
        }
    }


    CHAR_CLASS charClass  = CharClassFromCh(wch);
    BRKCLS     breakClass = ols->GetImager()->BreakClassFromCharClass[charClass];


    *breakClassAsLeading  =
    *breakClassAsTrailing = breakClass;


    if (breakClass != BREAKCLASS_THAI)
    {
        return lserrNone;
    }


    //  Dictionary-based linebreaking,
    //  As of now, only Thai falls into this category.

    BOOL isWordStart = FALSE;
    BOOL isWordLast  = FALSE;

    GpStatus status = ols->GetImager()->GetCharacterProperties (
        CharacterAttributes[charClass].Script,
        position,
        &isWordStart,
        &isWordLast
    );

    if (status == Ok)
    {
        switch (breakClass)
        {
            // !! Only Thai for now !!

            case BREAKCLASS_THAI :

                if (isWordStart)
                {
                    *breakClassAsTrailing = BREAKCLASS_THAIFIRST;
                }

                if (isWordLast)
                {
                    *breakClassAsLeading = BREAKCLASS_THAILAST;
                }
        }
    }
    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkFTruncateBefore(
    POLS       ols,                    // [IN] text imager instance
    PLSRUN     run,                    // [IN] run
    LSCP       position,               // [IN] position of truncation character
    WCHAR      character,              // [IN] truncation character
    long       width,                  // [IN] width of truncation character
    PLSRUN     runBefore,              // [IN] run of the character preceding truncation character
    LSCP       positionBefore,         // [IN] position of the character preceding truncation character
    WCHAR      characterBefore,        // [IN] character preceding truncation character
    long       widthBefore,            // [IN] width of the character preceding truncation character
    long       widthCut,               // [IN] distance from the right margin to the end of truncation character
    BOOL       *truncateBeforeOkay     // [OUT] Should the line truncated before truncation character?
)
{
    //  Always truncate before the character exceeding the margin
    //
    *truncateBeforeOkay = TRUE;
    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkCanBreakBeforeChar(
    POLS        ols,                // [IN] text imager instance
    BRKCLS      breakClass,         // [IN] class of the character
    BRKCOND     *condition          // [OUT] breaking condition before the character
)
{
    //  Break behind an inline object
    //
    //  The logic below follows Michel Suignard's breaking around object table
    //  (http://ie/specs/secure/trident/text/Line_Breaking.htm)

    switch (breakClass)
    {
        case 2 :    // Closing characters
        case 3 :    // No start ideographic
        case 4 :    // Exclamation/interrogation
            *condition = brkcondNever;
            break;

        case 8 :    // Ideographic
        case 13 :   // Slash
            *condition = brkcondPlease;
            break;

        default:
            *condition = brkcondCan;
    }
    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkCanBreakAfterChar(
    POLS        ols,                // [IN] text imager instance
    BRKCLS      breakClass,         // [IN] class of the character
    BRKCOND     *condition          // [OUT] breaking condition after the character
)
{
    //  Break before an inline object
    //
    //  The logic below follows Michel Suignard's breaking around object table
    //  (http://ie/specs/secure/trident/text/Line_Breaking.htm)

    switch (breakClass)
    {
        case 1 :    // Opening characters
            *condition = brkcondNever;
            break;
            
        case 8 :    // Ideographic
        case 13 :   // Slash
            *condition = brkcondPlease;
            break;

        default:
            *condition = brkcondCan;
    }
    return lserrNone;
}


LSERR WINAPI FullTextImager::GdipLscbkGetHyphenInfo(
    POLS     ols,                // [IN] text imager instance
    PLSRUN   run,                // [IN] run
    DWORD    *kysr,              // [OUT] YSR hyphenation type see "lskysr.h"
    WCHAR    *ysrCharacter       // [OUT] string of changed character caused by YSR
)
{
    //  Not support YSR hyphenation
    //
    *kysr = kysrNil;
    *ysrCharacter = 0;
    return lserrNone;
}





////    Memory management
//
//

void* WINAPI FullTextImager::GdipLscbkNewPtr(
    POLS    ols,            // [IN] text imager instance
    DWORD   countBytes      // [IN] byte count to alloc
)
{
    return GpMalloc(countBytes);
}


void WINAPI FullTextImager::GdipLscbkDisposePtr(
    POLS     ols,        // [IN] text imager instance
    void     *memory     // [IN] memory block
)
{
    GpFree(memory);
}


void* WINAPI FullTextImager::GdipLscbkReallocPtr(
    POLS    ols,        // [IN] text imager instance
    void    *memory,    // [IN] memory block
    DWORD   countBytes  // [IN] byte count to realloc
)
{
    return GpRealloc(memory, countBytes);
}




////    Misc.
//
//

LSERR WINAPI FullTextImager::GdipLscbkCheckParaBoundaries(
    POLS    ols,                   // [IN] text imager instance
    LONG    positionFirst,         // [IN] position in one paragraph
    LONG    positionSecond,        // [IN] position in different paragraph
    BOOL    *incompatibleOkay      // [OUT] Are two paragraphs incompatible?
)
{
    //  For now, two paragraphs always compatible
    //
    *incompatibleOkay = FALSE;
    return lserrNone;
}



LSERR WINAPI FullTextImager::GdipLscbkReverseGetInfo(
    POLS        ols,                    // [IN] text imager instance
    LSCP        position,               // [IN] run character position
    PLSRUN      run,                    // [IN] run
    BOOL        *dontBreakAround,       // [OUT] should reverse chunk be broken around?
    BOOL        *suppressTrailingSpaces // [OUT] suppress trailing spaces?
)
{
    *dontBreakAround        = TRUE;
    *suppressTrailingSpaces = TRUE;

    return lserrNone;
}



//  Reversal object initialization info

const REVERSEINIT ReverseObjectInitialization =
{
    REVERSE_VERSION,
    WCH_OBJECTTERMINATOR,
    NULL,
    FullTextImager::GdipLscbkReverseGetInfo,
    NULL
};



LSERR WINAPI FullTextImager::GdipLscbkGetObjectHandlerInfo(
    POLS      ols,                    // [IN] text imager instance
    DWORD     id,                     // [IN] object id
    void      *objectInitialization   // [OUT] object initialization info
)
{
    if (id == OBJECTID_REVERSE)
        GpMemcpy(objectInitialization, &ReverseObjectInitialization, sizeof(REVERSEINIT));
    else
    {
        // We should never get here unless we support other built-in objects e.g. Ruby.
        //

        ASSERTMSG(FALSE, ("Built-in object other than the reverse is detected.\n"));
    }

    return lserrNone;
}


#if DBG
void WINAPI FullTextImager::GdipLscbkAssertFailed(
    char   *string,    // [IN] assert string
    char   *file,      // [IN] file string
    int    line        // [IN] line number
)
{
    char szDebug[256];

    wsprintfA(szDebug, "LS assert - %s, file %s, line %d\n", string, file, line);
    OutputDebugStringA(szDebug);
    ASSERT(FALSE);
}
#endif



extern const LSCBK GdipLineServicesCallbacks =
{
    FullTextImager::GdipLscbkNewPtr,                     // pfnNewPtr
    FullTextImager::GdipLscbkDisposePtr,                 // pfnDisposePtr
    FullTextImager::GdipLscbkReallocPtr,                 // pfnReallocPtr
    FullTextImager::GdipLscbkFetchRun,                   // pfnFetchRun
    0,//GdipLscbkGetAutoNumberInfo,                      // pfnGetAutoNumberInfo
    0,//GdipLscbkGetNumericSeparators,                   // pfnGetNumericSeparators
    0,//GdipLscbkCheckForDigit,                          // pfnCheckForDigit
    FullTextImager::GdipLscbkFetchPap,                   // pfnFetchPap
    FullTextImager::GdipLscbkFetchTabs,                  // pfnFetchTabs
    FullTextImager::GdipLscbkGetBreakThroughTab,         // pfnGetBreakThroughTab
    FullTextImager::GdipLscbkFGetLastLineJustification,  // pfnFGetLastLineJustification
    FullTextImager::GdipLscbkCheckParaBoundaries,        // pfnCheckParaBoundaries
    FullTextImager::GdipLscbkGetRunCharWidths,           // pfnGetRunCharWidths
    0,                                                   // pfnCheckRunKernability
    0,                                                   // pfnGetRunCharKerning
    FullTextImager::GdipLscbkGetRunTextMetrics,          // pfnGetRunTextMetrics
    FullTextImager::GdipLscbkGetRunUnderlineInfo,        // pfnGetRunUnderlineInfo
    FullTextImager::GdipLscbkGetRunStrikethroughInfo,    // pfnGetRunStrikethroughInfo
    0,                                                   // pfnGetBorderInfo
    FullTextImager::GdipLscbkReleaseRun,                 // pfnReleaseRun
    0,                                                   // pfnHyphenate
    FullTextImager::GdipLscbkGetHyphenInfo,              // pfnGetHyphenInfo
    FullTextImager::GdipLscbkDrawUnderline,              // pfnDrawUnderline
    FullTextImager::GdipLscbkDrawStrikethrough,          // pfnDrawStrikethrough
    0,                                                   // pfnDrawBorder
    0,                                                   // pfnDrawUnderlineAsText
    FullTextImager::GdipLscbkFInterruptUnderline,        // pfnFInterruptUnderline
    0,                                                   // pfnFInterruptShade
    0,                                                   // pfnFInterruptBorder
    0,                                                   // pfnShadeRectangle
    FullTextImager::GdipLscbkDrawTextRun,                // pfnDrawTextRun
    0,                                                   // pfnDrawSplatLine
    FullTextImager::GdipLscbkFInterruptShaping,          // pfnFInterruptShaping
    FullTextImager::GdipLscbkGetGlyphs,                  // pfnGetGlyphs
    FullTextImager::GdipLscbkGetGlyphPositions,          // pfnGetGlyphPositions
    FullTextImager::GdipLscbkResetRunContents,           // pfnResetRunContents
    FullTextImager::GdipLscbkDrawGlyphs,                 // pfnDrawGlyphs
    0,                                                   // pfnGetGlyphExpansionInfo
    0,                                                   // pfnGetGlyphExpansionInkInfo
    0,                                                   // pfnGetEms
    0,                                                   // pfnPunctStartLine
    0,                                                   // pfnModWidthOnRun
    0,                                                   // pfnModWidthSpace
    0,                                                   // pfnCompOnRun
    0,                                                   // pfnCompWidthSpace
    0,                                                   // pfnExpOnRun
    0,                                                   // pfnExpWidthSpace
    0,                                                   // pfnGetModWidthClasses
    FullTextImager::GdipLscbkGetBreakingClasses,         // pfnGetBreakingClasses
    FullTextImager::GdipLscbkFTruncateBefore,            // pfnFTruncateBefore
    FullTextImager::GdipLscbkCanBreakBeforeChar,         // pfnCanBreakBeforeChar
    FullTextImager::GdipLscbkCanBreakAfterChar,          // pfnCanBreakAfterChar
    0,                                                   // pfnFHangingPunct
    0,                                                   // pfnGetSnapGrid
    0,                                                   // pfnDrawEffects
    0,                                                   // pfnFCancelHangingPunct
    0,                                                   // pfnModifyCompAtLastChar
    0,                                                   // pfnEnumText
    0,                                                   // pfnEnumTab
    0,                                                   // pfnEnumPen
    FullTextImager::GdipLscbkGetObjectHandlerInfo,       // pfnGetObjectHandlerInfo
#if DBG
    FullTextImager::GdipLscbkAssertFailed                // pfnAssertFailed
#else
    0                                                    // pfnAssertFailed
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\run.hpp ===
#ifndef _RUN_HPP
#define _RUN_HPP


////    Run - character sequence of consistent properties
//
//      Represents a run for passing to line services.
//
//      Runs are maintained in the text imager run span vector. The vector
//      is indexed by line services character position rather than imager
//      string offsets. Line services character positions are the same as
//      imager offsets for single direction text, however extra level opening
//      and closing characters are inserted for bidirectional strings.


struct lsrun
{
    enum Type
    {
        RunText,            // Normal run addressing text in the imager string
        RunEndOfParagraph,  // A virtual CR/LF representing the end of paragraph
        RunLevelUp,         // The preceding run has lower level
        RunLevelDown,       // The following run has lower level
        RunLevelSeparator,  // A level close followed by a level open
        RunNone
    } RunType;

    INT                ImagerStringOffset;  // Offset into imager string
    UINT               CharacterCount;

    // Note: the right-to-left flag in FormatFlags is the paragraph reading order.
    // The presentation order is the bottom bit of the Level field in Item.

    GpTextItem         Item;                // A copy of corresponding item in item vector
    INT                FormatFlags;         // Format flags

    const GpFontFace  *Face;                // Actual font face used, including font fallback
    REAL               EmSize;              // em size in world units
    REAL               BaselineOffset;      // Offset required for font fallback

    // The following buffers are released following line building

    INT                GlyphCount;
    GINDEX            *Glyphs;
    GMAP              *GlyphMap;
    GPROP             *GlyphProperties;
    USHORT             EngineState;         // state needed to be preserved across runs

    
    // Leading/trailing edge adjustment,
    // positive in text flow direction of run

    struct Adjustment
    {
        Adjustment (
            INT     leading,
            INT     trailing
        ) :
            Leading (leading),
            Trailing (trailing)
        {}

        INT     Leading;
        INT     Trailing;
    } Adjust;


    // Construction from basic (unglyphed) content

    lsrun(
        IN  Type               runType,
        IN  INT                runStringStart,
        IN  INT                runLength,
        IN  const GpTextItem  &item,
        IN  INT                formatFlags
    ) :
        RunType             (runType),
        ImagerStringOffset  (runStringStart),
        CharacterCount      (runLength),
        Item                (item),
        FormatFlags         (formatFlags),
        Face                (NULL),
        EmSize              (0),
        BaselineOffset      (0),
        GlyphCount          (0),
        Glyphs              (NULL),
        GlyphMap            (NULL),
        GlyphProperties     (NULL),
        EngineState         (0),
        Adjust              (0, 0)
    {}


    lsrun(const lsrun& run) :
        RunType             (run.RunType),
        ImagerStringOffset  (run.ImagerStringOffset),
        CharacterCount      (run.CharacterCount),
        Item                (run.Item),
        FormatFlags         (run.FormatFlags),
        Face                (run.Face),
        EmSize              (run.EmSize),
        BaselineOffset      (run.BaselineOffset),
        EngineState         (run.EngineState),
        Adjust              (run.Adjust),
        GlyphCount          (0),
        Glyphs              (NULL),
        GlyphMap            (NULL),
        GlyphProperties     (NULL)
    {}


    // Constructor as duplicate of existing run

    /*
    lsrun(
        const lsrun *previousRun
    )
    {
        *this = *previousRun;
    }
    */


    ~lsrun()
    {
        if (Glyphs)          delete [] Glyphs;
        if (GlyphMap)        delete [] GlyphMap;
        if (GlyphProperties) delete [] GlyphProperties;
    }
};

#endif // _RUN_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\precomp.hpp ===
#include "..\..\entry\precomp.hpp"

#define GDIPLUS 1   // Tell Uniscribe headers not to define face and size caches

extern "C"
{
struct ols;

#include "lscbk.h"
#include "lsdnfin.h"
#include "lsdnset.h"
#include "lstxtcfg.h"
#include "lsimeth.h"
#include "plsline.h"
#include "lslinfo.h"
#include "lschp.h"
#include "lspap.h"
#include "plspap.h"
#include "lstxm.h"
#include "lsdevres.h"
#include "lscontxt.h"
#include "lscrline.h"
#include "lsqline.h"
#include "lssetdoc.h"
#include "lsdsply.h"
#include "heights.h"
#include "lsstinfo.H"
#include "lsulinfo.H"
#include "plsstinf.h"
#include "plsulinf.h"
#include "plstabs.h"
#include "lstabs.h"
#include "robj.h"
#include "ruby.h"
#include "tatenak.h"
#include "warichu.h"
#include "lsffi.h"
#include "lstfset.h"
#include "lsqsinfo.h"
#include "lscell.h"
#include "lskysr.h"
}

#include "USP10.h"
#include "usp10p.h"

#include "usp_fontcache.hpp"    // Override SIZE_CACHE & FACE_CACHE

#include "unipart.hxx"
#include "unidir.hxx"
#include "secondaryClassification.hpp"
#include "usp_priv.hxx"

#include "usp_macro.hpp"

#include "brkclass.hxx"
#include "dwchar.hxx"
#include "item.hpp"
#include "run.hpp"
#include "break.hpp"
#include "lineServicesOwner.hpp"
#include "builtLine.hpp"
#include "paragraph.hpp"
#include "span.hpp"
#include "flip.hpp"
#include "imager.hpp"
#include "glyphPlacement.hpp"
#include "shaping.hpp"
#include "BiDiAnalysis.hpp"
#include "familyfallback.hpp"

#include "otl_scrp.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\inc\otlcbdef.h ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLCBDEF.H  ********
*
*            OTL Services Library Callback Function Definitions
*
*       The OTL Services Library calls back to the functions defined
*       in this file for operating system rescources.        - deanb
*
*       Copyright 1996 - 1997. Microsoft Corporation.
*
*       Jun 13, 1996    v 0.2   First release
*       Sep 25, 1996    v 0.3   Rename to OTL, trimmed to core
*       Jan 15, 1997    v 0.4   Portability renaming, etc.
*       Mar 14, 1997    v 0.5   Table tag param for FreeTable
*       Jul 28, 1997    v 0.8   hand off
*
************************************************************************


/***********************************************************************
*
*           Resource Management Callback Function Type Definitions
*   
***********************************************************************/

typedef enum 
{
	otlDestroyContent	= 0,
	otlPreserveContent	= 1
}
otlReallocOptions;

#ifdef __cplusplus

class IOTLClient
{
public:

    virtual otlErrCode GetOtlTable 
    (
        const	otlTag  tagTableName,   // in:  truetype table name tag 
        const BYTE**    ppvTable,       // out: pointer to the table data
        ULONG*          plTableLength   // out: table length
    ) = 0;

    virtual void FreeOtlTable 
    (
        BYTE*           pvTable,        // in: in case client needs it
        const otlTag    tagTableName    // in: truetype table name tag 
    ) = 0;

	virtual otlErrCode ReallocOtlList
	(
		otlList*			pList,				// in/out 
		USHORT				cbNewDataSize,		// in 
		USHORT				celmNewMaxLen,		// in 
		otlReallocOptions	optPreserveContent	// in; if set, client may assert  
												//   cbNewDataSize == cbDataSize
	) = 0;

	virtual otlErrCode GetDefaultGlyphs 
	(
		const otlList*		pliChars,			// in: characters 
		otlList*			pliGlyphInfo		// out: glyphs 
												// (fill in the "glyph" field only) 
	) = 0;

	virtual otlErrCode GetDefaultAdv 
	(
		const otlList*		pliGlyphInfo,	// in: glyphs 
		otlList*			pliduGlyphAdv	// out:	default glyph advances 
	) = 0;

	virtual otlErrCode GetGlyphPointCoords 
	(
		const otlGlyphID	glyph,				// in: glyph ID 
		otlPlacement**		prgplc				// out: x, y coords of points 
	) = 0;

	virtual otlErrCode FreeGlyphPointCoords
	(
		const otlGlyphID	glyph,				// in: glyph ID 
		otlPlacement*		rgplc				// in: point coord array to free
	) = 0;

};

#else // !defined(__cplusplus)

typedef struct 
{
  const IOTLClientVtbl* lpVtbl;
} 
IOTLClient;


typedef struct 
{
  	otlErrCode (OTL_PUBLIC * GetOtlTable) 
	(
		IOTLClient*			This,
		const	otlTag		tagTableName,  // in:  truetype table name tag 
		BYTE**			ppvTable,      // out: pointer to the table data
		ULONG*			plTableLength  // out: table length
	);

	void (OTL_PUBLIC * FreeOtlTable) 
	(
		IOTLClient*			This,
		BYTE*				pvTable,			// in: in case client needs it
		const otlTag		tagTableName        // in: truetype table name tag 
	);

	otlErrCode (OTL_PUBLIC * ReallocOtlList)
	(
		IOTLClient*			This,
		otlList*			pList,				// in/out 
		USHORT				cbNewDataSize,		// in 
		USHORT				celmNewMaxLen,		// in 
		otlReallocOptions	optPreserveContent	// in; if set, client may assert  
												//   cbNewDataSize == cbDataSize
	);

	otlErrCode (OTL_PUBLIC * GetDefaultGlyphs) 
	(
		IOTLClient*			This,
		const otlList*		pliChars,			// in: characters 
		otlList*			pliGlyphInfo		// out: glyphs 
												// (fill in the "glyph" field only) 
	);

	otlErrCode (OTL_PUBLIC * GetDefaultAdv) 
	(
		IOTLClient*			This,
		const otlList*		pliGlyphInfo,		// in: glyphs 
		otlList*			pliduGlyphAdv		// out:	default glyph advances 
	);

	otlErrCode (OTL_PUBLIC * GetGlyphPointCoords) 
	(
		IOTLClient*			This,
		const otlGlyphID	glyph,				// in: glyph ID 
		otlPlacement**		prgplc				// out: x, y coords of points 
	);

	otlErrCode (OTL_PUBLIC * FreeGlyphPointCoords)
	(
		IOTLClient*			This,
		const otlGlyphID	glyph,				// in: glyph ID 
		otlPlacement*		rgplc				// in: point coord array to free
	);

}
IOTLClientVtbl;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\splittransform.cpp ===
#include <precomp.hpp>


const DOUBLE PI = 3.1415926535897932384626433832795;



/**************************************************************************\
*
* SplitTransform:
*
*   Separates a transform into the sequence
*
*   o  scale        x always positive, y positive or negative
*   o  rotate       0 - 2pi
*   o  shear        along x (as a positive or negative factor of y)
*   o  translate    any x,y
*
* Arguments:
*
*   IN   transform
*   OUT  scale
*   OUT  rotate
*   OUT  shear
*   OUT  translate
*
* Return Value:
*
*   none
*
* Created:
*
*   06/18/99 dbrown
*
* !!!
*   SplitTransform should probably be in matrix.hpp
*
\**************************************************************************/

void SplitTransform(
    const GpMatrix  &matrix,
    PointF          &scale,
    REAL            &rotate,
    REAL            &shear,
    PointF          &translate)
{

    REAL m[6];
    matrix.GetMatrix(m);

    // m11 = m[0]    m12 = m[1]
    // m21 = m[2]    m22 = m[3]
    //  dx = m[4]     dy = m[5]


    // Extract translation

    translate = PointF(m[4],m[5]);


    //         2           2
    // Use  Sin theta + cos theta = 1 to obtain (absolute value) of
    // the X scale factor. Because we're returning the shear in X only,
    // it is a factor of y, so this formula is correct regardless of shear.


    REAL m11Sq = m[0]*m[0];
    REAL m12Sq = m[1]*m[1];

    scale.X = TOREAL(sqrt(m11Sq + m12Sq));

    // Always treat X scale factor as positive: handle originally negative
    // X scale factors as rotation by 180 degrees and invert Y scale factor.


    if (m[1] >= 0 && m[0] > 0)
    {
        rotate = TOREAL(atan(m[1]/m[0]));          // 0-90
    }
    else if (m[0] < 0)
    {
        rotate = TOREAL(atan(m[1]/m[0]) + PI);     // 90-270
    }
    else if (m[1] < 0 && m[0] > 0)
    {
        rotate = TOREAL(atan(m[1]/m[0]) + 2*PI);   // 270-360
    }
    else
    {
        // m[0] == 0

        if (m[1] > 0)
        {
            rotate = TOREAL(PI/2);                 // 90
        }
        else
        {
            rotate = TOREAL(3*PI/2);               // 270
        }
    }


    // y scale factor in terms of x scale factor

    scale.Y = scale.X * (m[0]*m[3] - m[1]*m[2]) / (m11Sq + m12Sq);


    // Shear

    shear = (m[1]*m[3] + m[0]*m[2]) / (m11Sq + m[1]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\span.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Character span support
*
* Revision History:
*
*   06/16/1999 dbrown
*       Created it.
*
\**************************************************************************/


#include "precomp.hpp"

////    VectorBase - very very simple dynamic array base class
//
//      VectorBase[]            - directly address index element (index checked in checked build)
//      VectorBase.Resize(size) - Allocate memory for at least size elements
//      VectorBase.Shrink(size) - Reduce vector to exactly size


template <class C> BOOL VectorBase<C>::Resize(INT targetAllocated)
{
    if (targetAllocated > Allocated)
    {
        INT newAllocated = targetAllocated;   // Required minimum new size

        // Round up to nearest higher power of sqrt(2). The idea is to
        // grow at least exponentially, but not as fast as doubling each
        // time.

        // First find nearest higher power of 2.

        newAllocated |= newAllocated >> 1;
        newAllocated |= newAllocated >> 2;
        newAllocated |= newAllocated >> 4;
        newAllocated |= newAllocated >> 8;
        newAllocated |= newAllocated >> 16;
        newAllocated |= newAllocated >> 32;
        newAllocated++;

        // We now know that newAllocated is a power of two
        // and that targetAllocated is between newAllocated/2 and newAllocated.

        // Adjust roundup to power of sqrt(2) by seeing which side of
        // 3/4 newAllocated targetAllocated falls.

        if (targetAllocated < newAllocated - (newAllocated >> 2))
        {
            // targetAllocated is between 1/2 and 3/4 the next higher power
            // of two - reduce newAllocated by 1/4 newAllocated.

            newAllocated -= newAllocated >> 2;

            // (This isn't eactly powers of root 2 as the intermediate steps
            // are 1.5 times the next lower power of two when they should be
            // 1.414 times. But this is more than good enough.)
        }

        C *newElements = (C*) GpRealloc(VectorElements, sizeof(C) * newAllocated);

        if (newElements)
        {
            Allocated      = newAllocated;
            VectorElements = newElements;
        }
        else
        {   // Reallocation failed - fatal
            return FALSE;
        }
    }

    return TRUE;
}


template <class C> BOOL VectorBase<C>::Shrink(INT targetAllocated)
{
    if (targetAllocated < Allocated)
    {
        if (targetAllocated > 0)
        {
            C *newElements = (C*) GpRealloc(VectorElements, sizeof(C) * targetAllocated);

            if (newElements)
            {
                Allocated      = targetAllocated;
                VectorElements = newElements;
                return TRUE;
            }
            else
            {   // Reallocation failed - fatal
                return FALSE;
            }
        }
        else
        {
            GpFree(VectorElements);
            Allocated      = 0;
            VectorElements = NULL;
        }
    }
    return TRUE;
}





/**************************************************************************\
*
* template <class C> void SpanVector<C>::SetSpan:
*
*   Update span vector with an Element over a range
*
* Arguments:
*
*   IN    first   - first character having this attribute
*   IN    Length  - number of characters having this attribute
*   IN    Element - attribute to record for this range
*
* Return Value:
*
*   none
*
* Algorithm
*
*   Identify first and last existing Spans affected by the change
*   Where status adjacent to the change is the same as the change
*   update the change range to include adjacent equal value.
*   Calculate how many Spans need to be added or removed.
*   Insert null Spans or delete Spans after first affected span.  The first
*   affected span may be updated, but is never removed.
*
*
* Created:
*
*   06/18/99 dbrown
*
\**************************************************************************/

template <class C> GpStatus SpanVector<C>::SetSpan(
    INT  first,
    INT  Length,
    C    Element
)
{
    GpStatus status = Ok;
    ASSERT(first  >= 0);
    ASSERT(Length >= 0);


    // Identify first span affected by update

    INT fs = 0;     // First affected span index
    INT fc = 0;     // Character position at start of first affected span

    while (    fs < Active
           &&  fc + (INT)Spans[fs].Length <= first)
    {
        fc += Spans[fs].Length;
        fs++;
    }


    // If the span list terminated before first, just add the new span

    if (fs >= Active)
    {
        // Ran out of Spans before reaching first

        ASSERT(fc <= first);

        if (fc < first)
        {
            // Create default run up to first
            status = Add(Span<C>(Default, first-fc));
            if (status != Ok)
                return status;
        }

        if (    Active > 0
            &&  Spans[Active-1].Element == Element)
        {
            // New Element matches end Element, just extend end Element
            Spans[Active-1].Length += Length;
        }
        else
        {
            status = Add(Span<C>(Element, Length));
        }

        return status;
    }


    // fs = index of first span partly or completely updated
    // fc = character index at start of fs

    // Now find the last span affected by the update

    INT ls = fs;
    INT lc = fc;

    while (    ls < Active
           &&  lc + (INT)Spans[ls].Length <= first+Length)
    {
        lc += Spans[ls].Length;
        ls++;
    }


    // ls = first span following update to remain unchanged in part or in whole
    // lc = character index at start of ls


    // expand update region backwatds to include existing Spans of identical
    // Element type

    if (first == fc)
    {
        // Item at [fs] is completely replaced. Check prior item

        if (    fs > 0
            &&  Spans[fs-1].Element == Element)
        {
            // Expand update area over previous run of equal classification
            fs--;
            fc -= Spans[fs].Length;
            first = fc;
            Length += Spans[fs].Length;
        }

    }
    else
    {
        // Item at [fs] is partially replaced. Check if it is same as update
        if (Spans[fs].Element == Element)
        {
            // Expand update area back to start of first affected equal valued run
            Length = first+Length-fc;
            first = fc;
        }
    }


    // Expand update region forwards to include existing Spans of identical
    // Element type

    if (    ls < Active
        &&  Spans[ls].Element == Element)
    {
        // Extend update region to end of existing split run

        Length = lc + Spans[ls].Length - first;
        lc += Spans[ls].Length;
        ls++;
    }


    // If no old Spans remain beyond area affected by update, handle easily:

    if (ls >= Active)
    {
        // None of the old span list extended beyond the update region

        if (fc < first)
        {
            // Updated region leaves some of [fs]

            if (Active != fs+2)
            {
                if (!Spans.Resize(fs+2))
                    return OutOfMemory;
                Active = fs+2;
            }
            Spans[fs].Length = first - fc;
            Spans[fs+1] = Span<C>(Element, Length);
        }
        else
        {
            // Updated item replaces [fs]

            if (Active != fs+1)
            {
                if (!Spans.Resize(fs+1))
                    return OutOfMemory;
                Active = fs+1;
            }
            Spans[fs] = Span<C>(Element, Length);
        }

        return status;  // DONE
    }


    // Record partial elementtype at end, if any

    C    trailingElement;
    INT  trailingLength;

    if (first+Length > lc)
    {
        trailingElement = Spans[ls].Element;
        trailingLength  = lc + Spans[ls].Length - (first+Length);
    }


    // Calculate change in number of Spans

    INT spanDelta =    1                          // The new span
                    +  (first  > fc ? 1 : 0)      // part span at start
                    -  (ls-fs);                   // existing affected span count

    // Note part span at end doesn't affect the calculation - the run may need
    // updating, but it doesn't need creating.


    if (spanDelta < 0)
    {
        status = Erase(fs + 1, -spanDelta);
        if (status != Ok)
            return status;
    }
    else if (spanDelta > 0)
    {
        status = Insert(fs + 1, spanDelta);
        if (status != Ok)
            return status;
        // Initialize inserted Spans
        for (INT i=0; i<spanDelta; i++)
        {
            Spans[fs+1+i] = Span<C>(NULL, 0);
        }
    }


    // Assign Element values

    // Correct Length of split span before updated range

    if (fc < first)
    {
        Spans[fs].Length = first-fc;
        fs++;
    }

    // Record Element type for updated range

    Spans[fs] = Span<C>(Element, Length);
    fs++;

    // Correct Length of split span following updated range

    if (lc < first+Length)
    {
        Spans[fs] = Span<C>(trailingElement, trailingLength);
    }

    // Phew, all done ....

    return Ok;
}

    // For checked builds and debugging only

#if DBG
    template <class C> void SpanVector<C>::Dump()
    {
        //OutputDebugStringA("Dump of SpanVector<");
        //OutputDebugStringA(typeid(C).name());
        //OutputDebugStringA(">\r\n  ");
        if (Active <= 0)
        {
            OutputDebugStringA("empty.");
        }
        else
        {
            INT i;
            INT offset = 0;
            for (i=0; i<Active; i++)
            {
                char str[30];
                wsprintfA(str, "[%d]L%d=%x, ", offset, Spans[i].Length, Spans[i].Element);
                offset += Spans[i].Length;
                OutputDebugStringA(str);
            }
        }
        OutputDebugStringA("\r\n");
    }
#endif





template <class C> GpStatus SpanVector<C>::OrSpan(
    INT  first,
    INT  length,
    C    element
)
{
    SpanRider<C> rider(this);
    rider.SetPosition(first);

    INT offset = first;
    UINT advance;

    while (length > 0)
    {
        advance = min(rider.GetUniformLength(), (UINT)length);
        GpStatus status = rider.SetSpan(offset, advance, element | rider.GetCurrentElement());
        if (status != Ok)
            return status;

        offset += advance;
        length -= advance;
        rider.SetPosition(offset);
    }
    return Ok;
}




/*
template <class C> GpStatus SpanVector<C>::OrSpan(
    INT  first,
    INT  length,
    C    element
)
{
    if (!length || !element)
    {
        return Ok;
    }

    ASSERT(first  >= 0);
    ASSERT(length >= 0);


    //  Identify first span affected by update

    INT fs = 0;     // First affected span index
    INT fc = 0;     // Character position at start of first affected span

    while (    fs < Active
           &&  fc + (INT)Spans[fs].Length <= first)
    {
        fc += Spans[fs].Length;
        fs++;
    }

    // If the span list terminated before first, just add the new span

    if (fs >= Active)
    {
        // Ran out of Spans before reaching first

        ASSERT(fc <= first);

        if (fc < first)
        {
            // Create default run up to first
            Add(Span<C>(Default, first - fc));
        }

        if (    Active > 0
            &&  Spans[Active - 1].Element == (element | Default))
        {
            // New Element matches end Element, just extend end Element
            Spans[Active - 1].Length += length;
        }
        else
        {
            Add(Span<C>(element, length));
        }

        return Ok;
    }

    if (first > fc)
    {
        //  Split a new span
        Insert(fs + 1, 1);

        Spans[fs + 1] = Span<C>(Spans[fs].Element, Spans[fs].Length - first + fc);
        Spans[fs].Length = first - fc;
        fs++;
        fc = first;
    }


    //  Now find the last span affected by the update

    INT ls = fs;
    INT lc = fc;

    while (    ls < Active
           &&  lc + (INT)Spans[ls].Length <= first + length)
    {
        lc += Spans[ls].Length;
        ls++;
    }

    if (   ls >= Active
        && first + length > lc)
    {
        // No old Spans remain beyond area affected by update

        INT uc = first + length - lc;   // update characters beyond end span

        if (   Active > 0
            && Spans[Active - 1].Element == (element | Default))
        {
            // New Element matches end Element, just extend end Element
            Spans[Active - 1].Length += uc;
        }
        else
        {
            Add(Span<C>(element, uc));
            ls++;
        }

        lc += uc;
    }

    if (lc < first + length)
    {
        //  Split a new span
        Insert(ls, 1);

        Spans[ls] = Span<C>(Spans[ls + 1].Element, first + length - lc);
        Spans[ls + 1].Length -= Spans[ls].Length;
        ls++;
        lc = first + length;
    }

    //  OR all affected spans

    for (INT i = fs; i < ls; i++)
    {
        Spans[i].Element |= element;
    }

    //  Merge adjacent spans if any duplicates

    fs = max(fs - 1, 0);
    ls = min(ls + 1, Active);

    INT s = fs;
    INT ms = s + 1;     // first span outside the merge range

    while (s < ls)
    {
        //  Find continuous spans to be merged
        while (   ms < ls
               && Spans[ms].Element == Spans[s].Element)
        {
            ms++;
        }

        if (ms - s > 1)
        {
            //  Merge all at once
            for (INT i = 1; i < ms - s; i++)
            {
                Spans[s].Length += Spans[s + i].Length;
            }

            Erase(s + 1, ms - s - 1);
        }

        s = ms;
        ms++;
    }

    return Ok;
}
*/


template <class C> void SpanVector<C>::Reset(BOOL shrink)
{
    Active = 0;
    if (shrink)
    {
        Spans.Shrink(0);
    }
}


template <class C> GpStatus SpanVector<C>::Erase(INT first, INT count)
{
    ASSERT(first>=0);
    ASSERT(count>=0);

    if (    first + count >= Active
        &&  first < Active)
    {
        // Erase at end
        if (!Spans.Resize(first))
            return OutOfMemory;
        Active = first;
    }
    else
    {
        GpMemmove(
            &Spans[first],
            &Spans[first+count],
            sizeof(Span<C>) * (Active - (first+count))
        );
        if (!Spans.Resize(Active-count))
            return OutOfMemory;
        Active -= count;
    }
    return Ok;
}


template <class C> GpStatus SpanVector<C>::Insert(INT first, INT count)
{
    ASSERT(first >= 0);
    ASSERT(count >= 0);


    if (first >= Active)
    {
        // All new entries are beyond exisiting entries
        if (!Spans.Resize(first+count))
            return OutOfMemory;
        Active = first+count;
    }
    else
    {
        // Make room for <count> more entries, and move all entries from
        // first to the old end up to the new end.

        /* Can't think why I wrote this: looks daft now [dbrown 19 Dec 99]
            INT amountToMove = count;
            if (amountToMove > Active-first)
            {
                amountToMove = Active-first;
            }
        */

        INT amountToMove = Active-first;

        if (!Spans.Resize(Active+count))
            return OutOfMemory;
        Active += count;
        GpMemmove(&Spans[first+count], &Spans[first], sizeof(Span<C>) * amountToMove);
    }
    return Ok;
}


template <class C> GpStatus SpanVector<C>::Add(const Span<C> &newSpan)
{
    if (!Spans.Resize(Active+1))
        return OutOfMemory;
    Active++;
    Spans[Active-1] = newSpan;
    return Ok;
}



/////   SpanRider - a class for efficiently running a cursor along a span vector
//
//


template <class C> BOOL SpanRider<C>::SetPosition(UINT32 newOffset)
{
    #if DBG
        // Check that current position details are valid

        if (newOffset > 0)
        {
            UINT offset = 0;
            INT element = 0;
            while (    offset < CurrentElementIndex
                   &&  element < Spanvector->Active)
            {
                offset += Spanvector->Spans[element].Length;
                element++;
            }

            ASSERT(element <= Spanvector->Active);
            ASSERT(element == CurrentElement);
            ASSERT(offset == CurrentElementIndex);
            if (element < Spanvector->Active)
            {
                ASSERT(CurrentOffset < offset + Spanvector->Spans[element].Length);
            }
        }
    #endif


    if (newOffset < CurrentElementIndex)
    {
        // Need to start at the beginning again
        CurrentOffset       = 0;
        CurrentElement      = 0;
        CurrentElementIndex = 0;
    }

    // Advance to element containing new offset

    while (    CurrentElement < Spanvector->Active
           &&  CurrentElementIndex + Spanvector->Spans[CurrentElement].Length <= newOffset)
    {
        CurrentElementIndex += Spanvector->Spans[CurrentElement].Length;
        CurrentElement++;
    }

    if (CurrentElement < Spanvector->Active)
    {
        CurrentOffset = newOffset;
        return TRUE;
    }
    else
    {
        CurrentOffset = min(newOffset, CurrentElementIndex);
        return FALSE;
    }
}



///// Explicit instantiations

//template class SpanVector<class BuiltLine*>;
//template class SpanVector<class GpTextItem>;
template class SpanRider<int>;
//template class SpanRider<struct lsrun *>;
template class SpanRider<class GpStringFormat const *>;
template class SpanRider<float>;
template class SpanRider<class GpBrush const *>;
template class SpanRider<BYTE>;

template GpStatus SpanVector<class BuiltLine *>::SetSpan(int,int,class BuiltLine *);
template GpStatus SpanVector<class GpTextItem>::SetSpan(int,int,class GpTextItem);
template GpStatus SpanVector<struct lsrun *>::SetSpan(int,int,struct lsrun *);
template GpStatus SpanVector<BYTE>::SetSpan(int,int,BYTE);
template GpStatus SpanVector<class Break *>::SetSpan(int,int,class Break *);
template GpStatus SpanVector<INT>::SetSpan(int,int, INT);

template void     SpanVector<UINT32>::Reset(BOOL);
template GpStatus SpanVector<UINT32>::OrSpan(int,int, UINT32);

template int      SpanRider<struct lsrun *>::SetPosition(unsigned int);
template int      SpanRider<class GpFontFamily const *>::SetPosition(unsigned int);
template int      SpanRider<class GpTextItem>::SetPosition(unsigned int);
template int      SpanRider<BYTE>::SetPosition(unsigned int);
template int      SpanRider<class Break *>::SetPosition(unsigned int);
template int      SpanRider<class BuiltLine *>::SetPosition(unsigned int);
template int      SpanRider<INT>::SetPosition(unsigned int);
template int      SpanRider<UINT32>::SetPosition(unsigned int);



template BOOL VectorBase<UINT>::Resize(INT);
template BOOL VectorBase<UINT>::Shrink(INT);
template BOOL VectorBase<LSTBD>::Resize(INT);
template BOOL VectorBase<LSTBD>::Shrink(INT);
template BOOL VectorBase<BREAKREC>::Resize(INT);
template BOOL VectorBase<BREAKREC>::Shrink(INT);


template void SpanVector<class GpTextItem>::Reset(INT);
template void SpanVector<BYTE>::Reset(INT);


#if DBG
    template void     SpanVector<struct lsrun *>::Dump();
    template void     SpanVector<BYTE>::Dump();
    template void     SpanVector<UINT32>::Dump();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\simpletextimager.cpp ===
/////   SimpleTextImager
//
//      Handles draw and mesure requests for a single line of simple text


/////   Assumptions
//
//      A simple text imager is only created when:
//
//          The text contains only simple script characters
//          There are no line breaks
//          The text is horizontal


#include "precomp.hpp"

GpStatus SimpleTextImager::Draw(
    GpGraphics *graphics,
    const PointF *origin
)
{
    GpStatus status;
    GpMatrix worldToDevice;
    graphics->GetWorldToDeviceTransform(&worldToDevice);

    REAL fontScale = EmSize / TOREAL(Face->GetDesignEmHeight());

    GpMatrix fontTransform(worldToDevice);
    fontTransform.Scale(fontScale, fontScale);

    // Build a face realization and prepare to adjust glyph placement

    GpFaceRealization faceRealization(
        Face,
        Style,
        &fontTransform,
        SizeF(graphics->GetDpiX(), graphics->GetDpiY()),
        graphics->GetTextRenderingHintInternal(),
        FALSE, /* bPath */
        FALSE /* bCompatibleWidth */
    );

    if (faceRealization.GetStatus() != Ok)
    {
        ASSERT(faceRealization.GetStatus() == Ok);
        return faceRealization.GetStatus();
    }

    if (faceRealization.IsPathFont())
    {
        /* the font size is too big to be handled by bitmap, we need to use path */
        GpPath path(FillModeWinding);
        GpLock lockGraphics(graphics->GetObjectLock());

        status = AddToPath( &path, origin);
        IF_NOT_OK_WARN_AND_RETURN(status);

        status = graphics->FillPath(Brush, &path);
        IF_NOT_OK_WARN_AND_RETURN(status);
    }
    else
    {

        AutoArray<PointF> glyphOrigins(new PointF[GlyphCount]);
        if (!glyphOrigins)
        {
            return OutOfMemory;
        }


        // Set first (leftmost) glyph origin

        PointF baselineOrigin(*origin);  // Origin in world coordinates

        // Offset x coordinate for alignment

        switch (Format ? Format->GetAlign() : StringAlignmentNear)
        {
        case StringAlignmentCenter:
            baselineOrigin.X += GpRound((Width - TotalWorldAdvance) / 2);
            break;

        case StringAlignmentFar:
            baselineOrigin.X += GpRound(Width - TotalWorldAdvance);
            break;
        }


        // Offset y coordinate for line alignment

        REAL cellHeight =   EmSize * (Face->GetDesignCellAscent() + Face->GetDesignCellDescent())
                          / Face->GetDesignEmHeight();

        switch (Format ? Format->GetLineAlign() : StringAlignmentNear)
        {
        case StringAlignmentCenter:
            baselineOrigin.Y += (Height - cellHeight) / 2;
            break;

        case StringAlignmentFar:
            baselineOrigin.Y += Height - cellHeight;
        }


        // Offset y coordinate from cell top to baseline

        baselineOrigin.Y +=   EmSize * Face->GetDesignCellAscent()
                             / Face->GetDesignEmHeight();

        baselineOrigin.X += LeftMargin;

        // Determine device glyph positions

        GlyphImager glyphImager(
            &faceRealization,
            &worldToDevice,
            WorldToIdeal,
            EmSize,
            GlyphCount,
            Glyphs
        );

        INT formatFlags = Format ? Format->GetFormatFlags() : 0;

        status = glyphImager.GetDeviceGlyphOrigins(
            &GpTextItem(0),
            formatFlags,
            GpRound(LeftMargin * WorldToIdeal),
            GpRound(RightMargin * WorldToIdeal),
            formatFlags & StringFormatFlagsNoFitBlackBox,
            formatFlags & StringFormatFlagsNoFitBlackBox,
            Format ? Format->GetAlign() : StringAlignmentNear,
            NULL,   // no glyph properties
            GlyphAdvances,
            NULL,   // no glyph offsets
            baselineOrigin,
            glyphOrigins.Get()
        );
        IF_NOT_OK_WARN_AND_RETURN(status);

        GpRegion *previousClip  = NULL;

        BOOL applyClip =
                Format
            &&  !(Format->GetFormatFlags() & StringFormatFlagsNoClip)
            &&  Width
            &&  Height;

        if (applyClip)
        {
            //  Preserve existing clipping and combine it with the new one if any
            if (!graphics->IsClipEmpty())
            {
                previousClip = graphics->GetClip();
            }

            RectF clippingRect(origin->X, origin->Y, Width, Height);
            graphics->SetClip(clippingRect, CombineModeIntersect);
        }

        status = graphics->DrawPlacedGlyphs(
            &faceRealization,
            Brush,
            (Format && Format->GetFormatFlags() & StringFormatFlagsPrivateNoGDI)
            ?  DG_NOGDI : 0,
            String,
            Length,
            FALSE,
            Glyphs,
            NULL, // one to one mapping in simple text imager
            glyphOrigins.Get(),
            GlyphCount,
            ScriptLatin,
            FALSE    // sideways
        );

        if (applyClip)
        {
            //  Restore clipping state if any
            if (previousClip)
            {
                graphics->SetClip(previousClip, CombineModeReplace);
                delete previousClip;
            }
            else
            {
                graphics->ResetClip();
            }
        }
    }

    return status;
}




GpStatus SimpleTextImager::AddToPath(
    GpPath *path,
    const PointF *origin
)
{
    GpStatus status;

    // !!! Need to loop through brushes individually

    // Establish font transformation

    REAL fontScale = EmSize / TOREAL(Face->GetDesignEmHeight());

    GpMatrix fontTransform;
    fontTransform.Scale(fontScale, fontScale);

    // Build a face realization and prepare to adjust glyph placement
    const GpMatrix identity;
    GpFaceRealization faceRealization(
        Face,
        Style,
        &identity,
        SizeF(150.0, 150.0),    // Arbitrary - we won't be hinting
        TextRenderingHintSingleBitPerPixel, // claudebe, do we want to allow for hinted or unhinted path ? // graphics->GetTextRenderingHint(),
        TRUE, /* bPath */
        FALSE /* bCompatibleWidth */
    );


    status = faceRealization.GetStatus();
    IF_NOT_OK_WARN_AND_RETURN(status);

    // Add glyphs to path

    INT i=0;

    PointF glyphOrigin(*origin);


    // Adjust so origin corresponds to top of initial cell.

    glyphOrigin.Y += TOREAL(   Face->GetDesignCellAscent() * EmSize
                            /  Face->GetDesignEmHeight());

    glyphOrigin.X += LeftMargin;

    while (    i < (INT)GlyphCount
           &&  status == Ok)
    {
        // Set marker at start of each logical character = cell = cluster

        path->SetMarker();


        // Add the path for the glyph itself

        GpGlyphPath *glyphPath = NULL;

        status = faceRealization.GetGlyphPath(
            *(Glyphs+i),
            &glyphPath
        );
        IF_NOT_OK_WARN_AND_RETURN(status);

        if (glyphPath != NULL)
        {
            status = path->AddGlyphPath(
                glyphPath,
                glyphOrigin.X,
                glyphOrigin.Y,
                &fontTransform
            );
            IF_NOT_OK_WARN_AND_RETURN(status);
        }

        // Update path position

        glyphOrigin.X += GlyphAdvances[i] / WorldToIdeal;


        i++;
    }

    // Force marker following last glyph

    path->SetMarker();

    return status;
}


GpStatus SimpleTextImager::Measure(
    GpGraphics *graphics,
    REAL       *nearGlyphEdge,
    REAL       *farGlyphEdge,
    REAL       *textDepth,
    INT        *codepointsFitted,
    INT        *linesFilled
) {
    // Offset x coordinate for alignment

    switch (Format ? Format->GetAlign() : StringAlignmentNear)
    {
        case StringAlignmentNear:
            *nearGlyphEdge = 0;
            *farGlyphEdge  = TotalWorldAdvance;
            break;

        case StringAlignmentCenter:
            *nearGlyphEdge = TOREAL((Width - TotalWorldAdvance) / 2.0);
            *farGlyphEdge  = *nearGlyphEdge + TotalWorldAdvance;
            break;

        case StringAlignmentFar:
            *nearGlyphEdge = Width - TotalWorldAdvance;
            *farGlyphEdge  = Width;
            break;
    }


    // Offset y coordinate for line alignment

    REAL cellHeight =   EmSize * (Face->GetDesignCellAscent() + Face->GetDesignCellDescent())
                      / Face->GetDesignEmHeight();

    *textDepth = cellHeight;

    if (codepointsFitted) {*codepointsFitted = GlyphCount;}
    if (linesFilled)      {*linesFilled      = 1;}

    return Ok;
}



#ifndef DCR_REMOVE_OLD_174340
GpStatus SimpleTextImager::MeasureRegion(
    INT           firstCharacterIndex,
    INT           characterCount,
    const PointF *origin,
    GpRegion     *region
)
{
    return MeasureRangeRegion(
        firstCharacterIndex,
        characterCount,
        origin,
        region
    );
}
#endif


GpStatus SimpleTextImager::MeasureRangeRegion(
    INT           firstCharacterIndex,
    INT           characterCount,
    const PointF *origin,
    GpRegion     *region
)
{
    if (!region || !region->IsValid())
    {
        return InvalidParameter;
    }

    region->SetEmpty();


    if (!characterCount)
    {
        //  return empty region
        return Ok;
    }
    else if (characterCount < 0)
    {
        firstCharacterIndex += characterCount;
        characterCount = -characterCount;
    }

    if (   firstCharacterIndex < 0
        || firstCharacterIndex > Length
        || firstCharacterIndex + characterCount > Length)
    {
        return InvalidParameter;
    }

    RectF rect;

    rect.X = origin->X + LeftMargin;
    rect.Y = origin->Y;

    switch (Format ? Format->GetAlign() : StringAlignmentNear)
    {
        case StringAlignmentNear:
            // nothing to add
            break;

        case StringAlignmentCenter:
            rect.X += TOREAL((Width - TotalWorldAdvance) / 2.0);
            break;

        case StringAlignmentFar:
            rect.X += TOREAL(Width - TotalWorldAdvance) ;
            break;
    }

    INT i = 0;
    REAL accumulated = 0.0f;
    while (i < firstCharacterIndex)
    {
        accumulated += GlyphAdvances[i];
        i++;
    }

    rect.X += accumulated / WorldToIdeal;

    rect.Width =0;
    while (i < min(firstCharacterIndex+characterCount , Length))
    {
        rect.Width += GlyphAdvances[i];
        i++;
    }
    rect.Width /= WorldToIdeal;

    rect.Height =   EmSize * (Face->GetDesignCellAscent() + Face->GetDesignCellDescent())
                      / Face->GetDesignEmHeight();


    switch (Format ? Format->GetLineAlign() : StringAlignmentNear)
    {
        case StringAlignmentNear:
            // nothing to add
            break;

        case StringAlignmentCenter:
            rect.Y += TOREAL((Height - rect.Height) / 2.0);
            break;

        case StringAlignmentFar:
            rect.Y += TOREAL(Height - rect.Height) ;
            break;
    }

    region->Set(&rect);

    return Ok;
}


GpStatus SimpleTextImager::MeasureRanges(
    GpGraphics      *graphics,
    const PointF    *origin,
    GpRegion        **regions
)
{
    if (!Format)
    {
        return InvalidParameter;
    }

    CharacterRange *ranges;
    INT rangeCount = Format->GetMeasurableCharacterRanges(&ranges);


    RectF clipRect(origin->X, origin->Y, Width, Height);
    BOOL clipped = !(Format->GetFormatFlags() & StringFormatFlagsNoClip);

    GpStatus status = Ok;

    for (INT i = 0; i < rangeCount; i++)
    {
        GpLock lockRegion(regions[i]->GetObjectLock());

        if (!lockRegion.IsValid())
        {
            return ObjectBusy;
        }

        status = MeasureRangeRegion (
            ranges[i].First,
            ranges[i].Length,
            origin,
            regions[i]
        );

        if (status != Ok)
        {
            return status;
        }

        if (clipped)
        {
            // we have a clipping so we need to make sure we didn't get out
            // of the layout box

            regions[i]->Combine(&clipRect, CombineModeIntersect);
        }
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\inc\otllib.h ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLLIB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       The OTL Services Library is a collection of functions which 
*       assist text processing clients with the task of text layout
*       using the information in OpenType fonts.            - deanb
*
*       Copyright 1996 - 1997. Microsoft Corporation.
*
*       Apr 01, 1996    v 0.1   First release
*       Jul 03, 1996    v 0.2   Sec prop uses feature bit mask, etc.
*       Aug 01, 1996    v 0.2a  OTLTextOut removed from API
*       Oct 11, 1996    v 0.3   Rename to OTL, trimmed to core
*       Jan 15, 1997    v 0.4   Portability renaming, etc.
*       Mar 18, 1997    v 0.5   Param changes, FreeTable, workspace
*       Apr 02, 1997    v 0.6   Feature handles
*       Apr 10, 1997    v 0.7   Otltypes.h, CharsAtPos, funits
*       Jul 28, 1997    v 0.8   hand off
*
************************************************************************
***********************************************************************/

/***********************************************************************
*   
*   The Goals of OTL Services 
* 
*   To expose the full functionality of OpenType fonts
*   To be platform independent, but pay particular attention to Windows
*   To support, not take over, text processing with helper functions
*
***********************************************************************/

/***********************************************************************
*   
*   Application Program Interface Overview
*
*   Font Information Functions
*       GetOtlVersion ( )           Returns current library version
*       GetOtlScriptList ( )        Enumerate scripts in a font
*       GetOtlLangSysList ( )       Enumerate language systems in a script
*       GetOtlFeatureDefs ( )       Enumerate features in a language system
*
*   Resource Management Functions
*       FreeOtlResources ( )        Frees all OTL tables and client memory
*
*   Text Information Functions
*       GetOtlLineSpacing ( )       Line spacing for a text run
*       GetOtlBaselineOffset ( )    Baseline adjustment between two scripts
*       GetOtlCharAtPosition ( )    What character is at given (x,y)
*       GetOtlExtentOfChars ( )     What is location of character range
*       GetOtlFeatureParams ( )     Find feature params within a run
*
*   Text Layout Functions
*       SubstituteOtlChars ( )      Do glyph subs according to features
*       SubstituteOtlGlyphs ( )     Do glyph subs according to features
*       PositionOtlGlyphs ( )       Do glyph positioning according to features
*
************************************************************************/

#include "otltypes.h"               // basic type definitions  
#include "otlcbdef.h"               // platform resource function typedefs  

#ifdef __cplusplus
#include "otltypes.inl"             // inline functions to work with OTL Types
#endif

/***********************************************************************
************************************************************************
*   
*           Application Program Interface Data Types
*
*   otlList             General expandable list structure
*   otlRunProp          Description of a font/size/script/langsys
*   otlFeatureDef       Defines features in a font
*   otlFeatureDesc      Describes how a feature is used
*   otlFeatureParam     Reports feature parameters
*   otlFeatureResults   Reports results of layout functions
*   IOTLClient          Client callback interface
*
***********************************************************************
***********************************************************************/


/***********************************************************************
*
*           Run Properties
*
*   This describes font/script/laguage system information for an entire
*   run of text. Multiple runs of text may point to the same properties
*   structure.
*
***********************************************************************/

typedef struct      // shared by multiple lines                                 
{
    IOTLClient*     pClient;        // ptr to client callback interface 
    long            lVersion;       // client expects / library supports 

    otlTag          tagScript;      // this run's script tag 
    otlTag          tagLangSys;     // set to 'dflt' for default LangSys 

    otlMetrics      metr;           // writing direction and font metrics
}
otlRunProp;                       // Hungarian: rp   


/***********************************************************************
************************************************************************
*   
*       Application Program Interface Functions
*
*   
*   Font Information Functions
*   Text Information Functions
*   Text Layout Functions
*
************************************************************************
***********************************************************************/


/***********************************************************************
*
*                       Font Information Functions
*
***********************************************************************/

/***********************************************************************
*
*   GetOtlVersion ( )       Returns current library version
*
*   Output: plVersion       Major version in top 16 bits, minor in bottom
*                           e.g. 0x00010002 = version 1.2
*
*   The client should put the smaller of this value and the version for
*   which it was written into the prpRunProp-lVersion field.
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlVersion 
( 
    long* plVersion
);


/***********************************************************************
*
*   GetOtlScriptList ( )        Enumerate scripts in a font
*
*   Input:  pRunProps->lVersion     Highest shared version
*           pRunProps->pClient      Client callback data
*           pliWorkspace            Workspace memory: initialize zero-length
*
*   Output: plitagScripts          List of script tags supported in font
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlScriptList 
( 
    const otlRunProp*   pRunProps,   
    otlList*            pliWorkspace,    
    otlList*            plitagScripts
);


/***********************************************************************
*
*   GetOtlLangSysList ( )       Enumerate language systems in a script
*
*   Input:  pRunProps->lVersion    Highest shared version
*           pRunProps->pClient     Client callback data
*           pRunProps->tagScript   Script tag
*           pliWorkspace           Workspace memory: initialize zero-length
*
*   Output: plitagLangSys          List of language systems supported in script
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlLangSysList 
( 
    const otlRunProp*   pRunProps,    
    otlList*            pliWorkspace,    
    otlList*            plitagLangSys
);


/***********************************************************************
*
*   GetOtlFeatureDefs ( )       Enumerate features in a language system 
*
*   Input:  pRunProps->lVersion     Highest shared version
*           pRunProps->pClient      Client callback interface
*           pRunProps->tagScript    Script tag
*           pRunProps->tagLangSys   Set to 'dflt' for default langsys
*           pliWorkspace            Workspace memory: initialize zero-length
*
*   Output: pliFDefs           List of features supported by langsys
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlFeatureDefs 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,    
    otlList*            pliFDefs
);


/***********************************************************************
*
*                       Resource Management Functions
*
***********************************************************************/

/***********************************************************************
*
*   FreeOtlResources ( )       Free OTL tables and client memory 
*
*   Input:  pRunProps->lVersion     Highest shared version
*           pRunProps->pvClient     Client callback data
*           pliWorkspace            Workspace
*
*   Frees all OTL Tables and pointer to client memory that may be stored 
*   in run workspace
*
***********************************************************************/

OTL_EXPORT otlErrCode FreeOtlResources 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace   
);


/***********************************************************************
*
*                       Text Information Functions
*
***********************************************************************/

/***********************************************************************
*
*   GetOtlLineSpacing ( )       Line spacing for a text run
*
*   Input:  pRunProps           Text run properties (script & langsys)
*           pliWorkspace        Workspace memory: initialize zero-length
*           pFSet               Which features apply (may affect spacing)
*
*   Output: pdvMax               Typographic ascender (horiz layout)
*           pdvMin               Typographic descender (horiz layout)
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlLineSpacing 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,
    
    long* pdvMax, 
    long* pdvMin
);


/***********************************************************************
*
*   GetOtlBaselineOffsets ( )   Baseline adjustment between two scripts
*
*   Input:  pRunProps           Text run properties (script & langsys)
*           pliWorkspace        Workspace memory: initialize zero-length
*
*   Output: pliBaselines        List of baseline tags and values
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlBaselineOffsets 
( 
    const otlRunProp*   pRunProps,   
    otlList*            pliWorkspace,    
    otlList*            pliBaselines
);


/***********************************************************************
*
*   GetOtlCharAtPosition ( )    What character is at given position
*
*   Input:  pRunProps           Text run properties (horiz/vert layout)
*           pliWorkspace        Workspace memory: initialize zero-length
*           pliCharMap          Unicode chars --> glyph indices mapping
*           pliGlyphInfo        Glyphs and flags
*           pliduGlyphAdv       Advance array
*
*           duAdv               Hit coordinate in advance direction
*   
*   Output: piChar              Index of character at position
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlCharAtPosition 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,    

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,

    long                duAdv,

    USHORT*             piChar
);


/***********************************************************************
*
*   GetOtlExtentOfChars ( )   What is location of character range
*
*   Input:  pRunProp          Text run properties (horiz/vert layout)
*           pliWorkspace      Workspace memory: initialize zero-length
*           pliCharMap        Unicode chars --> glyph indices mapping
*           pliGlyphInfo      Glyphs and flags list
*           pliduGlyphAdv     Advance array in layout direction
*           ichFirstChar      Index of first character
*           ichLastChar       Index of last character
*   
*   Output: piglfStartIdx        Index into Glyph list for first char
*           piglfEndIdx          Index into Glyph list for last char
*           pduStartPos          Left or Top of first char (right for RTL)
*           pduEndPos            Right or Bottom of last char (left for RTL)
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlExtentOfChars 
( 
    const otlRunProp*   pRunProp,
    otlList*            pliWorkspace,    

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,

    USHORT              ichFirstChar,
    USHORT              ichLastChar,
    
    long*               pduStartPos,
    long*               pduEndPos
);


/***********************************************************************
*
*   GetOtlFeatureParams ( )     Used to find glyph variants or feature parameter
*
*   Input:  pRunProps          Text run properties
*           pliWorkspace       Workspace memory: initialize zero-length
*           pliCharMap         Unicode chars --> glyph indices mapping
*           pliGlyphInfo       Text glyph list and glyph flag list 
*                               (chars/glyph and type)
*           tagFeature         Feature to examine
*
*   Output: plGlobalParam      Feature wide parameter
*           pliFeatureParams   List of character level feature params
*
*   Note:   Reserved for future use
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlFeatureParams 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,   

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,

    otlTag              tagFeature,
    
    long*               plGlobalParam,
    otlList*            pliFeatureParams
);


/***********************************************************************
*
*                       Text Layout Functions
*
***********************************************************************/


/***********************************************************************
*
*   SubstituteOtlChars ( )      Do glyph subs according to features
*   SubstituteOtlGlyphs ( )     Do glyph subs according to features
*
*   Input:  pRunProps           Text run properties
*           pliWorkspace        Workspace memory: initialize zero-length
*           pFSet               Which features apply

*           pliChars            Unicode chars in a text run

*           pliCharMap          Unicode chars  --> glyph indices mapping
*           pliGlyphInfo        Glyphs in a text run and properties
*                               (for SubstituteOtlGlyphs -- in/out)
*
*   Output: pliCharMap
*           pliGlyphInfo        Modified by substitution
*           pliFResults         Results per feature descriptor(length = size of FSet)
*
***********************************************************************/

OTL_EXPORT otlErrCode SubstituteOtlChars 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    const otlList*          pliChars,

    otlList*                pliCharMap,
    otlList*                pliGlyphInfo,
    otlList*                pliFResults
);

OTL_EXPORT otlErrCode SubstituteOtlGlyphs 
( 
    const otlRunProp*       pRunProp,
    otlList*                liWorkspace,   
    const otlFeatureSet*    pFSet,

    otlList*                pliCharMap,
    otlList*                pliGlyphInfo,
    otlList*                pliFResults
);


/***********************************************************************
*
*   PositionOtlGlyphs ( )       Do glyph positioning according to features
*   RePositionOtlGlyphs ( )     Adjust glyph positioning according to features
*
*   Input:  pRunProps           Text run properties
*           pliWorkspace        Workspace memory: initialize zero-length
*           pFSet               Which features apply
*           pliCharMap          Unicode chars  --> glyph indices mapping
*           pliGlyphInfo        Post-substituted glyphs and flags
*
*   Output: pliduGlyphAdv       Glyph advances 
*                               (RePositionOtlGlyphs -- in/out)
*           pliGlyphPlacement   Horizontal and vertical glyph placement
*                               (RePositionOtlGlyphs -- in/out)
*           pliFResults         Results per feature descriptor
*
***********************************************************************/

OTL_EXPORT otlErrCode PositionOtlGlyphs 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,

    otlList*            pliduGlyphAdv,
    otlList*            pliplcGlyphPlacement,

    otlList*            pliFResults
);


OTL_EXPORT otlErrCode RePositionOtlGlyphs 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,

    otlList*            pliduGlyphAdv,
    otlList*            pliplcGlyphPlacement,

    otlList*            pliFResults
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\inc\text_rt.h ===
/////   TEXT_RT.H
//
//      Uniscribe C-runtime redefinitions & prototypes
//
//      Created: wchao, 10-31-2000
//


#ifndef _TEXT_RT_H_
#define _TEXT_RT_H_

#ifdef GDIPLUS
#define memmove     GpMemmove
#else
#define memmove     UspMemmove
#endif

extern "C" void * __cdecl UspMemmove(void *dest, const void *src, size_t count);


#endif  // _TEXT_RT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\altersub.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  ALTERSUB.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with alternate substitution lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// translates lParameter to index into glyph variants array
// parameters are 1-based (0 meaning 'lookup is disabled',
// and the variant array is 0-based
inline USHORT ParameterToGlyphVariant(long lParameter)
{
    assert(lParameter > 0);
    return ((USHORT)lParameter - 1);
}


otlErrCode otlAlternateSubstLookup::apply
(
    otlList*                    pliGlyphInfo,
    
    long                        lParameter,

    USHORT                      iglIndex,
    USHORT                      iglAfterLast,

    USHORT*                     piglNextGlyph,  // out: next glyph

    otlSecurityData             sec
)                                               // return: did/did not apply
{ 
    if (!isValid()) return OTL_NOMATCH;

    if (format() != 1) return OTL_NOMATCH; //OTL_BAD_FONT_TABLE: Unknown format

    assert(lParameter != 0);
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(iglAfterLast > iglIndex);
    assert(iglAfterLast <= pliGlyphInfo->length());
    
    otlAlternateSubTable alternateSubst = otlAlternateSubTable(pbTable,sec);
    otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
    
    short index = alternateSubst.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
    if (index < 0)
    {
        return OTL_NOMATCH;
    }

    if (index > alternateSubst.alternateSetCount())
    {
        return OTL_NOMATCH; //OTL_BAD_FONT_TABLE
    }

    otlAlternateSetTable alternateSet = alternateSubst.altenateSet(index,sec);

    if (lParameter < 0 || alternateSet.glyphCount() < lParameter)
    {
        //assert(false); // bogus lParameter
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    pGlyphInfo->glyph = alternateSet
        .alternate(ParameterToGlyphVariant(lParameter));

    *piglNextGlyph = iglIndex + 1;
    return OTL_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\altersub.h ===
/***********************************************************************
************************************************************************
*
*                    ********  ALTERSUB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with alternate substitution lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetAlternateGlyphCount = 0;
const OFFSET offsetAlternateGlyphArray = 2;

const SIZE   sizeAlternateSetTableSize = sizeUSHORT;

class otlAlternateSetTable: public otlTable
{
public:
    otlAlternateSetTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeAlternateSetTableSize,offsetAlternateGlyphCount,sizeGlyphID,sec ))
        {
            setInvalid();
        }
    }

    USHORT glyphCount() const
    {   
        if (!isValid()) return 0;
        
        return UShort(pbTable + offsetAlternateGlyphCount); 
    }

    otlGlyphID alternate(USHORT index)
    {   
        assert(isValid());

        assert(index < glyphCount());
        return GlyphID(pbTable + offsetAlternateGlyphArray 
                                + index * sizeof(otlGlyphID)); 
    }
};


const OFFSET offsetAlternateCoverage = 2;
const OFFSET offsetAlternateSetCount = 4;
const OFFSET offsetAlternateSetArray = 6;

const SIZE sizeAlternateSubTable = sizeUSHORT+sizeOFFSET+sizeUSHORT;

class otlAlternateSubTable: public otlLookupFormat
{
public:

    otlAlternateSubTable(const BYTE* pb, otlSecurityData sec)
        : otlLookupFormat(pb,sec)
    {
        assert(isValid()); //Checked in otlLookupFormat
        assert(format()==1);
        
        if (!isValidTableWithArray(pb,sizeAlternateSubTable,
                                    offsetAlternateSetCount,sizeAlternateSetTableSize,sec))
        {
            setInvalid();
        }
    }

    otlCoverage coverage(otlSecurityData sec)
    {   
        if (!isValid()) return otlCoverage(pbInvalidData,sec);
        
        return otlCoverage(pbTable + Offset(pbTable + offsetAlternateCoverage),sec); 
    }

    USHORT alternateSetCount()
    {   
        if (!isValid()) return 0;
        return UShort(pbTable + offsetAlternateSetCount); 
    }

    otlAlternateSetTable altenateSet(USHORT index, otlSecurityData sec)
    {   
        if (!isValid()) return otlAlternateSetTable(pbInvalidData,sec);

        assert(index < alternateSetCount());
        return otlAlternateSetTable(pbTable + 
                Offset(pbTable + offsetAlternateSetArray 
                               + index * sizeof(OFFSET)),sec); 
    }
};


class otlAlternateSubstLookup: public otlLookupFormat
{
public:

    otlAlternateSubstLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec)
    {
        assert(isValid()); //Checked in LookupFormat
    }

    otlErrCode apply
    (
    otlList*                    pliGlyphInfo,

    long                        lParameter,

    USHORT                      iglIndex,
    USHORT                      iglAfterLast,

    USHORT*                     piglNextGlyph,      // out: next glyph

    otlSecurityData             sec
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\inc\otltypes.h ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLTYPES.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module contains basic OTL type and structure definitions.
*
*       Copyright 1997. Microsoft Corporation.
*
*       Apr 10, 1997    v 0.7   First release
*       Jul 28, 1997    v 0.8   hand off
*
************************************************************************
***********************************************************************/

/***********************************************************************
*
*           OTL build options
*
***********************************************************************/

//Enable critical error checking
#define     OTLCFG_SECURE

/***********************************************************************
*
*           OTL Basic Type Definitions
*
***********************************************************************/

typedef  unsigned short otlGlyphID;            // hungarian: glf
typedef  unsigned short otlGlyphFlags;         // hungarian: gf
typedef  signed long    otlTag;                // hungarian: tag
typedef  signed long    otlErrCode;            // hungarian: erc

#ifndef     BYTE
#define     BYTE    unsigned char
#endif

#ifndef     WCHAR
#define     WCHAR   unsigned short
#endif

#ifndef     USHORT
#define     USHORT  unsigned short
#endif

#ifndef     ULONG
#define     ULONG   unsigned long
#endif

#ifndef     NULL
#define     NULL    (void*)0
#endif

#ifndef     FALSE
#define     FALSE   0
#endif
#ifndef     TRUE
#define     TRUE    -1
#endif

#define     OTL_MAX_CHAR_COUNT          32000
#define     OTL_CONTEXT_NESTING_LIMIT   100

#define     OTL_PRIVATE     static
#define     OTL_PUBLIC
//#define     OTL_EXPORT      __declspec( dllexport ) /* needs portability work   */
#define     OTL_EXPORT      // No exports for LINKLIBS


#define     OTL_DEFAULT_TAG     0x746C6664

#define     OTL_GSUB_TAG        0x42555347
#define     OTL_GPOS_TAG        0x534F5047
#define     OTL_JSTF_TAG        0x4654534A
#define     OTL_BASE_TAG        0x45534142
#define     OTL_GDEF_TAG        0x46454447


/***********************************************************************
*
*                               OTL List
*
*   This is used to represent a number of different lists of data (such
*   as characters, glyphs, attributes, coordinates) that make up a text run
*
***********************************************************************/

#ifdef __cplusplus

class otlList
{
private:

    void*   pvData;                 // data pointer
    USHORT  cbDataSize;             // bytes per list element
    USHORT  celmMaxLen;             // allocated list element count
    USHORT  celmLength;             // current list element count

public:
        otlList (void* data, USHORT size, USHORT len, USHORT maxlen)
            : pvData(data), cbDataSize(size), celmLength(len), celmMaxLen(maxlen)
        {}

        inline BYTE* elementAt(USHORT index);
        inline const BYTE* readAt(USHORT index) const;

        inline void insertAt(USHORT index, USHORT celm);
        inline void deleteAt(USHORT index, USHORT celm);
        inline void append(const BYTE* element);

        void empty() { celmLength = 0; }

        USHORT length() const { return celmLength; }
        USHORT maxLength() const {return celmMaxLen; }
        USHORT dataSize() const {return cbDataSize; }
        const void*  data() const {return pvData; }

        inline void reset(void* pv, USHORT cbData, USHORT celmLen, USHORT celmMax);

};                                  // Hungarian: lixxx

#else

typedef struct otlList
{

    void*   pvData;                 // data pointer
    USHORT  cbDataSize;             // bytes per list element
    USHORT  celmMaxLen;             // allocated list element count
    USHORT  celmLength;             // current list element count

}
otlList;

#endif

/*
 *  When an OTL List is used for a function input parameter,
 *  the celmMaxLength field is not used. When an OTL List is
 *  used for a function output parameter, the celmMaxLength
 *  field is used to determine the memory available for the
 *  output data. If more memory is required than available,
 *  the function returns an OTL_ERR_INSUFFICIENT_MEMORY error
 *  message, and the celmLength field is set the the required
 *  memory size.
 *
 *  AndreiB(5-29-98) We're gonna switch to the model where OTL Services
 *  can request the client to realocate the list to the right size.
 *
 */

/**********************************************************************/


/***********************************************************************
*
*           Shared Structure Definitions
*
***********************************************************************/

typedef struct
{
    otlGlyphID      glyph;          // glyph ID
    otlGlyphFlags   grf;            // glyph flags

    USHORT          iChar;          // starting character index
    USHORT          cchLig;         // how many characters it maps to
}
otlGlyphInfo;                   // Hungarian glinf


/***********************************************************************
*
*           GlyphFlags masks and settings
*
***********************************************************************/

#define     OTL_GFLAG_CLASS     0x000F      // Base, mark, ligature, component

#define     OTL_GFLAG_SUBST     0x0010      // Glyph was substituted
#define     OTL_GFLAG_POS       0x0020      // Glyph was positioned

#define     OTL_GFLAG_RESERVED  0xFF00      // reserved

typedef enum
{
    otlUnassigned       = 0,
    otlBaseGlyph        = 1,
    otlLigatureGlyph    = 2,
    otlMarkGlyph        = 3,
    otlComponentGlyph   = 4,

    otlUnresolved       = 15, // This flag value will be substituted with 
                              // correct one from above values during OTLS
                              // call. Should be used when client creates or
                              // updates GlyphInfo structure manually
}
otlGlyphClass;

/***********************************************************************
*
*           Positioning structures
*
*   These structures (along with advance widths) are used in positioning
*   methods to relay font metrics/writing direction information and get
*   glyph positions back.
*
***********************************************************************/

typedef enum
{
    otlRunLTR   =   0,
    otlRunRTL   =   1,
    otlRunTTB   =   2,
    otlRunBTT   =   3
}
otlLayout;

typedef struct
{
    otlLayout       layout;     // horiz/vert left/right layout

    USHORT          cFUnits;        // font design units per Em
    USHORT          cPPEmX;         // horizontal pixels per Em
    USHORT          cPPEmY;         // vertical pixels per Em

}
otlMetrics;                     // Hungarian: metr

typedef struct
{
    long            dx;
    long            dy;

}
otlPlacement;                   // Hungarian: plc

/***********************************************************************
*
*           Feature Definition
*
*   These are returned by the GetOtlFeatureDefs call to identify
*   the set of features in a font, and are included in the Run
*   Property to identify the feature set
*
***********************************************************************/

typedef struct
{
    otlTag          tagFeature;             // feature tag
    USHORT          grfDetails;             // details of this feature
}
otlFeatureDef;                                  // Hungarian: fdef

#define     OTL_FEAT_FLAG_GSUB      0x0001    // does glyph substitution
#define     OTL_FEAT_FLAG_GPOS      0x0002    // does glyph positioning

/* The following flags are reserved for future use
*/
#define     OTL_FEAT_FLAG_ALTER     0x0004    // has alternate glyphs
#define     OTL_FEAT_FLAG_PARAM     0x0008    // uses a feature parameter

#define     OTL_FEAT_FLAG_EXP       0x0010    // may expand the glyph string
#define     OTL_FEAT_FLAG_SPEC      0x0020    // uses special processing


/***********************************************************************
*
*           Feature Description
*
*   This structure describes the use of one feature within a text run
*
***********************************************************************/

typedef struct
{
    otlTag          tagFeature;             // feature tag
    long            lParameter;             // 1 to enable, 0 to disable,
                                            // n for param
    USHORT          ichStart;               // start of feature range
    USHORT          cchScope;               // size of feature range
}
otlFeatureDesc;                             // Hungarian: fdsc


/***********************************************************************
*
*           Feature Set
*
*   This structure describes the set of features applied to a text run
*
***********************************************************************/
#ifdef __cplusplus

struct otlFeatureSet
{
    otlList         liFeatureDesc;      // list of feature descriptions
    USHORT          ichStart;           // offset into character list
    USHORT          cchScope;           // size of text run

    otlFeatureSet()
    : liFeatureDesc(NULL, 0, 0, 0), ichStart(0), cchScope(0)
    {}

};                              // Hungarian: fset

#else

typedef struct
{
    otlList         liFeatureDesc;      // list of feature descriptions
    USHORT          ichStart;           // offset into character list
    USHORT          cchScope;           // size of text run

} otlFeatureSet;                                // Hungarian: fset

#endif
/***********************************************************************
*
*           Feature Result
*
*   This structure is used to report results from applying a feature
*   descriptor
*
***********************************************************************/

typedef struct
{
    const otlFeatureDesc*   pFDesc;                 // feature descriptor
    USHORT                  cResActions;            // out: count of actions undertaken
}
otlFeatureResult;                               // Hungarian: fres


/***********************************************************************
*
*           Feature Parameter
*
*   This structures are returned by GetOtlFeatureParams to report
*   character level feature parameters
*
***********************************************************************/

typedef struct
{
    long            lParameter;             // feature parameter
    USHORT          ichStart;               // character start
    USHORT          cchScope;               // character length
}
otlFeatureParam;                                // Hungarian: fprm



/***********************************************************************
*
*           Base Value
*
*   This structure returns the tag and coordinate of one baseline
*
***********************************************************************/

typedef struct
{
    otlTag      tag;                    // baseline tag
    long        lCoordinate;            // baseline coordinate
}
otlBaseline;                            // Hungarian: basl



/***********************************************************************
*
*       Application Program Interface Function Return Codes
*
***********************************************************************/

inline USHORT ERRORLEVEL(otlErrCode erc) { return (USHORT)((erc & 0xFF00) >> 8); }

#define     OTL_ERRORLEVEL_MINOR            1

#define     OTL_SUCCESS                     0x0000
#define     OTL_ERROR                       0xFFFF

#define     OTL_ERR_TABLE_NOT_FOUND         0x0101
#define     OTL_ERR_SCRIPT_NOT_FOUND        0x0102
#define     OTL_ERR_LANGSYS_NOT_FOUND       0x0103
#define     OTL_ERR_FEATURE_NOT_FOUND       0x0104

#define     OTL_ERR_VERSION_OUT_OF_DATE     0x0301
#define     OTL_ERR_BAD_FONT_TABLE          0x0302
#define     OTL_ERR_CONTEXT_NESTING_TOO_DEEP 0x0303

#define     OTL_ERR_INCONSISTENT_RUNLENGTH  0x0401
#define     OTL_ERR_BAD_INPUT_PARAM         0x0402
#define     OTL_ERR_POS_OUTSIDE_TEXT        0x0403

#define     OTL_ERR_INSUFFICIENT_MEMORY     0x0501
#define     OTL_ERR_GLYPHIDS_NOT_FOUND      0x0502
#define     OTL_ERR_ADVANCE_NOT_FOUND       0x0503

#define     OTL_ERR_CANNOT_REENTER          0x0901

#define     OTL_ERR_UNDER_CONSTRUCTION      0x1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\inc\secondaryclassification.hpp ===
#ifndef _SECONDARYCLASSIFICATION_HPP
#define _SECONDARYCLASSIFICATION_HPP

///// SecondaryClassification
//
//    Provides classification for digit substitution, symmetric glyph
//    mirroring and auto vertical glyph rotoation.
//
//    DO NOT EDIT
//
//    Generated by engine/text/unilib/tools/upright.pl

enum SecondaryClassificationBase {
    ScCSAN,
    ScCSNN,
    ScENAN,
    ScENNN,
    ScETAN,
    ScETNN,
    ScNNAN,
    ScNNAS,
    ScNNFN,
    ScNNNN,
    ScNNNS,
};


/// Secondary classification flags
//
//  Bits 0-1: Numeric class,  0/EN/CS/ET
//  Bits 2-3: Mirror class,   0/MS/MX
//  Bits 4-5: Sideways class, 0/SA/SF
//
// The secondary classificationFlags exist because they an be masked for
// secondary itemization functionality.

enum SecondaryClassificationFlags {
    SecClassEN = 0x01,   // Digit U+0030-U+0039
    SecClassCS = 0x02,   // Common separator
    SecClassET = 0x03,   // European terminator
    SecClassMS = 0x04,   // Mirror subst
    SecClassMX = 0x08,   // Mirror Xform
    SecClassSA = 0x10,   // Sideways Always
    SecClassSF = 0x20,   // Sideways only in FE string
};

extern const unsigned char ScBaseToScFlags[];

enum SecondaryClassification {
    ScOther,
    ScSide,
    ScMirSub,
    ScMirXfm,
    ScEN,
    ScCS,
    ScET
};

extern const SecondaryClassification ScFlagsToScFE[];
extern const SecondaryClassification ScFlagsToScEng[];
extern const unsigned char *SecondaryClassificationLookup[];
#endif // _SECONDARYCLASSIFICATION_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\apply.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  APPLY.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements OTL Library calls dealing with  
*       applying features and lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"
/***********************************************************************/

void InitializeFeatureResults
(
    const otlFeatureSet*        pFSet,
    otlList*                    pliFResults
)
{
    if (pliFResults == NULL) return;

    assert((pFSet->liFeatureDesc).length() == pliFResults->length());
    assert((pFSet->liFeatureDesc).dataSize() == sizeof(otlFeatureDesc));
    assert(pliFResults->dataSize() == sizeof(otlFeatureResult));

    USHORT cFeatureDesc = (pFSet->liFeatureDesc).length();
    
    for (USHORT i = 0; i < cFeatureDesc; ++i)
    {
        otlFeatureResult* pResult = getOtlFeatureResult(pliFResults, i);
        const otlFeatureDesc* pFDesc = 
            readOtlFeatureDesc(&pFSet->liFeatureDesc, i);

        pResult->pFDesc = pFDesc;
        pResult->cResActions = 0;
    }

}

void UpdateFeatureResults
(
    const otlFeatureSet*        pFSet,
    USHORT                      iLookup,
    long                        lParameter,

    const otlList*              pliCharMap,
    const otlList*              pliGlyphInfo,    
    USHORT                      iGlyph,

    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,

    otlList*                    pliFResults
)
{
    if (pliFResults == NULL) return;

    assert((pFSet->liFeatureDesc).length() == pliFResults->length());
    assert((pFSet->liFeatureDesc).dataSize() == sizeof(otlFeatureDesc));
    assert(pliFResults->dataSize() == sizeof(otlFeatureResult));

    const otlGlyphInfo* pGlyphInfo = 
        readOtlGlyphInfo(pliGlyphInfo, iGlyph);

    USHORT cFeatureDesc = (pFSet->liFeatureDesc).length();
    for (USHORT iFeature = 0; iFeature < cFeatureDesc; ++iFeature)
    {
        const otlFeatureDesc* pFDesc = 
            readOtlFeatureDesc(&pFSet->liFeatureDesc, iFeature);

        otlFeatureResult* pResult = 
            getOtlFeatureResult(pliFResults, iFeature);

        assert(pResult->pFDesc == pFDesc);

        USHORT ichComp = pGlyphInfo->iChar;
        for (USHORT i = 0; i < pGlyphInfo->cchLig; ++i)
        {
            if (otlRange(pFDesc->ichStart, pFDesc->ichStart + pFDesc->cchScope)
                .contains(ichComp))
            {

                ++pResult->cResActions;
            }

            if (i + 1 < pGlyphInfo->cchLig)
            {
                ichComp = NextCharInLiga(pliCharMap, ichComp);
            }
        }

    }

    return;
}

// update glyph flags after lookup application
inline
void UpdateGlyphFlags
(
    otlTag      tagTable,
    otlList*    pliGlyphInfo,
    USHORT      iglFirst,
    USHORT      iglAfterLast
)
{
    if (tagTable == OTL_GSUB_TAG)
    {
        for (USHORT igl = iglFirst; igl < iglAfterLast; ++igl)
        {
            getOtlGlyphInfo(pliGlyphInfo, igl)->grf |= OTL_GFLAG_SUBST;
        }
    }
    else if (tagTable == OTL_GPOS_TAG)
    {
        for (USHORT igl = iglFirst; igl < iglAfterLast; ++igl)
        {
            getOtlGlyphInfo(pliGlyphInfo,igl)->grf |= OTL_GFLAG_POS;
        }
    }
}


void RefreshEnablesCache(
    const otlFeatureSet*        pFSet,
    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,

    USHORT iLookup,
    otlEnablesCache  &ec,

    otlSecurityData sec
)
{    
    if (!ec.IsActive()) return;

    ec.SetFirst(iLookup); 
    ec.ClearFlags();

    USHORT cFeatures = (pFSet->liFeatureDesc).length();

    //RequiredFeature
    ec.Refresh(RequiredFeature(langSysTable, featureList,sec), 
                                                ec.RequiredFeatureFlagIndex());

    for (USHORT iFeature = 0; iFeature < cFeatures; ++iFeature)
    {
        const otlFeatureDesc* pFDesc 
                   = readOtlFeatureDesc(&pFSet->liFeatureDesc, iFeature);

        if (pFDesc->lParameter != 0)
        {
            ec.Refresh(FindFeature(langSysTable, featureList,pFDesc->tagFeature,sec),iFeature);
        }
    }
}

void GetNewEnabledCharRange
(
    const otlFeatureSet*        pFSet,
    USHORT                      iLookup,

    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,

    USHORT      ichStart,
    USHORT*     pichFirst,
    USHORT*     pichAfterLast,
    long*       plParameter,

    const otlEnablesCache&      ec,

    otlSecurityData     sec
)
{

    // REVIEW (PERF)
    // There are two ways to speed this process up:
    // 1. Sort feature descriptors by ichStart
    // 2. Build in advance a table indicating which feature 
    //    descriptor enables which lookup and use it
    //
    // sergeym(09/29/00): Now we use Enables cache

    USHORT cFeatures = (pFSet->liFeatureDesc).length();

    ichStart = MAX(ichStart, pFSet->ichStart);

    if (EnablesRequired(langSysTable,featureList,iLookup,ec,sec))
    {
        *pichFirst = ichStart;
        *pichAfterLast = pFSet->ichStart + pFSet->cchScope;
        // REVIEW: a required feature should not take non-trivial parameters
        //          (or not force it -- and leave it to the app?)
        *plParameter = 1;
        return;
    }

    *pichFirst = MAXUSHORT;
    *plParameter = 0;
    for (USHORT iFeatureFirst = 0; iFeatureFirst < cFeatures; ++iFeatureFirst)
    {
        const otlFeatureDesc* pFDesc = 
            readOtlFeatureDesc(&pFSet->liFeatureDesc, iFeatureFirst);

        if (Enables(langSysTable,featureList,pFDesc,iLookup,iFeatureFirst,ec,sec) &&
            pFDesc->lParameter != 0 &&
            otlRange(pFDesc->ichStart, pFDesc->ichStart + pFDesc->cchScope)
             .intersects(otlRange(ichStart, *pichFirst))
           )   
        {
            assert(*pichFirst > pFDesc->ichStart);

            *pichFirst = MAX(ichStart, pFDesc->ichStart);
            *plParameter = pFDesc->lParameter;
        }
    }
    
    *pichFirst = MIN(*pichFirst, pFSet->ichStart + pFSet->cchScope);

    // did we get anything?
    if (*plParameter == 0)
    {
        *pichAfterLast = *pichFirst;
        return;
    }

    // got the new range start
    // now, the scope
    *pichAfterLast = *pichFirst + 1;
    USHORT iFeature = 0;
    while (iFeature < cFeatures)
    {
        const otlFeatureDesc* pFDesc = 
            readOtlFeatureDesc(&pFSet->liFeatureDesc, iFeature);
        
        if (Enables(langSysTable,featureList,pFDesc,iLookup,iFeature,ec,sec) &&
             pFDesc->lParameter == *plParameter &&
             otlRange(pFDesc->ichStart, pFDesc->ichStart + pFDesc->cchScope)
             .contains(*pichAfterLast)
           )
        {
            assert(*pichAfterLast < pFDesc->ichStart + pFDesc->cchScope);

            *pichAfterLast = pFDesc->ichStart + pFDesc->cchScope;
            
            // start all over (yes, we have to -- or sort)
            iFeature = 0;
        }
        else
        {
            ++iFeature;
        }
        
    }
    
    *pichAfterLast = MIN(*pichAfterLast, pFSet->ichStart + pFSet->cchScope);
}

inline
void GetGlyphRangeFromCharRange
(
    const otlList*      pliCharMap,    
    USHORT              ichFirst,
    USHORT              ichAfterLast,

    const otlList*      pliGlyphInfo,
    USHORT              iglStart,

    USHORT*             piglFirst,
    USHORT*             piglAfterLast
)
{
    // there's no 100%-correct way of mapping
    // so we stick with the simple one that's based on "visual continuity"

    *piglFirst = MAX(iglStart, readOtlGlyphIndex(pliCharMap, ichFirst));
    if (ichAfterLast < pliCharMap->length())
        *piglAfterLast = readOtlGlyphIndex(pliCharMap, ichAfterLast);
    else
        *piglAfterLast = pliGlyphInfo->length();

    return;

//  // update iglFirst, iglAfterLast acording to ichFrist, ichAfterLast
//  *piglFirst = MAXUSHORT;
//  *piglAfterLast = 0;
//  for (USHORT ich = ichFirst; ich < ichAfterLast; ++ich)
//  {
//      USHORT iGlyph = readOtlGlyphIndex(pliCharMap, ich);
//
//      if (iGlyph < *piglFirst && iGlyph >= iglStart)
//      {
//          *piglFirst = iGlyph;
//      }
//
//      if (iGlyph >= *piglAfterLast)
//      {
//          *piglAfterLast = iGlyph + 1;
//      }
//  }
}


otlErrCode ApplyFeatures
(
    otlTag                      tagTable,                   // GSUB/GPOS
    const otlFeatureSet*        pFSet,

    otlList*                    pliCharMap,
    otlList*                    pliGlyphInfo,  
    
    otlResourceMgr&             resourceMgr,

    otlTag                      tagScript,
    otlTag                      tagLangSys,

    const otlMetrics&   metr,       

    otlList*            pliduGlyphAdv,              // assert null for GSUB
    otlList*            pliplcGlyphPlacement,       // assert null for GSUB

    otlList*            pliFResults
)
{
    assert(tagTable == OTL_GPOS_TAG || tagTable == OTL_GSUB_TAG);

    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliCharMap->dataSize() == sizeof(USHORT));

    if (tagTable == OTL_GSUB_TAG)
    {
        assert(pliduGlyphAdv == NULL && pliplcGlyphPlacement == NULL);
    }
    else
    {
        assert(pliduGlyphAdv != NULL && pliplcGlyphPlacement != NULL);
        assert(pliduGlyphAdv->dataSize() == sizeof(long));
        assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));
    }

    otlErrCode erc;

    USHORT cFeatures = pFSet->liFeatureDesc.length();

    // prepare tables
    otlSecurityData sec = secEmptySecurityData;
    otlFeatureListTable featureList = otlFeatureListTable((const BYTE*)NULL,sec);
    otlScriptListTable scriptList = otlScriptListTable((const BYTE*)NULL,sec);
    otlLookupListTable lookupList = otlLookupListTable((const BYTE*)NULL,sec);

    erc = GetScriptFeatureLookupLists(tagTable, resourceMgr, 
                                            &scriptList, 
                                            &featureList, 
                                            &lookupList,
                                            &sec);
    if (erc != OTL_SUCCESS) return erc; // fatal error, return immediately
   
    // get the script and lang sys tables
    otlScriptTable scriptTable = FindScript(scriptList, tagScript,sec);
    if (!scriptTable.isValid()) return OTL_ERR_SCRIPT_NOT_FOUND;

    if (scriptTable.isNull())
    {
        return OTL_ERR_SCRIPT_NOT_FOUND;
    }

    otlLangSysTable langSysTable = FindLangSys(scriptTable, tagLangSys,sec);
    if (langSysTable.isNull())
    {
        return OTL_ERR_LANGSYS_NOT_FOUND;
    }

    // get GDEF
    otlSecurityData secgdef;
    const BYTE *pbgdef;
    resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
    otlGDefHeader gdef = 
        otlGDefHeader(pbgdef,secgdef);
    
    // go though lookups
    USHORT cLookups = lookupList.lookupCount();
    InitializeFeatureResults(pFSet, pliFResults);


    //Init ECache
    const USHORT DefaultECacheSize =256;
    BYTE DefaultECacheBuffer[DefaultECacheSize];
    
    otlEnablesCache ec(cFeatures,DefaultECacheBuffer,DefaultECacheSize);
    
    ec.Allocate(resourceMgr,cLookups);
    ec.Reset();

    for (USHORT iLookup = 0; iLookup < cLookups; ++iLookup)
    {
        if (!ec.InCache(iLookup))
            RefreshEnablesCache(pFSet, langSysTable, featureList, iLookup, ec, sec);

        if (!EnablesSomewhere(iLookup,ec)) continue;

        USHORT iglFirst = 0;
        USHORT iglAfterLast = 0;

        USHORT ichFirst = 0;
        USHORT ichAfterLast = 0;

        long lParameter = 0;

        // go though indexes keeping the upper bound of enabled range 
        otlLookupTable lookupTable = lookupList.lookup(iLookup,sec);

        // REVIEW (PERF): Consider defining lookupTable.coverage(),
        // getting it here and calling getIndex on it before ApplyLookup
        // down in the loop

        bool fLookupFinished = false;
        while (iglFirst < pliGlyphInfo->length() && !fLookupFinished)
        {
            if (iglAfterLast > iglFirst)
            {
                
                // for every index where it's enabled, try applying
                USHORT iglNext;
                USHORT iglAfterLastReliable = 
                            pliGlyphInfo->length() - iglAfterLast;
                erc = ApplyLookup(tagTable,
                                pliCharMap,
                                pliGlyphInfo,
                                resourceMgr,

                                lookupTable,
                                lParameter,
                                0,              // context nesting level

                                metr,          
                                pliduGlyphAdv,          
                                pliplcGlyphPlacement,   

                                iglFirst,           
                                iglAfterLast,           

                                &iglNext,

                                sec
                              );
                if (ERRORLEVEL(erc) > 0) return erc;
                
                if (erc == OTL_SUCCESS)
                {
                    // application successful
                    iglAfterLast = pliGlyphInfo->length() - iglAfterLastReliable;

                    // if GSUB, update new glyph types
                    if (tagTable == OTL_GSUB_TAG)
                    {
                        AssignGlyphTypes(pliGlyphInfo, gdef, secgdef, 
                                         iglFirst, iglNext, otlDoAll);
                    }

                    // update glyph flags
                    UpdateGlyphFlags(tagTable, pliGlyphInfo, iglFirst, iglNext);
                    
                    // update results for every fdef that was enabling this lookup
                    UpdateFeatureResults(pFSet, iLookup, lParameter, 
                                        pliCharMap, pliGlyphInfo, iglFirst,
                                        langSysTable, featureList, pliFResults);
                }
                else
                {
                    iglNext = iglFirst + 1;
                }

                // update next glyph
                assert(iglNext > iglFirst);
                iglFirst = NextGlyphInLookup(pliGlyphInfo, lookupTable.flags(),  
                                             gdef, secgdef,
                                             iglNext, otlForward);
            }
            else
            {
                // update next glyph and scope
                GetNewEnabledCharRange(pFSet, iLookup, 
                                        langSysTable, featureList, ichAfterLast, 
                                        &ichFirst, &ichAfterLast, &lParameter,
                                        ec,sec
                                      );

                if (lParameter != 0)
                {
                    assert(ichFirst < ichAfterLast);
                    GetGlyphRangeFromCharRange(pliCharMap, ichFirst, ichAfterLast,
                                               pliGlyphInfo, iglFirst, 
                                               &iglFirst, &iglAfterLast);

                    //and go to the next valid glyph for this lookup
                    iglFirst = NextGlyphInLookup(pliGlyphInfo, lookupTable.flags(), 
                                                 gdef, secgdef,
                                                 iglFirst, otlForward);
                }
                else
                {
                    //got nothing more to work on; it is time to say goodbye
                    fLookupFinished = true;
                }
            }
        }
    }

    return OTL_SUCCESS;
}


short NextGlyphInLookup
(
    const otlList*      pliGlyphInfo, 

    USHORT                  grfLookupFlags,
    const otlGDefHeader&    gdef,
    otlSecurityData         secgdef,

    short               iglFirst,
    otlDirection        direction
)
{
    assert(pliGlyphInfo != (otlList*)NULL);

    USHORT iglAfterLast = pliGlyphInfo->length();
    assert(iglAfterLast >= iglFirst);
    assert(iglFirst >= -1);

    if(grfLookupFlags == 0)
    {
        // a shortcut
        return iglFirst;
    }

    //Font Validation assert
    //assert( !gdef.isNull()); // no GDEF table but lookup flags are used 

    for (short i = iglFirst; i < iglAfterLast && i >= 0; i += direction)
    {
        const otlGlyphInfo* pGlyphInfo = 
            readOtlGlyphInfo(pliGlyphInfo, i);

        if ((grfLookupFlags & otlIgnoreMarks) != 0 &&
            (pGlyphInfo->grf & OTL_GFLAG_CLASS) == otlMarkGlyph)
        {
            continue;
        }

        if ((grfLookupFlags & otlIgnoreBaseGlyphs) != 0 &&
            (pGlyphInfo->grf & OTL_GFLAG_CLASS) == otlBaseGlyph)
        {
            continue;
        }

        if ((grfLookupFlags & otlIgnoreLigatures) != 0 &&
            (pGlyphInfo->grf & OTL_GFLAG_CLASS) == otlLigatureGlyph)
        {
            continue;
        }

        if (attachClass(grfLookupFlags)!= 0 && 
            (pGlyphInfo->grf & OTL_GFLAG_CLASS) == otlMarkGlyph &&
            gdef.attachClassDef(secgdef).getClass(pGlyphInfo->glyph,secgdef) 
                != attachClass(grfLookupFlags) )
        {
            continue;
        }

        return i;
    }

    // found nothing -- skipped all
    return (direction > 0)  ? iglAfterLast 
                            : -1;
}

otlErrCode ApplyLookup
(
    otlTag                      tagTable,           // GSUB/GPOS
    otlList*                    pliCharMap,
    otlList*                    pliGlyphInfo,
    otlResourceMgr&             resourceMgr,

    const otlLookupTable&       lookupTable,
    long                        lParameter,
    USHORT                      nesting,

    const otlMetrics&           metr,       
    otlList*                    pliduGlyphAdv,          // assert null for GSUB
    otlList*                    pliplcGlyphPlacement,   // assert null for GSUB

    USHORT                      iglFirst,       // where to apply it
    USHORT                      iglAfterLast,   // how long a context we can use

    USHORT*                     piglNext,       // out: next glyph index

    otlSecurityData             sec
)
{
    assert(tagTable == OTL_GSUB_TAG || tagTable == OTL_GPOS_TAG);

    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliCharMap->dataSize() == sizeof(USHORT));

    assert(lParameter != 0);

    assert(iglFirst < iglAfterLast);
    assert(iglAfterLast <= pliGlyphInfo->length());

    if (tagTable == OTL_GSUB_TAG)
    {
        assert(pliduGlyphAdv == NULL && pliplcGlyphPlacement == NULL);
    }
    else
    {
        assert(pliduGlyphAdv != NULL && pliplcGlyphPlacement != NULL);
        assert(pliduGlyphAdv->dataSize() == sizeof(long));
        assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));
        assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length() &&
                pliduGlyphAdv->length() == pliGlyphInfo->length());
    }

    assert (piglNext != NULL);


    const lookupTypeGSUBExtension=7;
    const lookupTypeGPOSExtension=9;

    otlErrCode erc;
    USHORT iSub;
    bool   bExtension;

    USHORT        lookupType  = lookupTable.lookupType();
    otlGlyphFlags lookupFlags = lookupTable.flags();
    
    if (tagTable == OTL_GSUB_TAG)
    {
        bExtension = (lookupType==lookupTypeGSUBExtension);

        for (iSub = 0; iSub < lookupTable.subTableCount(); ++iSub)
        {
            otlLookupFormat subTable = lookupTable.subTable(iSub,sec);
            if (!subTable.isValid()) continue;
            
            if (bExtension) 
            {
                otlExtensionLookup extLookup=otlExtensionLookup(subTable,sec);
                if (!extLookup.isValid()) continue;
                lookupType = extLookup.extensionLookupType();
                subTable   = extLookup.extensionSubTable(sec);
                if (!subTable.isValid()) continue;
            }

            switch(lookupType)
            {
            case(1):    // single substitution
                erc = otlSingleSubstLookup(subTable,sec)
                            .apply(pliGlyphInfo, 
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(2):    // multiple substitution
                erc = otlMultiSubstLookup(subTable,sec)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags,  
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(3):    // alternate substiution
                erc = otlAlternateSubstLookup(subTable,sec)
                            .apply(pliGlyphInfo, 
                                   lParameter, 
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(4):    // ligature substitution
                erc = otlLigatureSubstLookup(subTable,sec)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags,  
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;
            
            case(5):    // context subst
                erc = otlContextLookup(subTable,sec)
                            .apply(tagTable, pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, lParameter, nesting,
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(6):    // chaining context subst
                erc = otlChainingLookup(subTable,sec)
                            .apply(tagTable, pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, lParameter, nesting,
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(7):    // extension subst
                assert(false); //we had to process it before (as Extension lookup type)
                return OTL_ERR_BAD_FONT_TABLE;
                break;

            default:
                return OTL_ERR_BAD_FONT_TABLE;
            }
        }
        return OTL_NOMATCH;
    }
    else if (tagTable == OTL_GPOS_TAG)
    {
        bExtension = (lookupType==lookupTypeGPOSExtension);

        for (iSub = 0; iSub < lookupTable.subTableCount(); ++iSub)
        {
            otlLookupFormat subTable = lookupTable.subTable(iSub,sec);
            if (!subTable.isValid()) continue;
            
            if (bExtension) 
            {
                otlExtensionLookup extLookup=otlExtensionLookup(subTable,sec);
                if (!extLookup.isValid()) continue;
                lookupType = extLookup.extensionLookupType();
                subTable   = extLookup.extensionSubTable(sec);
                if (!subTable.isValid()) continue;

            }

            switch(lookupType)
            {
            case(1):    // single adjustment
                erc = otlSinglePosLookup(subTable,sec)
                            .apply(pliGlyphInfo,  
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(2):    // pair adjustment
                erc = otlPairPosLookup(subTable,sec)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, 
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(3):    // cursive attachment
                erc = otlCursivePosLookup(subTable,sec)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, 
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(4):    // mark to base
                //assert(lookupFlags == 0); //this lookup does not take flags
                erc = otlMkBasePosLookup(subTable,sec)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;
            
            case(5):    // mark to ligature
                //assert(lookupFlags == 0); //this lookup does not take flags
                erc = otlMkLigaPosLookup(subTable,sec)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(6):    // mark to mark
                erc = otlMkMkPosLookup(subTable,sec)
                            .apply(pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, 
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(7):    // context positionong
                erc = otlContextLookup(subTable,sec)
                            .apply(tagTable, pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, lParameter, nesting,
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(8):    // chaining context positioning
                erc = otlChainingLookup(subTable,sec)
                            .apply(tagTable, pliCharMap, pliGlyphInfo, resourceMgr, 
                                   lookupFlags, lParameter, nesting,
                                   metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                   iglFirst, iglAfterLast, piglNext,sec);
                if (erc != OTL_NOMATCH) return erc;
                break;

            case(9):    // extension positioning
                assert(false); //we had to process it before (as Extension lookup type)
                return OTL_ERR_BAD_FONT_TABLE;
                break;

            default:
                return OTL_ERR_BAD_FONT_TABLE;
            }
        }
        return OTL_NOMATCH;
    }

    // this should not happen -- still return something
    assert(false);
    return OTL_ERR_BAD_INPUT_PARAM;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\inc\otltypes.inl ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLTYPES.INL  ********
*
*              Open Type Layout Services Library Header File
*
*       This module contains inline functions for handling basic OTL structures
*
*       Copyright 1997. Microsoft Corporation.
*
*       July 27, 1997    v 0.9		AndreiB		Created
*
************************************************************************
***********************************************************************/

/***********************************************************************
*   
*       otlList inline helper functions 
*
***********************************************************************/

#include <assert.h>
#include <string.h>

// otlList inline functions

void otlList::reset(void* pvNewData, USHORT cbNewDataSize, 
					USHORT celmNewLength, USHORT celmNewMaxLen)
{
	assert(pvNewData != NULL || celmNewMaxLen == 0);
	assert(celmNewLength <= celmNewMaxLen);

	pvData = pvNewData;
	cbDataSize = cbNewDataSize;
	celmLength = celmNewLength;
	celmMaxLen = celmNewMaxLen;
}


inline BYTE* otlList::elementAt(unsigned short index)
{
	assert(index < celmLength);
	return (BYTE*)pvData + index * cbDataSize;
}

inline const BYTE* otlList::readAt(unsigned short index) const
{
	assert(index < celmLength);
	return (BYTE*)pvData + index * cbDataSize;
}

inline void otlList::insertAt(unsigned short index, unsigned short celm)
{
	assert(index <= celmLength);
	assert(celmMaxLen >= celmLength + celm);

	memmove((BYTE*)pvData + (index + celm) * cbDataSize,
			(BYTE*)pvData + index * cbDataSize, 
			(celmLength - index) * cbDataSize);

	celmLength += celm;
}

inline void otlList::deleteAt(unsigned short index, unsigned short celm)
{
	assert(index <= celmLength);
	assert(celmLength - celm >= 0);

	memmove((BYTE*)pvData + index * cbDataSize,
			(BYTE*)pvData + (index + celm) * cbDataSize, 
			(celmLength - index - celm) * cbDataSize);

	celmLength -= celm;
}

inline void otlList::append(const BYTE* element)
{
	assert(celmMaxLen > celmLength);
	memcpy((BYTE*)pvData + celmLength * cbDataSize, element, cbDataSize);
	++celmLength;
}


// type-specific primitives to avoid constant casting

// otlTag
inline otlTag readOtlTag(const otlList* pliTag, USHORT i)
{
	assert(pliTag->dataSize() == sizeof(otlTag));
	return *(const otlTag*)pliTag->readAt(i);
}


// otlGlyphInfo
inline const otlGlyphInfo* readOtlGlyphInfo(const otlList* pliGlyphInfo, USHORT i)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	return (const otlGlyphInfo*)pliGlyphInfo->readAt(i);
}

inline otlGlyphInfo* getOtlGlyphInfo(otlList* pliGlyphInfo, USHORT i)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	return (otlGlyphInfo*)pliGlyphInfo->elementAt(i);
}


// wchar
inline WCHAR readOtlChar(const otlList* pliChars, USHORT i)
{
	assert(pliChars->dataSize() == sizeof(WCHAR));
	return *(const WCHAR*)pliChars->readAt(i);
}


// iGlyph
inline USHORT readOtlGlyphIndex(const otlList* pliGlyphMap, USHORT i)
{
	assert(pliGlyphMap->dataSize() == sizeof(USHORT));
	return *(const USHORT*)pliGlyphMap->readAt(i);
}

inline USHORT* getOtlGlyphIndex(otlList* pliGlyphMap, USHORT i)
{
	assert(pliGlyphMap->dataSize() == sizeof(USHORT));
	return (USHORT*)pliGlyphMap->elementAt(i);
}


// otlPlacement
inline const otlPlacement* readOtlPlacement(const otlList* pliPlacement, USHORT i)
{
	assert(pliPlacement->dataSize() == sizeof(otlPlacement));
	return (const otlPlacement*)pliPlacement->readAt(i);
}

inline otlPlacement* getOtlPlacement(otlList* pliPlacement, USHORT i)
{
	assert(pliPlacement->dataSize() == sizeof(otlPlacement));
	return (otlPlacement*)pliPlacement->elementAt(i);
}


// advance widths
inline const long readOtlAdvance(const otlList* pliAdvance, USHORT i)
{
	assert(pliAdvance->dataSize() == sizeof(long));
	return *(const long*)pliAdvance->readAt(i);
}

inline long* getOtlAdvance(otlList* pliAdvance, USHORT i)
{
	assert(pliAdvance->dataSize() == sizeof(long));
	return (long*)pliAdvance->elementAt(i);
}


// otlFeatureDef (no read-only mode)
inline otlFeatureDef* getOtlFeatureDef(otlList* pliFDef, USHORT i)
{
	assert(pliFDef->dataSize() == sizeof(otlFeatureDef));
	return (otlFeatureDef*)pliFDef->elementAt(i);
}


// otlFeatureDesc (read-only - never modify)
inline const otlFeatureDesc* readOtlFeatureDesc(const otlList* pliFDesc, USHORT i)
{
	assert(pliFDesc->dataSize() == sizeof(otlFeatureDesc));
	return (const otlFeatureDesc*)pliFDesc->readAt(i);
}


// otlFeatureResult (no read-only mode)
inline otlFeatureResult* getOtlFeatureResult(otlList* pliFRes, USHORT i)
{
	assert(pliFRes->dataSize() == sizeof(otlFeatureResult));
	return (otlFeatureResult*)pliFRes->elementAt(i);
}


// otlBaseline (no read-only mode)
inline otlBaseline* getOtlBaseline(otlList* pliBaseline, USHORT i)
{
	assert(pliBaseline->dataSize() == sizeof(otlBaseline));
	return (otlBaseline*)pliBaseline->elementAt(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\chaining.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  CHAINING.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with chaining context-based substitution lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

    
otlErrCode otlChainingLookup::apply
(
    otlTag                  tagTable,
    otlList*                pliCharMap,
    otlList*                pliGlyphInfo,
    otlResourceMgr&         resourceMgr,

    USHORT                  grfLookupFlags,
    long                    lParameter,
    USHORT                  nesting,

    const otlMetrics&       metr,       
    otlList*                pliduGlyphAdv,              
    otlList*                pliplcGlyphPlacement,       

    USHORT                  iglIndex,
    USHORT                  iglAfterLast,

    USHORT*                 piglNextGlyph,      // out: next glyph

    otlSecurityData         sec
)
{
    if (!isValid()) return OTL_NOMATCH;

    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliCharMap->dataSize() == sizeof(USHORT));
    assert(iglAfterLast > iglIndex);
    assert(iglAfterLast <= pliGlyphInfo->length());

    otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);

    switch(format())  //sec: format() works since checked in LookupFormat
    {
    case(1):    // simple
        {
            otlChainSubTable simpleChainContext = otlChainSubTable(pbTable,sec);
            if (!simpleChainContext.isValid()) return OTL_NOMATCH;
            
            short index = simpleChainContext.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
            if (index < 0)
            {
                return OTL_NOMATCH;
            }

            if (index >= simpleChainContext.ruleSetCount())
            {
                return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
            }
            otlChainRuleSetTable ruleSet = simpleChainContext.ruleSet(index,sec);
            
            // get GDEF
            otlSecurityData secgdef;
            const BYTE *pbgdef;
            resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
            otlGDefHeader gdef = 
                otlGDefHeader(pbgdef,secgdef);

            // start checking contextes
            USHORT cRules = ruleSet.ruleCount();
            bool match = false;
            for (USHORT iRule = 0; iRule < cRules && !match; ++iRule)
            {
                match = true;

                otlChainRuleTable rule = ruleSet.rule(iRule,sec);
                if (!rule.isValid()) 
                {
                    match = false;
                }
                
                const USHORT cBacktrackGlyphs = rule.backtrackGlyphCount();
                const USHORT cLookaheadGlyphs = rule.lookaheadGlyphCount();
                const USHORT cInputGlyphs = rule.inputGlyphCount();

                // a simple check so we don't waste time
                if (iglIndex < cBacktrackGlyphs ||
                    iglIndex + cInputGlyphs > iglAfterLast)
                {
                    match = false;
                }

                short igl = iglIndex;
                for (USHORT iGlyphBack = 0; 
                            iGlyphBack < cBacktrackGlyphs && match; ++iGlyphBack)
                {
                    igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, secgdef, 
                                            igl - 1, otlBackward);

                    if (igl < 0 ||
                        getOtlGlyphInfo(pliGlyphInfo, igl)->glyph != 
                          rule.backtrack(iGlyphBack))
                    {
                        match = false;
                    }
                }
                

                igl = iglIndex;
                for (USHORT iGlyphInput = 1; 
                            iGlyphInput < cInputGlyphs && match; ++iGlyphInput)
                {
                    igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef,  secgdef,
                                            igl + 1, otlForward);

                    if (igl >= iglAfterLast ||
                        getOtlGlyphInfo(pliGlyphInfo, igl)->glyph != 
                          rule.input(iGlyphInput))
                    {
                        match = false;
                    }
                }
                
                // remember the next glyph in lookup here
                *piglNextGlyph = NextGlyphInLookup(pliGlyphInfo, 
                                                    grfLookupFlags, gdef, secgdef, 
                                                    igl + 1, otlForward);

                // igl: stays the same
                USHORT iglUBound = pliGlyphInfo->length();
                for (USHORT iGlyphForward = 0; 
                            iGlyphForward < cLookaheadGlyphs && match; ++iGlyphForward)
                {
                    igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, secgdef, 
                                            igl + 1, otlForward);

                    if (igl >= iglUBound ||
                        getOtlGlyphInfo(pliGlyphInfo, igl)->glyph != 
                          rule.lookahead(iGlyphForward))
                    {
                        match = false;
                    }
                }


                if (match)
                {

                    return applyContextLookups (rule.lookupRecords(),
                                    tagTable, 
                                    pliCharMap, pliGlyphInfo, resourceMgr,
                                    grfLookupFlags, lParameter, nesting,
                                    metr, pliduGlyphAdv, pliplcGlyphPlacement,  
                                    iglIndex, *piglNextGlyph, piglNextGlyph,sec);
                }
            }

            return OTL_NOMATCH;
        }

    case(2):    // class-based
        {
            otlChainClassSubTable classChainContext = 
                                    otlChainClassSubTable(pbTable,sec);
            if (!classChainContext.isValid()) return OTL_NOMATCH;
            
            short index = classChainContext.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
            if (index < 0)
            {
                return OTL_NOMATCH;
            }
            
            otlClassDef backClassDef =  classChainContext.backtrackClassDef(sec);
            otlClassDef inputClassDef =  classChainContext.inputClassDef(sec);
            otlClassDef aheadClassDef =  classChainContext.lookaheadClassDef(sec);

            USHORT indexClass = inputClassDef.getClass(pGlyphInfo->glyph,sec);

            if (indexClass >= classChainContext.ruleSetCount())
            {
                return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
            }
            otlChainClassRuleSetTable ruleSet = 
                    classChainContext.ruleSet(indexClass,sec);

            if (ruleSet.isNull())
            {
                return OTL_NOMATCH;
            }

            // get GDEF
            otlSecurityData secgdef;
            const BYTE *pbgdef;
            resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
            otlGDefHeader gdef = 
                otlGDefHeader(pbgdef,secgdef);

            // start checking contextes
            USHORT cRules = ruleSet.ruleCount();
            bool match = false;
            for (USHORT iRule = 0; iRule < cRules && !match; ++iRule)
            {
                otlChainClassRuleTable rule = ruleSet.rule(iRule,sec);
                short igl;

                match = true;

                const USHORT cBacktrackGlyphs = rule.backtrackClassCount();
                const USHORT cInputGlyphs = rule.inputClassCount();
                const USHORT cLookaheadGlyphs = rule.lookaheadClassCount();

                // a simple check so we don't waste time
                if (iglIndex < cBacktrackGlyphs ||
                    iglIndex + cInputGlyphs > iglAfterLast)
                {
                    match = false;
                }

                igl = iglIndex;
                for (USHORT iGlyphBack = 0; 
                            iGlyphBack < cBacktrackGlyphs && match; ++iGlyphBack)
                {
                    igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, secgdef, 
                                            igl - 1, otlBackward);

                    if (igl < 0 ||
                        backClassDef
                            .getClass(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph,sec)
                        != rule.backtrackClass(iGlyphBack))
                    {
                        match = false;
                    }
                }
                

                igl = iglIndex;
                for (USHORT iGlyphInput = 1; 
                            iGlyphInput < cInputGlyphs && match; ++iGlyphInput)
                {
                    igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, secgdef, 
                                            igl + 1, otlForward);

                    if (igl >= iglAfterLast || 
                        inputClassDef
                            .getClass(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph,sec)
                        != rule.inputClass(iGlyphInput))
                    {
                        match = false;
                    }
                }
                
                // remember the next glyph in lookup here
                *piglNextGlyph = NextGlyphInLookup(pliGlyphInfo, 
                                                    grfLookupFlags, gdef, secgdef, 
                                                    igl + 1, otlForward);

                // igl: stays the same
                USHORT iglUBound = pliGlyphInfo->length();
                for (USHORT iGlyphForward = 0; 
                            iGlyphForward < cLookaheadGlyphs && match; ++iGlyphForward)
                {
                    igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, secgdef, 
                                            igl + 1, otlForward);

                    if (igl >= iglUBound ||
                        aheadClassDef
                            .getClass(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph,sec)
                        != rule.lookaheadClass(iGlyphForward))
                    {
                        match = false;
                    }
                }

                if (match)
                {

                    return applyContextLookups (rule.lookupRecords(),
                                    tagTable, 
                                    pliCharMap, pliGlyphInfo, resourceMgr,
                                    grfLookupFlags,lParameter, nesting,
                                    metr, pliduGlyphAdv, pliplcGlyphPlacement,  
                                    iglIndex,*piglNextGlyph, piglNextGlyph,sec);
                }
            }

            return OTL_NOMATCH;
        }
    case(3):    // coverage-based
        {
            otlChainCoverageSubTable coverageChainContext = 
                                otlChainCoverageSubTable(pbTable,sec);
            if (!coverageChainContext.isValid()) return OTL_NOMATCH;

            bool match = true;
            
            const USHORT cBacktrackGlyphs = 
                    coverageChainContext.backtrackCoverageCount();
            const USHORT cInputGlyphs = 
                        coverageChainContext.inputCoverageCount();
            const USHORT cLookaheadGlyphs = 
                        coverageChainContext.lookaheadCoverageCount();

            // a simple check so we don't waste time
            if (iglIndex < cBacktrackGlyphs ||
                iglIndex + cInputGlyphs > iglAfterLast)
            {
                match = false;
            }

            // get GDEF
            otlSecurityData secgdef;
            const BYTE *pbgdef;
            resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
            otlGDefHeader gdef = 
                otlGDefHeader(pbgdef,secgdef);

            short igl = iglIndex;
            for (USHORT iGlyphBack = 0; 
                        iGlyphBack < cBacktrackGlyphs && match; ++iGlyphBack)
            {
                igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, secgdef, 
                                        igl - 1, otlBackward);

                if (igl < 0 ||
                    coverageChainContext.backtrackCoverage(iGlyphBack,sec)
                    .getIndex(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph,sec) < 0)
                {
                    match = false;
                }
            }
                
            igl = iglIndex;
            for (USHORT iGlyphInput = 0; 
                        iGlyphInput < cInputGlyphs && match; ++iGlyphInput)
            {
                if (igl >= iglAfterLast || 
                    coverageChainContext.inputCoverage(iGlyphInput,sec)
                    .getIndex(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph,sec) < 0)
                {
                    match = false;
                }
                else
                {
                    igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, secgdef, 
                                            igl + 1, otlForward);
                }
            }

            *piglNextGlyph = igl;

            // igl: stays the same
            USHORT iglUBound = pliGlyphInfo->length();
            for (USHORT iGlyphForward = 0; 
                        iGlyphForward < cLookaheadGlyphs && match; ++iGlyphForward)
            {
                if (igl >= iglUBound || 
                    coverageChainContext.lookaheadCoverage(iGlyphForward,sec)
                        .getIndex(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph,sec) < 0)
                {
                    match = false;
                }
                else
                {
                    igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, secgdef, 
                                            igl + 1, otlForward);
                }
            }


            if (match)
            {
                return applyContextLookups (coverageChainContext.lookupRecords(),
                                    tagTable, 
                                    pliCharMap, pliGlyphInfo, resourceMgr,
                                    grfLookupFlags,lParameter, nesting,
                                    metr, pliduGlyphAdv, pliplcGlyphPlacement,  
                                    iglIndex, *piglNextGlyph, piglNextGlyph,sec);
            }

            return OTL_NOMATCH;
        }

    default:
        //Unknown format, don't do anything
        return OTL_NOMATCH; //OTL_BAS_FONT_TABLE
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\apply.h ===
/***********************************************************************
************************************************************************
*
*                    ********  APPLY.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL feature/lookup application.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#define     OTL_NOMATCH                     0x0001

// HELPER FUNCTIONS

// skipps all marks as specified (assuming "skip marks" is on)
// returns iglAfter next glyph not found    (all skipped)

enum otlDirection
{
    otlForward  = 1,
    otlBackward = -1
};

short NextGlyphInLookup
    (
    const otlList*      pliGlyphInfo, 

    USHORT                  grfLookupFlags,
    const otlGDefHeader&    gdef,
    otlSecurityData         secgdef,

    short               iglFirst,
    otlDirection        direction
    );

// calls "apply" on specific lookup types -- subclassed in each case
// has a big case statement on lookup types (but not formats!)
otlErrCode ApplyLookup
(
    otlTag                      tagTable,           // GSUB/GPOS
    otlList*                    pliCharMap,
    otlList*                    pliGlyphInfo,
    otlResourceMgr&             resourceMgr,

    const otlLookupTable&       lookupTable,
    long                        lParameter,
    USHORT                      nesting,
    
    const otlMetrics&           metr,       
    otlList*                    pliduGlyphAdv,          // assert null for GSUB
    otlList*                    pliplcGlyphPlacement,   // assert null for GSUB

    USHORT                      iglFrist,       // where to apply it
    USHORT                      iglAfterLast,   // how long a context we can use

    USHORT*                     piglNext,       // out: next glyph index

    otlSecurityData             sec
);                                              // return: did/did not apply


// main function for feature application
// calls applyLookup() to actually perform lookups
// contains all logic of feature/lookup application algorithm
otlErrCode ApplyFeatures
(
    otlTag                      tagTable,                   // GSUB/GPOS
    const otlFeatureSet*        pFSet,
    otlList*                    pliCharMap,
    otlList*                    pliGlyphInfo, 
    
    otlResourceMgr&             resourceMgr,

    otlTag                      tagScript,
    otlTag                      tagLangSys,

    const otlMetrics&   metr,       
    otlList*            pliduGlyphAdv,              // assert null for GSUB
    otlList*            pliplcGlyphPlacement,       // assert null for GSUB

    otlList*            pliFResults
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\base.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  BASE.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements helper functions dealing with BASE table processing
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/
otlBaseScriptTable FindBaseScriptTable
(
    const otlAxisTable&     axisTable,
    otlTag                  tagScript, 
    otlSecurityData         sec
)
{
    if (axisTable.isNull())
    {
        return otlBaseScriptTable((const BYTE*)NULL, sec);
    }

    otlBaseScriptListTable scriptList = axisTable.baseScriptList(sec);

    USHORT cBaseScripts = scriptList.baseScriptCount();
    for (USHORT iScript = 0; iScript < cBaseScripts; ++iScript)
    {
        if (scriptList.baseScriptTag(iScript) == tagScript)
        {
            return scriptList.baseScript(iScript, sec);
        }
    }

    return otlBaseScriptTable((const BYTE*)NULL, sec);

}


otlMinMaxTable FindMinMaxTable
(
    const otlBaseScriptTable&       scriptTable,
    otlTag                          tagLangSys, 
    otlSecurityData                 sec
)
{
    if (tagLangSys == OTL_DEFAULT_TAG)
    {
        return scriptTable.defaultMinMax(sec);
    }

    USHORT cLangSys = scriptTable.baseLangSysCount();
    for(USHORT iLangSys = 0; iLangSys < cLangSys; ++iLangSys)
    {
        if (scriptTable.baseLangSysTag(iLangSys) == tagLangSys)
        {
            return scriptTable.minmax(iLangSys, sec);
        }
    }

    return otlMinMaxTable((const BYTE*)NULL, sec);

}


otlFeatMinMaxRecord FindFeatMinMaxRecord
(
    const otlMinMaxTable&   minmaxTable,
    otlTag                  tagFeature, 
    otlSecurityData         sec
)
{
    USHORT cFeatures = minmaxTable.featMinMaxCount();
    for(USHORT iFeature = 0; iFeature < cFeatures; ++iFeature)
    {
        otlFeatMinMaxRecord minmaxRecord = minmaxTable.featMinMaxRecord(iFeature, sec);
        if (minmaxRecord.featureTableTag() == tagFeature)
        {
            return minmaxRecord;
        }
    }

    return otlFeatMinMaxRecord((const BYTE*)NULL, (const BYTE*)NULL, sec);
}


/*
otlBaseCoord FindBaselineValue
(
    const otlBaseTagListTable&  taglistTable,
    const otlBaseValuesTable&   baseValues,
    otlTag                      tagBaseline
)
{
    if (tagBaseline == OTL_DEFAULT_TAG)
    {
        if (baseValues.deafaultIndex() >= baseValues.baseCoordCount())
        {
            assert(false);  // bad font
            return otlBaseCoord((const BYTE*)NULL);
        }
        return baseValues.baseCoord(baseValues.deafaultIndex());
    }

    short iBaseline;
    bool fBaselineFound = false;
    USHORT cBaselineTags = taglistTable.baseTagCount();
    for(USHORT iTag = 0; iTag < cBaselineTags && !fBaselineFound; ++iTag)
    {
        if (taglistTable.baselineTag(iTag) == tagBaseline)
        {
            iBaseline = iTag;
            fBaselineFound = true;
        }
    }

    if (!fBaselineFound)
    {
        return otlBaseCoord((const BYTE*)NULL);
    }

    if (iBaseline >= baseValues.baseCoordCount())
    {
        assert(false);  // bad font
        return otlBaseCoord((const BYTE*)NULL);
    }

    return baseValues.baseCoord(iBaseline);

}
*/

long otlBaseCoord::baseCoord
(
    const otlMetrics&   metr,       
    otlResourceMgr&     resourceMgr,        // for getting coordinate points
    otlSecurityData sec
) const
{
    assert(!isNull());

    switch(format())
    {
    case(1):    // design units only
        {
            otlSimpleBaseCoord simpleBaseline = otlSimpleBaseCoord(pbTable, sec);
            if (metr.layout == otlRunLTR || 
                metr.layout == otlRunRTL)
            {
                return DesignToPP(metr.cFUnits, metr.cPPEmY, 
                                 (long)simpleBaseline.coordinate());
            }
            else
            {
                return DesignToPP(metr.cFUnits, metr.cPPEmX, 
                                 (long)simpleBaseline.coordinate());
            }
        }

    case(2):    // contour point
        {
            otlContourBaseCoord contourBaseline = otlContourBaseCoord(pbTable, sec);

            otlPlacement* rgPointCoords = 
                resourceMgr.getPointCoords(contourBaseline.referenceGlyph());
            if (rgPointCoords != NULL)
            {
                USHORT iPoint = contourBaseline.baseCoordPoint();

                if (metr.layout == otlRunLTR || 
                    metr.layout == otlRunRTL)
                {
                    return rgPointCoords[iPoint].dy;
                }
                else
                {
                    return rgPointCoords[iPoint].dx;
                }
            }
            else
                return (long)0;
        }
    
    case(3):    // design units plus device table
        {
            otlDeviceBaseCoord deviceBaseline = otlDeviceBaseCoord(pbTable, sec);
            otlDeviceTable deviceTable = deviceBaseline.deviceTable(sec);
            if (metr.layout == otlRunLTR || 
                metr.layout == otlRunRTL)
            {
                return DesignToPP(metr.cFUnits, metr.cPPEmY, 
                            (long)deviceBaseline.coordinate()) +
                            deviceTable.value(metr.cPPEmY);
            }
            else
            {
                return DesignToPP(metr.cFUnits, metr.cPPEmX, 
                            (long)deviceBaseline.coordinate()) +
                            deviceTable.value(metr.cPPEmX);
            }
        }
    
    default:    // invalid format
        return (0); //OTL_BAD_FONT_TABLE
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\chaining.h ===
/***********************************************************************
************************************************************************
*
*                    ********  CHAINING.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with chaining context based lookups.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/


const OFFSET offsetChainBacktrackGlyphCount  = 0;
const OFFSET offsetChainBacktrackGlyphArray = 2;

class otlChainRuleTable: public otlTable
{
    OFFSET offsetChainInputGlyphCount;
    OFFSET offsetChainInputGlyphArray;
    OFFSET offsetChainLookaheadGlyphCount;
    OFFSET offsetChainLookaheadGlyphArray;
    OFFSET offsetChainLookupCount;
    OFFSET offsetChainLookupRecords;


public:

//  USHORT backtrackGlyphCount() const;
//  USHORT inputGlyphCount() const;
//  USHORT lookaheadGlyphCount() const;

    otlChainRuleTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,offsetChainBacktrackGlyphArray,
                                        offsetChainBacktrackGlyphCount,sizeUSHORT,sec))
        {
            setInvalid();
            return;
        }
    
        offsetChainInputGlyphCount = offsetChainBacktrackGlyphArray 
               + backtrackGlyphCount() * sizeof(otlGlyphID);
        offsetChainInputGlyphArray = 
                offsetChainInputGlyphCount + sizeof(USHORT);
        if (!isValidTableWithArray(pb,offsetChainInputGlyphArray,
                                        offsetChainInputGlyphCount,sizeUSHORT,sec))
        {
            setInvalid();
            return;
        }
        
        offsetChainLookaheadGlyphCount = offsetChainInputGlyphArray 
               + (inputGlyphCount() - 1) * sizeof(otlGlyphID); 
        offsetChainLookaheadGlyphArray = 
                offsetChainLookaheadGlyphCount + sizeof(USHORT);
        if (!isValidTableWithArray(pb,offsetChainLookaheadGlyphArray,
                                        offsetChainLookaheadGlyphCount,sizeUSHORT,sec))
        {
            setInvalid();
            return;
        }

        offsetChainLookupCount = offsetChainLookaheadGlyphArray 
               + lookaheadGlyphCount() * sizeof(otlGlyphID);
        offsetChainLookupRecords = 
                offsetChainLookupCount + sizeof(USHORT);
        if (!isValidTableWithArray(pb,offsetChainLookupRecords,
                                        offsetChainLookupCount,sizeContextLookupRecord,sec))
        {
            setInvalid();
            return;
        }
    }

    
    USHORT backtrackGlyphCount() const
    {   
        if (!isValid()) return 0;
            
        return UShort(pbTable + offsetChainBacktrackGlyphCount); 
    }

    USHORT inputGlyphCount() const
    {   
        if (!isValid()) return 0;
        
        return UShort(pbTable + offsetChainInputGlyphCount); 
    }

    USHORT lookaheadGlyphCount() const
    {   
        if (!isValid()) return 0;
        
        return UShort(pbTable + offsetChainLookaheadGlyphCount); 
    }

    USHORT lookupCount() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetChainLookupCount); 
    }

    otlGlyphID backtrack(USHORT index) const
    {   
        assert(isValid());  //should stop at count()
        
        assert(index < backtrackGlyphCount());
        return GlyphID(pbTable + offsetChainBacktrackGlyphArray 
                               + index * sizeof(otlGlyphID)); 
    }
    
    otlGlyphID input(USHORT index) const
    {   
        assert(isValid());  //should stop at count()

        assert(index < inputGlyphCount());
        assert(index > 0);
        return GlyphID(pbTable + offsetChainInputGlyphArray 
                               + (index - 1)* sizeof(otlGlyphID)); 
    }

    otlGlyphID lookahead(USHORT index) const
    {   
        assert(isValid());  //should stop at count()

        assert(index < lookaheadGlyphCount());
        return GlyphID(pbTable + offsetChainLookaheadGlyphArray 
                               + index * sizeof(otlGlyphID)); 
    }

    otlList lookupRecords() const
    {   
        assert(isValid());  //should stop at match
        
        return otlList((void*)(pbTable + offsetChainLookupRecords),
                        sizeContextLookupRecord, lookupCount(), lookupCount());
    }
};


const OFFSET offsetChainRuleCount = 0;
const OFFSET offsetChainRuleArray = 2;

const SIZE   sizeChainRuleSetTable = sizeOFFSET;

class otlChainRuleSetTable: public otlTable
{
public:
    otlChainRuleSetTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeChainRuleSetTable,sizeChainRuleSetTable,sizeOFFSET,sec))
            setInvalid();
    }

    USHORT ruleCount() const
    {   
        if (!isValid()) return 0;
        
        return UShort(pbTable + offsetChainRuleCount); 
    }

    otlChainRuleTable rule(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid()); //should stop at ruleCount()        
        
        assert(index < ruleCount());
        return otlChainRuleTable(pbTable + 
            Offset(pbTable + offsetChainRuleArray + index * sizeof(OFFSET)),sec);
    }
};
                                                    

const OFFSET offsetChainCoverage = 2;
const OFFSET offsetChainRuleSetCount = 4;
const OFFSET offsetChainRuleSetArray =6;

const SIZE   sizeChainSubTable = 6;

class otlChainSubTable: public otlLookupFormat
{
public:
    otlChainSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        assert(isValid()); //checked in LookupFormat;
        
        assert(format() == 1);

        if (!isValidTableWithArray(pb,sizeChainSubTable,
                                        offsetChainRuleSetCount,sizeOFFSET,sec))
        {
            setInvalid();
        }
    }

    otlCoverage coverage(otlSecurityData sec) const
    {   
        if (!isValid()) return otlCoverage(pbInvalidData,sec);
        
        return otlCoverage(pbTable + Offset(pbTable + offsetChainCoverage),sec); 
    }

    USHORT ruleSetCount() const
    {   
        assert(isValid()); //apply() should stop at coverage
        
        return UShort(pbTable + offsetChainRuleSetCount); 
    }

    otlChainRuleSetTable ruleSet(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid()); //apply() should stop at coverage

        assert(index < ruleSetCount());
        return otlChainRuleSetTable(pbTable +
            Offset(pbTable + offsetChainRuleSetArray + index * sizeof(OFFSET)),sec);
    }
};



const OFFSET offsetChainBacktrackClassCount = 0;
const OFFSET offsetChainBacktrackClassArray = 2;

class otlChainClassRuleTable: public otlTable
{
    OFFSET offsetChainInputClassCount;
    OFFSET offsetChainInputClassArray;
    OFFSET offsetChainLookaheadClassCount;
    OFFSET offsetChainLookaheadClassArray;
    OFFSET offsetChainLookupCount;
    OFFSET offsetChainLookupRecords;

public:
//  USHORT backtrackClassCount() const;
//  USHORT inputClassCount() const;
//  USHORT lookaheadClassCount() const;

    otlChainClassRuleTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,offsetChainBacktrackClassArray,
                                        offsetChainBacktrackClassCount,sizeUSHORT,sec))
        {
            setInvalid();
            return;
        }

        offsetChainInputClassCount = offsetChainBacktrackClassArray 
               + backtrackClassCount() * sizeof(USHORT);
        offsetChainInputClassArray = 
                offsetChainInputClassCount + sizeof(USHORT); 
        if (!isValidTableWithArray(pb,offsetChainInputClassArray,
                                        offsetChainInputClassCount,sizeUSHORT,sec))
        {
            setInvalid();
            return;
        }

        offsetChainLookaheadClassCount = offsetChainInputClassArray 
               + (inputClassCount() - 1) * sizeof(USHORT);
        offsetChainLookaheadClassArray =
                offsetChainLookaheadClassCount + sizeof(USHORT);
        if (!isValidTableWithArray(pb,offsetChainLookaheadClassArray,
                                        offsetChainLookaheadClassCount,sizeUSHORT,sec))
        {
            setInvalid();
            return;
        }

        offsetChainLookupCount = offsetChainLookaheadClassArray 
               + lookaheadClassCount() * sizeof(USHORT);
        offsetChainLookupRecords = 
                offsetChainLookupCount + sizeof(USHORT);
        if (!isValidTableWithArray(pb,offsetChainLookupRecords,
                                        offsetChainLookupCount,sizeContextLookupRecord,sec))
        {
            setInvalid();
            return;
        }
    }

    
    USHORT backtrackClassCount() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetChainBacktrackClassCount); 
    }

    USHORT inputClassCount() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetChainInputClassCount); 
    }

    USHORT lookaheadClassCount() const
    {
        assert(isValid());

        return UShort(pbTable + offsetChainLookaheadClassCount); 
    }

    USHORT lookupCount() const
    {
        assert(isValid());

        return UShort(pbTable + offsetChainLookupCount); }

    USHORT backtrackClass(USHORT index) const
    {   
        
        assert(isValid());

        assert(index < backtrackClassCount());
        return GlyphID(pbTable + offsetChainBacktrackClassArray 
                               + index * sizeof(USHORT)); 
    }
    
    USHORT inputClass(USHORT index) const
    {   

        assert(isValid());

        assert(index < inputClassCount());
        assert(index > 0);
        return GlyphID(pbTable + offsetChainInputClassArray 
                               + (index - 1)* sizeof(USHORT)); 
    }

    USHORT lookaheadClass(USHORT index) const
    {   

        assert(isValid());

        assert(index < lookaheadClassCount());
        return GlyphID(pbTable + offsetChainLookaheadClassArray 
                               + index * sizeof(USHORT)); 
    }

    otlList lookupRecords() const
    {   
        
        assert(isValid());

        return otlList((void*)(pbTable + offsetChainLookupRecords),
                        sizeContextLookupRecord, lookupCount(), lookupCount());
    }
};

const OFFSET offsetChainClassRuleCount = 0;
const OFFSET offsetChainClassRuleArray = 2;

const SIZE sizeChainClassRuleSetTable = sizeUSHORT;

class otlChainClassRuleSetTable: public otlTable
{
public:
    otlChainClassRuleSetTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeChainClassRuleSetTable,
                                        offsetChainClassRuleCount,sizeOFFSET,sec)) 
        {
            setInvalid();
        }
    }

    USHORT ruleCount() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetChainClassRuleCount); }

    otlChainClassRuleTable rule(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid());

        assert(index < ruleCount());
        return otlChainClassRuleTable(pbTable + 
            Offset(pbTable + offsetChainClassRuleArray 
                           + index * sizeof(OFFSET)),sec);
    }
};
                                                    

const OFFSET offsetChainClassCoverage = 2;
const OFFSET offsetChainBacktrackClassDef = 4;
const OFFSET offsetChainInputClassDef = 6;
const OFFSET offsetChainLookaheadClassDef = 8;
const OFFSET offsetChainClassRuleSetCount = 10;
const OFFSET offsetChainClassRuleSetArray = 12;

const SIZE sizeChainClassSubTable = sizeUSHORT+sizeOFFSET*4+sizeUSHORT;

class otlChainClassSubTable: public otlLookupFormat
{
public:
    otlChainClassSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        assert(isValid()); //checked in LookupFormat
       
        assert(format() == 2);

        if (!isValidTableWithArray(pb,sizeChainClassSubTable,
                                            offsetChainClassRuleSetCount,sizeOFFSET,sec))
        {
            setInvalid();
            return;
        }
    }

    otlCoverage coverage(otlSecurityData sec) const
    {   
        assert(isValid());
        
        return otlCoverage(pbTable 
                    + Offset(pbTable + offsetChainClassCoverage),sec); 
    }

    otlClassDef backtrackClassDef(otlSecurityData sec) const
    {   
        assert(isValid());

        return otlClassDef(pbTable 
                    + Offset(pbTable + offsetChainBacktrackClassDef),sec); 
    }
    
    otlClassDef inputClassDef(otlSecurityData sec) const
    {   
        assert(isValid());

        return otlClassDef(pbTable 
                    + Offset(pbTable + offsetChainInputClassDef),sec); 
    }
    
    otlClassDef lookaheadClassDef(otlSecurityData sec) const
    {   
        assert(isValid());

        return otlClassDef(pbTable 
                    + Offset(pbTable + offsetChainLookaheadClassDef),sec); 
    }

    USHORT ruleSetCount() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetChainClassRuleSetCount); 
    }

    otlChainClassRuleSetTable ruleSet(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid());
        
        assert(index < ruleSetCount());
        
        USHORT offset = 
            Offset(pbTable + offsetChainClassRuleSetArray 
                           + index * sizeof(OFFSET));
        if (offset == 0)
            return otlChainClassRuleSetTable((const BYTE*)NULL,sec);
        
        return otlChainClassRuleSetTable(pbTable + offset,sec);
    }
};
    


const OFFSET offsetChainBacktrackCoverageCount = 2;
const OFFSET offsetChainBacktrackCoverageArray = 4;

class otlChainCoverageSubTable: public otlLookupFormat
{
    OFFSET offsetChainInputCoverageCount;
    OFFSET offsetChainInputCoverageArray;
    OFFSET offsetChainLookaheadCoverageCount;
    OFFSET offsetChainLookaheadCoverageArray;
    OFFSET offsetChainLookupCount;
    OFFSET offsetChainLookupRecords;

public:

//  USHORT backtrackCoverageCount() const;
//  USHORT inputCoverageCount() const;
//  USHORT lookaheadCoverageCount() const;

    otlChainCoverageSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        assert(isValid()); //checked in LookupFormat;
       
        assert(format() == 3);

        if (!isValidTableWithArray(pb,offsetChainBacktrackCoverageArray,
                                        offsetChainBacktrackCoverageCount,sizeOFFSET,sec))
        {
            setInvalid();
            return;
        }
        offsetChainInputCoverageCount = offsetChainBacktrackCoverageArray 
               + backtrackCoverageCount() * sizeof(OFFSET);
        offsetChainInputCoverageArray = 
                offsetChainInputCoverageCount + sizeof(USHORT);

        if (!isValidTableWithArray(pb,offsetChainInputCoverageArray,
                                        offsetChainInputCoverageCount,sizeOFFSET,sec))
        {
            setInvalid();
            return;
        }

        offsetChainLookaheadCoverageCount = offsetChainInputCoverageArray 
               + inputCoverageCount() * sizeof(OFFSET);
        offsetChainLookaheadCoverageArray = 
                offsetChainLookaheadCoverageCount + sizeof(USHORT);
        if (!isValidTableWithArray(pb,offsetChainLookaheadCoverageArray,
                                        offsetChainLookaheadCoverageCount,sizeOFFSET,sec))
        {
            setInvalid();
            return;
        }

        offsetChainLookupCount = offsetChainLookaheadCoverageArray 
               + lookaheadCoverageCount() * sizeof(OFFSET); 
        offsetChainLookupRecords = 
                offsetChainLookupCount + sizeof(USHORT);
        if (!isValidTableWithArray(pb,offsetChainLookupRecords,
                                        offsetChainLookupCount,sizeContextLookupRecord,sec))
        {
            setInvalid();
            return;
        }
    }

    
    USHORT backtrackCoverageCount() const
    {   
        assert (isValid());
        
        return UShort(pbTable + offsetChainBacktrackCoverageCount); 
    }

    USHORT inputCoverageCount() const
    {   
        assert (isValid());
        
        return UShort(pbTable + offsetChainInputCoverageCount); }

    USHORT lookaheadCoverageCount() const
    {   
        assert (isValid());

        return UShort(pbTable + offsetChainLookaheadCoverageCount); 
    }

    USHORT lookupCount() const
    {   
        assert (isValid());

        return UShort(pbTable + offsetChainLookupCount); 
    }

    otlCoverage backtrackCoverage(USHORT index, otlSecurityData sec) const
    {   
        assert (isValid());

        assert(index < backtrackCoverageCount());
        return otlCoverage(pbTable + 
            Offset(pbTable + offsetChainBacktrackCoverageArray 
                            + index * sizeof(OFFSET)),sec); 
    }
    
    otlCoverage inputCoverage(USHORT index, otlSecurityData sec) const
    {   
        assert (isValid());

        assert(index < inputCoverageCount());
        return otlCoverage(pbTable +  
            Offset(pbTable + offsetChainInputCoverageArray
                               + index* sizeof(OFFSET)),sec); 
    }

    otlCoverage lookaheadCoverage(USHORT index, otlSecurityData sec) const
    {   
        assert (isValid());

        assert(index < lookaheadCoverageCount());
        return otlCoverage(pbTable + 
            Offset(pbTable + offsetChainLookaheadCoverageArray 
                               + index * sizeof(OFFSET)),sec); 
    }

    otlList lookupRecords() const
    {   
        assert (isValid());

        return otlList((void*)(pbTable + offsetChainLookupRecords),
                        sizeContextLookupRecord, lookupCount(), lookupCount());
    }
};


class otlChainingLookup: public otlLookupFormat
{
public:
    otlChainingLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec)
    {
        assert(isValid());
    }

    
    otlErrCode apply
    (
        otlTag                      tagTable,
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        USHORT                      grfLookupFlags,
        long                        lParameter,
        USHORT                      nesting,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph

        otlSecurityData             sec
    );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\base.h ===
/***********************************************************************
************************************************************************
*
*                    ********  BASE.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL BASE table formats.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/


const OFFSET offsetBaseTagCount = 0;
const OFFSET offsetBaselineTagArray = 2;

class otlBaseTagListTable: public otlTable
{
public:

    otlBaseTagListTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    USHORT baseTagCount() const
    {   return UShort(pbTable + offsetBaseTagCount); }

    otlTag baselineTag(USHORT index)  const
    {   assert(index < baseTagCount());
        return *(UNALIGNED otlTag*)(pbTable + offsetBaselineTagArray
                                  + index * sizeof(otlTag));
    }
};


const OFFSET offsetBaseCoordFormat = 0;

const OFFSET offsetSimpleBaseCoordinate = 2;

class otlSimpleBaseCoord: public otlTable
{
public:
    otlSimpleBaseCoord(const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec)
    {
        assert(baseCoordFormat() == 1);
    }

    USHORT baseCoordFormat() const
    {   return  UShort(pbTable + offsetBaseCoordFormat); }

    short coordinate()  const
    {   return SShort(pbTable + offsetSimpleBaseCoordinate); }
};


const OFFSET offsetContourBaseCoordinate = 2;
const OFFSET offsetReferenceGlyph = 4;
const OFFSET offsetBaseCoordPoint = 6;

class otlContourBaseCoord: public otlTable
{
public:
    otlContourBaseCoord(const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec)
    {
        assert(baseCoordFormat() == 2);
    }

    USHORT baseCoordFormat() const
    {   return  UShort(pbTable + offsetBaseCoordFormat); }

    short coordinate()  const
    {   return SShort(pbTable + offsetContourBaseCoordinate); }

    otlGlyphID referenceGlyph() const
    {   return GlyphID(pbTable + offsetReferenceGlyph); }

    USHORT baseCoordPoint() const
    {   return UShort(pbTable + offsetBaseCoordPoint); }
};


const OFFSET offsetDeviceBaseCoordinate = 2;
const OFFSET offsetDeviceTable = 4;

class otlDeviceBaseCoord: public otlTable
{
public:
    otlDeviceBaseCoord(const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec)
    {
        assert(baseCoordFormat() == 3);
    }

    USHORT baseCoordFormat() const
    {   return  UShort(pbTable + offsetBaseCoordFormat); }

    short coordinate()  const
    {   return SShort(pbTable + offsetDeviceBaseCoordinate); }

    otlDeviceTable deviceTable(otlSecurityData sec) const
    {   return otlDeviceTable(pbTable + Offset(pbTable + offsetDeviceTable),sec); }
};


class otlBaseCoord: public otlTable
{
public:

    otlBaseCoord(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    USHORT format() const
    {   return UShort(pbTable + offsetBaseCoordFormat); }

    long baseCoord
    (
        const otlMetrics&   metr,
        otlResourceMgr&     resourceMgr,     // for getting coordinate points
        otlSecurityData sec
    ) const;
};


const OFFSET offsetDefaultIndex = 0;
const OFFSET offsetBaseCoordCount = 2;
const OFFSET offsetBaseCoordArray = 4;

class otlBaseValuesTable: public otlTable
{
public:

    otlBaseValuesTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    USHORT deafaultIndex() const
    {   return UShort(pbTable + offsetDefaultIndex); }

    USHORT baseCoordCount() const
    {   return UShort(pbTable + offsetBaseCoordCount); }

    otlBaseCoord baseCoord(USHORT index, otlSecurityData sec) const
    {   assert(index < baseCoordCount());
        return otlBaseCoord(pbTable +
            Offset(pbTable + offsetBaseCoordArray + index * sizeof(OFFSET)),sec);
    }
};


const OFFSET offsetFeatureTableTag = 0;
const OFFSET offsetMinCoord = 4;
const OFFSET offsetMaxCoord = 6;

class otlFeatMinMaxRecord: public otlTable
{
    const BYTE* pbMainTable;
public:

    otlFeatMinMaxRecord(const BYTE* minmax, const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec),
          pbMainTable(minmax)
    {}

    otlTag featureTableTag() const
    {   return *(UNALIGNED otlTag*)(pbTable + offsetFeatureTableTag); }


    otlBaseCoord minCoord(otlSecurityData sec) const
    {   if (Offset(pbTable + offsetMinCoord) == 0)
            return otlBaseCoord((const BYTE*)NULL,sec);

        return otlBaseCoord(pbMainTable + Offset(pbTable + offsetMinCoord),sec);
    }


    otlBaseCoord maxCoord(otlSecurityData sec) const
    {   if (Offset(pbTable + offsetMaxCoord) == 0)
            return otlBaseCoord((const BYTE*)NULL,sec);

        return otlBaseCoord(pbMainTable + Offset(pbTable + offsetMaxCoord),sec);
    }

};


const OFFSET offsetDefaultMinCoord = 0;
const OFFSET offsetDefaultMaxCoord = 2;
const OFFSET offsetFeatMinMaxCount = 4;
const OFFSET offsetFeatMinMaxRecordArray = 6;
const USHORT sizeFeatMinMaxRecord = 8;

class otlMinMaxTable: public otlTable
{
public:

    otlMinMaxTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    otlBaseCoord minCoord(otlSecurityData sec) const
    {   if (Offset(pbTable + offsetDefaultMinCoord) == 0)
            return otlBaseCoord((const BYTE*)NULL,sec);

        return otlBaseCoord(pbTable + Offset(pbTable + offsetDefaultMinCoord),sec);
    }


    otlBaseCoord maxCoord(otlSecurityData sec) const
    {   if (Offset(pbTable + offsetDefaultMaxCoord) == 0)
            return otlBaseCoord((const BYTE*)NULL,sec);

        return otlBaseCoord(pbTable + Offset(pbTable + offsetDefaultMaxCoord),sec);
    }


    USHORT featMinMaxCount() const
    {   return UShort(pbTable + offsetFeatMinMaxCount); }

    otlFeatMinMaxRecord featMinMaxRecord(USHORT index, otlSecurityData sec) const
    {   assert(index < featMinMaxCount());
        return otlFeatMinMaxRecord(pbTable,
                                   pbTable + offsetFeatMinMaxRecordArray
                                           + index * sizeFeatMinMaxRecord,sec);
    }
};


const OFFSET offsetBaseValues = 0;
const OFFSET offsetDefaultMinMax = 2;
const OFFSET offsetBaseLangSysCount = 4;
const OFFSET offsetBaseLangSysRecordArray = 6;
const USHORT sizeBaseLangSysRecord = 6;

const OFFSET offsetBaseLangSysTag = 0;
const OFFSET offsetMinMax = 4;

class otlBaseScriptTable: public otlTable
{
public:

    otlBaseScriptTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    otlBaseValuesTable baseValues(otlSecurityData sec) const
    {   if (Offset(pbTable + offsetBaseValues) == 0)
            return otlBaseValuesTable((const BYTE*)NULL, sec);

        return otlBaseValuesTable(pbTable + Offset(pbTable + offsetBaseValues), sec);
    }

    otlMinMaxTable defaultMinMax(otlSecurityData sec) const
    {   if (Offset(pbTable + offsetDefaultMinMax) == 0)
            return otlMinMaxTable((const BYTE*)NULL, sec);

        return otlMinMaxTable(pbTable + Offset(pbTable + offsetDefaultMinMax), sec);
    }

    USHORT baseLangSysCount() const
    {   return UShort(pbTable + offsetBaseLangSysCount); }

    otlTag baseLangSysTag(USHORT index) const
    {   assert(index < baseLangSysCount());
        return *(UNALIGNED otlTag*)(pbTable + offsetBaseLangSysRecordArray
                                  + index * sizeBaseLangSysRecord
                                  + offsetBaseLangSysTag);
    }

    otlMinMaxTable minmax(USHORT index, otlSecurityData sec) const
    {   assert(index < baseLangSysCount());
        return otlMinMaxTable(pbTable +
            Offset(pbTable + offsetBaseLangSysRecordArray
                           + index * sizeBaseLangSysRecord + offsetMinMax), sec);
    }
};


const OFFSET offsetBaseScriptCount = 0;
const OFFSET offsetBaseScriptRecordArray = 2;
const USHORT sizeBaseScriptRecord = 6;

const OFFSET offsetBaseScriptTag = 0;
const OFFSET offsetBaseScriptOffset = 4;

class otlBaseScriptListTable: public otlTable
{
public:

    otlBaseScriptListTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    USHORT baseScriptCount() const
    {   return UShort(pbTable + offsetBaseScriptCount); }

    otlTag baseScriptTag(USHORT index)
    {   assert(index < baseScriptCount());
        return *(UNALIGNED otlTag*)(pbTable + offsetBaseScriptRecordArray
                                  + index * sizeBaseScriptRecord
                                  + offsetBaseScriptTag);
    }


    otlBaseScriptTable baseScript(USHORT index, otlSecurityData sec) const
    {   assert(index < baseScriptCount());
        return otlBaseScriptTable(pbTable +
            Offset(pbTable + offsetBaseScriptRecordArray
                           + index * sizeBaseScriptRecord
                           + offsetBaseScriptOffset), sec);
    }
};


const OFFSET offsetBaseTagList = 0;
const OFFSET offsetBaseScriptList = 2;

class otlAxisTable: public otlTable
{
public:

    otlAxisTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    otlBaseTagListTable baseTagList(otlSecurityData sec) const
    {   if (Offset(pbTable + offsetBaseTagList) == 0)
            return otlBaseTagListTable((const BYTE*)NULL, sec);

        return otlBaseTagListTable(pbTable + Offset(pbTable + offsetBaseTagList), sec);
    }

    otlBaseScriptListTable baseScriptList(otlSecurityData sec) const
    {   return otlBaseScriptListTable(pbTable
                    + Offset(pbTable + offsetBaseScriptList), sec);
    }
};


const OFFSET offsetBaseVersion = 0;
const OFFSET offsetHorizAxis = 4;
const OFFSET offsetVertAxis = 6;

class otlBaseHeader: public otlTable
{
public:

    otlBaseHeader(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    ULONG version() const
    {   return ULong(pbTable + offsetBaseVersion); }

    otlAxisTable horizAxis(otlSecurityData sec) const
    {   if (Offset(pbTable + offsetHorizAxis) == 0)
            return otlAxisTable((const BYTE*)NULL, sec);

        return otlAxisTable(pbTable + Offset(pbTable + offsetHorizAxis), sec);
    }

    otlAxisTable vertAxis(otlSecurityData sec) const
    {   if (Offset(pbTable + offsetVertAxis) == 0)
            return otlAxisTable((const BYTE*)NULL, sec);

        return otlAxisTable(pbTable + Offset(pbTable + offsetVertAxis), sec);
    }
};


// helper functions

// returns a NULL table if not found
otlBaseScriptTable FindBaseScriptTable
(
    const otlAxisTable&     axisTable,
    otlTag                  tagScript,
    otlSecurityData         sec
);

otlMinMaxTable FindMinMaxTable
(
    const otlBaseScriptTable&       scriptTable,
    otlTag                          tagLangSys,
    otlSecurityData         sec
);

otlFeatMinMaxRecord FindFeatMinMaxRecord
(
    const otlMinMaxTable&   minmaxTable,
    otlTag                  tagFeature,
    otlSecurityData         sec

);

/*
otlBaseCoord FindBaselineValue
(
    const otlBaseTagListTable&  taglistTable,
    const otlBaseScriptTable&   scriptTable,
    otlTag                      tagBaseline
);
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\classdef.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  CLASDEF.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of class definition tables.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// REVIEW (PERF): it's used a lot - optimize!

USHORT otlClassDef::getClass(otlGlyphID glyph, otlSecurityData sec) const
{
     switch(format())
     {
     case(1):       // class array
         {
             otlClassArrayTable classArray = 
                 otlClassArrayTable(pbTable,sec);

             if (!classArray.isValid()) return 0;

             long index = glyph - classArray.startGlyph();

             if (0 <= index && index < classArray.glyphCount())
             {
                 return classArray.classValue((USHORT)index);
             }
             else
                return 0;
         }

     case(2):       // class ranges
         {
             otlClassRangesTable classRanges = 
                        otlClassRangesTable(pbTable,sec);

             if (!classRanges.isValid()) return 0;
 
    /* Validation assert
    #ifdef _DEBUG
             // in debug mode, check that the coverage is sorted
             for (USHORT i = 0; i < classRanges.classRangeCount() - 1; ++i)
             {
                 otlGlyphID glThis = classRanges.classRangeRecord(i,sec).start();
                 otlGlyphID glNext = classRanges.classRangeRecord(i + 1,sec).start();
                 assert(classRanges.classRangeRecord(i,sec).start() 
                        < classRanges.classRangeRecord(i + 1,sec).start());
             }
    #endif
    */
             USHORT iLowRange = 0;
             // always beyond the upper bound
             USHORT iHighRange = classRanges.classRangeCount(); 
             while(iLowRange < iHighRange)
             {
                 USHORT iMiddleRange = (iLowRange + iHighRange) >> 1;
                 otlClassRangeRecord range = classRanges.classRangeRecord(iMiddleRange,sec);
                 if (glyph < range.start()) 
                 {
                     iHighRange = iMiddleRange;
                 }
                 else if (range.end() < glyph)
                 {
                     iLowRange = iMiddleRange + 1;
                 }
                 else
                 {
                     return range.getClass();
                 }            
             } 
 
             return  0;
         }
     }

     // default: invalid format
     return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\imager\span.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Character span support
*
* Revision History:
*
*   06/16/1999 dbrown
*       Created it.
*
\**************************************************************************/

#ifndef _SPAN_HPP
#define _SPAN_HPP




////    VectorBase - very very simple dynamic array base class
//
//      VectorBase[]            - directly address index element (index checked in checked build)
//      VectorBase.Resize(size) - Allocate memory for at least size elements
//      VectorBase.Shrink(size) - Reduce vector to exactly size


template <class C> class VectorBase
{
public:
    VectorBase() :
        Allocated      (0),
        VectorElements (NULL)
    {}

    ~VectorBase()
    {
        if (VectorElements)
        {
            GpFree(VectorElements);
            VectorElements = NULL;
        }
    }

    C &operator[] (INT index)
    {
        ASSERT(index >= 0  &&  index < Allocated);
        return VectorElements[index];
    }

    const C &operator[] (INT index) const
    {
        ASSERT(index >= 0  &&  index < Allocated);
        return VectorElements[index];
    }

    BOOL Resize(INT targetAllocation);
    BOOL Shrink(INT targetAllocation);

private:
    INT   Allocated;
    C    *VectorElements;
};






////    Vector - dynamic array class
//
//      Vector.Add(&element)    - Add an element at the end of the array
//      Vector.Del()            - Delete an element at the end of the array
//      Vector.GetCount()       - Get the number of active element
//      Vector.Reset()          - Reset the number of active element, shrink the buffer if wanted
//      Vector.GetDataBuffer()  - Get data buffer pointer


template <class C> class Vector : public VectorBase<C>
{
public:
    Vector() :
        Active  (0)
    {}

    GpStatus Add(const C& newElement)
    {
        if (!Resize(Active + 1))
            return OutOfMemory;
        C& currentElement = operator[](Active);
        GpMemcpy (&currentElement, &newElement, sizeof(C));
        Active++;
        return Ok;
    }

    void Del()
    {
        if (Active > 0)
            Active--;
    }

    void Reset(BOOL shrink = FALSE)
    {
        Active = 0;
        if (shrink)
        {
            Shrink(0);
        }
    }

    INT GetCount()
    {
        return Active;
    }

    C* GetDataBuffer()
    {
        return &operator[](0);
    }

private:
    INT     Active;
};







/////   Span - element pointer and length
//
//      A span is a simple pairing of a pointer to an arbitrary
//      run attribute, and a run length.


template <class C> class Span {
public:

    Span() :
        Element (NULL),
        Length  (0)
    {}

    Span(const C initElement, INT initLength) :
        Element (initElement),
        Length  (initLength)
    {}

    ~Span() {}

    C       Element;
    UINT32  Length;
};






/////   SpanVector - array of spans representing arbitrary character attributes
//
//      A SpanVector is an array of spans with support routines to update
//      the spans over character ranges.
//
//      When changing, inserting or deleting attributes of character ranges,
//      the SpanVector takes care of optimising the insertions to maintain
//      a minimal Length span vector.
//
//      A span whos element has value NULL is equivalent to a missing span.
//
//      Methods:
//
//          SetSpan(first, Length, value)
//
//              Sets the range [first .. first+Length-1]  to the given
//              value. Previous values (if any) for the range are lost.
//              Adjacent ranges are merged where possible.
//
//          OrSpan(first, Length, value)
//
//              Sets the range [first .. first+Length-1]  to the result of
//              OR combination between given and existing value. Duplicate
//              ranges are merged where possible.





////    !!! Optimise to avoid creating spans which match the default value



template <class C> class SpanRider;




/////   SpanVector
//
//      SpanVector(default value)
//
//      Status   spanvector.SetSpan(first, length, value)
//      Status   spanvector.OrSpan(first, length, value)
//      const C &spanVector.GetElement(INT) - returns element at position i, default if none
//
//      const C &spanvector.GetDefault()    - gets default value
//      INT      spanvector.GetActive()     - returns number of spans in vector
//      Span<C> &spanvector[INT]            - returns specified Span
//      void     spanvector.Free()          - free every non-null element


template <class C> class SpanVector {

friend class SpanRider<C>;

public:

    SpanVector(
        C defaultValue
    ) :
        Default   (defaultValue),
        Active    (0)
    {}


    Status SetSpan(INT first, INT length, C element);
    Status OrSpan(INT first, INT length, C element);

    void Free() // Only call 'Free' if <C> is a pointer type!
    {
        // free every non-null element.

        for (INT i=0; i<Active; i++)
        {
            if (Spans[i].Element != NULL)
            {
                delete Spans[i].Element;
            }
        }
        Active = 0;

        if (Default)
        {
            delete Default;
        }
    }

    const C &GetDefault()   {return Default;}
    INT      GetSpanCount() {return Active;}

    const Span<C> &operator[] (INT i) const
    {
        ASSERT(i<Active);
        return Spans[i];
    }

    Span<C> &operator[] (INT i)
    {
        ASSERT(i<Active);
        return Spans[i];
    }

    #if DBG
        void Dump();
    #endif

    void Reset(BOOL shrink = FALSE);

private:

    GpStatus Erase(INT first, INT count);
    GpStatus Insert(INT first, INT count);
    GpStatus Add(const Span<C> &newSpan);


    C                       Default;
    VectorBase< Span< C > > Spans;
    INT                     Active;
};


/*

    Span<C> &operator[] (INT index)
    {
        if (index >= Active)
        {
            return Span<C>(Default, 0);
        }
        else
        {
            return Spans[index];
        }
    }

    INT GetActive() {return Active;}

    / *
    const C &GetElement(INT index) const
    {
        if (    index < Active
            &&  Spans[index].Element != NULL)
        {
            return Spans[index].Element;
        }
        else
        {
            return Default;
        }
    }
    * /

    const C &GetElementAt(INT offset) const
    {
        INT elementIndex  = 0;
        INT elementOffset = 0;

        while (    elementIndex < Active
               &&  offset < elementOffset + Spans[elementIndex].Length)
        {
            elementOffset += Spans[elementIndex].Length;
            elementIndex++;
        }

        if (elementIndex < Active)
        {
            return Spans[elementIndex].Element;
        }
        else
        {
            return Default;
        }
    }

    const C&GetDefault() const
    {
        return Default;
    }
*/











/////   SpanRider - a class for efficiently running a cursor along a span vector
//
//


template <class C> class SpanRider {

public:

    SpanRider(SpanVector<C> *spans) :
        Spanvector           (spans),
        DefaultSpan          (spans->Default, 0xFFFFFFFF),
        CurrentOffset        (0),
        CurrentElement       (0),
        CurrentElementIndex  (0)
    {}

    BOOL SetPosition(UINT32 newOffset);

    BOOL AtEnd()
    {
        return CurrentElement >= Spanvector->Active;
    }

    void operator++(int)
    {
        if (CurrentElement < Spanvector->Active)
        {
            CurrentElementIndex += Spanvector->Spans[CurrentElement].Length;
            CurrentElement++;
        }
    }

    C &operator[] (INT offset)
    {
        if (    Spanvector->Active > 0
            &&  SetPosition(offset))
        {
            return Spanvector->Spans[CurrentElement].Element;
        }
        else
        {
            return Spanvector->Default;
        }
    }

    const Span<C> &GetCurrentSpan() const
    {
        if (CurrentElement < Spanvector->Active)
        {
            return Spanvector->Spans[CurrentElement];
        }
        else
        {
            return DefaultSpan;
        }
    }

    const C &GetCurrentElement() const
    {
        if (CurrentElement < Spanvector->Active)
        {
            return Spanvector->Spans[CurrentElement].Element;
        }
        else
        {
            return Spanvector->Default;
        }
    }

    C &GetCurrentElement()
    {
        if (CurrentElement < Spanvector->Active)
        {
            return Spanvector->Spans[CurrentElement].Element;
        }
        else
        {
            return Spanvector->Default;
        }
    }

    const C &GetPrecedingElement() const
    {
        if (   CurrentElement > 0
            && CurrentElement <= Spanvector->Active)
        {
            return Spanvector->Spans[CurrentElement - 1].Element;
        }
        else
        {
            return Spanvector->Default;
        }
    }

    UINT32 GetCurrentOffset() const {return CurrentOffset;}

    UINT32 GetUniformLength() const {
        if (CurrentElement < Spanvector->Active)
        {
            return CurrentElementIndex + Spanvector->Spans[CurrentElement].Length - CurrentOffset;
        }
        else
        {
            return 0xFFFFFFFF;  // There's no limit to this span
        }
    }

    UINT32 GetCurrentSpanStart() const {return CurrentElementIndex;}


    // SpanRider has its own SetSpan that must be used to guarantee that
    // the rider remains accurate.

    Status SetSpan(INT first, INT length, C element)
    {
        // Position the rider at the beginning. This change will require
        // the rider to be recalculated.
        CurrentOffset       = 0;
        CurrentElement      = 0;
        CurrentElementIndex = 0;
        return Spanvector->SetSpan(first, length, element);
    }


private:

    SpanVector<C> *Spanvector;
    Span<C>        DefaultSpan;
    UINT32         CurrentOffset;
    INT            CurrentElement;
    UINT32         CurrentElementIndex;
};



/*
    const C &GetElement() const {
        return (*Spans)[CurrentElement].Element;
    }
*/



#if 0

/////   MultiSpanRider
//
//      Supports advancing through parallel spanvectors of different types
//      returning the max length uniform in all registerd types.
//
//      The client calls SetScript, SetLanguage etc to register which
//      spanVectors to scan in parallel.


class MultiSpanRider {
public:
    MultiSpanRider(
        UINT32 stringLength
    ) :
        StringLength  (stringLength),
        FamilyRider   (NULL),
        StyleRider    (NULL),
        SizeRider     (NULL),
        //ScriptRider   (NULL),
        LanguageRider (NULL),
        LevelRider    (NULL),
        //ItemRider     (NULL),
        LineRider     (NULL),
        Offset        (0),
        UniformLength (0),
        Started       (FALSE)
    {}

    ~MultiSpanRider()
    {
        if (FamilyRider)   delete FamilyRider;
        if (StyleRider)    delete StyleRider;
        if (SizeRider)     delete SizeRider;
        //if (ScriptRider)   delete ScriptRider;
        if (LanguageRider) delete LanguageRider;
        if (LevelRider)    delete LevelRider;
        //if (ItemRider)     delete ItemRider;
        if (LineRider)     delete LineRider;
    }

    // ---  Font

    void SetFamily(SpanVector<const GpFontFamily*> *familyVector)
    {
        ASSERT(!Started);
        FamilyRider = new SpanRider<const GpFontFamily*>(familyVector);
    }

    const GpFontFamily *GetFamily()
    {
        ASSERT(Started);
        return FamilyRider->GetCurrentElement();
    }


    void SetStyle(SpanVector<INT> *styleVector)
    {
        ASSERT(!Started);
        StyleRider = new SpanRider<INT>(styleVector);
    }

    const INT GetStyle()
    {
        ASSERT(Started);
        return StyleRider->GetCurrentElement();
    }


    void SetEmSize(SpanVector<REAL> *sizeVector)
    {
        ASSERT(!Started);
        SizeRider = new SpanRider<REAL>(sizeVector);
    }

    const REAL GetEmSize()
    {
        ASSERT(Started);
        return SizeRider->GetCurrentElement();
    }

    /*
    // ---  Script

    void SetScript(SpanVector<Script> *scriptVector)
    {
        ASSERT(!Started);
        ScriptRider = new SpanRider<Script>(scriptVector);
    }

    Script GetScript()
    {
        ASSERT(Started);
        return ScriptRider->GetCurrentElement();
    }
    */


    // ---  Language


    void SetLanguage(SpanVector<UINT16> *languageVector)
    {
        ASSERT(!Started);
        LanguageRider = new SpanRider<UINT16>(languageVector);
    }

    UINT16 GetLanguage()
    {
        ASSERT(Started);
        return LanguageRider->GetCurrentElement();
    }

    // ---  bidi Level

    void SetLevel(SpanVector<BYTE> *levelVector)
    {
        ASSERT(!Started);
        LevelRider = new SpanRider<BYTE>(levelVector);
    }

    UINT16 GetLevel()
    {
        ASSERT(Started);
        return LevelRider->GetCurrentElement();
    }

    // ---  item

    /*
    void SetItem(SpanVector<Item*> *vector)
    {
        ASSERT(!Started);
        ItemRider = new SpanRider<Item*>(vector);
    }

    Item* GetItem()
    {
        ASSERT(Started);
        return ItemRider->GetCurrentElement();
    }

    const Span<Item*> &GetItemSpan() const
    {
        ASSERT(Started);
        return ItemRider->GetCurrentSpan();
    }

    UINT32 GetItemStart() const
    {
        ASSERT(Started);
        return ItemRider->GetCurrentSpanStart();
    }
    */

    // ---  filledLine

    void SetLine(SpanVector<BuiltLine*> *vector)
    {
        ASSERT(!Started);
        LineRider = new SpanRider<BuiltLine*>(vector);
    }

    const BuiltLine* GetLine() const
    {
        ASSERT(Started);
        return LineRider->GetCurrentElement();
    }

    UINT32 GetLineStart() const
    {
        ASSERT(Started);
        return LineRider->GetCurrentSpanStart();
    }

    // ---

    UINT32 GetUniformLength()
    {
        if (!Started)
        {
            ASSERT(   FamilyRider
                   || StyleRider
                   || SizeRider
                   //|| ScriptRider
                   || LanguageRider
                   || LevelRider
                   //|| ItemRider
                   || LineRider);
            CalculateUniformLength();
            Started = TRUE;
        }

        return UniformLength;
    }

    UINT32 GetOffset()
    {
        return Offset;
    }

    void operator++(int)
    {
        ASSERT(Started);

        // Advance to next uniform length

        Offset += UniformLength;
        SetPosition(Offset);
        CalculateUniformLength();
    }



private:

    void SetPosition(UINT32 Offset)
    {
        if (FamilyRider)   FamilyRider   -> SetPosition(Offset);
        if (StyleRider)    StyleRider    -> SetPosition(Offset);
        if (SizeRider)     SizeRider     -> SetPosition(Offset);
        // if (ScriptRider)   ScriptRider   -> SetPosition(Offset);
        if (LanguageRider) LanguageRider -> SetPosition(Offset);
        if (LevelRider)    LevelRider    -> SetPosition(Offset);
        // if (ItemRider)     ItemRider     -> SetPosition(Offset);
        if (LineRider)     LineRider     -> SetPosition(Offset);
        {

        }
    }

    void CalculateUniformLength()
    {
        UniformLength = 0x3FFFFFFF;

        if (FamilyRider && FamilyRider->GetUniformLength() < UniformLength)
        {
            UniformLength = FamilyRider->GetUniformLength();
        }

        if (StyleRider && StyleRider->GetUniformLength() < UniformLength)
        {
            UniformLength = StyleRider->GetUniformLength();
        }

        if (SizeRider && SizeRider->GetUniformLength() < UniformLength)
        {
            UniformLength = SizeRider->GetUniformLength();
        }

        /*
        if (ScriptRider && ScriptRider->GetUniformLength() < UniformLength)
        {
            UniformLength = ScriptRider->GetUniformLength();
        }
        */

        if (LanguageRider && LanguageRider->GetUniformLength() < UniformLength)
        {
            UniformLength = LanguageRider->GetUniformLength();
        }

        if (LevelRider && LevelRider->GetUniformLength() < UniformLength)
        {
            UniformLength = LevelRider->GetUniformLength();
        }

        /*
        if (ItemRider && ItemRider->GetUniformLength() < UniformLength)
        {
            UniformLength = ItemRider->GetUniformLength();
        }
        */

        if (LineRider && LineRider->GetUniformLength() < UniformLength)
        {
            UniformLength = LineRider->GetUniformLength();
        }

        if (UniformLength >= StringLength - Offset)
        {
            UniformLength = StringLength - Offset;   // It's uniform all the way to the end
        }
    }



    SpanRider<const GpFontFamily*> *FamilyRider;
    SpanRider<INT>                 *StyleRider;
    SpanRider<REAL>                *SizeRider;
    // SpanRider<Script>              *ScriptRider;
    SpanRider<UINT16>              *LanguageRider;
    SpanRider<BYTE>                *LevelRider;
    // SpanRider<Item*>               *ItemRider;
    SpanRider<BuiltLine*>         *LineRider;

    UINT32  StringLength;
    UINT32  Offset;
    UINT32  UniformLength;
    BOOL    Started;
};


#endif // 0



#endif // _SPAN_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\classdef.h ===
/***********************************************************************
************************************************************************
*
*                    ********  CLASSDEF.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of ClassDef tables
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetClassDefFormat = 0;

const OFFSET offsetStartClassGlyph = 2;
const OFFSET offsetClassGlyphCount = 4;
const OFFSET offsetClassValueArray = 6;

const SIZE sizeClassArrayTableSize = sizeUSHORT + sizeGlyphID + sizeUSHORT;

class otlClassArrayTable: public otlTable
{
public:

    otlClassArrayTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeClassArrayTableSize,
                                        offsetClassGlyphCount,sizeUSHORT,sec))
        {
            setInvalid();
            return;
        }

        assert(format() == 1);
    }

    USHORT format() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetClassDefFormat); 
    }

    otlGlyphID startGlyph() const 
    {   
        assert(isValid());

        return GlyphID(pbTable + offsetStartClassGlyph); 
    }

    USHORT glyphCount() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetClassGlyphCount); 
    }

    USHORT classValue(USHORT index) const
    {   
        assert(isValid());

        assert(index < glyphCount());
        return UShort(pbTable + offsetClassValueArray + index*sizeof(USHORT)); 
    }
};


const OFFSET offsetClassRangeStart = 0;
const OFFSET offsetClassRangeEnd = 2;
const OFFSET offsetClass = 4;

const SIZE sizeClassRangeRecord = sizeGlyphID + sizeGlyphID + sizeUSHORT;
    
class otlClassRangeRecord: public otlTable
{
public:

    otlClassRangeRecord(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec)
    {
        if (!isValidTable(pb,sizeRangeRecord,sec)) // should bechecked in CoverageTable
        {
            assert(false);
            setInvalid();
        }
    }

    otlGlyphID start() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetClassRangeStart); 
    }

    otlGlyphID end() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetClassRangeEnd); 
    }

    USHORT getClass() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetClass); 
    }
};


const OFFSET offsetClassRangeCount = 2;
const OFFSET offsetClassRangeRecordArray = 4;

const SIZE sizeClassRangesTable = sizeUSHORT + sizeUSHORT;

class otlClassRangesTable: public otlTable
{
public:

    otlClassRangesTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeClassRangesTable,
                                        offsetClassRangeCount,sizeClassRangeRecord,sec))
        {
            setInvalid();
            return;
        }
        
        assert(format() == 2);
    }

    USHORT format() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetClassDefFormat); 
    }

    USHORT classRangeCount() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetClassRangeCount); 
    }

    otlClassRangeRecord classRangeRecord(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid());
        
        assert(index < classRangeCount());
        return otlClassRangeRecord(pbTable + offsetClassRangeRecordArray 
                                              + index*sizeClassRangeRecord,sec); 
    }
};


class otlClassDef: public otlTable
{
public:

    otlClassDef(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTable(pb,sizeUSHORT,sec)) setInvalid(); //format field only
    }

    USHORT format() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetClassDefFormat); 
    }

    USHORT getClass(otlGlyphID glyph, otlSecurityData sec) const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\common.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  COMMON.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements common helper functions 
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"


/***********************************************************************/

USHORT NextCharInLiga
(
    const otlList*      pliCharMap,
    USHORT              iChar
)
{
    USHORT len = pliCharMap->length();
    USHORT iGlyph = readOtlGlyphIndex(pliCharMap, iChar);

    for(USHORT ich = iChar + 1; ich < len; ++ich)
    {
        if (readOtlGlyphIndex(pliCharMap, ich) == iGlyph)
        {
            return ich;
        }
    }

    return len;
}

// REVIEW:  review handling iGlyph indices -- 
//          what we do here is very far from optimal


void InsertGlyphs
(
    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,
    USHORT              iGlyph,
    USHORT              cHowMany
)
{
    if (cHowMany == 0) return;

    pliGlyphInfo->insertAt(iGlyph, cHowMany);

    for (USHORT ich = 0; ich < pliCharMap->length(); ++ich)
    {
        USHORT* piGlyph = getOtlGlyphIndex(pliCharMap, ich);
        if (*piGlyph >= iGlyph)
        {
            *piGlyph += cHowMany;
        }
    }
}

void DeleteGlyphs
(
    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,
    USHORT              iGlyph,
    USHORT              cHowMany
)
{
    if (cHowMany == 0) return;

    pliGlyphInfo->deleteAt(iGlyph, cHowMany);

    for (USHORT ich = 0; ich < pliCharMap->length(); ++ich)
    {
        USHORT* piGlyph = getOtlGlyphIndex(pliCharMap, ich);
        if (*piGlyph >= iGlyph + cHowMany)
        {
            *piGlyph -= cHowMany;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\context.h ===
/***********************************************************************
************************************************************************
*
*                    ********  CONTEXT.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with context based lookups.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetContextSequenceIndex = 0;
const OFFSET offsetContextLookupIndex = 2;

const SIZE   sizeContextLookupRecord = sizeUSHORT + sizeUSHORT;

class otlContextLookupRecord: public otlTable
{
public:
    otlContextLookupRecord(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTable(pb,sizeContextLookupRecord,sec)) setInvalid();
    }

    USHORT sequenceIndex() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetContextSequenceIndex); 
    }

    USHORT lookupListIndex() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetContextLookupIndex); 
    }
};


const OFFSET offsetContextGlyphCount  = 0;
const OFFSET offsetContextLookupRecordCount = 2;
const OFFSET offsetContextInput = 4;

const SIZE   sizeContextRuleTable = sizeUSHORT + sizeUSHORT;

class otlContextRuleTable: public otlTable
{
public:
    otlContextRuleTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeContextRuleTable,
                                    offsetContextGlyphCount,sizeGlyphID,sec))
        {
            setInvalid();
            return;
        }

        OFFSET offsetLookupRecord = offsetContextInput + glyphCount()*sizeGlyphID;

        if (!isValidTableWithArray(pb,offsetLookupRecord,
                                    offsetContextLookupRecordCount,sizeGlyphID,sec))
        {
            setInvalid();
            return;
        }
        
    }

    USHORT glyphCount() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetContextGlyphCount); 
    }

    USHORT lookupCount() const
    {  
        assert(isValid());

        return UShort(pbTable + offsetContextLookupRecordCount); 
    }

    otlGlyphID input(USHORT index) const
    {   
        assert(isValid());

        assert(index < glyphCount());
        assert(index > 0);
        return GlyphID(pbTable + offsetContextInput 
                               + (index - 1)* sizeof(otlGlyphID));
    }

    otlList lookupRecords() const
    {   
        assert(isValid());
        
        return otlList((void*)(pbTable + offsetContextInput 
                                       + (glyphCount() - 1) * sizeof(otlGlyphID)),
                        sizeContextLookupRecord, lookupCount(), lookupCount());
    }
};


const OFFSET offsetContextRuleCount = 0;
const OFFSET offsetContextRuleArray = 2;

const SIZE   sizeContextRuleSetTable = sizeUSHORT;

class otlContextRuleSetTable: public otlTable
{
public:
    otlContextRuleSetTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeContextRuleSetTable,
                                        offsetContextRuleCount,sizeOFFSET,sec))
        {
            setInvalid();
        }
    }

    USHORT ruleCount() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetContextRuleCount); 
    }

    otlContextRuleTable rule(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid());
        
        assert(index < ruleCount());
        return otlContextRuleTable(pbTable + 
            Offset(pbTable + offsetContextRuleArray + index * sizeof(OFFSET)),sec);
    }
};
                                                    

const OFFSET offsetContextCoverage = 2;
const OFFSET offsetContextRuleSetCount = 4;
const OFFSET offsetContextRuleSetArray =6;

const SIZE   sizeContextSubTable =  sizeUSHORT + sizeOFFSET + sizeUSHORT;

class otlContextSubTable: public otlLookupFormat
{
public:
    otlContextSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeContextSubTable,
                                        offsetContextRuleSetCount,sizeOFFSET,sec))
        {
            setInvalid();
            return;
        }
            
        assert(format() == 1);
    }

    otlCoverage coverage(otlSecurityData sec) const
    {   
        assert(isValid());
        
        return otlCoverage(pbTable + Offset(pbTable + offsetContextCoverage),sec); 
    }

    USHORT ruleSetCount() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetContextRuleSetCount); 
    }

    otlContextRuleSetTable ruleSet(USHORT index, otlSecurityData sec) const
    {
        assert(isValid());

        assert(index < ruleSetCount());
        return otlContextRuleSetTable(pbTable +
            Offset(pbTable + offsetContextRuleSetArray + index * sizeof(OFFSET)),sec);
    }
};



const OFFSET offsetContextClassCount = 0;
const OFFSET offsetContextClassLookupRecordCount = 2;
const OFFSET offsetContextClassInput = 4;

const SIZE   sizeContextClassRuleTable = sizeUSHORT + sizeUSHORT;

class otlContextClassRuleTable: public otlTable
{
public:
    otlContextClassRuleTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        //Use two checks instead of isValidTable with array
        if (!isValidTable(pb,sizeContextClassRuleTable,sec))
        {
            setInvalid();
            return;
        }

        if  (!isValidTable(pb,sizeContextClassRuleTable+(classCount()-1)*sizeOFFSET,sec))
        {
            setInvalid();
            return;
        }
        
        USHORT offsetContextClassLookups = offsetContextClassInput+ (classCount()-1)*sizeUSHORT;

        if (!isValidTableWithArray(pb,sizeContextClassRuleTable,
                                        offsetContextClassLookupRecordCount,
                                        sizeContextLookupRecord,sec))
        {
            setInvalid();
            return;
        }
    }

    USHORT classCount() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetContextClassCount); 
    }

    USHORT lookupCount() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetContextClassLookupRecordCount); 
    }

    USHORT inputClass(USHORT index) const
    {   
        assert(isValid());
        
        assert(index < classCount());
        assert(index > 0);
        return GlyphID(pbTable + offsetContextClassInput 
                               + (index - 1) * sizeof(USHORT)); 
    }

    otlList lookupRecords() const
    {   
        assert(isValid());
        
        return otlList((void*)(pbTable + offsetContextClassInput 
                                       + (classCount() - 1) * sizeof(USHORT)),
                        sizeContextLookupRecord, lookupCount(), lookupCount());
    }
};


const OFFSET offsetContextClassRuleCount = 0;
const OFFSET offsetContextClassRuleArray = 2;

const SIZE sizeContextClassRuleSetTable = sizeUSHORT;

class otlContextClassRuleSetTable: public otlTable
{
public:
    otlContextClassRuleSetTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeContextClassRuleSetTable,
                                        offsetContextClassRuleCount,sizeOFFSET,sec))
        {
            setInvalid();
        }
    }

    USHORT ruleCount() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetContextClassRuleCount); 
    }

    otlContextClassRuleTable rule(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid());

        assert(index < ruleCount());
        return otlContextClassRuleTable(pbTable + 
            Offset(pbTable + offsetContextClassRuleArray 
                           + index * sizeof(OFFSET)),sec);
    }
};
                                                    

const OFFSET offsetContextClassCoverage = 2;
const OFFSET offsetContextClassDef = 4;
const OFFSET offsetContextClassRuleSetCount = 6;
const OFFSET offsetContextClassRuleSetArray =8;

const SIZE sizeContextClassSubTable = sizeUSHORT + sizeOFFSET + sizeOFFSET + sizeUSHORT;

class otlContextClassSubTable: public otlLookupFormat
{
public:
    otlContextClassSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeContextClassSubTable,
                                        offsetContextClassRuleSetCount,sizeOFFSET,sec))
        {
            setInvalid();
            return;
        }
        
        assert(format() == 2);
    }

    otlCoverage coverage(otlSecurityData sec) const
    {   
        assert(isValid());
        
        return otlCoverage(pbTable 
                    + Offset(pbTable + offsetContextClassCoverage),sec); 
    }

    otlClassDef classDef(otlSecurityData sec) const
    {   
        assert(isValid());

        return otlClassDef(pbTable 
                    + Offset(pbTable + offsetContextClassDef),sec); 
    }

    USHORT ruleSetCount() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetContextClassRuleSetCount); 
    }

    otlContextClassRuleSetTable ruleSet(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid());

        assert(index < ruleSetCount());

        USHORT offset = 
            Offset(pbTable + offsetContextClassRuleSetArray 
                           + index * sizeof(OFFSET));
        if (offset == 0)
            return otlContextClassRuleSetTable((const BYTE*)NULL,sec);

        return otlContextClassRuleSetTable(pbTable + offset,sec);
    }
};
    


const OFFSET offsetContextCoverageGlyphCount = 2;
const OFFSET offsetContextCoverageLookupRecordCount = 4;
const OFFSET offsetContextCoverageArray = 6;

const SIZE   sizeContextCoverageSubTable = sizeUSHORT*3;

class otlContextCoverageSubTable: public otlLookupFormat
{
public:
    otlContextCoverageSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeContextCoverageSubTable,
                                        offsetContextCoverageGlyphCount,sizeOFFSET,sec))
        {
            setInvalid();
            return;
        }
        
        OFFSET offsetContextCoverageLookupRecordArray = offsetContextCoverageArray +
                                                            glyphCount()*sizeOFFSET;

        if (!isValidTableWithArray(pb,offsetContextCoverageLookupRecordArray,
                                        offsetContextCoverageLookupRecordCount,
                                        sizeContextLookupRecord,sec))
        {
            setInvalid();
            return;
        }
                                                            
        assert(format() == 3);
    }

    USHORT glyphCount() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetContextCoverageGlyphCount); 
    }

    USHORT lookupCount() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetContextCoverageLookupRecordCount); 
    }

    otlCoverage coverage(USHORT index, otlSecurityData sec) const
    {   assert(index < glyphCount());
        return otlCoverage(pbTable + 
            Offset(pbTable + offsetContextCoverageArray 
                           + index * sizeof(OFFSET)),sec);
    }

    otlList lookupRecords() const
    {   
        assert(isValid());

        return otlList((void*)(pbTable + offsetContextCoverageArray 
                                       + glyphCount() * sizeof(OFFSET)),
                        sizeContextLookupRecord, lookupCount(), lookupCount());
    }
};


class otlContextLookup: public otlLookupFormat
{
public:
    otlContextLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec) 
    {
        assert(isValid());
    }
    
    otlErrCode apply
    (
        otlTag                      tagTable,
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        USHORT                      grfLookupFlags,
        long                        lParameter,
        USHORT                      nesting,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph

        otlSecurityData             sec
    );

};

// helper functions

otlErrCode applyContextLookups
(
        const otlList&              liLookupRecords,
 
        otlTag                      tagTable,           // GSUB/GPOS
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        USHORT                      grfLookupFlags,
        long                        lParameter,
        USHORT                      nesting,
        
        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,          // assert null for GSUB
        otlList*                    pliplcGlyphPlacement,   // assert null for GSUB

        USHORT                      iglFrist,           // where to apply it
        USHORT                      iglAfterLast,       // how long a context we can use
        
        USHORT*                     piglNext,

        otlSecurityData             sec
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\common.h ===
/***********************************************************************
************************************************************************
*
*                    ********  COMMON.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL common table formats.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/
#define     MAX(x,y)    ((x) > (y) ? (x) : (y))
#define     MIN(x,y)    ((x) > (y) ? (y) : (x))

const unsigned short MAXUSHORT = 0xFFFF;

#ifndef     OFFSET
#define     OFFSET  unsigned short
#endif

#ifndef SIZE
#define SIZE unsigned short
#endif

const sizeOFFSET    = sizeof(OFFSET);
const sizeUSHORT    = sizeof(USHORT);
const sizeGlyphID   = sizeof(otlGlyphID);
const sizeFIXED     = sizeof(ULONG);
const sizeTAG       = sizeof(otlTag);

// (from ntdef.h)
#ifndef     UNALIGNED
#if defined(_M_MRX000) || defined(_M_AMD64) || defined(_M_PPC) || defined(_M_IA64)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif

inline OTL_PUBLIC otlGlyphID GlyphID( const BYTE* pbTable);
inline OTL_PUBLIC OFFSET Offset( const BYTE* pbTable);
inline OTL_PUBLIC USHORT UShort( const BYTE* pbTable);
inline OTL_PUBLIC short SShort( const BYTE* pbTable);
inline OTL_PUBLIC ULONG ULong( const BYTE* pbTable);

//
//  Security check structures
//

// <sergeym>
// Since this otlSecurityData is very simple
// I won't make security checks parameter presence based on OTLCFG_SECURE.
// Most constructors are inlines so parameters and checks will be eliminated.
// Actual checks are always true if OTLCFG_SECURE is undefined

typedef const BYTE * otlSecurityData;   // we dont need any complex structures 
                                        // here, so this pointer means just 
                                        // pointer to the byte after table end

const otlSecurityData secEmptySecurityData = (const BYTE*)NULL;
const otlSecurityData pbInvalidData = (const BYTE*) NULL;

const otlInvalidLookupType    = 0xFFFF;
const otlInvalidSubtableFormat   = 0xFFFF;

#ifdef OTLCFG_SECURE
inline bool isValidOffset(const BYTE * pbTable, otlSecurityData sec)
    { return (pbTable && (!sec || pbTable<=sec)); }

inline bool isValidTable(const BYTE * pbTable, SIZE size, otlSecurityData sec)
    { return (pbTable && isValidOffset(pbTable+size,sec)); }

inline bool isValidTableWithArray(const BYTE * pbTable, SIZE sizeFixedPart, OFFSET OffsetToLength, SIZE sizeRecord, otlSecurityData sec)
    { 
        return (pbTable && 
                isValidOffset(pbTable+sizeFixedPart,sec) && 
                isValidOffset(pbTable+sizeFixedPart+sizeRecord*UShort(pbTable+OffsetToLength),sec)
               ); 
    }

inline otlErrCode InitSecurityData(otlSecurityData *psec, const BYTE *pbTable, ULONG lTableLength)
{
    *psec = pbTable + lTableLength;
    return OTL_SUCCESS;
}

inline  otlErrCode FreeSecutiryData(otlSecurityData sec)
{
    return OTL_SUCCESS;
}

#else //OTLCFG_SECURE

inline bool isValidOffset(const BYTE * pbTable, otlSecurityData sec)
    { return TRUE; }

inline bool isValidTable(const BYTE * pbTable, USHORT size, otlSecurityData sec)
    { return TRUE; }

inline bool isValidTableWithArray(const BYTE * pbTable, USHORT size, USHORT OffsetToLength, USHORT RecordSize, otlSecurityData sec)
    { return TRUE; }

inline otlErrCode InitSecurityData(otlSecurityData *psec, const BYTE *pbTable, ULONG lTableLength)
{
    *psec = secEmptySecurityData
    return OTL_SUCCESS;
}

inline  otlErrCode FreeSecurityData(otlSecurityData sec)
{
    return OTL_SUCCESS;
}
#endif //#ifdef OTLCFG_SECURE

//
// End Security check structures
// -----------------------------


class otlTable
{
protected:

    const BYTE* pbTable;

    otlTable(const BYTE* pb, otlSecurityData sec)
        : pbTable(pb)
    {
        if (!isValidOffset(pb,sec)) setInvalid();
    }

private:

    // new not allowed
    void* operator new(size_t size);

public:

    otlTable& operator = (const otlTable& copy)
    {
        pbTable = copy.pbTable;
        return *this;
    }

    bool isNull() const
    {
        return (pbTable == (const BYTE*)NULL);
    }

#ifdef OTLCFG_SECURE
    bool isValid() const
    {
        return (pbTable != pbInvalidData);
    }

    void setInvalid()
    {
        pbTable = pbInvalidData;
    }    
#else
    bool isValid() const
    {
        return TRUE;
    }

    void setInvalid()
    {
    }    
#endif //#ifdef OTLCFG_SECURE

};


USHORT NextCharInLiga
(
    const otlList*      pliCharMap,
    USHORT              iChar
);

void InsertGlyphs
(
    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,
    USHORT              iGlyph,
    USHORT              cHowMany
);

void DeleteGlyphs
(
    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,
    USHORT              iGlyph,
    USHORT              cHowMany
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\coverage.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  COVERAGE.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of coverage tables.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// REVIEW (PERF): it's used a lot - optimize!

short otlCoverage::getIndex(otlGlyphID glyph, otlSecurityData sec) const
{
    if (!isValid()) return -1; //invalid coverage table
        
    switch (format())
    {
    case(1):    // individual glyph coverage
        {
            otlIndividualGlyphCoverageTable individualCoverage = 
                            otlIndividualGlyphCoverageTable(pbTable,sec);
            if (!individualCoverage.isValid()) return -1;
            
   /* Validation assert
   #ifdef _DEBUG            
            // in debug mode, check that the coverage is sorted
            for (USHORT i = 0; i < individualCoverage.glyphCount() - 1; ++i)
            {
                assert(individualCoverage.glyph(i) < individualCoverage.glyph(i + 1));
            }
   #endif
   */
            USHORT iLow = 0;
            // always beyond the upper bound
            USHORT iHigh = individualCoverage.glyphCount();  
            while(iLow < iHigh)
            {
                USHORT iMiddle = (iLow + iHigh) >> 1;
                otlGlyphID glyphMiddle = individualCoverage.glyph(iMiddle);
                if (glyph < glyphMiddle) 
                {
                    iHigh = iMiddle;
                }
                else if (glyphMiddle < glyph)
                {
                    iLow = iMiddle + 1;
                }
                else
                {
                    return iMiddle;
                }            
            } 

            return  -1;
        }

    case(2):    // range coverage
        {
            otlRangeCoverageTable rangeCoverage = 
                        otlRangeCoverageTable(pbTable,sec);

            if (!rangeCoverage.isValid()) return -1;

   /* Validation assert
   #ifdef _DEBUG
            // in debug mode, check that the coverage is sorted
            for (USHORT i = 0; i < rangeCoverage.rangeCount() - 1; ++i)
            {
                assert(rangeCoverage.rangeRecord(i,sec).start() 
                       < rangeCoverage.rangeRecord(i + 1,sec).start());
            }
   #endif
   */
            USHORT iLowRange = 0;
            // always beyond the upper bound
            USHORT iHighRange = rangeCoverage.rangeCount(); 
            while(iLowRange < iHighRange)
            {
                USHORT iMiddleRange = (iLowRange + iHighRange) >> 1;
                otlRangeRecord range = rangeCoverage.rangeRecord(iMiddleRange,sec);
                if (glyph < range.start()) 
                {
                    iHighRange = iMiddleRange;
                }
                else if (range.end() < glyph)
                {
                    iLowRange = iMiddleRange + 1;
                }
                else
                {
                    return glyph - range.start() + range.startCoverageIndex();
                }            
            } 

            return  -1;
        }
    }

    // default: invalid format
    return -1; //OTL_BAD_FONT_TABLE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\context.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  CONTEXT.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with context-based substitution lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode applyContextLookups
(
        const otlList&              liLookupRecords,
 
        otlTag                      tagTable,           // GSUB/GPOS
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        USHORT                      grfLookupFlags,
        long                        lParameter,
        USHORT                      nesting,
        
        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,          // assert null for GSUB
        otlList*                    pliplcGlyphPlacement,   // assert null for GSUB

        USHORT                      iglFirst,       
        USHORT                      iglAfterLast,   

        USHORT*                     piglNext,

        otlSecurityData             sec
)
{
    if (nesting > OTL_CONTEXT_NESTING_LIMIT) return OTL_ERR_CONTEXT_NESTING_TOO_DEEP;

    otlLookupListTable lookupList = otlLookupListTable((const BYTE*)NULL,sec);

    otlErrCode erc;
    erc =  GetScriptFeatureLookupLists(tagTable, resourceMgr, 
                                        (otlScriptListTable*)NULL, 
                                        (otlFeatureListTable*)NULL, 
                                        &lookupList,
                                        (otlSecurityData*)NULL);
    if (erc != OTL_SUCCESS) return erc;

    // get GDEF
    otlSecurityData secgdef;
    const BYTE *pbgdef;
    resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
    otlGDefHeader gdef = 
        otlGDefHeader(pbgdef,secgdef);

    USHORT cLookups = liLookupRecords.length();

    short iCurLookup   = -1;
    short iCurSeqIndex = -1;

    for (USHORT i = 0; i < cLookups; ++i)
    {
        USHORT iListIndex = MAXUSHORT;
        USHORT iSeqIndex  = MAXUSHORT;
        // get the next lookup index
        for (USHORT iLookup = 0; iLookup < cLookups; ++iLookup)
        {
            otlContextLookupRecord lookupRecord = 
                otlContextLookupRecord(liLookupRecords.readAt(iLookup),sec);
            assert(lookupRecord.isValid());

            if ((lookupRecord.lookupListIndex() < iListIndex && 
                 lookupRecord.lookupListIndex() > iCurLookup
                ) ||
                (lookupRecord.lookupListIndex() == iCurLookup && 
                 lookupRecord.sequenceIndex() < iSeqIndex &&
                 lookupRecord.sequenceIndex() > iCurSeqIndex
                )
               )
            {
                iListIndex = lookupRecord.lookupListIndex();
                iSeqIndex = lookupRecord.sequenceIndex();
            }
        }

        assert(iListIndex < MAXUSHORT);
        if (iListIndex == MAXUSHORT) return OTL_ERR_BAD_FONT_TABLE;

        iCurLookup   = iListIndex;
        iCurSeqIndex = iSeqIndex;

        otlLookupTable lookupTable = lookupList.lookup(iCurLookup,sec);

        USHORT iglLookupStart = iglFirst;
        for (USHORT iSeq = 0; iSeq < iSeqIndex && iglLookupStart < iglAfterLast; 
                    ++iSeq)
        {
            iglLookupStart = NextGlyphInLookup(pliGlyphInfo,  
                                               grfLookupFlags, gdef, secgdef, 
                                               iglLookupStart + 1, otlForward);
        }

        if (iglLookupStart < iglAfterLast)
        {
            USHORT iglAfterLastReliable = pliGlyphInfo->length() - iglAfterLast;
            USHORT dummy;
            erc = ApplyLookup(tagTable, 
                              pliCharMap, pliGlyphInfo, resourceMgr,
                              lookupTable, lParameter, nesting+1,
                              metr, pliduGlyphAdv, pliplcGlyphPlacement, 
                              iglLookupStart, iglAfterLast, &dummy,sec);
            if (ERRORLEVEL(erc) > 0) return erc;

            iglAfterLast = pliGlyphInfo->length() - iglAfterLastReliable;
        }
    }

    *piglNext = iglAfterLast;
    return OTL_SUCCESS;

}
    
otlErrCode otlContextLookup::apply
(
    otlTag                      tagTable,
    otlList*                    pliCharMap,
    otlList*                    pliGlyphInfo,
    otlResourceMgr&             resourceMgr,

    USHORT                      grfLookupFlags,
    long                        lParameter,
    USHORT                      nesting,

    const otlMetrics&           metr,       
    otlList*                    pliduGlyphAdv,              
    otlList*                    pliplcGlyphPlacement,       

    USHORT                      iglIndex,
    USHORT                      iglAfterLast,

    USHORT*                     piglNextGlyph,      // out: next glyph

    otlSecurityData             sec
)
{
    if (!isValid()) return OTL_NOMATCH;

    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliCharMap->dataSize() == sizeof(USHORT));
    assert(iglAfterLast > iglIndex);
    assert(iglAfterLast <= pliGlyphInfo->length());

    otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);

    switch(format())
    {
    case(1):    // simple
        {
            otlContextSubTable simpleContext = otlContextSubTable(pbTable,sec);
            short index = simpleContext.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
            if (index < 0)
            {
                return OTL_NOMATCH;
            }
            assert (simpleContext.isValid()); //if passed coverage

            if (index >= simpleContext.ruleSetCount())
            {
                return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
            }
            otlContextRuleSetTable ruleSet = simpleContext.ruleSet(index,sec);

            // get GDEF
            otlSecurityData secgdef;
            const BYTE *pbgdef;
            resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
            otlGDefHeader gdef = 
                otlGDefHeader(pbgdef,secgdef);

            // start checking contextes
            USHORT cRules = ruleSet.ruleCount();
            bool match = false;
            for (USHORT iRule = 0; iRule < cRules && !match; ++iRule)
            {
                otlContextRuleTable rule = ruleSet.rule(iRule,sec);
                const USHORT cInputGlyphs = rule.glyphCount();

                // a simple check so we don't waste time
                if (iglIndex + cInputGlyphs > iglAfterLast)
                {
                    match = false;
                }

                USHORT igl = iglIndex;
                match = true;
                for (USHORT iGlyph = 1; 
                            iGlyph < cInputGlyphs && match; ++iGlyph)
                {
                    igl = NextGlyphInLookup(pliGlyphInfo, 
                                            grfLookupFlags, gdef, secgdef, 
                                            igl + 1, otlForward);

                    if (igl >= iglAfterLast ||
                        getOtlGlyphInfo(pliGlyphInfo, igl)->glyph != 
                          rule.input(iGlyph))
                    {
                        match = false;
                    }
                }

                if (match)
                {
                    *piglNextGlyph = NextGlyphInLookup(pliGlyphInfo,  
                                                        grfLookupFlags, gdef, secgdef, 
                                                        igl + 1, otlForward);

                    return applyContextLookups 
                               (rule.lookupRecords(),
                                tagTable, 
                                pliCharMap, pliGlyphInfo, resourceMgr,
                                grfLookupFlags, lParameter, nesting,
                                metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                iglIndex, *piglNextGlyph, piglNextGlyph,sec);
                }
            }

            return OTL_NOMATCH;
        }

    case(2):    // class-based
        {
            otlContextClassSubTable classContext = 
                        otlContextClassSubTable(pbTable,sec);
            short index = classContext.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
            if (index < 0)
            {
                return OTL_NOMATCH;
            }
            assert (classContext.isValid()); //if passed coverage

            otlClassDef classDef =  classContext.classDef(sec);
            USHORT indexClass = classDef.getClass(pGlyphInfo->glyph,sec);

            if (indexClass >= classContext.ruleSetCount())
            {
                return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
            }
            otlContextClassRuleSetTable ruleSet = 
                        classContext.ruleSet(indexClass,sec);

            if (ruleSet.isNull())
            {
                return OTL_NOMATCH;
            }

            // get GDEF
            otlSecurityData secgdef;
            const BYTE *pbgdef;
            resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
            otlGDefHeader gdef = 
                otlGDefHeader(pbgdef,secgdef);

            // start checking contextes
            USHORT cRules = ruleSet.ruleCount();
            bool match = false;
            for (USHORT iRule = 0; iRule < cRules && !match; ++iRule)
            {
                otlContextClassRuleTable rule = ruleSet.rule(iRule,sec);
                USHORT cInputGlyphs = rule.classCount();

                // a simple check so we don't waste time
                if (iglIndex + cInputGlyphs > iglAfterLast)
                {
                    match = false;
                }

                USHORT igl = iglIndex;
                match = true;
                for (USHORT iGlyph = 1; 
                            iGlyph < cInputGlyphs && match; ++iGlyph)
                {
                    igl = NextGlyphInLookup(pliGlyphInfo, 
                                            grfLookupFlags, gdef, secgdef, 
                                            igl + 1, otlForward);

                    if (igl >= iglAfterLast || 
                        classDef.getClass(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph,sec)
                        != rule.inputClass(iGlyph))
                    {
                        match = false;
                    }
                }

                if (match)
                {
                    *piglNextGlyph = NextGlyphInLookup(pliGlyphInfo,  
                                                        grfLookupFlags, gdef, secgdef, 
                                                        igl + 1, otlForward);

                    return applyContextLookups 
                                   (rule.lookupRecords(),
                                    tagTable, 
                                    pliCharMap, pliGlyphInfo, resourceMgr,
                                    grfLookupFlags, lParameter, nesting,
                                    metr, pliduGlyphAdv, pliplcGlyphPlacement,  
                                    iglIndex,*piglNextGlyph, piglNextGlyph,sec);
                }
            }

            return OTL_NOMATCH;
        }
    case(3):    // coverage-based
        {
            otlContextCoverageSubTable coverageContext = 
                            otlContextCoverageSubTable(pbTable,sec);
            if (!coverageContext.isValid()) return OTL_NOMATCH;
            
            bool match = true;

            USHORT cInputGlyphs = coverageContext.glyphCount();

            // a simple check so we don't waste time
            if (iglIndex + cInputGlyphs > iglAfterLast)
            {
                match = false;
            }

            // get GDEF
            otlSecurityData secgdef;
            const BYTE *pbgdef;
            resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
            otlGDefHeader gdef = 
                otlGDefHeader(pbgdef,secgdef);

            USHORT igl = iglIndex;
            for (USHORT iGlyph = 0; 
                        iGlyph < cInputGlyphs && match; ++iGlyph)
            {
                if (igl >= iglAfterLast || coverageContext.coverage(iGlyph,sec)
                    .getIndex(getOtlGlyphInfo(pliGlyphInfo, igl)->glyph,sec) < 0)
                {
                    match = false;
                }
                else
                {
                    igl = NextGlyphInLookup(pliGlyphInfo, 
                                            grfLookupFlags, gdef, secgdef, 
                                            igl + 1, otlForward);
                }
            }

            if (match)
            {
                return applyContextLookups 
                               (coverageContext.lookupRecords(),
                                tagTable, 
                                pliCharMap, pliGlyphInfo, resourceMgr,
                                grfLookupFlags, lParameter, nesting,
                                metr, pliduGlyphAdv, pliplcGlyphPlacement,
                                iglIndex, igl, piglNextGlyph,sec);
            }

            return OTL_NOMATCH;
        }

    default:
        //Unknown format, don't do anything
        return OTL_NOMATCH; //OTL_BAD_FONT_TABLE
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\common.inl ===
/***********************************************************************
************************************************************************
*
*                    ********  COMMON.INL  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals OTL most common functions
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

/***********************************************************************/

/*  Read one Glyph ID (unsigned 16 bits) from the big endian table     */

inline OTL_PUBLIC otlGlyphID GlyphID(const BYTE* pbTable )
{
    return (((otlGlyphID)pbTable[0] << 8) + (otlGlyphID)pbTable[1]);
}

/***********************************************************************/

/*  Read one unsigned 16 bit value from the big endian table           */

inline OTL_PUBLIC USHORT UShort(const BYTE* pbTable )
{
    return (((USHORT)pbTable[0] << 8) + (USHORT)pbTable[1]);
}

/***********************************************************************/
/*  Read one unsigned 16 bit offset from the big endian table           */

inline OTL_PUBLIC USHORT Offset(const BYTE* pbTable )
{
    return UShort(pbTable);
}

/***********************************************************************/

/*  Read one unsigned 16 bit value from the big endian table           */

inline OTL_PUBLIC short SShort(const BYTE* pbTable )
{
    return (short)(((USHORT)pbTable[0] << 8) + (USHORT)pbTable[1]);
}

/***********************************************************************/

/*  Read one unsigned 32 bit value from the big endian table           */

inline OTL_PUBLIC ULONG ULong(const BYTE* pbTable )
{
    return (((ULONG)pbTable[0] << 24) + ((ULONG)pbTable[1] << 16) + 
            ((ULONG)pbTable[2] << 8) + (ULONG)pbTable[3] );
}

/***********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\cursipos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  CURSIPOS.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with cursive attachment lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// defenitions and helpers

// recording cursive attachment dependencies in glyph flags

#define     OTL_GFLAG_DEPPOS    0xFF00  // cursive attachment dependency offset
                                        // used to handle right-to-left attachment

USHORT getPosDependency(const otlList* pliGlyphInfo, USHORT from)
{
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(from < pliGlyphInfo->length());

    const otlGlyphInfo* pGlyphInfoFrom = readOtlGlyphInfo(pliGlyphInfo, from);
    return from - ((pGlyphInfoFrom->grf & OTL_GFLAG_DEPPOS) >> 8);
}

void setPosDependency(otlList* pliGlyphInfo, USHORT from, USHORT to)
{
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(from < pliGlyphInfo->length());
    assert(to < from);
    assert(from - to < 0x0100);

    otlGlyphInfo* pGlyphInfoFrom = getOtlGlyphInfo(pliGlyphInfo, from);
    pGlyphInfoFrom->grf &= ~OTL_GFLAG_DEPPOS;
    pGlyphInfoFrom->grf |= (from - to) << 8;
}

void AdjustCursiveDependents
(
    const otlList*      pliGlyphInfo,
    otlList*            pliPlacement,
    USHORT              igl,
    const otlPlacement& plcAfter,
    const otlPlacement& plcBefore
)
{
    USHORT iglPrev = getPosDependency(pliGlyphInfo, igl);
    if (iglPrev != igl)
    {
        otlPlacement* plc = getOtlPlacement(pliPlacement, iglPrev);

        plc->dx += plcAfter.dx - plcBefore.dx;
        plc->dy += plcAfter.dy - plcBefore.dy;

        AdjustCursiveDependents(pliGlyphInfo, pliPlacement, iglPrev, 
                                plcAfter, plcBefore);
    }
}


otlErrCode otlCursivePosLookup::apply
(
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        USHORT                      grfLookupFlags,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph

        otlSecurityData             sec
)
{
    if (!isValid()) return OTL_NOMATCH;

    assert(pliGlyphInfo != NULL);
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

    assert(pliduGlyphAdv != NULL);
    assert(pliduGlyphAdv->dataSize() == sizeof(long));
    assert(pliplcGlyphPlacement != NULL);
    assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));

    assert(pliduGlyphAdv->length() == pliGlyphInfo->length());
    assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length());

    assert(iglAfterLast > iglIndex);
    assert(iglAfterLast <= pliGlyphInfo->length());

    //assert(format() == 1); //Validation assert
    if (format()!=1) return OTL_NOMATCH;

    otlCursivePosSubTable cursiPos = otlCursivePosSubTable(pbTable,sec);

    otlGlyphID glyph = getOtlGlyphInfo(pliGlyphInfo, iglIndex)->glyph;
    short index = cursiPos.coverage(sec).getIndex(glyph,sec);
    if (index < 0)
    {
        return OTL_NOMATCH;
    }

    if (index >= cursiPos.entryExitCount())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }

    // get GDEF
    otlSecurityData secgdef;
    const BYTE *pbgdef;
    resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
    otlGDefHeader gdef = 
        otlGDefHeader(pbgdef,secgdef);

    if ((grfLookupFlags & otlRightToLeft) == 0)
    {

        short iglPrev = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, secgdef, 
                                          iglIndex - 1, otlBackward);
        if (iglPrev < 0)
        {
            return OTL_NOMATCH;
        }

        otlGlyphID glPrev = getOtlGlyphInfo(pliGlyphInfo, iglPrev)->glyph;
        short indexPrev = cursiPos.coverage(sec).getIndex(glPrev,sec);
        if (indexPrev < 0)
        {
            return OTL_NOMATCH;
        }

        if (indexPrev >= cursiPos.entryExitCount())
        {
            return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
        }


        otlAnchor anchorMain = cursiPos.entryAnchor(index,sec);
        otlAnchor anchorPrev = cursiPos.exitAnchor(indexPrev,sec);

        if (anchorMain.isNull() || anchorPrev.isNull())
        {
            return OTL_NOMATCH;
        }

        AlignAnchors(pliGlyphInfo, pliplcGlyphPlacement, pliduGlyphAdv, 
                     iglPrev, iglIndex, anchorPrev, anchorMain, resourceMgr, 
                     metr, otlUseAdvances, sec);

        // taking care of cursive dependencies
        setPosDependency(pliGlyphInfo, iglIndex, iglPrev);


        *piglNextGlyph = iglIndex + 1;
        return OTL_SUCCESS;

    }

    else
    {
        short iglNext = NextGlyphInLookup(pliGlyphInfo, 
                                          grfLookupFlags, gdef, secgdef, 
                                          iglIndex + 1, otlForward);
        if (iglNext >= iglAfterLast)
        {
            return OTL_NOMATCH;
        }

        otlGlyphID glNext = getOtlGlyphInfo(pliGlyphInfo, iglNext)->glyph;
        short indexNext = cursiPos.coverage(sec).getIndex(glNext,sec);
        if (indexNext < 0)
        {
            return OTL_NOMATCH;
        }

        if (indexNext >= cursiPos.entryExitCount())
        {
            return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
        }


        otlAnchor anchorMain = cursiPos.exitAnchor(index,sec);
        otlAnchor anchorNext = cursiPos.entryAnchor(indexNext,sec);

        if (anchorMain.isNull() || anchorNext.isNull())
        {
            return OTL_NOMATCH;
        }

        otlPlacement plcBefore = *getOtlPlacement(pliplcGlyphPlacement, iglIndex);

        AlignAnchors(pliGlyphInfo, pliplcGlyphPlacement, pliduGlyphAdv, 
                     iglNext, iglIndex, anchorNext, anchorMain, resourceMgr, 
                     metr, otlUseAdvances, sec);

        
        // taking care of cursive dependencies:  
        // adjusting old ones, creating a new one
        AdjustCursiveDependents(pliGlyphInfo, pliplcGlyphPlacement, iglIndex, 
                               *getOtlPlacement(pliplcGlyphPlacement, iglIndex),
                                plcBefore);

        setPosDependency(pliGlyphInfo, iglNext, iglIndex);


        *piglNextGlyph = iglIndex + 1;
        return OTL_SUCCESS;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\coverage.h ===
/***********************************************************************
************************************************************************
*
*                    ********  COVERAGE.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of coverage tables.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetCoverageFormat = 0;

const OFFSET offsetGlyphCount = 2;
const OFFSET offsetGlyphArray = 4;
const SIZE   sizeGlyphCoverageTable=sizeUSHORT+sizeUSHORT;

class otlIndividualGlyphCoverageTable: public otlTable
{
public:

    otlIndividualGlyphCoverageTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeGlyphCoverageTable,offsetGlyphCount,sizeGlyphID,sec))
        {
            setInvalid();
            return;
        }

        assert(format() == 1);
    }
    
    USHORT format() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetCoverageFormat); 
    }

    USHORT glyphCount() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetGlyphCount);
    }

    otlGlyphID glyph(USHORT index) const
    {   
        assert(isValid());

        assert(index < glyphCount());
        return GlyphID(pbTable + offsetGlyphArray 
                               + index*sizeof(otlGlyphID)); 
    }

};

const OFFSET offsetRangeStart = 0;
const OFFSET offsetRangeEnd = 2;
const OFFSET offsetStartCoverageIndex = 4;

const SIZE   sizeRangeRecord=sizeGlyphID+sizeGlyphID+sizeUSHORT;

class otlRangeRecord: public otlTable
{
public:

    otlRangeRecord(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTable(pb,sizeRangeRecord,sec)) 
        {
            assert(false); // should bechecked in CoverageTable
            setInvalid();
        }
    }

    otlGlyphID start() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetRangeStart); 
    }

    otlGlyphID end() const
    {   
        assert(isValid());
                          
        return UShort(pbTable + offsetRangeEnd); 
    }

    USHORT startCoverageIndex() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetStartCoverageIndex); 
    }
};



const OFFSET offsetRangeCount = 2;
const OFFSET offsetRangeRecordArray = 4;

const SIZE   sizeRangeCoverageTable = sizeUSHORT + sizeUSHORT;

class otlRangeCoverageTable: public otlTable
{
public:

    otlRangeCoverageTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeRangeCoverageTable,
                                        offsetRangeCount,sizeRangeRecord,sec))
        {
            setInvalid();
            return;
        }
        
        assert(format() == 2);
    }
    
    USHORT format() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetCoverageFormat); 
    }

    USHORT rangeCount() const
    {   
        assert(isValid());

        return UShort(pbTable + offsetRangeCount); 
    }

    otlRangeRecord rangeRecord(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid());

        assert(index < rangeCount());
        return otlRangeRecord(pbTable + offsetRangeRecordArray 
                                            + index*sizeRangeRecord,sec); 
    }
};


class otlCoverage: public otlTable
{
public:

    otlCoverage(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTable(pb,sizeUSHORT,sec)) setInvalid(); //format field only
    }

    USHORT format() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetCoverageFormat); 
    }

    // returns -1 if glyph is not covered
    short getIndex(otlGlyphID glyph, otlSecurityData sec) const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\device.h ===
/***********************************************************************
************************************************************************
*
*                    ********  DEVICE.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL device table formats.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetStartSize = 0;
const OFFSET offsetEndSize = 2;
const OFFSET offsetDeltaFormat = 4;
const OFFSET offsetDeltaValues = 6;

class otlDeviceTable: public otlTable
{
private:

    USHORT startSize() const
    {   
        assert(isValid());
        return UShort(pbTable + offsetStartSize); 
    }

    USHORT endSize() const
    {   
        assert(isValid());
        return UShort(pbTable + offsetEndSize); 
    }

    USHORT deltaFormat() const
    {   
        assert(isValid());
        return UShort(pbTable + offsetDeltaFormat); 
    }

    USHORT* deltaValueArray() const
    {   
        assert(isValid());
        return (USHORT*)(pbTable + offsetDeltaValues); 
    }

public:

    otlDeviceTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!pb) return; //DeviceTable could be ebsent, provide default behavior
        
        if (!isValidTable(pbTable,3*sizeUSHORT,sec)) setInvalid();

        //Required number of elements in delta array
        USHORT uArraySize = (endSize()-startSize()-1)/(16>>deltaFormat())+1;
        if (!isValidTable(pb,3*sizeUSHORT+uArraySize*sizeUSHORT,sec)) setInvalid();
    }

    long value(USHORT cPPEm) const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\device.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  DEVICE.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of device tables.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/
 
long otlDeviceTable::value(USHORT cPPEm) const
{
    if (!isValid()) return 0;
    
    long lDeltaValue;

    USHORT cppemStartSize = startSize();
    USHORT cppemEndSize = endSize();
    if ((cPPEm < cppemStartSize) || (cPPEm > cppemEndSize))
    {
        return 0;       /* quick return if outside the data range */
    }

    USHORT iSizeIndex = cPPEm - cppemStartSize;
    USHORT cwValueOffset, cbitShiftUp, cbitShiftDown;

    USHORT grfDeltaFormat = deltaFormat();

    switch (grfDeltaFormat)
    {
    case 1:             /* signed 2 bit value */
        {
            cwValueOffset = iSizeIndex >> 3;
            cbitShiftUp = (8 + (iSizeIndex & 0x0007)) << 1;
            cbitShiftDown = 30;
            break;
        }

    case 2:             /* signed 4 bit value */
        {
            cwValueOffset = iSizeIndex >> 2;
            cbitShiftUp = (4 + (iSizeIndex & 0x0003)) << 2;
            cbitShiftDown = 28;
            break;
        }

    case 3:             /* signed 8 bit value */
        {
            cwValueOffset = iSizeIndex >> 1;
            cbitShiftUp = (2 + (iSizeIndex & 0x0001)) << 3;
            cbitShiftDown = 24;
            break;
        }
    
    default:            /* unrecognized format */
        return 0; //OTL_BAD_FONT_TABLE
    }
    
    lDeltaValue = (long)UShort((BYTE*)(deltaValueArray() + cwValueOffset));
    lDeltaValue <<= cbitShiftUp;          /* erase leading data */
    lDeltaValue >>= cbitShiftDown;        /* erase trailing data & sign extend */
    
    return lDeltaValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\extension.h ===
/***********************************************************************
************************************************************************
*
*                    ********  EXTENSION.H  ********
*
*              Open Type Layout Services Library Header File
*
*               This module deals with Extension lookup type.
*
*               Copyright 1997 - 2000. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetExtensionLookupType = 2;
const OFFSET offsetExtensionOffset     = 4;


class otlExtensionLookup: public otlLookupFormat
{
public:
    otlExtensionLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec) {}

    USHORT extensionLookupType() const
    {   return UShort(pbTable + offsetExtensionLookupType); }

    otlLookupFormat extensionSubTable(otlSecurityData sec) const
    {   return otlLookupFormat(pbTable + ULong(pbTable+offsetExtensionOffset),sec); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\features.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  FEATURES.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements OTL Library calls dealing with features
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/



otlErrCode GetScriptFeatureLookupLists
(
    otlTag                  tagTable,
    otlResourceMgr&         resourceMgr, 

    otlScriptListTable*     pScriptList,
    otlFeatureListTable*    pFeatureList,
    otlLookupListTable*     pLookupList,
    otlSecurityData*        psec
)   
{
    const BYTE* pbTable;
    otlSecurityData sec;
    
    // script list in GPOS
    if (tagTable == OTL_GSUB_TAG)
    {
        resourceMgr.getOtlTable(OTL_GSUB_TAG,&pbTable,&sec);
        if (pbTable==(const BYTE*)NULL) return OTL_ERR_TABLE_NOT_FOUND;
        
        otlGSubHeader gsub = otlGSubHeader(pbTable, sec);
        if (!gsub.isValid()) return OTL_ERR_BAD_FONT_TABLE;

        if (pScriptList != NULL)
        {
            *pScriptList = gsub.scriptList(sec);
            if (!pScriptList->isValid()) return OTL_ERR_BAD_FONT_TABLE;
        }

        if (pFeatureList != NULL)
        {
            *pFeatureList = gsub.featureList(sec);
            if (!pFeatureList->isValid()) return OTL_ERR_BAD_FONT_TABLE;
        }

        if (pLookupList != NULL)
        {
            *pLookupList = gsub.lookupList(sec);
            if (!pLookupList->isValid()) return OTL_ERR_BAD_FONT_TABLE;
        }

        if (psec != NULL)
        {
            *psec = sec;
        }
        
        return OTL_SUCCESS;
    }

    // script list in GSUB
    else if (tagTable == OTL_GPOS_TAG)
    {
        resourceMgr.getOtlTable(OTL_GPOS_TAG,&pbTable,&sec);
        if (pbTable==(const BYTE*)NULL) return OTL_ERR_TABLE_NOT_FOUND;

        otlGPosHeader gpos = otlGPosHeader(pbTable, sec);
        if (!gpos.isValid()) return OTL_ERR_BAD_FONT_TABLE;

        if (pScriptList != NULL)
        {
            *pScriptList = gpos.scriptList(sec);
            if (!pScriptList->isValid()) return OTL_ERR_BAD_FONT_TABLE;
        }

        if (pFeatureList != NULL)
        {
            *pFeatureList = gpos.featureList(sec);
            if (!pFeatureList->isValid()) return OTL_ERR_BAD_FONT_TABLE;
        }

        if (pLookupList != NULL)
        {
            *pLookupList = gpos.lookupList(sec);
            if (!pLookupList->isValid()) return OTL_ERR_BAD_FONT_TABLE;
        }

        if (psec != NULL)
        {
            *psec = sec;
        }
 
        return OTL_SUCCESS;
    }

    // this should not happen -- still return something
    assert(false);
    return OTL_ERR_BAD_INPUT_PARAM;
}


void AddFeatureDetails
(
    otlTag                  tagTable,
    const otlFeatureRecord& featureRecord,
    otlFeatureDef*          pfdef
)
{
    assert(featureRecord.isValid()); //should exit before calling
    
    // these are the details we support so far
    // TODO: add more feature details
    if (tagTable == OTL_GSUB_TAG)
    {
        pfdef->grfDetails |= OTL_FEAT_FLAG_GSUB;
    }
    else if (tagTable == OTL_GPOS_TAG)
    {
        pfdef->grfDetails |= OTL_FEAT_FLAG_GPOS;
    }

}


otlErrCode AppendFeatureDefs
(
    otlTag                      tagTable,
    otlResourceMgr&             resourceMgr,

    const otlScriptListTable&   scriptList,
    otlTag                      tagScript,
    otlTag                      tagLangSys,

    const otlFeatureListTable&  featureList, 
    otlList*                    pliFDefs, 

    otlSecurityData sec
)
{
    assert(pliFDefs->dataSize() == sizeof(otlFeatureDef));
    assert(pliFDefs->length() <= pliFDefs->maxLength());
    assert(tagTable == OTL_GSUB_TAG || tagTable == OTL_GPOS_TAG);

    // get the number of features that are already recorded
    USHORT cPrevFeatures = pliFDefs->length();
    otlErrCode erc = OTL_SUCCESS;
                                                          
    otlScriptTable scriptTable = FindScript(scriptList, tagScript, sec);
    if (!scriptTable.isValid()) return OTL_ERR_SCRIPT_NOT_FOUND;
    
    if (scriptTable.isNull())
    {
        return OTL_ERR_SCRIPT_NOT_FOUND;
    }

    otlLangSysTable langSysTable = FindLangSys(scriptTable, tagLangSys, sec);
    if (!langSysTable.isValid()) return OTL_ERR_LANGSYS_NOT_FOUND;

    if (langSysTable.isNull())
    {
        return OTL_ERR_LANGSYS_NOT_FOUND;
    }

    // now, start filling in feature descriptors
    USHORT cFCount = langSysTable.featureCount();

    for (USHORT iFeature = 0; iFeature < cFCount; ++iFeature)
    {
        otlFeatureRecord featureRecord = 
            featureList.featureRecord(langSysTable.featureIndex(iFeature), sec);
        if (!featureRecord.isValid()) continue;

        otlTag tagFeature = featureRecord.featureTag();

        bool fFeatureFound = FALSE;
        for (USHORT iPrevFeature = 0; 
                    iPrevFeature < cPrevFeatures && !fFeatureFound;
                    ++iPrevFeature)
        {
            otlFeatureDef* pFDef = 
                getOtlFeatureDef(pliFDefs, iPrevFeature);
                        
            if (pFDef->tagFeature == tagFeature)
            {
                AddFeatureDetails(tagTable, featureRecord, pFDef);
                fFeatureFound = true;
            }
        }

        if (!fFeatureFound)
        {
            // make sure we have enough space
            if (pliFDefs->length() + 1 > pliFDefs->maxLength())
            {
                erc = resourceMgr.reallocOtlList(pliFDefs, 
                                                 pliFDefs->dataSize(), 
                                                 pliFDefs->maxLength() + 1, 
                                                 otlPreserveContent);

                if (erc != OTL_SUCCESS) return erc;
            }

            otlFeatureDef fdefNew;
            fdefNew.tagFeature = featureRecord.featureTag();

            fdefNew.grfDetails = 0;
            AddFeatureDetails(tagTable, featureRecord, &fdefNew);

            pliFDefs->append((const BYTE*)&fdefNew);
        }
    }

    return OTL_SUCCESS;
}

otlFeatureTable FindFeature
(
    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,
    otlTag                      tagFeature, 

    otlSecurityData sec
)
{
    assert(!langSysTable.isNull());
    assert(!featureList.isNull());


    USHORT cFeatures = langSysTable.featureCount();

    for (USHORT iFeature = 0; iFeature < cFeatures; ++iFeature)
    {
        USHORT index = langSysTable.featureIndex(iFeature);

        assert(index < featureList.featureCount());
        // but still do not fail on a bad font
        if (index >= featureList.featureCount()) continue;
            
        otlFeatureRecord featureRecord = featureList.featureRecord(index, sec);
        if (featureRecord.featureTag() == tagFeature)
        {
            return featureRecord.featureTable(sec);
        }
    }

    // not found
    return otlFeatureTable((const BYTE*) NULL, sec);
}

otlFeatureTable RequiredFeature
(
    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList, 

    otlSecurityData sec
)
{
    USHORT reqIndex = langSysTable.reqFeatureIndex();
    if (reqIndex == 0xFFFF)
    {
        return otlFeatureTable((BYTE*)NULL, sec);
    }

    if (reqIndex >= featureList.featureCount())
    {
        return otlFeatureTable((BYTE*)NULL, sec); //OTL_BAD_FONT_TABLE
    }

    return featureList.featureRecord(reqIndex, sec).featureTable(sec);
}

bool EnablesFull
(
    const otlFeatureTable&      featureTable,
    USHORT                      iLookup
)
{
    // invalid feature tags do nothing
    if (featureTable.isNull())
    {
        return false;
    }

    USHORT cLookups = featureTable.lookupCount();

    for (USHORT i = 0; i < cLookups; ++i)
    {
        if (featureTable.lookupIndex(i) == iLookup)
        {
            return true;
        }
    }

    return false;
}


//Functions to get Enables functionality from cache

bool otlEnablesCache::Allocate( otlResourceMgr& resourceMgr, USHORT cLookups)
{
    const USHORT MaxECacheSize =8192;

    if ((cBitsPerLookup*cLookups) > (cbSize*8) )
    {
        USHORT cbNewSize = MIN(((cBitsPerLookup*cLookups-1)>>3)+1,
                             MaxECacheSize);

        BYTE* pbNewBuf = resourceMgr.getEnablesCacheBuf(cbNewSize);
        if (pbNewBuf) 
        {
            pbData = pbNewBuf;
            cbSize  = cbNewSize;
        }
        else
        {
            cbNewSize=resourceMgr.getEnablesCacheBufSize();
            if (cbNewSize>cbSize)
            {
                pbNewBuf=resourceMgr.getEnablesCacheBuf(cbNewSize);
                if (pbNewBuf) pbData=pbNewBuf;
                cbSize=cbNewSize;
            }

            if ((cbSize*8) < cBitsPerLookup)
            {
                pbData = (BYTE*)NULL;
                cbSize = 0;
                return false; //We can work only with EnablesFull function
            }
        }
    }

    cLookupsPerCache = (cbSize*8)/cBitsPerLookup;
    return true;
}

void otlEnablesCache::ClearFlags()
{
    if (!IsActive()) return;

    memset(pbData,0,cbSize);
}

void otlEnablesCache::Refresh(
    const otlFeatureTable& featureTable,
    USHORT iFlagNum
)
{
    if (!IsActive()) return;

    if (featureTable.isNull()) return;

    for(USHORT i=0; i<featureTable.lookupCount(); i++)
    {
        USHORT iLookup = featureTable.lookupIndex(i),
               LookupStartBit=(iLookup-iLookupFirst)*cBitsPerLookup;

        if (iLookup >= iLookupFirst && 
            iLookup <  iLookupAfter)
        {
            BIT_SET(pbData,LookupStartBit+iFlagNum);
            BIT_SET(pbData,LookupStartBit+AggregateFlagIndex()); //Flag for whole lookup
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\cursipos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  CURSIPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with cursive attachment lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetEntryAnchor = 0;
const OFFSET offsetExitAnchor = 2;

const OFFSET offsetCursiveCoverage = 2;
const OFFSET offsetEntryExitCount = 4;
const OFFSET offsetEntryExitRecordArray = 6;
const USHORT sizeEntryExitRecord = 8;

class otlCursivePosSubTable: public otlLookupFormat
{
public:
    otlCursivePosSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        assert(format() == 1);
    }

    otlCoverage coverage(otlSecurityData sec)
    {   return otlCoverage(pbTable + Offset(pbTable + offsetCursiveCoverage),sec); }

    USHORT entryExitCount()
    {   return UShort(pbTable + offsetEntryExitCount); }

    otlAnchor entryAnchor(USHORT index, otlSecurityData sec)
    {   
        assert(index < entryExitCount());
        OFFSET offset = Offset(pbTable + offsetEntryExitRecordArray
                                       + index * (sizeof(OFFSET) + sizeof(OFFSET))
                                       + offsetEntryAnchor);
        if (offset == 0)
            return otlAnchor((const BYTE*)NULL,sec);
        
        return otlAnchor(pbTable + offset,sec); 
    }

    otlAnchor exitAnchor(USHORT index, otlSecurityData sec)
    {   
        assert(index < entryExitCount());
        OFFSET offset = Offset(pbTable + offsetEntryExitRecordArray
                                       + index * (sizeof(OFFSET) + sizeof(OFFSET))
                                       + offsetExitAnchor);
        if (offset == 0)
            return otlAnchor((const BYTE*)NULL,sec);
        
        return otlAnchor(pbTable + offset,sec); 
    }
};


class otlCursivePosLookup: public otlLookupFormat
{
public:
    otlCursivePosLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec) 
    {
        assert(isValid());
    }

    otlErrCode apply
    (
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        USHORT                      grfLookupFlags,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph
    
        otlSecurityData             sec
);                                              // return: did/did not apply

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\gdef.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  GDEF.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements helper functions dealing with gdef processing
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

long otlCaret::value
(
    const otlMetrics&   metr,       
    otlPlacement*       rgPointCoords,  // may be NULL

    otlSecurityData     sec
) const
{
    assert(!isNull());

    switch(format())
    {
    case(1):    // design units only
        {
            otlSimpleCaretValueTable simpleCaret = 
                        otlSimpleCaretValueTable(pbTable,sec);
            if (metr.layout == otlRunLTR || 
                metr.layout == otlRunRTL)
            {
                return DesignToPP(metr.cFUnits, metr.cPPEmX, 
                                 (long)simpleCaret.coordinate());
            }
            else
            {
                return DesignToPP(metr.cFUnits, metr.cPPEmY, 
                                 (long)simpleCaret.coordinate());
            }
        }

    case(2):    // contour point
        {
            otlContourCaretValueTable contourCaret = 
                        otlContourCaretValueTable(pbTable,sec);
            if (rgPointCoords != NULL)
            {
                USHORT iPoint = contourCaret.caretValuePoint();

                if (metr.layout == otlRunLTR || 
                    metr.layout == otlRunRTL)
                {
                    return rgPointCoords[iPoint].dx;
                }
                else
                {
                    return rgPointCoords[iPoint].dy;
                }
            }
            else
                return (long)0;
        }
    
    case(3):    // design units plus device table
        {
            otlDeviceCaretValueTable deviceCaret = 
                        otlDeviceCaretValueTable(pbTable,sec);
            otlDeviceTable deviceTable = deviceCaret.deviceTable(sec);
            if (metr.layout == otlRunLTR || 
                metr.layout == otlRunRTL)
            {
                return DesignToPP(metr.cFUnits, metr.cPPEmX, 
                                 (long)deviceCaret.coordinate()) +
                                        deviceTable.value(metr.cPPEmX);
            }
            else
            {
                return DesignToPP(metr.cFUnits, metr.cPPEmY, 
                                 (long)deviceCaret.coordinate()) +
                                        deviceTable.value(metr.cPPEmY);
            }
        }
    
    default:    // invalid format
        return (0); //OTL_BAD_FONT_TABLE
    }
        
}


otlErrCode AssignGlyphTypes
(
    otlList*                pliGlyphInfo,
    const otlGDefHeader&    gdef,
    otlSecurityData         secgdef,

    USHORT                  iglFirst,
    USHORT                  iglAfterLast,
    otlGlyphTypeOptions     grfOptions          

)
{
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(iglFirst < iglAfterLast);
    assert(iglAfterLast <= pliGlyphInfo->length());

    // if no gdef, glyphs types stay unassigned forever
    if(gdef.isNull()) return OTL_SUCCESS;

    otlClassDef glyphClassDef = gdef.glyphClassDef(secgdef);

    for (USHORT iGlyph = iglFirst; iGlyph < iglAfterLast; ++iGlyph)
    {
        otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iGlyph);

        if (!glyphClassDef.isValid())
        {
            
        }

        if ((grfOptions & otlDoAll) ||
            (pGlyphInfo->grf & OTL_GFLAG_CLASS) == otlUnresolved ||
            //we process otlUnassigned just for backward compatibility
            (pGlyphInfo->grf & OTL_GFLAG_CLASS) == otlUnassigned) 
        {
            if (glyphClassDef.isValid()) //seccheck
            {
                pGlyphInfo->grf &= ~OTL_GFLAG_CLASS;
                pGlyphInfo->grf |= glyphClassDef.getClass(pGlyphInfo->glyph,secgdef);
            }
            else
            {
                pGlyphInfo->grf &= ~OTL_GFLAG_CLASS;
                pGlyphInfo->grf |= otlUnassigned;
            }
            
        }
    }

    return OTL_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\features.h ===
/***********************************************************************
************************************************************************
*
*                    ********  FEATURES.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of feature lists and tables.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetFeatureParams = 0;
const OFFSET offsetFeatureLookupCount = 2;
const OFFSET offsetFeatureLookupListIndexArray = 4;

const SIZE sizeFeatureTable = sizeOFFSET + sizeUSHORT;

class otlFeatureTable: public otlTable
{
public:

    otlFeatureTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeFeatureTable,offsetFeatureLookupCount,sizeUSHORT,sec))
            setInvalid();
    }

    OFFSET featureParamsOffset() const
    {   
        assert(isValid()); //should break before calling
            
        return Offset(pbTable + offsetFeatureParams); 
    }

    USHORT lookupCount() const
    {
        if (!isValid()) return 0;
        
        return UShort(pbTable + offsetFeatureLookupCount); 
    }

    USHORT lookupIndex(USHORT index) const
    {   
        assert(isValid()); //should break before calling

        assert(index < lookupCount());
        return UShort(pbTable + offsetFeatureLookupListIndexArray
                              + index*sizeof(USHORT)); 
    }
};


const OFFSET offsetFeatureTag = 0;
const OFFSET offsetFeature = 4;
const SIZE   sizeFeatureRecord = sizeTAG + sizeOFFSET;

class otlFeatureRecord: public otlTable
{

private:
    const BYTE*   pbMainTable;

public:
    otlFeatureRecord(const BYTE* pbList, const BYTE* pbRecord, otlSecurityData sec)
        : otlTable(pbRecord,sec),
          pbMainTable(pbList)
    {
        assert(isValidTable(pbRecord,sizeFeatureRecord,sec)); //should be checked at FeatureList
    }

    otlFeatureRecord& operator = (const otlFeatureRecord& copy)
    {
        assert(isValid()); //should break in FeatureList
        
        pbTable = copy.pbTable;
        pbMainTable = copy.pbMainTable;
        return *this;
    }


    otlTag featureTag() const
    {   
        assert(isValid()); //should break in FeatureList

        return *(UNALIGNED otlTag*)(pbTable + offsetFeatureTag); 
    }

    otlFeatureTable featureTable(otlSecurityData sec) const
    {   
        assert(isValid()); //should break in FeatureList

        return otlFeatureTable(pbMainTable + Offset(pbTable + offsetFeature), sec);
    }

};


const OFFSET offsetFeatureCount = 0;
const OFFSET offsetFeatureRecordArray = 2;
const SIZE sizeFeatureListTable = sizeUSHORT;

class otlFeatureListTable: public otlTable
{
public:

    otlFeatureListTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeFeatureTable,offsetFeatureCount,sizeFeatureRecord,sec))
            setInvalid();
    }

    USHORT featureCount() const
    {   
        assert(isValid()); //should break before calling
        
        return UShort(pbTable + offsetFeatureCount); 
    }

    otlFeatureRecord featureRecord(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid()); //list should be valid, but if index is incorrect...
        if (index>=featureCount()) return otlFeatureRecord(pbTable,pbInvalidData,sec);

        return otlFeatureRecord(pbTable,
                 pbTable + offsetFeatureRecordArray
                         + index*sizeFeatureRecord, sec);
    }
};


// helper functions

// get script, feature and lookup list tables from either gpos or gsub
// (gets the tables form the client)
// if GetScriptFeatureLookupLists succeeds, tagTable needs to be freed
otlErrCode GetScriptFeatureLookupLists
(
    otlTag                  tagTable,
    otlResourceMgr&         resourceMgr,

    otlScriptListTable*     pScriptList,
    otlFeatureListTable*    pFeatureList,
    otlLookupListTable*     pLookupList,

    otlSecurityData*        psec
);

// get feature definitions
otlErrCode AppendFeatureDefs
(
    otlTag                      tagTable,
    otlResourceMgr&             resourceMgr,

    const otlScriptListTable&   scriptList,
    otlTag                      tagScript,
    otlTag                      tagLangSys,

    const otlFeatureListTable&  featureList,

    otlList*                    pliFDefs,

    otlSecurityData sec
);

// returns a NULL feature if feature not found
otlFeatureTable FindFeature
(
    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,
    otlTag                      tagFeature,

    otlSecurityData sec
);

otlFeatureTable RequiredFeature
(
    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,

    otlSecurityData sec
);

bool EnablesFull
(
    const otlFeatureTable&      featureTable,
    USHORT                      iLookup
);

#define BIT_SET(C,i)      ( (C)[(i)>>3] |= ( 1 << ((i)&7) ) )
#define IS_BIT_SET(C,i) ( ( (C)[(i)>>3] &  ( 1 << ((i)&7) ) ) != 0)

class otlEnablesCache {

private:
    BYTE*  pbData;
    USHORT cbSize;
    USHORT cLookupsPerCache;
    USHORT cBitsPerLookup;
    USHORT iLookupFirst;
    USHORT iLookupAfter;

public:
    otlEnablesCache(USHORT cFeatures, BYTE* pb, USHORT cbS) 
        :pbData(pb), 
     cbSize(cbS), 
         cBitsPerLookup(cFeatures+2), //+1 Required feature, +1 AggregateFlag
         cLookupsPerCache(0), iLookupFirst(0), iLookupAfter(0) {};

    bool IsActive( ) const { return (pbData!=NULL); }
    bool InCache(USHORT iLookup) const 
            { return (iLookup>=iLookupFirst && iLookup<iLookupAfter); }
    
    bool Allocate( otlResourceMgr& resourceMgr, USHORT cLookups);
    void Reset() { iLookupAfter = iLookupFirst; };
    void ClearFlags();
    void SetFirst(USHORT iLookup) 
            {iLookupFirst=iLookup; iLookupAfter=iLookup+cLookupsPerCache;}
    void Refresh(const otlFeatureTable& featureTable, USHORT iFeatureIndex);
    bool Check(USHORT iFlagIndex, USHORT iLookup) const 
          { return IS_BIT_SET(pbData,
                              (iLookup-iLookupFirst)*cBitsPerLookup+iFlagIndex
                             );
          }
    USHORT RequiredFeatureFlagIndex() const { return (cBitsPerLookup-2); }
    USHORT AggregateFlagIndex() const { return (cBitsPerLookup-1); }
};

inline bool Enables(
    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,
    const otlFeatureDesc*       pFDesc,

    USHORT                      iLookup,
 
    USHORT                      iFeatureIndex,
    const otlEnablesCache&      ec,

    otlSecurityData             sec
)
{
    if (ec.IsActive()) return ec.Check(iFeatureIndex,iLookup);
    return EnablesFull(FindFeature(langSysTable, featureList,pFDesc->tagFeature,sec),iLookup);
}

inline bool EnablesRequired(
    const otlLangSysTable&      langSysTable,
    const otlFeatureListTable&  featureList,

    USHORT                      iLookup,
 
    const otlEnablesCache&      ec,

    otlSecurityData             sec
)
{
    if (ec.IsActive()) return ec.Check(ec.RequiredFeatureFlagIndex(),iLookup);
    return EnablesFull(RequiredFeature(langSysTable, featureList, sec),iLookup);
}


inline bool EnablesSomewhere(
    USHORT                  iLookup,
    const otlEnablesCache&  ec
)
{
    if (ec.IsActive()) return  ec.Check(ec.AggregateFlagIndex(),iLookup);
    return true; //Cache doesn't work, we need to check each feature separately
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\gdef.h ===
/***********************************************************************
************************************************************************
*
*                    ********  GDEF.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL GDEF table.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/


const OFFSET offsetPointCount = 0;
const OFFSET offsetPointIndexArray = 2;
const USHORT sizeAttachPoint = 4;

class otlAttachPointTable: public otlTable
{
public:

    otlAttachPointTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTable(pb,sizeAttachPoint,sec)) setInvalid();
    }

    USHORT pointCount() const
    {   
        return UShort(pbTable + offsetPointCount); 
    }

    USHORT pointIndex(USHORT index) const
    {   assert(index < pointCount());
        return UShort(pbTable + offsetPointIndexArray + index*sizeof(USHORT)); }
};


const OFFSET offsetCoverage = 0;
const OFFSET offsetAttachGlyphCount = 2;
const OFFSET offsetAttachPointTableArray = 4;

class otlAttachListTable: public otlTable
{
public:

    otlAttachListTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    otlCoverage coverage(otlSecurityData sec) const
    {   return otlCoverage(pbTable + Offset(pbTable + offsetCoverage), sec); }

    USHORT glyphCount() const
    {   return UShort(pbTable + offsetAttachGlyphCount); }

    otlAttachPointTable attachPointTable(USHORT index, otlSecurityData sec) const
    {   assert(index < glyphCount());
        return otlAttachPointTable(pbTable 
                + Offset(pbTable + offsetAttachPointTableArray 
                                 + index*sizeof(OFFSET)), sec); 
    }
};


const OFFSET offsetCaretValueFormat = 0;

const OFFSET offsetSimpleCaretCoordinate = 2;

class otlSimpleCaretValueTable: public otlTable
{
public:

    otlSimpleCaretValueTable(const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec)
    {
        assert(UShort(pbTable + offsetCaretValueFormat) == 1);
    }

    short coordinate() const
    {   return SShort(pbTable + offsetSimpleCaretCoordinate); }

};


const OFFSET offsetCaretValuePoint = 2;

class otlContourCaretValueTable: public otlTable
{
public:

    otlContourCaretValueTable(const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec)
    {
        assert(UShort(pbTable + offsetCaretValueFormat) == 2);
    }

    USHORT caretValuePoint() const
    {   return UShort(pbTable + offsetCaretValuePoint); }

};


const OFFSET offsetDeviceCaretCoordinate = 2;
const OFFSET offsetCaretDeviceTable = 4;

class otlDeviceCaretValueTable: public otlTable
{
public:

    otlDeviceCaretValueTable(const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec)
    {
        assert(UShort(pbTable + offsetCaretValueFormat) == 3);
    }

    short coordinate() const
    {   return SShort(pbTable + offsetDeviceCaretCoordinate); }


    otlDeviceTable deviceTable(otlSecurityData sec) const
    {   return otlDeviceTable(pbTable 
                    + Offset(pbTable + offsetCaretDeviceTable), sec); 
    }
};



class otlCaret: public otlTable
{
public:

    otlCaret(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    USHORT format() const
    {   return UShort(pbTable + offsetCaretValueFormat); }

    long value
    (
        const otlMetrics&   metr,       
        otlPlacement*       rgPointCoords,  // may be NULL
        otlSecurityData sec
    ) const;
};


const OFFSET offsetCaretCount = 0;
const OFFSET offsetCaretValueArray = 2;

class otlLigGlyphTable: public otlTable
{
public:

    otlLigGlyphTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    USHORT caretCount() const
    {   return UShort(pbTable + offsetCaretCount); }

    otlCaret caret(USHORT index, otlSecurityData sec) const
    {   assert(index < caretCount());
        return otlCaret(pbTable 
                + Offset(pbTable + offsetCaretValueArray 
                                 + index*sizeof(OFFSET)), sec); 
    }
};



const OFFSET offsetLigGlyphCoverage = 0;
const OFFSET offsetLigGlyphCount = 2;
const OFFSET offsetLigGlyphTableArray = 4;

class otlLigCaretListTable: public otlTable
{
public:

    otlLigCaretListTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    otlCoverage coverage(otlSecurityData sec) const
    {   return otlCoverage(pbTable + Offset(pbTable + offsetLigGlyphCoverage), sec); }

    USHORT ligGlyphCount() const
    {   return UShort(pbTable + offsetLigGlyphCount); }

    otlLigGlyphTable ligGlyphTable(USHORT index, otlSecurityData sec) const
    {   assert(index < ligGlyphCount());
        return otlLigGlyphTable(pbTable 
                + Offset(pbTable + offsetLigGlyphTableArray 
                                 + index*sizeof(OFFSET)), sec); 
    }
};


const OFFSET offsetGDefVersion = 0;
const OFFSET offsetGlyphClassDef = 4;
const OFFSET offsetAttachList = 6;
const OFFSET offsetLigCaretList = 8;
const OFFSET offsetAttachClassDef = 10;
const USHORT sizeGDefHeader = sizeFIXED + 4*sizeOFFSET;

class otlGDefHeader: public otlTable
{
public:

    otlGDefHeader(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTable(pbTable,sizeGDefHeader,sec)) setInvalid();
    }

    ULONG version() const
    {   
        assert(isValid()); //should return error before calling

        return ULong(pbTable + offsetGDefVersion); 
    }

    otlClassDef glyphClassDef(otlSecurityData sec) const
    {   
        if (!isValid()) return otlClassDef(pbInvalidData,sec);

        return otlClassDef(pbTable + Offset(pbTable + offsetGlyphClassDef), sec); 
    }

    otlAttachListTable attachList(otlSecurityData sec) const
    {   
        
        assert(isValid()); //should return error before calling

        if (Offset(pbTable + offsetAttachList) == 0) 
               return otlAttachListTable((const BYTE*)NULL, sec);
        return otlAttachListTable(pbTable + Offset(pbTable + offsetAttachList), sec); 
    }

    otlLigCaretListTable ligCaretList(otlSecurityData sec) const
    {   
        
        assert(isValid()); //should return error before calling

        if (Offset(pbTable + offsetLigCaretList) == 0)
               return otlLigCaretListTable((const BYTE*)NULL, sec);
        return otlLigCaretListTable(pbTable 
                    + Offset(pbTable + offsetLigCaretList), sec); 
    }

    otlClassDef attachClassDef(otlSecurityData sec) const
    {   
        if (!isValid()) return otlClassDef(pbInvalidData,sec);

        return otlClassDef(pbTable + Offset(pbTable + offsetAttachClassDef), sec); 
    }

};


// helper functions
enum otlGlyphTypeOptions
{
    otlDoUnresolved     =   0,
    otlDoAll            =   1
};

otlErrCode AssignGlyphTypes
(
    otlList*                pliGlyphInfo,
    const otlGDefHeader&    gdef,
    otlSecurityData         secgdef,
    
    USHORT                  iglFirst,
    USHORT                  iglAfterLast,
    otlGlyphTypeOptions     grfOptions          
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\gpos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  GPOS.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements helper functions calls dealing with gpos 
*       processing
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"


/***********************************************************************/

long DesignToPP
(
    USHORT          cFUnits,        // font design units per Em 
    USHORT          cPPEm,          // pixels per Em

    long            lFValue         // value to convert, in design units
)
{
    long lHalf;
    long lNegHalf;
    long lCorrect;

    lHalf = (long)cFUnits >> 1;
    lNegHalf = -lHalf + 1;         /* ensures the same rounding as a shift */

    if (lFValue >= 0)
    {
        lCorrect = lHalf;
    }
    else
    {
        lCorrect = lNegHalf;
    }

    //division by zero: Division by zero, do nothing
    if (cFUnits==0) return lFValue;

    return (lFValue * (long)cPPEm + lCorrect) / (long)cFUnits;
}

void otlValueRecord::adjustPos
(
    const otlMetrics&   metr,       
    otlPlacement*       pplcGlyphPalcement, // in/out
    long*               pduDAdvance,        // in/out
    otlSecurityData     sec
) const
{
    /*seccheck*/
    if (!isValid()) return;

    assert(!isNull());
    assert(pplcGlyphPalcement != NULL);
    assert(pduDAdvance != NULL);

    const BYTE* pbTableBrowser = pbTable;
    
    if (grfValueFormat & otlValueXPlacement)
    {
        pplcGlyphPalcement->dx += DesignToPP(metr.cFUnits, metr.cPPEmX, 
                                             SShort(pbTableBrowser));
        pbTableBrowser += 2;
    }
    if (grfValueFormat & otlValueYPlacement)
    {
        pplcGlyphPalcement->dy += DesignToPP(metr.cFUnits, metr.cPPEmY, 
                                             SShort(pbTableBrowser));
        pbTableBrowser += 2;
    }
    if (grfValueFormat & otlValueXAdvance)
    {
        if (metr.layout == otlRunLTR || 
            metr.layout == otlRunRTL)
        {
            *pduDAdvance += DesignToPP(metr.cFUnits, metr.cPPEmX, 
                                       SShort(pbTableBrowser));
        }
        pbTableBrowser += 2;
    }
    if (grfValueFormat & otlValueYAdvance)
    {
        if (metr.layout == otlRunTTB || 
            metr.layout == otlRunBTT)
        {
            *pduDAdvance += DesignToPP(metr.cFUnits, metr.cPPEmY, 
                                       SShort(pbTableBrowser));
        }
        pbTableBrowser += 2;
    }


    if (grfValueFormat & otlValueXPlaDevice)
    {
        if (Offset(pbTableBrowser) != 0) 
        {
            pplcGlyphPalcement->dx += 
                otlDeviceTable(pbMainTable + Offset(pbTableBrowser),sec)
                .value(metr.cPPEmX);
        }
        pbTableBrowser += 2;
    }
    if (grfValueFormat & otlValueYPlaDevice)
    {
        if (Offset(pbTableBrowser) != 0) 
        {
            pplcGlyphPalcement->dx += 
                otlDeviceTable(pbMainTable + Offset(pbTableBrowser),sec)
                .value(metr.cPPEmY);
        }
        pbTableBrowser += 2;
    }
    if (grfValueFormat & otlValueXAdvDevice)
    {
        if (metr.layout == otlRunLTR || 
            metr.layout == otlRunRTL)
        {
            if (Offset(pbTableBrowser) != 0) 
            {
                *pduDAdvance += 
                    otlDeviceTable(pbMainTable + Offset(pbTableBrowser),sec)
                    .value(metr.cPPEmX);
            }
        }
        pbTableBrowser += 2;
    }
    if (grfValueFormat & otlValueYAdvDevice)
    {
        if (metr.layout == otlRunTTB || 
            metr.layout == otlRunBTT)
        {
            if (Offset(pbTableBrowser) != 0) 
            {
                *pduDAdvance += 
                    otlDeviceTable(pbMainTable + Offset(pbTableBrowser),sec)
                    .value(metr.cPPEmY);
            }
        }
        pbTableBrowser += 2;
    }

    assert((pbTableBrowser-pbTable)==size(grfValueFormat));
        
    return;
}


bool otlAnchor::getAnchor
(
    USHORT          cFUnits,        // font design units per Em 
    USHORT          cPPEmX,         // horizontal pixels per Em 
    USHORT          cPPEmY,         // vertical pixels per Em 
    
    otlPlacement*   rgPointCoords,  // may be NULL if not available
            
    otlPlacement*   pplcAnchorPoint,    // out: anchor point in rendering units

    otlSecurityData sec
) const
{
    if (!isValid()) return false;
    
    assert(!isNull());
    assert(pplcAnchorPoint != NULL);

    switch(format())
    {
    case(1):    // design units only
        {
            otlSimpleAnchorTable simpleAnchor = otlSimpleAnchorTable(pbTable,sec);
            if (!simpleAnchor.isValid()) return false;

            pplcAnchorPoint->dx = DesignToPP(cFUnits, cPPEmX, 
                                             simpleAnchor.xCoordinate());
            pplcAnchorPoint->dy = DesignToPP(cFUnits, cPPEmY, 
                                             simpleAnchor.yCoordinate());
            return true;
        }

    case(2):    // design units plus contour point
        {
            otlContourAnchorTable contourAnchor = otlContourAnchorTable(pbTable,sec);
            if (!contourAnchor.isValid()) return false;

            if (rgPointCoords != NULL)
            {
                *pplcAnchorPoint = rgPointCoords[ contourAnchor.anchorPoint() ];
            }
            else
            {
                pplcAnchorPoint->dx = DesignToPP(cFUnits, cPPEmX, 
                                                 contourAnchor.xCoordinate());
                pplcAnchorPoint->dy = DesignToPP(cFUnits, cPPEmY, 
                                                 contourAnchor.yCoordinate());
            }

            return true;
        }

    case(3):    // design units plus device table
        {
            otlDeviceAnchorTable deviceAnchor = otlDeviceAnchorTable(pbTable,sec);
            if (!deviceAnchor.isValid()) return false;

            pplcAnchorPoint->dx = DesignToPP(cFUnits, cPPEmX, 
                                             deviceAnchor.xCoordinate());
            pplcAnchorPoint->dy = DesignToPP(cFUnits, cPPEmY, 
                                             deviceAnchor.yCoordinate());

            otlDeviceTable deviceX = deviceAnchor.xDeviceTable(sec);
            otlDeviceTable deviceY = deviceAnchor.yDeviceTable(sec);

            if (!deviceX.isNull())
            {
                pplcAnchorPoint->dx += deviceX.value(cPPEmX);
            }
            if (!deviceY.isNull())
            {
                pplcAnchorPoint->dy += deviceY.value(cPPEmY);
            }

            return true;
        }

    default:    // invalid anchor format
        return false; //OTL_BAD_FONT_TABLE
    }

}


void AlignAnchors
(
    const otlList*      pliGlyphInfo,   
    otlList*            pliPlacement,
    otlList*            pliduDAdv,

    USHORT              iglStatic,
    USHORT              iglMobile,

    const otlAnchor&    anchorStatic,
    const otlAnchor&    anchorMobile,

    otlResourceMgr&     resourceMgr, 

    const otlMetrics&   metr,       
    USHORT              grfOptions,
    
    otlSecurityData sec
)
{
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliPlacement->dataSize() == sizeof(otlPlacement));
    assert(pliduDAdv->dataSize() == sizeof(long));

    assert(pliGlyphInfo->length() == pliPlacement->length());
    assert(pliPlacement->length() == pliduDAdv->length());

    assert(iglStatic < pliGlyphInfo->length());
    assert(iglMobile < pliGlyphInfo->length());

    assert(!anchorStatic.isNull());
    assert(!anchorMobile.isNull());


    const otlGlyphInfo* pglinfStatic = 
        readOtlGlyphInfo(pliGlyphInfo, iglStatic);
    const otlGlyphInfo* pglinfMobile = 
        readOtlGlyphInfo(pliGlyphInfo, iglMobile);

    otlPlacement* pplcStatic = getOtlPlacement(pliPlacement, iglStatic);
    otlPlacement* pplcMobile = getOtlPlacement(pliPlacement, iglMobile);

    long* pduDAdvStatic = getOtlAdvance(pliduDAdv, iglStatic);
    long* pduDAdvMobile = getOtlAdvance(pliduDAdv, iglMobile);

    otlPlacement plcStaticAnchor;
    if (!anchorStatic.getAnchor(metr.cFUnits, metr.cPPEmX, metr.cPPEmY,
                            resourceMgr.getPointCoords(pglinfStatic->glyph),
                            &plcStaticAnchor,sec)) return;

    otlPlacement plcMobileAnchor;
    if (!anchorMobile.getAnchor(metr.cFUnits, metr.cPPEmX, metr.cPPEmY,
                            resourceMgr.getPointCoords(pglinfMobile->glyph),
                            &plcMobileAnchor,sec)) return;


    long duAdvanceInBetween = 0;
    for (USHORT igl = MIN(iglStatic, iglMobile) + 1;
                igl < MAX(iglStatic, iglMobile); ++igl)
    {
        duAdvanceInBetween += *getOtlAdvance(pliduDAdv, igl);
    }

    if (metr.layout == otlRunLTR || 
        metr.layout == otlRunRTL)
    {
        pplcMobile->dy = pplcStatic->dy + plcStaticAnchor.dy 
                                        - plcMobileAnchor.dy;
        
        if ((metr.layout == otlRunLTR) == (iglStatic < iglMobile))
        {
            long dx = pplcStatic->dx - *pduDAdvStatic + plcStaticAnchor.dx 
                                - duAdvanceInBetween  - plcMobileAnchor.dx;

            if (grfOptions & otlUseAdvances)
            {
                *pduDAdvStatic += dx;
            }
            else
            {
                pplcMobile->dx = dx;
            }
        }
        else
        {
            long dx = pplcStatic->dx + *pduDAdvMobile + plcStaticAnchor.dx 
                                + duAdvanceInBetween  - plcMobileAnchor.dx;

            if (grfOptions & otlUseAdvances)
            {
                *pduDAdvMobile -= dx;
            }
            else
            {
                pplcMobile->dx = dx;
            }
        }
    }
    else
    {
        pplcMobile->dx = pplcStatic->dx + plcStaticAnchor.dx 
                                        - plcMobileAnchor.dx;
        
        if ((metr.layout == otlRunTTB) == (iglStatic < iglMobile))
        {
            long dy = pplcStatic->dy - *pduDAdvStatic + plcStaticAnchor.dy 
                                 - duAdvanceInBetween - plcMobileAnchor.dy;

            if (grfOptions & otlUseAdvances)
            {
                *pduDAdvStatic += dy;
            }
            else
            {
                pplcMobile->dy = dy;
            }
        }
        else
        {
            long dy = pplcStatic->dy + *pduDAdvMobile + plcStaticAnchor.dy 
                                 + duAdvanceInBetween - plcMobileAnchor.dy;

            if (grfOptions & otlUseAdvances)
            {
                *pduDAdvMobile -= dy;
            }
            else
            {
                pplcMobile->dy = dy;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\gpos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  GPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL GPOS formats 
*       (GPOS header, ValueRecord,  AnchorTable and mark array)
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetGPosVersion = 0;
const OFFSET offsetGPosScriptList = 4;
const OFFSET offsetGPosFeatureList = 6;
const OFFSET offsetGPosLookupList = 8;
const USHORT sizeGPosHeader = sizeFIXED + 3*sizeOFFSET;

const ULONG  fixedGPosDefaultVersion = 0x00010000;

class otlGPosHeader: public otlTable
{
public:

    otlGPosHeader(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTable(pbTable,sizeGPosHeader,sec)) setInvalid();
    }

    ULONG version() const
    {   
        assert(isValid()); //should return error before calling

        return ULong(pbTable + offsetGPosVersion); 
    }

    otlScriptListTable scriptList(otlSecurityData sec) const
    {
        assert(isValid()); //should return error before calling

        return otlScriptListTable(pbTable
                        +Offset(pbTable + offsetGPosScriptList),sec);
    }

    otlFeatureListTable featureList(otlSecurityData sec) const
    {   
        assert(isValid()); //should return error before calling

        return otlFeatureListTable(pbTable 
                        + Offset(pbTable + offsetGPosFeatureList),sec); 
    }

    otlLookupListTable lookupList(otlSecurityData sec) const
    {   
        assert(isValid()); //should return error before calling

        return otlLookupListTable(pbTable 
                        + Offset(pbTable + offsetGPosLookupList),sec);
    }
};

// value record
enum  otlValueRecordFlag
{
    otlValueXPlacement  = 0x0001,
    otlValueYPlacement  = 0x0002,
    otlValueXAdvance    = 0x0004,
    otlValueYAdvance    = 0x0008,
    otlValueXPlaDevice  = 0x0010,
    otlValueYPlaDevice  = 0x0020,
    otlValueXAdvDevice  = 0x0040,
    otlValueYAdvDevice  = 0x0080 

};

//For otlValueRecord::size; Nuber of bits*2 for each 4-bit combination
static USHORT const cbNibbleCount[16] = 
    { 0, 2, 2, 4,  2, 4, 4, 6,  2, 4, 4, 6,  4, 6, 6, 8 };

class otlValueRecord: public otlTable
{
private:
    const BYTE* pbMainTable;
    USHORT      grfValueFormat;

public:

    otlValueRecord(USHORT grf, const BYTE* table, const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec),
          pbMainTable(table),
          grfValueFormat(grf)
    {
        if (!isValidTable(pbTable,size(grf),sec)) setInvalid();
    }

    otlValueRecord& operator = (const otlValueRecord& copy)
    {
        pbTable = copy.pbTable;
        pbMainTable = copy.pbMainTable;
        grfValueFormat = copy.grfValueFormat;
        return *this;
    }

    USHORT valueFormat()
    {   
        return grfValueFormat; 
    }

    void adjustPos
    (
        const otlMetrics&   metr,       
        otlPlacement*       pplcGlyphPalcement, // in/out
        long*               pduDAdvance,        // in/out
        otlSecurityData     sec
    ) const;

    static USHORT size(USHORT grfValueFormat )
    {
        return (cbNibbleCount[grfValueFormat & 0x000F] +
            cbNibbleCount[(grfValueFormat >> 4) & 0x000F]);
    }
};


const OFFSET offsetAnchorFormat = 0;
const OFFSET offsetSimpleXCoordinate = 2;
const OFFSET offsetSimpleYCoordinate = 4;
const USHORT sizeSimpleAnchor = 6;

class otlSimpleAnchorTable: public otlTable
{
public:
    otlSimpleAnchorTable(const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec)
    {
        if (!isValidTable(pbTable,sizeSimpleAnchor,sec)) setInvalid();

        assert(UShort(pbTable + offsetAnchorFormat) == 1);
    }

    short xCoordinate() const
    {   
        if (!isValid())
        {
            assert(false); //we should catch it in otlAnchor::getAnchor()
            return 0;
        }    

        return SShort(pbTable + offsetSimpleXCoordinate); 
    }

    short yCoordinate() const
    {   
        if (!isValid())
        {
            assert(false); //we should catch it in otlAnchor::getAnchor()
            return 0;
        }    

        return SShort(pbTable + offsetSimpleYCoordinate); 
    }

};

const OFFSET offsetContourXCoordinate = 2;
const OFFSET offsetContourYCoordinate = 4;
const OFFSET offsetAnchorPoint = 6;
const USHORT sizeContourAnchor=8;
    
class otlContourAnchorTable: public otlTable
{
public:
    otlContourAnchorTable(const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec)
    {
        if (!isValidTable(pbTable,sizeContourAnchor,sec)) setInvalid();

        assert(UShort(pbTable + offsetAnchorFormat) == 2);
    }

    short xCoordinate() const
    {   
        if (!isValid())
        {
            assert(false); //we should catch it in otlAnchor::getAnchor()
            return 0;
        }    

        return SShort(pbTable + offsetContourXCoordinate); 
    }

    short yCoordinate() const
    {   
        if (!isValid())
        {
            assert(false); //we should catch it in otlAnchor::getAnchor()
            return 0;
        }    

        return SShort(pbTable + offsetContourYCoordinate);
    }

    USHORT anchorPoint() const
    {   
        if (!isValid())
        {
            assert(false); //we should catch it in otlAnchor::getAnchor()
            return 0;
        }    

        return UShort(pbTable + offsetAnchorPoint); 
    }

};


const OFFSET offsetDeviceXCoordinate = 2;
const OFFSET offsetDeviceYCoordinate = 4;
const OFFSET offsetXDeviceTable = 6;
const OFFSET offsetYDeviceTable = 8;
const USHORT sizeDeviceAnchor=10;

class otlDeviceAnchorTable: public otlTable
{
public:
    otlDeviceAnchorTable(const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec)
    {
        if (!isValidTable(pbTable,sizeDeviceAnchor,sec)) setInvalid();

        assert(UShort(pbTable + offsetAnchorFormat) == 3);
    }

    short xCoordinate() const
    {   
        if (!isValid())
        {
            assert(false); //we should catch it in otlAnchor::getAnchor()
            return 0;
        }    

        return SShort(pbTable + offsetDeviceXCoordinate);
    }

    short yCoordinate() const
    {   
        if (!isValid())
        {
            assert(false); //we should catch it in otlAnchor::getAnchor()
            return 0;
        }    

        return SShort(pbTable + offsetDeviceYCoordinate);
    }

    otlDeviceTable xDeviceTable(otlSecurityData sec) const
    {   
        if (!isValid()) return otlDeviceTable(pbInvalidData, sec);
            
        if (Offset(pbTable + offsetXDeviceTable) == 0)
            return otlDeviceTable((const BYTE*)NULL, sec);

        return otlDeviceTable(pbTable + Offset(pbTable + offsetXDeviceTable), sec); 
    }

    otlDeviceTable yDeviceTable(otlSecurityData sec) const
    {   
        if (!isValid()) return otlDeviceTable(pbInvalidData, sec);

        if (Offset(pbTable + offsetYDeviceTable) == 0)
            return otlDeviceTable((const BYTE*)NULL, sec);

        return otlDeviceTable(pbTable + Offset(pbTable + offsetYDeviceTable), sec); 
    }

};


class otlAnchor: public otlTable
{

public:

    otlAnchor(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTable(pbTable,sizeUSHORT,sec)) setInvalid();
    }

    USHORT format() const
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetAnchorFormat); 
    }

    bool getAnchor
    (
        USHORT          cFUnits,        // font design units per Em 
        USHORT          cPPEmX,         // horizontal pixels per Em 
        USHORT          cPPEmY,         // vertical pixels per Em 
        
        otlPlacement*   rgPointCoords,  // may be NULL if not available
                
        otlPlacement*   pplcAnchorPoint,    // out: anchor point in rendering units

        otlSecurityData sec
    ) const;
};



const OFFSET offsetMarkClass = 0;
const OFFSET offsetMarkAnchor = 2;
const USHORT defaultMarkClass=0;

const SIZE sizeMarkRecord = sizeUSHORT + sizeOFFSET;

class otlMarkRecord: public otlTable
{
    const BYTE* pbMainTable;
public:

    otlMarkRecord(const BYTE* array, const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec),
          pbMainTable(array)
    {
        if (!isValidTable(pb,sizeMarkRecord,sec)) setInvalid();
    }

    USHORT markClass() const
    {
        if (!isValid()) return defaultMarkClass;

        return UShort(pbTable + offsetMarkClass); 
    }

    otlAnchor markAnchor(otlSecurityData sec) const
    {   
        if (!pbMainTable || !isValid()) return otlAnchor((BYTE*)NULL,sec); 

        return otlAnchor(pbMainTable + Offset(pbTable + offsetMarkAnchor), sec); 
    }
};


const OFFSET offsetMarkCount = 0;
const OFFSET offsetMarkRecordArray = 2;

const SIZE sizeMarkArray = sizeUSHORT;

class otlMarkArray: public otlTable
{
public:

    otlMarkArray(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTable(pb,sizeMarkArray,sec) ||
            !isValidTable(pb,sizeMarkArray+markCount(),sec)) setInvalid();
    }

    USHORT markCount() const
    {   
        if (!isValid()) return 0;

        return UShort(pbTable + offsetMarkCount); 
    }

    otlMarkRecord markRecord(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid()); //execution should stop after markCount();

        assert(index < markCount());
        return otlMarkRecord(pbTable,
                             pbTable + offsetMarkRecordArray 
                                     + index * sizeMarkRecord, sec); 
    }
};


// helper functions

long DesignToPP
(
    USHORT          cFUnits,        // font design units per Em 
    USHORT          cPPem,          // pixels per Em

    long            lFValue         // value to convert, in design units
);

// align anchors on two glyphs; assume no spacing glyphs between these two
enum otlAnchorAlighmentOptions
{
    otlUseAdvances      =   1 

};

void AlignAnchors
(
    const otlList*      pliGlyphInfo,   
    otlList*            pliPlacement,
    otlList*            pliduDAdv,

    USHORT              iglStatic,
    USHORT              iglMobile,

    const otlAnchor&    anchorStatic,
    const otlAnchor&    anchorMobile,

    otlResourceMgr&     resourceMgr, 

    const otlMetrics&   metr,       

    USHORT              grfOptions,

    otlSecurityData sec
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\gsub.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  GSUB.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements helper functions calls dealing with gsub 
*       processing
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"


/***********************************************************************/
otlErrCode SubstituteNtoM
(
    otlList*        pliCharMap,
    otlList*        pliGlyphInfo,
    otlResourceMgr& resourceMgr,

    USHORT          grfLookupFlags,

    USHORT          iGlyph,
    USHORT          cGlyphs,
    const otlList&  liglSubstitutes
)
{
    assert(pliCharMap->dataSize() == sizeof(USHORT));
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

    assert(iGlyph + cGlyphs <= pliGlyphInfo->length());
    assert(cGlyphs > 0);

    assert(liglSubstitutes.dataSize() == sizeof(otlGlyphID));
    assert(liglSubstitutes.length() > 0);

    //security check: Number of glyphs can not exceed 65K
    // GlyphCount - Old + New <= 0xFFFF
    if (
        pliGlyphInfo->length() < cGlyphs ||
        (pliGlyphInfo->length() - cGlyphs) >= (65536 - liglSubstitutes.length())
       )
    {
       return OTL_SUCCESS; //Do nothing
    }
    
    // get GDEF
    otlSecurityData secgdef;
    const BYTE *pbgdef;
    resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
    otlGDefHeader gdef = 
        otlGDefHeader(pbgdef,secgdef);

    // Record the original starting char and number of characters;
    // Merge all components (make all chars in all components point to iGlyph)
    otlGlyphInfo* pglinfFirst = getOtlGlyphInfo(pliGlyphInfo, iGlyph);
    USHORT iChar = pglinfFirst->iChar;
    USHORT cchLigTotal = pglinfFirst->cchLig;

    USHORT igl = iGlyph;
    for (USHORT i = 1; i < cGlyphs; ++i)
    {
        igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, secgdef, 
                                igl + 1, otlForward);

        //context already matched, all glyphs should exist
        assert(igl < pliGlyphInfo->length());

        otlGlyphInfo* pglinf = getOtlGlyphInfo(pliGlyphInfo, igl);

        if (cchLigTotal == 0) 
            iChar = pglinf->iChar;

        cchLigTotal += pglinf->cchLig;

        USHORT ichComp = pglinf->iChar;
        for(USHORT ich = 0; ich < pglinf->cchLig; ++ich)
        {
            USHORT* piGlyph = getOtlGlyphIndex(pliCharMap, ichComp);
            if (ich + 1 < pglinf->cchLig)
            {
                ichComp = NextCharInLiga(pliCharMap, ichComp);
            }

            assert (*piGlyph == igl);
            *piGlyph = iGlyph;
        }

    }

    // make sure we got enough space
    USHORT cNewGlyphs = liglSubstitutes.length();
    assert(cNewGlyphs > 0);

    otlErrCode erc;
    if (pliGlyphInfo->length() + cNewGlyphs - cGlyphs > pliGlyphInfo->maxLength())
    {
        erc = resourceMgr.reallocOtlList(pliGlyphInfo, 
                                            pliGlyphInfo->dataSize(), 
                                            pliGlyphInfo->maxLength() 
                                                + cNewGlyphs - cGlyphs, 
                                            otlPreserveContent);

        if (erc != OTL_SUCCESS) return erc;
    }

    // get rid of old glyphs, allocate space for new ones
    if (grfLookupFlags == 0)
    {
        // easy special case
        if (cNewGlyphs - cGlyphs > 0)
        {
            InsertGlyphs(pliCharMap, pliGlyphInfo, iGlyph, cNewGlyphs - cGlyphs);
        }
        else if (cNewGlyphs - cGlyphs < 0)
        {
            DeleteGlyphs(pliCharMap, pliGlyphInfo, iGlyph, cGlyphs - cNewGlyphs);
        }
    }
    else
    {
        igl = iGlyph + 1;
        for (USHORT i = 1; i < cGlyphs; ++i)
        {
            igl = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, secgdef, 
                                    igl, otlForward);

            assert(igl < pliGlyphInfo->length());
            DeleteGlyphs(pliCharMap, pliGlyphInfo, igl, 1);

        }

        InsertGlyphs(pliCharMap, pliGlyphInfo, iGlyph, cNewGlyphs - 1);
    }

    // go though glyphs assigning them the right values
    // and getting their cchLig from gdef

    // NOTE: glyph components are defined by both GDEF caret tables
    // and mark-to-liagture positioning tables
    // Where there is choice we give preference to GDEF

    USHORT cchCurTotal = 0;
    for (USHORT iSub = 0; iSub < cNewGlyphs; ++iSub)    
    {
        otlGlyphID glSubst = GlyphID(liglSubstitutes.readAt(iSub));

        otlGlyphInfo* pglinf = 
            getOtlGlyphInfo(pliGlyphInfo, iGlyph + iSub);

        pglinf->glyph = glSubst;
        pglinf->iChar = iChar;

        // REVIEW
        // this is how we distribute components in case of multiple substitution
        if (iSub + 1 == cNewGlyphs)
        {
            pglinf->cchLig = cchLigTotal - cchCurTotal;
        }
        else 
        {
            otlLigGlyphTable ligGlyph = FindLigGlyph(gdef, secgdef, glSubst);
            if (!ligGlyph.isNull())
            {
                pglinf->cchLig = MIN(ligGlyph.caretCount() + 1, 
                                     cchLigTotal - cchCurTotal);
            }
            else 
            {
                pglinf->cchLig = MIN(1, cchLigTotal - cchCurTotal);

            }
        }

        if (pglinf->cchLig > 0)
        {
            for (USHORT i = 0; i < pglinf->cchLig; ++i)
            {
                USHORT* piGlyph = getOtlGlyphIndex(pliCharMap, iChar);
                if (cchCurTotal + i + 1 < cchLigTotal)
                {
                    iChar = NextCharInLiga(pliCharMap, iChar);
                }

                *piGlyph = iGlyph + iSub;
            }
        }
        
        cchCurTotal += pglinf->cchLig;
    }
    
    return OTL_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\mkbaspos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  MKBASPOS.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with mark-to-base attachment lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// Look for the *logically* preceding base
short findBase
(
    const otlList*              pliCharMap,
    const otlList*              pliGlyphInfo,
    USHORT                      iglMark
)
{
    USHORT iglBase;
    bool fFoundBase = false;
    for (short ich = readOtlGlyphInfo(pliGlyphInfo, iglMark)->iChar; 
                ich >= 0 && !fFoundBase; --ich)
    {
        USHORT igl = readOtlGlyphIndex(pliCharMap, ich);
        if ((readOtlGlyphInfo(pliGlyphInfo, igl)->grf & OTL_GFLAG_CLASS) 
                != otlMarkGlyph)
        {
            iglBase = igl;
            fFoundBase = true;
        }
    }
    if (!fFoundBase)
    {
        return -1;
    }
    
    return iglBase;
}

otlErrCode otlMkBasePosLookup::apply
(
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph

        otlSecurityData             sec
)
{
    if (!isValid()) return OTL_NOMATCH;

    assert(pliGlyphInfo != NULL);
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

    assert(pliduGlyphAdv != NULL);
    assert(pliduGlyphAdv->dataSize() == sizeof(long));
    assert(pliplcGlyphPlacement != NULL);
    assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));

    assert(pliduGlyphAdv->length() == pliGlyphInfo->length());
    assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length());

    assert(iglAfterLast > iglIndex);
    assert(iglAfterLast <= pliGlyphInfo->length());

    //assert(format() == 1); //Validation assert
    if (format()!=1) return OTL_NOMATCH;

    otlGlyphInfo* pMarkInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
    if ((pMarkInfo->grf & OTL_GFLAG_CLASS) != otlMarkGlyph)
    {
        return OTL_NOMATCH;
    }

    MkBasePosSubTable mkBasePos = MkBasePosSubTable(pbTable, sec);

    short indexMark = mkBasePos.markCoverage(sec).getIndex(pMarkInfo->glyph,sec);
    if (indexMark < 0)
    {
        return OTL_NOMATCH;
    }


    // Look for the *logically* preceding base
    short iglBase = findBase(pliCharMap, pliGlyphInfo, iglIndex);
    if (iglBase < 0)
    {
        return OTL_NOMATCH;
    }

    otlGlyphInfo* pBaseInfo = getOtlGlyphInfo(pliGlyphInfo, iglBase);
    short indexBase = mkBasePos.baseCoverage(sec).getIndex(pBaseInfo->glyph,sec);
    if (indexBase < 0)
    {
        return OTL_NOMATCH;
    }

    if (indexMark >= mkBasePos.markArray(sec).markCount())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }
    otlMarkRecord markRecord = mkBasePos.markArray(sec).markRecord(indexMark,sec);
    otlAnchor anchorMark = markRecord.markAnchor(sec);

    if (indexBase >= mkBasePos.baseArray(sec).baseCount())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }
    if (markRecord.markClass() >= mkBasePos.baseArray(sec).classCount())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }
    otlAnchor anchorBase = 
        mkBasePos.baseArray(sec).baseAnchor(indexBase, markRecord.markClass(),sec);


    AlignAnchors(pliGlyphInfo, pliplcGlyphPlacement, pliduGlyphAdv, 
                 iglBase, iglIndex, anchorBase, anchorMark, resourceMgr, 
                 metr, 0, sec);

    *piglNextGlyph = iglIndex + 1;
    return OTL_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\ligasub.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  LIGASUB.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with ligature substitution lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode otlLigatureSubstLookup::apply
(
    otlList*                    pliCharMap,
    otlList*                    pliGlyphInfo,
    otlResourceMgr&             resourceMgr,

    USHORT                      grfLookupFlags,

    USHORT                      iglIndex,
    USHORT                      iglAfterLast,

    USHORT*                     piglNextGlyph,      // out: next glyph

    otlSecurityData             sec
)
{
    if (!isValid()) return OTL_NOMATCH;

    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliCharMap->dataSize() == sizeof(USHORT));
    assert(iglAfterLast > iglIndex);
    assert(iglAfterLast <= pliGlyphInfo->length());

    otlLigatureSubTable ligaSubst = otlLigatureSubTable(pbTable,sec);
    if (!ligaSubst.isValid()) return OTL_NOMATCH;

    otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
    
    short index = ligaSubst.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
    if (index < 0)
    {
        return OTL_NOMATCH;
    }

    // look for a ligature that applies
    if (index >= ligaSubst.ligSetCount())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }

    // get GDEF
    otlSecurityData secgdef;
    const BYTE *pbgdef;
    resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
    otlGDefHeader gdef = 
        otlGDefHeader(pbgdef,secgdef);

    otlLigatureSetTable ligaSet = ligaSubst.ligatureSet(index,sec);

    USHORT cLiga = ligaSet.ligatureCount();
    for (USHORT iLiga = 0; iLiga < cLiga; ++iLiga)
    {
        otlLigatureTable ligaTable = ligaSet.ligature(iLiga,sec);
           
        USHORT cComp = ligaTable.compCount();

        bool match = true;

        if (cComp==0) //OTL_BAD_FONT_TABLE
        {
            match=false;
        }

        // a simple check so we don't waste time
        if (iglIndex + cComp > iglAfterLast)
        {
            match = false;
        }

        USHORT iglComp = iglIndex;
        for (USHORT i = 1; i < cComp && iglComp < iglAfterLast && match; ++i)
        {
            iglComp = NextGlyphInLookup(pliGlyphInfo, 
                                        grfLookupFlags, gdef, secgdef, 
                                        iglComp + 1, otlForward);
            
            if (iglComp < iglAfterLast)
            {
                otlGlyphInfo* pglinf = getOtlGlyphInfo(pliGlyphInfo, iglComp);
                if (pglinf->glyph != ligaTable.component(i))
                {
                    match = false;
                }
            }
            else
            {
                match = false;
            }
        }

        if (match)
        {
            // that's where the next glyph will be after the subst is done
            *piglNextGlyph = (iglComp - cComp + 1) + 1;

            return SubstituteNtoM(pliCharMap, pliGlyphInfo, resourceMgr, 
                                  grfLookupFlags,  
                                  iglIndex, cComp,
                                  ligaTable.substitute());
        }
    }

    return OTL_NOMATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\lookups.h ===
/***********************************************************************
************************************************************************
*
*                    ********  LOOKUPS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with functions common for all lookup formats.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/


const USHORT offsetLookupFormat = 0;

class otlSingleSubstLookup;
class otlAlternateSubstLookup;
class otlMultiSubstLookup;
class otlLigatureSubstLookup;

class otlSinglePosLookup;
class otlPairPosLookup;
class otlCursivePosLookup;
class otlMkBasePosLookup;
class otlMkLigaPosLookup;
class otlMkMkPosLookup;

class otlContextLookup;
class otlChainingLookup;
class otlExtensionLookup;


const SIZE sizeLookupFormat = sizeUSHORT;

class otlLookupFormat: public otlTable 
{
public:

    friend otlSingleSubstLookup;
    friend otlAlternateSubstLookup;
    friend otlMultiSubstLookup;
    friend otlLigatureSubstLookup;

    friend otlSinglePosLookup;
    friend otlPairPosLookup;
    friend otlCursivePosLookup;
    friend otlMkBasePosLookup;
    friend otlMkLigaPosLookup;
    friend otlMkMkPosLookup;

    friend otlContextLookup;
    friend otlChainingLookup;
    friend otlExtensionLookup;

    otlLookupFormat(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTable(pb,sizeLookupFormat,sec)) setInvalid();
    }

    USHORT format() const 
    {
        if (!isValid()) return otlInvalidSubtableFormat;
        
        return UShort(pbTable + offsetLookupFormat); 
    }

};


const USHORT offsetLookupType = 0;
const USHORT offsetLookupFlags = 2;
const USHORT offsetSubTableCount = 4;
const USHORT offsetSubTableArray = 6;

const SIZE sizeLookupTable = sizeUSHORT;

class otlLookupTable: public otlTable
{
public:

    otlLookupTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTable(pb,sizeLookupTable,sec)) setInvalid();
    }

    USHORT  lookupType() const 
    {   
        if (!isValid()) return otlInvalidLookupType;
            
        return UShort(pbTable + offsetLookupType); 
    }

    otlGlyphFlags   flags() const 
    {   
        assert(isValid()); //this function should not be called if table is invalid.
                           //execution should stop after lookupType call.

        return UShort(pbTable + offsetLookupFlags); 
    }

    unsigned int    subTableCount() const
    {   
        assert(isValid()); //should break (after lookupType()) before calling.

        return UShort(pbTable + offsetSubTableCount); 
    }

    // we don't know the type
    otlLookupFormat subTable(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid()); //should break (after lookupType()) before calling.

        assert(index < subTableCount());
        
        return otlLookupFormat(pbTable + Offset(pbTable + offsetSubTableArray 
                                                        + index*sizeof(OFFSET)), sec); 
    }
};

enum otlLookupFlag
{
    otlRightToLeft          = 0x0001,   // for CursiveAttachment only
    otlIgnoreBaseGlyphs     = 0x0002,   
    otlIgnoreLigatures      = 0x0004,   
    otlIgnoreMarks          = 0x0008,

    otlMarkAttachClass      = 0xFF00
};

inline USHORT attachClass(USHORT grfLookupFlags)
{   return (grfLookupFlags & otlMarkAttachClass) >> 8; }


const OFFSET offsetLookupCount = 0;
const OFFSET offsetLookupArray = 2;

const SIZE sizeLookupListTable = sizeUSHORT;

class otlLookupListTable: public otlTable
{
public:

    otlLookupListTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeLookupListTable,offsetLookupCount,sizeUSHORT,sec))
            setInvalid();
    }

    USHORT lookupCount() const
    {   
        if (!isValid()) return 0;
        
        return UShort(pbTable + offsetLookupCount); }

    otlLookupTable lookup(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid()); //should break (after lookupCount()) before calling.
        
        assert(index < lookupCount());
        return otlLookupTable(pbTable 
                     + Offset(pbTable + offsetLookupArray 
                                      + index*sizeof(OFFSET)), sec); 
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\measure.h ===
/***********************************************************************
************************************************************************
*
*                    ********  MEASURE.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL measuring functions
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

otlLigGlyphTable FindLigGlyph
(
    const otlGDefHeader&    gdef,
    otlSecurityData         secgdef,
    otlGlyphID              glLigature
);

// count marks to this base
USHORT CountMarks
(
    const otlList*  pliCharMap,
    const otlList*  pliGlyphInfo,
    USHORT          ichBase
);

USHORT ComponentToChar
(
    const otlList*  pliCharMap,
    const otlList*  pliGlyphInfo,
    USHORT          iglLigature,
    USHORT          iComponent
);

USHORT CharToComponent
(
    const otlList*  pliCharMap,
    const otlList*  pliGlyphInfo,
    USHORT          iChar
);

otlErrCode GetCharAtPos 
( 
    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,
    otlResourceMgr&     resourceMgr, 

    long                duAdv,
    
    const otlMetrics&   metr,       
    USHORT*             piChar
);

otlErrCode GetPosOfChar 
( 
    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,
    otlResourceMgr&     resourceMgr, 

    const otlMetrics&   metr,       
    USHORT              iChar,
    
    long*               pduStartPos,
    long*               pduEndPos
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\measure.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  MEASURE.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements measuring-related functions
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// find caret value for a ligature component
// returns NULL if caret is not defined for that ligature
// (fall back to glyph advance then)
otlLigGlyphTable FindLigGlyph
(
    const otlGDefHeader&    gdef,
    otlSecurityData         secgdef,
    otlGlyphID              glLigature
)
{
    if (!gdef.isValid()) return otlLigGlyphTable((const BYTE*)NULL,secgdef);
    
    if(gdef.isNull()) return otlLigGlyphTable((const BYTE*)NULL,secgdef);

    otlLigCaretListTable ligCaretList = gdef.ligCaretList(secgdef);
    if (ligCaretList.isNull()) 
    {
        return otlLigGlyphTable((const BYTE*)NULL,secgdef);
    }

    short index = ligCaretList.coverage(secgdef).getIndex(glLigature,secgdef);

    // glyph not covered?
    if (index < 0) return otlLigGlyphTable((const BYTE*)NULL,secgdef);

    assert(index < ligCaretList.ligGlyphCount());
    // if the table is broken, still return something
    if (index >= ligCaretList.ligGlyphCount()) 
    {
        return otlLigGlyphTable((const BYTE*)NULL,secgdef);
    }

    return ligCaretList.ligGlyphTable(index,secgdef);

}


// find character corresponding to ligature component
USHORT ComponentToChar
(
    const otlList*  pliCharMap,
    const otlList*  pliGlyphInfo,
    USHORT          iglLigature,
    USHORT          iComponent
)
{
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(iglLigature < pliGlyphInfo->length());

    const otlGlyphInfo* pglinfLigature = 
        readOtlGlyphInfo(pliGlyphInfo, iglLigature);

    assert(iComponent < pglinfLigature->cchLig);

    USHORT iChar = pglinfLigature->iChar;
    for(USHORT ich = 0; ich < iComponent; ++ich)
    {
        iChar = NextCharInLiga(pliCharMap, iChar);
        assert(iChar < pliCharMap->length());
    }   

    return iChar;
}


// find ligature compoonent corresponding to character
USHORT CharToComponent
(
    const otlList*  pliCharMap,
    const otlList*  pliGlyphInfo,
    USHORT          iChar
)
{
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliCharMap->dataSize() == sizeof(USHORT));

    USHORT iglLigature = readOtlGlyphIndex(pliCharMap, iChar);

    const otlGlyphInfo* pglinfLigature = 
        readOtlGlyphInfo(pliGlyphInfo, iglLigature);

    USHORT ich = pglinfLigature->iChar;
    assert(ich <= iChar);
    for (USHORT iComp = 0; iComp < pglinfLigature->cchLig; ++iComp )
    {
        if (ich == iChar)
        {
            return iComp;
        }
        
        ich = NextCharInLiga(pliCharMap, ich);
    }

    assert(false);
    return 0;
}


// count marks to this base
USHORT CountMarks
(
    const otlList*  pliCharMap,
    const otlList*  pliGlyphInfo,
    USHORT          ichBase
)
{
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliCharMap->dataSize() == sizeof(USHORT));
    
    USHORT cMarks = 0;

    bool done = false;
    for (USHORT ich = ichBase + 1; ich < pliCharMap->length(); ++ich)
    {
        USHORT iglMark = readOtlGlyphIndex(pliCharMap, ich);

        const otlGlyphInfo* pglinfMark = 
            readOtlGlyphInfo(pliGlyphInfo, iglMark);
        
        // are we done? have we gone too far?
        if ((pglinfMark->grf & OTL_GFLAG_CLASS) == otlMarkGlyph)
        {
            ++cMarks;
        }
        else
        {
            return cMarks;
        }
    }

    return cMarks;
}


otlErrCode GetCharAtPos 
( 
    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,
    otlResourceMgr&     resourceMgr, 

    const long          duAdv,

    const otlMetrics&   metr,       
    USHORT*             piChar
)
{
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliCharMap->dataSize() == sizeof(USHORT));
    assert(pliduGlyphAdv->dataSize() == sizeof(long));
    assert(pliGlyphInfo->length() == pliduGlyphAdv->length());

    if (duAdv < 0) return OTL_ERR_POS_OUTSIDE_TEXT;

    long duPen = 0;
    long duLastAdv = 0;

    USHORT iglBase=0; //iglBase does not need to be initialized. Just to avoid warnings
    bool found = false;
    for(USHORT igl = 0; igl < pliGlyphInfo->length() && !found; ++igl)
    {
        duLastAdv = readOtlAdvance(pliduGlyphAdv, igl);

        if (duPen + duLastAdv > duAdv)
        {
            iglBase = igl;
            found = true;
        }
        else
        {
            duPen += duLastAdv;
        }
    }

    if (!found) return OTL_ERR_POS_OUTSIDE_TEXT;

    const otlGlyphInfo* pglinfBase = readOtlGlyphInfo(pliGlyphInfo, iglBase);

    // ok we found our glyph

    // now if it's a ligature we need to figure which component to take

    // if it's not however, then it's simple
    if (pglinfBase->cchLig <= 1)
    {
        *piChar = pglinfBase->iChar;
        return OTL_SUCCESS;
    }

    // now we try to figure out the component
    USHORT iComponent;
    long duComponent = duAdv - duPen;

    assert(duComponent >= 0);
    assert(duComponent < duLastAdv);

    // try to get caret information if it's a ligature
    // time to get GDEF
    otlSecurityData secgdef;
    const BYTE *pbgdef;
    resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
    otlGDefHeader gdef = 
        otlGDefHeader(pbgdef,secgdef);

    otlLigGlyphTable ligGlyph = FindLigGlyph(gdef, secgdef, pglinfBase->glyph);
    if (!ligGlyph.isNull())
    {
        // now we know it's a ligature, and caret table was found
        // go through carets
        iComponent = 0;

        USHORT cCarets = ligGlyph.caretCount();
        for (USHORT iCaret = 0; iCaret < cCarets; ++iCaret)
        {
             if (duComponent >= ligGlyph.caret(iCaret,secgdef)
                 .value(metr, resourceMgr.getPointCoords(pglinfBase->glyph),secgdef)
                )
                       
             {
                 ++iComponent;
             }
        }
    }
    else
    {
        // resort to the simplistic fallback

        // Round it up, so that we always round-trip 
        // iComponent --> duComponent --> iComponent
        iComponent = (USHORT)((pglinfBase->cchLig * (duComponent + 1) - 1) / duLastAdv);
    }
                        
    iComponent  = MIN(iComponent, pglinfBase->cchLig);
    
    *piChar =  ComponentToChar(pliCharMap, pliGlyphInfo, iglBase, iComponent);

    return OTL_SUCCESS;
}


otlErrCode GetPosOfChar 
( 
    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,
    otlResourceMgr&     resourceMgr, 

    const otlMetrics&   metr,       
    USHORT              iChar,
    
    long*               pduStartPos,
    long*               pduEndPos
)
{
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliCharMap->dataSize() == sizeof(USHORT));
    assert(pliduGlyphAdv->dataSize() == sizeof(long));
    assert(pliGlyphInfo->length() == pliduGlyphAdv->length());
    
    if(iChar >= pliCharMap->length()) 
    {
        return OTL_ERR_POS_OUTSIDE_TEXT;
    }

    USHORT iGlyph = readOtlGlyphIndex(pliCharMap, iChar);

    const otlGlyphInfo* pglinfBase = 
        readOtlGlyphInfo(pliGlyphInfo, iGlyph);

    
    // sum up advances to get to our glyph
    long duPen = 0;
    for(USHORT iglPen = 0; iglPen < iGlyph; ++iglPen)
    {
        duPen += readOtlAdvance(pliduGlyphAdv, iglPen);

    }

    long duLastAdv = readOtlAdvance(pliduGlyphAdv, iGlyph);

    // add advances of glyphs that go to the same character
    // we should add this space to the last component as all these
    // glyphs map to the last character
    long duExtra = 0;
    for (USHORT igl = iGlyph + 1; igl < pliGlyphInfo->length() 
                && readOtlGlyphInfo(pliGlyphInfo, igl)->cchLig == 0; ++igl)
    {
        assert(readOtlGlyphInfo(pliGlyphInfo, igl)->iChar == iChar);
        duExtra += readOtlAdvance(pliduGlyphAdv, igl);

    }

    // now if it's a ligature we need to figure which component to take
    // if it's not however, then it's simple
    if (pglinfBase->cchLig == 1)
    {
        *pduStartPos =  duPen;
        *pduEndPos = duPen + duLastAdv + duExtra;

        return OTL_SUCCESS;
    }

    USHORT iComponent = CharToComponent(pliCharMap, pliGlyphInfo, iChar);

    // else try to get caret information if it's a ligature
    // time to get GDEF
    otlSecurityData secgdef;
    const BYTE *pbgdef;
    resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
    otlGDefHeader gdef = 
        otlGDefHeader(pbgdef,secgdef);

    otlLigGlyphTable ligGlyph = FindLigGlyph(gdef, secgdef, pglinfBase->glyph);
    if (!ligGlyph.isNull())
    {
        // got the caret table
        // now our position is between two carets
        if (iComponent == 0)
        {
             *pduStartPos = duPen;
        }
        else if (iComponent - 1 < ligGlyph.caretCount())
        {
            *pduStartPos =  duPen + ligGlyph.caret(iComponent - 1,secgdef)
                .value(metr, resourceMgr.getPointCoords(pglinfBase->glyph),secgdef);
        }
        else
        {
            assert(false);          // more components than caret pos + 1
            *pduStartPos = duPen + duLastAdv + duExtra;
        }

        if (iComponent < ligGlyph.caretCount())
        {
            *pduEndPos =    duPen + ligGlyph.caret(iComponent,secgdef)
                .value(metr, resourceMgr.getPointCoords(pglinfBase->glyph),secgdef);
        }
        else if (iComponent == ligGlyph.caretCount())
        {
            *pduEndPos = duPen + duLastAdv + duExtra;
        }
        else
        {
            assert(false);          // more components than caret pos + 1
            *pduStartPos = duPen + duLastAdv + duExtra;
        }

    }
    else
    {
        // simplistic fallback
        *pduStartPos =  duPen + (duLastAdv * iComponent) / pglinfBase->cchLig;
        *pduEndPos = duPen + (duLastAdv * (iComponent + 1)) / pglinfBase->cchLig;

        if (iComponent + 1 == pglinfBase->cchLig)
        {
            *pduEndPos += duExtra;
        }
    }

    return OTL_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\gsub.h ===
/***********************************************************************
************************************************************************
*
*                    ********  GSUB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL GSUB formats (GSUB Header).
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/


const OFFSET offsetGSubVersion = 0;
const OFFSET offsetGSubScriptList = 4;
const OFFSET offsetGSubFeatureList = 6;
const OFFSET offsetGSubLookupList = 8;
const USHORT sizeGSubHeader = sizeFIXED + 3*sizeOFFSET;

const ULONG  fixedGSubDefaultVersion = 0x00010000;

class otlGSubHeader: public otlTable
{
public:

    otlGSubHeader(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTable(pbTable,sizeGSubHeader,sec)) setInvalid();
    }

    ULONG version() const
    {   
        assert(isValid()); //should return error before calling

        return ULong(pbTable + offsetGSubVersion); 
    }

    otlScriptListTable scriptList(otlSecurityData sec) const
    {
        assert(isValid()); //should return error before calling

        return otlScriptListTable(pbTable 
                        + Offset(pbTable + offsetGSubScriptList),sec); 
    }

    otlFeatureListTable featureList(otlSecurityData sec) const
    {   
        assert(isValid()); //should return error before calling

        return otlFeatureListTable(pbTable  
                        + Offset(pbTable + offsetGSubFeatureList), sec); 
    }

    otlLookupListTable lookupList(otlSecurityData sec) const
    {   
        assert(isValid()); //should return error before calling

        return otlLookupListTable(pbTable 
                        + Offset(pbTable + offsetGSubLookupList),sec); 
    }

};


class otlRange
{
private:

    USHORT  iFirst;
    USHORT  iAfterLast;

    // new not allowed
    void* operator new(size_t size);

public:

    otlRange(USHORT first, USHORT after_last)
        : iFirst(first), iAfterLast(after_last)
    {}

    bool contains (USHORT i) const
    {   return (iFirst <= i) && (iAfterLast > i); }

    bool intersects (const otlRange& other) const
    {   return MAX(iFirst, other.iFirst) < MIN(iAfterLast, other.iAfterLast); }

};


// n --> m substitution
otlErrCode SubstituteNtoM
(
    otlList*        pliCharMap,
    otlList*        pliGlyphInfo,
    otlResourceMgr& resourceMgr,

    USHORT          grfLookupFlags,

    USHORT          iGlyph,
    USHORT          cGlyphs,
    const otlList&  liglSubstitutes
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\ligasub.h ===
/***********************************************************************
************************************************************************
*
*                    ********  LIGASUB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with ligature substitution lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetLigGlyph = 0;
const OFFSET offsetLigCompCount = 2;
const OFFSET offsetLigComponentArray = 4;
const USHORT sizeLigatureTable = sizeGlyphID + sizeUSHORT;

class otlLigatureTable: public otlTable
{
public:

    otlLigatureTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec)
    {
        if (!isValidTable(pb,sizeLigatureTable,sec) ||
            !isValidTable(pb,sizeLigatureTable+sizeGlyphID*(compCount()-1),sec)
           )
        {
            setInvalid();
        }
    }

    // we return otlList of length 1 so it's in the same format
    // as in multiple substitution lookup
    otlList substitute()
    {   
        assert(isValid());
        
        return otlList((void*)(pbTable + offsetLigGlyph), 
                        sizeof(otlGlyphID), 1, 1); 
    }
    
    USHORT compCount()
    {   
        assert(isValid());
        
        return UShort(pbTable + offsetLigCompCount); 
    }

    otlGlyphID component(USHORT index)
    {   
        assert(isValid());
        
        assert(index < compCount());
        assert(index > 0);
        return GlyphID(pbTable + offsetLigComponentArray 
                                + (index - 1) * sizeof(otlGlyphID)); 
    }
};


const OFFSET offsetLigatureCount = 0;
const OFFSET offsetLigatureArray = 2;
const USHORT sizeLigatureSetTable = sizeUSHORT;

class otlLigatureSetTable: public otlTable
{
public:

    otlLigatureSetTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeLigatureSetTable,offsetLigatureCount,sizeOFFSET,sec))
        {
            setInvalid();
        }
    }

    USHORT ligatureCount()
    {   
        if (!isValid()) return 0;

        return UShort(pbTable + offsetLigatureCount); 
    }

    otlLigatureTable ligature(USHORT index, otlSecurityData sec)
    {   
        assert(isValid());

        assert(index < ligatureCount());
        return otlLigatureTable(pbTable + 
                    Offset(pbTable + offsetLigatureArray 
                                   + index * sizeof(OFFSET)),sec);
    }
};


const OFFSET offsetLigaCoverage = 2;
const OFFSET offsetLigSetCount = 4;
const OFFSET offsetLigatureSetArray = 6;
const USHORT sizeLigatureSubTable = sizeUSHORT+sizeOFFSET+sizeUSHORT;

class otlLigatureSubTable: public otlLookupFormat
{
public:
    otlLigatureSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeLigatureSubTable,offsetLigSetCount,sizeOFFSET,sec))
        {
            setInvalid();
        }
    }

    otlCoverage coverage(otlSecurityData sec)
    {   
        assert(isValid());
            
        return otlCoverage(pbTable + Offset(pbTable + offsetLigaCoverage),sec); 
    }

    USHORT ligSetCount()
    {   
        assert(isValid());

        return UShort(pbTable + offsetLigSetCount); 
    }
    
    otlLigatureSetTable ligatureSet(USHORT index, otlSecurityData sec)
    {   
        assert(isValid());

        assert(index < ligSetCount());
        return otlLigatureSetTable(pbTable + 
                    Offset(pbTable + offsetLigatureSetArray 
                                   + index * sizeof(OFFSET)),sec);
    }
};


class otlLigatureSubstLookup: public otlLookupFormat
{
public:
    otlLigatureSubstLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec) 
    {
        assert(isValid());
    }
    
    otlErrCode apply
    (
    otlList*                    pliCharMap,
    otlList*                    pliGlyphInfo,
    otlResourceMgr&             resourceMgr,

    USHORT                      grfLookupFlags,

    USHORT                      iglIndex,
    USHORT                      iglAfterLast,

    USHORT*                     piglNextGlyph,      // out: next glyph

    otlSecurityData             sec
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\mkmkpos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  MKMKPOS.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with mark-to-mark attachment lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode otlMkMkPosLookup::apply
(
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        USHORT                      grfLookupFlags,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph

        otlSecurityData             sec
)
{
    if (!isValid()) return OTL_NOMATCH;

    assert(pliGlyphInfo != NULL);
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

    assert(pliduGlyphAdv != NULL);
    assert(pliduGlyphAdv->dataSize() == sizeof(long));
    assert(pliplcGlyphPlacement != NULL);
    assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));

    assert(pliduGlyphAdv->length() == pliGlyphInfo->length());
    assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length());

    assert(iglAfterLast > iglIndex);
    assert(iglAfterLast <= pliGlyphInfo->length());

    // assert(format() == 1); Validation assert
    if (format()!=1) return OTL_NOMATCH;
    
    otlGlyphInfo* pMark1Info = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
    if ((pMark1Info->grf & OTL_GFLAG_CLASS) != otlMarkGlyph)
    {
        return OTL_NOMATCH;
    }

    MkMkPosSubTable mkMkPos = MkMkPosSubTable(pbTable,sec);

    short indexMark1 = mkMkPos.mark1Coverage(sec).getIndex(pMark1Info->glyph,sec);
    if (indexMark1 < 0)
    {
        return OTL_NOMATCH;
    }

    otlSecurityData secgdef;
    const BYTE *pbgdef;
    resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
    otlGDefHeader gdef = 
        otlGDefHeader(pbgdef,secgdef);

    // preceding glyph 

    short iglPrev = NextGlyphInLookup(pliGlyphInfo, grfLookupFlags, gdef, secgdef, 
                                      iglIndex - 1, otlBackward);
    if (iglPrev < 0)
    {
        return OTL_NOMATCH;
    }

    otlGlyphInfo* pMark2Info = getOtlGlyphInfo(pliGlyphInfo, iglPrev);
    if ((pMark2Info->grf & OTL_GFLAG_CLASS) != otlMarkGlyph)
    {
        return OTL_NOMATCH;
    }

    short indexMark2 = mkMkPos.mark2Coverage(sec).getIndex(pMark2Info->glyph,sec);
    if (indexMark2 < 0)
    {
        return OTL_NOMATCH;
    }

    // make sure that marks of different bases or components don't interact
    for (USHORT ichBetween = pMark2Info->iChar + 1; 
                ichBetween < pMark1Info->iChar; ++ichBetween)
    {
        USHORT iglBetween = readOtlGlyphIndex(pliCharMap, ichBetween);
        if ((readOtlGlyphInfo(pliGlyphInfo, iglBetween)->grf & OTL_GFLAG_CLASS) 
                != otlMarkGlyph)
        {
            return OTL_NOMATCH;
        }
    }

    if (indexMark1 >= mkMkPos.mark1Array(sec).markCount())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }
    otlMarkRecord markRecord = mkMkPos.mark1Array(sec).markRecord(indexMark1,sec);


    otlAnchor anchorMark1 = markRecord.markAnchor(sec);

    if (indexMark2 >= mkMkPos.mark2Array(sec).mark2Count())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }
    if (markRecord.markClass() >= mkMkPos.mark2Array(sec).classCount())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }
    otlAnchor anchorMark2 = 
        mkMkPos.mark2Array(sec).mark2Anchor(indexMark2, markRecord.markClass(),sec);

    AlignAnchors(pliGlyphInfo, pliplcGlyphPlacement, pliduGlyphAdv, 
                 iglPrev, iglIndex, anchorMark2, anchorMark1, resourceMgr, 
                 metr, 0, sec);

    *piglNextGlyph = iglIndex + 1;

    return OTL_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\mkligpos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  MKLIGPOS.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with mark-to-ligature attachment lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// Look for the *logically* preceding base
short findBaseLigature
(
    const otlList*              pliCharMap,
    const otlList*              pliGlyphInfo,
    USHORT                      iglMark,
    USHORT*                     piComponent
)
{
    USHORT ichBase, iglBase;
    bool fFoundBase = false;
    for (short ich = readOtlGlyphInfo(pliGlyphInfo, iglMark)->iChar; 
                ich >= 0 && !fFoundBase; --ich)
    {
        USHORT igl = readOtlGlyphIndex(pliCharMap, ich);
        if ((readOtlGlyphInfo(pliGlyphInfo, igl)->grf & OTL_GFLAG_CLASS) 
                != otlMarkGlyph)
        {
            ichBase = ich;
            iglBase = igl;
            fFoundBase = true;
        }
    }
    if (!fFoundBase)
    {
        return -1;
    }

    *piComponent = CharToComponent(pliCharMap, pliGlyphInfo, ichBase);
    
    return iglBase;
}


otlErrCode otlMkLigaPosLookup::apply
(
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph

        otlSecurityData             sec
)
{
    if (!isValid()) return OTL_NOMATCH;

    assert(pliGlyphInfo != NULL);
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

    assert(pliduGlyphAdv != NULL);
    assert(pliduGlyphAdv->dataSize() == sizeof(long));
    assert(pliplcGlyphPlacement != NULL);
    assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));

    assert(pliduGlyphAdv->length() == pliGlyphInfo->length());
    assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length());

    assert(iglAfterLast > iglIndex);
    assert(iglAfterLast <= pliGlyphInfo->length());

    //assert(format() == 1); //Validation assert
    if (format()!=1) return OTL_NOMATCH;

    otlGlyphInfo* pMarkInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
    if ((pMarkInfo->grf & OTL_GFLAG_CLASS) != otlMarkGlyph)
    {
        return OTL_NOMATCH;
    }

    MkLigaPosSubTable mkLigaPos = MkLigaPosSubTable(pbTable,sec);

    short indexMark = mkLigaPos.markCoverage(sec).getIndex(pMarkInfo->glyph,sec);
    if (indexMark < 0)
    {
        return OTL_NOMATCH;
    }


    // Look for the *logically* preceding base
    USHORT iComponent;
    short iglBase = findBaseLigature(pliCharMap, pliGlyphInfo, 
                                     iglIndex, &iComponent);
    if (iglBase < 0)
    {
        return OTL_NOMATCH;
    }

    otlGlyphInfo* pBaseInfo = getOtlGlyphInfo(pliGlyphInfo, iglBase);
    short indexBase = mkLigaPos.ligatureCoverage(sec).getIndex(pBaseInfo->glyph,sec);
    if (indexBase < 0)
    {
        return OTL_NOMATCH;
    }


    if (indexBase >= mkLigaPos.ligatureArray(sec).ligatureCount())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }
    otlLigatureAttachTable ligaAttach = 
        mkLigaPos.ligatureArray(sec).ligatureAttach(indexBase,sec);

    if (iComponent >= ligaAttach.componentCount())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }   
    
    if (indexMark >= mkLigaPos.markArray(sec).markCount())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }
    otlMarkRecord markRecord = mkLigaPos.markArray(sec).markRecord(indexMark,sec);


    otlAnchor anchorMark = markRecord.markAnchor(sec);

    if (markRecord.markClass() >= ligaAttach.classCount())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }
    otlAnchor anchorBase = 
        ligaAttach.ligatureAnchor(iComponent, markRecord.markClass(),sec);


    AlignAnchors(pliGlyphInfo, pliplcGlyphPlacement, pliduGlyphAdv, 
                 iglBase, iglIndex, anchorBase, anchorMark, resourceMgr, 
                 metr, 0, sec);

    *piglNextGlyph = iglIndex + 1;

    return OTL_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\mkbaspos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  MKBASPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with mark-to-base positioning lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetBaseCount = 0;
const OFFSET offsetBaseRecordArray = 2;
const USHORT sizeBaseArray=sizeUSHORT;

class otlBaseArray: public otlTable
{
    const USHORT cClassCount;

public:
    otlBaseArray(USHORT classCount, const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec),
          cClassCount(classCount)
    {
        if (!isValidTable(pb,sizeBaseArray,sec) ||
            !isValidTable(pb,sizeBaseArray+baseCount()*classCount*sizeOFFSET,sec)
           )
            setInvalid();
    }

    USHORT baseCount()
    {   
        if (!isValid()) return 0;
        return UShort(pbTable + offsetBaseCount); 
    }

    USHORT classCount()
    {   
        assert(isValid());

        return cClassCount; 
    }

    otlAnchor baseAnchor(USHORT index, USHORT iClass, otlSecurityData sec)
    {   
        assert(isValid());
        
        assert(index < baseCount());
        return otlAnchor(pbTable + 
            Offset(pbTable + offsetBaseRecordArray 
                           + (index * cClassCount + iClass) * sizeof(OFFSET)),sec);
    }
};


const OFFSET offsetMkBaseMarkCoverage = 2;
const OFFSET offsetMkBaseBaseCoverage = 4;
const USHORT offsetMkBaseClassCount = 6;
const OFFSET offsetMkBaseMarkArray = 8;
const OFFSET offsetMkBaseBaseArray = 10;

const SIZE sizeMkBasePos = sizeUSHORT + 2*sizeOFFSET + sizeUSHORT + 2*sizeOFFSET;

class MkBasePosSubTable: public otlLookupFormat
{
public:
    MkBasePosSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec)
    {
        assert(isValid()); //Checked in LookupFormat
        assert(format() == 1);

        if (!isValidTable(pb,sizeMkBasePos,sec)) setInvalid();
    }

    otlCoverage markCoverage(otlSecurityData sec)
    {   
        if (!isValid()) return otlCoverage(pbInvalidData,sec);
        
        return otlCoverage(pbTable + Offset(pbTable + offsetMkBaseMarkCoverage),sec); 
    }

    otlCoverage baseCoverage(otlSecurityData sec)
    {   
        if (!isValid()) return otlCoverage(pbInvalidData,sec);

        return otlCoverage(pbTable + Offset(pbTable + offsetMkBaseBaseCoverage),sec); 
    }

    USHORT classCount()
    {   
        if (!isValid()) return 0;
        
        return UShort(pbTable + offsetMkBaseClassCount); 
    }

    otlMarkArray markArray(otlSecurityData sec)
    {   
        if (!isValid()) return otlMarkArray((BYTE*)NULL,sec);

        return otlMarkArray(pbTable + Offset(pbTable + offsetMkBaseMarkArray),sec); 
    }

    otlBaseArray baseArray(otlSecurityData sec)
    {   
        assert(isValid());

        return otlBaseArray(classCount(),
                            pbTable + Offset(pbTable + offsetMkBaseBaseArray),sec); 
    }

};


class otlMkBasePosLookup: public otlLookupFormat
{
public:
    otlMkBasePosLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec) 
    {

        assert(isValid());
    }
    
    otlErrCode apply
    (
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph

        otlSecurityData             sec
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\otllib.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLLIB.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements all top-level OTL Library calls.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"


/***********************************************************************/

#define     OTL_MAJOR_VERSION           1
#define     OTL_MINOR_VERSION           0
#define     OTL_MAJOR_VERSION_MASK      0xFF00

/***********************************************************************/

inline long version()
{
    return (OTL_MAJOR_VERSION << 16) + OTL_MINOR_VERSION;
}

OTL_EXPORT otlErrCode GetOtlVersion ( 
    long* plVersion
)
{
    *plVersion = version();

    return OTL_SUCCESS; 
}

// make sure that the (major) version we support is greater
// or equal to what the client requests
inline bool checkVersion(const otlRunProp* pRunProps)
{
    return (version() & OTL_MAJOR_VERSION_MASK) >= 
            (pRunProps->lVersion & OTL_MAJOR_VERSION_MASK);
}


OTL_EXPORT otlErrCode GetOtlScriptList 
    ( 
    const otlRunProp*   pRunProps, 
    otlList*            pliWorkspace,   
    otlList*            plitagScripts
    )
{
    // sanity check
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        plitagScripts == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if(plitagScripts->dataSize() != sizeof(otlTag) ||
        plitagScripts->length() > plitagScripts->maxLength()) 
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc, ercGSub, ercGPos;

    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    plitagScripts->empty();

    otlSecurityData sec=secEmptySecurityData;
    otlScriptListTable scriptList = otlScriptListTable((const BYTE*)NULL,sec);
    
    // GSUB
    ercGSub = GetScriptFeatureLookupLists(OTL_GSUB_TAG, resourceMgr,  
                                            &scriptList, 
                                            (otlFeatureListTable*)NULL, 
                                            (otlLookupListTable*)NULL,
                                            &sec);
    if (ercGSub == OTL_SUCCESS) 
        // get the script list from GSUB 
        ercGSub = AppendScriptTags(scriptList, plitagScripts, resourceMgr,sec);
    
    if (ERRORLEVEL(ercGSub) > OTL_ERRORLEVEL_MINOR) return ercGSub;


    // GPOS
    ercGPos = GetScriptFeatureLookupLists(OTL_GPOS_TAG, resourceMgr, 
                                            &scriptList, 
                                            (otlFeatureListTable*)NULL, 
                                            (otlLookupListTable*)NULL,
                                            &sec);
    if (ercGPos == OTL_SUCCESS)
        // get the script list, from GPOS
        ercGPos = AppendScriptTags(scriptList, plitagScripts, resourceMgr,sec);
        

    // return greater error
    if (ERRORLEVEL(ercGSub) < ERRORLEVEL(ercGPos)) 
        return ercGPos; 
    else 
        return ercGSub;
    
}



OTL_EXPORT otlErrCode GetOtlLangSysList 
    ( 
    const otlRunProp*   pRunProps,    
    otlList*            pliWorkspace,   
    otlList*            plitagLangSys
    )
{
    // sanity check
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        plitagLangSys == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if(plitagLangSys->dataSize() != sizeof(otlTag) ||
        plitagLangSys->length() > plitagLangSys->maxLength()) 
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc, ercGSub, ercGPos;

    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    plitagLangSys->empty();

    otlSecurityData sec=secEmptySecurityData;
    otlScriptListTable scriptList = otlScriptListTable((const BYTE*)NULL,sec);

    
    // GSUB
    ercGSub = GetScriptFeatureLookupLists(OTL_GSUB_TAG, resourceMgr, 
                                            &scriptList, 
                                            (otlFeatureListTable*)NULL, 
                                            (otlLookupListTable*)NULL,
                                            &sec);
    if (ercGSub == OTL_SUCCESS)
        ercGSub = AppendLangSysTags(scriptList, pRunProps->tagScript, 
                                    plitagLangSys, resourceMgr,sec);

    // return immediately if fatal error, but keep going if script was not found
    if (ERRORLEVEL(ercGSub) > OTL_ERRORLEVEL_MINOR) return ercGSub;  


    // GPOS
    ercGPos = GetScriptFeatureLookupLists(OTL_GPOS_TAG, resourceMgr, 
                                            &scriptList, 
                                            (otlFeatureListTable*)NULL, 
                                            (otlLookupListTable*)NULL,
                                            &sec);
    if (ercGPos == OTL_SUCCESS)
        ercGPos = AppendLangSysTags(scriptList, pRunProps->tagScript, 
                                    plitagLangSys, resourceMgr,sec);

    
    // return greater error
    if (ERRORLEVEL(ercGSub) < ERRORLEVEL(ercGPos)) 
        return ercGPos; 
    else 
        return ercGSub;
    
}


OTL_EXPORT otlErrCode GetOtlFeatureDefs 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,   
    otlList*            pliFDefs
)
{
    // sanity check
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL || 
        pliFDefs == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if(pliFDefs->dataSize() != sizeof(otlFeatureDef) ||
        pliFDefs->length() > pliFDefs->maxLength()) 
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc, ercGSub , ercGPos;

    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    pliFDefs->empty();

    otlSecurityData sec=secEmptySecurityData;
    otlFeatureListTable featureList = otlFeatureListTable((const BYTE*)NULL,sec);
    otlScriptListTable scriptList = otlScriptListTable((const BYTE*)NULL,sec);

    
    // GSUB
    ercGSub = GetScriptFeatureLookupLists(OTL_GSUB_TAG, resourceMgr, 
                                            &scriptList, 
                                            &featureList, 
                                            (otlLookupListTable*)NULL,
                                            &sec);
    if (ercGSub == OTL_SUCCESS)
        ercGSub = AppendFeatureDefs(OTL_GSUB_TAG, resourceMgr, 
                                    scriptList, 
                                    pRunProps->tagScript,
                                    pRunProps->tagLangSys,
                                    featureList, pliFDefs,sec);

    // return immediately if fatal error, but keep going if script 
    // or langsys were not found
    if (ERRORLEVEL(ercGSub) > OTL_ERRORLEVEL_MINOR) return ercGSub;
    
    
    // GPOS
    ercGPos = GetScriptFeatureLookupLists(OTL_GPOS_TAG, resourceMgr, 
                                            &scriptList, 
                                            &featureList, 
                                            (otlLookupListTable*)NULL,
                                            &sec);
    if (ercGPos == OTL_SUCCESS)
        ercGPos = AppendFeatureDefs(OTL_GPOS_TAG, resourceMgr, 
                                    scriptList,  
                                    pRunProps->tagScript,
                                    pRunProps->tagLangSys,
                                    featureList, pliFDefs,sec);

    
    // return greater error
    if (ERRORLEVEL(ercGSub) < ERRORLEVEL(ercGPos)) 
        return ercGPos; 
    else 
        return ercGSub;

}


OTL_EXPORT otlErrCode FreeOtlResources 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace   
)
{
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    otlErrCode erc;
    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;
    
    return resourceMgr.freeResources();
}


OTL_EXPORT otlErrCode GetOtlLineSpacing 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,   
    const otlFeatureSet*    pFSet,
    
    long* pdvMax, 
    long* pdvMin
)
{
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pdvMax == (long*)NULL || pdvMin == (long*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;

    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    // get BASE
    otlSecurityData secbase;
    const BYTE *pbbase;
    resourceMgr.getOtlTable(OTL_BASE_TAG,&pbbase,&secbase);
    otlBaseHeader base = 
        otlBaseHeader(pbbase,secbase);

    if (base.isNull()) return  OTL_ERR_TABLE_NOT_FOUND;

    otlBaseScriptTable baseScript = otlBaseScriptTable((const BYTE*)NULL,secbase);
    if (pRunProps->metr.layout == otlRunLTR ||
        pRunProps->metr.layout == otlRunRTL)
    {
        baseScript = FindBaseScriptTable(base.horizAxis(secbase), pRunProps->tagScript,secbase);
    }
    else
    {
        baseScript = FindBaseScriptTable(base.vertAxis(secbase), pRunProps->tagScript,secbase);
    }

    if (baseScript.isNull())
    {
        return OTL_ERR_SCRIPT_NOT_FOUND;
    }
    
    otlMinMaxTable minmaxTable = 
        FindMinMaxTable(baseScript, pRunProps->tagLangSys,secbase);
    if (minmaxTable.isNull())
    {
        return OTL_ERR_LANGSYS_NOT_FOUND;
    }

    long lMinCoord, lMaxCoord;
    lMinCoord = minmaxTable.minCoord(secbase).baseCoord(pRunProps->metr, resourceMgr,secbase);

    lMaxCoord = minmaxTable.maxCoord(secbase).baseCoord(pRunProps->metr, resourceMgr,secbase);

    if (pFSet != (otlFeatureSet*)NULL)
    {
        for(USHORT iFeature = 0; 
                   iFeature < pFSet->liFeatureDesc.length(); ++iFeature)
        {
            const otlFeatureDesc* pFeatureDesc = 
                readOtlFeatureDesc(&pFSet->liFeatureDesc, iFeature);

            otlFeatMinMaxRecord featMinMax = 
                FindFeatMinMaxRecord(minmaxTable, pFeatureDesc->tagFeature,secbase);

            if (!featMinMax.isNull())
            {
                lMinCoord = MIN(lMinCoord, featMinMax.minCoord(secbase)
                      .baseCoord(pRunProps->metr, resourceMgr,secbase));

                lMaxCoord = MAX(lMinCoord, featMinMax.maxCoord(secbase)
                      .baseCoord(pRunProps->metr, resourceMgr,secbase));
            }
        }
    }

    *pdvMin = lMinCoord;
    *pdvMax = lMaxCoord;

    return OTL_SUCCESS;
}


OTL_EXPORT otlErrCode GetOtlBaselineOffsets 
    ( 
    const otlRunProp*   pRunProps,   
    otlList*            pliWorkspace,   
    otlList*            pliBaselines
    )
{
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        pliBaselines == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;

    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    // get BASE
    otlSecurityData secbase;
    const BYTE *pbbase;
    resourceMgr.getOtlTable(OTL_BASE_TAG,&pbbase,&secbase);
    otlBaseHeader base = 
        otlBaseHeader(pbbase,secbase);
    if (base.isNull()) return  OTL_ERR_TABLE_NOT_FOUND;

    otlAxisTable axisTable = otlAxisTable((const BYTE*)NULL,secbase);
    if (pRunProps->metr.layout == otlRunLTR ||
        pRunProps->metr.layout == otlRunRTL)
    {
        axisTable = base.horizAxis(secbase);
    }
    else
    {
        axisTable = base.vertAxis(secbase);
    }

    otlBaseScriptTable baseScript = 
        FindBaseScriptTable(axisTable, pRunProps->tagScript,secbase);

    if (baseScript.isNull())
    {
        return OTL_ERR_SCRIPT_NOT_FOUND;
    }
    
    otlBaseTagListTable baseTagList = axisTable.baseTagList(secbase);
    
    USHORT cBaselines = baseTagList.baseTagCount();


    if (pliBaselines->maxLength() < cBaselines ||
        pliBaselines->dataSize() != sizeof(otlBaseline))
    {
        erc = resourceMgr.reallocOtlList(pliBaselines, 
                                         sizeof(otlBaseline), 
                                         cBaselines, 
                                         otlDestroyContent);

        if (erc != OTL_SUCCESS) return erc;
    }
    pliBaselines->empty();


    otlBaseValuesTable baseValues = baseScript.baseValues(secbase);
    if (baseValues.isNull())
    {
        // no baselines -- nothing to report
        return OTL_SUCCESS;
    }
    
    if (cBaselines != baseValues.baseCoordCount())
    {
        assert(false);  // bad font -- the values should match up
        return OTL_ERR_BAD_FONT_TABLE;
    }
    

    for (USHORT iBaseline = 0; iBaseline < cBaselines; ++iBaseline)
    {
        otlBaseline baseline;

        baseline.tag = baseTagList.baselineTag(iBaseline);
        baseline.lCoordinate = baseValues.baseCoord(iBaseline,secbase)
                      .baseCoord(pRunProps->metr, resourceMgr,secbase);
        pliBaselines->append((const BYTE*)&baseline);
    }
        

    return OTL_SUCCESS;
}



OTL_EXPORT otlErrCode GetOtlCharAtPosition 
    ( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,   

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,

    const long          duAdv,
    
    USHORT*             piChar
    )
{
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        pliCharMap == (otlList*)NULL || pliGlyphInfo == (otlList*)NULL ||
        pliduGlyphAdv == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (piChar == (USHORT*)NULL) 
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliGlyphInfo->dataSize() != sizeof(otlGlyphInfo) ||
        pliduGlyphAdv->dataSize() != sizeof(long) ||
        pliGlyphInfo->length() != pliduGlyphAdv->length())
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;

    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    erc = GetCharAtPos(pliCharMap, pliGlyphInfo, pliduGlyphAdv, resourceMgr, 
                        duAdv, pRunProps->metr, piChar);
    if (erc != OTL_SUCCESS) return erc;

    return OTL_SUCCESS;
}



OTL_EXPORT otlErrCode GetOtlExtentOfChars ( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,   

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,

    USHORT              ichFirstChar,
    USHORT              ichLastChar,
    
    long*               pduStartPos,
    long*               pduEndPos
)
{
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        pliCharMap == (otlList*)NULL || pliGlyphInfo == (otlList*)NULL ||
        pliduGlyphAdv == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pduStartPos == (long*)NULL || pduEndPos == (long*)NULL) 
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliGlyphInfo->dataSize() != sizeof(otlGlyphInfo) ||
        pliduGlyphAdv->dataSize() != sizeof(long) ||
        pliGlyphInfo->length() != pliduGlyphAdv->length() ||
        ichFirstChar > ichLastChar)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc; 
    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    erc = GetPosOfChar(pliCharMap, pliGlyphInfo, pliduGlyphAdv, resourceMgr,                         
                        pRunProps->metr,
                        ichFirstChar, pduStartPos, pduEndPos);
    if (erc != OTL_SUCCESS) return erc;

    if (ichFirstChar != ichLastChar)
    {
        long duStartLastPos;
        erc = GetPosOfChar(pliCharMap, pliGlyphInfo, pliduGlyphAdv,resourceMgr,    
                            pRunProps->metr,
                            ichLastChar, &duStartLastPos, pduEndPos);
    }

    return erc;
}


OTL_EXPORT otlErrCode GetOtlFeatureParams ( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,   

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,

    const otlTag        tagFeature,
    
    long*               plGlobalParam,
    otlList*            pliFeatureParams
)
{
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        pliCharMap == (otlList*)NULL || pliGlyphInfo == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (plGlobalParam == (long*)NULL || pliFeatureParams == (otlList*)NULL) 
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    // REVIEW: -- feature parameters are not defined in the current spec
    // (TODO)   we probably should report information for alternative
    //          substitution parameters here
    *plGlobalParam = 0;
    pliFeatureParams->empty();

    return OTL_SUCCESS;
}


OTL_EXPORT otlErrCode SubstituteOtlChars ( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    const otlList*          pliChars,

    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,
    otlList*            pliFResults
)
{
    // sanity checks
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL || 
        pliChars == (otlList*)NULL || pliCharMap == (otlList*)NULL ||
        (otlList*)pliGlyphInfo == NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliChars->length() > OTL_MAX_CHAR_COUNT)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;
    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    // allocate lists for CMAP application
    //
    USHORT cChars = pliChars->length();

    if (pliGlyphInfo->maxLength() < cChars ||
        pliGlyphInfo->dataSize() != sizeof(otlGlyphInfo))
    {
        erc = pRunProps->pClient->ReallocOtlList(pliGlyphInfo, 
                                                 sizeof(otlGlyphInfo), 
                                                 cChars, 
                                                 otlDestroyContent);

        if (erc != OTL_SUCCESS) return erc;
    }
    pliGlyphInfo->empty();
    pliGlyphInfo->insertAt(0, cChars);

    if (pliCharMap->maxLength() < cChars ||
        pliCharMap->dataSize() != sizeof(USHORT))
    {
        erc = pRunProps->pClient->ReallocOtlList(pliCharMap, 
                                                 sizeof(USHORT), 
                                                 cChars, 
                                                 otlDestroyContent);

        if (erc != OTL_SUCCESS) return erc;
    }
    pliCharMap->empty();
    pliCharMap->insertAt(0, cChars);
    

    // initialize the glyph info
    erc = pRunProps->pClient->GetDefaultGlyphs(pliChars, pliGlyphInfo);
    if (erc != OTL_SUCCESS) return erc;

    if (pliChars->length() != pliGlyphInfo->length())
    {
        return OTL_ERR_INCONSISTENT_RUNLENGTH;
    }

    USHORT cGlyphs = pliGlyphInfo->length();

    // initialize info structures
    for (USHORT i = 0; i < cGlyphs; ++i)
    {
        *getOtlGlyphIndex(pliCharMap, i) = i;

        otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, i);

        pGlyphInfo->iChar = i;
        pGlyphInfo->cchLig = 1;
        pGlyphInfo->grf = otlUnresolved;
    }

    // assign glyph types
    // get GDEF
    otlSecurityData secgdef;
    const BYTE *pbgdef;
    resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
    otlGDefHeader gdef = 
        otlGDefHeader(pbgdef,secgdef);

    erc = AssignGlyphTypes(pliGlyphInfo, gdef, secgdef, 0, pliGlyphInfo->length(), 
                            otlDoAll);
    if (erc != OTL_SUCCESS) return erc;

    // we kill the resource manager here just so we can create 
    // another one in SubstituteOtlGlyphs
    resourceMgr.detach();  

    // no features -- no substitutions; we just set everything up
    if (pFSet == (otlFeatureSet*)NULL) return OTL_SUCCESS;

    // now do the substitutions
    erc = SubstituteOtlGlyphs (pRunProps, pliWorkspace, pFSet, 
                               pliCharMap, pliGlyphInfo, pliFResults);

    return erc;
}


OTL_EXPORT otlErrCode SubstituteOtlGlyphs ( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,
    otlList*            pliFResults
)
{
    // sanity checks
    if (pRunProps == (otlRunProp*)NULL || pliWorkspace == (otlList*)NULL ||
        pFSet == (otlFeatureSet*)NULL || pliCharMap == (otlList*)NULL ||
        pliGlyphInfo == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliGlyphInfo->dataSize() != sizeof(otlGlyphInfo) ||
        pliCharMap->dataSize() != sizeof(USHORT) ||
        pFSet->liFeatureDesc.dataSize() != sizeof(otlFeatureDesc))
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pFSet->ichStart >= pliCharMap->length() || 
        pFSet->ichStart + pFSet->cchScope > pliCharMap->length())
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliCharMap->length() > OTL_MAX_CHAR_COUNT)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;
    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    if (pliFResults != (otlList*)NULL)
    {
        if (pliFResults->maxLength() < pFSet->liFeatureDesc.length() ||
            pliFResults->dataSize() != sizeof(otlFeatureResult))        
        {
            erc = pRunProps->pClient->ReallocOtlList(pliFResults, 
                                                     sizeof(otlFeatureResult), 
                                                     pFSet->liFeatureDesc.length(), 
                                                     otlDestroyContent);

            if (erc != OTL_SUCCESS) return erc;
        }
        pliFResults->empty();
        pliFResults->insertAt(0, pFSet->liFeatureDesc.length());
    }


    // get GDEF
    otlSecurityData secgdef;
    const BYTE *pbgdef;
    resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
    otlGDefHeader gdef = 
        otlGDefHeader(pbgdef,secgdef);

    erc = AssignGlyphTypes(pliGlyphInfo, gdef, secgdef, 0, pliGlyphInfo->length(), 
                            otlDoUnresolved);
    if (erc != OTL_SUCCESS) return erc;


    erc = ApplyFeatures
            (
                OTL_GSUB_TAG,
                pFSet,
                pliCharMap,
                pliGlyphInfo,    
                resourceMgr,

                pRunProps->tagScript,
                pRunProps->tagLangSys,

                pRunProps->metr,        // not needed, but still pass
                (otlList*)NULL,             
                (otlList*)NULL, 

                pliFResults
            );

    return erc;

}


OTL_EXPORT otlErrCode PositionOtlGlyphs 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    otlList*        pliCharMap,         // these could be const except we may 
    otlList*        pliGlyphInfo,       // need to restore glyph flags
                                        // (and ApplyLokups doesn't take consts)

    otlList*        pliduGlyphAdv,
    otlList*        pliplcGlyphPlacement,

    otlList*        pliFResults
)
{
    // sanity checks
    if (pRunProps == (otlRunProp*)NULL || pFSet == (otlFeatureSet*)NULL || 
        pliGlyphInfo == (otlList*)NULL || pliCharMap == (otlList*)NULL ||
        pliduGlyphAdv == (otlList*)NULL || pliplcGlyphPlacement == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliGlyphInfo->dataSize() != sizeof(otlGlyphInfo) || 
        pliCharMap->dataSize() != sizeof(USHORT) ||
        pFSet->liFeatureDesc.dataSize() != sizeof(otlFeatureDesc))
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pFSet->ichStart >= pliCharMap->length() || 
        pFSet->ichStart + pFSet->cchScope > pliCharMap->length())
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliCharMap->length() > OTL_MAX_CHAR_COUNT)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }


    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;
    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    const USHORT cGlyphs = pliGlyphInfo->length();

    if (pliduGlyphAdv->maxLength() < cGlyphs ||
        pliduGlyphAdv->dataSize() != sizeof(long))
    {
        erc = pRunProps->pClient->ReallocOtlList(pliduGlyphAdv, 
                                                 sizeof(long), 
                                                 cGlyphs, 
                                                 otlDestroyContent);

        if (erc != OTL_SUCCESS) return erc;
    }
    pliduGlyphAdv->empty();
    pliduGlyphAdv->insertAt(0, cGlyphs);

    if (pliplcGlyphPlacement->maxLength() < cGlyphs ||
        pliplcGlyphPlacement->dataSize() != sizeof(otlPlacement))
    {
        erc = pRunProps->pClient->ReallocOtlList(pliplcGlyphPlacement, 
                                                 sizeof(otlPlacement), 
                                                 cGlyphs, 
                                                 otlDestroyContent);

        if (erc != OTL_SUCCESS) return erc;
    }
    pliplcGlyphPlacement->empty();
    pliplcGlyphPlacement->insertAt(0, cGlyphs);
    
    // initialize advance and placement
    erc = pRunProps->pClient->GetDefaultAdv (pliGlyphInfo, pliduGlyphAdv);
    if (erc != OTL_SUCCESS) return erc;
    
    for (USHORT iGlyph = 0; iGlyph < cGlyphs; ++iGlyph)
    {
        otlPlacement* plc = getOtlPlacement(pliplcGlyphPlacement, iGlyph);

        plc->dx = 0;
        plc->dy = 0;
    }

    // reassign glyph types where necessary 
    // (so clients don't have to cache them)
    otlSecurityData secgdef;
    const BYTE *pbgdef;
    resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
    otlGDefHeader gdef = 
        otlGDefHeader(pbgdef,secgdef);

    erc = AssignGlyphTypes(pliGlyphInfo, gdef, secgdef,
                            0, cGlyphs, otlDoUnresolved);
    if (erc != OTL_SUCCESS) return erc;

    // we kill the resource manager here just so we can create 
    // another one in RePositionOtlGlyphs
    resourceMgr.detach();
    
    // now everything's initialized, position!
    erc = RePositionOtlGlyphs (pRunProps, pliWorkspace, pFSet, 
                               pliCharMap, pliGlyphInfo, 
                               pliduGlyphAdv, pliplcGlyphPlacement, 
                               pliFResults);

    return erc;
        
}

OTL_EXPORT otlErrCode RePositionOtlGlyphs 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    otlList*        pliCharMap,          
    otlList*        pliGlyphInfo,       
                                        

    otlList*        pliduGlyphAdv,
    otlList*        pliplcGlyphPlacement,

    otlList*        pliFResults
)
{
    // sanity checks
    if (pRunProps == (otlRunProp*)NULL || pFSet == (otlFeatureSet*)NULL || 
        pliGlyphInfo == (otlList*)NULL || pliCharMap == (otlList*)NULL ||
        pliduGlyphAdv == (otlList*)NULL || pliplcGlyphPlacement == (otlList*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliGlyphInfo->dataSize() != sizeof(otlGlyphInfo) || 
        pliCharMap->dataSize() != sizeof(USHORT) ||
        pFSet->liFeatureDesc.dataSize() != sizeof(otlFeatureDesc))
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pFSet->ichStart >= pliCharMap->length() || 
        pFSet->ichStart + pFSet->cchScope > pliCharMap->length())
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliCharMap->length() > OTL_MAX_CHAR_COUNT)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    if (pliduGlyphAdv->length() != pliGlyphInfo->length() ||
        pliplcGlyphPlacement->length() != pliGlyphInfo->length())
    {
        return OTL_ERR_INCONSISTENT_RUNLENGTH;
    }

    if (!checkVersion(pRunProps))
        return OTL_ERR_VERSION_OUT_OF_DATE;

    otlErrCode erc;
    otlResourceMgr resourceMgr;
    erc = resourceMgr.init(pRunProps, pliWorkspace);
    if (erc != OTL_SUCCESS) return erc;

    if (pliFResults != (otlList*)NULL)
    {
        if (pliFResults->maxLength() < pFSet->liFeatureDesc.length() ||
            pliFResults->dataSize() != sizeof(otlFeatureResult))        
        {
            erc = pRunProps->pClient->ReallocOtlList(pliFResults, 
                                                     sizeof(otlFeatureResult), 
                                                     pFSet->liFeatureDesc.length(), 
                                                     otlDestroyContent);

            if (erc != OTL_SUCCESS) return erc;
        }
        pliFResults->empty();
        pliFResults->insertAt(0, pFSet->liFeatureDesc.length());
    }

    // now apply features
    erc = ApplyFeatures
            (
                OTL_GPOS_TAG,
                pFSet,
                pliCharMap,
                pliGlyphInfo,   
                resourceMgr,

                pRunProps->tagScript,
                pRunProps->tagLangSys,

                pRunProps->metr,
                pliduGlyphAdv,              
                pliplcGlyphPlacement,   

                pliFResults
            );

    return erc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\multisub.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  MULTISUB.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with multiple substitution lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode otlMultiSubstLookup::apply
(
    otlList*                    pliCharMap, 
    otlList*                    pliGlyphInfo,
    otlResourceMgr&             resourceMgr,

    USHORT                      grfLookupFlags,

    USHORT                      iglIndex,
    USHORT                      iglAfterLast,

    USHORT*                     piglNextGlyph,      // out: next glyph

    otlSecurityData             sec
)   // return: did/did not apply
{ 
    if (!isValid()) return OTL_NOMATCH;

    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(pliCharMap->dataSize() == sizeof(USHORT));
    assert(iglAfterLast > iglIndex);
    assert(iglAfterLast <= pliGlyphInfo->length());

    otlMultiSubTable multiSubst = otlMultiSubTable(pbTable,sec);
    otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
    
    short index = multiSubst.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
    if (index < 0)
    {
        return OTL_NOMATCH;
    }

    if (index >= multiSubst.sequenceCount())
    {
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }

    otlSequenceTable sequence = multiSubst.sequence(index,sec);

    otlErrCode erc;

    *piglNextGlyph = iglIndex + sequence.glyphCount();
    erc = SubstituteNtoM(pliCharMap, pliGlyphInfo, resourceMgr,
                         grfLookupFlags, 
                         iglIndex, 1, sequence.substituteArray());
    return erc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\multisub.h ===
/***********************************************************************
************************************************************************
*
*                    ********  MULTISUB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with alternate substitution lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetSequenceGlyphCount = 0;
const OFFSET offsetSubstituteArray = 2;

class otlSequenceTable: public otlTable
{
public:

    otlSequenceTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) {}

    USHORT glyphCount()
    {   return UShort(pbTable + offsetSequenceGlyphCount); }

    otlList substituteArray()
    {   return otlList((void*)(pbTable + offsetSubstituteArray), 
                        sizeof(otlGlyphID),
                        glyphCount(), glyphCount()); 
    }
};


const OFFSET offsetMultiCoverage = 2;
const OFFSET offsetSequenceCount = 4;
const OFFSET offsetSequenceArray = 6;

class otlMultiSubTable: public otlLookupFormat
{
public:

    otlMultiSubTable(const BYTE* pb, otlSecurityData sec)
        : otlLookupFormat(pb,sec)
    {
        assert(format() == 1);
    }

    otlCoverage coverage(otlSecurityData sec)
    {   return otlCoverage(pbTable + Offset(pbTable + offsetMultiCoverage),sec); }

    USHORT sequenceCount()
    {   return UShort(pbTable + offsetSequenceCount); }

    otlSequenceTable sequence(USHORT index, otlSecurityData sec)
    {   return otlSequenceTable(pbTable + 
                Offset(pbTable + offsetSequenceArray 
                               + index * sizeof(OFFSET)),sec); }
};


class otlMultiSubstLookup: public otlLookupFormat
{
public:

    otlMultiSubstLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec) 
    {
        assert(isValid());
    }

    otlErrCode apply
    (
    otlList*                    pliCharMap,
    otlList*                    pliGlyphInfo,
    otlResourceMgr&             resourceMgr,

    USHORT                      grfLookupFlags,

    USHORT                      iglIndex,
    USHORT                      iglAfterLast,

    USHORT*                     piglNextGlyph,      // out: next glyph

    otlSecurityData             sec
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\mkmkpos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  MKMKPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with mark-to-mark positioning lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetMark2Count = 0;
const OFFSET offsetMark2AnchorArray = 2;

class otlMark2Array: public otlTable
{
    const USHORT cClassCount;

public:
    otlMark2Array(USHORT classCount, const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec),
          cClassCount(classCount)
    {}

    USHORT mark2Count()
    {   return UShort(pbTable + offsetComponentCount); }

    USHORT classCount()
    {   return cClassCount; }

    otlAnchor mark2Anchor(USHORT mark2Index, USHORT classIndex, otlSecurityData sec)
    {   assert(mark2Index < mark2Count());
        assert(classIndex < classCount());

        return otlAnchor(pbTable + 
            Offset(pbTable + offsetMark2AnchorArray  
                           + (mark2Index * cClassCount + classIndex) 
                              * sizeof(OFFSET)),sec);
    }
};



const OFFSET offsetMkMkMark1Coverage = 2;
const OFFSET offsetMkMkMark2Coverage = 4;
const OFFSET offsetMkMkClassCount = 6;
const OFFSET offsetMkMkMark1Array = 8;
const OFFSET offsetMkMkMark2Array = 10;
const USHORT sizeMkMkPosSubTable = sizeUSHORT+sizeOFFSET*2+sizeUSHORT+sizeOFFSET*2;

class MkMkPosSubTable: public otlLookupFormat
{
public:
    MkMkPosSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec)
    {
        assert(isValid()); //Checked in LookupFormat
        assert(format() == 1);

        if (!isValidTable(pb,sizeMkMkPosSubTable,sec)) setInvalid();
    }

    otlCoverage mark1Coverage(otlSecurityData sec)
    {   
        if (!isValid()) return otlCoverage(pbInvalidData,sec);

        return otlCoverage(pbTable + Offset(pbTable + offsetMkMkMark1Coverage),sec); 
    }

    otlCoverage mark2Coverage(otlSecurityData sec)
    {   
        if (!isValid()) return otlCoverage(pbInvalidData,sec);

        return otlCoverage(pbTable + Offset(pbTable + offsetMkMkMark2Coverage),sec); 
    }

    USHORT classCount()
    {   
        if (!isValid()) return 0;

        return UShort(pbTable + offsetMkMkClassCount); 
    }

    otlMarkArray mark1Array(otlSecurityData sec)
    {   
        assert(isValid());
        
        return otlMarkArray(pbTable + Offset(pbTable + offsetMkMkMark1Array),sec); 
    }

    otlMark2Array mark2Array(otlSecurityData sec)
    {   
        assert(isValid());
        
        return otlMark2Array(classCount(),
                            pbTable + Offset(pbTable + offsetMkMkMark2Array),sec); 
    }

};


class otlMkMkPosLookup: public otlLookupFormat
{
public:
    otlMkMkPosLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec) 
    {
        assert(isValid());
    }
    
    otlErrCode apply
    (
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        USHORT                      grfLookupFlags,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph

        otlSecurityData             sec
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\mkligpos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  MKLIGAPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with mark-to-ligature positioning lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetComponentCount = 0;
const OFFSET offsetLigatureAnchorArray = 2;

class otlLigatureAttachTable: public otlTable
{
    const USHORT cClassCount;

public:
    otlLigatureAttachTable(USHORT classCount, const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec),
          cClassCount(classCount)
    {}

    USHORT componentCount()
    {   return UShort(pbTable + offsetComponentCount); }

    USHORT classCount()
    {   return cClassCount; }

    otlAnchor ligatureAnchor(USHORT componentIndex, USHORT classIndex, otlSecurityData sec)
    {   assert(componentIndex < componentCount());
        assert(classIndex < classCount());

        return otlAnchor(pbTable + 
            Offset(pbTable + offsetLigatureAnchorArray  
                           + (componentIndex * cClassCount + classIndex) 
                              * sizeof(OFFSET)),sec);
    }
};


const OFFSET offsetAttachLigatureCount = 0;
const OFFSET offsetLigatureAttachArray = 2;

class otlLigatureArrayTable: public otlTable
{
    const USHORT cClassCount;

public:
    otlLigatureArrayTable(USHORT classCount, const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec),
          cClassCount(classCount)
    {}

    USHORT ligatureCount()
    {   return UShort(pbTable + offsetAttachLigatureCount); }

    USHORT classCount()
    {   return cClassCount; }

    otlLigatureAttachTable ligatureAttach(USHORT index, otlSecurityData sec)
    {   assert(index < ligatureCount());
        return otlLigatureAttachTable(cClassCount, pbTable +        
                Offset(pbTable + offsetLigatureAttachArray 
                               + index * sizeof(OFFSET)),sec);
    }
};


const OFFSET offsetMkLigaMarkCoverage = 2;
const OFFSET offsetMkLigaLigatureCoverage = 4;
const OFFSET offsetMkLigaClassCount = 6;
const OFFSET offsetMkLigaMarkArray = 8;
const OFFSET offsetMkLigaLigatureArray = 10;
const USHORT sizeMkLigaPosSubTable = sizeUSHORT+sizeOFFSET*2+sizeUSHORT+sizeOFFSET*2;

class MkLigaPosSubTable: public otlLookupFormat
{
public:
    MkLigaPosSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec)
    {
        assert(isValid()); //Checked in LookupFormat
        assert(format() == 1);

        if (!isValidTable(pb,sizeMkLigaPosSubTable,sec)) setInvalid();
    }

    otlCoverage markCoverage(otlSecurityData sec)
    {   
        if (!isValid()) return otlCoverage(pbInvalidData,sec);
        
        return otlCoverage(pbTable 
                    + Offset(pbTable + offsetMkLigaMarkCoverage),sec); 
    }

    otlCoverage ligatureCoverage(otlSecurityData sec)
    {   
        if (!isValid()) return otlCoverage(pbInvalidData,sec);

        return otlCoverage(pbTable 
                    + Offset(pbTable + offsetMkLigaLigatureCoverage),sec); 
    }

    USHORT classCount()
    {   
        if (!isValid()) return 0;

        return UShort(pbTable + offsetMkLigaClassCount); 
    }

    otlMarkArray markArray(otlSecurityData sec)
    {   
        assert(isValid());

        return otlMarkArray(pbTable 
                    + Offset(pbTable + offsetMkLigaMarkArray),sec); 
    }

    otlLigatureArrayTable ligatureArray(otlSecurityData sec)
    {   
        assert(isValid());

        return otlLigatureArrayTable(classCount(),
                    pbTable + Offset(pbTable + offsetMkLigaLigatureArray),sec); 
    }

};


class otlMkLigaPosLookup: public otlLookupFormat
{
public:
    otlMkLigaPosLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec) 
    {
        assert(isValid());
    }
    
    otlErrCode apply
    (
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph
    
        otlSecurityData             sec
);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\pch.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  PCH.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module includes all internal and external header files in order.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/


#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\resource.cpp ===
/************************************************************************
*
*                    ********  RESOURCE.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL resource management.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

const otlGlyphID GLYPH_INVALID = (otlGlyphID)(-1);

otlErrCode otlResourceMgr::init(const otlRunProp *prp, otlList* workspace)
{
    if (workspace == (otlList*)NULL ||
        prp == (otlRunProp*)NULL)
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    otlErrCode erc;
    if (workspace->length() == 0)
    {
        if (workspace->maxLength() < sizeof(otlResources)|| 
             workspace->dataSize() != sizeof(BYTE))
        {
            erc = prp->pClient->ReallocOtlList(workspace, sizeof(BYTE), 
                                                sizeof(otlResources), 
                                                otlDestroyContent);
            if (erc != OTL_SUCCESS) return erc;
        }
        workspace->insertAt(0, sizeof(otlResources));
    
        otlResources* pres = (otlResources*)workspace->data();

        // initialize newly constructured otlResources structure

        // copy the run properties for verification
        // one needs to re-initialize workspace every time they change 
        memcpy((void*)&pres->RunProp, (void*)prp, sizeof(otlResources));

        pres->pbBASE = pres->pbGDEF = pres->pbGPOS = pres->pbGSUB = (BYTE*)NULL;

        pres->secGSUB=secEmptySecurityData;
        pres->secGPOS=secEmptySecurityData;
        pres->secGDEF=secEmptySecurityData;
        pres->secBASE=secEmptySecurityData;
        
        pres->grf = 0;
        pres->rgplcLastContourPtArray = (otlPlacement*)NULL;
        pres->glLastGlyph = GLYPH_INVALID;
    }
    else if (workspace->length() < sizeof(otlResources) || 
             workspace->dataSize() != sizeof(BYTE))
    {
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    otlResources* pres = (otlResources*)workspace->data();

    // make sure the workspace cache and run properties match
    // REVIEW: (AndreiB): so far disabled -- is it really the level of fool-proof we need?
//  if ((pres->RunProp).pClient != prp->pClient ||
//      pres->RunProp.metr.layout != prp->metr.layout ||
//      pres->RunProp.metr.cFUnits != prp->metr.cFUnits ||
//      pres->RunProp.metr.cPPEmX != prp->metr.cPPEmX ||
//      pres->RunProp.metr.cPPEmY != prp->metr.cPPEmY )
//  {
//      return OTL_ERR_BAD_INPUT_PARAM;
//  }

    if ((pres->grf & otlBusy) != 0)
    {
        return OTL_ERR_CANNOT_REENTER;
    }
    pres->grf |= otlBusy;

    pClient = prp->pClient;
    pliWorkspace = workspace;

    return OTL_SUCCESS;
}

otlResourceMgr::~otlResourceMgr()
{
    detach();
}

void otlResourceMgr::detach()
{
    if (pliWorkspace == (otlList*)NULL) 
    {
        return;
    }
    
    assert(pliWorkspace->dataSize() == sizeof(BYTE));
    assert(pliWorkspace->length() >= sizeof(otlResources));
    assert(pClient != (IOTLClient*)NULL);

    otlResources* pres = (otlResources*)pliWorkspace->data();

    // TODO -- move these to FreeOtlResources
    // (will need to call FreeOtlResources in OtlPad)

    if (pres->pbGSUB != NULL)
    {
        pClient->FreeOtlTable(pres->pbGSUB, OTL_GSUB_TAG);
    }
    if (pres->pbGPOS != NULL)
    {
        pClient->FreeOtlTable(pres->pbGPOS, OTL_GPOS_TAG);
    }
    if (pres->pbGDEF != NULL)
    {
        pClient->FreeOtlTable(pres->pbGDEF, OTL_GDEF_TAG);
    }
    if (pres->pbBASE != NULL)
    {
        pClient->FreeOtlTable(pres->pbBASE, OTL_BASE_TAG);
    }

    FreeSecutiryData(pres->secGSUB);
    FreeSecutiryData(pres->secGPOS);
    FreeSecutiryData(pres->secGDEF);
    FreeSecutiryData(pres->secBASE);

    pres->pbBASE = pres->pbGDEF = pres->pbGPOS = pres->pbGSUB = (BYTE*)NULL;

    pres->grf &= ~otlBusy;

    // now null everything out to return to the "clean" state
    pClient = (IOTLClient*)NULL;
    pliWorkspace = (otlList*)NULL;
}


otlErrCode otlResourceMgr::freeResources ()
{
    assert(pliWorkspace->dataSize() == sizeof(BYTE));
    assert(pliWorkspace->length() >= sizeof(otlResources));

    otlResources* pres = (otlResources*)pliWorkspace->data();

    // (TODO) later on we will cache more glyph contour point arrays in 
    // the workspace list then we will free them all here

    if (pres->rgplcLastContourPtArray != NULL)
    {
        otlErrCode erc;
        erc = pClient->FreeGlyphPointCoords(pres->glLastGlyph, 
                                            pres->rgplcLastContourPtArray);
        if (erc != OTL_SUCCESS) return erc;

        pres->rgplcLastContourPtArray = (otlPlacement*)NULL;
        pres->glLastGlyph = GLYPH_INVALID;  
    }

    return OTL_SUCCESS;
}


otlErrCode otlResourceMgr::getOtlTable (const otlTag tagTableName, const BYTE** ppbTable, otlSecurityData* psec)
{
    assert(pliWorkspace->dataSize() == sizeof(BYTE));
    assert(pliWorkspace->length() >= sizeof(otlResources));

    otlResources* pres = (otlResources*)pliWorkspace->data();

    if (tagTableName == OTL_GSUB_TAG)
    {
        *ppbTable = pres->pbGSUB;
        *psec     = pres->secGSUB;
    }
    else if (tagTableName == OTL_GPOS_TAG)
    {
        *ppbTable = pres->pbGPOS;
        *psec     = pres->secGPOS;
    }
    else if (tagTableName == OTL_GDEF_TAG)
    {
        *ppbTable = pres->pbGDEF;
        *psec     = pres->secGDEF;
    }
    else if (tagTableName == OTL_BASE_TAG)
    {
        *ppbTable = pres->pbBASE;
        *psec     = pres->secBASE;
    }
    else
    {
        // we should not ask for any other table
        assert(false);
        *ppbTable   =(const BYTE*)NULL;
        *psec       = secEmptySecurityData;
        return OTL_ERR_BAD_INPUT_PARAM;
    }

    // now ppbTable points to the right pointer
    if (*ppbTable == (const BYTE*)NULL)
    {
        ULONG lTableLength;
        otlErrCode erc;

        erc=pClient->GetOtlTable(tagTableName,ppbTable,&lTableLength);
        if (erc != OTL_SUCCESS) return erc;
        return InitSecurityData(psec,*ppbTable,lTableLength);
    }

    return OTL_SUCCESS;
}


// called from inside OTL Services library
otlPlacement* otlResourceMgr::getPointCoords 
(
    const otlGlyphID    glyph
)
{
    assert(pliWorkspace->dataSize() == sizeof(BYTE));
    assert(pliWorkspace->length() >= sizeof(otlResources));

    otlResources* pres = (otlResources*)pliWorkspace->data();

    // for now, getting them one-by-one is good enough
    // we never need glyph coords for two points at the same time (REVIEW!)
    // (TODO) we will cache more of them and free on request later
    if (glyph != pres->glLastGlyph)
    {
        otlErrCode erc;
        if (pres->rgplcLastContourPtArray != NULL)
        {
            erc = pClient->FreeGlyphPointCoords(pres->glLastGlyph, 
                                                pres->rgplcLastContourPtArray);
            if (erc != OTL_SUCCESS) return (otlPlacement*)NULL;
        }
        pres->glLastGlyph = GLYPH_INVALID;  

        erc = pClient->GetGlyphPointCoords(glyph, &pres->rgplcLastContourPtArray);
        if (erc != OTL_SUCCESS) return (otlPlacement*)NULL;
        pres->glLastGlyph = glyph;
    }

    return pres->rgplcLastContourPtArray;

}

BYTE*  otlResourceMgr::getEnablesCacheBuf(USHORT cbSize)
{
    assert(pliWorkspace->dataSize() == sizeof(BYTE));
    assert(pliWorkspace->length() >= sizeof(otlResources));

    otlErrCode erc;

    if ( (sizeof(otlResources)+cbSize) > pliWorkspace->length() )
    {   
        erc = reallocOtlList(pliWorkspace,sizeof(BYTE),sizeof(otlResources)+cbSize,otlPreserveContent);
        if (erc != OTL_SUCCESS) return (BYTE*)NULL;
    }

    return (BYTE*)pliWorkspace->data() + sizeof(otlResources);
}

USHORT otlResourceMgr::getEnablesCacheBufSize()
{
    assert(pliWorkspace->dataSize() == sizeof(BYTE));
    assert(pliWorkspace->length() >= sizeof(otlResources));

    return pliWorkspace->length() - sizeof(otlResources);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\resource.h ===
/************************************************************************
*
*                    ********  RESOURCE.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with OTL resource management.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

enum otlResourceFlag
{
    otlBusy =   0x0001
};

struct otlResources
{
    // a copy to ensure consistent processing
    // reset the workspace every time you change run props
    otlRunProp      RunProp;
    
    USHORT          grf;
    
    BYTE*           pbGSUB;
    BYTE*           pbGPOS;
    BYTE*           pbGDEF;
    BYTE*           pbBASE;

    otlSecurityData secGSUB;
    otlSecurityData secGPOS;
    otlSecurityData secGDEF;
    otlSecurityData secBASE;
    
    // TODO: cache more than one contour point array!!!

    otlGlyphID      glLastGlyph;
    otlPlacement*   rgplcLastContourPtArray;
};


class otlResourceMgr
{
private:

    IOTLClient*         pClient;

    otlList*            pliWorkspace;

    // new not allowed
    void* operator new(size_t size);

public:

    otlResourceMgr()
        : pClient((IOTLClient*)NULL), 
          pliWorkspace((otlList*)NULL)
    {}

    ~otlResourceMgr();

    otlList* workspace () { return pliWorkspace; }

    otlErrCode reallocOtlList
    (
    otlList*                pList,              // in/out 
    const USHORT            cbNewDataSize,      // in 
    const USHORT            celmNewMaxLen,      // in 
    otlReallocOptions       optPreserveContent  // in (may assert cbNewDataSize 
                                                //                == cbDataSize)
    )
    {
        return pClient->ReallocOtlList(pList, cbNewDataSize, 
                                        celmNewMaxLen, optPreserveContent);
    }   
        
    otlErrCode init(const otlRunProp* prp, otlList* workspace);

    void detach();

    otlErrCode getOtlTable (const otlTag tagTableName, const BYTE** ppbTable, otlSecurityData* psec);

    otlPlacement* getPointCoords (const otlGlyphID glyph);

    BYTE*  getEnablesCacheBuf(USHORT cbSize);
    USHORT getEnablesCacheBufSize();

    otlErrCode freeResources ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\pairpos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  PAIRPOS.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with pair adjustment lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode otlPairPosLookup::apply
(
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        USHORT                      grfLookupFlags,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph

        otlSecurityData             sec
)
{
    if (!isValid()) return OTL_NOMATCH;

    assert(pliGlyphInfo != NULL);
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

    assert(pliduGlyphAdv != NULL);
    assert(pliduGlyphAdv->dataSize() == sizeof(long));
    assert(pliplcGlyphPlacement != NULL);
    assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));

    assert(pliduGlyphAdv->length() == pliGlyphInfo->length());
    assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length());

    assert(iglAfterLast > iglIndex);
    assert(iglAfterLast <= pliGlyphInfo->length());

    // a simple check so we don't waste time; 2 is for 'pair'
    if (iglIndex + 2 > iglAfterLast)
    {
        return OTL_NOMATCH;
    }

    switch(format())
    {
    case(1):        // glyph pairs
        {
            otlPairPosSubTable pairPos = otlPairPosSubTable(pbTable,sec);

            otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
            short index = pairPos.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
            if (index < 0)
            {
                return OTL_NOMATCH;
            }

            // get GDEF
            otlSecurityData secgdef;
            const BYTE *pbgdef;
            resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
            otlGDefHeader gdef = 
                otlGDefHeader(pbgdef,secgdef);

            USHORT iglSecond = NextGlyphInLookup(pliGlyphInfo, 
                                                 grfLookupFlags, gdef, secgdef, 
                                                 iglIndex + 1, otlForward);
            if (iglSecond  >= iglAfterLast)
            {
                return OTL_NOMATCH;
            }


            if (index > pairPos.pairSetCount())
            {
                return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
            }
            otlPairSetTable pairSet = pairPos.pairSet(index,sec);

            USHORT cSecondGlyphs = pairSet.pairValueCount();
            otlGlyphID glSecond = getOtlGlyphInfo(pliGlyphInfo, iglSecond)->glyph;
            for (USHORT iSecond = 0; iSecond < cSecondGlyphs; ++iSecond)
            {
                otlPairValueRecord pairRecord = pairSet.pairValueRecord(iSecond,sec);
                
                if (pairRecord.secondGlyph() == glSecond)
                {
                    pairRecord.valueRecord1(sec)
                        .adjustPos(metr,
                                   getOtlPlacement(pliplcGlyphPlacement, iglIndex), 
                                   getOtlAdvance(pliduGlyphAdv, iglIndex),sec);

                    pairRecord.valueRecord2(sec)
                        .adjustPos(metr, 
                                   getOtlPlacement(pliplcGlyphPlacement, iglSecond), 
                                   getOtlAdvance(pliduGlyphAdv, iglSecond),sec);

                    if (pairPos.valueFormat2() == 0)
                    {
                        *piglNextGlyph = iglIndex + 1;
                    }
                    else
                    {
                        *piglNextGlyph = iglSecond + 1;
                    }
                    return OTL_SUCCESS;
                }

            }

        return OTL_NOMATCH;
        }


    case(2):        // class pair adjustment
        {
            otlClassPairPosSubTable classPairPos = 
                        otlClassPairPosSubTable(pbTable,sec);

            otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
            short indexCoverage = 
                classPairPos.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
            if (indexCoverage < 0)
            {
                return OTL_NOMATCH;
            }

            // get GDEF
            otlSecurityData secgdef;
            const BYTE *pbgdef;
            resourceMgr.getOtlTable(OTL_GDEF_TAG,&pbgdef,&secgdef);
            otlGDefHeader gdef = 
                otlGDefHeader(pbgdef,secgdef);
            
            USHORT iglSecond = NextGlyphInLookup(pliGlyphInfo, 
                                                 grfLookupFlags, gdef, secgdef, 
                                                 iglIndex + 1, otlForward);
            if (iglSecond  >= iglAfterLast)
            {
                return OTL_NOMATCH;
            }


            USHORT iClass1 = classPairPos.classDef1(sec).getClass(pGlyphInfo->glyph,sec);
            if (iClass1 > classPairPos.class1Count())
            {
                return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
            }

            otlGlyphID glSecond = getOtlGlyphInfo(pliGlyphInfo, iglSecond)->glyph;
            USHORT iClass2 = classPairPos.classDef2(sec).getClass(glSecond,sec);
            if (iClass2 > classPairPos.class2Count())
            {
                return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
            }

            otlClassValueRecord classRecord = 
                classPairPos.classRecord(iClass1, iClass2,sec);
            
            classRecord.valueRecord1(sec)
                .adjustPos(metr, 
                            getOtlPlacement(pliplcGlyphPlacement, iglIndex), 
                            getOtlAdvance(pliduGlyphAdv, iglIndex),sec);

            classRecord.valueRecord2(sec)
                .adjustPos(metr, 
                            getOtlPlacement(pliplcGlyphPlacement, iglSecond), 
                            getOtlAdvance(pliduGlyphAdv, iglSecond),sec);

            if (classPairPos.valueFormat2() == 0)
            {
                *piglNextGlyph = iglIndex + 1;
            }
            else
            {
                *piglNextGlyph = iglSecond + 1;
            }
            return OTL_SUCCESS;

        }


    default:
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE: Unknown format
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\scrilang.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  SCRILANG.CPP ********
*
*              Open Type Layout Services Library Header File
*
*       This module implements functions dealing with scripts and languages.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

// returns a NULL script if not found
otlScriptTable FindScript
(
    const otlScriptListTable&   scriptList,
    otlTag                      tagScript, 
    otlSecurityData sec
)
{
    if (!scriptList.isValid())
    {
        return otlScriptTable(pbInvalidData, sec);
    }
    
    if (scriptList.isNull())
    {
        return otlScriptTable((const BYTE*)NULL, sec);
    }
    
    USHORT cScripts = scriptList.scriptCount();

    for(USHORT iScript = 0; iScript < cScripts; ++iScript)
    {
        if (scriptList.scriptRecord(iScript,sec).scriptTag() == tagScript)
        {
            return  scriptList.scriptRecord(iScript,sec).scriptTable(sec);
        }
    }

    return otlScriptTable((const BYTE*)NULL, sec);

}

// returns a NULL language system if not found
otlLangSysTable FindLangSys
(
    const otlScriptTable&   scriptTable,
    otlTag                  tagLangSys, 
    otlSecurityData sec
)
{
    assert(scriptTable.isValid()); //should break before calling 
    
    if (tagLangSys == OTL_DEFAULT_TAG)
    {
        return scriptTable.defaultLangSys(sec);
    }
    
    USHORT cLangSys = scriptTable.langSysCount();

    for(USHORT iLangSys = 0; iLangSys < cLangSys; ++iLangSys)
    {
        if (scriptTable.langSysRecord(iLangSys,sec).langSysTag() == tagLangSys)
        {
            return  scriptTable.langSysRecord(iLangSys,sec).langSysTable(sec);
        }
    }

    return otlLangSysTable((const BYTE*)NULL,sec);
}

// helper function-- tells us if a tag is already in the list
bool isNewTag
(
    USHORT      cTagsToCheck,
    otlList*    pliTags,
    otlTag      newtag
)
{
    assert(pliTags != NULL);
    assert(pliTags->dataSize() == sizeof(otlTag));
    assert(cTagsToCheck <= pliTags->length());

    bool fTagFound = FALSE;
    for (USHORT iPrevTag = 0; iPrevTag < cTagsToCheck && !fTagFound; ++iPrevTag)
    {
        if (readOtlTag(pliTags, iPrevTag) == newtag)
        {
            fTagFound = true;
        }
    }

    return !fTagFound;
}


// append new script tags to the current list

otlErrCode AppendScriptTags
(
    const otlScriptListTable&       scriptList,

    otlList*                        plitagScripts,
    otlResourceMgr&                 resourceMgr, 
    otlSecurityData                 sec
)
{
    if (!scriptList.isValid()) // isValid==isNull (see next if), 
                               // so just to be consistent :)
        return OTL_ERR_BAD_FONT_TABLE;

    assert(plitagScripts != NULL);
    assert(plitagScripts->dataSize() == sizeof(otlTag));
    assert(plitagScripts->length() <= plitagScripts->maxLength());

    USHORT cPrevTags = plitagScripts->length();

    otlErrCode erc = OTL_SUCCESS;   
    
    if (scriptList.isNull())
        return OTL_ERR_TABLE_NOT_FOUND;

    USHORT cScripts = scriptList.scriptCount();


    // add tags that are new
    for (USHORT iScript = 0; iScript < cScripts; ++iScript)
    {
        otlScriptRecord scriptRecord = scriptList.scriptRecord(iScript, sec);
        if (!scriptRecord.isValid()) continue;

        otlTag newtag = scriptRecord.scriptTag();

        if (isNewTag(cPrevTags, plitagScripts, newtag) )
        {
            // make sure we have the space
            if (plitagScripts->length() + 1 > plitagScripts->maxLength())
            {
                erc = resourceMgr.reallocOtlList(plitagScripts, 
                                                 plitagScripts->dataSize(), 
                                                 plitagScripts->maxLength() + 1, 
                                                 otlPreserveContent);

                if (erc != OTL_SUCCESS) return erc;
            }

            plitagScripts->append((BYTE*)&newtag);
        }
    }

    return OTL_SUCCESS;
}


// append new language system tags to the current list
otlErrCode AppendLangSysTags
(
    const otlScriptListTable&       scriptList,
    otlTag                          tagScript,

    otlList*                        plitagLangSys,
    otlResourceMgr&                 resourceMgr, 
    otlSecurityData sec
)
{
    if (!scriptList.isValid()) 
        return OTL_ERR_BAD_FONT_TABLE;

    assert(plitagLangSys != NULL);
    assert(plitagLangSys->dataSize() == sizeof(otlTag));
    assert(plitagLangSys->length() <= plitagLangSys->maxLength());

    USHORT cPrevTags = plitagLangSys->length();
    otlErrCode erc = OTL_SUCCESS;

    if (scriptList.isNull())
        return OTL_ERR_TABLE_NOT_FOUND;

    otlScriptTable scriptTable = FindScript(scriptList, tagScript,sec);
    if (!scriptTable.isValid()) return OTL_ERR_BAD_FONT_TABLE;

    USHORT cLangSys = scriptTable.langSysCount();

    // add lang sys tags that are new
    for (USHORT iLangSys = 0; iLangSys < cLangSys; ++iLangSys)
    {
        otlLangSysRecord langSysRecord = scriptTable.langSysRecord(iLangSys,sec);
        if (!langSysRecord.isValid()) continue;

        otlTag newtag = langSysRecord.langSysTag();

        if (isNewTag(cPrevTags, plitagLangSys, newtag))
        {
            // make sure we have the space
            // add one for the default lang sys
            if (plitagLangSys->length() + 1 > plitagLangSys->maxLength())
            {
                erc = resourceMgr.reallocOtlList(plitagLangSys, 
                                                    plitagLangSys->dataSize(), 
                                                    plitagLangSys->length() + 1, 
                                                    otlPreserveContent);

                if (erc != OTL_SUCCESS) return erc;
            }
            plitagLangSys->append((BYTE*)&newtag);
        }
    }

    // add the 'dflt' if it's not there and is supported
    if (!scriptTable.defaultLangSys(sec).isNull())
    {
        otlTag newtag = OTL_DEFAULT_TAG;
        if (isNewTag(cPrevTags, plitagLangSys, newtag))
        {
            if (plitagLangSys->length() + 1 > plitagLangSys->maxLength())
            {
                erc = resourceMgr.reallocOtlList(plitagLangSys, 
                                                    plitagLangSys->dataSize(), 
                                                    plitagLangSys->length() + 1, 
                                                    otlPreserveContent);

                if (erc != OTL_SUCCESS) return erc;
            }
            plitagLangSys->append((BYTE*)&newtag);
        }
    }

    return OTL_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\pairpos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  PAIRPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with pair positioning lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetSecondGlyph = 0;
const OFFSET offsetPairValues = 2;

class otlPairValueRecord: public otlTable
{
    const BYTE* pbMainTable;
    USHORT      grfValueFormat1;
    USHORT      grfValueFormat2;
public:

    otlPairValueRecord(USHORT format1, USHORT format2, 
                       const BYTE* table, const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec),
          pbMainTable(table),
          grfValueFormat1(format1),
          grfValueFormat2(format2)
    {}

    otlGlyphID secondGlyph()
    {   return GlyphID(pbTable + offsetSecondGlyph); }

    otlValueRecord valueRecord1(otlSecurityData sec)
    {   return otlValueRecord(grfValueFormat1, pbMainTable, 
                              pbTable + offsetPairValues,sec); }

    otlValueRecord valueRecord2(otlSecurityData sec)
    {   return otlValueRecord(grfValueFormat2, pbMainTable, 
                              pbTable + offsetPairValues 
                                + otlValueRecord::size(grfValueFormat1),sec);
    }

    static size(USHORT grfFormat1, USHORT grfFormat2)
    {   return sizeof(otlGlyphID) + 
                otlValueRecord::size(grfFormat1) + 
                otlValueRecord::size(grfFormat2);
    }
};


const OFFSET offsetPairValueCount = 0;
const OFFSET offsetPairValueRecordArray = 2;

class otlPairSetTable: public otlTable
{
    USHORT grfValueFormat1;
    USHORT grfValueFormat2;
public:

    otlPairSetTable(USHORT format1, USHORT format2, const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec),
          grfValueFormat1(format1),
          grfValueFormat2(format2)
    {}

    USHORT pairValueCount()
    {   return UShort(pbTable + offsetPairValueCount); }

    otlPairValueRecord pairValueRecord(USHORT index, otlSecurityData sec)
    {   assert(index < pairValueCount());
        return otlPairValueRecord(grfValueFormat1, grfValueFormat2, pbTable,
            pbTable + offsetPairValueRecordArray +
            index * otlPairValueRecord::size(grfValueFormat1, grfValueFormat2),sec);
    }
};


const OFFSET offsetPairPosCoverage = 2;
const OFFSET offsetPairPosFormat1 = 4;
const OFFSET offsetPairPosFormat2 = 6;
const OFFSET offsetPairSetCount = 8;
const OFFSET offsetPairSetArray = 10;

class otlPairPosSubTable: public otlLookupFormat
{
public:
    otlPairPosSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        assert(format() == 1);
    }

    otlCoverage coverage(otlSecurityData sec)
    {   return otlCoverage(pbTable + Offset(pbTable + offsetPairPosCoverage),sec); }

    USHORT valueFormat1()
    {   return UShort(pbTable + offsetPairPosFormat1); }

    USHORT valueFormat2()
    {   return UShort(pbTable + offsetPairPosFormat2); }

    USHORT pairSetCount()
    {   return UShort(pbTable + offsetPairSetCount); }

    otlPairSetTable pairSet(USHORT index, otlSecurityData sec)
    {   assert(index < pairSetCount());
        return otlPairSetTable(valueFormat1(), valueFormat2(),
               pbTable + Offset(pbTable + offsetPairSetArray 
                                        + index * sizeof(OFFSET)),sec);
    }
};


class otlClassValueRecord: public otlTable
{
    const BYTE* pbMainTable;
    USHORT      grfValueFormat1;
    USHORT      grfValueFormat2;
public:

    otlClassValueRecord(USHORT format1, USHORT format2, 
                        const BYTE* table, const BYTE* pb, otlSecurityData sec)
        : otlTable(pb,sec),
          pbMainTable(table),
          grfValueFormat1(format1),
          grfValueFormat2(format2)
    {}

    otlValueRecord valueRecord1(otlSecurityData sec)
    {   return otlValueRecord(grfValueFormat1, pbMainTable, pbTable,sec); }

    otlValueRecord valueRecord2(otlSecurityData sec)
    {   return otlValueRecord(grfValueFormat2, pbMainTable, 
                              pbTable + otlValueRecord::size(grfValueFormat1),sec); 
    }

    static size(USHORT grfFormat1, USHORT grfFormat2)
    {   return otlValueRecord::size(grfFormat1) +
               otlValueRecord::size(grfFormat2);
    }
};


const OFFSET offsetClassPairPosCoverage = 2;
const OFFSET offsetClassPairPosFormat1 = 4;
const OFFSET offsetClassPairPosFormat2 = 6;
const OFFSET offsetClassPairPosClassDef1 = 8;
const OFFSET offsetClassPairPosClassDef2 = 10;
const OFFSET offsetClassPairPosClass1Count = 12;
const OFFSET offsetClassPairPosClass2Count = 14;
const OFFSET offsetClassPairPosValueRecordArray = 16;

class otlClassPairPosSubTable: public otlLookupFormat
{
public:
    otlClassPairPosSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        assert(format() == 2);
    }

    otlCoverage coverage(otlSecurityData sec)
    {   return otlCoverage(pbTable + Offset(pbTable + offsetClassPairPosCoverage),sec); 
    }

    USHORT valueFormat1()
    {   return UShort(pbTable + offsetClassPairPosFormat1); }

    USHORT valueFormat2()
    {   return UShort(pbTable + offsetClassPairPosFormat2); }

    otlClassDef classDef1(otlSecurityData sec)
    {   return otlClassDef(pbTable 
                    + Offset(pbTable + offsetClassPairPosClassDef1),sec); 
    }

    otlClassDef classDef2(otlSecurityData sec)
    {   return otlClassDef(pbTable 
                    + Offset(pbTable + offsetClassPairPosClassDef2),sec); 
    }

    USHORT class1Count()
    {   return UShort(pbTable + offsetClassPairPosClass1Count); }

    USHORT class2Count()
    {   return UShort(pbTable + offsetClassPairPosClass2Count); }

    otlClassValueRecord classRecord(USHORT index1, USHORT index2, otlSecurityData sec)
    {
        assert(index1 < class1Count());
        assert(index2 < class2Count());
        return otlClassValueRecord(valueFormat1(), valueFormat2(), pbTable, 
                pbTable + offsetClassPairPosValueRecordArray + 
                (index1 * class2Count() + index2) * 
                    otlClassValueRecord::size(valueFormat1(), valueFormat2()),sec);
    }
};


class otlPairPosLookup: public otlLookupFormat
{
public:
    otlPairPosLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec) 
    {
        assert(isValid());
    }
        
    otlErrCode apply
    (
        otlList*                    pliCharMap,
        otlList*                    pliGlyphInfo,
        otlResourceMgr&             resourceMgr,

        USHORT                      grfLookupFlags,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph

        otlSecurityData             sec
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\singlpos.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  SINGLPOS.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with single positioning lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode otlSinglePosLookup::apply
(
        otlList*                    pliGlyphInfo,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph

        otlSecurityData             sec
)
{
    if (!isValid()) return OTL_NOMATCH;

    assert(pliGlyphInfo != NULL);
    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));

    assert(pliduGlyphAdv != NULL);
    assert(pliduGlyphAdv->dataSize() == sizeof(long));
    assert(pliplcGlyphPlacement != NULL);
    assert(pliplcGlyphPlacement->dataSize() == sizeof(otlPlacement));

    assert(pliduGlyphAdv->length() == pliGlyphInfo->length());
    assert(pliduGlyphAdv->length() == pliplcGlyphPlacement->length());

    assert(iglAfterLast > iglIndex);
    assert(iglAfterLast <= pliGlyphInfo->length());

    switch(format())
    {
    case(1):        // one value record
        {
            otlOneSinglePosSubTable onePos = otlOneSinglePosSubTable(pbTable,sec);

            otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
            short index = onePos.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
            if (index < 0)
            {
                return OTL_NOMATCH;
            }

            long* pduDAdv = getOtlAdvance(pliduGlyphAdv, iglIndex);
            otlPlacement* pplc = getOtlPlacement(pliplcGlyphPlacement, iglIndex);
            
            onePos.valueRecord(sec).adjustPos(metr, pplc, pduDAdv,sec);

            *piglNextGlyph = iglIndex + 1;
            return OTL_SUCCESS;
        }


    case(2):        // value record array
        {
            otlSinglePosArraySubTable arrayPos = 
                    otlSinglePosArraySubTable(pbTable,sec);

            otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);

            short index = arrayPos.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
            if (index < 0)
            {
                return OTL_NOMATCH;
            }

            if (index >= arrayPos.valueCount())
            {
                return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
            }

            long* pduDAdv = getOtlAdvance(pliduGlyphAdv, iglIndex);
            otlPlacement* pplc = getOtlPlacement(pliplcGlyphPlacement, iglIndex);
            
            arrayPos.valueRecord(index,sec).adjustPos(metr, pplc, pduDAdv,sec);

            *piglNextGlyph = iglIndex + 1;
            return OTL_SUCCESS;
        }

    default:
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\gpotls\pch.h ===
/***********************************************************************
************************************************************************
*
*                    ********  PCH.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This header includes all other headers in the right order
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#define OTL_CONSTANT    const

#include "runtime.hpp"   // GdiPlus runtime, including private memory allocation

#define GDIPLUS     1
#include "text_rt.h"

#include "otllib.h"

#undef assert
#define assert      ASSERT

#include "common.h"
#include "common.inl"

#include "resource.h"

#include "coverage.h"
#include "classdef.h"
#include "device.h"

#include "base.h"

#include "scrilang.h"
#include "lookups.h"
#include "features.h"

#include "GDEF.h"
#include "GSUB.h"
#include "GPOS.h"

#include "apply.h"
#include "measure.h"

/***********************************************************************/

#include "singlsub.h"
#include "multisub.h"
#include "altersub.h"
#include "ligasub.h"

#include "singlpos.h"
#include "pairpos.h"
#include "cursipos.h"
#include "mkbaspos.h"
#include "mkligpos.h"
#include "mkmkpos.h"

#include "context.h"
#include "chaining.h"
#include "extension.h"

/***********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\singlsub.h ===
/***********************************************************************
************************************************************************
*
*                    ********  SINGLSUB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with single substitution lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetCalculatedSingleCoverage = 2;
const OFFSET offsetDeltaGlyphID = 4;

class otlCalculatedSingleSubTable: public otlLookupFormat
{
public:

    otlCalculatedSingleSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        assert(format() == 1);
    }

    otlCoverage coverage(otlSecurityData sec)
    {   return otlCoverage(pbTable + 
                    Offset(pbTable + offsetCalculatedSingleCoverage),sec);
    }

    short deltaGlyphID()
    {   return SShort(pbTable + offsetDeltaGlyphID); }
};

const OFFSET offsetListSingleSubTableCoverage = 2;
const OFFSET offsetSingleGlyphCount = 4;
const OFFSET offsetSingleSubstituteArray = 6;

class otlListSingleSubTable: public otlLookupFormat
{
public:

    otlListSingleSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        assert(format() == 2);
    }

    otlCoverage coverage(otlSecurityData sec)
    {   return otlCoverage(pbTable + 
                    Offset(pbTable + offsetListSingleSubTableCoverage),sec);
    }
    

    USHORT glyphCount()
    {   return UShort(pbTable + offsetSingleGlyphCount); }

    otlGlyphID substitute(USHORT index)
    {   assert(index < glyphCount());
        return GlyphID(pbTable + offsetSingleSubstituteArray 
                                + index * sizeof(otlGlyphID));
    }
};


class otlSingleSubstLookup: public otlLookupFormat
{
public:

    otlSingleSubstLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec) 
    {
        assert(isValid());
    }
    
    otlErrCode apply
    (
    otlList*            pliGlyphInfo,

    USHORT              iglIndex,
    USHORT              iglAfterLast,

    USHORT*             piglNextGlyph,      // out: next glyph

    otlSecurityData             sec
    );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\sources.inc ===
!include "..\..\..\..\sources.inc"
DEBUG_CRTS = 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\singlsub.cpp ===
/***********************************************************************
************************************************************************
*
*                    ********  SINGLSUB.CPP  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with single substitution lookups
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#include "pch.h"

/***********************************************************************/

otlErrCode otlSingleSubstLookup::apply
(
    otlList*                    pliGlyphInfo,

    USHORT                      iglIndex,
    USHORT                      iglAfterLast,

    USHORT*                     piglNextGlyph,      // out: next glyph

    otlSecurityData             sec
)
{
    if (!isValid()) return OTL_NOMATCH;

    assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
    assert(iglAfterLast > iglIndex);
    assert(iglAfterLast <= pliGlyphInfo->length());

    switch(format())
    {
    case(1):        // calculated
        {
            otlCalculatedSingleSubTable calcSubst = 
                    otlCalculatedSingleSubTable(pbTable,sec);
            otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
            
            short index = calcSubst.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
            if (index < 0)
            {
                return OTL_NOMATCH;
            }

            pGlyphInfo->glyph += calcSubst.deltaGlyphID();

            *piglNextGlyph = iglIndex + 1;
            return OTL_SUCCESS;
        }


    case(2):        // glyph list
        {
            otlListSingleSubTable listSubst = otlListSingleSubTable(pbTable,sec);
            otlGlyphInfo* pGlyphInfo = getOtlGlyphInfo(pliGlyphInfo, iglIndex);
            
            short index = listSubst.coverage(sec).getIndex(pGlyphInfo->glyph,sec);
            if (index < 0)
            {
                return OTL_NOMATCH;
            }

            if (index > listSubst.glyphCount())
            {
                return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
            }

            pGlyphInfo->glyph = listSubst.substitute(index);

            *piglNextGlyph = iglIndex + 1;
            return OTL_SUCCESS;
        }

    default:
        return OTL_NOMATCH; //OTL_ERR_BAD_FONT_TABLE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\singlpos.h ===
/***********************************************************************
************************************************************************
*
*                    ********  SINGLPOS.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with single positioning lookup.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetSinglPosCoverage = 2;
const OFFSET offsetSinglePosValueFormat = 4;
const OFFSET offsetSinglePosValueRecord = 6;

class otlOneSinglePosSubTable: public otlLookupFormat
{
public:
    otlOneSinglePosSubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec) 
    {
        assert(format() == 1);
    }

    otlCoverage coverage(otlSecurityData sec)
    {   return otlCoverage(pbTable + Offset(pbTable + offsetSinglPosCoverage),sec); }

    USHORT valueFormat()
    {   return UShort(pbTable + offsetSinglePosValueFormat); }

    otlValueRecord valueRecord(otlSecurityData sec)
    {   return otlValueRecord(valueFormat(), pbTable, 
                    pbTable + offsetSinglePosValueRecord,sec); 
    }
};


const OFFSET offsetSinglPosArrayCoverage = 2;
const OFFSET offsetSinglePosArrayValueFormat = 4;
const OFFSET offsetSinglePosArrayValueCount = 6;
const OFFSET offsetSinglePosValueRecordArray = 8;

class otlSinglePosArraySubTable: public otlLookupFormat
{
public:
    otlSinglePosArraySubTable(const BYTE* pb, otlSecurityData sec): otlLookupFormat(pb,sec)
    {
        assert(format() == 2);
    }

    otlCoverage coverage(otlSecurityData sec)
    {   return otlCoverage(pbTable 
                    + Offset(pbTable + offsetSinglPosArrayCoverage),sec); 
    }

    USHORT valueFormat()
    {   return UShort(pbTable + offsetSinglePosArrayValueFormat); }

    USHORT valueCount()
    {   return UShort(pbTable + offsetSinglePosArrayValueCount); }

    otlValueRecord valueRecord(USHORT index, otlSecurityData sec)
    {   assert(index < valueCount());   
        return otlValueRecord(valueFormat(), pbTable, 
                              pbTable + offsetSinglePosValueRecordArray
                            + index * otlValueRecord::size(valueFormat()),sec); 
    }
    
};


class otlSinglePosLookup: public otlLookupFormat
{
public:
    otlSinglePosLookup(otlLookupFormat subtable, otlSecurityData sec)
        : otlLookupFormat(subtable.pbTable,sec) 
    {
        assert(isValid());
    }
    
    otlErrCode apply
    (
        otlList*                    pliGlyphInfo,

        const otlMetrics&           metr,       
        otlList*                    pliduGlyphAdv,              
        otlList*                    pliplcGlyphPlacement,       

        USHORT                      iglIndex,
        USHORT                      iglAfterLast,

        USHORT*                     piglNextGlyph,      // out: next glyph

        otlSecurityData             sec
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\scrilang.h ===
/***********************************************************************
************************************************************************
*
*                    ********  SCRILANG.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module deals with formats of script and lang system tables.
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

const OFFSET offsetLookupOrder = 0;
const OFFSET offsetReqFeatureIndex = 2;
const OFFSET offsetLangFeatureCount = 4;
const OFFSET offsetLangFeatureIndexArray = 6;

const SIZE sizeLangSysTable = sizeOFFSET + 3*sizeUSHORT;

class otlLangSysTable: public otlTable
{
public:

    otlLangSysTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        //could be null, if invlalid set NULL
        if (pb && !isValidTableWithArray(pb,sizeLangSysTable,offsetLangFeatureCount,sizeUSHORT,sec))
            pbTable=(BYTE*)NULL;
    }

    USHORT reqFeatureIndex() const
    {   
        assert(pbTable); //should break before calling

        return UShort(pbTable + offsetReqFeatureIndex);
    }

    USHORT featureCount() const
    {   
        assert(pbTable); //should break before calling
        
        return UShort(pbTable + offsetLangFeatureCount); 
    }

    USHORT featureIndex(USHORT index) const
    {   
        assert(pbTable); //should break before calling

        assert(index < featureCount());
        return UShort(pbTable + offsetLangFeatureIndexArray
                              + index*sizeof(USHORT));
    }
};


const OFFSET offsetLangSysTag = 0;
const OFFSET offsetLangSys = 4;
const SIZE sizeLangSysRecord = sizeTAG + sizeOFFSET;

class otlLangSysRecord: public otlTable
{

private:
    const BYTE* pbScriptTable;

public:
    otlLangSysRecord(const BYTE* pbScript, const BYTE* pbRecord, otlSecurityData sec)
        : otlTable(pbRecord,sec),
          pbScriptTable(pbScript)
    {
        assert(isValidTable(pbRecord,sizeLangSysRecord,sec)); //it has been checked in ScriptTable
    }

    otlLangSysRecord& operator = (const otlLangSysRecord& copy)
    {
        assert(isValid()); //shoud break before calling;
        
        pbTable = copy.pbTable;
        pbScriptTable = copy.pbScriptTable;
        return *this;
    }

    otlTag langSysTag() const
    {   
        assert(isValid()); //shoud break before calling;
        
        return *(UNALIGNED otlTag*)(pbTable + offsetLangSysTag); 
    }

    otlLangSysTable langSysTable(otlSecurityData sec) const
    {   
        assert(isValid()); //shoud break before calling;
    
        return otlLangSysTable(pbScriptTable + Offset(pbTable + offsetLangSys), sec); 
    }

};


const OFFSET offsetDefaultLangSys = 0;
const OFFSET offsetLangSysCount = 2;
const OFFSET offsetLangSysRecordArray = 4;
const SIZE   sizeScriptTable=sizeOFFSET + sizeUSHORT;

class otlScriptTable: public otlTable
{
public:

    otlScriptTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeScriptTable,offsetLangSysCount,sizeLangSysRecord,sec))
            setInvalid();
    }

    otlLangSysTable defaultLangSys(otlSecurityData sec) const
    {   
        assert(isValid()); //should break before calling
        
        if (Offset(pbTable + offsetDefaultLangSys) == 0)
            return otlLangSysTable((const BYTE*)NULL, sec);
        return otlLangSysTable(pbTable + Offset(pbTable + offsetDefaultLangSys), sec);
    }

    USHORT langSysCount() const
    {   
        assert(isValid()); //should break before calling

        return UShort(pbTable + offsetLangSysCount); 
    }

    otlLangSysRecord langSysRecord(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid()); //should break before calling
        if (index >= langSysCount()) return otlLangSysRecord(pbTable,pbInvalidData,sec);

        assert(index < langSysCount());
        return otlLangSysRecord(pbTable, pbTable + offsetLangSysRecordArray
                                                 + index*sizeLangSysRecord, sec);
    }
};



const OFFSET offsetScriptTag = 0;
const OFFSET offsetScript = 4;
const USHORT sizeScriptRecord = sizeTAG + sizeOFFSET;

class otlScriptRecord: public otlTable
{
private:
    const BYTE* pbMainTable;

public:

    otlScriptRecord(const BYTE* pbList, const BYTE* pbRecord, otlSecurityData sec)
        : otlTable(pbRecord,sec),
          pbMainTable(pbList)
    {
        assert(isValid()); //should be checked in ScriptList and break before calling
    }

    otlScriptRecord& operator = (const otlScriptRecord& copy)
    {
        assert(isValid()); //should break before calling

        pbTable = copy.pbTable;
        pbMainTable = copy.pbMainTable;
        return *this;
    }

    otlTag scriptTag() const
    {   
        assert(isValid()); //should break before calling

        return *(UNALIGNED otlTag*)(pbTable + offsetScriptTag); 
    }

    otlScriptTable scriptTable(otlSecurityData sec) const
    {   
        assert(isValid()); //should break before calling

        return otlScriptTable(pbMainTable + Offset(pbTable + offsetScript), sec); 
    }

};


const OFFSET offsetScriptCount = 0;
const OFFSET offsetScriptRecordArray = 2;
const SIZE   sizeScriptList = sizeUSHORT;

class otlScriptListTable: public otlTable
{
public:

    otlScriptListTable(const BYTE* pb, otlSecurityData sec): otlTable(pb,sec) 
    {
        if (!isValidTableWithArray(pb,sizeScriptList,offsetScriptCount,sizeScriptRecord,sec))
            setInvalid();
    }

    USHORT scriptCount() const
    {   
        assert(isValid());   //should break before calling

        return UShort(pbTable + offsetScriptCount); 
    }

    otlScriptRecord scriptRecord(USHORT index, otlSecurityData sec) const
    {   
        assert(isValid());   //should break before calling

        assert(index < scriptCount());
        return otlScriptRecord(pbTable,
                 pbTable + offsetScriptRecordArray + index*sizeScriptRecord, sec);
    }
};


// helper functions

// returns a NULL script if not found
otlScriptTable FindScript
(
    const otlScriptListTable&   scriptList,
    otlTag                      tagScript, 
    otlSecurityData sec
);

// returns a NULL language system if not found
otlLangSysTable FindLangSys
(
    const otlScriptTable&   scriptTable,
    otlTag                  tagLangSys, 
    otlSecurityData sec
);

// append script tags to the otl list; ask for more memory if needed
otlErrCode AppendScriptTags
(
    const otlScriptListTable&       scriptList,

    otlList*                        plitagScripts,
    otlResourceMgr&                 resourceMgr,
    otlSecurityData sec

);

// append lang system tags to the otl list; ask for more memory if needed
// the desired script is in prp->tagScript
otlErrCode AppendLangSysTags
(
    const otlScriptListTable&       scriptList,
    otlTag                          tagScript,

    otlList*                        plitagLangSys,
    otlResourceMgr&                 resourceMgr,
    otlSecurityData sec
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\otls\otls\pch.h ===
/***********************************************************************
************************************************************************
*
*                    ********  PCH.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This header includes all other headers in the right order
*
*       Copyright 1997 - 1998. Microsoft Corporation.
*
*
************************************************************************
***********************************************************************/

#define OTL_CONSTANT    const

#define USP_DLL  1
#include "text_rt.h"
#include "usp_dbg.hxx"

#include "otllib.h"

#undef assert
#define assert   ASSERT

#include "common.h"
#include "common.inl"

#include "resource.h"

#include "coverage.h"
#include "classdef.h"
#include "device.h"

#include "base.h"

#include "scrilang.h"
#include "lookups.h"
#include "features.h"

#include "GDEF.h"
#include "GSUB.h"
#include "GPOS.h"

#include "apply.h"
#include "measure.h"

/***********************************************************************/

#include "singlsub.h"
#include "multisub.h"
#include "altersub.h"
#include "ligasub.h"

#include "singlpos.h"
#include "pairpos.h"
#include "cursipos.h"
#include "mkbaspos.h"
#include "mkligpos.h"
#include "mkmkpos.h"

#include "context.h"
#include "chaining.h"
#include "extension.h"

/***********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\unilib\classify.cxx ===
#ifndef X__UNIPART_H
#define X__UNIPART_H
#include "unipart.hxx"
#endif

#include "windows.h"
#include "assert.h"


//+----------------------------------------------------------------------------
//
//  Function:   CharClassFromCh
//
//  Synopsis:   Given a character return a Unicode character class.  This
//              character class implies other properties, such as script id,
//              breaking class, etc.
//
//      Note:   pccUnicodeClass is a hack table.  For every Unicode page for
//              which every codepoint is the same value, the table entry is
//              the charclass itself.  Otherwise we have a pointer to a table
//              of charclass.
//
//-----------------------------------------------------------------------------

CHAR_CLASS __stdcall
CharClassFromCh(INT wch)
{
    // either Unicode plane 0 or in surrogate range
    assert(wch <= 0x10FFFF);

    // Plane 0 codepoint
    if( wch <= 0xFFFF)
    {
        const CHAR_CLASS * const pcc = pccUnicodeClass[(wch & 0xFFFF)>>8];
        const UINT_PTR icc = UINT_PTR(pcc);

        return (CHAR_CLASS)(icc < CHAR_CLASS_UNICODE_MAX ? icc : pcc[wch & 0xff]);
    }
    else if(   ((wch >= 0x00010000) && (wch <= 0x0001FFFF))
            || ((wch >= 0x00040000) && (wch <= 0x0010FFFF)))
    {
        // non-Han surrogates - high ranges D800-D83F and D8C0 - DBFF
        return NHS_;
    }
    else if((wch >= 0x00020000) && (wch <= 0x0003FFFF))
    {
        // Han surrogates - high range D840 - D8BF
        return WHT_;
    }
    else
    {
        // Currently, we don't have any plane1 or higher allocation.
        // Let's treat it as unassigned codepoint.
        return XNW_;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\unilib\mirror.cxx ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   Mirrored Helper
*
* Abstract:
*
*   Contains Mirrorred codepoints helper routines
*
*
* Revision History:
*
*   05/15/2000 Mohamed Sadek [msadek]
*       Created it.
*
\**************************************************************************/
#include "windows.h"
    const INT acc_00[256] = // U+00xx
    {
    //0    1      2      3      4      5      6      7      8      9      A      B      C      D      E      F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 00 - 0F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 10 - 1F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0029,0x0028,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 20 - 2F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x003E,0x0000,0x003C,0x0000, // 30 - 3F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 40 - 4F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x005D,0x0000,0x005B,0x0000,0x0000, // 50 - 5F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 60 - 6F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x007D,0x0000,0x007B,0x0000,0x0000, // 70 - 7F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 80 - 8F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 90 - 9F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x00BB,0x0000,0x0000,0x0000,0x0000, // A0 - AF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x00AB,0x0000,0x0000,0x0000,0x0000, // B0 - BF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // C0 - CF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // D0 - DF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // E0 - EF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // F0 - FF
    };

    const INT acc_20[256] = // U+20xx
    {
    //0    1      2      3      4      5      6      7      8      9      A      B      C      D      E      F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 00 - 0F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 10 - 1F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 20 - 2F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x203A,0x2039,0x0000,0x0000,0x0000,0x0000,0x0000, // 30 - 3F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x2046,0x2045,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 40 - 4F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 50 - 5F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 60 - 6F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x207E,0x207D,0x0000, // 70 - 7F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x208E,0x208D,0x0000, // 80 - 8F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 90 - 9F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // A0 - AF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // B0 - BF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // C0 - CF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // D0 - DF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // E0 - EF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // F0 - FF
    };
    
    const INT acc_22[256] = // U+22xx
    {
    //0    1      2      3      4      5      6      7      8      9      A      B      C      D      E      F
    0x0000,0x2201,0x2202,0x2203,0x2204,0x0000,0x0000,0x0000,0x220B,0x220C,0x220D,0x2208,0x2209,0x220A,0x0000,0x0000, // 00 - 0F
    0x0000,0x2211,0x0000,0x0000,0x0000,0x2216,0x2215,0x0000,0x0000,0x0000,0x221A,0x221B,0x221C,0x221D,0x0000,0x221F, // 10 - 1F
    0x2220,0x2221,0x2222,0x0000,0x2224,0x0000,0x2226,0x0000,0x0000,0x0000,0x0000,0x222B,0x222C,0x222D,0x222E,0x222F, // 20 - 2F
    0x2230,0x2231,0x2232,0x2233,0x0000,0x0000,0x0000,0x0000,0x0000,0x2239,0x0000,0x223B,0x223D,0x223C,0x223E,0x223F, // 30 - 3F
    0x2240,0x2241,0x2242,0x22CD,0x2244,0x2245,0x2246,0x2247,0x2248,0x2249,0x224A,0x224B,0x224C,0x0000,0x0000,0x0000, // 40 - 4F
    0x0000,0x0000,0x2253,0x2252,0x2255,0x2254,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x225F, // 50 - 5F
    0x2260,0x0000,0x2262,0x0000,0x2265,0x2264,0x2267,0x2266,0x2269,0x2268,0x226B,0x226A,0x0000,0x0000,0x226F,0x226E, // 60 - 6F
    0x2271,0x2270,0x2273,0x2272,0x2275,0x2274,0x2277,0x2276,0x2279,0x2278,0x227B,0x227A,0x227D,0x227C,0x227F,0x227E, // 70 - 7F
    0x2281,0x2280,0x2283,0x2282,0x2285,0x2284,0x2287,0x2286,0x2289,0x2288,0x228B,0x228A,0x228C,0x0000,0x0000,0x2290, // 80 - 8F
    0x228F,0x2292,0x2291,0x0000,0x0000,0x0000,0x0000,0x0000,0x2298,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 90 - 9F
    0x0000,0x0000,0x22A3,0x22A2,0x0000,0x0000,0x22A6,0x22A7,0x22A8,0x22A9,0x22AA,0x22AB,0x22AC,0x22AD,0x22AE,0x22AF, // A0 - AF
    0x22B1,0x22B0,0x22B3,0x22B2,0x22B5,0x22B4,0x22B7,0x22B6,0x22B8,0x0000,0x0000,0x0000,0x0000,0x0000,0x22BE,0x22BF, // B0 - BF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x22CA,0x22C9,0x22CC,0x22CB,0x2243,0x0000,0x0000, // C0 - CF
    0x22D1,0x22D0,0x0000,0x0000,0x0000,0x0000,0x22D7,0x22D6,0x22D9,0x22D8,0x22DB,0x22DA,0x22DD,0x22DC,0x22DF,0x22DE, // D0 - DF
    0x22E1,0x22E0,0x22E3,0x22E2,0x22E5,0x22E4,0x22E7,0x22E6,0x22E9,0x22E8,0x22EB,0x22EA,0x22ED,0x22EC,0x0000,0x0000, // E0 - EF
    0x22F1,0x22F0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // F0 - FF
    };
    

    const INT acc_23[256] = // U+23xx
    {
    //0    1      2      3      4      5      6      7      8      9      A      B      C      D      E      F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2309,0x2308,0x230B,0x230A,0x0000,0x0000,0x0000,0x0000, // 00 - 0F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 10 - 1F
    0x2320,0x2321,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x232A,0x2329,0x0000,0x0000,0x0000,0x0000,0x0000, // 20 - 2F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 30 - 3F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 40 - 4F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 50 - 5F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 60 - 6F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 70 - 7F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 80 - 8F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 90 - 9F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // A0 - AF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // B0 - BF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // C0 - CF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // D0 - DF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // E0 - EF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // F0 - FF
    };

    const INT acc_30[256] = // U+30xx
    {
    //0    1      2      3      4      5      6      7      8      9      A      B      C      D      E      F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x3009,0x3008,0x300B,0x300A,0x300C,0x300D,0x300E,0x300F, // 00 - 0F
    0x3011,0x3010,0x0000,0x0000,0x3014,0x3015,0x3017,0x3016,0x3019,0x3018,0x301B,0x301A,0x0000,0x0000,0x0000,0x0000, // 10 - 1F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 20 - 2F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 30 - 3F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 40 - 4F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 50 - 5F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 60 - 6F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 70 - 7F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 80 - 8F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // 90 - 9F
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // A0 - AF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // B0 - BF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // C0 - CF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // D0 - DF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000, // E0 - EF
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // F0 - FF
    };

    const INT * const pccUnicodeLevel1[256] =
    {
    acc_00, NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 00 - 07
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 08 - 0F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 10 - 17
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 18 - 1F
    acc_20, NULL,   acc_22, acc_23, NULL,   NULL,   NULL,   NULL,    // 20 - 27
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 28 - 2F
    acc_30, NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 30 - 37
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 38 - 3F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 40 - 47
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 48 - 4F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 50 - 57
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 58 - 5F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 60 - 67
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 68 - 6F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 70 - 77
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 78 - 7F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 80 - 87
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 88 - 8F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 90 - 97
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // 98 - 9F
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // A0 - A7
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // A8 - AF
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // B0 - B7
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // B8 - BF
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // C0 - C7
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // C8 - CF
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // D0 - D7
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // D8 - DF
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // E0 - E7
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // E8 - EF
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // F0 - F7
    NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,    // F8 - FF
    };

//
// GetMirroredCodepoint
//
// if the passed codepoint has a valid mirrored codepoint, it return it.
// otherwise it returns the original passed codepoint.

INT __stdcall
GetMirroredCodepoint(INT codepoint)
{
    if(codepoint > 0xFFFF)
    {
        // no surrogates mirrored codepoint so far
        return codepoint;
    }
    const INT *pcc;
    if(!(pcc = pccUnicodeLevel1[(codepoint & 0xFFFF)>>8]))
    {
        return codepoint;
    }
    
    // No parameter validation for performace.
    INT mirroredCodepoint = pcc[codepoint & 0xff];
    return mirroredCodepoint==0 ? codepoint : mirroredCodepoint;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\unilib\secondaryclassification.cpp ===
#include "SecondaryClassification.hpp"

///// SecondaryClassification
//
//    Provides classification for digit substitution, symmetric glyph
//    mirroring and auto vertical glyph rotoation.
//
//    DO NOT EDIT
//
//    Generated by engine/text/unilib/tools/upright.pl

const unsigned char ScBaseToScFlags[] = {
/*ScCSAN*/    SecClassCS | SecClassSA,
/*ScCSNN*/    SecClassCS,
/*ScENAN*/    SecClassEN | SecClassSA,
/*ScENNN*/    SecClassEN,
/*ScETAN*/    SecClassET | SecClassSA,
/*ScETNN*/    SecClassET,
/*ScNNAN*/    SecClassSA,
/*ScNNAS*/    SecClassSA | SecClassMS,
/*ScNNFN*/    SecClassSF,
/*ScNNNN*/    0,
/*ScNNNS*/    SecClassMS,
};

const SecondaryClassification ScFlagsToScFE[] = {
    ScOther,  ScEN,     ScCS,     ScET,     // 00 - 03
    ScMirSub, ScMirSub, ScMirSub, ScMirSub, // 04 - 07 MS
    ScMirXfm, ScMirXfm, ScMirXfm, ScMirXfm, // 08 - 0C MX
    ScOther,  ScOther,  ScOther,  ScOther,  // 0D - 0F invalid
    ScSide,   ScSide,   ScSide,   ScSide,   // 10 - 13 SA
    ScSide,   ScSide,   ScSide,   ScSide,   // 14 - 17 SA MS
    ScSide,   ScSide,   ScSide,   ScSide,   // 18 - 1C SA MX
    ScOther,  ScOther,  ScOther,  ScOther,  // 1D - 1F invalid
    ScSide,   ScSide,   ScSide,   ScSide,   // 20 - 23 SF
    ScSide,   ScSide,   ScSide,   ScSide,   // 24 - 27 SF MS
    ScSide,   ScSide,   ScSide,   ScSide,   // 28 - 2C SF MX
    ScOther,  ScOther,  ScOther,  ScOther,  // 2D - 2F invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 30 - 33 invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 34 - 37 invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 38 - 3C invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 3D - 3F invalid
};

const SecondaryClassification ScFlagsToScEng[] = {
    ScOther,  ScEN,     ScCS,     ScET,     // 00 - 03
    ScMirSub, ScMirSub, ScMirSub, ScMirSub, // 04 - 07 MS
    ScMirXfm, ScMirXfm, ScMirXfm, ScMirXfm, // 08 - 0C MX
    ScOther,  ScOther,  ScOther,  ScOther,  // 0D - 0F invalid
    ScSide,   ScSide,   ScSide,   ScSide,   // 10 - 13 SA
    ScSide,   ScSide,   ScSide,   ScSide,   // 14 - 17 SA MS
    ScSide,   ScSide,   ScSide,   ScSide,   // 18 - 1C SA MX
    ScOther,  ScOther,  ScOther,  ScOther,  // 1D - 1F invalid
    ScOther,  ScEN,     ScCS,     ScET,     // 20 - 23 SF
    ScMirSub, ScMirSub, ScMirSub, ScMirSub, // 24 - 27 SF MS
    ScMirXfm, ScMirXfm, ScMirXfm, ScMirXfm, // 28 - 2C SF MX
    ScOther,  ScOther,  ScOther,  ScOther,  // 2D - 2F invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 30 - 33 invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 34 - 37 invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 38 - 3C invalid
    ScOther,  ScOther,  ScOther,  ScOther,  // 3D - 3F invalid
};


unsigned char ScPage00[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScETNN, ScETNN, ScETNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, ScETNN, ScCSNN, ScETNN, ScCSNN, ScNNNN, 
  ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScCSNN, ScNNNN, ScNNNS, ScNNNN, ScNNNS, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNN, ScNNNS, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNN, ScNNNS, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScCSNN, ScNNNN, ScETNN, ScETNN, ScETNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScETNN, ScETNN, ScENNN, ScENNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScENNN, ScNNNN, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage06[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScCSNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage09[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScETNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage0E[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage17[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage20[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScENNN, ScNNNN, ScNNNN, ScNNNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScETNN, ScETNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, 
  ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScENNN, ScETNN, ScETNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, ScETNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage21[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage22[] = {
  ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNS, ScETNN, ScETNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNS, ScNNNN, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, 
  ScNNNS, ScNNNN, ScNNNS, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNS, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, 
  ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, 
  ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, 
  ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage23[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNS, ScNNNS, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage24[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, 
  ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, 
  ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, 
  ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScENAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
};

unsigned char ScPage25[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
};

unsigned char ScPage2E[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
};

unsigned char ScPage2F[] = {
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPage30[] = {
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, 
  ScNNAS, ScNNAS, ScNNAN, ScNNAN, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAS, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
};

unsigned char ScPage31[] = {
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPageA4[] = {
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPageD7[] = {
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPageD8[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPageDB[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
};

unsigned char ScPageFB[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPageFE[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScCSNN, ScNNNN, ScCSNN, ScNNNN, ScNNNN, ScCSNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, 
  ScNNNN, ScNNNN, ScETNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScETNN, ScETNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};

unsigned char ScPageFF[] = {
  ScNNAN, ScNNAN, ScNNAN, ScETAN, ScETAN, ScETAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScETAN, ScCSAN, ScETAN, ScCSAN, ScNNAN, 
  ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScENAN, ScCSAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScETAN, ScETAN, ScNNAN, ScNNAN, ScNNAN, ScETAN, ScETAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};



/// Classes used for entire pages
//

unsigned char ScPgNNAN[] = {
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
  ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, ScNNAN, 
};

unsigned char ScPgNNFN[] = {
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
  ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, ScNNFN, 
};

unsigned char ScPgNNNN[] = {
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
  ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, ScNNNN, 
};



const unsigned char *SecondaryClassificationLookup[] = {
  ScPage00, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPage06, ScPgNNNN, ScPgNNNN, ScPage09, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPage0E, ScPgNNNN, 
  ScPgNNNN, ScPgNNAN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPage17, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, 
  ScPage20, ScPage21, ScPage22, ScPage23, ScPage24, ScPage25, ScPgNNAN, ScPgNNAN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPage2E, ScPage2F, 
  ScPage30, ScPage31, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPageA4, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, 
  ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPgNNAN, ScPageD7, ScPageD8, ScPgNNNN, ScPgNNNN, ScPageDB, ScPgNNNN, ScPgNNNN, ScPgNNNN, ScPgNNNN, 
  ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, 
  ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNFN, ScPgNNAN, ScPgNNAN, ScPageFB, ScPgNNNN, ScPgNNNN, ScPageFE, ScPageFF, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\unilib\linebreakclass.cxx ===
//
// This is a generated file.  Do not modify by hand.
//
// Copyright (c) 2000  Microsoft Corporation
//
// Generating script: breakclass_extract.pl
// Generated on Wed Jun  6 01:24:48 2001
//

#ifndef X__UNIPART_H
#define X__UNIPART_H
#include "unipart.hxx"
#endif // !X__UNIPART_H

#include "brkclass.hxx"


const unsigned short BreakClassFromCharClassNarrow[CHAR_CLASS_UNICODE_MAX] =
{
    1   ,  // (  0) WOB_ - Open brackets for inline-note
    1   ,  // (  1) NOPP - Open parenthesis
    1   ,  // (  2) NOPA - Open parenthesis
    1   ,  // (  3) NOPW - Open parenthesis
    1   ,  // (  4) HOP_ - Open parenthesis
    1   ,  // (  5) WOP_ - Open parenthesis
    1   ,  // (  6) WOP5 - Open parenthesis, Big 5
    14  ,  // (  7) NOQW - Open quotes
    14  ,  // (  8) AOQW - Open quotes
    1   ,  // (  9) WOQ_ - Open quotes
    2   ,  // ( 10) WCB_ - Close brackets for inline-note
    2   ,  // ( 11) NCPP - Close parenthesis
    2   ,  // ( 12) NCPA - Close parenthesis
    2   ,  // ( 13) NCPW - Close parenthesis
    2   ,  // ( 14) HCP_ - Close parenthesis
    2   ,  // ( 15) WCP_ - Close parenthesis
    2   ,  // ( 16) WCP5 - Close parenthesis, Big 5
    14  ,  // ( 17) NCQW - Close quotes
    14  ,  // ( 18) ACQW - Close quotes
    2   ,  // ( 19) WCQ_ - Close quotes
    14  ,  // ( 20) ARQW - Right single quotation mark
    15  ,  // ( 21) NCSA - Comma
    2   ,  // ( 22) HCO_ - Comma
    2   ,  // ( 23) WC__ - Comma
    2   ,  // ( 24) WCS_ - Comma
    2   ,  // ( 25) WC5_ - Comma, Big 5
    2   ,  // ( 26) WC5S - Comma, Big 5
    3   ,  // ( 27) NKS_ - Kana Sound marks
    3   ,  // ( 28) WKSM - Kana Sound marks
    3   ,  // ( 29) WIM_ - Iteration mark
    3   ,  // ( 30) NSSW - Symbols which can't start a line
    3   ,  // ( 31) WSS_ - Symbols which can't start a line
    3   ,  // ( 32) WHIM - Hiragana iteration marks
    3   ,  // ( 33) WKIM - Katakana iteration marks
    3   ,  // ( 34) NKSL - Katakana that can't start a line
    3   ,  // ( 35) WKS_ - Katakana that can't start a line
    20  ,  // ( 36) WKSC - Katakana that can't start a line
    3   ,  // ( 37) WHS_ - Hiragana that can't start a line
    4   ,  // ( 38) NQFP - Question/exclamation
    4   ,  // ( 39) NQFA - Question/exclamation
    3   ,  // ( 40) WQE_ - Question/exclamation
    3   ,  // ( 41) WQE5 - Question/exclamation, Big 5
    3   ,  // ( 42) NKCC - Kana centered characters
    3   ,  // ( 43) WKC_ - Kana centered characters
    15  ,  // ( 44) NOCP - Other centered characters
    15  ,  // ( 45) NOCA - Other centered characters
    15  ,  // ( 46) NOCW - Other centered characters
    3   ,  // ( 47) WOC_ - Other centered characters
    3   ,  // ( 48) WOCS - Other centered characters
    3   ,  // ( 49) WOC5 - Other centered characters, Big 5
    3   ,  // ( 50) WOC6 - Other centered characters, Big 5
    3   ,  // ( 51) AHPW - Hyphenation point
    15  ,  // ( 52) NPEP - Period
    15  ,  // ( 53) NPAR - Period
    3   ,  // ( 54) HPE_ - Period
    3   ,  // ( 55) WPE_ - Period
    3   ,  // ( 56) WPES - Period
    3   ,  // ( 57) WPE5 - Period, Big 5
    5   ,  // ( 58) NISW - Inseparable characters
    5   ,  // ( 59) AISW - Inseparable characters
    12  ,  // ( 60) NQCS - Glue characters
    12  ,  // ( 61) NQCW - Glue characters
    12  ,  // ( 62) NQCC - Glue characters
    6   ,  // ( 63) NPTA - Prefix currencies and symbols
    6   ,  // ( 64) NPNA - Prefix currencies and symbols
    6   ,  // ( 65) NPEW - Prefix currencies and symbols
    6   ,  // ( 66) NPEH - Prefix currencies and symbols
    6   ,  // ( 67) NPEV - Prefix currencies and symbols
    6   ,  // ( 68) APNW - Prefix currencies and symbols
    6   ,  // ( 69) HPEW - Prefix currencies and symbols
    6   ,  // ( 70) WPR_ - Prefix currencies and symbols
    7   ,  // ( 71) NQEP - Postfix currencies and symbols
    7   ,  // ( 72) NQEW - Postfix currencies and symbols
    7   ,  // ( 73) NQNW - Postfix currencies and symbols
    7   ,  // ( 74) AQEW - Postfix currencies and symbols
    7   ,  // ( 75) AQNW - Postfix currencies and symbols
    7   ,  // ( 76) AQLW - Postfix currencies and symbols
    7   ,  // ( 77) WQO_ - Postfix currencies and symbols
    21  ,  // ( 78) NSBL - Space
    8   ,  // ( 79) WSP_ - Space
    8   ,  // ( 80) WHI_ - Hiragana, except small letters
    8   ,  // ( 81) NKA_ - Katakana, except small letters
    8   ,  // ( 82) WKA_ - Katakana, except small letters
    11  ,  // ( 83) ASNW - Ambiguous symbols, Latin, Greek, Cyrillic
    11  ,  // ( 84) ASEW - Ambiguous symbols, Latin, Greek, Cyrillic
    11  ,  // ( 85) ASRN - Ambiguous symbols, Latin, Greek, Cyrillic
    11  ,  // ( 86) ASEN - Ambiguous symbols, Latin, Greek, Cyrillic
    11  ,  // ( 87) ALA_ - Ambiguous symbols, Latin, Greek, Cyrillic
    11  ,  // ( 88) AGR_ - Ambiguous symbols, Latin, Greek, Cyrillic
    11  ,  // ( 89) ACY_ - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 90) WID_ - Han Ideographs
    8   ,  // ( 91) WPUA - End user defined characters
    16  ,  // ( 92) NHG_ - Hangul Ideographs
    16  ,  // ( 93) WHG_ - Hangul Ideographs
    8   ,  // ( 94) WCI_ - Compatibility Ideographs
    8   ,  // ( 95) NOI_ - Other Ideographs
    8   ,  // ( 96) WOI_ - Other Ideographs
    20  ,  // ( 97) WOIC - Other Ideographs
    8   ,  // ( 98) WOIL - Other Ideographs
    8   ,  // ( 99) WOIS - Other Ideographs
    8   ,  // (100) WOIT - Other Ideographs
    11  ,  // (101) NSEN - Super/subscript/attachment characters
    11  ,  // (102) NSET - Super/subscript/attachment characters
    11  ,  // (103) NSNW - Super/subscript/attachment characters
    11  ,  // (104) ASAN - Super/subscript/attachment characters
    11  ,  // (105) ASAE - Super/subscript/attachment characters
    9   ,  // (106) NDEA - Digits
    8   ,  // (107) WD__ - Digits
    11  ,  // (108) NLLA - Basic Latin
    8   ,  // (109) WLA_ - Basic Latin
    10  ,  // (110) NWBL - Word breaking spaces
    10  ,  // (111) NWZW - Word breaking spaces
    11  ,  // (112) NPLW - Punctuation in text
    11  ,  // (113) NPZW - Punctuation in text
    11  ,  // (114) NPF_ - Punctuation in text
    11  ,  // (115) NPFL - Punctuation in text
    11  ,  // (116) NPNW - Punctuation in text
    11  ,  // (117) APLW - Punctuation in text
    20  ,  // (118) APCO - Punctuation in text
    10  ,  // (119) ASYW - Soft Hyphen
    10  ,  // (120) NHYP - Hyphen
    10  ,  // (121) NHYW - Hyphen
    10  ,  // (122) AHYW - Hyphen
    14  ,  // (123) NAPA - Apostrophe
    14  ,  // (124) NQMP - Quotation mark
    13  ,  // (125) NSLS - Slash
    10  ,  // (126) NSF_ - Non space word break
    10  ,  // (127) NSBB - Non space word break
    10  ,  // (128) NSBS - Non space word break
    11  ,  // (129) NLA_ - Latin
    11  ,  // (130) NLQ_ - Latin Punctuation in text
    20  ,  // (131) NLQC - Latin Punctuation in text
    11  ,  // (132) NLQN - Latin Punctuation in text
    11  ,  // (133) ALQ_ - Latin Punctuation in text
    11  ,  // (134) ALQN - Latin Punctuation in text
    11  ,  // (135) NGR_ - Greek
    11  ,  // (136) NGRN - Greek
    11  ,  // (137) NGQ_ - Greek Punctuation in text
    11  ,  // (138) NGQN - Greek Punctuation in text
    11  ,  // (139) NCY_ - Cyrillic
    11  ,  // (140) NCYP - Cyrillic Punctuation in text
    20  ,  // (141) NCYC - Cyrillic Punctuation in text
    11  ,  // (142) NAR_ - Armenian
    11  ,  // (143) NAQL - Armenian Punctuation in text
    11  ,  // (144) NAQN - Armenian Punctuation in text
    11  ,  // (145) NHB_ - Hebrew
    20  ,  // (146) NHBC - Hebrew
    11  ,  // (147) NHBW - Hebrew
    11  ,  // (148) NHBR - Hebrew
    11  ,  // (149) NASR - Arabic
    11  ,  // (150) NAAR - Arabic
    20  ,  // (151) NAAC - Arabic
    9   ,  // (152) NAAD - Arabic
    9   ,  // (153) NAED - Arabic
    11  ,  // (154) NANW - Arabic
    11  ,  // (155) NAEW - Arabic
    11  ,  // (156) NAAS - Arabic
    11  ,  // (157) NHI_ - Devanagari
    11  ,  // (158) NHIN - Devanagari
    20  ,  // (159) NHIC - Devanagari
    9   ,  // (160) NHID - Devanagari
    11  ,  // (161) NBE_ - Bengali
    20  ,  // (162) NBEC - Bengali
    9   ,  // (163) NBED - Bengali
    6   ,  // (164) NBET - Bengali
    11  ,  // (165) NGM_ - Gurmukhi
    20  ,  // (166) NGMC - Gurmukhi
    9   ,  // (167) NGMD - Gurmukhi
    11  ,  // (168) NGJ_ - Gujarati
    20  ,  // (169) NGJC - Gujarati
    9   ,  // (170) NGJD - Gujarati
    11  ,  // (171) NOR_ - Oriya
    20  ,  // (172) NORC - Oriya
    9   ,  // (173) NORD - Oriya
    11  ,  // (174) NTA_ - Tamil
    20  ,  // (175) NTAC - Tamil
    9   ,  // (176) NTAD - Tamil
    11  ,  // (177) NTE_ - Telugu
    20  ,  // (178) NTEC - Telugu
    9   ,  // (179) NTED - Telugu
    11  ,  // (180) NKD_ - Kannada
    20  ,  // (181) NKDC - Kannada
    9   ,  // (182) NKDD - Kannada
    11  ,  // (183) NMA_ - Malayalam
    20  ,  // (184) NMAC - Malayalam
    9   ,  // (185) NMAD - Malayalam
    19  ,  // (186) NTH_ - Thai
    19  ,  // (187) NTHC - Thai
    9   ,  // (188) NTHD - Thai
    7   ,  // (189) NTHT - Thai
    11  ,  // (190) NLO_ - Lao
    20  ,  // (191) NLOC - Lao
    9   ,  // (192) NLOD - Lao
    11  ,  // (193) NTI_ - Tibetan
    20  ,  // (194) NTIC - Tibetan
    9   ,  // (195) NTID - Tibetan
    11  ,  // (196) NTIN - Tibetan
    11  ,  // (197) NGE_ - Georgian
    11  ,  // (198) NGEQ - Georgian Punctuation in text
    11  ,  // (199) NBO_ - Bopomofo
    12  ,  // (200) NBSP - No Break space
    12  ,  // (201) NBSS - No Break space
    11  ,  // (202) NOF_ - Other symbols
    11  ,  // (203) NOBS - Other symbols
    11  ,  // (204) NOEA - Other symbols
    11  ,  // (205) NONA - Other symbols
    11  ,  // (206) NONP - Other symbols
    11  ,  // (207) NOEP - Other symbols
    11  ,  // (208) NONW - Other symbols
    11  ,  // (209) NOEW - Other symbols
    11  ,  // (210) NOLW - Other symbols
    20  ,  // (211) NOCO - Other symbols
    11  ,  // (212) NOEN - Other symbols
    11  ,  // (213) NOBN - Other symbols
    11  ,  // (214) NSBN - Other symbols
    11  ,  // (215) NOLE - Other symbols
    11  ,  // (216) NORE - Other symbols
    11  ,  // (217) NOPF - Other symbols
    11  ,  // (218) NOLO - Other symbols
    11  ,  // (219) NORO - Other symbols
    11  ,  // (220) NET_ - Ethiopic
    22  ,  // (221) NETP - Ethiopic
    9   ,  // (222) NETD - Ethiopic
    11  ,  // (223) NCA_ - Canadian Syllabics
    11  ,  // (224) NCH_ - Cherokee
    8   ,  // (225) WYI_ - Yi
    8   ,  // (226) WYIN - Yi
    11  ,  // (227) NBR_ - Braille
    11  ,  // (228) NRU_ - Runic
    11  ,  // (229) NOG_ - Oghma
    11  ,  // (230) NOGS - Oghma
    11  ,  // (231) NOGN - Oghma
    11  ,  // (232) NSI_ - Sinhala
    20  ,  // (233) NSIC - Sinhala
    11  ,  // (234) NTN_ - Thaana
    20  ,  // (235) NTNC - Thaana
    11  ,  // (236) NKH_ - Khmer
    20  ,  // (237) NKHC - Khmer
    9   ,  // (238) NKHD - Khmer
    6   ,  // (239) NKHT - Khmer
    11  ,  // (240) NBU_ - Burmese
    20  ,  // (241) NBUC - Burmese
    9   ,  // (242) NBUD - Burmese
    11  ,  // (243) NSY_ - Syriac
    11  ,  // (244) NSYP - Syriac
    20  ,  // (245) NSYC - Syriac
    11  ,  // (246) NSYW - Syriac
    11  ,  // (247) NMO_ - Mongolian
    20  ,  // (248) NMOC - Mongolian
    9   ,  // (249) NMOD - Mongolian
    11  ,  // (250) NMOB - Mongolian
    11  ,  // (251) NMON - Mongolian
    11  ,  // (252) NHS_ - High Surrogate
    8   ,  // (253) WHT_ - High Surrogate
    20  ,  // (254) LS__ - Low Surrogate
    11  ,  // (255) XNW_ - Undefined or reserved characters
    11  ,  // (256) XNWA - Undefined or reserved characters
    11  ,  // (257) XNWB - Undefined or reserved characters
};


const unsigned short BreakClassFromCharClassWide[CHAR_CLASS_UNICODE_MAX] =
{
    1   ,  // (  0) WOB_ - Open brackets for inline-note
    1   ,  // (  1) NOPP - Open parenthesis
    1   ,  // (  2) NOPA - Open parenthesis
    1   ,  // (  3) NOPW - Open parenthesis
    1   ,  // (  4) HOP_ - Open parenthesis
    1   ,  // (  5) WOP_ - Open parenthesis
    1   ,  // (  6) WOP5 - Open parenthesis, Big 5
    14  ,  // (  7) NOQW - Open quotes
    1   ,  // (  8) AOQW - Open quotes
    1   ,  // (  9) WOQ_ - Open quotes
    2   ,  // ( 10) WCB_ - Close brackets for inline-note
    2   ,  // ( 11) NCPP - Close parenthesis
    2   ,  // ( 12) NCPA - Close parenthesis
    2   ,  // ( 13) NCPW - Close parenthesis
    2   ,  // ( 14) HCP_ - Close parenthesis
    2   ,  // ( 15) WCP_ - Close parenthesis
    2   ,  // ( 16) WCP5 - Close parenthesis, Big 5
    14  ,  // ( 17) NCQW - Close quotes
    2   ,  // ( 18) ACQW - Close quotes
    2   ,  // ( 19) WCQ_ - Close quotes
    2   ,  // ( 20) ARQW - Right single quotation mark
    15  ,  // ( 21) NCSA - Comma
    2   ,  // ( 22) HCO_ - Comma
    2   ,  // ( 23) WC__ - Comma
    2   ,  // ( 24) WCS_ - Comma
    2   ,  // ( 25) WC5_ - Comma, Big 5
    2   ,  // ( 26) WC5S - Comma, Big 5
    3   ,  // ( 27) NKS_ - Kana Sound marks
    3   ,  // ( 28) WKSM - Kana Sound marks
    3   ,  // ( 29) WIM_ - Iteration mark
    3   ,  // ( 30) NSSW - Symbols which can't start a line
    3   ,  // ( 31) WSS_ - Symbols which can't start a line
    3   ,  // ( 32) WHIM - Hiragana iteration marks
    3   ,  // ( 33) WKIM - Katakana iteration marks
    3   ,  // ( 34) NKSL - Katakana that can't start a line
    3   ,  // ( 35) WKS_ - Katakana that can't start a line
    20  ,  // ( 36) WKSC - Katakana that can't start a line
    3   ,  // ( 37) WHS_ - Hiragana that can't start a line
    4   ,  // ( 38) NQFP - Question/exclamation
    4   ,  // ( 39) NQFA - Question/exclamation
    3   ,  // ( 40) WQE_ - Question/exclamation
    3   ,  // ( 41) WQE5 - Question/exclamation, Big 5
    3   ,  // ( 42) NKCC - Kana centered characters
    3   ,  // ( 43) WKC_ - Kana centered characters
    15  ,  // ( 44) NOCP - Other centered characters
    15  ,  // ( 45) NOCA - Other centered characters
    15  ,  // ( 46) NOCW - Other centered characters
    3   ,  // ( 47) WOC_ - Other centered characters
    3   ,  // ( 48) WOCS - Other centered characters
    3   ,  // ( 49) WOC5 - Other centered characters, Big 5
    3   ,  // ( 50) WOC6 - Other centered characters, Big 5
    3   ,  // ( 51) AHPW - Hyphenation point
    15  ,  // ( 52) NPEP - Period
    15  ,  // ( 53) NPAR - Period
    3   ,  // ( 54) HPE_ - Period
    3   ,  // ( 55) WPE_ - Period
    3   ,  // ( 56) WPES - Period
    3   ,  // ( 57) WPE5 - Period, Big 5
    5   ,  // ( 58) NISW - Inseparable characters
    5   ,  // ( 59) AISW - Inseparable characters
    12  ,  // ( 60) NQCS - Glue characters
    12  ,  // ( 61) NQCW - Glue characters
    12  ,  // ( 62) NQCC - Glue characters
    6   ,  // ( 63) NPTA - Prefix currencies and symbols
    6   ,  // ( 64) NPNA - Prefix currencies and symbols
    6   ,  // ( 65) NPEW - Prefix currencies and symbols
    6   ,  // ( 66) NPEH - Prefix currencies and symbols
    6   ,  // ( 67) NPEV - Prefix currencies and symbols
    6   ,  // ( 68) APNW - Prefix currencies and symbols
    6   ,  // ( 69) HPEW - Prefix currencies and symbols
    6   ,  // ( 70) WPR_ - Prefix currencies and symbols
    7   ,  // ( 71) NQEP - Postfix currencies and symbols
    7   ,  // ( 72) NQEW - Postfix currencies and symbols
    7   ,  // ( 73) NQNW - Postfix currencies and symbols
    7   ,  // ( 74) AQEW - Postfix currencies and symbols
    7   ,  // ( 75) AQNW - Postfix currencies and symbols
    7   ,  // ( 76) AQLW - Postfix currencies and symbols
    7   ,  // ( 77) WQO_ - Postfix currencies and symbols
    21  ,  // ( 78) NSBL - Space
    8   ,  // ( 79) WSP_ - Space
    8   ,  // ( 80) WHI_ - Hiragana, except small letters
    8   ,  // ( 81) NKA_ - Katakana, except small letters
    8   ,  // ( 82) WKA_ - Katakana, except small letters
    8   ,  // ( 83) ASNW - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 84) ASEW - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 85) ASRN - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 86) ASEN - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 87) ALA_ - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 88) AGR_ - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 89) ACY_ - Ambiguous symbols, Latin, Greek, Cyrillic
    8   ,  // ( 90) WID_ - Han Ideographs
    8   ,  // ( 91) WPUA - End user defined characters
    16  ,  // ( 92) NHG_ - Hangul Ideographs
    16  ,  // ( 93) WHG_ - Hangul Ideographs
    8   ,  // ( 94) WCI_ - Compatibility Ideographs
    8   ,  // ( 95) NOI_ - Other Ideographs
    8   ,  // ( 96) WOI_ - Other Ideographs
    20  ,  // ( 97) WOIC - Other Ideographs
    8   ,  // ( 98) WOIL - Other Ideographs
    8   ,  // ( 99) WOIS - Other Ideographs
    8   ,  // (100) WOIT - Other Ideographs
    11  ,  // (101) NSEN - Super/subscript/attachment characters
    11  ,  // (102) NSET - Super/subscript/attachment characters
    11  ,  // (103) NSNW - Super/subscript/attachment characters
    11  ,  // (104) ASAN - Super/subscript/attachment characters
    11  ,  // (105) ASAE - Super/subscript/attachment characters
    9   ,  // (106) NDEA - Digits
    8   ,  // (107) WD__ - Digits
    11  ,  // (108) NLLA - Basic Latin
    8   ,  // (109) WLA_ - Basic Latin
    10  ,  // (110) NWBL - Word breaking spaces
    10  ,  // (111) NWZW - Word breaking spaces
    11  ,  // (112) NPLW - Punctuation in text
    11  ,  // (113) NPZW - Punctuation in text
    11  ,  // (114) NPF_ - Punctuation in text
    11  ,  // (115) NPFL - Punctuation in text
    11  ,  // (116) NPNW - Punctuation in text
    8   ,  // (117) APLW - Punctuation in text
    20  ,  // (118) APCO - Punctuation in text
    10  ,  // (119) ASYW - Soft Hyphen
    10  ,  // (120) NHYP - Hyphen
    10  ,  // (121) NHYW - Hyphen
    10  ,  // (122) AHYW - Hyphen
    14  ,  // (123) NAPA - Apostrophe
    14  ,  // (124) NQMP - Quotation mark
    13  ,  // (125) NSLS - Slash
    10  ,  // (126) NSF_ - Non space word break
    10  ,  // (127) NSBB - Non space word break
    10  ,  // (128) NSBS - Non space word break
    11  ,  // (129) NLA_ - Latin
    11  ,  // (130) NLQ_ - Latin Punctuation in text
    20  ,  // (131) NLQC - Latin Punctuation in text
    11  ,  // (132) NLQN - Latin Punctuation in text
    8   ,  // (133) ALQ_ - Latin Punctuation in text
    8   ,  // (134) ALQN - Latin Punctuation in text
    11  ,  // (135) NGR_ - Greek
    11  ,  // (136) NGRN - Greek
    11  ,  // (137) NGQ_ - Greek Punctuation in text
    11  ,  // (138) NGQN - Greek Punctuation in text
    11  ,  // (139) NCY_ - Cyrillic
    11  ,  // (140) NCYP - Cyrillic Punctuation in text
    20  ,  // (141) NCYC - Cyrillic Punctuation in text
    11  ,  // (142) NAR_ - Armenian
    11  ,  // (143) NAQL - Armenian Punctuation in text
    11  ,  // (144) NAQN - Armenian Punctuation in text
    11  ,  // (145) NHB_ - Hebrew
    20  ,  // (146) NHBC - Hebrew
    11  ,  // (147) NHBW - Hebrew
    11  ,  // (148) NHBR - Hebrew
    11  ,  // (149) NASR - Arabic
    11  ,  // (150) NAAR - Arabic
    20  ,  // (151) NAAC - Arabic
    9   ,  // (152) NAAD - Arabic
    9   ,  // (153) NAED - Arabic
    11  ,  // (154) NANW - Arabic
    11  ,  // (155) NAEW - Arabic
    11  ,  // (156) NAAS - Arabic
    11  ,  // (157) NHI_ - Devanagari
    11  ,  // (158) NHIN - Devanagari
    20  ,  // (159) NHIC - Devanagari
    9   ,  // (160) NHID - Devanagari
    11  ,  // (161) NBE_ - Bengali
    20  ,  // (162) NBEC - Bengali
    9   ,  // (163) NBED - Bengali
    6   ,  // (164) NBET - Bengali
    11  ,  // (165) NGM_ - Gurmukhi
    20  ,  // (166) NGMC - Gurmukhi
    9   ,  // (167) NGMD - Gurmukhi
    11  ,  // (168) NGJ_ - Gujarati
    20  ,  // (169) NGJC - Gujarati
    9   ,  // (170) NGJD - Gujarati
    11  ,  // (171) NOR_ - Oriya
    20  ,  // (172) NORC - Oriya
    9   ,  // (173) NORD - Oriya
    11  ,  // (174) NTA_ - Tamil
    20  ,  // (175) NTAC - Tamil
    9   ,  // (176) NTAD - Tamil
    11  ,  // (177) NTE_ - Telugu
    20  ,  // (178) NTEC - Telugu
    9   ,  // (179) NTED - Telugu
    11  ,  // (180) NKD_ - Kannada
    20  ,  // (181) NKDC - Kannada
    9   ,  // (182) NKDD - Kannada
    11  ,  // (183) NMA_ - Malayalam
    20  ,  // (184) NMAC - Malayalam
    9   ,  // (185) NMAD - Malayalam
    19  ,  // (186) NTH_ - Thai
    19  ,  // (187) NTHC - Thai
    9   ,  // (188) NTHD - Thai
    7   ,  // (189) NTHT - Thai
    11  ,  // (190) NLO_ - Lao
    20  ,  // (191) NLOC - Lao
    9   ,  // (192) NLOD - Lao
    11  ,  // (193) NTI_ - Tibetan
    20  ,  // (194) NTIC - Tibetan
    9   ,  // (195) NTID - Tibetan
    11  ,  // (196) NTIN - Tibetan
    11  ,  // (197) NGE_ - Georgian
    11  ,  // (198) NGEQ - Georgian Punctuation in text
    11  ,  // (199) NBO_ - Bopomofo
    12  ,  // (200) NBSP - No Break space
    12  ,  // (201) NBSS - No Break space
    11  ,  // (202) NOF_ - Other symbols
    11  ,  // (203) NOBS - Other symbols
    11  ,  // (204) NOEA - Other symbols
    11  ,  // (205) NONA - Other symbols
    11  ,  // (206) NONP - Other symbols
    11  ,  // (207) NOEP - Other symbols
    11  ,  // (208) NONW - Other symbols
    11  ,  // (209) NOEW - Other symbols
    11  ,  // (210) NOLW - Other symbols
    20  ,  // (211) NOCO - Other symbols
    11  ,  // (212) NOEN - Other symbols
    11  ,  // (213) NOBN - Other symbols
    11  ,  // (214) NSBN - Other symbols
    11  ,  // (215) NOLE - Other symbols
    11  ,  // (216) NORE - Other symbols
    11  ,  // (217) NOPF - Other symbols
    11  ,  // (218) NOLO - Other symbols
    11  ,  // (219) NORO - Other symbols
    11  ,  // (220) NET_ - Ethiopic
    22  ,  // (221) NETP - Ethiopic
    9   ,  // (222) NETD - Ethiopic
    11  ,  // (223) NCA_ - Canadian Syllabics
    11  ,  // (224) NCH_ - Cherokee
    8   ,  // (225) WYI_ - Yi
    8   ,  // (226) WYIN - Yi
    11  ,  // (227) NBR_ - Braille
    11  ,  // (228) NRU_ - Runic
    11  ,  // (229) NOG_ - Oghma
    11  ,  // (230) NOGS - Oghma
    11  ,  // (231) NOGN - Oghma
    11  ,  // (232) NSI_ - Sinhala
    20  ,  // (233) NSIC - Sinhala
    11  ,  // (234) NTN_ - Thaana
    20  ,  // (235) NTNC - Thaana
    11  ,  // (236) NKH_ - Khmer
    20  ,  // (237) NKHC - Khmer
    9   ,  // (238) NKHD - Khmer
    6   ,  // (239) NKHT - Khmer
    11  ,  // (240) NBU_ - Burmese
    20  ,  // (241) NBUC - Burmese
    9   ,  // (242) NBUD - Burmese
    11  ,  // (243) NSY_ - Syriac
    11  ,  // (244) NSYP - Syriac
    20  ,  // (245) NSYC - Syriac
    11  ,  // (246) NSYW - Syriac
    11  ,  // (247) NMO_ - Mongolian
    20  ,  // (248) NMOC - Mongolian
    9   ,  // (249) NMOD - Mongolian
    11  ,  // (250) NMOB - Mongolian
    11  ,  // (251) NMON - Mongolian
    11  ,  // (252) NHS_ - High Surrogate
    8   ,  // (253) WHT_ - High Surrogate
    20  ,  // (254) LS__ - Low Surrogate
    11  ,  // (255) XNW_ - Undefined or reserved characters
    11  ,  // (256) XNWA - Undefined or reserved characters
    11  ,  // (257) XNWB - Undefined or reserved characters
};


// 0 indicates that line breaking is allowed between these 2 classes.
// 1 indicates no line breaking as well as no break across space.
// 2 indicates no line breaking, but can break across space. 
// 3 is like 0 when break-latin is on, otherwise it is 2.
// 4 is like 0 when break-CJK is on, otherwise it is 2.
//

const unsigned char LineBreakBehavior[BREAKCLASS_MAX][BREAKCLASS_MAX] =
{
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},  // ( 0) *Break Always*
    {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1},  // ( 1) Opening characters
    {0, 0, 1, 1, 1, 0, 0, 2, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // ( 2) Closing characters
    {0, 0, 1, 2, 1, 2, 0, 2, 4, 0, 0, 4, 2, 1, 2, 1, 4, 0, 0, 0, 2, 1, 1},  // ( 3) No start ideographic
    {0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // ( 4) Exclamation/interrogation
    {0, 0, 1, 2, 1, 2, 0, 0, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // ( 5) Inseparable
    {0, 2, 1, 2, 1, 0, 2, 0, 2, 2, 0, 3, 2, 1, 2, 1, 2, 2, 0, 0, 2, 1, 1},  // ( 6) Prefix
    {0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // ( 7) Postfix
    {0, 0, 1, 2, 1, 2, 0, 2, 4, 0, 0, 4, 2, 1, 2, 1, 4, 0, 0, 0, 2, 1, 1},  // ( 8) Ideographic
    {0, 0, 1, 2, 1, 2, 0, 2, 0, 3, 0, 3, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // ( 9) Numeral sequence
    {0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // (10) Alpha space
    {0, 0, 1, 2, 1, 2, 2, 2, 4, 3, 0, 3, 2, 1, 2, 1, 4, 0, 0, 0, 2, 1, 1},  // (11) Alpha characters/symbols
    {0, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1},  // (12) Glue Characters
    {0, 0, 1, 2, 1, 2, 0, 2, 0, 2, 0, 3, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // (13) Slash
    {0, 1, 1, 2, 1, 2, 2, 3, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1},  // (14) Quotation characters
    {0, 0, 1, 2, 1, 0, 2, 2, 0, 2, 0, 3, 2, 1, 2, 2, 0, 0, 0, 0, 2, 1, 1},  // (15) Numeric separators
    {0, 0, 1, 2, 1, 2, 0, 2, 4, 0, 0, 4, 2, 1, 2, 1, 4, 0, 0, 0, 2, 1, 1},  // (16) Hangul
    {0, 0, 1, 2, 1, 2, 0, 2, 0, 0, 0, 0, 2, 1, 2, 1, 4, 2, 2, 2, 2, 1, 1},  // (17) Thai first
    {0, 0, 1, 2, 1, 2, 0, 2, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 2, 2, 2, 1, 1},  // (18) Thai last
    {0, 0, 1, 2, 1, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 1, 0, 2, 2, 2, 2, 1, 1},  // (19) Thai middle
    {0, 0, 1, 2, 1, 2, 2, 2, 4, 3, 0, 3, 2, 1, 2, 1, 4, 0, 0, 0, 1, 1, 1},  // (20) Combining
    {0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 1, 0, 0, 0, 0, 2, 1, 1},  // (21) Ascii space
    {0, 0, 1, 2, 1, 0, 2, 2, 0, 2, 0, 0, 2, 1, 2, 2, 0, 0, 0, 0, 2, 1, 2},  // (22) Special punctuation
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\unilib\unidir.cxx ===
//
// This is a generated file.  Do not modify by hand.
//
// Generating script: unicodedirection_maketable.pl
// Generated on Tue Apr 17 17:25:36 2001
//

#ifndef X__UNIPART_H
#define X__UNIPART_H
#include "unipart.hxx"
#endif

#ifndef X__UNIDIR_H
#define X__UNIDIR_H
#include "unidir.hxx"
#endif

extern "C" const GpCharacterClass s_aDirClassFromCharClass[CHAR_CLASS_UNICODE_MAX] =
{
    ON ,  // WOB_ - Open Brackets for inline-note (JIS 1 or 19)
    ON ,  // NOPP - Open parenthesis (JIS 1)
    ON ,  // NOPA - Open parenthesis (JIS 1)
    ON ,  // NOPW - Open parenthesis (JIS 1)
    ON ,  // HOP_ - Open parenthesis (JIS 1)
    ON ,  // WOP_ - Open parenthesis (JIS 1)
    ON ,  // WOP5 - Open parenthesis, Big 5 (JIS 1)
    ON ,  // NOQW - Open quotes (JIS 1)
    ON ,  // AOQW - Open quotes (JIS 1)
    ON ,  // WOQ_ - Open quotes (JIS 1)
    ON ,  // WCB_ - Close brackets for inline-note (JIS 2 or 20)
    ON ,  // NCPP - Close parenthesis (JIS 2)
    ON ,  // NCPA - Close parenthesis (JIS 2)
    ON ,  // NCPW - Close parenthesis (JIS 2)
    ON ,  // HCP_ - Close parenthesis (JIS 2)
    ON ,  // WCP_ - Close parenthesis (JIS 2)
    ON ,  // WCP5 - Close parenthesis, Big 5 (JIS 2)
    ON ,  // NCQW - Close quotes (JIS 2)
    ON ,  // ACQW - Close quotes (JIS 2)
    ON ,  // WCQ_ - Close quotes (JIS 2)
    ON ,  // ARQW - Right single quotation mark (JIS 2)
    CS ,  // NCSA - Comma (JIS 2 or 15)
    ON ,  // HCO_ - Comma (JIS 2 or 15)
    ON ,  // WC__ - Comma (JIS 2)
    CS ,  // WCS_ - Comma (JIS 2)
    ON ,  // WC5_ - Comma, Big 5 (JIS 2)
    CS ,  // WC5S - Comma, Big 5 (JIS 2)
    L  ,  // NKS_ - Kana sound marks (JIS 3)
    ON ,  // WKSM - Kana sound marks (JIS 3)
    L  ,  // WIM_ - Iteration marks (JIS 3)
    ON ,  // NSSW - Symbols which cant start a line (JIS 3)
    ON ,  // WSS_ - Symbols that cant start a line (JIS 3)
    L  ,  // WHIM - Hiragana iteration marks (JIS 3)
    L  ,  // WKIM - Katakana iteration marks (JIS 3)
    L  ,  // NKSL - Katakana that cant start a line (JIS 3)
    L  ,  // WKS_ - Katakana that cant start a line (JIS 3)
    NSM,  // WKSC - Katakana that cant start a line (JIS 3)
    L  ,  // WHS_ - Hiragana that cant start a line (JIS 3)
    ON ,  // NQFP - Question/Exclamation (JIS 4)
    ON ,  // NQFA - Question/Exclamation (JIS 4)
    ON ,  // WQE_ - Question/Exclamation (JIS 4)
    ON ,  // WQE5 - Question/Exclamation, Big 5 (JIS 4)
    ON ,  // NKCC - Kana centered characters (JIS 5)
    ON ,  // WKC_ - Kana centered characters (JIS 5)
    CS ,  // NOCP - Other centered characters (JIS 5)
    ON ,  // NOCA - Other centered characters (JIS 5)
    ON ,  // NOCW - Other centered characters (JIS 5)
    ON ,  // WOC_ - Other centered characters (JIS 5)
    CS ,  // WOCS - Other centered characters (JIS 5)
    CS ,  // WOC5 - Other centered characters, Big 5 (JIS 5)
    ON ,  // WOC6 - Other centered characters, Big 5 (JIS 5)
    ON ,  // AHPW - Hyphenation point (JIS 5)
    CS ,  // NPEP - Period (JIS 6 or 15)
    L  ,  // NPAR - Period (JIS 6 or 15)
    ON ,  // HPE_ - Period (JIS 6 or 15)
    ON ,  // WPE_ - Period (JIS 6)
    CS ,  // WPES - Period (JIS 6)
    CS ,  // WPE5 - Period, Big 5 (JIS 6)
    ON ,  // NISW - Inseparable characters (JIS 7)
    ON ,  // AISW - Inseparable characters (JIS 7)
    WS ,  // NQCS - Glue characters (no JIS)
    BN ,  // NQCW - Glue characters (no JIS)
    NSM,  // NQCC - Glue characters (no JIS)
    ET ,  // NPTA - Prefix currencies and symbols (JIS 8)
    ON ,  // NPNA - Prefix currencies and symbols (JIS 8)
    ET ,  // NPEW - Prefix currencies and symbols (JIS 8)
    ET ,  // NPEH - Prefix currencies and symbols (JIS 8)
    ET ,  // NPEV - Prefix currencies and symbols (JIS 8)
    ON ,  // APNW - Prefix currencies and symbols (JIS 8)
    ET ,  // HPEW - Prefix currencies and symbols (JIS 8)
    ET ,  // WPR_ - Prefix currencies and symbols (JIS 8)
    ET ,  // NQEP - Postfix currencies and symbols (JIS 9)
    ET ,  // NQEW - Postfix currencies and symbols (JIS 9)
    ON ,  // NQNW - Postfix currencies and symbols (JIS 9)
    ET ,  // AQEW - Postfix currencies and symbols (JIS 9)
    ON ,  // AQNW - Postfix currencies and symbols (JIS 9)
    L  ,  // AQLW - Postfix currencies and symbols (JIS 9)
    ET ,  // WQO_ - Postfix currencies and symbols (JIS 9)
    WS ,  // NSBL - Space(JIS 15 or 17)
    WS ,  // WSP_ - Space (JIS 10)
    L  ,  // WHI_ - Hiragana except small letters (JIS 11)
    L  ,  // NKA_ - Katakana except small letters Ideographic (JIS 12)
    L  ,  // WKA_ - Katakana except small letters (JIS 12)
    ON ,  // ASNW - Ambiguous symbols (JIS 12 or 18) 
    ET ,  // ASEW - Ambiguous symbols (JIS 12 or 18) 
    L  ,  // ASRN - Ambiguous symbols (JIS 12 or 18) 
    EN ,  // ASEN - Ambiguous symbols (JIS 12 or 18) 
    L  ,  // ALA_ - Ambiguous Latin (JIS 12 or 18) 
    L  ,  // AGR_ - Ambiguous Greek (JIS 12 or 18) 
    L  ,  // ACY_ - Ambiguous Cyrillic (JIS 12 or 18) 
    L  ,  // WID_ - Han Ideographs (JIS 12, 14S or 14D)
    L  ,  // WPUA - End user defined characters (JIS 12, 14S or 14D)
    L  ,  // NHG_ - Hangul Ideographs (JIS 12)
    L  ,  // WHG_ - Hangul Ideographs (JIS 12)
    L  ,  // WCI_ - Compatibility Ideographs (JIS 12)
    ON ,  // NOI_ - Other Ideographs (JIS 12)
    ON ,  // WOI_ - Other Ideographs (JIS 12)
    NSM,  // WOIC - Other Ideographs (JIS 12)
    L  ,  // WOIL - Other Ideographs (JIS 12)
    ES ,  // WOIS - Other Ideographs (JIS 12)
    ET ,  // WOIT - Other Ideographs (JIS 12)
    EN ,  // NSEN - Superscript/Subscript/Attachments (JIS 13)
    ET ,  // NSET - Superscript/Subscript/Attachments (JIS 13)
    ON ,  // NSNW - Superscript/Subscript/Attachments (JIS 13)
    L  ,  // ASAN - Superscript/Subscript/Attachments (JIS 13)
    EN ,  // ASAE - Superscript/Subscript/Attachments (JIS 13)
    EN ,  // NDEA - Digits (JIS 15 or 18)
    EN ,  // WD__ - Digits (JIS 15 or 18)
    L  ,  // NLLA - Basic Latin (JIS 16 or 18)
    L  ,  // WLA_ - Basic Latin (JIS 16 or 18)
    WS ,  // NWBL - Word breaking Spaces (JIS 17)
    BN ,  // NWZW - Word breaking Spaces (JIS 17)
    L  ,  // NPLW - Punctuation in Text (JIS 18)
    BN ,  // NPZW - Punctuation in Text (JIS 18)
    R  ,  // NPF_ - Punctuation in Text (JIS 18)
    L  ,  // NPFL - Punctuation in Text (JIS 18)
    ON ,  // NPNW - Punctuation in Text (JIS 18)
    L  ,  // APLW - Punctuation in text (JIS 12 or 18)
    NSM,  // APCO - Punctuation in text (JIS 12 or 18)
    ON ,  // ASYW - Soft Hyphen (JIS 12 or 18)
    ES ,  // NHYP - Hyphen (JIS 18)
    ON ,  // NHYW - Hyphen (JIS 18)
    ON ,  // AHYW - Hyphen (JIS 12 or 18)
    ON ,  // NAPA - Apostrophe (JIS 18)
    ON ,  // NQMP - Quotation mark (JIS 18)
    CS ,  // NSLS - Slash (JIS 18)
    S  ,  // NSF_ - Non space word break (JIS 18)
    B  ,  // NSBB - Non space word break (JIS 18)
    WS ,  // NSBS - Non space word break (JIS 18)
    L  ,  // NLA_ - Latin (JIS 18)
    L  ,  // NLQ_ - Latin Punctuation in text (JIS 18)
    L  ,  // NLQC - Latin Punctuation in text (JIS 18)
    ON ,  // NLQN - Latin Punctuation in text (JIS 18)
    ON ,  // ALQ_ - Latin Punctuation in text (JIS 12 or 18)
    ON ,  // ALQN - Latin Punctuation in text (JIS 12 or 18)
    L  ,  // NGR_ - Greek (JIS 18)
    ON ,  // NGRN - Greek (JIS 18)
    L  ,  // NGQ_ - Greek Punctuation in text (JIS 18)
    ON ,  // NGQN - Greek Punctuation in text (JIS 18)
    L  ,  // NCY_ - Cyrillic (JIS 18)
    L  ,  // NCYP - Cyrillic Punctuation in text (JIS 18)
    NSM,  // NCYC - Cyrillic Punctuation in text (JIS 18)
    L  ,  // NAR_ - Armenian (JIS 18)
    L  ,  // NAQL - Armenian Punctuation in text (JIS 18)
    ON ,  // NAQN - Armenian Punctuation in text (JIS 18)
    R  ,  // NHB_ - Hebrew (JIS 18)
    NSM,  // NHBC - Hebrew (JIS 18)
    ET ,  // NHBW - Hebrew (JIS 18)
    R  ,  // NHBR - Hebrew (JIS 18)
    CS ,  // NASR - Arabic (JIS 18)
    AL ,  // NAAR - Arabic (JIS 18)
    NSM,  // NAAC - Arabic (JIS 18)
    AN ,  // NAAD - Arabic (JIS 18)
    EN ,  // NAED - Arabic (JIS 18)
    ON ,  // NANW - Arabic (JIS 18)
    ET ,  // NAEW - Arabic (JIS 18)
    AL ,  // NAAS - Arabic (JIS 18)
    L  ,  // NHI_ - Devanagari (JIS 18)
    L  ,  // NHIN - Devanagari (JIS 18)
    NSM,  // NHIC - Devanagari (JIS 18)
    L  ,  // NHID - Devanagari (JIS 18)
    L  ,  // NBE_ - Bengali (JIS 18)
    NSM,  // NBEC - Bengali (JIS 18)
    L  ,  // NBED - Bengali (JIS 18)
    ET ,  // NBET - Bengali (JIS 18)
    L  ,  // NGM_ - Gurmukhi (JIS 18)
    NSM,  // NGMC - Gurmukhi (JIS 18)
    L  ,  // NGMD - Gurmukhi (JIS 18)
    L  ,  // NGJ_ - Gujarati (JIS 18)
    NSM,  // NGJC - Gujarati (JIS 18)
    L  ,  // NGJD - Gujarati (JIS 18)
    L  ,  // NOR_ - Oriya (JIS 18)
    NSM,  // NORC - Oriya (JIS 18)
    L  ,  // NORD - Oriya (JIS 18)
    L  ,  // NTA_ - Tamil (JIS 18)
    NSM,  // NTAC - Tamil (JIS 18)
    L  ,  // NTAD - Tamil (JIS 18)
    L  ,  // NTE_ - Telugu (JIS 18)
    NSM,  // NTEC - Telugu (JIS 18)
    L  ,  // NTED - Telugu (JIS 18)
    L  ,  // NKD_ - Kannada (JIS 18)
    NSM,  // NKDC - Kannada (JIS 18)
    L  ,  // NKDD - Kannada (JIS 18)
    L  ,  // NMA_ - Malayalam (JIS 18)
    NSM,  // NMAC - Malayalam (JIS 18)
    L  ,  // NMAD - Malayalam (JIS 18)
    L  ,  // NTH_ - Thai (JIS 18) 
    NSM,  // NTHC - Thai (JIS 18) 
    L  ,  // NTHD - Thai (JIS 18) 
    ET ,  // NTHT - Thai (JIS 18) 
    L  ,  // NLO_ - Lao (JIS 18)
    NSM,  // NLOC - Lao (JIS 18)
    L  ,  // NLOD - Lao (JIS 18)
    L  ,  // NTI_ - Tibetan (JIS 18)
    NSM,  // NTIC - Tibetan (JIS 18)
    L  ,  // NTID - Tibetan (JIS 18)
    ON ,  // NTIN - Tibetan (JIS 18)
    L  ,  // NGE_ - Georgian (JIS 18)
    L  ,  // NGEQ - Georgian Punctuation in text (JIS 18)
    L  ,  // NBO_ - Bopomofo (JIS 18)
    CS ,  // NBSP - No Break space (no JIS) 
    WS ,  // NBSS - No Break space (no JIS) 
    S  ,  // NOF_ - Other symbols (JIS 18)
    B  ,  // NOBS - Other symbols (JIS 18)
    ET ,  // NOEA - Other symbols (JIS 18)
    ON ,  // NONA - Other symbols (JIS 18)
    ON ,  // NONP - Other symbols (JIS 18)
    ES ,  // NOEP - Other symbols (JIS 18)
    ON ,  // NONW - Other symbols (JIS 18)
    ET ,  // NOEW - Other symbols (JIS 18)
    L  ,  // NOLW - Other symbols (JIS 18)
    NSM,  // NOCO - Other symbols (JIS 18)
    EN ,  // NOEN - Other symbols (JIS 18)
    BN ,  // NOBN - Other symbols (JIS 18)
    BN ,  // NSBN - Other symbols (JIS 18)
    LRE,  // NOLE - Other symbols (JIS 18)
    RLE,  // NORE - Other symbols (JIS 18)
    PDF,  // NOPF - Other symbols (JIS 18)
    LRO,  // NOLO - Other symbols (JIS 18)
    RLO,  // NORO - Other symbols (JIS 18)
    L  ,  // NET_ - Ethiopic
    L  ,  // NETP - Ethiopic
    L  ,  // NETD - Ethiopic
    L  ,  // NCA_ - Canadian Syllabics
    L  ,  // NCH_ - Cherokee
    L  ,  // WYI_ - Yi
    ON ,  // WYIN - Yi
    ON ,  // NBR_ - Braille
    L  ,  // NRU_ - Runic
    L  ,  // NOG_ - Ogham
    WS ,  // NOGS - Ogham
    ON ,  // NOGN - Ogham
    L  ,  // NSI_ - Sinhala
    NSM,  // NSIC - Sinhala
    AL ,  // NTN_ - Thaana
    NSM,  // NTNC - Thaana
    L  ,  // NKH_ - Khmer
    NSM,  // NKHC - Khmer
    L  ,  // NKHD - Khmer
    ET ,  // NKHT - Khmer
    L  ,  // NBU_ - Burmese/Myanmar
    NSM,  // NBUC - Burmese/Myanmar
    L  ,  // NBUD - Burmese/Myanmar
    AL ,  // NSY_ - Syriac
    AL ,  // NSYP - Syriac
    NSM,  // NSYC - Syriac
    BN ,  // NSYW - Syriac
    L  ,  // NMO_ - Mongolian
    NSM,  // NMOC - Mongolian
    L  ,  // NMOD - Mongolian
    BN ,  // NMOB - Mongolian
    ON ,  // NMON - Mongolian
    L  ,  // NHS_ - High Surrogate
    L  ,  // WHT_ - High Surrogate
    L  ,  // LS__ - Low Surrogate
    L  ,  // XNW_ - Unassigned
    AL ,  // XNWA - Unassigned
    BN ,  // XNWB - Unassigned
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\text\unilib\unipart.cxx ===
//
// This is a generated file.  Do not modify by hand.
//
// Generating script: unicodepartition_maketables.pl
// Generated on Mon Apr 30 19:22:17 2001
//

#ifndef X__UNIPART_H
#define X__UNIPART_H
#include "unipart.hxx"
#endif

#include "windows.h"
#include "assert.h"
#pragma data_seg( "Shared" )

const CHAR_CLASS acc_00[256] = // U+00xx
{
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NSF_,NSBB,NOF_,NSBS,NSBB,NOBN,NOBN, // 00 - 0F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBS,NOBS,NOBS,NOF_, // 10 - 1F
    NSBL,NQFP,NQMP,NOEA,NPTA,NQEP,NONA,NAPA,NOPP,NCPP,NONP,NOEP,NCSA,NHYP,NPEP,NSLS, // 20 - 2F
    NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NOCP,NOCA,NONA,NONP,NONA,NQFA, // 30 - 3F
    NONA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA, // 40 - 4F
    NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NOPP,NPNA,NCPP,NONA,NONA, // 50 - 5F
    NONA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA, // 60 - 6F
    NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NOPA,NONA,NCPA,NONA,NOBN, // 70 - 7F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBS,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // 80 - 8F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // 90 - 9F
    NBSP,ASNW,NQEW,NPEW,ASEW,NPEW,NONW,ASNW,ASNW,NONW,ASAN,NOQW,NONW,ASYW,NONW,ASNW, // A0 - AF
    AQEW,ASEW,ASAE,ASAE,ASNW,NOLW,ASNW,ASNW,ASNW,ASAE,ASAN,NCQW,ASNW,ASNW,ASNW,ASNW, // B0 - BF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // C0 - CF
    ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ASNW,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_, // D0 - DF
    ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,ALA_,ALA_,ALA_,NLA_,ALA_,ALA_,NLA_,NLA_, // E0 - EF
    ALA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,ASNW,ALA_,ALA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_  // F0 - FF
};

const CHAR_CLASS acc_01[256] = // U+01xx
{
    ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,ALA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 10 - 1F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 20 - 2F
    NLA_,ALA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_, // 30 - 3F
    ALA_,ALA_,ALA_,NLA_,ALA_,NLA_,NLA_,NLA_,ALA_,ALA_,ALA_,ALA_,ALA_,ALA_,NLA_,NLA_, // 40 - 4F
    NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 50 - 5F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 60 - 6F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 70 - 7F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 80 - 8F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 90 - 9F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // A0 - AF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // B0 - BF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_, // C0 - CF
    ALA_,ALA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,NLA_,NLA_, // D0 - DF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // E0 - EF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_  // F0 - FF
};

const CHAR_CLASS acc_02[256] = // U+02xx
{
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 10 - 1F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 20 - 2F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 30 - 3F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 40 - 4F
    ALA_,ALA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 50 - 5F
    NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 60 - 6F
    NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 70 - 7F
    NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 80 - 8F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 90 - 9F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // A0 - AF
    NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NPNW,NPNW,NPLW,NPLW,NPLW,NPLW,NPLW, // B0 - BF
    NPLW,NPLW,NPNW,NPNW,NPNW,NPNW,ALQN,ALQ_,NPNW,ALQ_,ALQ_,ALQ_,NPNW,ALQ_,NPNW,NPNW, // C0 - CF
    APLW,NPLW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,ALQ_,ALQ_,ALQ_,ALQ_,NLQN,ALQ_,NPNW,NPNW, // D0 - DF
    NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPLW,NPLW, // E0 - EF
    NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW,NPLW  // F0 - FF
};

const CHAR_CLASS acc_03[256] = // U+03xx
{
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 00 - 0F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 10 - 1F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 20 - 2F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 30 - 3F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 40 - 4F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 50 - 5F
    NQCC,NQCC,NQCC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC, // 60 - 6F
    NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQ_,NGQN,NGQN,NGQN,NGQN,NGQN, // 70 - 7F
    NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGR_,NGQN,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 80 - 8F
    NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_, // 90 - 9F
    AGR_,AGR_,NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // A0 - AF
    NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_, // B0 - BF
    AGR_,AGR_,NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // C0 - CF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // D0 - DF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // E0 - EF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_  // F0 - FF
};

const CHAR_CLASS acc_04[256] = // U+04xx
{
    NCY_,ACY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 00 - 0F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 10 - 1F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 20 - 2F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 30 - 3F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 40 - 4F
    NCY_,ACY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 50 - 5F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 60 - 6F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 70 - 7F
    NCY_,NCY_,NCYP,NCYC,NCYC,NCYC,NCYC,NCYC,NCYC,NCYC,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 80 - 8F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 90 - 9F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // A0 - AF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // B0 - BF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // C0 - CF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // D0 - DF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // E0 - EF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_  // F0 - FF
};

const CHAR_CLASS acc_05[256] = // U+05xx
{
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 00 - 0F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 10 - 1F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 20 - 2F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 30 - 3F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 40 - 4F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAQL,NAQL,NAQL,NAQL,NAQL,NAQL,NAQL, // 50 - 5F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 60 - 6F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 70 - 7F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NPAR,NAQN,NAQL,NAQL,NAQL,NAQL,NAQL, // 80 - 8F
    NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC, // 90 - 9F
    NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC, // A0 - AF
    NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHB_,NHBC, // B0 - BF
    NHB_,NHBC,NHBC,NHB_,NHBC,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_, // C0 - CF
    NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_, // D0 - DF
    NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_, // E0 - EF
    NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_  // F0 - FF
};

const CHAR_CLASS acc_06[256] = // U+06xx
{
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NASR,NAAR,NAAR,NAAR, // 00 - 0F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 10 - 1F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 20 - 2F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 30 - 3F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAC,NAAC,NAAC,NAAC,NAAC, // 40 - 4F
    NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 50 - 5F
    NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAEW,NAAD,NAAD,NAAR,NAAR,NAAR, // 60 - 6F
    NAAC,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 70 - 7F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 80 - 8F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 90 - 9F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // A0 - AF
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // B0 - BF
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // C0 - CF
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC, // D0 - DF
    NAAC,NAAC,NAAC,NAAC,NAAC,NAAR,NAAR,NAAC,NAAC,NANW,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC, // E0 - EF
    NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR  // F0 - FF
};

const CHAR_CLASS acc_07[256] = // U+07xx
{
    NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYW, // 00 - 0F
    NSY_,NSYC,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_, // 10 - 1F
    NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_, // 20 - 2F
    NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC, // 30 - 3F
    NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSY_,NSY_,NSY_,NSY_,NSY_, // 40 - 4F
    XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA, // 50 - 5F
    XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA, // 60 - 6F
    XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA, // 70 - 7F
    NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_, // 80 - 8F
    NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_, // 90 - 9F
    NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC, // A0 - AF
    NTNC,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_, // B0 - BF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // C0 - CF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // D0 - DF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // E0 - EF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_  // F0 - FF
};

const CHAR_CLASS acc_09[256] = // U+09xx
{
    NHI_,NHIC,NHIC,NHIC,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 00 - 0F
    NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 10 - 1F
    NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 20 - 2F
    NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHIC,NHI_,NHIC,NHIC, // 30 - 3F
    NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHI_,NHI_, // 40 - 4F
    NHI_,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 50 - 5F
    NHI_,NHI_,NHIC,NHIC,NHIN,NHIN,NHID,NHID,NHID,NHID,NHID,NHID,NHID,NHID,NHID,NHID, // 60 - 6F
    NHIN,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 70 - 7F
    NBE_,NBEC,NBEC,NBEC,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // 80 - 8F
    NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // 90 - 9F
    NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // A0 - AF
    NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBEC,NBE_,NBEC,NBEC, // B0 - BF
    NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBE_,NBE_, // C0 - CF
    NBE_,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // D0 - DF
    NBE_,NBE_,NBEC,NBEC,NBE_,NBE_,NBED,NBED,NBED,NBED,NBED,NBED,NBED,NBED,NBED,NBED, // E0 - EF
    NBE_,NBE_,NBET,NBET,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_  // F0 - FF
};

const CHAR_CLASS acc_0A[256] = // U+0Axx
{
    NGM_,NGMC,NGMC,NGMC,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 00 - 0F
    NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 10 - 1F
    NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 20 - 2F
    NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGMC,NGM_,NGMC,NGMC, // 30 - 3F
    NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGM_,NGM_, // 40 - 4F
    NGM_,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 50 - 5F
    NGM_,NGM_,NGMC,NGMC,NGM_,NGM_,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD, // 60 - 6F
    NGMC,NGMC,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 70 - 7F
    NGJ_,NGJC,NGJC,NGJC,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // 80 - 8F
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // 90 - 9F
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // A0 - AF
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJC,NGJ_,NGJC,NGJC, // B0 - BF
    NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJ_,NGJ_, // C0 - CF
    NGJ_,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // D0 - DF
    NGJ_,NGJ_,NGJC,NGJC,NGJ_,NGJ_,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD, // E0 - EF
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_  // F0 - FF
};

const CHAR_CLASS acc_0B[256] = // U+0Bxx
{
    NOR_,NORC,NORC,NORC,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 00 - 0F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 10 - 1F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 20 - 2F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NORC,NOR_,NORC,NORC, // 30 - 3F
    NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NOR_,NOR_, // 40 - 4F
    NOR_,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 50 - 5F
    NOR_,NOR_,NORC,NORC,NOR_,NOR_,NORD,NORD,NORD,NORD,NORD,NORD,NORD,NORD,NORD,NORD, // 60 - 6F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 70 - 7F
    NTA_,NTAC,NTAC,NTAC,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // 80 - 8F
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // 90 - 9F
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // A0 - AF
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTAC,NTA_,NTAC,NTAC, // B0 - BF
    NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTA_,NTA_, // C0 - CF
    NTA_,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // D0 - DF
    NTA_,NTA_,NTAC,NTAC,NTA_,NTA_,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD, // E0 - EF
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_  // F0 - FF
};

const CHAR_CLASS acc_0C[256] = // U+0Cxx
{
    NTE_,NTEC,NTEC,NTEC,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 00 - 0F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 10 - 1F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 20 - 2F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTEC,NTE_,NTEC,NTEC, // 30 - 3F
    NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTE_,NTE_, // 40 - 4F
    NTE_,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 50 - 5F
    NTE_,NTE_,NTEC,NTEC,NTE_,NTE_,NTED,NTED,NTED,NTED,NTED,NTED,NTED,NTED,NTED,NTED, // 60 - 6F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 70 - 7F
    NKD_,NKDC,NKDC,NKDC,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // 80 - 8F
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // 90 - 9F
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // A0 - AF
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKDC,NKD_,NKDC,NKDC, // B0 - BF
    NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKD_,NKD_, // C0 - CF
    NKD_,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // D0 - DF
    NKD_,NKD_,NKDC,NKDC,NKD_,NKD_,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD, // E0 - EF
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_  // F0 - FF
};

const CHAR_CLASS acc_0D[256] = // U+0Dxx
{
    NMA_,NMAC,NMAC,NMAC,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 00 - 0F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 10 - 1F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 20 - 2F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMAC,NMA_,NMAC,NMAC, // 30 - 3F
    NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMA_,NMA_, // 40 - 4F
    NMA_,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 50 - 5F
    NMA_,NMA_,NMAC,NMAC,NMA_,NMA_,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD, // 60 - 6F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 70 - 7F
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // 80 - 8F
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // 90 - 9F
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // A0 - AF
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // B0 - BF
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSIC,NSI_,NSI_,NSI_,NSI_,NSIC, // C0 - CF
    NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC, // D0 - DF
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // E0 - EF
    NSI_,NSI_,NSIC,NSIC,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_  // F0 - FF
};

const CHAR_CLASS acc_0E[256] = // U+0Exx
{
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 00 - 0F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 10 - 1F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 20 - 2F
    NTH_,NTHC,NTH_,NTH_,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHT, // 30 - 3F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTH_, // 40 - 4F
    NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 50 - 5F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 60 - 6F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 70 - 7F
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // 80 - 8F
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // 90 - 9F
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // A0 - AF
    NLO_,NLOC,NLO_,NLO_,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLO_,NLO_,NLO_, // B0 - BF
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC, // C0 - CF
    NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // D0 - DF
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // E0 - EF
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_  // F0 - FF
};

const CHAR_CLASS acc_0F[256] = // U+0Fxx
{
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTIC,NTI_,NTI_,NTI_, // 00 - 0F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTIC,NTIC,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 10 - 1F
    NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID, // 20 - 2F
    NTID,NTID,NTID,NTID,NTI_,NTIC,NTI_,NTIC,NTI_,NTIC,NTIN,NTIN,NTIN,NTIN,NTIC,NTIC, // 30 - 3F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 40 - 4F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 50 - 5F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 60 - 6F
    NTI_,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // 70 - 7F
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // 80 - 8F
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // 90 - 9F
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // A0 - AF
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTI_,NTI_, // B0 - BF
    NTIC,NTIC,NTIC,NTIC,NTI_,NTI_,NTIC,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // C0 - CF
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // D0 - DF
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // E0 - EF
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_  // F0 - FF
};

const CHAR_CLASS acc_10[256] = // U+10xx
{
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 00 - 0F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 10 - 1F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBUC,NBUC,NBUC,NBUC, // 20 - 2F
    NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC, // 30 - 3F
    NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 40 - 4F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBUC,NBUC,NBUC,NBUC,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 50 - 5F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 60 - 6F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 70 - 7F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 80 - 8F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 90 - 9F
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // A0 - AF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // B0 - BF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // C0 - CF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // D0 - DF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // E0 - EF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGEQ,NGE_,NGE_,NGE_,NGE_  // F0 - FF
};

const CHAR_CLASS acc_13[256] = // U+13xx
{
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 00 - 0F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 10 - 1F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 20 - 2F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 30 - 3F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 40 - 4F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 50 - 5F
    NET_,NETP,NETP,NETP,NETP,NETP,NETP,NETP,NETP,NETD,NETD,NETD,NETD,NETD,NETD,NETD, // 60 - 6F
    NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NET_,NET_,NET_, // 70 - 7F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 80 - 8F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 90 - 9F
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // A0 - AF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // B0 - BF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // C0 - CF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // D0 - DF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // E0 - EF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_  // F0 - FF
};

const CHAR_CLASS acc_16[256] = // U+16xx
{
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 00 - 0F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 10 - 1F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 20 - 2F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 30 - 3F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 40 - 4F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 50 - 5F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 60 - 6F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 70 - 7F
    NOGS,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_, // 80 - 8F
    NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOGN,NOGN,NOG_,NOG_,NOG_, // 90 - 9F
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // A0 - AF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // B0 - BF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // C0 - CF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // D0 - DF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // E0 - EF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_  // F0 - FF
};

const CHAR_CLASS acc_17[256] = // U+17xx
{
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 00 - 0F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 10 - 1F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 20 - 2F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 30 - 3F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 40 - 4F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 50 - 5F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 60 - 6F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 70 - 7F
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // 80 - 8F
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // 90 - 9F
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // A0 - AF
    NKH_,NKH_,NKH_,NKH_,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC, // B0 - BF
    NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC, // C0 - CF
    NKHC,NKHC,NKHC,NKHC,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKHT,NKH_,NKH_,NKH_,NKH_, // D0 - DF
    NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // E0 - EF
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_  // F0 - FF
};

const CHAR_CLASS acc_18[256] = // U+18xx
{
    NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMOB,NMOB,NMOB,NMOB,NMOB, // 00 - 0F
    NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 10 - 1F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 20 - 2F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 30 - 3F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 40 - 4F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 50 - 5F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 60 - 6F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 70 - 7F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 80 - 8F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 90 - 9F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMOC,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // A0 - AF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // B0 - BF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // C0 - CF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // D0 - DF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // E0 - EF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_  // F0 - FF
};

const CHAR_CLASS acc_1E[256] = // U+1Exx
{
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 10 - 1F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 20 - 2F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 30 - 3F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 40 - 4F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 50 - 5F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 60 - 6F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 70 - 7F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 80 - 8F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 90 - 9F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // A0 - AF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_, // B0 - BF
    ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // C0 - CF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // D0 - DF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // E0 - EF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_  // F0 - FF
};

const CHAR_CLASS acc_1F[256] = // U+1Fxx
{
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 00 - 0F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 10 - 1F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 20 - 2F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 30 - 3F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 40 - 4F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 50 - 5F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 60 - 6F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 70 - 7F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 80 - 8F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 90 - 9F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // A0 - AF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGR_,NGRN, // B0 - BF
    NGRN,NGRN,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN, // C0 - CF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN, // D0 - DF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN, // E0 - EF
    NGRN,NGRN,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN  // F0 - FF
};

const CHAR_CLASS acc_20[256] = // U+20xx
{
    NWBL,NWBL,NWBL,NWBL,NWBL,NWBL,NWBL,NQCS,NWBL,NWBL,NWBL,NWZW,NPZW,NPZW,NPFL,NPF_, // 00 - 0F
    AHYW,NPNW,NHYW,AHYW,AISW,ASNW,ASNW,NONW,AOQW,ARQW,NCQW,NOQW,AOQW,ACQW,NCQW,NOQW, // 10 - 1F
    ASNW,ASNW,NOCW,NONW,NISW,AISW,AISW,AHPW,NSBS,NSBB,NOLE,NORE,NOPF,NOLO,NORO,NBSS, // 20 - 2F
    AQEW,NQEW,AQEW,AQEW,NQEW,AQNW,NQNW,NQNW,NONW,NOQW,NCQW,ASNW,NSSW,NONW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NSSW,NOPW,NCPW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NSBN,NSBN,NSBN,NSBN,NSBN,NSBN, // 60 - 6F
    NSEN,NSEN,NSEN,NSEN,ASAE,NSEN,NSEN,NSEN,NSEN,NSEN,NSET,NSET,NSNW,NSNW,NSNW,ASAN, // 70 - 7F
    NSEN,ASAE,ASAE,ASAE,ASAE,NSEN,NSEN,NSEN,NSEN,NSEN,NSET,NSET,NSNW,NSNW,NSNW,NSNW, // 80 - 8F
    NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW, // 90 - 9F
    NOEW,NPEW,NPEW,NOEW,NPEW,NOEW,NOEW,NQEW,NOEW,HPEW,NPEH,NPEV,NOEW,NOEW,NOEW,NOEW, // A0 - AF
    NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW, // B0 - BF
    NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW, // C0 - CF
    NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO, // D0 - DF
    NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO, // E0 - EF
    NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO  // F0 - FF
};

const CHAR_CLASS acc_21[256] = // U+21xx
{
    NONW,NONW,NOLW,AQNW,NONW,ASNW,NONW,NOLW,NONW,AQNW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 00 - 0F
    NOLW,NOLW,NOLW,ASRN,NONW,NOLW,APNW,NONW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW,NONW,NONW, // 10 - 1F
    NONW,ASNW,ASNW,NONW,NOLW,NONW,AQLW,NONW,NOLW,NONW,NOLW,ASRN,NOLW,NOLW,NOEW,NOLW, // 20 - 2F
    NOLW,NOLW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW, // 30 - 3F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 40 - 4F
    NOLW,NOLW,NOLW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW, // 50 - 5F
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOLW,NOLW,NOLW,NOLW, // 60 - 6F
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 70 - 7F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 80 - 8F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,ASNW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_22[256] = // U+22xx
{
    ASNW,NONW,ASNW,ASNW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,NONW,NONW,NONW,ASNW, // 00 - 0F
    NONW,ASNW,NOEW,NOEW,NONW,ASNW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,ASNW,ASNW,ASNW, // 10 - 1F
    ASNW,NONW,NONW,ASNW,NONW,ASNW,NONW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,ASNW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    ASNW,ASNW,NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,ASNW, // 60 - 6F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_23[256] = // U+23xx
{
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 00 - 0F
    NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 30 - 3F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 40 - 4F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 50 - 5F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 60 - 6F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,NOLW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_24[256] = // U+24xx
{
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 00 - 0F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN, // 60 - 6F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN, // 70 - 7F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN, // 80 - 8F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASRN,ASRN,ASRN,ASRN, // 90 - 9F
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN, // A0 - AF
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // B0 - BF
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // C0 - CF
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN, // D0 - DF
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOEN,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_25[256] = // U+25xx
{
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 00 - 0F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 10 - 1F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 20 - 2F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 30 - 3F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW, // 40 - 4F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 50 - 5F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 60 - 6F
    ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 80 - 8F
    NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    ASNW,ASNW,NONW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW, // B0 - BF
    ASNW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW,ASNW,NONW,NONW,ASNW,NONW,NONW,ASNW,ASNW, // C0 - CF
    ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_26[256] = // U+26xx
{
    NONW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW, // 00 - 0F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,ASNW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 30 - 3F
    ASNW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    ASNW,ASNW,NONW,ASNW,ASNW,ASNW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,ASNW,ASNW,NONW,ASNW, // 60 - 6F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_27[256] = // U+27xx
{
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 00 - 0F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 60 - 6F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_2E[256] = // U+2Exx
{
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 00 - 0F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 10 - 1F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 20 - 2F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 30 - 3F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 40 - 4F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 50 - 5F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 60 - 6F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 70 - 7F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // 80 - 8F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // 90 - 9F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // A0 - AF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // B0 - BF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // C0 - CF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // D0 - DF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // E0 - EF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_  // F0 - FF
};

const CHAR_CLASS acc_30[256] = // U+30xx
{
    WSP_,WC__,WPE_,WOI_,WOI_,WIM_,WOIL,WOIL,WOP_,WCP_,WOP_,WCP_,WOP_,WCP_,WOP_,WCP_, // 00 - 0F
    WOP_,WCP_,WOI_,WOI_,WOB_,WCB_,WOP_,WCP_,WOP_,WCP_,WOP_,WCP_,WSS_,WOQ_,WCQ_,WCQ_, // 10 - 1F
    WOI_,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIC,WOIC,WOIC,WOIC,WOIC,WOIC, // 20 - 2F
    WOI_,WOIL,WOIL,WOIL,WOIL,WOIL,WOI_,WOI_,WOIL,WOIL,WOIL,WOI_,WOI_,WOI_,WOI_,WOI_, // 30 - 3F
    WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 40 - 4F
    WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 50 - 5F
    WHI_,WHI_,WHI_,WHS_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 60 - 6F
    WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 70 - 7F
    WHI_,WHI_,WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHS_,WHI_, // 80 - 8F
    WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WKSC,WKSC,WKSM,WKSM,WHIM,WHIM,WHI_, // 90 - 9F
    WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // A0 - AF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // B0 - BF
    WKA_,WKA_,WKA_,WKS_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // C0 - CF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // D0 - DF
    WKA_,WKA_,WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKS_,WKA_, // E0 - EF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKS_,WKS_,WKA_,WKA_,WKA_,WKA_,WKC_,WKS_,WKIM,WKIM,WKA_  // F0 - FF
};

const CHAR_CLASS acc_31[256] = // U+31xx
{
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // 00 - 0F
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // 10 - 1F
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // 20 - 2F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 30 - 3F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 40 - 4F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 50 - 5F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 60 - 6F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 70 - 7F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 80 - 8F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 90 - 9F
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // A0 - AF
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // B0 - BF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // C0 - CF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // D0 - DF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // E0 - EF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_  // F0 - FF
};

const CHAR_CLASS acc_32[256] = // U+32xx
{
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 00 - 0F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 10 - 1F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 20 - 2F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 30 - 3F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 40 - 4F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 50 - 5F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 60 - 6F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 70 - 7F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 80 - 8F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 90 - 9F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // A0 - AF
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // B0 - BF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // C0 - CF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // D0 - DF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // E0 - EF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL  // F0 - FF
};

const CHAR_CLASS acc_33[256] = // U+33xx
{
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 00 - 0F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 10 - 1F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 20 - 2F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 30 - 3F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 40 - 4F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 50 - 5F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 60 - 6F
    WCI_,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 70 - 7F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 80 - 8F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 90 - 9F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // A0 - AF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // B0 - BF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // C0 - CF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // D0 - DF
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // E0 - EF
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_  // F0 - FF
};

const CHAR_CLASS acc_A4[256] = // U+A4xx
{
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 00 - 0F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 10 - 1F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 20 - 2F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 30 - 3F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 40 - 4F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 50 - 5F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 60 - 6F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 70 - 7F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 80 - 8F
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // 90 - 9F
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // A0 - AF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // B0 - BF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // C0 - CF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // D0 - DF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // E0 - EF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN  // F0 - FF
};

const CHAR_CLASS acc_D8[256] = // U+D8xx
{
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 00 - 0F
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 10 - 1F
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 20 - 2F
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 30 - 3F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 40 - 4F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 50 - 5F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 60 - 6F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 70 - 7F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 80 - 8F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 90 - 9F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // A0 - AF
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // B0 - BF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // C0 - CF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // D0 - DF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // E0 - EF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_  // F0 - FF
};

const CHAR_CLASS acc_E7[256] = // U+E7xx
{
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 00 - 0F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 10 - 1F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 20 - 2F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 30 - 3F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 40 - 4F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 50 - 5F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 60 - 6F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 70 - 7F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 80 - 8F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 90 - 9F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // A0 - AF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // B0 - BF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // C0 - CF
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // D0 - DF
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // E0 - EF
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_  // F0 - FF
};

const CHAR_CLASS acc_E8[256] = // U+E8xx
{
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // 00 - 0F
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // 10 - 1F
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // 20 - 2F
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // 30 - 3F
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // 40 - 4F
    WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_,WID_, // 50 - 5F
    WID_,WID_,WID_,WID_,WID_,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 60 - 6F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 70 - 7F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 80 - 8F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // 90 - 9F
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // A0 - AF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // B0 - BF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // C0 - CF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // D0 - DF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA, // E0 - EF
    WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA,WPUA  // F0 - FF
};

const CHAR_CLASS acc_FB[256] = // U+FBxx
{
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,NLA_,NLA_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NHBR,NHBC,NHBR, // 10 - 1F
    NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBW,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR, // 20 - 2F
    NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR, // 30 - 3F
    NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR, // 40 - 4F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 50 - 5F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 60 - 6F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 70 - 7F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 80 - 8F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 90 - 9F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // A0 - AF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // B0 - BF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // C0 - CF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // D0 - DF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // E0 - EF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS  // F0 - FF
};

const CHAR_CLASS acc_FD[256] = // U+FDxx
{
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 00 - 0F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 10 - 1F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 20 - 2F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NANW,NANW, // 30 - 3F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 40 - 4F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 50 - 5F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 60 - 6F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 70 - 7F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 80 - 8F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 90 - 9F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // A0 - AF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // B0 - BF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // C0 - CF
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // D0 - DF
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // E0 - EF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS  // F0 - FF
};

const CHAR_CLASS acc_FE[256] = // U+FExx
{
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 00 - 0F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 10 - 1F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 20 - 2F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOP5, // 30 - 3F
    WCP5,WOP5,WCP5,WOP5,WCP5,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // 40 - 4F
    WC5S,WC5_,WPE5,WOI_,WOC6,WOC5,WQE5,WQE5,WOI_,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOIT, // 50 - 5F
    WOI_,WOI_,WOIT,WOIT,WOI_,WOI_,WOI_,WOI_,WOI_,WPR_,WQO_,WOI_,WOI_,WOI_,WOI_,WOI_, // 60 - 6F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 70 - 7F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 80 - 8F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 90 - 9F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // A0 - AF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // B0 - BF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // C0 - CF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // D0 - DF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // E0 - EF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NQCW  // F0 - FF
};

const CHAR_CLASS acc_FF[256] = // U+FFxx
{
    XNW_,WQE_,WOI_,WOIT,WPR_,WQO_,WOI_,WOI_,WOB_,WCB_,WOI_,WOIT,WCS_,WOIT,WPES,WOIS, // 00 - 0F
    WD__,WD__,WD__,WD__,WD__,WD__,WD__,WD__,WD__,WD__,WOCS,WOC_,WOI_,WOI_,WOI_,WQE_, // 10 - 1F
    WOI_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_, // 20 - 2F
    WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WOB_,WOI_,WCB_,WOI_,WOI_, // 30 - 3F
    WOI_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_, // 40 - 4F
    WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WOP_,WOI_,WCP_,WOI_,XNW_, // 50 - 5F
    XNW_,HPE_,HOP_,HCP_,HCO_,NKCC,NKA_,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL, // 60 - 6F
    NKSL,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_, // 70 - 7F
    NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_, // 80 - 8F
    NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKS_,NKS_, // 90 - 9F
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_, // A0 - AF
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_, // B0 - BF
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_, // C0 - CF
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,XNW_,XNW_,XNW_, // D0 - DF
    WQO_,WPR_,WOI_,WOI_,WOI_,WPR_,WPR_,XNW_,NOI_,NOI_,NOI_,NOI_,NOI_,NOI_,NOI_,XNW_, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NOBN,NOBN,NOBN,NONW,NONW,NOBN,XNWB  // F0 - FF
};

#pragma data_seg()   // The following structure contains pointers and so cannot be shared

static const CHAR_CLASS * const pccUnicodeClass[256] =
{
    acc_00, acc_01, acc_02, acc_03, acc_04, acc_05, acc_06, acc_07,  // 00 - 07
    __XNW_, acc_09, acc_0A, acc_0B, acc_0C, acc_0D, acc_0E, acc_0F,  // 08 - 0F
    acc_10, __WHG_, __NET_, acc_13, __NCA_, __NCA_, acc_16, acc_17,  // 10 - 17
    acc_18, __XNW_, __XNW_, __XNW_, __XNW_, __XNW_, acc_1E, acc_1F,  // 18 - 1F
    acc_20, acc_21, acc_22, acc_23, acc_24, acc_25, acc_26, acc_27,  // 20 - 27
    __NBR_, __NONW, __NONW, __XNW_, __XNW_, __XNW_, acc_2E, __WOI_,  // 28 - 2F
    acc_30, acc_31, acc_32, acc_33, __WID_, __WID_, __WID_, __WID_,  // 30 - 37
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 38 - 3F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 40 - 47
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 48 - 4F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 50 - 57
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 58 - 5F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 60 - 67
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 68 - 6F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 70 - 77
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 78 - 7F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 80 - 87
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 88 - 8F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 90 - 97
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 98 - 9F
    __WYI_, __WYI_, __WYI_, __WYI_, acc_A4, __XNW_, __XNW_, __XNW_,  // A0 - A7
    __XNW_, __XNW_, __XNW_, __XNW_, __WHG_, __WHG_, __WHG_, __WHG_,  // A8 - AF
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // B0 - B7
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // B8 - BF
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // C0 - C7
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // C8 - CF
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // D0 - D7
    acc_D8, __NHS_, __NHS_, __NHS_, __LS__, __LS__, __LS__, __LS__,  // D8 - DF
    __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, acc_E7,  // E0 - E7
    acc_E8, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA,  // E8 - EF
    __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA,  // F0 - F7
    __WPUA, __WID_, __WID_, acc_FB, __NAAS, acc_FD, acc_FE, acc_FF   // F8 - FF
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\gpexts\gpexts.cxx ===
/******************************Module*Header*******************************\
* Module Name: gpexts.cxx
*
* This file is for debugging tools and extensions.
*
* Created: 05-14-99
* Author: Adrian Secchia
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C" {
#include <excpt.h>
#include <ntstatus.h>
#include <wdbgexts.h>
};

/***************************************************************************\
* Global variables
\***************************************************************************/
WINDBG_EXTENSION_APIS   ExtensionApis;
EXT_API_VERSION         ApiVersion = { (GPVER_PRODUCTVERSION_W >> 8), (GPVER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis, // 64Bit Change
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

VOID
CheckVersion(
    VOID
    )
{
}


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

char *gaszHelpCli[] = {
 "=======================================================================\n"
,"GPEXTS client debugger extentions:\n"
,"-----------------------------------------------------------------------\n"
,"GDI+ UM debugger extensions\n"
,"dgraphics: dumps a Graphics structure\n"
,"dgpgraphics: dumps a GpGraphics structure\n"
,"dmh: dumps gdi+ memory header for memory tracking\n"
,"=======================================================================\n"
,NULL
};

DECLARE_API(help)
{
    char **ppsz = gaszHelpCli;
    while (*ppsz)
      dprintf(*ppsz++);

}

char *gaszStatus[] = {
 "Ok"
,"GenericError"
,"InvalidParameter"
,"OutOfMemory"
,"ObjectBusy"
,"InsufficientBuffer"
,"NotImplemented"
,"Win32Error"
,NULL
};

DECLARE_API(dgraphics)
{
  ULONG Size;
  using namespace Gdiplus;
  GPOBJECT(Gdiplus::Graphics, g);
  PARSE_POINTER(dgraphics_help);
  ReadMemory(arg, g, sizeof(Gdiplus::Graphics), &Size);

  dprintf("Graphics\n");
  dprintf("GpGraphics   *nativeGraphics     %p\n",      g->nativeGraphics);
  dprintf("Status       lastResult          %s (%d)\n", gaszStatus[g->lastResult], g->lastResult);
  return;

dgraphics_help:
    dprintf("Usage: dgraphics [-?] graphics\n");
}


char *gaszGraphicsType[] = {
 "GraphicsBitmap"
,"GraphicsScreen"
,"GraphicsMetafile"
,NULL
};

DECLARE_API(dgpgraphics)
{
  ULONG Size;
  GPOBJECT(GpGraphics, g);
  PARSE_POINTER(dgpgraphics_help);
  ReadMemory(arg, g, sizeof(GpGraphics), &Size);

  dprintf("GpGraphics\n");
  dprintf("GpLockable   Lockable.LockCount  %ld\n", g->Lockable.LockCount);
  dprintf("BOOL         Valid               %s\n",  (g->Tag == ObjectTagGraphics)?"True":"False");
  dprintf("GpRect       SurfaceBounds       (%#lx, %#lx, %#lx, %#lx)\n",
            g->SurfaceBounds.X,
            g->SurfaceBounds.Y,
            g->SurfaceBounds.Width,
            g->SurfaceBounds.Height);
  dprintf("DpBitmap     *Surface            %p\n", g->Surface);
  dprintf("GpMetafile   *Metafile           %p\n", g->Metafile);
  dprintf("GraphicsType Type                %s (%d)\n", gaszGraphicsType[g->Type], g->Type);
  dprintf("GpDevice     *Device             %p\n", g->Device);
  dprintf("DpDriver     *Driver             %p\n", g->Driver);
  dprintf("DpContext    *Context            %p\n", g->Context);
  dprintf("&DpContext   BottomContext       %p\n", GPOFFSETOF(g->BottomContext));
  dprintf("&DpRegion    WindowClip          %p\n", GPOFFSETOF(g->WindowClip));

  return;

dgpgraphics_help:
    dprintf("Usage: dgpgraphics [-?] graphics\n");
  return;
}


// copied from Engine\runtime\standalone\mem.cpp

enum AllocTrackHeaderFlags
{
    MemoryAllocated     = 0x00000001,
    MemoryFreed         = 0x00000002,     // useful in catching double frees
    APIAllocation       = 0x00000004
};

struct AllocTrackHeader {
  struct AllocTrackHeader *flink;
  struct AllocTrackHeader *blink;
  DWORD  size;
  DWORD  caller_address;
  DWORD  flags;
#if DBROWN
  char  *callerFileName;
  INT    callerLineNumber;
#endif
};


DECLARE_API(dmh)
{
  ULONG Size;
  BOOL bRecursive = FALSE;
  BOOL bFLink = FALSE;
  BOOL bBLink = FALSE;
  BOOL bCount = FALSE;
  BOOL bAPI = FALSE;
  int count = 0;

  GPOBJECT(AllocTrackHeader, hdr);
  PARSE_POINTER(dmh_help);


  if(parse_iFindSwitch(tokens, ntok, 'r')!=-1) { bRecursive = TRUE; }
  if(parse_iFindSwitch(tokens, ntok, 'f')!=-1) { bFLink = TRUE; }
  if(parse_iFindSwitch(tokens, ntok, 'b')!=-1) { bBLink = TRUE; }
  if(parse_iFindSwitch(tokens, ntok, 'c')!=-1) { bCount = TRUE; }
  if(parse_iFindSwitch(tokens, ntok, 'a')!=-1) { bAPI = TRUE; }


  do {

    ReadMemory(arg, hdr, sizeof(AllocTrackHeader), &Size);

    if( !bAPI || (hdr->flags & APIAllocation) )
    {
      if(!bCount) {
        dprintf("GPMEM Block (%p)\n", arg);
        dprintf("FLink               0x%p\n", hdr->flink);
        dprintf("BLink               0x%p\n", hdr->blink);
        dprintf("size                0x%p\n", hdr->size);
        dprintf("Allocation callsite 0x%p\n", hdr->caller_address);
        dprintf("Flags               0x%p ", hdr->flags);
        if(hdr->flags & APIAllocation) {dprintf("API");}
        dprintf("\n");
      }
    
      count++;
    }
    arg = (UINT_PTR)(hdr->flink);
    if(bBLink) arg = (UINT_PTR)(hdr->blink);

  } while( bRecursive && arg );


  if(bRecursive) {
    dprintf("Total: %d\n", count);
  }

  return;

dmh_help:
  dprintf("Usage: dmh [-?] [-rfbca] memoryblock\n");
  dprintf("  FLink and BLink are forward and backward memory links in the\n"
          "    double linked list of tracked allocations\n");
  dprintf("  Size is the amount of memory in this allocation\n");
  dprintf("  Allocation Callsite is the return address of the GpMalloc call that\n"
          "    allocated this memory block. Unassemble to find the symbol\n");
  dprintf("  The tracked memory list head is at gdiplus!gpmemAllocList\n");
  dprintf("  -r recursive - default FLink \n");
  dprintf("  -f follow FLink (only useful with -r)\n");
  dprintf("  -b follow BLink (only useful with -r, will override -f)\n");
  dprintf("  -c Suppress output, only display the count. Only useful with -r\n");
  dprintf("  -a Only display blocks with the API flag set.\n");
  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\gpexts\extparse.cxx ===
#include "precomp.hxx"

/* Command line parsing routines
 *
 * This routine should return an array of char* 's in the idx parameter
 * with the beginning of each token in the array.
 * It also returns the number of tokens found. 
 */
int parse_Tokenizer(char *cmdstr, char **tok) {
  char *seps=" \t\n";                  //white space separators
  int tok_count = 0;                   //the token count
  char *token = strtok(cmdstr, seps);  //get the first token
  while(token) {
    tok[tok_count++]=token;
    token = strtok(NULL, seps);
  }
  return tok_count;
}

/* This routine finds the token specified in srchtok 
 * and returns the index into tok.
 * A return value of -1 is used if the token is not found.
 *
 * Generally we use the case insensitive version (parse_iFindToken) 
 * but occasionally we need the case sensitive version (parse_FindToken).
 */
int parse_FindToken(char **tok, int ntok, char *srchtok) {
  for(int i=0; i<ntok; i++) {
    if(strcmp(tok[i], srchtok)==0) break;
  }
  if(i>=ntok) return -1;
  return i;
}

int parse_iFindToken(char **tok, int ntok, char *srchtok) {
  for(int i=0; i<ntok; i++) {
    if(_strnicmp(tok[i], srchtok, strlen(srchtok))==0) break;
  }
  if(i>=ntok) return -1;
  return i;
}

/* Verifies that the given token at tok[tok_pos] is a switch
 * and contains the switch value sw.
 *
 * Both case sensitive and insensitive versions.
 */
int parse_iIsSwitch(char **tok, int tok_pos, char sw) {
  if(tok_pos<0) return 0;
  char *s=tok[tok_pos];
  if((s[0]=='-')||(s[0]=='/')) {  //is a switch.
    for(s++; *s; s++) {
      if(toupper(*s)==toupper(sw)) {return 1;}
    }
  }
  return 0;
}

int parse_IsSwitch(char **tok, int tok_pos, char sw) {
  if(tok_pos<0) return 0;
  char *s=tok[tok_pos];
  if((s[0]=='-')||(s[0]=='/')) {  //is a switch.
    for(s++; *s; s++) {
      if(*s==sw) {return 1;}      //search each char
    }
  }
  return 0;
}

/* Finds a switch in a given list of tokens.
 * of the form -xxx(sw)xxx or /xxx(sw)xxx
 * example:
 * searching for 'a' in -jklabw returns true.
 *
 * Again both case sensitive and insensitive versions are needed.
 */
int parse_FindSwitch(char **tok, int ntok, char sw) {
  for(int i=0; i<ntok; i++) {                          //search each token
    if(parse_IsSwitch(tok, i, sw)) {return i;}         //found it? return position.
  }
  return -1;
}

int parse_iFindSwitch(char **tok, int ntok, char sw) {
  for(int i=0; i<ntok; i++) {
    if(parse_IsSwitch(tok, i, sw)) {return i;}         //found it? return position.
  }
  return -1;
}


/* Find the first non-switch token starting from position start
 * Will find token at position start
 */
int parse_FindNonSwitch(char **tok, int ntok, int start) {
  for(int i=start; i<ntok; i++) {
    if((tok[i][0]!='-')&&(tok[i][0]!='/')) break;
  }
  if(i>=ntok) return -1;
  return i;
}

/* case insensitive token comparer.
 * returns 1 if chk==tok[tok_pos] otherwise returns 0
 *
 * Pay careful attention to the length specifier in the _strnicmp
 */
int parse_iIsToken(char **tok, int tok_pos, char *chk) {
  if(tok_pos<0) {return 0;}
  return (_strnicmp(tok[tok_pos], chk, strlen(chk))==0);
}

/* case sensitive token comparer.
 * returns 1 if chk==tok[tok_pos] otherwise returns 0
 */
int parse_IsToken(char **tok, int tok_pos, char *chk) {
  if(tok_pos<0) {return 0;}
  return (strcmp(tok[tok_pos], chk)==0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\privinc\pixelformats.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Pixel Format definitions.
*
* Abstract:
*
*   Internal pixel format definitions.
*
* Created:
*
*   08/09/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _PIXELFORMATS_H
#define _PIXELFORMATS_H


// First bit of the reserved area
// Used for surfaces that have multiple pixel formats
// e.g. the meta device surface for the multimon driver.

#define PixelFormatMulti        ((PixelFormatID)0x10000000)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplus.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus.h
*
* Abstract:
*
*   GDI+ public header file
*
\**************************************************************************/

#ifndef _GDIPLUS_H
#define _GDIPLUS_H

struct IDirectDrawSurface7;

typedef signed   short   INT16;
typedef unsigned short  UINT16;

#include <pshpack8.h>   // set structure packing to 8

namespace Gdiplus
{
    namespace DllExports
    {
        #include "GdiplusMem.h"
    };

    #include "GdiplusBase.h"

    #include "GdiplusEnums.h"
    #include "GdiplusTypes.h"
    #include "GdiplusInit.h"
    #include "GdiplusPixelFormats.h"
    #include "GdiplusColor.h"
    #include "GdiplusMetaHeader.h"
    #include "GdiplusImaging.h"
    #include "GdiplusColorMatrix.h"

    #include "GdiplusGpStubs.h"
    #include "GdiplusHeaders.h"

    namespace DllExports
    {
        #include "GdiplusFlat.h"
    };


    #include "GdiplusImageAttributes.h"
    #include "GdiplusMatrix.h"
    #include "GdiplusBrush.h"
    #include "GdiplusPen.h"
    #include "GdiplusStringFormat.h"
    #include "GdiplusPath.h"
    #include "GdiplusLineCaps.h"
    #include "GdiplusMetafile.h"
    #include "GdiplusGraphics.h"
    #include "GdiplusCachedBitmap.h"
    #include "GdiplusRegion.h"
    #include "GdiplusFontCollection.h"
    #include "GdiplusFontFamily.h"
    #include "GdiplusFont.h"
    #include "GdiplusBitmap.h"
    #include "GdiplusImageCodec.h"

}; // namespace Gdiplus

#include <poppack.h>    // pop structure packing back to previous state

#endif // !_GDIPLUS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\privinc\imaging.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   imaging.h
*
* Abstract:
*
*   Public SDK header file for the imaging library
*
* Notes:
*
*   This is hand-coded for now. Eventually it'll be automatically
*   generated from an IDL file.
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _IMAGING_H
#define _IMAGING_H

#include "..\sdkinc\GdiplusPixelFormats.h"
#include "..\sdkinc\GdiplusImaging.h"

//
// Imaging library GUIDS:
//  image file format identifiers
//  interface and class identifers
//

#include "imgguids.h"

// Default bitmap resolution

#define DEFAULT_RESOLUTION 96   // most display screens are set to 96 dpi

// Default thumbnail image size in pixels

#define DEFAULT_THUMBNAIL_SIZE 120


//
// Image Property types
//

#define TAG_TYPE_BYTE       1   // 8-bit unsigned int
#define TAG_TYPE_ASCII      2   // 8-bit byte containing one 7-bit ASCII code.
                                // NULL terminated.
#define TAG_TYPE_SHORT      3   // 16-bit unsigned int
#define TAG_TYPE_LONG       4   // 32-bit unsigned int
#define TAG_TYPE_RATIONAL   5   // Two LONGs.  The first LONG is the numerator,
                                // the second LONG expresses the denomintor.
#define TAG_TYPE_UNDEFINED  7   // 8-bit byte that can take any value depending
                                // on field definition
#define TAG_TYPE_SLONG      9   // 32-bit singed integer (2's compliment
                                // notation)
#define TAG_TYPE_SRATIONAL  10  // Two SLONGs. First is numerator, second is
                                // denominator.


//
// Image property ID tags (PROPID's from the EXIF tags)
//

#define TAG_EXIF_IFD            0x8769
#define TAG_GPS_IFD             0x8825

#define TAG_NEW_SUBFILE_TYPE    0x00FE
#define TAG_SUBFILE_TYPE        0x00FF
#define TAG_IMAGE_WIDTH         0x0100
#define TAG_IMAGE_HEIGHT        0x0101
#define TAG_BITS_PER_SAMPLE     0x0102
#define TAG_COMPRESSION         0x0103
#define TAG_PHOTOMETRIC_INTERP  0x0106
#define TAG_THRESH_HOLDING      0x0107
#define TAG_CELL_WIDTH          0x0108
#define TAG_CELL_HEIGHT         0x0109
#define TAG_FILL_ORDER          0x010A
#define TAG_DOCUMENT_NAME       0x010D
#define TAG_IMAGE_DESCRIPTION   0x010E
#define TAG_EQUIP_MAKE          0x010F
#define TAG_EQUIP_MODEL         0x0110
#define TAG_STRIP_OFFSETS       0x0111
#define TAG_ORIENTATION         0x0112
#define TAG_SAMPLES_PER_PIXEL   0x0115
#define TAG_ROWS_PER_STRIP      0x0116
#define TAG_STRIP_BYTES_COUNT   0x0117
#define TAG_MIN_SAMPLE_VALUE    0x0118
#define TAG_MAX_SAMPLE_VALUE    0x0119
#define TAG_X_RESOLUTION        0x011A  // Image resolution in width direction
#define TAG_Y_RESOLUTION        0x011B  // Image resolution in height direction
#define TAG_PLANAR_CONFIG       0x011C  // Image data arrangement
#define TAG_PAGE_NAME           0x011D
#define TAG_X_POSITION          0x011E
#define TAG_Y_POSITION          0x011F
#define TAG_FREE_OFFSET         0x0120
#define TAG_FREE_BYTE_COUNTS    0x0121
#define TAG_GRAY_RESPONSE_UNIT  0x0122
#define TAG_GRAY_RESPONSE_CURVE 0x0123
#define TAG_T4_OPTION           0x0124
#define TAG_T6_OPTION           0x0125
#define TAG_RESOLUTION_UNIT     0x0128  // Unit of X and Y resolution
#define TAG_PAGE_NUMBER         0x0129
#define TAG_TRANSFER_FUNCTION   0x012D
#define TAG_SOFTWARE_USED       0x0131
#define TAG_DATE_TIME           0x0132
#define TAG_ARTIST              0x013B
#define TAG_HOST_COMPUTER       0x013C
#define TAG_PREDICTOR           0x013D
#define TAG_WHITE_POINT         0x013E
#define TAG_PRIMAY_CHROMATICS   0x013F
#define TAG_COLOR_MAP           0x0140
#define TAG_HALFTONE_HINTS      0x0141
#define TAG_TILE_WIDTH          0x0142
#define TAG_TILE_LENGTH         0x0143
#define TAG_TILE_OFFSET         0x0144
#define TAG_TILE_BYTE_COUNTS    0x0145
#define TAG_INK_SET             0x014C
#define TAG_INK_NAMES           0x014D
#define TAG_NUMBER_OF_INKS      0x014E
#define TAG_DOT_RANGE           0x0150
#define TAG_TARGET_PRINTER      0x0151
#define TAG_EXTRA_SAMPLES       0x0152
#define TAG_SAMPLE_FORMAT       0x0153
#define TAG_SMIN_SAMPLE_VALUE   0x0154
#define TAG_SMAX_SAMPLE_VALUE   0x0155
#define TAG_TRANSFER_RANGE      0x0156

#define TAG_JPEG_PROC           0x0200
#define TAG_JPEG_INTER_FORMAT   0x0201
#define TAG_JPEG_INTER_LENGTH   0x0202
#define TAG_JPEG_RESTART_INTERVAL     0x0203
#define TAG_JPEG_LOSSLESS_PREDICTORS  0x0205
#define TAG_JPEG_POINT_TRANSFORMS     0x0206
#define TAG_JPEG_Q_TABLES       0x0207
#define TAG_JPEG_DC_TABLES      0x0208
#define TAG_JPEG_AC_TABLES      0x0209

#define TAG_YCbCr_COEFFICIENTS  0x0211
#define TAG_YCbCr_SUBSAMPLING   0x0212
#define TAG_YCbCr_POSITIONING   0x0213
#define TAG_REF_BLACK_WHITE     0x0214

// ICC profile and gamma
#define TAG_ICC_PROFILE         0x8773          // This TAG is defined by ICC
                                                // for embedded ICC in TIFF
#define TAG_GAMMA               0x0301
#define TAG_ICC_PROFILE_DESCRIPTOR  0x0302
#define TAG_SRGB_RENDERING_INTENT   0x0303

#define TAG_IMAGE_TITLE         0x0320

#define TAG_COPYRIGHT           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define TAG_RESOLUTION_X_UNIT           0x5001
#define TAG_RESOLUTION_Y_UNIT           0x5002
#define TAG_RESOLUTION_X_LENGTH_UNIT    0x5003
#define TAG_RESOLUTION_Y_LENGTH_UNIT    0x5004
#define TAG_PRINT_FLAGS                 0x5005
#define TAG_PRINT_FLAGS_VERSION         0x5006
#define TAG_PRINT_FLAGS_CROP            0x5007
#define TAG_PRINT_FLAGS_BLEEDWIDTH      0x5008
#define TAG_PRINT_FLAGS_BLEEDWIDTHSCALE 0x5009
#define TAG_HALFTONE_LPI                0x500A
#define TAG_HALFTONE_LPI_UNIT           0x500B
#define TAG_HALFTONE_DEGREE             0x500C
#define TAG_HALFTONE_SHAPE              0x500D
#define TAG_HALFTONE_MISC               0x500E
#define TAG_HALFTONE_SCREEN             0x500F
#define TAG_JPEG_QUALITY                0x5010
#define TAG_GRID_SIZE                   0x5011
#define TAG_THUMBNAIL_FORMAT            0x5012  // 1 = JPEG, 0 = RAW RGB
#define TAG_THUMBNAIL_WIDTH             0x5013
#define TAG_THUMBNAIL_HEIGHT            0x5014
#define TAG_THUMBNAIL_COLORDEPTH        0x5015
#define TAG_THUMBNAIL_PLANES            0x5016
#define TAG_THUMBNAIL_RAWBYTES          0x5017
#define TAG_THUMBNAIL_SIZE              0x5018
#define TAG_THUMBNAIL_COMPRESSED_SIZE   0x5019
#define TAG_COLORTRANSFER_FUNCTION      0x501A
#define TAG_THUMBNAIL_DATA              0x501B  // RAW thumbnail bits in JPEG
                                                // format or RGB format depends
                                                // on TAG_THUMBNAIL_FORMAT

// Thumbnail related TAGs
                                                
#define TAG_THUMBNAIL_IMAGE_WIDTH       0x5020  // Thumbnail width
#define TAG_THUMBNAIL_IMAGE_HEIGHT      0x5021  // Thumbnail height
#define TAG_THUMBNAIL_BITS_PER_SAMPLE   0x5022  // Number of bits per component
#define TAG_THUMBNAIL_COMPRESSION       0x5023  // Compression Scheme
#define TAG_THUMBNAIL_PHOTOMETRIC_INTERP 0x5024 // Pixel composition
#define TAG_THUMBNAIL_IMAGE_DESCRIPTION 0x5025  // Image Tile
#define TAG_THUMBNAIL_EQUIP_MAKE        0x5026  // Manufacturer of Image Input
                                                // equipment
#define TAG_THUMBNAIL_EQUIP_MODEL       0x5027  // Model of Image input
                                                // equipment
#define TAG_THUMBNAIL_STRIP_OFFSETS     0x5028  // Image data location
#define TAG_THUMBNAIL_ORIENTATION       0x5029  // Orientation of image
#define TAG_THUMBNAIL_SAMPLES_PER_PIXEL 0x502A  // Number of components
#define TAG_THUMBNAIL_ROWS_PER_STRIP    0x502B  // Number of rows per strip
#define TAG_THUMBNAIL_STRIP_BYTES_COUNT 0x502C  // Bytes per compressed strip
#define TAG_THUMBNAIL_RESOLUTION_X      0x502D  // Resolution in width direction
#define TAG_THUMBNAIL_RESOLUTION_Y      0x502E  // Resolution in height direc
#define TAG_THUMBNAIL_PLANAR_CONFIG     0x502F  // Image data arrangement
#define TAG_THUMBNAIL_RESOLUTION_UNIT   0x5030  // Unit of X and Y Resolution
#define TAG_THUMBNAIL_TRANSFER_FUNCTION 0x5031  // Transfer function
#define TAG_THUMBNAIL_SOFTWARE_USED     0x5032  // Software used
#define TAG_THUMBNAIL_DATE_TIME         0x5033  // File change date and time
#define TAG_THUMBNAIL_ARTIST            0x5034  // Person who created the image
#define TAG_THUMBNAIL_WHITE_POINT       0x5035  // White point chromaticity
#define TAG_THUMBNAIL_PRIMAY_CHROMATICS 0x5036  // Chromaticities of primaries
#define TAG_THUMBNAIL_YCbCr_COEFFICIENTS 0x5037 // Color space transformation
                                                // coefficients
#define TAG_THUMBNAIL_YCbCr_SUBSAMPLING 0x5038  // Subsampling ratio of Y to C
#define TAG_THUMBNAIL_YCbCr_POSITIONING 0x5039  // Y and C position
#define TAG_THUMBNAIL_REF_BLACK_WHITE   0x503A  // Pair of black and white
                                                // reference values
#define TAG_THUMBNAIL_COPYRIGHT         0x503B  // CopyRight holder

#define TAG_INTEROP_INDEX               0x5041  // InteroperabilityIndex
#define TAG_INTEROP_EXIFR98VER          0x5042  // ExifR98 Version

// Special JPEG internal values

#define TAG_LUMINANCE_TABLE             0x5090
#define TAG_CHROMINANCE_TABLE           0x5091

// GIF image

#define TAG_FRAMEDELAY                  0x5100
#define TAG_LOOPCOUNT                   0x5101

// PNG Image

#define TAG_PIXEL_UNIT                  0x5110  // Unit specifier for pixel/unit
#define TAG_PIXEL_PER_UNIT_X            0x5111  // Pixels per unit in X
#define TAG_PIXEL_PER_UNIT_Y            0x5112  // Pixels per unit in Y
#define TAG_PALETTE_HISTOGRAM           0x5113  // Palette histogram

// EXIF specific tag

#define EXIF_TAG_EXPOSURE_TIME  0x829A
#define EXIF_TAG_F_NUMBER       0x829D

#define EXIF_TAG_EXPOSURE_PROG  0x8822
#define EXIF_TAG_SPECTRAL_SENSE 0x8824
#define EXIF_TAG_ISO_SPEED      0x8827
#define EXIF_TAG_OECF           0x8828

#define EXIF_TAG_VER            0x9000
#define EXIF_TAG_D_T_ORIG       0x9003 // Date & time of original
#define EXIF_TAG_D_T_DIGITIZED  0x9004 // Date & time of digital data generation

#define EXIF_TAG_COMP_CONFIG    0x9101
#define EXIF_TAG_COMP_BPP       0x9102

#define EXIF_TAG_SHUTTER_SPEED  0x9201
#define EXIF_TAG_APERATURE      0x9202
#define EXIF_TAG_BRIGHTNESS     0x9203
#define EXIF_TAG_EXPOSURE_BIAS  0x9204
#define EXIF_TAG_MAX_APERATURE  0x9205
#define EXIF_TAG_SUBJECT_DIST   0x9206
#define EXIF_TAG_METERING_MODE  0x9207
#define EXIF_TAG_LIGHT_SOURCE   0x9208
#define EXIF_TAG_FLASH          0x9209
#define EXIF_TAG_FOCAL_LENGTH   0x920A
#define EXIF_TAG_MAKER_NOTE     0x927C
#define EXIF_TAG_USER_COMMENT   0x9286
#define EXIF_TAG_D_T_SUBSEC     0x9290  // Date & Time subseconds
#define EXIF_TAG_D_T_ORIG_SS    0x9291  // Date & Time original subseconds
#define EXIF_TAG_D_T_DIG_SS     0x9292  // Date & TIme digitized subseconds

#define EXIF_TAG_FPX_VER        0xA000
#define EXIF_TAG_COLOR_SPACE    0xA001
#define EXIF_TAG_PIX_X_DIM      0xA002
#define EXIF_TAG_PIX_Y_DIM      0xA003
#define EXIF_TAG_RELATED_WAV    0xA004  // related sound file
#define EXIF_TAG_INTEROP        0xA005
#define EXIF_TAG_FLASH_ENERGY   0xA20B
#define EXIF_TAG_SPATIAL_FR     0xA20C  // Spatial Frequency Response
#define EXIF_TAG_FOCAL_X_RES    0xA20E  // Focal Plane X Resolution
#define EXIF_TAG_FOCAL_Y_RES    0xA20F  // Focal Plane Y Resolution
#define EXIF_TAG_FOCAL_RES_UNIT 0xA210  // Focal Plane Resolution Unit
#define EXIF_TAG_SUBJECT_LOC    0xA214
#define EXIF_TAG_EXPOSURE_INDEX 0xA215
#define EXIF_TAG_SENSING_METHOD 0xA217
#define EXIF_TAG_FILE_SOURCE    0xA300
#define EXIF_TAG_SCENE_TYPE     0xA301
#define EXIF_TAG_CFA_PATTERN    0xA302

#define GPS_TAG_VER             0x0000
#define GPS_TAG_LATTITUDE_REF   0x0001
#define GPS_TAG_LATTITUDE       0x0002
#define GPS_TAG_LONGITUDE_REF   0x0003
#define GPS_TAG_LONGITUDE       0x0004
#define GPS_TAG_ALTITUDE_REF    0x0005
#define GPS_TAG_ALTITUDE        0x0006
#define GPS_TAG_GPS_TIME        0x0007
#define GPS_TAG_GPS_SATELLITES  0x0008
#define GPS_TAG_GPS_STATUS      0x0009
#define GPS_TAG_GPS_MEASURE_MODE 0x00A
#define GPS_TAG_GPS_DOP         0x000B  // Measurement precision
#define GPS_TAG_SPEED_REF       0x000C
#define GPS_TAG_SPEED           0x000D
#define GPS_TAG_TRACK_REF       0x000E
#define GPS_TAG_TRACK           0x000F
#define GPS_TAG_IMG_DIR_REF     0x0010
#define GPS_TAG_IMG_DIR         0x0011
#define GPS_TAG_MAP_DATUM       0x0012
#define GPS_TAG_DEST_LAT_REF    0x0013
#define GPS_TAG_DEST_LAT        0x0014
#define GPS_TAG_DEST_LONG_REF   0x0015
#define GPS_TAG_DEST_LONG       0x0016
#define GPS_TAG_DEST_BEAR_REF   0x0017
#define GPS_TAG_DEST_BEAR       0x0018
#define GPS_TAG_DEST_DIST_REF   0x0019
#define GPS_TAG_DEST_DIST       0x001A

#define MAKEARGB(a, r, g, b) \
        (((ARGB) ((a) & 0xff) << ALPHA_SHIFT) | \
         ((ARGB) ((r) & 0xff) <<   RED_SHIFT) | \
         ((ARGB) ((g) & 0xff) << GREEN_SHIFT) | \
         ((ARGB) ((b) & 0xff) <<  BLUE_SHIFT))

typedef PixelFormat PixelFormatID;

// Map COM Flags to GDI+ Flags
#define PIXFMTFLAG_INDEXED      PixelFormatIndexed
#define PIXFMTFLAG_GDI          PixelFormatGDI
#define PIXFMTFLAG_ALPHA        PixelFormatAlpha
#define PIXFMTFLAG_PALPHA       PixelFormatPAlpha
#define PIXFMTFLAG_EXTENDED     PixelFormatExtended
#define PIXFMTFLAG_CANONICAL    PixelFormatCanonical
#define PIXFMT_UNDEFINED        PixelFormatUndefined
#define PIXFMT_DONTCARE         PixelFormatDontCare
#define PIXFMT_1BPP_INDEXED     PixelFormat1bppIndexed
#define PIXFMT_4BPP_INDEXED     PixelFormat4bppIndexed
#define PIXFMT_8BPP_INDEXED     PixelFormat8bppIndexed
#define PIXFMT_16BPP_GRAYSCALE  PixelFormat16bppGrayScale
#define PIXFMT_16BPP_RGB555     PixelFormat16bppRGB555
#define PIXFMT_16BPP_RGB565     PixelFormat16bppRGB565
#define PIXFMT_16BPP_ARGB1555   PixelFormat16bppARGB1555
#define PIXFMT_24BPP_RGB        PixelFormat24bppRGB
#define PIXFMT_32BPP_RGB        PixelFormat32bppRGB
#define PIXFMT_32BPP_ARGB       PixelFormat32bppARGB
#define PIXFMT_32BPP_PARGB      PixelFormat32bppPARGB
#define PIXFMT_48BPP_RGB        PixelFormat48bppRGB
#define PIXFMT_64BPP_ARGB       PixelFormat64bppARGB
#define PIXFMT_64BPP_PARGB      PixelFormat64bppPARGB

#define PIXFMT_24BPP_BGR        (15 | (24 << 8) | PixelFormatGDI)
#define PIXFMT_MAX              PixelFormatMax + 1

#define PALFLAG_HASALPHA        PaletteFlagsHasAlpha
#define PALFLAG_GRAYSCALE       PaletteFlagsGrayScale
#define PALFLAG_HALFTONE        PaletteFlagsHalftone

#define IMGLOCK_READ              ImageLockModeRead
#define IMGLOCK_WRITE             ImageLockModeWrite
#define IMGLOCK_USERINPUTBUF      ImageLockModeUserInputBuf

#define IMGFLAG_NONE                ImageFlagsNone
#define IMGFLAG_SCALABLE            ImageFlagsScalable
#define IMGFLAG_HASALPHA            ImageFlagsHasAlpha
#define IMGFLAG_HASTRANSLUCENT      ImageFlagsHasTranslucent
#define IMGFLAG_PARTIALLY_SCALABLE  ImageFlagsPartiallyScalable
#define IMGFLAG_COLORSPACE_RGB      ImageFlagsColorSpaceRGB
#define IMGFLAG_COLORSPACE_CMYK     ImageFlagsColorSpaceCMYK
#define IMGFLAG_COLORSPACE_GRAY     ImageFlagsColorSpaceGRAY
#define IMGFLAG_COLORSPACE_YCBCR    ImageFlagsColorSpaceYCBCR
#define IMGFLAG_COLORSPACE_YCCK     ImageFlagsColorSpaceYCCK
#define IMGFLAG_HASREALDPI          ImageFlagsHasRealDPI
#define IMGFLAG_HASREALPIXELSIZE    ImageFlagsHasRealPixelSize
#define IMGFLAG_READONLY            ImageFlagsReadOnly
#define IMGFLAG_CACHING             ImageFlagsCaching

#define ImageFlag                   ImageFlags


//
// Decoder flags
//

/* Only used in COM interface */
enum DecoderInitFlag
{
    DecoderInitFlagNone        = 0,

    // NOBLOCK indicates that the caller requires non-blocking
    // behavior.  This will be honored only by non-blocking decoders, that
    // is, decoders that don't have the IMGCODEC_BLOCKING_DECODE flag.

    DecoderInitFlagNoBlock     = 0x0001,

    // Choose built-in decoders first before looking at any
    // installed plugin decoders.

    DecoderInitFlagBuiltIn1st  = 0x0002
};

#define DECODERINIT_NONE          DecoderInitFlagNone
#define DECODERINIT_NOBLOCK       DecoderInitFlagNoBlock
#define DECODERINIT_BUILTIN1ST    DecoderInitFlagBuiltIn1st

/* Only used in COM interface */
enum BufferDisposalFlag
{
    BufferDisposalFlagNone,
    BufferDisposalFlagGlobalFree,
    BufferDisposalFlagCoTaskMemFree,
    BufferDisposalFlagUnmapView
};
    
#define DISPOSAL_NONE            BufferDisposalFlagNone
#define DISPOSAL_GLOBALFREE      BufferDisposalFlagGlobalFree
#define DISPOSAL_COTASKMEMFREE   BufferDisposalFlagCoTaskMemFree
#define DISPOSAL_UNMAPVIEW       BufferDisposalFlagUnmapView

//---------------------------------------------------------------------------
// Intepolation hints used by resize/rotation operations
//---------------------------------------------------------------------------
enum InterpolationHint
{
    InterpolationHintDefault,
    InterpolationHintNearestNeighbor,
    InterpolationHintBilinear,
    InterpolationHintAveraging,
    InterpolationHintBicubic
};

#define INTERP_DEFAULT              InterpolationHintDefault
#define INTERP_NEAREST_NEIGHBOR     InterpolationHintNearestNeighbor
#define INTERP_BILINEAR             InterpolationHintBilinear
#define INTERP_AVERAGING            InterpolationHintAveraging
#define INTERP_BICUBIC              InterpolationHintBicubic

#define IMGCODEC_ENCODER          ImageCodecFlagsEncoder
#define IMGCODEC_DECODER          ImageCodecFlagsDecoder
#define IMGCODEC_SUPPORT_BITMAP   ImageCodecFlagsSupportBitmap
#define IMGCODEC_SUPPORT_VECTOR   ImageCodecFlagsSupportVector
#define IMGCODEC_SEEKABLE_ENCODE  ImageCodecFlagsSeekableEncode
#define IMGCODEC_BLOCKING_DECODE  ImageCodecFlagsBlockingDecode

#define IMGCODEC_BUILTIN          ImageCodecFlagsBuiltin
#define IMGCODEC_SYSTEM           ImageCodecFlagsSystem
#define IMGCODEC_USER             ImageCodecFlagsUser

//
// Identifier for channel(s) in a pixel
//
/* Only used internally */
enum ChannelID
{
    ChannelID_Alpha      = 0x00000001,
    ChannelID_Red        = 0x00000002,
    ChannelID_Green      = 0x00000004,
    ChannelID_Blue       = 0x00000008,
    ChannelID_Color      = ChannelID_Red|ChannelID_Green|ChannelID_Blue,
    ChannelID_All        = ChannelID_Color|ChannelID_Alpha,
    
    ChannelID_Intensity  = 0x00010000
};

//
// Data structure for communicating to an image sink
//

/* Only used internally */
enum SinkFlags
{
    // Low-word: shared with ImgFlagx

    SinkFlagsScalable          = ImageFlagsScalable,
    SinkFlagsHasAlpha          = ImageFlagsHasAlpha,
    SinkFlagsPartiallyScalable = ImageFlagsPartiallyScalable,
    
    // High-word

    SinkFlagsTopDown    = 0x00010000,
    SinkFlagsBottomUp   = 0x00020000,
    SinkFlagsFullWidth  = 0x00040000,
    SinkFlagsMultipass  = 0x00080000,
    SinkFlagsComposite  = 0x00100000,
    SinkFlagsWantProps  = 0x00200000
};

#define SINKFLAG_SCALABLE           SinkFlagsScalable
#define SINKFLAG_HASALPHA           SinkFlagsHasAlpha
#define SINKFLAG_PARTIALLY_SCALABLE SinkFlagsPartiallyScalable
#define SINKFLAG_TOPDOWN    SinkFlagsTopDown
#define SINKFLAG_BOTTOMUP   SinkFlagsBottomUp
#define SINKFLAG_FULLWIDTH  SinkFlagsFullWidth
#define SINKFLAG_MULTIPASS  SinkFlagsMultipass
#define SINKFLAG_COMPOSITE  SinkFlagsComposite
#define SINKFLAG_WANTPROPS  SinkFlagsWantProps

/* Only used internally */
struct ImageInfo
{
    GUID RawDataFormat;
    PixelFormat PixelFormat;
    UINT Width, Height;
    UINT TileWidth, TileHeight;
    double Xdpi, Ydpi;
    UINT Flags;
};

//
// Interface and class identifiers
//

interface IImagingFactory;
interface IImage;
interface IBitmapImage;
interface IImageDecoder;
interface IImageEncoder;
interface IImageSink;
interface IBasicBitmapOps;

//--------------------------------------------------------------------------
// Imaging utility factory object
//  This is a CoCreate-able object.
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDA7-072B-11D3-9D7B-0000F81EF32E")
IImagingFactory : public IUnknown
{
public:

    // Create an image object from an input stream
    //  stream doesn't have to seekable
    //  caller should Release the stream if call is successful

    STDMETHOD(CreateImageFromStream)(
        IN IStream* stream,
        OUT IImage** image
        ) = 0;

    // Create an image object from a file

    STDMETHOD(CreateImageFromFile)(
        IN const WCHAR* filename,
        OUT IImage** image
        ) = 0;
    
    // Create an image object from a memory buffer

    STDMETHOD(CreateImageFromBuffer)(
        IN const VOID* buf,
        IN UINT size,
        IN BufferDisposalFlag disposalFlag,
        OUT IImage** image
        ) = 0;

    // Create a new bitmap image object

    STDMETHOD(CreateNewBitmap)(
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a bitmap image from an IImage object

    STDMETHOD(CreateBitmapFromImage)(
        IN IImage* image,
        IN OPTIONAL UINT width,
        IN OPTIONAL UINT height,
        IN OPTIONAL PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a new bitmap image object on user-supplied memory buffer

    STDMETHOD(CreateBitmapFromBuffer)(
        IN BitmapData* bitmapData,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create an image decoder object to process the given input stream

    STDMETHOD(CreateImageDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags,
        OUT IImageDecoder** decoder
        ) = 0;

    // Create an image encoder object that can output data in the
    // specified image file format.

    STDMETHOD(CreateImageEncoderToStream)(
        IN const CLSID* clsid,
        IN IStream* stream,
        OUT IImageEncoder** encoder
        ) = 0;

    STDMETHOD(CreateImageEncoderToFile)(
        IN const CLSID* clsid,
        IN const WCHAR* filename,
        OUT IImageEncoder** encoder
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledDecoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** decoders
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledEncoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** encoders
        ) = 0;

    // Install an image encoder / decoder
    //  caller should do the regular COM component
    //  installation before calling this method

    STDMETHOD(InstallImageCodec)(
        IN const ImageCodecInfo* codecInfo
        ) = 0;

    // Uninstall an image encoder / decoder

    STDMETHOD(UninstallImageCodec)(
        IN const WCHAR* codecName,
        IN UINT flags
        ) = 0;
};

//--------------------------------------------------------------------------
// Image interface
//  bitmap image
//  vector image
//  procedural image
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDA9-072B-11D3-9D7B-0000F81EF32E")
IImage : public IUnknown
{
public:

    // Get the device-independent physical dimension of the image
    //  in unit of 0.01mm

    STDMETHOD(GetPhysicalDimension)(
        OUT SIZE* size
        ) = 0;

    // Get basic image info

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Set image flags

    STDMETHOD(SetImageFlags)(
        IN UINT flags
        ) = 0;

    // Display the image in a GDI device context

    STDMETHOD(Draw)(
        IN HDC hdc,
        IN const RECT* dstRect,
        IN OPTIONAL const RECT* srcRect
        ) = 0;

    // Push image data into an IImageSink

    STDMETHOD(PushIntoSink)(
        IN IImageSink* sink
        ) = 0;

    // Get a thumbnail representation for the image object

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;
};


//--------------------------------------------------------------------------
// Bitmap interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAA-072B-11D3-9D7B-0000F81EF32E")
IBitmapImage : public IUnknown
{
public:

    // Get bitmap dimensions in pixels

    STDMETHOD(GetSize)(
        OUT SIZE* size
        ) = 0;

    // Get bitmap pixel format

    STDMETHOD(GetPixelFormatID)(
        OUT PixelFormatID* pixelFormat
        ) = 0;

    // Access bitmap data in the specified pixel format
    //  must support at least PIXFMT_DONTCARE and
    //  the caninocal formats.

    STDMETHOD(LockBits)(
        IN const RECT* rect,
        IN UINT flags,
        IN PixelFormatID pixelFormat,
        IN OUT BitmapData* lockedBitmapData
        ) = 0;

    STDMETHOD(UnlockBits)(
        IN const BitmapData* lockedBitmapData
        ) = 0;

    // Set/get palette associated with the bitmap image

    STDMETHOD(GetPalette)(
        OUT ColorPalette** palette
        ) = 0;

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;
};


//--------------------------------------------------------------------------
// Interface for performing basic operations on a bitmap image
//  This can be QI'ed from an IBitmapImage object.
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAF-072B-11D3-9D7B-0000F81EF32E")
IBasicBitmapOps : public IUnknown
{
public:

    // Clone an area of the bitmap image

    STDMETHOD(Clone)(
        IN OPTIONAL const RECT* rect,
        OUT IBitmapImage** outbmp,
        BOOL    bNeedCloneProperty
        );

    // Flip the bitmap image in x- and/or y-direction

    STDMETHOD(Flip)(
        IN BOOL flipX,
        IN BOOL flipY,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Resize the bitmap image

    STDMETHOD(Resize)(
        IN UINT newWidth,
        IN UINT newHeight,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Rotate the bitmap image by the specified angle

    STDMETHOD(Rotate)(
        IN FLOAT angle,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Adjust the brightness of the bitmap image

    STDMETHOD(AdjustBrightness)(
        IN FLOAT percent
        ) = 0;
    
    // Adjust the contrast of the bitmap image

    STDMETHOD(AdjustContrast)(
        IN FLOAT shadow,
        IN FLOAT highlight
        ) = 0;
    
    // Adjust the gamma of the bitmap image

    STDMETHOD(AdjustGamma)(
        IN FLOAT gamma
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decoder interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAB-072B-11D3-9D7B-0000F81EF32E")
IImageDecoder : public IUnknown
{
public:

    // Initialize the image decoder object

    STDMETHOD(InitDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags
        ) = 0;

    // Clean up the image decoder object

    STDMETHOD(TerminateDecoder)() = 0;

    // Start decoding the current frame

    STDMETHOD(BeginDecode)(
        IN IImageSink* sink,
        IN OPTIONAL IPropertySetStorage* newPropSet
        ) = 0;

    // Continue decoding

    STDMETHOD(Decode)() = 0;

    // Stop decoding the current frame

    STDMETHOD(EndDecode)(
        IN HRESULT statusCode
        ) = 0;

    // Query multi-frame dimensions

    STDMETHOD(GetFrameDimensionsCount)(
        OUT UINT* count
        ) = 0;

    STDMETHOD(GetFrameDimensionsList)(
        OUT GUID* dimensionIDs,
        IN OUT UINT count
        ) = 0;

    // Get number of frames for the specified dimension

    STDMETHOD(GetFrameCount)(
        IN const GUID* dimensionID,
        OUT UINT* count
        ) = 0;

    // Select currently active frame

    STDMETHOD(SelectActiveFrame)(
        IN const GUID* dimensionID,
        IN UINT frameIndex
        ) = 0;

    // Get basic information about the image

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Get image thumbnail

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;

    // Query decoder parameters

    STDMETHOD(QueryDecoderParam)(
        IN GUID     Guid
        ) = 0;

    // Set decoder parameters

    STDMETHOD(SetDecoderParam)(
        IN GUID     Guid,
        IN UINT     Length,
        IN PVOID    Value
        ) = 0;
    
    // Property related functions

    STDMETHOD(GetPropertyCount)(
        OUT UINT* numOfProperty
        ) = 0;

    STDMETHOD(GetPropertyIdList)(
        IN UINT numOfProperty,
  	    IN OUT PROPID* list
        ) = 0;

    STDMETHOD(GetPropertyItemSize)(
        IN PROPID propId, 
        OUT UINT* size
        ) = 0;
    
    STDMETHOD(GetPropertyItem)(
        IN PROPID propId,
        IN UINT propSize,
        IN OUT PropertyItem* buffer
        ) = 0;

    STDMETHOD(GetPropertySize)(
        OUT UINT* totalBufferSize,
		OUT UINT* numProperties
        ) = 0;

    STDMETHOD(GetAllPropertyItems)(
        IN UINT totalBufferSize,
        IN UINT numProperties,
        IN OUT PropertyItem* allItems
        ) = 0;

    STDMETHOD(RemovePropertyItem)(
        IN PROPID   propId
        ) = 0;

    STDMETHOD(SetPropertyItem)(
        IN PropertyItem item
        ) = 0;

    STDMETHOD(GetRawInfo)(
        IN OUT VOID **ppRawInfo
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decode sink interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAE-072B-11D3-9D7B-0000F81EF32E")
IImageSink : public IUnknown
{
public:

    // Begin the sink process

    STDMETHOD(BeginSink)(
        IN OUT ImageInfo* imageInfo,
        OUT OPTIONAL RECT* subarea
        ) = 0;

    // End the sink process

    STDMETHOD(EndSink)(
        IN HRESULT statusCode
        ) = 0;

    // Pass the color palette to the image sink

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;

    // Ask the sink to allocate pixel data buffer

    STDMETHOD(GetPixelDataBuffer)(
        IN const RECT* rect,
        IN PixelFormatID pixelFormat,
        IN BOOL lastPass,
        OUT BitmapData* bitmapData
        ) = 0;

    // Give the sink pixel data and release data buffer

    STDMETHOD(ReleasePixelDataBuffer)(
        IN const BitmapData* bitmapData
        ) = 0;

    // Push pixel data

    STDMETHOD(PushPixelData)(
        IN const RECT* rect,
        IN const BitmapData* bitmapData,
        IN BOOL lastPass
        ) = 0;

    // Push raw image data

    STDMETHOD(PushRawData)(
        IN const VOID* buffer,
        IN UINT bufsize
        ) = 0;

    STDMETHOD(NeedTransform)(
        OUT UINT* rotation
        ) = 0;

    STDMETHOD(NeedRawProperty)(
        IN void *pSrc) = 0;
    
    STDMETHOD(PushRawInfo)(
        IN OUT void* info
        ) = 0;

    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        ) = 0;
    
    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item,
        IN BOOL             fICCProfileChanged
        ) = 0;
};


//--------------------------------------------------------------------------
// Image encoder interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAC-072B-11D3-9D7B-0000F81EF32E")
IImageEncoder : public IUnknown
{
public:

    // Initialize the image encoder object

    STDMETHOD(InitEncoder)(
        IN IStream* stream
        ) = 0;
    
    // Clean up the image encoder object

    STDMETHOD(TerminateEncoder)() = 0;

    // Get an IImageSink interface for encoding the next frame

    STDMETHOD(GetEncodeSink)(
        OUT IImageSink** sink
        ) = 0;
    
    // Set active frame dimension

    STDMETHOD(SetFrameDimension)(
        IN const GUID* dimensionID
        ) = 0;
    
    STDMETHOD(GetEncoderParameterListSize)(
       	OUT UINT* size
        ) = 0;

    STDMETHOD(GetEncoderParameterList)(
        IN UINT	  size,
        OUT EncoderParameters* Params
        ) = 0;

    STDMETHOD(SetEncoderParameters)(
        IN const EncoderParameters* Param
        ) = 0;
};


//--------------------------------------------------------------------------
// Imaging library error codes
//
// !!! TODO
//  How does one pick a facility code?
//
// Standard error code used:
//  E_INVALIDARG
//  E_OUTOFMEMORY
//  E_NOTIMPL
//  E_ACCESSDENIED
//  E_PENDING
//--------------------------------------------------------------------------

#define FACILITY_IMAGING        0x87b
#define MAKE_IMGERR(n)          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_IMAGING, n)
#define IMGERR_OBJECTBUSY       MAKE_IMGERR(1)
#define IMGERR_NOPALETTE        MAKE_IMGERR(2)
#define IMGERR_BADLOCK          MAKE_IMGERR(3)
#define IMGERR_BADUNLOCK        MAKE_IMGERR(4)
#define IMGERR_NOCONVERSION     MAKE_IMGERR(5)
#define IMGERR_CODECNOTFOUND    MAKE_IMGERR(6)
#define IMGERR_NOFRAME          MAKE_IMGERR(7)
#define IMGERR_ABORT            MAKE_IMGERR(8)
#define IMGERR_FAILLOADCODEC    MAKE_IMGERR(9)
#define IMGERR_PROPERTYNOTFOUND MAKE_IMGERR(10)
#define IMGERR_PROPERTYNOTSUPPORTED MAKE_IMGERR(11)

#endif // !_IMAGING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\privinc\imgguids.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   imgguids.h
*
* Abstract:
*
*   GUIDs defined and used by the imaging library
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

//
// Image file format identifiers
//

DEFINE_GUID(IMGFMT_UNDEFINED, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_MEMORYBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_BMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_WMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_JPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_GIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_TIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PHOTOCD, 0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_FLASHPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_ICO, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Interface and class identifiers
//

DEFINE_GUID(IID_IImagingFactory, 0x327abda7,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(CLSID_ImagingFactory, 0x327abda8,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImage, 0x327abda9,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBitmapImage, 0x327abdaa,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageDecoder, 0x327abdab,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageEncoder, 0x327abdac,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageSink, 0x327abdae,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBasicBitmapOps, 0x327abdaf,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageBytes,0x025d1823,0x6c7d,0x447b,0xbb, 0xdb, 0xa3, 0xcb, 0xc3, 0xdf, 0xa2, 0xfc);

//
// Predefined multi-frame dimension IDs
//

DEFINE_GUID(FRAMEDIM_TIME, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FRAMEDIM_RESOLUTION, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FRAMEDIM_PAGE, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//
// Property sets
//

DEFINE_GUID(FMTID_ImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FMTID_JpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

//
// Decoder parameter sets
//
DEFINE_GUID(DECODER_TRANSCOLOR, 0xb7a98c8f,0xdce7,0x457d,0xbf,0xa5,0xce,0xa7,0x1b,0xd1,0x4d,0xd6);
DEFINE_GUID(DECODER_TRANSRANGE, 0xabeed189,0xd988,0x4d03,0xb4,0x25,0x57,0x10,0x55,0xc7,0x6a,0xd1);
DEFINE_GUID(DECODER_OUTPUTCHANNEL, 0x2ff8f51e,0x724d,0x45fe,0x86,0xce,0x17,0x77,0xa0,0x56,0xda,0x60);
DEFINE_GUID(DECODER_ICONRES, 0x5c656eec,0xe94f,0x45ba,0xa6,0xf6,0x10,0x62,0xe8,0x5f,0x4a,0x7f);
DEFINE_GUID(DECODER_USEICC,  0x1d6347c4,0x5ec2,0x4070,0x81,0x4d,0x7a,0x6e,0x39,0xa4,0x23,0xa2);
 
//
// Encoder parameter sets
//
DEFINE_GUID(ENCODER_COMPRESSION, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(ENCODER_COLORDEPTH, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(ENCODER_SCANMETHOD, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(ENCODER_VERSION, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(ENCODER_RENDERMETHOD, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(ENCODER_QUALITY, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(ENCODER_ROTATION,0x109555d4,0x2ab6,0x4379,0xa8,0x3f,0x5d,0x78,0xfa,0x53,0x8c,0x45);
DEFINE_GUID(ENCODER_TRANSFORMATION,0x8d0eb2d1,0xa58e,0x4ea8,0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9);
DEFINE_GUID(ENCODER_LUMINANCE_TABLE,0xedb33bce,0x0266,0x4a77,0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17);
DEFINE_GUID(ENCODER_CHROMINANCE_TABLE,0xf2e455dc,0x09b3,0x4316,0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c);
DEFINE_GUID(ENCODER_TRIMEDGE,0xac9cd9ec,0x116a,0x484e,0xba,0xea,0xca,0x32,0xef,0x9b,0x84,0x80);
DEFINE_GUID(ENCODER_SUPPRESSAPP0,0xb42b3959,0x57ef,0x4efc,0xa3,0x63,0x94,0x22,0x0,0x8a,0xdc,0xb4);
DEFINE_GUID(ENCODER_SAVE_FLAG,0x292266fc,0xac40,0x47bf,0x8c, 0xfc, 0xa8, 0x5b, 0x89, 0xa6, 0x55, 0xde);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusbase.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusBase.h
*
* Abstract:
*
*   GDI+ base memory allocation class
*
\**************************************************************************/

#ifndef _GDIPLUSBASE_H
#define _GDIPLUSBASE_H

class GdiplusBase
{
public:
    void (operator delete)(void* in_pVoid)
    {
       DllExports::GdipFree(in_pVoid);
    }
    void* (operator new)(size_t in_size)
    {
       return DllExports::GdipAlloc(in_size);
    }
    void (operator delete[])(void* in_pVoid)
    {
       DllExports::GdipFree(in_pVoid);
    }
    void* (operator new[])(size_t in_size)
    {
       return DllExports::GdipAlloc(in_size);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusbitmap.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusBitmap.h
*
* Abstract:
*
*   GDI+ Bitmap class
*
\**************************************************************************/

#ifndef _GDIPLUSBITMAP_H
#define _GDIPLUSBITMAP_H

inline 
Image::Image(
    IN const WCHAR* filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    nativeImage = NULL;
    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipLoadImageFromFileICM(
            filename, 
            &nativeImage
        );
    }
    else
    {      
        lastResult = DllExports::GdipLoadImageFromFile(
            filename, 
            &nativeImage
        );
    }
}

inline 
Image::Image(
    IN IStream* stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    nativeImage = NULL;
    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipLoadImageFromStreamICM(
            stream, 
            &nativeImage
        );
    }
    else
    {
        lastResult = DllExports::GdipLoadImageFromStream(
            stream, 
            &nativeImage
        );
    }
}

inline Image* 
Image::FromFile(
    IN const WCHAR* filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Image(
        filename, 
        useEmbeddedColorManagement
    );
}

inline Image*
Image::FromStream(
    IN IStream* stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Image(
        stream,
        useEmbeddedColorManagement
    );
}

inline 
Image::~Image()
{
    DllExports::GdipDisposeImage(nativeImage);
}

inline Image* 
Image::Clone() 
{
    GpImage *cloneimage = NULL;

    SetStatus(DllExports::GdipCloneImage(nativeImage, &cloneimage));

    return new Image(cloneimage, lastResult);
}

inline UINT
Image::GetEncoderParameterListSize(
    IN const CLSID* clsidEncoder
    ) 
{
    UINT size = 0;

    SetStatus(DllExports::GdipGetEncoderParameterListSize(nativeImage,
                                                          clsidEncoder,
                                                          &size));
    return size;
}

inline Status
Image::GetEncoderParameterList(
    IN const CLSID* clsidEncoder,
    IN UINT size,
    OUT EncoderParameters* buffer
    )
{
    return SetStatus(DllExports::GdipGetEncoderParameterList(nativeImage,
                                                             clsidEncoder,
                                                             size,
                                                             buffer));
}

inline Status
Image::Save(
    IN const WCHAR* filename,
    IN const CLSID* clsidEncoder,
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveImageToFile(nativeImage,
                                                     filename,
                                                     clsidEncoder,
                                                     encoderParams));
}

inline Status
Image::Save(
    IN IStream* stream,
    IN const CLSID* clsidEncoder,
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveImageToStream(nativeImage,
                                                       stream,
                                                       clsidEncoder,
                                                       encoderParams));
}

inline Status
Image::SaveAdd(
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveAdd(nativeImage,
                                             encoderParams));
}

inline Status
Image::SaveAdd(
    IN Image* newImage,
    IN const EncoderParameters *encoderParams
    )
{
    if ( newImage == NULL )
    {
        return SetStatus(InvalidParameter);
    }

    return SetStatus(DllExports::GdipSaveAddImage(nativeImage,
                                                  newImage->nativeImage,
                                                  encoderParams));
}

inline ImageType 
Image::GetType() const
{
    ImageType type = ImageTypeUnknown;

    SetStatus(DllExports::GdipGetImageType(nativeImage, &type));

    return type;
}

inline Status 
Image::GetPhysicalDimension(
    OUT SizeF* size
    ) 
{
    if (size == NULL) 
    {
        return SetStatus(InvalidParameter);
    }
    
    REAL width, height;
    Status status;

    status = SetStatus(DllExports::GdipGetImageDimension(nativeImage,
                                                         &width, &height));

    size->Width  = width;
    size->Height = height;

    return status;
}

inline Status 
Image::GetBounds(
    OUT RectF *srcRect, 
    OUT Unit *srcUnit
    )
{
    return SetStatus(DllExports::GdipGetImageBounds(nativeImage,
                                                    srcRect, srcUnit));
}

inline UINT 
Image::GetWidth()
{
    UINT width = 0;

    SetStatus(DllExports::GdipGetImageWidth(nativeImage, &width));

    return width;
}

inline UINT 
Image::GetHeight()
{
    UINT height = 0;

    SetStatus(DllExports::GdipGetImageHeight(nativeImage, &height));

    return height;
}

inline REAL 
Image::GetHorizontalResolution()
{
    REAL resolution = 0.0f;

    SetStatus(DllExports::GdipGetImageHorizontalResolution(nativeImage, &resolution));

    return resolution;
}

inline REAL 
Image::GetVerticalResolution()
{
    REAL resolution = 0.0f;

    SetStatus(DllExports::GdipGetImageVerticalResolution(nativeImage, &resolution));

    return resolution;
}

inline UINT 
Image::GetFlags()
{
    UINT flags = 0;

    SetStatus(DllExports::GdipGetImageFlags(nativeImage, &flags));

    return flags;
}

inline Status 
Image::GetRawFormat(OUT GUID *format)
{
    return SetStatus(DllExports::GdipGetImageRawFormat(nativeImage, format));
}

inline PixelFormat 
Image::GetPixelFormat()
{
    PixelFormat format;

    SetStatus(DllExports::GdipGetImagePixelFormat(nativeImage, &format));

    return format;
}

inline INT 
Image::GetPaletteSize()
{
    INT size = 0;
    
    SetStatus(DllExports::GdipGetImagePaletteSize(nativeImage, &size));
    
    return size;
}

inline Status 
Image::GetPalette(
    OUT ColorPalette *palette,
    IN INT size
)
{
    return SetStatus(DllExports::GdipGetImagePalette(nativeImage, palette, size));
}

inline Status 
Image::SetPalette(
    IN const ColorPalette *palette
    )
{
    return SetStatus(DllExports::GdipSetImagePalette(nativeImage, palette));
}

inline Image* 
Image::GetThumbnailImage(
    IN UINT thumbWidth,
    IN UINT thumbHeight,
    IN GetThumbnailImageAbort callback,
    IN VOID* callbackData
    )
{
    GpImage *thumbimage = NULL;

    SetStatus(DllExports::GdipGetImageThumbnail(nativeImage,
                                                thumbWidth, thumbHeight,
                                                &thumbimage,
                                                callback, callbackData));

    Image *newImage = new Image(thumbimage, lastResult);

    if (newImage == NULL) 
    {
        DllExports::GdipDisposeImage(thumbimage);
    }

    return newImage;
}

inline UINT 
Image::GetFrameDimensionsCount()
{
    UINT count = 0;

    SetStatus(DllExports::GdipImageGetFrameDimensionsCount(nativeImage,
                                                                  &count));

    return count;
}

inline Status 
Image::GetFrameDimensionsList(
    OUT GUID* dimensionIDs, 
    IN UINT count
    )
{
    return SetStatus(DllExports::GdipImageGetFrameDimensionsList(nativeImage,
                                                                 dimensionIDs,
                                                                 count));
}

inline UINT 
Image::GetFrameCount(
    IN const GUID* dimensionID
    )
{
    UINT count = 0;

    SetStatus(DllExports::GdipImageGetFrameCount(nativeImage,
                                                        dimensionID,
                                                        &count));
    return count;
}

inline Status 
Image::SelectActiveFrame(
    IN const GUID *dimensionID, 
    IN UINT frameIndex
    )
{
    return SetStatus(DllExports::GdipImageSelectActiveFrame(nativeImage,
                                                            dimensionID,
                                                            frameIndex));
}

inline Status
Image::RotateFlip(
    IN RotateFlipType rotateFlipType
    )
{
    return SetStatus(DllExports::GdipImageRotateFlip(nativeImage,
                                                     rotateFlipType));
}

inline UINT 
Image::GetPropertyCount()
{
    UINT numProperty = 0;

    SetStatus(DllExports::GdipGetPropertyCount(nativeImage,
                                               &numProperty));

    return numProperty;
}

inline Status 
Image::GetPropertyIdList(
    IN UINT numOfProperty, 
    OUT PROPID* list
    )
{
    return SetStatus(DllExports::GdipGetPropertyIdList(nativeImage,
                                                       numOfProperty, list));
}
    
inline UINT 
Image::GetPropertyItemSize(
    IN PROPID propId
    )
{
    UINT size = 0;

    SetStatus(DllExports::GdipGetPropertyItemSize(nativeImage,
                                                  propId,
                                                  &size));

    return size;
}

inline Status 
Image::GetPropertyItem(
    IN PROPID propId, 
    IN UINT propSize,
    OUT PropertyItem* buffer
    )
{
    return SetStatus(DllExports::GdipGetPropertyItem(nativeImage,
                                                     propId, propSize, buffer));
}

inline Status 
Image::GetPropertySize(
    OUT UINT* totalBufferSize, 
    OUT UINT* numProperties
    )
{
    return SetStatus(DllExports::GdipGetPropertySize(nativeImage,
                                                     totalBufferSize,
                                                     numProperties));
}

inline Status 
Image::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    OUT PropertyItem* allItems
    )
{
    if (allItems == NULL) 
    {
        return SetStatus(InvalidParameter);
    }
    return SetStatus(DllExports::GdipGetAllPropertyItems(nativeImage,
                                                         totalBufferSize,
                                                         numProperties,
                                                         allItems));
}

inline Status 
Image::RemovePropertyItem(
    IN PROPID propId
    )
{
    return SetStatus(DllExports::GdipRemovePropertyItem(nativeImage, propId));
}

inline Status 
Image::SetPropertyItem(
    IN const PropertyItem* item
    )
{
    return SetStatus(DllExports::GdipSetPropertyItem(nativeImage, item));
}

inline Status
Image::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

inline 
Image::Image(GpImage *nativeImage, Status status)
{
    SetNativeImage(nativeImage);
    lastResult = status;
}

inline VOID 
Image::SetNativeImage(GpImage *nativeImage)
{
    this->nativeImage = nativeImage;
}

inline 
Bitmap::Bitmap(
    IN const WCHAR *filename, 
    IN BOOL useEmbeddedColorManagement
    )
{
    GpBitmap *bitmap = NULL;

    if(useEmbeddedColorManagement) 
    {
        lastResult = DllExports::GdipCreateBitmapFromFileICM(filename, &bitmap);
    }
    else
    {
        lastResult = DllExports::GdipCreateBitmapFromFile(filename, &bitmap);
    }

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN IStream *stream, 
    IN BOOL useEmbeddedColorManagement
    )
{
    GpBitmap *bitmap = NULL;

    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipCreateBitmapFromStreamICM(stream, &bitmap);
    }
    else
    {
        lastResult = DllExports::GdipCreateBitmapFromStream(stream, &bitmap);
    }

    SetNativeImage(bitmap);
}

inline
Bitmap::Bitmap(
    IN INT width,
    IN INT height,
    IN INT stride,
    IN PixelFormat format,
    IN BYTE *scan0
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromScan0(width,
                                                       height,
                                                       stride,
                                                       format,
                                                       scan0,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN INT width,
    IN INT height,
    IN PixelFormat format
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromScan0(width,
                                                       height,
                                                       0,
                                                       format,
                                                       NULL,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline
Bitmap::Bitmap(
    IN INT width, 
    IN INT height, 
    IN Graphics* target)
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromGraphics(width,
                                                          height,
                                                          target->nativeGraphics,
                                                          &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN IDirectDrawSurface7 * surface
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromDirectDrawSurface(surface,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN const BITMAPINFO* gdiBitmapInfo, 
    IN VOID* gdiBitmapData
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromGdiDib(gdiBitmapInfo,
                                                        gdiBitmapData,
                                                        &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HBITMAP hbm, 
    IN HPALETTE hpal
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromHBITMAP(hbm, hpal, &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HICON hicon
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromHICON(hicon, &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HINSTANCE hInstance, 
    IN const WCHAR *bitmapName
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromResource(hInstance,
                                                          bitmapName,
                                                          &bitmap);

    SetNativeImage(bitmap);
}


inline Bitmap* 
Bitmap::FromFile(
    IN const WCHAR *filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Bitmap(
        filename, 
        useEmbeddedColorManagement
    );
}

inline Bitmap* 
Bitmap::FromStream(
    IN IStream *stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Bitmap(
        stream, 
        useEmbeddedColorManagement
    );
}

inline Bitmap* 
Bitmap::FromDirectDrawSurface7(
    IN IDirectDrawSurface7* surface
    )
{
    return new Bitmap(surface);
}

inline Bitmap* 
Bitmap::FromBITMAPINFO(
    IN const BITMAPINFO* gdiBitmapInfo, 
    IN VOID* gdiBitmapData)
{
    return new Bitmap(gdiBitmapInfo, gdiBitmapData);
}

inline Bitmap* 
Bitmap::FromHBITMAP(
    IN HBITMAP hbm, 
    IN HPALETTE hpal
    )
{
    return new Bitmap(hbm, hpal);
}

inline Bitmap* 
Bitmap::FromHICON(
    IN HICON hicon
    )
{
    return new Bitmap(hicon);
}

inline Bitmap* 
Bitmap::FromResource(
    IN HINSTANCE hInstance, 
    IN const WCHAR *bitmapName)
{
    return new Bitmap(hInstance, bitmapName);
}

inline Status 
Bitmap::GetHBITMAP(
    IN const Color& colorBackground,
    OUT HBITMAP* hbmReturn
    )
{
    return SetStatus(DllExports::GdipCreateHBITMAPFromBitmap(
                                        static_cast<GpBitmap*>(nativeImage),
                                        hbmReturn,
                                        colorBackground.GetValue()));
}

inline Status 
Bitmap::GetHICON(
    OUT HICON* hiconReturn
    )
{
    return SetStatus(DllExports::GdipCreateHICONFromBitmap(
                                        static_cast<GpBitmap*>(nativeImage),
                                        hiconReturn));
}

inline Bitmap* 
Bitmap::Clone(
    IN const Rect& rect,
    IN PixelFormat format
    )
{
    return Clone(rect.X, rect.Y, rect.Width, rect.Height, format);
}

inline Bitmap* 
Bitmap::Clone(
    IN INT x,
    IN INT y,
    IN INT width,
    IN INT height,
    IN PixelFormat format
    )
{
   GpBitmap* gpdstBitmap = NULL;
   Bitmap* bitmap;

   lastResult = DllExports::GdipCloneBitmapAreaI(
                               x,
                               y,
                               width,
                               height,
                               format,
                               (GpBitmap *)nativeImage,
                               &gpdstBitmap);

   if (lastResult == Ok)
   {
       bitmap = new Bitmap(gpdstBitmap);

       if (bitmap == NULL) 
       {
           DllExports::GdipDisposeImage(gpdstBitmap);
       }

       return bitmap;
   }
   else
       return NULL;
}

inline Bitmap* 
Bitmap::Clone(
    IN const RectF& rect,
    IN PixelFormat format
    )
{
    return Clone(rect.X, rect.Y, rect.Width, rect.Height, format);
}

inline Bitmap*
Bitmap::Clone(
    IN REAL x,
    IN REAL y,
    IN REAL width,
    IN REAL height,
    IN PixelFormat format
    )
{
   GpBitmap* gpdstBitmap = NULL;
   Bitmap* bitmap;

   SetStatus(DllExports::GdipCloneBitmapArea(
                               x,
                               y,
                               width,
                               height,
                               format,
                               (GpBitmap *)nativeImage,
                               &gpdstBitmap));

   if (lastResult == Ok)
   {
       bitmap = new Bitmap(gpdstBitmap);

       if (bitmap == NULL) 
       {
           DllExports::GdipDisposeImage(gpdstBitmap);
       }

       return bitmap;
   }
   else
       return NULL;
}

inline Bitmap::Bitmap(GpBitmap *nativeBitmap)
{
    lastResult = Ok;

    SetNativeImage(nativeBitmap);
}

inline Status
Bitmap::LockBits(
    IN const Rect* rect,
    IN UINT flags,
    IN PixelFormat format,
    OUT BitmapData* lockedBitmapData
)
{
    return SetStatus(DllExports::GdipBitmapLockBits(
                                    static_cast<GpBitmap*>(nativeImage),
                                    rect,
                                    flags,
                                    format,
                                    lockedBitmapData));
}

inline Status 
Bitmap::UnlockBits(
    IN BitmapData* lockedBitmapData
    )
{
    return SetStatus(DllExports::GdipBitmapUnlockBits(
                                    static_cast<GpBitmap*>(nativeImage),
                                    lockedBitmapData));
}

inline Status 
Bitmap::GetPixel(
    IN INT x, 
    IN INT y, 
    OUT Color *color) 
{
    ARGB argb;

    Status status = SetStatus(DllExports::GdipBitmapGetPixel(
        static_cast<GpBitmap *>(nativeImage),
        x, y,        
        &argb));

    if (status == Ok) 
    {
        color->SetValue(argb);
    }

    return  status;
}

inline Status 
Bitmap::SetPixel(
    IN INT x, 
    IN INT y, 
    IN const Color& color) 
{
    return SetStatus(DllExports::GdipBitmapSetPixel(
        static_cast<GpBitmap *>(nativeImage),
        x, y,
        color.GetValue()));
}

inline Status 
Bitmap::SetResolution(
    IN REAL xdpi, 
    IN REAL ydpi)
{
    return SetStatus(DllExports::GdipBitmapSetResolution(
        static_cast<GpBitmap *>(nativeImage),
        xdpi, ydpi));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdipluscolor.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusColor.h
*
* Abstract:
*
*   GDI+ Color Object
*
\**************************************************************************/

#ifndef _GDIPLUSCOLOR_H
#define _GDIPLUSCOLOR_H

//----------------------------------------------------------------------------
// Color mode
//----------------------------------------------------------------------------

enum ColorMode
{
    ColorModeARGB32 = 0,
    ColorModeARGB64 = 1
};

//----------------------------------------------------------------------------
// Color Channel flags
//----------------------------------------------------------------------------

enum ColorChannelFlags
{
    ColorChannelFlagsC = 0,
    ColorChannelFlagsM,
    ColorChannelFlagsY,
    ColorChannelFlagsK,
    ColorChannelFlagsLast
};

//----------------------------------------------------------------------------
// Color
//----------------------------------------------------------------------------

class Color
{
public:

    Color()
    {
        Argb = (ARGB)Color::Black;
    }

    // Construct an opaque Color object with
    // the specified Red, Green, Blue values.
    //
    // Color values are not premultiplied.

    Color(IN BYTE r,
          IN BYTE g,
          IN BYTE b)
    {
        Argb = MakeARGB(255, r, g, b);
    }

    Color(IN BYTE a,
          IN BYTE r,
          IN BYTE g,
          IN BYTE b)
    {
        Argb = MakeARGB(a, r, g, b);
    }

    Color(IN ARGB argb)
    {
        Argb = argb;
    }

    BYTE GetAlpha() const
    {
        return (BYTE) (Argb >> AlphaShift);
    }

    BYTE GetA() const
    {
        return GetAlpha();
    }

    BYTE GetRed() const
    {
        return (BYTE) (Argb >> RedShift);
    }

    BYTE GetR() const
    {
        return GetRed();
    }

    BYTE GetGreen() const
    {
        return (BYTE) (Argb >> GreenShift);
    }

    BYTE GetG() const
    {
        return GetGreen();
    }

    BYTE GetBlue() const
    {
        return (BYTE) (Argb >> BlueShift);
    }

    BYTE GetB() const
    {
        return GetBlue();
    }

    ARGB GetValue() const
    {
        return Argb;
    }

    VOID SetValue(IN ARGB argb)
    {
        Argb = argb;
    }

    VOID SetFromCOLORREF(IN COLORREF rgb)
    {
        Argb = MakeARGB(255, GetRValue(rgb), GetGValue(rgb), GetBValue(rgb));
    }

    COLORREF ToCOLORREF() const
    {
        return RGB(GetRed(), GetGreen(), GetBlue());
    }

public:

    // Common color constants
    
    enum
    {
        AliceBlue            = 0xFFF0F8FF,
        AntiqueWhite         = 0xFFFAEBD7,
        Aqua                 = 0xFF00FFFF,
        Aquamarine           = 0xFF7FFFD4,
        Azure                = 0xFFF0FFFF,
        Beige                = 0xFFF5F5DC,
        Bisque               = 0xFFFFE4C4,
        Black                = 0xFF000000,
        BlanchedAlmond       = 0xFFFFEBCD,
        Blue                 = 0xFF0000FF,
        BlueViolet           = 0xFF8A2BE2,
        Brown                = 0xFFA52A2A,
        BurlyWood            = 0xFFDEB887,
        CadetBlue            = 0xFF5F9EA0,
        Chartreuse           = 0xFF7FFF00,
        Chocolate            = 0xFFD2691E,
        Coral                = 0xFFFF7F50,
        CornflowerBlue       = 0xFF6495ED,
        Cornsilk             = 0xFFFFF8DC,
        Crimson              = 0xFFDC143C,
        Cyan                 = 0xFF00FFFF,
        DarkBlue             = 0xFF00008B,
        DarkCyan             = 0xFF008B8B,
        DarkGoldenrod        = 0xFFB8860B,
        DarkGray             = 0xFFA9A9A9,
        DarkGreen            = 0xFF006400,
        DarkKhaki            = 0xFFBDB76B,
        DarkMagenta          = 0xFF8B008B,
        DarkOliveGreen       = 0xFF556B2F,
        DarkOrange           = 0xFFFF8C00,
        DarkOrchid           = 0xFF9932CC,
        DarkRed              = 0xFF8B0000,
        DarkSalmon           = 0xFFE9967A,
        DarkSeaGreen         = 0xFF8FBC8B,
        DarkSlateBlue        = 0xFF483D8B,
        DarkSlateGray        = 0xFF2F4F4F,
        DarkTurquoise        = 0xFF00CED1,
        DarkViolet           = 0xFF9400D3,
        DeepPink             = 0xFFFF1493,
        DeepSkyBlue          = 0xFF00BFFF,
        DimGray              = 0xFF696969,
        DodgerBlue           = 0xFF1E90FF,
        Firebrick            = 0xFFB22222,
        FloralWhite          = 0xFFFFFAF0,
        ForestGreen          = 0xFF228B22,
        Fuchsia              = 0xFFFF00FF,
        Gainsboro            = 0xFFDCDCDC,
        GhostWhite           = 0xFFF8F8FF,
        Gold                 = 0xFFFFD700,
        Goldenrod            = 0xFFDAA520,
        Gray                 = 0xFF808080,
        Green                = 0xFF008000,
        GreenYellow          = 0xFFADFF2F,
        Honeydew             = 0xFFF0FFF0,
        HotPink              = 0xFFFF69B4,
        IndianRed            = 0xFFCD5C5C,
        Indigo               = 0xFF4B0082,
        Ivory                = 0xFFFFFFF0,
        Khaki                = 0xFFF0E68C,
        Lavender             = 0xFFE6E6FA,
        LavenderBlush        = 0xFFFFF0F5,
        LawnGreen            = 0xFF7CFC00,
        LemonChiffon         = 0xFFFFFACD,
        LightBlue            = 0xFFADD8E6,
        LightCoral           = 0xFFF08080,
        LightCyan            = 0xFFE0FFFF,
        LightGoldenrodYellow = 0xFFFAFAD2,
        LightGray            = 0xFFD3D3D3,
        LightGreen           = 0xFF90EE90,
        LightPink            = 0xFFFFB6C1,
        LightSalmon          = 0xFFFFA07A,
        LightSeaGreen        = 0xFF20B2AA,
        LightSkyBlue         = 0xFF87CEFA,
        LightSlateGray       = 0xFF778899,
        LightSteelBlue       = 0xFFB0C4DE,
        LightYellow          = 0xFFFFFFE0,
        Lime                 = 0xFF00FF00,
        LimeGreen            = 0xFF32CD32,
        Linen                = 0xFFFAF0E6,
        Magenta              = 0xFFFF00FF,
        Maroon               = 0xFF800000,
        MediumAquamarine     = 0xFF66CDAA,
        MediumBlue           = 0xFF0000CD,
        MediumOrchid         = 0xFFBA55D3,
        MediumPurple         = 0xFF9370DB,
        MediumSeaGreen       = 0xFF3CB371,
        MediumSlateBlue      = 0xFF7B68EE,
        MediumSpringGreen    = 0xFF00FA9A,
        MediumTurquoise      = 0xFF48D1CC,
        MediumVioletRed      = 0xFFC71585,
        MidnightBlue         = 0xFF191970,
        MintCream            = 0xFFF5FFFA,
        MistyRose            = 0xFFFFE4E1,
        Moccasin             = 0xFFFFE4B5,
        NavajoWhite          = 0xFFFFDEAD,
        Navy                 = 0xFF000080,
        OldLace              = 0xFFFDF5E6,
        Olive                = 0xFF808000,
        OliveDrab            = 0xFF6B8E23,
        Orange               = 0xFFFFA500,
        OrangeRed            = 0xFFFF4500,
        Orchid               = 0xFFDA70D6,
        PaleGoldenrod        = 0xFFEEE8AA,
        PaleGreen            = 0xFF98FB98,
        PaleTurquoise        = 0xFFAFEEEE,
        PaleVioletRed        = 0xFFDB7093,
        PapayaWhip           = 0xFFFFEFD5,
        PeachPuff            = 0xFFFFDAB9,
        Peru                 = 0xFFCD853F,
        Pink                 = 0xFFFFC0CB,
        Plum                 = 0xFFDDA0DD,
        PowderBlue           = 0xFFB0E0E6,
        Purple               = 0xFF800080,
        Red                  = 0xFFFF0000,
        RosyBrown            = 0xFFBC8F8F,
        RoyalBlue            = 0xFF4169E1,
        SaddleBrown          = 0xFF8B4513,
        Salmon               = 0xFFFA8072,
        SandyBrown           = 0xFFF4A460,
        SeaGreen             = 0xFF2E8B57,
        SeaShell             = 0xFFFFF5EE,
        Sienna               = 0xFFA0522D,
        Silver               = 0xFFC0C0C0,
        SkyBlue              = 0xFF87CEEB,
        SlateBlue            = 0xFF6A5ACD,
        SlateGray            = 0xFF708090,
        Snow                 = 0xFFFFFAFA,
        SpringGreen          = 0xFF00FF7F,
        SteelBlue            = 0xFF4682B4,
        Tan                  = 0xFFD2B48C,
        Teal                 = 0xFF008080,
        Thistle              = 0xFFD8BFD8,
        Tomato               = 0xFFFF6347,
        Transparent          = 0x00FFFFFF,
        Turquoise            = 0xFF40E0D0,
        Violet               = 0xFFEE82EE,
        Wheat                = 0xFFF5DEB3,
        White                = 0xFFFFFFFF,
        WhiteSmoke           = 0xFFF5F5F5,
        Yellow               = 0xFFFFFF00,
        YellowGreen          = 0xFF9ACD32
    };

    // Shift count and bit mask for A, R, G, B components
    
    enum
    {
        AlphaShift  = 24,
        RedShift    = 16,
        GreenShift  = 8,
        BlueShift   = 0
    };

    enum
    {
        AlphaMask   = 0xff000000,
        RedMask     = 0x00ff0000,
        GreenMask   = 0x0000ff00,
        BlueMask    = 0x000000ff
    };

    // Assemble A, R, G, B values into a 32-bit integer
    
    static ARGB MakeARGB(IN BYTE a,
                         IN BYTE r,
                         IN BYTE g,
                         IN BYTE b)
    {
        return (((ARGB) (b) <<  BlueShift) |
                ((ARGB) (g) << GreenShift) |
                ((ARGB) (r) <<   RedShift) |
                ((ARGB) (a) << AlphaShift));
    }

protected:

    ARGB Argb;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusbrush.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusBrush.h
*
* Abstract:
*
*   GDI+ Brush class
*
\**************************************************************************/

#ifndef _GDIPLUSBRUSH_H
#define _GDIPLUSBRUSH_H

class GraphicsPath;

//--------------------------------------------------------------------------
// Abstract base class for various brush types
//--------------------------------------------------------------------------

class Brush : public GdiplusBase
{
public:
    friend class Pen;
    friend class Graphics;

    virtual ~Brush()
    {
        DllExports::GdipDeleteBrush(nativeBrush);
    }

    virtual Brush* Clone() const
    {
        GpBrush *brush = NULL;

        SetStatus(DllExports::GdipCloneBrush(nativeBrush, &brush));

        Brush *newBrush = new Brush(brush, lastResult);
        
        if (newBrush == NULL) 
        {
            DllExports::GdipDeleteBrush(brush);
        }

        return newBrush;
    }

    BrushType GetType() const
    {
        BrushType type = static_cast<BrushType>(-1);

        SetStatus(DllExports::GdipGetBrushType(nativeBrush, &type));

        return type;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:

    Brush()
    {
        SetStatus(NotImplemented);
    }

private:
    Brush(const Brush& brush);
    Brush& operator=(const Brush& brush);
protected:

    Brush(GpBrush* nativeBrush, Status status)
    {
        lastResult = status;
        SetNativeBrush(nativeBrush);
    }

    VOID SetNativeBrush(GpBrush* nativeBrush)
    {
        this->nativeBrush = nativeBrush;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpBrush* nativeBrush;
    mutable Status lastResult;
};

//--------------------------------------------------------------------------
// Solid Fill Brush Object
//--------------------------------------------------------------------------

class SolidBrush : public Brush
{
public:
    friend class Pen;

    SolidBrush(IN const Color& color)
    {
        GpSolidFill *brush = NULL;

        lastResult = DllExports::GdipCreateSolidFill(color.GetValue(), &brush);

        SetNativeBrush(brush);
    }

    Status GetColor(OUT Color* color) const
    {
        ARGB argb;

        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        SetStatus(DllExports::GdipGetSolidFillColor((GpSolidFill*)nativeBrush,
                                                    &argb));

        *color = Color(argb);

        return lastResult;
    }

    Status SetColor(IN const Color& color)
    {
        return SetStatus(DllExports::GdipSetSolidFillColor((GpSolidFill*)nativeBrush, 
                                                           color.GetValue()));
    }

private:
    SolidBrush(const SolidBrush &);
    SolidBrush& operator=(const SolidBrush &);

protected:

    SolidBrush()
    {
    }
};

//--------------------------------------------------------------------------
// Texture Brush Fill Object
//--------------------------------------------------------------------------

class TextureBrush : public Brush
{
public:
    friend class Pen;

    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode = WrapModeTile)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture(
                                                  image->nativeImage,
                                                  wrapMode, &texture);

        SetNativeBrush(texture);
    }

    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.
    
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode,
                 IN const RectF &dstRect)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2(
                                                   image->nativeImage,
                                                   wrapMode, 
                                                   dstRect.X, 
                                                   dstRect.Y, 
                                                   dstRect.Width, 
                                                   dstRect.Height,
                                                   &texture);

        SetNativeBrush(texture);
    }
    
    TextureBrush(IN Image *image, 
                 IN const RectF &dstRect,
                 IN const ImageAttributes *imageAttributes = NULL)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTextureIA(
            image->nativeImage,
            (imageAttributes)?imageAttributes->nativeImageAttr:NULL,
            dstRect.X, 
            dstRect.Y, 
            dstRect.Width, 
            dstRect.Height,
            &texture
        );

        SetNativeBrush(texture);
    }
    
    TextureBrush(IN Image *image, 
                 IN const Rect &dstRect,
                 IN const ImageAttributes *imageAttributes = NULL)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTextureIAI(
            image->nativeImage,
            (imageAttributes)?imageAttributes->nativeImageAttr:NULL,
            dstRect.X, 
            dstRect.Y, 
            dstRect.Width, 
            dstRect.Height,
            &texture
        );

        SetNativeBrush(texture);
    }

    TextureBrush(
        IN Image* image,
        IN WrapMode wrapMode,
        
        const IN Rect &dstRect
    )
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2I(
                                                    image->nativeImage,
                                                    wrapMode, 
                                                    dstRect.X, 
                                                    dstRect.Y, 
                                                    dstRect.Width, 
                                                    dstRect.Height,
                                                    &texture);

        SetNativeBrush(texture);
    }
    
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode, 
                 IN REAL dstX, 
                 IN REAL dstY, 
                 IN REAL dstWidth, 
                 IN REAL dstHeight)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2(
                                                   image->nativeImage,
                                                   wrapMode, 
                                                   dstX, 
                                                   dstY, 
                                                   dstWidth, 
                                                   dstHeight,
                                                   &texture);

        SetNativeBrush(texture);
    }
    
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode, 
                 IN INT dstX, 
                 IN INT dstY, 
                 IN INT dstWidth, 
                 IN INT dstHeight)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2I(
                                                    image->nativeImage,
                                                    wrapMode, 
                                                    dstX, 
                                                    dstY, 
                                                    dstWidth, 
                                                    dstHeight,
                                                    &texture);

        SetNativeBrush(texture);
    }

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetTextureTransform((GpTexture*)nativeBrush, 
                                                             matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetTextureTransform((GpTexture*)nativeBrush, 
                                                             matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetTextureTransform((GpTexture*)nativeBrush));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyTextureTransform((GpTexture*)nativeBrush,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx,
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateTextureTransform((GpTexture*)nativeBrush,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleTextureTransform((GpTexture*)nativeBrush,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateTextureTransform((GpTexture*)nativeBrush,
                                                              angle, order));
    }

    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetTextureWrapMode((GpTexture*)nativeBrush, 
                                                            wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetTextureWrapMode((GpTexture*)nativeBrush, 
                                                     &wrapMode));
        return wrapMode;
    }

    Image *GetImage() const
    {
        GpImage *image;

        SetStatus(DllExports::GdipGetTextureImage((GpTexture *)nativeBrush,
                                                  &image));

        Image *retimage = new Image(image, lastResult);

        if (retimage == NULL) 
        {
            DllExports::GdipDisposeImage(image);
        }

        return retimage;
    }

private:
    TextureBrush(const TextureBrush &);
    TextureBrush& operator=(const TextureBrush &);

protected:

    TextureBrush()
    {
    }
};

//--------------------------------------------------------------------------
// Linear Gradient Brush Object
//--------------------------------------------------------------------------

class LinearGradientBrush : public Brush
{
public:
    friend class Pen;

    LinearGradientBrush(IN const PointF& point1,
                        IN const PointF& point2,
                        IN const Color& color1,
                        IN const Color& color2)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrush(&point1,
                                                     &point2,
                                                     color1.GetValue(),
                                                     color2.GetValue(),
                                                     WrapModeTile,
                                                     &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Point& point1,
                        IN const Point& point2,
                        IN const Color& color1,
                        IN const Color& color2)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushI(&point1,
                                                      &point2,
                                                      color1.GetValue(),
                                                      color2.GetValue(),
                                                      WrapModeTile,
                                                      &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const RectF& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN LinearGradientMode mode)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRect(&rect,
                                                             color1.GetValue(),
                                                             color2.GetValue(),
                                                             mode,
                                                             WrapModeTile,
                                                             &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Rect& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN LinearGradientMode mode)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectI(&rect,
                                                              color1.GetValue(),
                                                              color2.GetValue(),
                                                              mode,
                                                              WrapModeTile,
                                                              &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const RectF& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN REAL angle,
                        IN BOOL isAngleScalable = FALSE)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectWithAngle(&rect,
                                                                      color1.GetValue(),
                                                                      color2.GetValue(),
                                                                      angle,
                                                                      isAngleScalable,
                                                                      WrapModeTile,
                                                                      &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Rect& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN REAL angle,
                        IN BOOL isAngleScalable = FALSE)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectWithAngleI(&rect,
                                                                       color1.GetValue(),
                                                                       color2.GetValue(),
                                                                       angle,
                                                                       isAngleScalable,
                                                                       WrapModeTile,
                                                                       &brush);

        SetNativeBrush(brush);
    }

    Status SetLinearColors(IN const Color& color1, 
                           IN const Color& color2)
    {
        return SetStatus(DllExports::GdipSetLineColors((GpLineGradient*)nativeBrush,
                                                       color1.GetValue(),
                                                       color2.GetValue()));
    }

    Status GetLinearColors(OUT Color* colors) const
    {
        ARGB argb[2];

        if (colors == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        SetStatus(DllExports::GdipGetLineColors((GpLineGradient*) nativeBrush, argb));

        if (lastResult == Ok)
        {
            // use bitwise copy operator for Color copy
            colors[0] = Color(argb[0]);
            colors[1] = Color(argb[1]);
        }

        return lastResult;
    }

    Status GetRectangle(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetLineRect((GpLineGradient*)nativeBrush, rect));
    }

    Status GetRectangle(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetLineRectI((GpLineGradient*)nativeBrush, rect));
    }

    Status SetGammaCorrection(IN BOOL useGammaCorrection)
    {
        return SetStatus(DllExports::GdipSetLineGammaCorrection((GpLineGradient*)nativeBrush,
                    useGammaCorrection));
    }
    
    BOOL GetGammaCorrection() const
    {
        BOOL useGammaCorrection;

        SetStatus(DllExports::GdipGetLineGammaCorrection((GpLineGradient*)nativeBrush,
                    &useGammaCorrection));

        return useGammaCorrection;
    }

    INT GetBlendCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetLineBlendCount((GpLineGradient*)
                                                    nativeBrush,
                                                    &count));

        return count;
    }

    Status SetBlend(IN const REAL* blendFactors, 
                    IN const REAL* blendPositions,
                    IN INT count)
    {
        return SetStatus(DllExports::GdipSetLineBlend((GpLineGradient*)
                                                      nativeBrush,
                                                      blendFactors,
                                                      blendPositions,
                                                      count));
    }

    Status GetBlend(OUT REAL* blendFactors, 
                    OUT REAL* blendPositions, 
                    IN INT count) const 
    {
        return SetStatus(DllExports::GdipGetLineBlend((GpLineGradient*)nativeBrush,
                                                      blendFactors,
                                                      blendPositions,
                                                      count));
    }

    INT GetInterpolationColorCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetLinePresetBlendCount((GpLineGradient*)
                                                          nativeBrush,
                                                          &count));

        return count;
    }

    Status SetInterpolationColors(IN const Color* presetColors,
                                  IN const REAL* blendPositions, 
                                  IN INT count)
    {
        if ((count <= 0) || !presetColors)
            return SetStatus(InvalidParameter);
         
        ARGB *argbs = (ARGB*) new BYTE[count*sizeof(ARGB)];
        
        if (argbs)
        {
            for (INT i = 0; i < count; i++)
            {
                argbs[i] = presetColors[i].GetValue();
            }

            Status status = SetStatus(DllExports::GdipSetLinePresetBlend(
                                                                        (GpLineGradient*) nativeBrush,
                                                                        argbs,
                                                                        blendPositions,
                                                                        count));
            delete [] argbs;
            return status;
        }
        else
        {
            return SetStatus(OutOfMemory);
        }
    }

    Status GetInterpolationColors(OUT Color* presetColors, 
                                  OUT REAL* blendPositions, 
                                  IN INT count) const 
    {
        if ((count <= 0) || !presetColors)
            return SetStatus(InvalidParameter);

        ARGB* argbs = (ARGB*) new BYTE[count*sizeof(ARGB)];
        
        if (!argbs)
        {
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetLinePresetBlend((GpLineGradient*)nativeBrush,
                                                                     argbs,
                                                                     blendPositions,
                                                                     count));
        if (status == Ok) 
        {
            for (INT i = 0; i < count; i++)
            { 
                presetColors[i] = Color(argbs[i]);
            }
        }
        
        delete [] argbs;
        
        return status;
    }

    Status SetBlendBellShape(IN REAL focus, 
                             IN REAL scale = 1.0f)
    {
        return SetStatus(DllExports::GdipSetLineSigmaBlend((GpLineGradient*)nativeBrush, focus, scale));
    }

    Status SetBlendTriangularShape(
        IN REAL focus,
        IN REAL scale = 1.0f
    )
    {
        return SetStatus(DllExports::GdipSetLineLinearBlend((GpLineGradient*)nativeBrush, focus, scale));
    }

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetLineTransform((GpLineGradient*)nativeBrush, 
                                                          matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetLineTransform((GpLineGradient*)nativeBrush, 
                                                          matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetLineTransform((GpLineGradient*)nativeBrush));
    }

    Status MultiplyTransform(IN const Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyLineTransform((GpLineGradient*)nativeBrush,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateLineTransform((GpLineGradient*)nativeBrush,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleLineTransform((GpLineGradient*)nativeBrush,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateLineTransform((GpLineGradient*)nativeBrush,
                                                              angle, order));
    }

    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetLineWrapMode((GpLineGradient*)nativeBrush, 
                                                         wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetLineWrapMode((GpLineGradient*)
                                                  nativeBrush, 
                                                  &wrapMode));

        return wrapMode;
    }

private:
    LinearGradientBrush(const LinearGradientBrush &);
    LinearGradientBrush& operator=(const LinearGradientBrush &);

protected:

    LinearGradientBrush()
    {
    }
};

//--------------------------------------------------------------------------
// PathGradientBrush object is defined
// in gdipluspath.h.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
// Hatch Brush Object
//--------------------------------------------------------------------------

class HatchBrush : public Brush
{
public:
    friend class Pen;

    HatchBrush(IN HatchStyle hatchStyle, 
               IN const Color& foreColor,
               IN const Color& backColor = Color())
    {
        GpHatch *brush = NULL;

        lastResult = DllExports::GdipCreateHatchBrush(hatchStyle, 
                                                      foreColor.GetValue(), 
                                                      backColor.GetValue(),
                                                      &brush);
        SetNativeBrush(brush);
    }

    HatchStyle GetHatchStyle() const
    {
        HatchStyle hatchStyle;

        SetStatus(DllExports::GdipGetHatchStyle((GpHatch*)nativeBrush, 
                                                &hatchStyle));

        return hatchStyle;
    }
    
    Status GetForegroundColor(OUT Color* color) const
    {
        ARGB argb;

        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        Status status = SetStatus(DllExports::GdipGetHatchForegroundColor(
                                                        (GpHatch*)nativeBrush, 
                                                        &argb));

        color->SetValue(argb);

        return status;
    }

    Status GetBackgroundColor(OUT Color *color) const
    {
        ARGB argb;
        
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        Status status = SetStatus(DllExports::GdipGetHatchBackgroundColor(
                                                        (GpHatch*)nativeBrush,
                                                        &argb));

        color->SetValue(argb);
        
        return status;
    }

private:
    HatchBrush(const HatchBrush &);
    HatchBrush& operator=(const HatchBrush &);

protected:

    HatchBrush()
    {
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdipluscachedbitmap.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   CachedBitmap class definition
*
* Abstract:
*
*   GDI+ CachedBitmap is a representation of an accelerated drawing
*   that has restrictions on what operations are allowed in order
*   to accelerate the drawing to the destination.
*
*   Look for class definition in GdiplusHeaders.h
*
**************************************************************************/

#ifndef _GDIPLUSCACHEDBITMAP_H
#define _GDIPLUSCACHEDBITMAP_H

inline 
CachedBitmap::CachedBitmap(
    IN Bitmap *bitmap, 
    IN Graphics *graphics)
{
    nativeCachedBitmap = NULL;    

    lastResult = DllExports::GdipCreateCachedBitmap(
        (GpBitmap *)bitmap->nativeImage,
        graphics->nativeGraphics,
        &nativeCachedBitmap
    );
}

inline 
CachedBitmap::~CachedBitmap()
{
    DllExports::GdipDeleteCachedBitmap(nativeCachedBitmap);
}

inline Status 
CachedBitmap::GetLastStatus() const 
{
    Status lastStatus = lastResult;
    lastResult = Ok;    
    return (lastStatus);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdipluscolormatrix.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusColorMatrix.h
*
* Abstract:
*
*  GDI+ Color Matrix object, used with Graphics.DrawImage
*
\**************************************************************************/

#ifndef _GDIPLUSCOLORMATRIX_H
#define _GDIPLUSCOLORMATRIX_H

//----------------------------------------------------------------------------
// Color matrix
//----------------------------------------------------------------------------

struct ColorMatrix
{
    REAL m[5][5];
};

//----------------------------------------------------------------------------
// Color Matrix flags
//----------------------------------------------------------------------------

enum ColorMatrixFlags
{
    ColorMatrixFlagsDefault   = 0,
    ColorMatrixFlagsSkipGrays = 1,
    ColorMatrixFlagsAltGray   = 2
};

//----------------------------------------------------------------------------
// Color Adjust Type
//----------------------------------------------------------------------------

enum ColorAdjustType
{
    ColorAdjustTypeDefault,
    ColorAdjustTypeBitmap,
    ColorAdjustTypeBrush,
    ColorAdjustTypePen,
    ColorAdjustTypeText,
    ColorAdjustTypeCount,
    ColorAdjustTypeAny      // Reserved
};

//----------------------------------------------------------------------------
// Color Map
//----------------------------------------------------------------------------

struct ColorMap
{
    Color oldColor;
    Color newColor;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusflat.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusFlat.h
*
* Abstract:
*
*   Private GDI+ header file.
*
\**************************************************************************/

#ifndef _FLATAPI_H
#define _FLATAPI_H

#define WINGDIPAPI __stdcall

#define GDIPCONST const

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
// GraphicsPath APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePath(GpFillMode brushMode, GpPath **path);

GpStatus WINGDIPAPI
GdipCreatePath2(GDIPCONST GpPointF*, GDIPCONST BYTE*, INT, GpFillMode,
                                    GpPath **path);

GpStatus WINGDIPAPI
GdipCreatePath2I(GDIPCONST GpPoint*, GDIPCONST BYTE*, INT, GpFillMode,
                                     GpPath **path);

GpStatus WINGDIPAPI
GdipClonePath(GpPath* path, GpPath **clonePath);

GpStatus WINGDIPAPI
GdipDeletePath(GpPath* path);

GpStatus WINGDIPAPI
GdipResetPath(GpPath* path);

GpStatus WINGDIPAPI
GdipGetPointCount(GpPath* path, INT* count);

GpStatus WINGDIPAPI
GdipGetPathTypes(GpPath* path, BYTE* types, INT count);

GpStatus WINGDIPAPI
GdipGetPathPoints(GpPath*, GpPointF* points, INT count);

GpStatus WINGDIPAPI
GdipGetPathPointsI(GpPath*, GpPoint* points, INT count);

GpStatus WINGDIPAPI
GdipGetPathFillMode(GpPath *path, GpFillMode *fillmode);

GpStatus WINGDIPAPI
GdipSetPathFillMode(GpPath *path, GpFillMode fillmode);

GpStatus WINGDIPAPI
GdipGetPathData(GpPath *path, GpPathData* pathData);

GpStatus WINGDIPAPI
GdipStartPathFigure(GpPath *path);

GpStatus WINGDIPAPI
GdipClosePathFigure(GpPath *path);

GpStatus WINGDIPAPI
GdipClosePathFigures(GpPath *path);

GpStatus WINGDIPAPI
GdipSetPathMarker(GpPath* path);

GpStatus WINGDIPAPI
GdipClearPathMarkers(GpPath* path);

GpStatus WINGDIPAPI
GdipReversePath(GpPath* path);

GpStatus WINGDIPAPI
GdipGetPathLastPoint(GpPath* path, GpPointF* lastPoint);

GpStatus WINGDIPAPI
GdipAddPathLine(GpPath *path, REAL x1, REAL y1, REAL x2, REAL y2);

GpStatus WINGDIPAPI
GdipAddPathLine2(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathArc(GpPath *path, REAL x, REAL y, REAL width, REAL height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathBezier(GpPath *path, REAL x1, REAL y1, REAL x2, REAL y2,
                           REAL x3, REAL y3, REAL x4, REAL y4);

GpStatus WINGDIPAPI
GdipAddPathBeziers(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve2(GpPath *path, GDIPCONST GpPointF *points, INT count,
                           REAL tension);

GpStatus WINGDIPAPI
GdipAddPathCurve3(GpPath *path, GDIPCONST GpPointF *points, INT count,
                           INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve2(GpPath *path, GDIPCONST GpPointF *points, INT count,
                                 REAL tension);

GpStatus WINGDIPAPI
GdipAddPathRectangle(GpPath *path, REAL x, REAL y, REAL width, REAL height);

GpStatus WINGDIPAPI
GdipAddPathRectangles(GpPath *path, GDIPCONST GpRectF *rects, INT count);

GpStatus WINGDIPAPI
GdipAddPathEllipse(GpPath *path, REAL x, REAL y, REAL width,
                            REAL height);

GpStatus WINGDIPAPI
GdipAddPathPie(GpPath *path, REAL x, REAL y, REAL width, REAL height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathPolygon(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathPath(GpPath *path, GDIPCONST GpPath* addingPath, BOOL connect);

GpStatus WINGDIPAPI
GdipAddPathString(GpPath *path, GDIPCONST WCHAR *string,
                        INT length, GDIPCONST GpFontFamily *family, INT style,
                        REAL emSize, GDIPCONST RectF *layoutRect,
                        GDIPCONST GpStringFormat *format);

GpStatus WINGDIPAPI
GdipAddPathStringI(GpPath *path, GDIPCONST WCHAR *string,
                        INT length, GDIPCONST GpFontFamily *family, INT style,
                        REAL emSize, GDIPCONST Rect *layoutRect,
                        GDIPCONST GpStringFormat *format);

GpStatus WINGDIPAPI
GdipAddPathLineI(GpPath *path, INT x1, INT y1, INT x2, INT y2);

GpStatus WINGDIPAPI
GdipAddPathLine2I(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathArcI(GpPath *path, INT x, INT y, INT width, INT height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathBezierI(GpPath *path, INT x1, INT y1, INT x2, INT y2,
                           INT x3, INT y3, INT x4, INT y4);

GpStatus WINGDIPAPI
GdipAddPathBeziersI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurveI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve2I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                           REAL tension);

GpStatus WINGDIPAPI
GdipAddPathCurve3I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                           INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipAddPathClosedCurveI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve2I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                                 REAL tension);

GpStatus WINGDIPAPI
GdipAddPathRectangleI(GpPath *path, INT x, INT y, INT width, INT height);

GpStatus WINGDIPAPI
GdipAddPathRectanglesI(GpPath *path, GDIPCONST GpRect *rects, INT count);

GpStatus WINGDIPAPI
GdipAddPathEllipseI(GpPath *path, INT x, INT y, INT width, INT height);

GpStatus WINGDIPAPI
GdipAddPathPieI(GpPath *path, INT x, INT y, INT width, INT height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathPolygonI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFlattenPath(GpPath *path, GpMatrix* matrix, REAL flatness);

GpStatus WINGDIPAPI
GdipWindingModeOutline(
    GpPath *path,
    GpMatrix *matrix,
    REAL flatness
);

GpStatus WINGDIPAPI
GdipWidenPath(
    GpPath *nativePath,
    GpPen *pen,
    GpMatrix *matrix,
    REAL flatness
);

GpStatus WINGDIPAPI
GdipWarpPath(GpPath *path, GpMatrix* matrix,
            GDIPCONST GpPointF *points, INT count,
            REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight,
            WarpMode warpMode, REAL flatness);

GpStatus WINGDIPAPI
GdipTransformPath(GpPath* path, GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetPathWorldBounds(GpPath* path, GpRectF* bounds, 
                       GDIPCONST GpMatrix *matrix, GDIPCONST GpPen *pen);

GpStatus WINGDIPAPI
GdipGetPathWorldBoundsI(GpPath* path, GpRect* bounds, 
                        GDIPCONST GpMatrix *matrix, GDIPCONST GpPen *pen);

GpStatus WINGDIPAPI
GdipIsVisiblePathPoint(GpPath* path, REAL x, REAL y,
                       GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePathPointI(GpPath* path, INT x, INT y,
                        GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsOutlineVisiblePathPoint(GpPath* path, REAL x, REAL y, GpPen *pen,
                              GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsOutlineVisiblePathPointI(GpPath* path, INT x, INT y, GpPen *pen,
                               GpGraphics *graphics, BOOL *result);


//----------------------------------------------------------------------------
// PathIterator APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePathIter(GpPathIterator **iterator, GpPath* path);

GpStatus WINGDIPAPI
GdipDeletePathIter(GpPathIterator *iterator);

GpStatus WINGDIPAPI
GdipPathIterNextSubpath(GpPathIterator* iterator, INT *resultCount,
        INT* startIndex, INT* endIndex, BOOL* isClosed);

GpStatus WINGDIPAPI
GdipPathIterNextSubpathPath(GpPathIterator* iterator, INT* resultCount,
        GpPath* path, BOOL* isClosed);

GpStatus WINGDIPAPI
GdipPathIterNextPathType(GpPathIterator* iterator, INT* resultCount,
        BYTE* pathType, INT* startIndex, INT* endIndex);

GpStatus WINGDIPAPI
GdipPathIterNextMarker(GpPathIterator* iterator, INT *resultCount,
        INT* startIndex, INT* endIndex);

GpStatus WINGDIPAPI
GdipPathIterNextMarkerPath(GpPathIterator* iterator, INT* resultCount,
        GpPath* path);

GpStatus WINGDIPAPI
GdipPathIterGetCount(GpPathIterator* iterator, INT* count);

GpStatus WINGDIPAPI
GdipPathIterGetSubpathCount(GpPathIterator* iterator, INT* count);

GpStatus WINGDIPAPI
GdipPathIterIsValid(GpPathIterator* iterator, BOOL* valid);

GpStatus WINGDIPAPI
GdipPathIterHasCurve(GpPathIterator* iterator, BOOL* hasCurve);

GpStatus WINGDIPAPI
GdipPathIterRewind(GpPathIterator* iterator);

GpStatus WINGDIPAPI
GdipPathIterEnumerate(GpPathIterator* iterator, INT* resultCount,
    GpPointF *points, BYTE *types, INT count);

GpStatus WINGDIPAPI
GdipPathIterCopyData(GpPathIterator* iterator, INT* resultCount,
    GpPointF* points, BYTE* types, INT startIndex, INT endIndex);

//----------------------------------------------------------------------------
// Matrix APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateMatrix(GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix2(REAL m11, REAL m12, REAL m21, REAL m22, REAL dx,
                                      REAL dy, GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix3(GDIPCONST GpRectF *rect, GDIPCONST GpPointF *dstplg,
                                      GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix3I(GDIPCONST GpRect *rect, GDIPCONST GpPoint *dstplg,
                                       GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCloneMatrix(GpMatrix *matrix, GpMatrix **cloneMatrix);

GpStatus WINGDIPAPI
GdipDeleteMatrix(GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetMatrixElements(GpMatrix *matrix, REAL m11, REAL m12, REAL m21, REAL m22,
                      REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipMultiplyMatrix(GpMatrix *matrix, GpMatrix* matrix2,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateMatrix(GpMatrix *matrix, REAL offsetX, REAL offsetY,
                    GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleMatrix(GpMatrix *matrix, REAL scaleX, REAL scaleY,
                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateMatrix(GpMatrix *matrix, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipShearMatrix(GpMatrix *matrix, REAL shearX, REAL shearY,
                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipInvertMatrix(GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipTransformMatrixPoints(GpMatrix *matrix, GpPointF *pts, INT count);

GpStatus WINGDIPAPI
GdipTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts, INT count);

GpStatus WINGDIPAPI
GdipVectorTransformMatrixPoints(GpMatrix *matrix, GpPointF *pts,
                                         INT count);

GpStatus WINGDIPAPI
GdipVectorTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts,
                                         INT count);

GpStatus WINGDIPAPI
GdipGetMatrixElements(GDIPCONST GpMatrix *matrix, REAL *matrixOut);

GpStatus WINGDIPAPI
GdipIsMatrixInvertible(GDIPCONST GpMatrix *matrix, BOOL *result);

GpStatus WINGDIPAPI
GdipIsMatrixIdentity(GDIPCONST GpMatrix *matrix, BOOL *result);

GpStatus WINGDIPAPI
GdipIsMatrixEqual(GDIPCONST GpMatrix *matrix, GDIPCONST GpMatrix *matrix2, 
                  BOOL *result);

//----------------------------------------------------------------------------
// Region APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateRegion(GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRect(GDIPCONST GpRectF *rect, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRectI(GDIPCONST GpRect *rect, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionPath(GpPath *path, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRgnData(GDIPCONST BYTE *regionData, INT size, 
                        GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionHrgn(HRGN hRgn, GpRegion **region);

GpStatus WINGDIPAPI
GdipCloneRegion(GpRegion *region, GpRegion **cloneRegion);

GpStatus WINGDIPAPI
GdipDeleteRegion(GpRegion *region);

GpStatus WINGDIPAPI
GdipSetInfinite(GpRegion *region);

GpStatus WINGDIPAPI
GdipSetEmpty(GpRegion *region);

GpStatus WINGDIPAPI
GdipCombineRegionRect(GpRegion *region, GDIPCONST GpRectF *rect,
                      CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionRectI(GpRegion *region, GDIPCONST GpRect *rect,
                       CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionPath(GpRegion *region, GpPath *path, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionRegion(GpRegion *region,  GpRegion *region2,
                        CombineMode combineMode);

GpStatus WINGDIPAPI
GdipTranslateRegion(GpRegion *region, REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipTranslateRegionI(GpRegion *region, INT dx, INT dy);

GpStatus WINGDIPAPI
GdipTransformRegion(GpRegion *region, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipGetRegionBounds(GpRegion *region, GpGraphics *graphics,
                             GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetRegionBoundsI(GpRegion *region, GpGraphics *graphics,
                             GpRect *rect);

GpStatus WINGDIPAPI
GdipGetRegionHRgn(GpRegion *region, GpGraphics *graphics, HRGN *hRgn);

GpStatus WINGDIPAPI
GdipIsEmptyRegion(GpRegion *region, GpGraphics *graphics,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsInfiniteRegion(GpRegion *region, GpGraphics *graphics,
                              BOOL *result);

GpStatus WINGDIPAPI
GdipIsEqualRegion(GpRegion *region, GpRegion *region2,
                           GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetRegionDataSize(GpRegion *region, UINT * bufferSize);

GpStatus WINGDIPAPI
GdipGetRegionData(GpRegion *region, BYTE * buffer, UINT bufferSize, 
                  UINT * sizeFilled);

GpStatus WINGDIPAPI
GdipIsVisibleRegionPoint(GpRegion *region, REAL x, REAL y,
                                  GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionPointI(GpRegion *region, INT x, INT y,
                                  GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionRect(GpRegion *region, REAL x, REAL y, REAL width,
                        REAL height, GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionRectI(GpRegion *region, INT x, INT y, INT width,
                         INT height, GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetRegionScansCount(GpRegion *region, UINT* count, GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetRegionScans(GpRegion *region, GpRectF* rects, INT* count, 
                   GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetRegionScansI(GpRegion *region, GpRect* rects, INT* count, 
                    GpMatrix* matrix);

//----------------------------------------------------------------------------
// Brush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCloneBrush(GpBrush *brush, GpBrush **cloneBrush);

GpStatus WINGDIPAPI
GdipDeleteBrush(GpBrush *brush);

GpStatus WINGDIPAPI
GdipGetBrushType(GpBrush *brush, GpBrushType *type);

//----------------------------------------------------------------------------
// HatchBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateHatchBrush(GpHatchStyle hatchstyle, ARGB forecol,
                              ARGB backcol, GpHatch **brush);

GpStatus WINGDIPAPI
GdipGetHatchStyle(GpHatch *brush, GpHatchStyle *hatchstyle);

GpStatus WINGDIPAPI
GdipGetHatchForegroundColor(GpHatch *brush, ARGB* forecol);

GpStatus WINGDIPAPI
GdipGetHatchBackgroundColor(GpHatch *brush, ARGB* backcol);

//----------------------------------------------------------------------------
// TextureBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateTexture(GpImage *image, GpWrapMode wrapmode,
                           GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTexture2(GpImage *image, GpWrapMode wrapmode, REAL x,
                   REAL y, REAL width, REAL height, GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTextureIA(GpImage *image, 
                    GDIPCONST GpImageAttributes *imageAttributes,
                    REAL x, REAL y, REAL width, REAL height,
                    GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTexture2I(GpImage *image, GpWrapMode wrapmode, INT x,
                    INT y, INT width, INT height, GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTextureIAI(GpImage *image, 
                     GDIPCONST GpImageAttributes *imageAttributes,
                     INT x, INT y, INT width, INT height,
                     GpTexture **texture);


GpStatus WINGDIPAPI
GdipGetTextureTransform(GpTexture *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetTextureTransform(GpTexture *brush, GDIPCONST GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetTextureTransform(GpTexture* brush);

GpStatus WINGDIPAPI
GdipMultiplyTextureTransform(GpTexture* brush, GDIPCONST GpMatrix *matrix,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateTextureTransform(GpTexture* brush, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleTextureTransform(GpTexture* brush, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateTextureTransform(GpTexture* brush, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipSetTextureWrapMode(GpTexture *brush, GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetTextureWrapMode(GpTexture *brush, GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipGetTextureImage(GpTexture *brush, GpImage **image);

//----------------------------------------------------------------------------
// SolidBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateSolidFill(ARGB color, GpSolidFill **brush);

GpStatus WINGDIPAPI
GdipSetSolidFillColor(GpSolidFill *brush, ARGB color);

GpStatus WINGDIPAPI
GdipGetSolidFillColor(GpSolidFill *brush, ARGB *color);

//----------------------------------------------------------------------------
// LineBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateLineBrush(GDIPCONST GpPointF* point1,
                    GDIPCONST GpPointF* point2,
                    ARGB color1, ARGB color2,
                    GpWrapMode wrapMode,
                    GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushI(GDIPCONST GpPoint* point1,
                     GDIPCONST GpPoint* point2,
                     ARGB color1, ARGB color2,
                     GpWrapMode wrapMode,
                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRect(GDIPCONST GpRectF* rect,
                            ARGB color1, ARGB color2,
                            LinearGradientMode mode,
                            GpWrapMode wrapMode,
                            GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectI(GDIPCONST GpRect* rect,
                             ARGB color1, ARGB color2,
                             LinearGradientMode mode,
                             GpWrapMode wrapMode,
                             GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectWithAngle(GDIPCONST GpRectF* rect,
                                     ARGB color1, ARGB color2,
                                     REAL angle,
                                     BOOL isAngleScalable,
                                     GpWrapMode wrapMode,
                                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectWithAngleI(GDIPCONST GpRect* rect,
                                     ARGB color1, ARGB color2,
                                     REAL angle,
                                     BOOL isAngleScalable,
                                     GpWrapMode wrapMode,
                                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipSetLineColors(GpLineGradient *brush, ARGB color1, ARGB color2);

GpStatus WINGDIPAPI
GdipGetLineColors(GpLineGradient *brush, ARGB* colors);

GpStatus WINGDIPAPI
GdipGetLineRect(GpLineGradient *brush, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetLineRectI(GpLineGradient *brush, GpRect *rect);

GpStatus WINGDIPAPI
GdipSetLineGammaCorrection(GpLineGradient *brush, BOOL useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetLineGammaCorrection(GpLineGradient *brush, BOOL *useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetLineBlendCount(GpLineGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetLineBlend(GpLineGradient *brush, REAL *blend, REAL* positions,
                 INT count);

GpStatus WINGDIPAPI
GdipSetLineBlend(GpLineGradient *brush, GDIPCONST REAL *blend,
                 GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipGetLinePresetBlendCount(GpLineGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetLinePresetBlend(GpLineGradient *brush, ARGB *blend,
                                           REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetLinePresetBlend(GpLineGradient *brush, GDIPCONST ARGB *blend,
                       GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetLineSigmaBlend(GpLineGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetLineLinearBlend(GpLineGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetLineWrapMode(GpLineGradient *brush, GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetLineWrapMode(GpLineGradient *brush, GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipGetLineTransform(GpLineGradient *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetLineTransform(GpLineGradient *brush, GDIPCONST GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetLineTransform(GpLineGradient* brush);

GpStatus WINGDIPAPI
GdipMultiplyLineTransform(GpLineGradient* brush, GDIPCONST GpMatrix *matrix,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateLineTransform(GpLineGradient* brush, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleLineTransform(GpLineGradient* brush, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateLineTransform(GpLineGradient* brush, REAL angle, 
                        GpMatrixOrder order);

//----------------------------------------------------------------------------
// PathGradientBrush APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePathGradient(GDIPCONST GpPointF* points,
                                    INT count,
                                    GpWrapMode wrapMode,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipCreatePathGradientI(GDIPCONST GpPoint* points,
                                    INT count,
                                    GpWrapMode wrapMode,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipCreatePathGradientFromPath(GDIPCONST GpPath* path,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterColor(
                        GpPathGradient *brush, ARGB* colors);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterColor(
                        GpPathGradient *brush, ARGB colors);

GpStatus WINGDIPAPI
GdipGetPathGradientSurroundColorsWithCount(
                        GpPathGradient *brush, ARGB* color, INT* count);

GpStatus WINGDIPAPI
GdipSetPathGradientSurroundColorsWithCount(
                        GpPathGradient *brush,
                        GDIPCONST ARGB* color, INT* count);

GpStatus WINGDIPAPI
GdipGetPathGradientPath(GpPathGradient *brush, GpPath *path);

GpStatus WINGDIPAPI
GdipSetPathGradientPath(GpPathGradient *brush, GDIPCONST GpPath *path);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterPoint(
                        GpPathGradient *brush, GpPointF* points);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterPointI(
                        GpPathGradient *brush, GpPoint* points);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterPoint(
                        GpPathGradient *brush, GDIPCONST GpPointF* points);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterPointI(
                        GpPathGradient *brush, GDIPCONST GpPoint* points);

GpStatus WINGDIPAPI
GdipGetPathGradientRect(GpPathGradient *brush, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetPathGradientRectI(GpPathGradient *brush, GpRect *rect);

GpStatus WINGDIPAPI
GdipGetPathGradientPointCount(GpPathGradient *brush, INT* count);

GpStatus WINGDIPAPI
GdipGetPathGradientSurroundColorCount(GpPathGradient *brush, INT* count);

GpStatus WINGDIPAPI
GdipSetPathGradientGammaCorrection(GpPathGradient *brush, 
                                   BOOL useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetPathGradientGammaCorrection(GpPathGradient *brush, 
                                   BOOL *useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetPathGradientBlendCount(GpPathGradient *brush,
                                             INT *count);

GpStatus WINGDIPAPI
GdipGetPathGradientBlend(GpPathGradient *brush,
                                    REAL *blend, REAL *positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientBlend(GpPathGradient *brush,
                GDIPCONST REAL *blend, GDIPCONST REAL *positions, INT count);

GpStatus WINGDIPAPI
GdipGetPathGradientPresetBlendCount(GpPathGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetPathGradientPresetBlend(GpPathGradient *brush, ARGB *blend,
                                                REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientPresetBlend(GpPathGradient *brush, GDIPCONST ARGB *blend,
                                        GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientSigmaBlend(GpPathGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetPathGradientLinearBlend(GpPathGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipGetPathGradientWrapMode(GpPathGradient *brush,
                                         GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipSetPathGradientWrapMode(GpPathGradient *brush,
                                         GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetPathGradientTransform(GpPathGradient *brush,
                                          GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetPathGradientTransform(GpPathGradient *brush,
                                          GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPathGradientTransform(GpPathGradient* brush);

GpStatus WINGDIPAPI
GdipMultiplyPathGradientTransform(GpPathGradient* brush, 
                                  GDIPCONST GpMatrix *matrix,
                                  GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslatePathGradientTransform(GpPathGradient* brush, REAL dx, REAL dy,
                                   GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScalePathGradientTransform(GpPathGradient* brush, REAL sx, REAL sy,
                               GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotatePathGradientTransform(GpPathGradient* brush, REAL angle,
                                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipGetPathGradientFocusScales(GpPathGradient *brush, REAL* xScale, 
                               REAL* yScale);

GpStatus WINGDIPAPI
GdipSetPathGradientFocusScales(GpPathGradient *brush, REAL xScale, 
                               REAL yScale);

//----------------------------------------------------------------------------
// Pen APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePen1(ARGB color, REAL width, GpUnit unit, GpPen **pen);

GpStatus WINGDIPAPI
GdipCreatePen2(GpBrush *brush, REAL width, GpUnit unit,
                        GpPen **pen);

GpStatus WINGDIPAPI
GdipClonePen(GpPen *pen, GpPen **clonepen);

GpStatus WINGDIPAPI
GdipDeletePen(GpPen *pen);

GpStatus WINGDIPAPI
GdipSetPenWidth(GpPen *pen, REAL width);

GpStatus WINGDIPAPI
GdipGetPenWidth(GpPen *pen, REAL *width);

GpStatus WINGDIPAPI
GdipSetPenUnit(GpPen *pen, GpUnit unit);

GpStatus WINGDIPAPI
GdipGetPenUnit(GpPen *pen, GpUnit *unit);

GpStatus WINGDIPAPI
GdipSetPenLineCap197819(GpPen *pen, GpLineCap startCap, GpLineCap endCap,
                  GpDashCap dashCap);

GpStatus WINGDIPAPI
GdipSetPenStartCap(GpPen *pen, GpLineCap startCap);

GpStatus WINGDIPAPI
GdipSetPenEndCap(GpPen *pen, GpLineCap endCap);

GpStatus WINGDIPAPI
GdipSetPenDashCap197819(GpPen *pen, GpDashCap dashCap);

GpStatus WINGDIPAPI
GdipGetPenStartCap(GpPen *pen, GpLineCap *startCap);

GpStatus WINGDIPAPI
GdipGetPenEndCap(GpPen *pen, GpLineCap *endCap);

GpStatus WINGDIPAPI
GdipGetPenDashCap197819(GpPen *pen, GpDashCap *dashCap);

GpStatus WINGDIPAPI
GdipSetPenLineJoin(GpPen *pen, GpLineJoin lineJoin);

GpStatus WINGDIPAPI
GdipGetPenLineJoin(GpPen *pen, GpLineJoin *lineJoin);

GpStatus WINGDIPAPI
GdipSetPenCustomStartCap(GpPen *pen, GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipGetPenCustomStartCap(GpPen *pen, GpCustomLineCap** customCap);

GpStatus WINGDIPAPI
GdipSetPenCustomEndCap(GpPen *pen, GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipGetPenCustomEndCap(GpPen *pen, GpCustomLineCap** customCap);

GpStatus WINGDIPAPI
GdipSetPenMiterLimit(GpPen *pen, REAL miterLimit);

GpStatus WINGDIPAPI
GdipGetPenMiterLimit(GpPen *pen, REAL *miterLimit);

GpStatus WINGDIPAPI
GdipSetPenMode(GpPen *pen, GpPenAlignment penMode);

GpStatus WINGDIPAPI
GdipGetPenMode(GpPen *pen, GpPenAlignment *penMode);

GpStatus WINGDIPAPI
GdipSetPenTransform(GpPen *pen, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipGetPenTransform(GpPen *pen, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPenTransform(GpPen *pen);

GpStatus WINGDIPAPI
GdipMultiplyPenTransform(GpPen *pen, GDIPCONST GpMatrix *matrix,
                           GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslatePenTransform(GpPen *pen, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScalePenTransform(GpPen *pen, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotatePenTransform(GpPen *pen, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipSetPenColor(GpPen *pen, ARGB argb);

GpStatus WINGDIPAPI
GdipGetPenColor(GpPen *pen, ARGB *argb);

GpStatus WINGDIPAPI
GdipSetPenBrushFill(GpPen *pen, GpBrush *brush);

GpStatus WINGDIPAPI
GdipGetPenBrushFill(GpPen *pen, GpBrush **brush);

GpStatus WINGDIPAPI
GdipGetPenFillType(GpPen *pen, GpPenType* type);

GpStatus WINGDIPAPI
GdipGetPenDashStyle(GpPen *pen, GpDashStyle *dashstyle);

GpStatus WINGDIPAPI
GdipSetPenDashStyle(GpPen *pen, GpDashStyle dashstyle);

GpStatus WINGDIPAPI
GdipGetPenDashOffset(GpPen *pen, REAL *offset);

GpStatus WINGDIPAPI
GdipSetPenDashOffset(GpPen *pen, REAL offset);

GpStatus WINGDIPAPI
GdipGetPenDashCount(GpPen *pen, INT *count);

GpStatus WINGDIPAPI
GdipSetPenDashArray(GpPen *pen, GDIPCONST REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenDashArray(GpPen *pen, REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenCompoundCount(GpPen *pen, INT *count);

GpStatus WINGDIPAPI
GdipSetPenCompoundArray(GpPen *pen, GDIPCONST REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenCompoundArray(GpPen *pen, REAL *dash, INT count);

//----------------------------------------------------------------------------
// CustomLineCap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateCustomLineCap(GpPath* fillPath, GpPath* strokePath,
   GpLineCap baseCap, REAL baseInset, GpCustomLineCap **customCap);

GpStatus WINGDIPAPI
GdipDeleteCustomLineCap(GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipCloneCustomLineCap(GpCustomLineCap* customCap,
                       GpCustomLineCap** clonedCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapType(GpCustomLineCap* customCap,
                       CustomLineCapType* capType);

GpStatus WINGDIPAPI
GdipSetCustomLineCapStrokeCaps(GpCustomLineCap* customCap,
                               GpLineCap startCap, GpLineCap endCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapStrokeCaps(GpCustomLineCap* customCap,
                               GpLineCap* startCap, GpLineCap* endCap);

GpStatus WINGDIPAPI
GdipSetCustomLineCapStrokeJoin(GpCustomLineCap* customCap, 
                               GpLineJoin lineJoin);

GpStatus WINGDIPAPI
GdipGetCustomLineCapStrokeJoin(GpCustomLineCap* customCap, 
                               GpLineJoin* lineJoin);

GpStatus WINGDIPAPI
GdipSetCustomLineCapBaseCap(GpCustomLineCap* customCap, GpLineCap baseCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapBaseCap(GpCustomLineCap* customCap, GpLineCap* baseCap);

GpStatus WINGDIPAPI
GdipSetCustomLineCapBaseInset(GpCustomLineCap* customCap, REAL inset);

GpStatus WINGDIPAPI
GdipGetCustomLineCapBaseInset(GpCustomLineCap* customCap, REAL* inset);

GpStatus WINGDIPAPI
GdipSetCustomLineCapWidthScale(GpCustomLineCap* customCap, REAL widthScale);

GpStatus WINGDIPAPI
GdipGetCustomLineCapWidthScale(GpCustomLineCap* customCap, REAL* widthScale);

//----------------------------------------------------------------------------
// AdjustableArrowCap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateAdjustableArrowCap(REAL height, REAL width, BOOL isFilled,
                             GpAdjustableArrowCap **cap);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapHeight(GpAdjustableArrowCap* cap, REAL height);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapHeight(GpAdjustableArrowCap* cap, REAL* height);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapWidth(GpAdjustableArrowCap* cap, REAL width);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapWidth(GpAdjustableArrowCap* cap, REAL* width);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapMiddleInset(GpAdjustableArrowCap* cap, 
                                     REAL middleInset);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapMiddleInset(GpAdjustableArrowCap* cap, 
                                     REAL* middleInset);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapFillState(GpAdjustableArrowCap* cap, BOOL fillState);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapFillState(GpAdjustableArrowCap* cap, BOOL* fillState);

//----------------------------------------------------------------------------
// Image APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipLoadImageFromStream(IStream* stream, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromFile(GDIPCONST WCHAR* filename, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromStreamICM(IStream* stream, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromFileICM(GDIPCONST WCHAR* filename, GpImage **image);

GpStatus WINGDIPAPI
GdipCloneImage(GpImage *image, GpImage **cloneImage);

GpStatus WINGDIPAPI
GdipDisposeImage(GpImage *image);

GpStatus WINGDIPAPI
GdipSaveImageToFile(GpImage *image, GDIPCONST WCHAR* filename,
                    GDIPCONST CLSID* clsidEncoder, 
                    GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveImageToStream(GpImage *image, IStream* stream,
                      GDIPCONST CLSID* clsidEncoder, 
                      GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveAdd(GpImage *image, GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveAddImage(GpImage *image, GpImage* newImage,
                 GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipGetImageGraphicsContext(GpImage *image, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipGetImageBounds(GpImage *image, GpRectF *srcRect, GpUnit *srcUnit);

GpStatus WINGDIPAPI
GdipGetImageDimension(GpImage *image, REAL *width, REAL *height);

GpStatus WINGDIPAPI
GdipGetImageType(GpImage *image, ImageType *type);

GpStatus WINGDIPAPI
GdipGetImageWidth(GpImage *image, UINT *width);

GpStatus WINGDIPAPI
GdipGetImageHeight(GpImage *image, UINT *height);

GpStatus WINGDIPAPI
GdipGetImageHorizontalResolution(GpImage *image, REAL *resolution);

GpStatus WINGDIPAPI
GdipGetImageVerticalResolution(GpImage *image, REAL *resolution);

GpStatus WINGDIPAPI
GdipGetImageFlags(GpImage *image, UINT *flags);

GpStatus WINGDIPAPI
GdipGetImageRawFormat(GpImage *image, GUID *format);

GpStatus WINGDIPAPI
GdipGetImagePixelFormat(GpImage *image, PixelFormat *format);

GpStatus WINGDIPAPI
GdipGetImageThumbnail(GpImage *image, UINT thumbWidth, UINT thumbHeight,
                      GpImage **thumbImage,
                      GetThumbnailImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipGetEncoderParameterListSize(GpImage *image, GDIPCONST CLSID* clsidEncoder,
                                UINT* size);

GpStatus WINGDIPAPI
GdipGetEncoderParameterList(GpImage *image, GDIPCONST CLSID* clsidEncoder,
                            UINT size, EncoderParameters* buffer);

GpStatus WINGDIPAPI
GdipImageGetFrameDimensionsCount(GpImage* image, UINT* count);

GpStatus WINGDIPAPI
GdipImageGetFrameDimensionsList(GpImage* image, GUID* dimensionIDs, 
                                UINT count);

GpStatus WINGDIPAPI
GdipImageGetFrameCount(GpImage *image, GDIPCONST GUID* dimensionID, 
                       UINT* count);

GpStatus WINGDIPAPI
GdipImageSelectActiveFrame(GpImage *image, GDIPCONST GUID* dimensionID,
                           UINT frameIndex);

GpStatus WINGDIPAPI
GdipImageRotateFlip(GpImage *image, RotateFlipType rfType);

GpStatus WINGDIPAPI
GdipGetImagePalette(GpImage *image, ColorPalette *palette, INT size);

GpStatus WINGDIPAPI
GdipSetImagePalette(GpImage *image, GDIPCONST ColorPalette *palette);

GpStatus WINGDIPAPI
GdipGetImagePaletteSize(GpImage *image, INT *size);

GpStatus WINGDIPAPI
GdipGetPropertyCount(GpImage *image, UINT* numOfProperty);

GpStatus WINGDIPAPI
GdipGetPropertyIdList(GpImage *image, UINT numOfProperty, PROPID* list);

GpStatus WINGDIPAPI
GdipGetPropertyItemSize(GpImage *image, PROPID propId, UINT* size);

GpStatus WINGDIPAPI
GdipGetPropertyItem(GpImage *image, PROPID propId,UINT propSize,
                    PropertyItem* buffer);

GpStatus WINGDIPAPI
GdipGetPropertySize(GpImage *image, UINT* totalBufferSize, 
                    UINT* numProperties);

GpStatus WINGDIPAPI
GdipGetAllPropertyItems(GpImage *image, UINT totalBufferSize,
                        UINT numProperties, PropertyItem* allItems);

GpStatus WINGDIPAPI
GdipRemovePropertyItem(GpImage *image, PROPID propId);

GpStatus WINGDIPAPI
GdipSetPropertyItem(GpImage *image, GDIPCONST PropertyItem* item);

GpStatus WINGDIPAPI
GdipImageForceValidation(GpImage *image);

//----------------------------------------------------------------------------
// Bitmap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateBitmapFromStream(IStream* stream, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromFile(GDIPCONST WCHAR* filename, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromStreamICM(IStream* stream, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromFileICM(GDIPCONST WCHAR* filename, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromScan0(INT width,
                          INT height,
                          INT stride,
                          PixelFormat format,
                          BYTE* scan0,
                          GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromGraphics(INT width,
                             INT height,
                             GpGraphics* target,
                             GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromDirectDrawSurface(IDirectDrawSurface7* surface,
                                      GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromGdiDib(GDIPCONST BITMAPINFO* gdiBitmapInfo,
                           VOID* gdiBitmapData,
                           GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromHBITMAP(HBITMAP hbm,
                            HPALETTE hpal,
                            GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateHBITMAPFromBitmap(GpBitmap* bitmap,
                            HBITMAP* hbmReturn,
                            ARGB background);

GpStatus WINGDIPAPI
GdipCreateBitmapFromHICON(HICON hicon,
                          GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateHICONFromBitmap(GpBitmap* bitmap,
                          HICON* hbmReturn);

GpStatus WINGDIPAPI
GdipCreateBitmapFromResource(HINSTANCE hInstance,
                             GDIPCONST WCHAR* lpBitmapName,
                             GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCloneBitmapArea(REAL x, REAL y, REAL width, REAL height,
                            PixelFormat format,
                            GpBitmap *srcBitmap,
                            GpBitmap **dstBitmap);

GpStatus WINGDIPAPI
GdipCloneBitmapAreaI(INT x,
                     INT y,
                     INT width,
                     INT height,
                     PixelFormat format,
                     GpBitmap *srcBitmap,
                     GpBitmap **dstBitmap);

GpStatus WINGDIPAPI
GdipBitmapLockBits(GpBitmap* bitmap,
                   GDIPCONST GpRect* rect,
                   UINT flags,
                   PixelFormat format,
                   BitmapData* lockedBitmapData);

GpStatus WINGDIPAPI
GdipBitmapUnlockBits(GpBitmap* bitmap,
                     BitmapData* lockedBitmapData);

GpStatus WINGDIPAPI
GdipBitmapGetPixel(GpBitmap* bitmap, INT x, INT y, ARGB *color);

GpStatus WINGDIPAPI
GdipBitmapSetPixel(GpBitmap* bitmap, INT x, INT y, ARGB color);

GpStatus WINGDIPAPI
GdipBitmapSetResolution(GpBitmap* bitmap, REAL xdpi, REAL ydpi);

//----------------------------------------------------------------------------
// ImageAttributes APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateImageAttributes(GpImageAttributes **imageattr);

GpStatus WINGDIPAPI
GdipCloneImageAttributes(GDIPCONST GpImageAttributes *imageattr,
                         GpImageAttributes **cloneImageattr);

GpStatus WINGDIPAPI
GdipDisposeImageAttributes(GpImageAttributes *imageattr);

GpStatus WINGDIPAPI
GdipSetImageAttributesToIdentity(GpImageAttributes *imageattr,
                                 ColorAdjustType type);
GpStatus WINGDIPAPI
GdipResetImageAttributes(GpImageAttributes *imageattr,
                         ColorAdjustType type);

GpStatus WINGDIPAPI
GdipSetImageAttributesColorMatrix(GpImageAttributes *imageattr,
                               ColorAdjustType type,
                               BOOL enableFlag,
                               GDIPCONST ColorMatrix* colorMatrix,
                               GDIPCONST ColorMatrix* grayMatrix,
                               ColorMatrixFlags flags);

GpStatus WINGDIPAPI
GdipSetImageAttributesThreshold(GpImageAttributes *imageattr,
                                ColorAdjustType type,
                                BOOL enableFlag,
                                REAL threshold);

GpStatus WINGDIPAPI
GdipSetImageAttributesGamma(GpImageAttributes *imageattr,
                            ColorAdjustType type,
                            BOOL enableFlag,
                            REAL gamma);

GpStatus WINGDIPAPI
GdipSetImageAttributesNoOp(GpImageAttributes *imageattr,
                           ColorAdjustType type,
                           BOOL enableFlag);

GpStatus WINGDIPAPI
GdipSetImageAttributesColorKeys(GpImageAttributes *imageattr,
                                ColorAdjustType type,
                                BOOL enableFlag,
                                ARGB colorLow,
                                ARGB colorHigh);

GpStatus WINGDIPAPI
GdipSetImageAttributesOutputChannel(GpImageAttributes *imageattr,
                                    ColorAdjustType type,
                                    BOOL enableFlag,
                                    ColorChannelFlags channelFlags);

GpStatus WINGDIPAPI
GdipSetImageAttributesOutputChannelColorProfile(GpImageAttributes *imageattr,
                                                ColorAdjustType type,
                                                BOOL enableFlag,
                                                GDIPCONST 
                                                  WCHAR *colorProfileFilename);

GpStatus WINGDIPAPI
GdipSetImageAttributesRemapTable(GpImageAttributes *imageattr,
                                 ColorAdjustType type,
                                 BOOL enableFlag,
                                 UINT mapSize,
                                 GDIPCONST ColorMap *map);
GpStatus WINGDIPAPI
GdipSetImageAttributesWrapMode(
    GpImageAttributes *imageAttr,
    WrapMode wrap,
    ARGB argb,
    BOOL clamp
);

GpStatus WINGDIPAPI
GdipSetImageAttributesICMMode(
    GpImageAttributes *imageAttr,
    BOOL on
);

GpStatus WINGDIPAPI
GdipGetImageAttributesAdjustedPalette(
    GpImageAttributes *imageAttr,
    ColorPalette * colorPalette,
    ColorAdjustType colorAdjustType
);

//----------------------------------------------------------------------------
// Graphics APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipFlush(GpGraphics *graphics, GpFlushIntention intention);

GpStatus WINGDIPAPI
GdipCreateFromHDC(HDC hdc, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHDC2(HDC hdc, HANDLE hDevice, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHWND(HWND hwnd, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHWNDICM(HWND hwnd, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipDeleteGraphics(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipGetDC(GpGraphics* graphics, HDC * hdc);

GpStatus WINGDIPAPI
GdipReleaseDC(GpGraphics* graphics, HDC hdc);

GpStatus WINGDIPAPI
GdipSetCompositingMode(GpGraphics *graphics, CompositingMode compositingMode);

GpStatus WINGDIPAPI
GdipGetCompositingMode(GpGraphics *graphics, CompositingMode *compositingMode);

GpStatus WINGDIPAPI
GdipSetRenderingOrigin(GpGraphics *graphics, INT x, INT y);

GpStatus WINGDIPAPI
GdipGetRenderingOrigin(GpGraphics *graphics, INT *x, INT *y);

GpStatus WINGDIPAPI
GdipSetCompositingQuality(GpGraphics *graphics, 
                          CompositingQuality compositingQuality);

GpStatus WINGDIPAPI
GdipGetCompositingQuality(GpGraphics *graphics, 
                          CompositingQuality *compositingQuality);
                          
GpStatus WINGDIPAPI
GdipSetSmoothingMode(GpGraphics *graphics, SmoothingMode smoothingMode);

GpStatus WINGDIPAPI
GdipGetSmoothingMode(GpGraphics *graphics, SmoothingMode *smoothingMode);

GpStatus WINGDIPAPI
GdipSetPixelOffsetMode(GpGraphics* graphics, PixelOffsetMode pixelOffsetMode);

GpStatus WINGDIPAPI
GdipGetPixelOffsetMode(GpGraphics *graphics, PixelOffsetMode *pixelOffsetMode);

GpStatus WINGDIPAPI
GdipSetTextRenderingHint(GpGraphics *graphics, TextRenderingHint mode);

GpStatus WINGDIPAPI
GdipGetTextRenderingHint(GpGraphics *graphics, TextRenderingHint *mode);

GpStatus  WINGDIPAPI
GdipSetTextContrast(GpGraphics *graphics, UINT contrast);

GpStatus  WINGDIPAPI
GdipGetTextContrast(GpGraphics *graphics, UINT * contrast);

GpStatus WINGDIPAPI
GdipSetInterpolationMode(GpGraphics *graphics, 
                         InterpolationMode interpolationMode);

GpStatus WINGDIPAPI
GdipGetInterpolationMode(GpGraphics *graphics, 
                         InterpolationMode *interpolationMode);

GpStatus WINGDIPAPI
GdipSetWorldTransform(GpGraphics *graphics, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetWorldTransform(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipMultiplyWorldTransform(GpGraphics *graphics, GDIPCONST GpMatrix *matrix,
                           GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateWorldTransform(GpGraphics *graphics, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleWorldTransform(GpGraphics *graphics, REAL sx, REAL sy,
                        GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateWorldTransform(GpGraphics *graphics, REAL angle, 
                         GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipGetWorldTransform(GpGraphics *graphics, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPageTransform(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipGetPageUnit(GpGraphics *graphics, GpUnit *unit);

GpStatus WINGDIPAPI
GdipGetPageScale(GpGraphics *graphics, REAL *scale);

GpStatus WINGDIPAPI
GdipSetPageUnit(GpGraphics *graphics, GpUnit unit);

GpStatus WINGDIPAPI
GdipSetPageScale(GpGraphics *graphics, REAL scale);

GpStatus WINGDIPAPI
GdipGetDpiX(GpGraphics *graphics, REAL* dpi);

GpStatus WINGDIPAPI
GdipGetDpiY(GpGraphics *graphics, REAL* dpi);

GpStatus WINGDIPAPI
GdipTransformPoints(GpGraphics *graphics, GpCoordinateSpace destSpace,
                             GpCoordinateSpace srcSpace, GpPointF *points,
                             INT count);

GpStatus WINGDIPAPI
GdipTransformPointsI(GpGraphics *graphics, GpCoordinateSpace destSpace,
                             GpCoordinateSpace srcSpace, GpPoint *points,
                             INT count);

GpStatus WINGDIPAPI
GdipGetNearestColor(GpGraphics *graphics, ARGB* argb);

// Creates the Win9x Halftone Palette (even on NT) with correct Desktop colors
HPALETTE WINGDIPAPI
GdipCreateHalftonePalette();

GpStatus WINGDIPAPI
GdipDrawLine(GpGraphics *graphics, GpPen *pen, REAL x1, REAL y1,
                      REAL x2, REAL y2);

GpStatus WINGDIPAPI
GdipDrawLineI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1,
                      INT x2, INT y2);

GpStatus WINGDIPAPI
GdipDrawLines(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawLinesI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawArc(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
            REAL width, REAL height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawArcI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                     INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawBezier(GpGraphics *graphics, GpPen *pen, REAL x1, REAL y1,
                        REAL x2, REAL y2, REAL x3, REAL y3, REAL x4, REAL y4);

GpStatus WINGDIPAPI
GdipDrawBezierI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1,
                        INT x2, INT y2, INT x3, INT y3, INT x4, INT y4);

GpStatus WINGDIPAPI
GdipDrawBeziers(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawBeziersI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawRectangle(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                      REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawRectangleI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                      INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawRectangles(GpGraphics *graphics, GpPen *pen, GDIPCONST GpRectF *rects,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawRectanglesI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpRect *rects,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawEllipse(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                         REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawEllipseI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                         INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawPie(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                     REAL width, REAL height, REAL startAngle, 
            REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawPieI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                     INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawPolygon(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawPolygonI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawPath(GpGraphics *graphics, GpPen *pen, GpPath *path);

GpStatus WINGDIPAPI
GdipDrawCurve(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawCurveI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawCurve2(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve2I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve3(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
               INT count, INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve3I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                INT count, INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipDrawClosedCurve(GpGraphics *graphics, GpPen *pen,
                    GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipDrawClosedCurveI(GpGraphics *graphics, GpPen *pen,
                     GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipDrawClosedCurve2(GpGraphics *graphics, GpPen *pen,
                     GDIPCONST GpPointF *points, INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawClosedCurve2I(GpGraphics *graphics, GpPen *pen,
                      GDIPCONST GpPoint *points, INT count, REAL tension);

GpStatus WINGDIPAPI
GdipGraphicsClear(GpGraphics *graphics, ARGB color);

GpStatus WINGDIPAPI
GdipFillRectangle(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
                  REAL width, REAL height);

GpStatus WINGDIPAPI
GdipFillRectangleI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
                   INT width, INT height);

GpStatus WINGDIPAPI
GdipFillRectangles(GpGraphics *graphics, GpBrush *brush,
                   GDIPCONST GpRectF *rects, INT count);

GpStatus WINGDIPAPI
GdipFillRectanglesI(GpGraphics *graphics, GpBrush *brush,
                    GDIPCONST GpRect *rects, INT count);

GpStatus WINGDIPAPI
GdipFillPolygon(GpGraphics *graphics, GpBrush *brush,
                GDIPCONST GpPointF *points, INT count, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillPolygonI(GpGraphics *graphics, GpBrush *brush,
                 GDIPCONST GpPoint *points, INT count, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillPolygon2(GpGraphics *graphics, GpBrush *brush,
                 GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipFillPolygon2I(GpGraphics *graphics, GpBrush *brush,
                  GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFillEllipse(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
                REAL width, REAL height);

GpStatus WINGDIPAPI
GdipFillEllipseI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
                 INT width, INT height);

GpStatus WINGDIPAPI
GdipFillPie(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
            REAL width, REAL height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipFillPieI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
             INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipFillPath(GpGraphics *graphics, GpBrush *brush, GpPath *path);

GpStatus WINGDIPAPI
GdipFillClosedCurve(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipFillClosedCurveI(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFillClosedCurve2(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPointF *points, INT count,
                              REAL tension, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillClosedCurve2I(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPoint *points, INT count,
                              REAL tension, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillRegion(GpGraphics *graphics, GpBrush *brush,
                        GpRegion *region);

GpStatus WINGDIPAPI
GdipDrawImage(GpGraphics *graphics, GpImage *image, REAL x, REAL y);

GpStatus WINGDIPAPI
GdipDrawImageI(GpGraphics *graphics, GpImage *image, INT x, INT y);

GpStatus WINGDIPAPI
GdipDrawImageRect(GpGraphics *graphics, GpImage *image, REAL x, REAL y,
                           REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawImageRectI(GpGraphics *graphics, GpImage *image, INT x, INT y,
                           INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawImagePoints(GpGraphics *graphics, GpImage *image,
                             GDIPCONST GpPointF *dstpoints, INT count);

GpStatus WINGDIPAPI
GdipDrawImagePointsI(GpGraphics *graphics, GpImage *image,
                             GDIPCONST GpPoint *dstpoints, INT count);

GpStatus WINGDIPAPI
GdipDrawImagePointRect(GpGraphics *graphics, GpImage *image, REAL x,
                                REAL y, REAL srcx, REAL srcy, REAL srcwidth,
                                REAL srcheight, GpUnit srcUnit);

GpStatus WINGDIPAPI
GdipDrawImagePointRectI(GpGraphics *graphics, GpImage *image, INT x,
                                INT y, INT srcx, INT srcy, INT srcwidth,
                                INT srcheight, GpUnit srcUnit);

GpStatus WINGDIPAPI
GdipDrawImageRectRect(GpGraphics *graphics, GpImage *image, REAL dstx,
                      REAL dsty, REAL dstwidth, REAL dstheight,
                      REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight,
                      GpUnit srcUnit,
                      GDIPCONST GpImageAttributes* imageAttributes,
                      DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImageRectRectI(GpGraphics *graphics, GpImage *image, INT dstx,
                       INT dsty, INT dstwidth, INT dstheight,
                       INT srcx, INT srcy, INT srcwidth, INT srcheight,
                       GpUnit srcUnit,
                       GDIPCONST GpImageAttributes* imageAttributes,
                       DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image,
                        GDIPCONST GpPointF *points, INT count, REAL srcx,
                        REAL srcy, REAL srcwidth, REAL srcheight,
                        GpUnit srcUnit,
                        GDIPCONST GpImageAttributes* imageAttributes,
                        DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImagePointsRectI(GpGraphics *graphics, GpImage *image,
                         GDIPCONST GpPoint *points, INT count, INT srcx,
                         INT srcy, INT srcwidth, INT srcheight,
                         GpUnit srcUnit,
                         GDIPCONST GpImageAttributes* imageAttributes,
                         DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point *       destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point *       destPoints,
    INT                     count,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipPlayMetafileRecord(
    GDIPCONST GpMetafile *  metafile,
    EmfPlusRecordType       recordType,
    UINT                    flags,
    UINT                    dataSize,
    GDIPCONST BYTE *        data
    );

GpStatus WINGDIPAPI
GdipSetClipGraphics(GpGraphics *graphics, GpGraphics *srcgraphics,
                    CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRect(GpGraphics *graphics, REAL x, REAL y,
                         REAL width, REAL height, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRectI(GpGraphics *graphics, INT x, INT y,
                         INT width, INT height, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipPath(GpGraphics *graphics, GpPath *path, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRegion(GpGraphics *graphics, GpRegion *region,
                  CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipHrgn(GpGraphics *graphics, HRGN hRgn, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipResetClip(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipTranslateClip(GpGraphics *graphics, REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipTranslateClipI(GpGraphics *graphics, INT dx, INT dy);

GpStatus WINGDIPAPI
GdipGetClip(GpGraphics *graphics, GpRegion *region);

GpStatus WINGDIPAPI
GdipGetClipBounds(GpGraphics *graphics, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetClipBoundsI(GpGraphics *graphics, GpRect *rect);

GpStatus WINGDIPAPI
GdipIsClipEmpty(GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetVisibleClipBounds(GpGraphics *graphics, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetVisibleClipBoundsI(GpGraphics *graphics, GpRect *rect);

GpStatus WINGDIPAPI
GdipIsVisibleClipEmpty(GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePoint(GpGraphics *graphics, REAL x, REAL y,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePointI(GpGraphics *graphics, INT x, INT y,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRect(GpGraphics *graphics, REAL x, REAL y,
                           REAL width, REAL height, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRectI(GpGraphics *graphics, INT x, INT y,
                           INT width, INT height, BOOL *result);

GpStatus WINGDIPAPI
GdipSaveGraphics(GpGraphics *graphics, GraphicsState *state);

GpStatus WINGDIPAPI
GdipRestoreGraphics(GpGraphics *graphics, GraphicsState state);

GpStatus WINGDIPAPI
GdipBeginContainer(GpGraphics *graphics, GDIPCONST GpRectF* dstrect,
                   GDIPCONST GpRectF *srcrect, GpUnit unit, 
                   GraphicsContainer *state);

GpStatus WINGDIPAPI
GdipBeginContainerI(GpGraphics *graphics, GDIPCONST GpRect* dstrect,
                    GDIPCONST GpRect *srcrect, GpUnit unit, 
                    GraphicsContainer *state);

GpStatus WINGDIPAPI
GdipBeginContainer2(GpGraphics *graphics, GraphicsContainer* state);

GpStatus WINGDIPAPI
GdipEndContainer(GpGraphics *graphics, GraphicsContainer state);

GpStatus
GdipGetMetafileHeaderFromWmf(
    HMETAFILE           hWmf,
    GDIPCONST WmfPlaceableFileHeader *     wmfPlaceableFileHeader,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromEmf(
    HENHMETAFILE        hEmf,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromFile(
    GDIPCONST WCHAR*        filename,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromStream(
    IStream *           stream,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromMetafile(
    GpMetafile *        metafile,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetHemfFromMetafile(
    GpMetafile *        metafile,
    HENHMETAFILE *      hEmf
    );

GpStatus WINGDIPAPI
GdipCreateStreamOnFile(GDIPCONST WCHAR * filename, UINT access, 
                       IStream **stream);

GpStatus WINGDIPAPI
GdipCreateMetafileFromWmf(HMETAFILE hWmf, BOOL deleteWmf,
                          GDIPCONST WmfPlaceableFileHeader * wmfPlaceableFileHeader, 
                          GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromEmf(HENHMETAFILE hEmf, BOOL deleteEmf,
                          GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromFile(GDIPCONST WCHAR* file, GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromWmfFile(GDIPCONST WCHAR* file, 
                              GDIPCONST WmfPlaceableFileHeader * wmfPlaceableFileHeader, 
                              GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromStream(IStream * stream, GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipRecordMetafile(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileI(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileFileName(
    GDIPCONST WCHAR*    fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileFileNameI(
    GDIPCONST WCHAR*    fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileStream(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileStreamI(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipSetMetafileDownLevelRasterizationLimit(
    GpMetafile *            metafile,
    UINT                    metafileRasterizationLimitDpi
    );

GpStatus WINGDIPAPI
GdipGetMetafileDownLevelRasterizationLimit(
    GDIPCONST GpMetafile *  metafile,
    UINT *                  metafileRasterizationLimitDpi
    );

GpStatus WINGDIPAPI
GdipGetImageDecodersSize(UINT *numDecoders, UINT *size);

GpStatus WINGDIPAPI
GdipGetImageDecoders(UINT numDecoders,
                     UINT size,
                     ImageCodecInfo *decoders);

GpStatus WINGDIPAPI
GdipGetImageEncodersSize(UINT *numEncoders, UINT *size);

GpStatus WINGDIPAPI
GdipGetImageEncoders(UINT numEncoders,
                     UINT size,
                     ImageCodecInfo *encoders);

GpStatus WINGDIPAPI
GdipComment(GpGraphics* graphics, UINT sizeData, GDIPCONST BYTE * data);

//----------------------------------------------------------------------------
// FontFamily APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateFontFamilyFromName(GDIPCONST WCHAR *name,
                             GpFontCollection *fontCollection,
                             GpFontFamily **FontFamily);

GpStatus WINGDIPAPI
GdipDeleteFontFamily(GpFontFamily *FontFamily);

GpStatus WINGDIPAPI
GdipCloneFontFamily(GpFontFamily *FontFamily, GpFontFamily **clonedFontFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilySansSerif(GpFontFamily **nativeFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilySerif(GpFontFamily **nativeFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilyMonospace(GpFontFamily **nativeFamily);


GpStatus WINGDIPAPI
GdipGetFamilyName(
    GDIPCONST GpFontFamily  *family,
    WCHAR                name[LF_FACESIZE],
    LANGID               language
);

GpStatus   WINGDIPAPI
GdipIsStyleAvailable(GDIPCONST GpFontFamily *family, INT style, 
                     BOOL * IsStyleAvailable);

GpStatus WINGDIPAPI
GdipFontCollectionEnumerable(
    GpFontCollection* fontCollection,
    GpGraphics* graphics,
    INT *       numFound
);

GpStatus WINGDIPAPI GdipFontCollectionEnumerate(
    GpFontCollection* fontCollection,
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound,
    GpGraphics*     graphics
);

GpStatus WINGDIPAPI
GdipGetEmHeight(GDIPCONST GpFontFamily *family, INT style, 
                UINT16 * EmHeight);

GpStatus WINGDIPAPI
GdipGetCellAscent(GDIPCONST GpFontFamily *family, INT style,
                  UINT16 * CellAscent);

GpStatus WINGDIPAPI
GdipGetCellDescent(GDIPCONST GpFontFamily *family, INT style, 
                   UINT16 * CellDescent);

GpStatus WINGDIPAPI
GdipGetLineSpacing(GDIPCONST GpFontFamily *family, INT style, 
                   UINT16 * LineSpacing);


//----------------------------------------------------------------------------
// Font APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateFontFromDC(
    HDC        hdc,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFontFromLogfontA(
    HDC        hdc,
    GDIPCONST LOGFONTA  *logfont,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFontFromLogfontW(
    HDC        hdc,
    GDIPCONST LOGFONTW  *logfont,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFont(
    GDIPCONST GpFontFamily  *fontFamily,
    REAL                 emSize,
    INT                  style,
    Unit                 unit,
    GpFont             **font
);

GpStatus WINGDIPAPI
GdipCloneFont(GpFont* font, GpFont** cloneFont);

GpStatus WINGDIPAPI
GdipDeleteFont(GpFont* font);

GpStatus WINGDIPAPI
GdipGetFamily(GpFont *font, GpFontFamily **family);

GpStatus WINGDIPAPI
GdipGetFontStyle(GpFont *font, INT *style);

GpStatus WINGDIPAPI
GdipGetFontSize(GpFont *font, REAL *size);

GpStatus WINGDIPAPI
GdipGetFontUnit(GpFont *font, Unit *unit);

GpStatus WINGDIPAPI
GdipGetFontHeight(GDIPCONST GpFont *font, GDIPCONST GpGraphics *graphics, 
                  REAL *height);

GpStatus WINGDIPAPI
GdipGetFontHeightGivenDPI(GDIPCONST GpFont *font, REAL dpi, REAL *height);

GpStatus WINGDIPAPI
GdipGetLogFontA(GpFont * font, GpGraphics *graphics, LOGFONTA * logfontA);

GpStatus WINGDIPAPI
GdipGetLogFontW(GpFont * font, GpGraphics *graphics, LOGFONTW * logfontW);

GpStatus WINGDIPAPI
GdipNewInstalledFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipNewPrivateFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipDeletePrivateFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipGetFontCollectionFamilyCount(
    GpFontCollection* fontCollection,
    INT *       numFound
);

GpStatus WINGDIPAPI
GdipGetFontCollectionFamilyList(
    GpFontCollection* fontCollection,
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound
);

GpStatus WINGDIPAPI
GdipPrivateAddFontFile(
    GpFontCollection* fontCollection,
    GDIPCONST WCHAR* filename
);

GpStatus WINGDIPAPI
GdipPrivateAddMemoryFont(
    GpFontCollection* fontCollection,
    GDIPCONST void* memory,
    INT length
);

//----------------------------------------------------------------------------
// Text APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipDrawString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    GDIPCONST GpBrush        *brush
);

GpStatus WINGDIPAPI
GdipMeasureString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    RectF                    *boundingBox,
    INT                      *codepointsFitted,
    INT                      *linesFilled
);

GpStatus
WINGDIPAPI
GdipMeasureCharacterRanges(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          &layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    INT                       regionCount,
    GpRegion                **regions
);

GpStatus WINGDIPAPI
GdipDrawDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST GpBrush *brush,
    GDIPCONST PointF *positions,
    INT flags,
    GDIPCONST GpMatrix *matrix
);

GpStatus WINGDIPAPI
GdipMeasureDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST PointF *positions,
    INT flags,
    GDIPCONST GpMatrix *matrix,
    RectF *boundingBox
);

//----------------------------------------------------------------------------
// String format APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateStringFormat(
    INT               formatAttributes,
    LANGID            language,
    GpStringFormat  **format
);

GpStatus WINGDIPAPI
GdipStringFormatGetGenericDefault(GpStringFormat **format);

GpStatus WINGDIPAPI
GdipStringFormatGetGenericTypographic(GpStringFormat **format);

GpStatus WINGDIPAPI
GdipDeleteStringFormat(GpStringFormat *format);

GpStatus WINGDIPAPI
GdipCloneStringFormat(GDIPCONST GpStringFormat *format, 
                      GpStringFormat **newFormat);

GpStatus WINGDIPAPI
GdipSetStringFormatFlags(GpStringFormat *format, INT flags);

GpStatus WINGDIPAPI GdipGetStringFormatFlags(GDIPCONST GpStringFormat *format, 
                                             INT *flags);

GpStatus WINGDIPAPI
GdipSetStringFormatAlign(GpStringFormat *format, StringAlignment align);

GpStatus WINGDIPAPI
GdipGetStringFormatAlign(GDIPCONST GpStringFormat *format, 
                         StringAlignment *align);

GpStatus WINGDIPAPI
GdipSetStringFormatLineAlign(GpStringFormat *format,
                             StringAlignment align);

GpStatus WINGDIPAPI
GdipGetStringFormatLineAlign(GDIPCONST GpStringFormat *format,
                             StringAlignment *align);

GpStatus WINGDIPAPI
GdipSetStringFormatTrimming(
    GpStringFormat  *format,
    StringTrimming   trimming
);

GpStatus WINGDIPAPI
GdipGetStringFormatTrimming(
    GDIPCONST GpStringFormat *format,
    StringTrimming       *trimming
);

GpStatus WINGDIPAPI
GdipSetStringFormatHotkeyPrefix(GpStringFormat *format, INT hotkeyPrefix);

GpStatus WINGDIPAPI
GdipGetStringFormatHotkeyPrefix(GDIPCONST GpStringFormat *format, 
                                INT *hotkeyPrefix);

GpStatus WINGDIPAPI
GdipSetStringFormatTabStops(GpStringFormat *format, REAL firstTabOffset, 
                            INT count, GDIPCONST REAL *tabStops);

GpStatus WINGDIPAPI
GdipGetStringFormatTabStops(GDIPCONST GpStringFormat *format, INT count, 
                            REAL *firstTabOffset, REAL *tabStops);

GpStatus WINGDIPAPI
GdipGetStringFormatTabStopCount(GDIPCONST GpStringFormat *format, INT * count);

GpStatus WINGDIPAPI
GdipSetStringFormatDigitSubstitution(GpStringFormat *format, LANGID language,
                                     StringDigitSubstitute substitute);

GpStatus WINGDIPAPI
GdipGetStringFormatDigitSubstitution(GDIPCONST GpStringFormat *format, 
                                     LANGID *language,
                                     StringDigitSubstitute *substitute);

GpStatus WINGDIPAPI
GdipGetStringFormatMeasurableCharacterRangeCount(
    GDIPCONST GpStringFormat    *format,
    INT                         *count
);

GpStatus WINGDIPAPI
GdipSetStringFormatMeasurableCharacterRanges(
    GpStringFormat              *format,
    INT                         rangeCount,
    GDIPCONST CharacterRange    *ranges
);

//----------------------------------------------------------------------------
// Cached Bitmap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateCachedBitmap(
    GpBitmap *bitmap,
    GpGraphics *graphics,
    GpCachedBitmap **cachedBitmap
);

GpStatus WINGDIPAPI
GdipDeleteCachedBitmap(GpCachedBitmap *cachedBitmap);

GpStatus WINGDIPAPI
GdipDrawCachedBitmap(
    GpGraphics *graphics,
    GpCachedBitmap *cachedBitmap,
    INT x,
    INT y
);

UINT WINGDIPAPI
GdipEmfToWmfBits(
    HENHMETAFILE hemf,
    UINT         cbData16,
    LPBYTE       pData16,
    INT          iMapMode,
    INT          eFlags
);

GpStatus WINGDIPAPI
GdipSetImageAttributesCachedBackground(
    GpImageAttributes *imageattr,
    BOOL enableFlag
);

GpStatus WINGDIPAPI
GdipTestControl(
    GpTestControlEnum control,
    void * param
);

GpStatus WINAPI
GdiplusNotificationHook(
    OUT ULONG_PTR *token
);

VOID WINAPI
GdiplusNotificationUnhook(
    ULONG_PTR token
);

#ifdef __cplusplus
}
#endif

#endif // !_FLATAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusfont.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusFont.h
*
* Abstract:
*
*   GDI+ Font class
*
\**************************************************************************/

#ifndef _GDIPLUSFONT_H
#define _GDIPLUSFONT_H

inline
Font::Font(IN HDC hdc)
{
    GpFont *font = NULL;
    lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const HFONT hfont)
{
    GpFont *font = NULL;

    if (hfont)
    {
        LOGFONTA lf;

        if(GetObjectA(hfont, sizeof(LOGFONTA), &lf))
            lastResult = DllExports::GdipCreateFontFromLogfontA(hdc, &lf, &font);
        else
            lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const LOGFONTW* logfont)
{
    GpFont *font = NULL;
    if (logfont)
    {
        lastResult = DllExports::GdipCreateFontFromLogfontW(hdc, logfont, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const LOGFONTA* logfont)
{
    GpFont *font = NULL;

    if (logfont)
    {
        lastResult = DllExports::GdipCreateFontFromLogfontA(hdc, logfont, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

    SetNativeFont(font);
}

inline
Font::Font(
     IN const FontFamily * family,
     IN REAL         emSize,
     IN INT          style,
     IN Unit         unit
)
{
    GpFont *font = NULL;

    lastResult = DllExports::GdipCreateFont(family ? family->nativeFamily : NULL,
                    emSize,
                    style,
                    unit,
                    &font);

    SetNativeFont(font);
}

inline
Font::Font(
     IN const WCHAR *          familyName,
     IN REAL                   emSize,
     IN INT                    style,
     IN Unit                   unit,
     IN const FontCollection * fontCollection
)
{
    nativeFont = NULL;

    FontFamily family(familyName, fontCollection);
    GpFontFamily *nativeFamily = family.nativeFamily;

    lastResult = family.GetLastStatus();

    if (lastResult != Ok)
    {
        nativeFamily = FontFamily::GenericSansSerif()->nativeFamily;
        lastResult = FontFamily::GenericSansSerif()->lastResult;
        if (lastResult != Ok)
            return;
    }

    lastResult = DllExports::GdipCreateFont(nativeFamily,
                            emSize,
                            style,
                            unit,
                            &nativeFont);

    if (lastResult != Ok)
    {
        nativeFamily = FontFamily::GenericSansSerif()->nativeFamily;
        lastResult = FontFamily::GenericSansSerif()->lastResult;
        if (lastResult != Ok)
            return;

        lastResult = DllExports::GdipCreateFont(
            nativeFamily,
            emSize,
            style,
            unit,
            &nativeFont);
    }
}

inline Status
Font::GetLogFontA(IN const Graphics *g,
                  OUT LOGFONTA *logfontA) const
{
    return SetStatus(DllExports::GdipGetLogFontA(nativeFont, g ? g->nativeGraphics : NULL, logfontA));

}

inline Status
Font::GetLogFontW(IN const Graphics *g,
                  OUT LOGFONTW *logfontW) const
{
    return SetStatus(DllExports::GdipGetLogFontW(nativeFont, g ? g->nativeGraphics : NULL, logfontW));
}


inline Font*
Font::Clone() const
{
    GpFont *cloneFont = NULL;

    SetStatus(DllExports::GdipCloneFont(nativeFont, &cloneFont));

    return new Font(cloneFont, lastResult);
}

inline
Font::~Font()
{
    DllExports::GdipDeleteFont(nativeFont);
}

// Operations

inline BOOL
Font::IsAvailable() const
{
    return (nativeFont ? TRUE : FALSE);
}

inline Status
Font::GetFamily(OUT FontFamily *family) const
{
    if (family == NULL)
    {
        return SetStatus(InvalidParameter);
    }

    Status status = DllExports::GdipGetFamily(nativeFont, &(family->nativeFamily));
    family->SetStatus(status);

    return SetStatus(status);
}

inline INT
Font::GetStyle() const
{
    INT style;

    SetStatus(DllExports::GdipGetFontStyle(nativeFont, &style));

    return style;
}

inline REAL
Font::GetSize() const
{
    REAL size;
    SetStatus(DllExports::GdipGetFontSize(nativeFont, &size));
    return size;
}

inline Unit
Font::GetUnit() const
{
    Unit unit;
    SetStatus(DllExports::GdipGetFontUnit(nativeFont, &unit));
    return unit;
}

inline REAL
Font::GetHeight(IN const Graphics *graphics) const
{
    REAL height;
    SetStatus(DllExports::GdipGetFontHeight(
        nativeFont,
        graphics ? graphics->nativeGraphics : NULL,
        &height
    ));
    return height;
}


inline REAL
Font::GetHeight(IN REAL dpi) const
{
    REAL height;
    SetStatus(DllExports::GdipGetFontHeightGivenDPI(nativeFont, dpi, &height));
    return height;
}

inline
Font::Font(IN GpFont* font,
           IN Status status)
{
    lastResult = status;
    SetNativeFont(font);
}

inline VOID
Font::SetNativeFont(GpFont *Font)
{
    nativeFont = Font;
}

inline Status
Font::GetLastStatus(void) const
{
    return lastResult;
}

inline Status
Font::SetStatus(IN Status status) const
{
    if (status != Ok)
        return (lastResult = status);
    else
        return status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\sdkinc\gdiplusenums.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusEnums.h
*
* Abstract:
*
*   GDI+ Enumeration Types
*
\**************************************************************************/

#ifndef _GDIPLUSENUMS_H
#define _GDIPLUSENUMS_H

//--------------------------------------------------------------------------
// Default bezier flattening tolerance in device pixels.
//--------------------------------------------------------------------------

const float FlatnessDefault = 1.0f/4.0f;

//--------------------------------------------------------------------------
// Graphics and Container State cookies
//--------------------------------------------------------------------------

typedef UINT     GraphicsState;
typedef UINT     GraphicsContainer;

//--------------------------------------------------------------------------
// Fill mode constants
//--------------------------------------------------------------------------

enum FillMode
{
    FillModeAlternate,        // 0
    FillModeWinding           // 1
};

//--------------------------------------------------------------------------
// Quality mode constants
//--------------------------------------------------------------------------

enum QualityMode
{
    QualityModeInvalid   = -1,
    QualityModeDefault   = 0,
    QualityModeLow       = 1, // Best performance
    QualityModeHigh      = 2  // Best rendering quality
};

//--------------------------------------------------------------------------
// Alpha Compositing mode constants
//--------------------------------------------------------------------------

enum CompositingMode
{
    CompositingModeSourceOver,    // 0
    CompositingModeSourceCopy     // 1
};

//--------------------------------------------------------------------------
// Alpha Compositing quality constants
//--------------------------------------------------------------------------

enum CompositingQuality
{
    CompositingQualityInvalid          = QualityModeInvalid,
    CompositingQualityDefault          = QualityModeDefault,
    CompositingQualityHighSpeed        = QualityModeLow,
    CompositingQualityHighQuality      = QualityModeHigh,
    CompositingQualityGammaCorrected,
    CompositingQualityAssumeLinear
};

//--------------------------------------------------------------------------
// Unit constants
//--------------------------------------------------------------------------

enum Unit
{
    UnitWorld,      // 0 -- World coordinate (non-physical unit)
    UnitDisplay,    // 1 -- Variable -- for PageTransform only
    UnitPixel,      // 2 -- Each unit is one device pixel.
    UnitPoint,      // 3 -- Each unit is a printer's point, or 1/72 inch.
    UnitInch,       // 4 -- Each unit is 1 inch.
    UnitDocument,   // 5 -- Each unit is 1/300 inch.
    UnitMillimeter  // 6 -- Each unit is 1 millimeter.
};

//--------------------------------------------------------------------------
// MetafileFrameUnit
//
// The frameRect for creating a metafile can be specified in any of these
// units.  There is an extra frame unit value (MetafileFrameUnitGdi) so
// that units can be supplied in the same units that GDI expects for
// frame rects -- these units are in .01 (1/100ths) millimeter units
// as defined by GDI.
//--------------------------------------------------------------------------

enum MetafileFrameUnit
{
    MetafileFrameUnitPixel      = UnitPixel,
    MetafileFrameUnitPoint      = UnitPoint,
    MetafileFrameUnitInch       = UnitInch,
    MetafileFrameUnitDocument   = UnitDocument,
    MetafileFrameUnitMillimeter = UnitMillimeter,
    MetafileFrameUnitGdi                        // GDI compatible .01 MM units
};

//--------------------------------------------------------------------------
// Coordinate space identifiers
//--------------------------------------------------------------------------

enum CoordinateSpace
{
    CoordinateSpaceWorld,     // 0
    CoordinateSpacePage,      // 1
    CoordinateSpaceDevice     // 2
};

//--------------------------------------------------------------------------
// Various wrap modes for brushes
//--------------------------------------------------------------------------

enum WrapMode
{
    WrapModeTile,        // 0
    WrapModeTileFlipX,   // 1
    WrapModeTileFlipY,   // 2
    WrapModeTileFlipXY,  // 3
    WrapModeClamp        // 4
};

//--------------------------------------------------------------------------
// Various hatch styles
//--------------------------------------------------------------------------

enum HatchStyle
{
    HatchStyleHorizontal,                   // 0
    HatchStyleVertical,                     // 1
    HatchStyleForwardDiagonal,              // 2
    HatchStyleBackwardDiagonal,             // 3
    HatchStyleCross,                        // 4
    HatchStyleDiagonalCross,                // 5
    HatchStyle05Percent,                    // 6
    HatchStyle10Percent,                    // 7
    HatchStyle20Percent,                    // 8
    HatchStyle25Percent,                    // 9
    HatchStyle30Percent,                    // 10
    HatchStyle40Percent,                    // 11
    HatchStyle50Percent,                    // 12
    HatchStyle60Percent,                    // 13
    HatchStyle70Percent,                    // 14
    HatchStyle75Percent,                    // 15
    HatchStyle80Percent,                    // 16
    HatchStyle90Percent,                    // 17
    HatchStyleLightDownwardDiagonal,        // 18
    HatchStyleLightUpwardDiagonal,          // 19
    HatchStyleDarkDownwardDiagonal,         // 20
    HatchStyleDarkUpwardDiagonal,           // 21
    HatchStyleWideDownwardDiagonal,         // 22
    HatchStyleWideUpwardDiagonal,           // 23
    HatchStyleLightVertical,                // 24
    HatchStyleLightHorizontal,              // 25
    HatchStyleNarrowVertical,               // 26
    HatchStyleNarrowHorizontal,             // 27
    HatchStyleDarkVertical,                 // 28
    HatchStyleDarkHorizontal,               // 29
    HatchStyleDashedDownwardDiagonal,       // 30
    HatchStyleDashedUpwardDiagonal,         // 31
    HatchStyleDashedHorizontal,             // 32
    HatchStyleDashedVertical,               // 33
    HatchStyleSmallConfetti,                // 34
    HatchStyleLargeConfetti,                // 35
    HatchStyleZigZag,                       // 36
    HatchStyleWave,                         // 37
    HatchStyleDiagonalBrick,                // 38
    HatchStyleHorizontalBrick,              // 39
    HatchStyleWeave,                        // 40
    HatchStylePlaid,                        // 41
    HatchStyleDivot,                        // 42
    HatchStyleDottedGrid,                   // 43
    HatchStyleDottedDiamond,                // 44
    HatchStyleShingle,                      // 45
    HatchStyleTrellis,                      // 46
    HatchStyleSphere,                       // 47
    HatchStyleSmallGrid,                    // 48
    HatchStyleSmallCheckerBoard,            // 49
    HatchStyleLargeCheckerBoard,            // 50
    HatchStyleOutlinedDiamond,              // 51
    HatchStyleSolidDiamond,                 // 52

    HatchStyleTotal,   
    HatchStyleLargeGrid = HatchStyleCross,  // 4

    HatchStyleMin       = HatchStyleHorizontal,
    HatchStyleMax       = HatchStyleTotal - 1,
};

//--------------------------------------------------------------------------
// Dash style constants
//--------------------------------------------------------------------------

enum DashStyle
{
    DashStyleSolid,          // 0
    DashStyleDash,           // 1
    DashStyleDot,            // 2
    DashStyleDashDot,        // 3
    DashStyleDashDotDot,     // 4
    DashStyleCustom          // 5
};

//--------------------------------------------------------------------------
// Dash cap constants
//--------------------------------------------------------------------------

enum DashCap
{
    DashCapFlat             = 0,
    DashCapRound            = 2,
    DashCapTriangle         = 3
};

//--------------------------------------------------------------------------
// Line cap constants (only the lowest 8 bits are used).
//--------------------------------------------------------------------------

enum LineCap
{
    LineCapFlat             = 0,
    LineCapSquare           = 1,
    LineCapRound            = 2,
    LineCapTriangle         = 3,

    LineCapNoAnchor         = 0x10, // corresponds to flat cap
    LineCapSquareAnchor     = 0x11, // corresponds to square cap
    LineCapRoundAnchor      = 0x12, // corresponds to round cap
    LineCapDiamondAnchor    = 0x13, // corresponds to triangle cap
    LineCapArrowAnchor      = 0x14, // no correspondence

    LineCapCustom           = 0xff, // custom cap

    LineCapAnchorMask       = 0xf0  // mask to check for anchor or not.
};

//--------------------------------------------------------------------------
// Custom Line cap type constants
//--------------------------------------------------------------------------

enum CustomLineCapType
{
    CustomLineCapTypeDefault         = 0,
    CustomLineCapTypeAdjustableArrow = 1
};

//--------------------------------------------------------------------------
// Line join constants
//--------------------------------------------------------------------------

enum LineJoin
{
    LineJoinMiter        = 0,
    LineJoinBevel        = 1,
    LineJoinRound        = 2,
    LineJoinMiterClipped = 3
};

//--------------------------------------------------------------------------
// Path point types (only the lowest 8 bits are used.)
//  The lowest 3 bits are interpreted as point type
//  The higher 5 bits are reserved for flags.
//--------------------------------------------------------------------------

enum PathPointType
{
    PathPointTypeStart           = 0,    // move
    PathPointTypeLine            = 1,    // line
    PathPointTypeBezier          = 3,    // default Bezier (= cubic Bezier)
    PathPointTypePathTypeMask    = 0x07, // type mask (lowest 3 bits).
    PathPointTypeDashMode        = 0x10, // currently in dash mode.
    PathPointTypePathMarker      = 0x20, // a marker for the path.
    PathPointTypeCloseSubpath    = 0x80, // closed flag

    // Path types used for advanced path.

    PathPointTypeBezier3    = 3,         // cubic Bezier
};


//--------------------------------------------------------------------------
// WarpMode constants
//--------------------------------------------------------------------------

enum WarpMode
{
    WarpModePerspective,    // 0
    WarpModeBilinear        // 1
};

//--------------------------------------------------------------------------
// LineGradient Mode
//--------------------------------------------------------------------------

enum LinearGradientMode
{
    LinearGradientModeHorizontal,         // 0
    LinearGradientModeVertical,           // 1
    LinearGradientModeForwardDiagonal,    // 2
    LinearGradientModeBackwardDiagonal    // 3
};

//--------------------------------------------------------------------------
// Region Comine Modes
//--------------------------------------------------------------------------

enum CombineMode
{
    CombineModeReplace,     // 0
    CombineModeIntersect,   // 1
    CombineModeUnion,       // 2
    CombineModeXor,         // 3
    CombineModeExclude,     // 4
    CombineModeComplement   // 5 (Exclude From)
};

//--------------------------------------------------------------------------
 // Image types
//--------------------------------------------------------------------------

enum ImageType
{
    ImageTypeUnknown,   // 0
    ImageTypeBitmap,    // 1
    ImageTypeMetafile   // 2
};

//--------------------------------------------------------------------------
// Interpolation modes
//--------------------------------------------------------------------------

enum InterpolationMode
{
    InterpolationModeInvalid          = QualityModeInvalid,
    InterpolationModeDefault          = QualityModeDefault,
    InterpolationModeLowQuality       = QualityModeLow,
    InterpolationModeHighQuality      = QualityModeHigh,
    InterpolationModeBilinear,
    InterpolationModeBicubic,
    InterpolationModeNearestNeighbor,
    InterpolationModeHighQualityBilinear,
    InterpolationModeHighQualityBicubic
};

//--------------------------------------------------------------------------
// Pen types
//--------------------------------------------------------------------------

enum PenAlignment
{
    PenAlignmentCenter       = 0,
    PenAlignmentInset        = 1
};

//--------------------------------------------------------------------------
// Brush types
//--------------------------------------------------------------------------

enum BrushType
{
   BrushTypeSolidColor       = 0,
   BrushTypeHatchFill        = 1,
   BrushTypeTextureFill      = 2,
   BrushTypePathGradient     = 3,
   BrushTypeLinearGradient   = 4
};

//--------------------------------------------------------------------------
// Pen's Fill types
//--------------------------------------------------------------------------

enum PenType
{
   PenTypeSolidColor       = BrushTypeSolidColor,
   PenTypeHatchFill        = BrushTypeHatchFill,
   PenTypeTextureFill      = BrushTypeTextureFill,
   PenTypePathGradient     = BrushTypePathGradient,
   PenTypeLinearGradient   = BrushTypeLinearGradient,
   PenTypeUnknown          = -1
};

//--------------------------------------------------------------------------
// Matrix Order
//--------------------------------------------------------------------------

enum MatrixOrder
{
    MatrixOrderPrepend    = 0,
    MatrixOrderAppend     = 1
};

//--------------------------------------------------------------------------
// Generic font families
//--------------------------------------------------------------------------

enum GenericFontFamily
{
    GenericFontFamilySerif,
    GenericFontFamilySansSerif,
    GenericFontFamilyMonospace

};

//--------------------------------------------------------------------------
// FontStyle: face types and common styles
//--------------------------------------------------------------------------

enum FontStyle
{
    FontStyleRegular    = 0,
    FontStyleBold       = 1,
    FontStyleItalic     = 2,
    FontStyleBoldItalic = 3,
    FontStyleUnderline  = 4,
    FontStyleStrikeout  = 8
};

//---------------------------------------------------------------------------
// Smoothing Mode
//---------------------------------------------------------------------------

enum SmoothingMode
{
    SmoothingModeInvalid     = QualityModeInvalid,
    SmoothingModeDefault     = QualityModeDefault,
    SmoothingModeHighSpeed   = QualityModeLow,
    SmoothingModeHighQuality = QualityModeHigh,
    SmoothingModeNone,
    SmoothingModeAntiAlias
};

//---------------------------------------------------------------------------
// Pixel Format Mode
//---------------------------------------------------------------------------

enum PixelOffsetMode
{
    PixelOffsetModeInvalid     = QualityModeInvalid,
    PixelOffsetModeDefault     = QualityModeDefault,
    PixelOffsetModeHighSpeed   = QualityModeLow,
    PixelOffsetModeHighQuality = QualityModeHigh,
    PixelOffsetModeNone,    // No pixel offset
    PixelOffsetModeHalf     // Offset by -0.5, -0.5 for fast anti-alias perf
};

//---------------------------------------------------------------------------
// Text Rendering Hint
//---------------------------------------------------------------------------

enum TextRenderingHint
{
    TextRenderingHintSystemDefault = 0,            // Glyph with system default rendering hint
    TextRenderingHintSingleBitPerPixelGridFit,     // Glyph bitmap with hinting
    TextRenderingHintSingleBitPerPixel,            // Glyph bitmap without hinting
    TextRenderingHintAntiAliasGridFit,             // Glyph anti-alias bitmap with hinting
    TextRenderingHintAntiAlias,                    // Glyph anti-alias bitmap without hinting
    TextRenderingHintClearTypeGridFit              // Glyph CT bitmap with hinting
};

//---------------------------------------------------------------------------
// Metafile Types
//---------------------------------------------------------------------------

enum MetafileType
{
    MetafileTypeInvalid,            // Invalid metafile
    MetafileTypeWmf,                // Standard WMF
    MetafileTypeWmfPlaceable,       // Placeable WMF
    MetafileTypeEmf,                // EMF (not EMF+)
    MetafileTypeEmfPlusOnly,        // EMF+ without dual, down-level records
    MetafileTypeEmfPlusDual         // EMF+ with dual, down-level records
};

//---------------------------------------------------------------------------
// Specifies the type of EMF to record
//---------------------------------------------------------------------------

enum EmfType
{
    EmfTypeEmfOnly     = MetafileTypeEmf,          // no EMF+, only EMF
    EmfTypeEmfPlusOnly = MetafileTypeEmfPlusOnly,  // no EMF, only EMF+
    EmfTypeEmfPlusDual = MetafileTypeEmfPlusDual   // both EMF+ and EMF
};

//---------------------------------------------------------------------------
// EMF+ Persistent object types
//---------------------------------------------------------------------------

enum ObjectType
{
    ObjectTypeInvalid,
    ObjectTypeBrush,
    ObjectTypePen,
    ObjectTypePath,
    ObjectTypeRegion,
    ObjectTypeImage,
    ObjectTypeFont,
    ObjectTypeStringFormat,
    ObjectTypeImageAttributes,
    ObjectTypeCustomLineCap,

    ObjectTypeMax = ObjectTypeCustomLineCap,
    ObjectTypeMin = ObjectTypeBrush
};

inline BOOL
ObjectTypeIsValid(
    ObjectType      type
    )
{
    return ((type >= ObjectTypeMin) && (type <= ObjectTypeMax));
}

//---------------------------------------------------------------------------
// EMF+ Records
//---------------------------------------------------------------------------

// We have to change the WMF record numbers so that they don't conflict with
// the EMF and EMF+ record numbers.

enum EmfPlusRecordType;

#define GDIP_EMFPLUS_RECORD_BASE        0x00004000
#define GDIP_WMF_RECORD_BASE            0x00010000
#define GDIP_WMF_RECORD_TO_EMFPLUS(n)   ((EmfPlusRecordType)((n) | GDIP_WMF_RECORD_BASE))
#define GDIP_EMFPLUS_RECORD_TO_WMF(n)   ((n) & (~GDIP_WMF_RECORD_BASE))
#define GDIP_IS_WMF_RECORDTYPE(n)       (((n) & GDIP_WMF_RECORD_BASE) != 0)

enum EmfPlusRecordType
{
   // Since we have to enumerate GDI records right along with GDI+ records,
   // We list all the GDI records here so that they can be part of the
   // same enumeration type which is used in the enumeration callback.

    WmfRecordTypeSetBkColor              = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETBKCOLOR),
    WmfRecordTypeSetBkMode               = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETBKMODE),
    WmfRecordTypeSetMapMode              = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETMAPMODE),
    WmfRecordTypeSetROP2                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETROP2),
    WmfRecordTypeSetRelAbs               = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETRELABS),
    WmfRecordTypeSetPolyFillMode         = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPOLYFILLMODE),
    WmfRecordTypeSetStretchBltMode       = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETSTRETCHBLTMODE),
    WmfRecordTypeSetTextCharExtra        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTCHAREXTRA),
    WmfRecordTypeSetTextColor            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTCOLOR),
    WmfRecordTypeSetTextJustification    = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTJUSTIFICATION),
    WmfRecordTypeSetWindowOrg            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETWINDOWORG),
    WmfRecordTypeSetWindowExt            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETWINDOWEXT),
    WmfRecordTypeSetViewportOrg          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETVIEWPORTORG),
    WmfRecordTypeSetViewportExt          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETVIEWPORTEXT),
    WmfRecordTypeOffsetWindowOrg         = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETWINDOWORG),
    WmfRecordTypeScaleWindowExt          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SCALEWINDOWEXT),
    WmfRecordTypeOffsetViewportOrg       = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETVIEWPORTORG),
    WmfRecordTypeScaleViewportExt        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SCALEVIEWPORTEXT),
    WmfRecordTypeLineTo                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_LINETO),
    WmfRecordTypeMoveTo                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_MOVETO),
    WmfRecordTypeExcludeClipRect         = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXCLUDECLIPRECT),
    WmfRecordTypeIntersectClipRect       = GDIP_WMF_RECORD_TO_EMFPLUS(META_INTERSECTCLIPRECT),
    WmfRecordTypeArc                     = GDIP_WMF_RECORD_TO_EMFPLUS(META_ARC),
    WmfRecordTypeEllipse                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_ELLIPSE),
    WmfRecordTypeFloodFill               = GDIP_WMF_RECORD_TO_EMFPLUS(META_FLOODFILL),
    WmfRecordTypePie                     = GDIP_WMF_RECORD_TO_EMFPLUS(META_PIE),
    WmfRecordTypeRectangle               = GDIP_WMF_RECORD_TO_EMFPLUS(META_RECTANGLE),
    WmfRecordTypeRoundRect               = GDIP_WMF_RECORD_TO_EMFPLUS(META_ROUNDRECT),
    WmfRecordTypePatBlt                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_PATBLT),
    WmfRecordTypeSaveDC                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_SAVEDC),
    WmfRecordTypeSetPixel                = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPIXEL),
    WmfRecordTypeOffsetClipRgn           = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETCLIPRGN),
    WmfRecordTypeTextOut                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_TEXTOUT),
    WmfRecordTypeBitBlt                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_BITBLT),
    WmfRecordTypeStretchBlt              = GDIP_WMF_RECORD_TO_EMFPLUS(META_STRETCHBLT),
    WmfRecordTypePolygon                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYGON),
    WmfRecordTypePolyline                = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYLINE),
    WmfRecordTypeEscape                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_ESCAPE),
    WmfRecordTypeRestoreDC               = GDIP_WMF_RECORD_TO_EMFPLUS(META_RESTOREDC),
    WmfRecordTypeFillRegion              = GDIP_WMF_RECORD_TO_EMFPLUS(META_FILLREGION),
    WmfRecordTypeFrameRegion             = GDIP_WMF_RECORD_TO_EMFPLUS(META_FRAMEREGION),
    WmfRecordTypeInvertRegion            = GDIP_WMF_RECORD_TO_EMFPLUS(META_INVERTREGION),
    WmfRecordTypePaintRegion             = GDIP_WMF_RECORD_TO_EMFPLUS(META_PAINTREGION),
    WmfRecordTypeSelectClipRegion        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTCLIPREGION),
    WmfRecordTypeSelectObject            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTOBJECT),
    WmfRecordTypeSetTextAlign            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTALIGN),
    WmfRecordTypeDrawText                = GDIP_WMF_RECORD_TO_EMFPLUS(0x062F),  // META_DRAWTEXT
    WmfRecordTypeChord                   = GDIP_WMF_RECORD_TO_EMFPLUS(META_CHORD),
    WmfRecordTypeSetMapperFlags          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETMAPPERFLAGS),
    WmfRecordTypeExtTextOut              = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXTTEXTOUT),
    WmfRecordTypeSetDIBToDev             = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETDIBTODEV),
    WmfRecordTypeSelectPalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTPALETTE),
    WmfRecordTypeRealizePalette          = GDIP_WMF_RECORD_TO_EMFPLUS(META_REALIZEPALETTE),
    WmfRecordTypeAnimatePalette          = GDIP_WMF_RECORD_TO_EMFPLUS(META_ANIMATEPALETTE),
    WmfRecordTypeSetPalEntries           = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPALENTRIES),
    WmfRecordTypePolyPolygon             = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYPOLYGON),
    WmfRecordTypeResizePalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_RESIZEPALETTE),
    WmfRecordTypeDIBBitBlt               = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBBITBLT),
    WmfRecordTypeDIBStretchBlt           = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBSTRETCHBLT),
    WmfRecordTypeDIBCreatePatternBrush   = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBCREATEPATTERNBRUSH),
    WmfRecordTypeStretchDIB              = GDIP_WMF_RECORD_TO_EMFPLUS(META_STRETCHDIB),
    WmfRecordTypeExtFloodFill            = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXTFLOODFILL),
    WmfRecordTypeSetLayout               = GDIP_WMF_RECORD_TO_EMFPLUS(0x0149),  // META_SETLAYOUT
    WmfRecordTypeResetDC                 = GDIP_WMF_RECORD_TO_EMFPLUS(0x014C),  // META_RESETDC
    WmfRecordTypeStartDoc                = GDIP_WMF_RECORD_TO_EMFPLUS(0x014D),  // META_STARTDOC
    WmfRecordTypeStartPage               = GDIP_WMF_RECORD_TO_EMFPLUS(0x004F),  // META_STARTPAGE
    WmfRecordTypeEndPage                 = GDIP_WMF_RECORD_TO_EMFPLUS(0x0050),  // META_ENDPAGE
    WmfRecordTypeAbortDoc                = GDIP_WMF_RECORD_TO_EMFPLUS(0x0052),  // META_ABORTDOC
    WmfRecordTypeEndDoc                  = GDIP_WMF_RECORD_TO_EMFPLUS(0x005E),  // META_ENDDOC
    WmfRecordTypeDeleteObject            = GDIP_WMF_RECORD_TO_EMFPLUS(META_DELETEOBJECT),
    WmfRecordTypeCreatePalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPALETTE),
    WmfRecordTypeCreateBrush             = GDIP_WMF_RECORD_TO_EMFPLUS(0x00F8),  // META_CREATEBRUSH
    WmfRecordTypeCreatePatternBrush      = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPATTERNBRUSH),
    WmfRecordTypeCreatePenIndirect       = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPENINDIRECT),
    WmfRecordTypeCreateFontIndirect      = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEFONTINDIRECT),
    WmfRecordTypeCreateBrushIndirect     = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEBRUSHINDIRECT),
    WmfRecordTypeCreateBitmapIndirect    = GDIP_WMF_RECORD_TO_EMFPLUS(0x02FD),  // META_CREATEBITMAPINDIRECT
    WmfRecordTypeCreateBitmap            = GDIP_WMF_RECORD_TO_EMFPLUS(0x06FE),  // META_CREATEBITMAP
    WmfRecordTypeCreateRegion            = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEREGION),

    EmfRecordTypeHeader                  = EMR_HEADER,
    EmfRecordTypePolyBezier              = EMR_POLYBEZIER,
    EmfRecordTypePolygon                 = EMR_POLYGON,
    EmfRecordTypePolyline                = EMR_POLYLINE,
    EmfRecordTypePolyBezierTo            = EMR_POLYBEZIERTO,
    EmfRecordTypePolyLineTo              = EMR_POLYLINETO,
    EmfRecordTypePolyPolyline            = EMR_POLYPOLYLINE,
    EmfRecordTypePolyPolygon             = EMR_POLYPOLYGON,
    EmfRecordTypeSetWindowExtEx          = EMR_SETWINDOWEXTEX,
    EmfRecordTypeSetWindowOrgEx          = EMR_SETWINDOWORGEX,
    EmfRecordTypeSetViewportExtEx        = EMR_SETVIEWPORTEXTEX,
    EmfRecordTypeSetViewportOrgEx        = EMR_SETVIEWPORTORGEX,
    EmfRecordTypeSetBrushOrgEx           = EMR_SETBRUSHORGEX,
    EmfRecordTypeEOF                     = EMR_EOF,
    EmfRecordTypeSetPixelV               = EMR_SETPIXELV,
    EmfRecordTypeSetMapperFlags          = EMR_SETMAPPERFLAGS,
    EmfRecordTypeSetMapMode              = EMR_SETMAPMODE,
    EmfRecordTypeSetBkMode               = EMR_SETBKMODE,
    EmfRecordTypeSetPolyFillMode         = EMR_SETPOLYFILLMODE,
    EmfRecordTypeSetROP2                 = EMR_SETROP2,
    EmfRecordTypeSetStretchBltMode       = EMR_SETSTRETCHBLTMODE,
    EmfRecordTypeSetTextAlign            = EMR_SETTEXTALIGN,
    EmfRecordTypeSetColorAdjustment      = EMR_SETCOLORADJUSTMENT,
    EmfRecordTypeSetTextColor            = EMR_SETTEXTCOLOR,
    EmfRecordTypeSetBkColor              = EMR_SETBKCOLOR,
    EmfRecordTypeOffsetClipRgn           = EMR_OFFSETCLIPRGN,
    EmfRecordTypeMoveToEx                = EMR_MOVETOEX,
    EmfRecordTypeSetMetaRgn              = EMR_SETMETARGN,
    EmfRecordTypeExcludeClipRect         = EMR_EXCLUDECLIPRECT,
    EmfRecordTypeIntersectClipRect       = EMR_INTERSECTCLIPRECT,
    EmfRecordTypeScaleViewportExtEx      = EMR_SCALEVIEWPORTEXTEX,
    EmfRecordTypeScaleWindowExtEx        = EMR_SCALEWINDOWEXTEX,
    EmfRecordTypeSaveDC                  = EMR_SAVEDC,
    EmfRecordTypeRestoreDC               = EMR_RESTOREDC,
    EmfRecordTypeSetWorldTransform       = EMR_SETWORLDTRANSFORM,
    EmfRecordTypeModifyWorldTransform    = EMR_MODIFYWORLDTRANSFORM,
    EmfRecordTypeSelectObject            = EMR_SELECTOBJECT,
    EmfRecordTypeCreatePen               = EMR_CREATEPEN,
    EmfRecordTypeCreateBrushIndirect     = EMR_CREATEBRUSHINDIRECT,
    EmfRecordTypeDeleteObject            = EMR_DELETEOBJECT,
    EmfRecordTypeAngleArc                = EMR_ANGLEARC,
    EmfRecordTypeEllipse                 = EMR_ELLIPSE,
    EmfRecordTypeRectangle               = EMR_RECTANGLE,
    EmfRecordTypeRoundRect               = EMR_ROUNDRECT,
    EmfRecordTypeArc                     = EMR_ARC,
    EmfRecordTypeChord                   = EMR_CHORD,
    EmfRecordTypePie                     = EMR_PIE,
    EmfRecordTypeSelectPalette           = EMR_SELECTPALETTE,
    EmfRecordTypeCreatePalette           = EMR_CREATEPALETTE,
    EmfRecordTypeSetPaletteEntries       = EMR_SETPALETTEENTRIES,
    EmfRecordTypeResizePalette           = EMR_RESIZEPALETTE,
    EmfRecordTypeRealizePalette          = EMR_REALIZEPALETTE,
    EmfRecordTypeExtFloodFill            = EMR_EXTFLOODFILL,
    EmfRecordTypeLineTo                  = EMR_LINETO,
    EmfRecordTypeArcTo                   = EMR_ARCTO,
    EmfRecordTypePolyDraw                = EMR_POLYDRAW,
    EmfRecordTypeSetArcDirection         = EMR_SETARCDIRECTION,
    EmfRecordTypeSetMiterLimit           = EMR_SETMITERLIMIT,
    EmfRecordTypeBeginPath               = EMR_BEGINPATH,
    EmfRecordTypeEndPath                 = EMR_ENDPATH,
    EmfRecordTypeCloseFigure             = EMR_CLOSEFIGURE,
    EmfRecordTypeFillPath                = EMR_FILLPATH,
    EmfRecordTypeStrokeAndFillPath       = EMR_STROKEANDFILLPATH,
    EmfRecordTypeStrokePath              = EMR_STROKEPATH,
    EmfRecordTypeFlattenPath             = EMR_FLATTENPATH,
    EmfRecordTypeWidenPath               = EMR_WIDENPATH,
    EmfRecordTypeSelectClipPath          = EMR_SELECTCLIPPATH,
    EmfRecordTypeAbortPath               = EMR_ABORTPATH,
    EmfRecordTypeReserved_069            = 69,  // Not Used
    EmfRecordTypeGdiComment              = EMR_GDICOMMENT,
    EmfRecordTypeFillRgn                 = EMR_FILLRGN,
    EmfRecordTypeFrameRgn                = EMR_FRAMERGN,
    EmfRecordTypeInvertRgn               = EMR_INVERTRGN,
    EmfRecordTypePaintRgn                = EMR_PAINTRGN,
    EmfRecordTypeExtSelectClipRgn        = EMR_EXTSELECTCLIPRGN,
    EmfRecordTypeBitBlt                  = EMR_BITBLT,
    EmfRecordTypeStretchBlt              = EMR_STRETCHBLT,
    EmfRecordTypeMaskBlt                 = EMR_MASKBLT,
    EmfRecordTypePlgBlt                  = EMR_PLGBLT,
    EmfRecordTypeSetDIBitsToDevice       = EMR_SETDIBITSTODEVICE,
    EmfRecordTypeStretchDIBits           = EMR_STRETCHDIBITS,
    EmfRecordTypeExtCreateFontIndirect   = EMR_EXTCREATEFONTINDIRECTW,
    EmfRecordTypeExtTextOutA             = EMR_EXTTEXTOUTA,
    EmfRecordTypeExtTextOutW             = EMR_EXTTEXTOUTW,
    EmfRecordTypePolyBezier16            = EMR_POLYBEZIER16,
    EmfRecordTypePolygon16               = EMR_POLYGON16,
    EmfRecordTypePolyline16              = EMR_POLYLINE16,
    EmfRecordTypePolyBezierTo16          = EMR_POLYBEZIERTO16,
    EmfRecordTypePolylineTo16            = EMR_POLYLINETO16,
    EmfRecordTypePolyPolyline16          = EMR_POLYPOLYLINE16,
    EmfRecordTypePolyPolygon16           = EMR_POLYPOLYGON16,
    EmfRecordTypePolyDraw16              = EMR_POLYDRAW16,
    EmfRecordTypeCreateMonoBrush         = EMR_CREATEMONOBRUSH,
    EmfRecordTypeCreateDIBPatternBrushPt = EMR_CREATEDIBPATTERNBRUSHPT,
    EmfRecordTypeExtCreatePen            = EMR_EXTCREATEPEN,
    EmfRecordTypePolyTextOutA            = EMR_POLYTEXTOUTA,
    EmfRecordTypePolyTextOutW            = EMR_POLYTEXTOUTW,
    EmfRecordTypeSetICMMode              = 98,  // EMR_SETICMMODE,
    EmfRecordTypeCreateColorSpace        = 99,  // EMR_CREATECOLORSPACE,
    EmfRecordTypeSetColorSpace           = 100, // EMR_SETCOLORSPACE,
    EmfRecordTypeDeleteColorSpace        = 101, // EMR_DELETECOLORSPACE,
    EmfRecordTypeGLSRecord               = 102, // EMR_GLSRECORD,
    EmfRecordTypeGLSBoundedRecord        = 103, // EMR_GLSBOUNDEDRECORD,
    EmfRecordTypePixelFormat             = 104, // EMR_PIXELFORMAT,
    EmfRecordTypeDrawEscape              = 105, // EMR_RESERVED_105,
    EmfRecordTypeExtEscape               = 106, // EMR_RESERVED_106,
    EmfRecordTypeStartDoc                = 107, // EMR_RESERVED_107,
    EmfRecordTypeSmallTextOut            = 108, // EMR_RESERVED_108,
    EmfRecordTypeForceUFIMapping         = 109, // EMR_RESERVED_109,
    EmfRecordTypeNamedEscape             = 110, // EMR_RESERVED_110,
    EmfRecordTypeColorCorrectPalette     = 111, // EMR_COLORCORRECTPALETTE,
    EmfRecordTypeSetICMProfileA          = 112, // EMR_SETICMPROFILEA,
    EmfRecordTypeSetICMProfileW          = 113, // EMR_SETICMPROFILEW,
    EmfRecordTypeAlphaBlend              = 114, // EMR_ALPHABLEND,
    EmfRecordTypeSetLayout               = 115, // EMR_SETLAYOUT,
    EmfRecordTypeTransparentBlt          = 116, // EMR_TRANSPARENTBLT,
    EmfRecordTypeReserved_117            = 117, // Not Used
    EmfRecordTypeGradientFill            = 118, // EMR_GRADIENTFILL,
    EmfRecordTypeSetLinkedUFIs           = 119, // EMR_RESERVED_119,
    EmfRecordTypeSetTextJustification    = 120, // EMR_RESERVED_120,
    EmfRecordTypeColorMatchToTargetW     = 121, // EMR_COLORMATCHTOTARGETW,
    EmfRecordTypeCreateColorSpaceW       = 122, // EMR_CREATECOLOR