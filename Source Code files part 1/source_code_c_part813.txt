ctWnd );

    ZeroMemory( &lvColumn, 
               sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0
    //

    VERIFY( strTitle.LoadString( IDS_ENABLED_QUESTION ) );

    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.12 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_SettingsList.InsertColumn( 0, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_SettingsList.InsertColumn( 0, &lvColumn ) != -1 );
    }

    //
    // Column 1
    //

    VERIFY( strTitle.LoadString( IDS_SETTING ) );

    lvColumn.iSubItem = 1;
    lvColumn.cx = (int)( rectWnd.Width() * 0.85 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_SettingsList.InsertColumn( 1, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_SettingsList.InsertColumn( 1, &lvColumn ) != -1 );
    }
}

/////////////////////////////////////////////////////////////////////////////
VOID CFullListSettingsPage::FillTheList()
{
    //
    // N.B.
    //
    // If you change the first parameter (verifier bit index) 
    // then you need to change GetNewVerifierFlags as well
    //

    AddListItem( 0, IDS_SPECIAL_POOL );
    AddListItem( 1, IDS_POOL_TRACKING );
    AddListItem( 2, IDS_FORCE_IRQL_CHECKING );
    AddListItem( 3, IDS_IO_VERIFICATION );
    AddListItem( 4, IDS_ENH_IO_VERIFICATION );
    AddListItem( 5, IDS_DEADLOCK_DETECTION );
    AddListItem( 6, IDS_DMA_CHECHKING );
    AddListItem( 7, IDS_LOW_RESOURCE_SIMULATION );
    AddListItem( 8, IDS_DISK_INTEGRITY_CHECKING );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CFullListSettingsPage::GetNewVerifierFlags()
{
    //
    // N.B.
    //
    // If you change this order then you need to
    // change FillTheList as well
    //

    m_bSPool        = GetCheckFromItemData( 0 );
    m_bPoolTrack    = GetCheckFromItemData( 1 );
    m_bIrqLevel     = GetCheckFromItemData( 2 );
    m_bIoVerif      = GetCheckFromItemData( 3 );
    m_bEnhIoVerif   = GetCheckFromItemData( 4 );
    m_bDeadlock     = GetCheckFromItemData( 5 );
    m_bDMA          = GetCheckFromItemData( 6 );
    m_bLowRes       = GetCheckFromItemData( 7 );
    m_bDiskIntegrity= GetCheckFromItemData( 8 );

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CFullListSettingsPage::GetCheckFromItemData( INT nItemData )
{
    BOOL bChecked = FALSE;
    INT nItemIndex;
    LVFINDINFO FindInfo;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = nItemData;

    nItemIndex = m_SettingsList.FindItem( &FindInfo );

    if( nItemIndex >= 0 )
    {
        bChecked = m_SettingsList.GetCheck( nItemIndex );
    }

    return bChecked;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CFullListSettingsPage::GetBitNameFromItemData( LPARAM lParam,
                                                    TCHAR *szName,
                                                    ULONG uNameBufferLength )
{
    BOOL bSuccess = FALSE;
    INT nItemIndex;
    LVFINDINFO FindInfo;
    LVITEM lvItem;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam;

    nItemIndex = m_SettingsList.FindItem( &FindInfo );

    if( nItemIndex >= 0 )
    {
        //
        // Found it
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nItemIndex;
        lvItem.iSubItem = 1;
        lvItem.pszText = szName;
        lvItem.cchTextMax = uNameBufferLength;

        bSuccess = m_SettingsList.GetItem( &lvItem );
        
        if( FALSE == bSuccess )
        {
            //
            // Could not get the current item's attributes?!?
            //

            ASSERT( FALSE );
        }
    }

    return bSuccess;
}


/////////////////////////////////////////////////////////////////////////////
VOID CFullListSettingsPage::AddListItem( INT nItemData, 
                                         ULONG uIdResourceString )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strName;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - enabled/diabled - empty text and a checkbox
    //

    lvItem.pszText = g_szVoidText;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nItemData;
    lvItem.iItem = m_SettingsList.GetItemCount();

    nActualIndex = m_SettingsList.InsertItem( &lvItem );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    m_SettingsList.SetCheck( nActualIndex, FALSE );

    //
    // Sub-item 1 - feature name
    //

    VERIFY( strName.LoadString( uIdResourceString ) );

    lvItem.pszText = strName.GetBuffer( strName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;
    
    VERIFY( m_SettingsList.SetItem( &lvItem ) );

    strName.ReleaseBuffer();

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CFullListSettingsPage::SortTheList()
{
    if( 0 != m_nSortColumnIndex )
    {
        //
        // Sort by settings name
        //

        m_SettingsList.SortItems( StringCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by selected status
        //

        m_SettingsList.SortItems( CheckedStatusCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
int CALLBACK CFullListSettingsPage::StringCmpFunc( LPARAM lParam1,
                                                   LPARAM lParam2,
                                                   LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    TCHAR szBitName1[ _MAX_PATH ];
    TCHAR szBitName2[ _MAX_PATH ];

    CFullListSettingsPage *pThis = (CFullListSettingsPage *)lParamSort;
    ASSERT_VALID( pThis );

    ASSERT( 0 != pThis->m_nSortColumnIndex );

    //
    // Get the first name
    //

    bSuccess = pThis->GetBitNameFromItemData( lParam1, 
                                              szBitName1,
                                              ARRAY_LENGTH( szBitName1 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second name
    //

    bSuccess = pThis->GetBitNameFromItemData( lParam2, 
                                              szBitName2,
                                              ARRAY_LENGTH( szBitName2 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = _tcsicmp( szBitName1, szBitName2 );
    
    if( FALSE != pThis->m_bAscendSortName )
    {
        nCmpRez *= -1;
    }

Done:

    return nCmpRez;

}

/////////////////////////////////////////////////////////////
int CALLBACK CFullListSettingsPage::CheckedStatusCmpFunc( LPARAM lParam1,
                                                       LPARAM lParam2,
                                                       LPARAM lParamSort)
{
    int nCmpRez = 0;
    INT nItemIndex;
    BOOL bVerified1;
    BOOL bVerified2;
    LVFINDINFO FindInfo;

    CFullListSettingsPage *pThis = (CFullListSettingsPage *)lParamSort;
    ASSERT_VALID( pThis );

    ASSERT( 0 == pThis->m_nSortColumnIndex );

    //
    // Find the first item
    //

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam1;

    nItemIndex = pThis->m_SettingsList.FindItem( &FindInfo );

    if( nItemIndex < 0 )
    {
        ASSERT( FALSE );

        goto Done;
    }

    bVerified1 = pThis->m_SettingsList.GetCheck( nItemIndex );

    //
    // Find the second item
    //

    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam2;

    nItemIndex = pThis->m_SettingsList.FindItem( &FindInfo );

    if( nItemIndex < 0 )
    {
        ASSERT( FALSE );

        goto Done;
    }

    bVerified2 = pThis->m_SettingsList.GetCheck( nItemIndex );

    //
    // Compare them
    //
    
    if( bVerified1 != bVerified2 )
    {
        if( FALSE != bVerified1 )
        {
            nCmpRez = 1;
        }
        else
        {
            nCmpRez = -1;
        }

        if( FALSE != pThis->m_bAscendSortSelected )
        {
            nCmpRez *= -1;
        }
    }

Done:

    return nCmpRez;

}

/////////////////////////////////////////////////////////////////////////////
// CFullListSettingsPage message handlers

LRESULT CFullListSettingsPage::OnWizardNext() 
{
    LRESULT lNextPageId;
    BOOL bVerifyDrivers;

    //
    // Let's assume we cannot continue
    //

    lNextPageId = -1;

    if( GetNewVerifierFlags() == TRUE )
    {
        bVerifyDrivers = (  m_bIoVerif    ||
                            m_bIrqLevel   ||
                            m_bLowRes     ||
                            m_bPoolTrack  ||
                            m_bSPool      ||
                            m_bDeadlock   ||
                            m_bDMA        ||
                            m_bEnhIoVerif );

        if( FALSE == bVerifyDrivers &&
            FALSE == m_bDiskIntegrity )
        {
            //
            // No tests are currently selected - we cannot continue
            //

            VrfErrorResourceFormat( IDS_NO_TESTS_SELECTED );
        }
        else
        {
            //
            // Set our data according to the GUI
            //

            ASSERT( CSettingsBits::SettingsTypeCustom == 
                    g_NewVerifierSettings.m_SettingsBits.m_SettingsType );

            g_NewVerifierSettings.m_SettingsBits.m_bSpecialPoolEnabled    = m_bSPool;
            g_NewVerifierSettings.m_SettingsBits.m_bForceIrqlEnabled      = m_bIrqLevel;
            g_NewVerifierSettings.m_SettingsBits.m_bLowResEnabled         = m_bLowRes;
            g_NewVerifierSettings.m_SettingsBits.m_bPoolTrackingEnabled   = m_bPoolTrack;
            g_NewVerifierSettings.m_SettingsBits.m_bIoEnabled             = m_bIoVerif;
            g_NewVerifierSettings.m_SettingsBits.m_bDeadlockDetectEnabled = m_bDeadlock;
            g_NewVerifierSettings.m_SettingsBits.m_bDMAVerifEnabled       = m_bDMA;
            g_NewVerifierSettings.m_SettingsBits.m_bEnhIoEnabled          = m_bEnhIoVerif;

            g_bShowDiskPropertyPage = m_bDiskIntegrity;

            //
            // Go to the next page
            //

            if( FALSE != bVerifyDrivers )
            {
                //
                // We have at least one settings bit that is targetted on drivers.
                //

                lNextPageId = IDD_DRVSET_PAGE;
            }
            else
            {
                //
                // We don't have any drivers to select for verification. 
                // We have to select physical disks. 
                //

                lNextPageId = IDD_DISK_LIST_PAGE;
            }
        }
    }
	
    GoingToNextPageNotify( lNextPageId );

    return lNextPageId;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CFullListSettingsPage::OnInitDialog() 
{
	CVerifierPropertyPage::OnInitDialog();

    //
    // setup the list
    //

    m_SettingsList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES | m_SettingsList.GetExtendedStyle() );

    SetupListHeader();
    FillTheList();
	
    VrfSetWindowText( m_NextDescription, IDS_FLSETT_PAGE_NEXT_DESCR );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
BOOL CFullListSettingsPage::OnSetActive() 
{
    //
    // The wizard has at least one more step (select drivers)
    //

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                        PSWIZB_NEXT );

    return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CFullListSettingsPage::OnWizardBack() 
{
    g_bShowDiskPropertyPage = FALSE;
	
	return CVerifierPropertyPage::OnWizardBack();
}

/////////////////////////////////////////////////////////////////////////////
void CFullListSettingsPage::OnColumnclickFlsettList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortName = !m_bAscendSortName;
        }
    }
    else
    {
        //
        // Clicked on the selected status column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortSelected = !m_bAscendSortSelected;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
LONG CFullListSettingsPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CFullListSettingsPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\flpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: FLPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_FLPAGE_H__3D3D85C5_AC1B_4D20_8FF1_1D2EE9908ACC__INCLUDED_)
#define AFX_FLPAGE_H__3D3D85C5_AC1B_4D20_8FF1_1D2EE9908ACC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FLPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CFullListSettingsPage dialog

class CFullListSettingsPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CFullListSettingsPage)

public:
    //
    // Construction
    //

	CFullListSettingsPage();
	~CFullListSettingsPage();

    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

    VOID SetupListHeader();
    VOID FillTheList();
    VOID AddListItem( INT nItemData, 
                      ULONG uIdResourceString );

    BOOL GetNewVerifierFlags();
    BOOL GetCheckFromItemData( INT nItemData );
    BOOL GetBitNameFromItemData( LPARAM lParam,
                                 TCHAR *szName,
                                 ULONG uNameBufferLength );

    VOID SortTheList();

    static int CALLBACK StringCmpFunc( LPARAM lParam1,
                                       LPARAM lParam2,
                                       LPARAM lParamSort);

    static int CALLBACK CheckedStatusCmpFunc( LPARAM lParam1,
                                              LPARAM lParam2,
                                              LPARAM lParamSort);

protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    INT m_nSortColumnIndex;        // selected status (0) or settings name (1)
    BOOL m_bAscendSortSelected;    // sort ascendent the selected status
    BOOL m_bAscendSortName;        // sort ascendent the settings name

    //
    // Dialog Data
    //

    BOOL m_bSPool;
    BOOL m_bPoolTrack;
    BOOL m_bIrqLevel;
    BOOL m_bIoVerif;
    BOOL m_bEnhIoVerif;
    BOOL m_bDeadlock;
    BOOL m_bDMA;
    BOOL m_bLowRes;
    BOOL m_bDiskIntegrity;

    //{{AFX_DATA(CFullListSettingsPage)
	enum { IDD = IDD_FULL_LIST_SETT_PAGE };
	CListCtrl	m_SettingsList;
	CStatic	m_NextDescription;
	//}}AFX_DATA


    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generated virtual function overrides
    //

    //{{AFX_VIRTUAL(CFullListSettingsPage)
    public:
    virtual LRESULT OnWizardNext();
    virtual LRESULT OnWizardBack();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CFullListSettingsPage)
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    afx_msg void OnColumnclickFlsettList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FLPAGE_H__3D3D85C5_AC1B_4D20_8FF1_1D2EE9908ACC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\helpids.h ===
// Driver Verifier "Select a Task" screen

#define	IDH_DV_Settings_standard		800100
#define	IDH_DV_Settings_custom			800105
#define	IDH_DV_Settings_deleteexisting		800110
#define	IDH_DV_Settings_displayexisting		800115
#define	IDH_DV_Settings_displaycurrent		800120

// Driver Verifier "Select what driver to verify" screen

#define	IDH_DV_SelectUnsigned			800125
#define	IDH_DV_SelectOlderversions		800130
#define	IDH_DV_SelectAll			800135
#define	IDH_DV_SelectFromList			800140

// Driver Verifier "The list of unsigned drivers chosen to be verified" screen

#define	IDH_DV_UnsignedDriversList		800150

// Driver Verifier "Create custom settings" screen

#define	IDH_DV_EnablePredefined			800155
#define	IDH_DV_Standard				800160
#define	IDH_DV_DiskCheck				800162
#define	IDH_DV_Rigorous				800165
#define	IDH_DV_LowResource			800170
#define	IDH_DV_IndividualSettings		800175

// Driver Verifier "Select drivers to verify" screen

#define	IDH_DV_SelectDriversToVerify		800180
#define	IDH_DV_Addbut_UnloadedDrivers		800185

// Driver Verifier "Settings and verified drivers" screen

#define	IDH_DV_SettingsEnabled_TestType		800190
#define	IDH_DV_VerifyAllDrivers_NameDesc	800195

// Driver Verifier "Select individual settings from this full list" screen

#define	IDH_DV_SettingsEnabled_TestType_FullList		800198

// Driver Verifier "Current settings and verified drivers (run time info)" screen

#define	IDH_DV_CurrentSettings			800200
#define	IDH_DV_CurrentVerifiedDrivers		800205
#define	IDH_DV_Changebut			800210
#define	IDH_DV_Addbut				800215
#define	IDH_DV_Removebut			800220

// Driver Verifier "Global counters" screen

#define	IDH_DV_GlobalCounters			800225

// Driver Verifier "Counters specific to each of the currently verified drivers" screen

#define	IDH_DV_Counters_DriverList		800230
#define	IDH_DV_DriverCounters			800235

// Driver Verifier "Select physical disks from this full list" screen

#define	IDH_DV_DisksEnabled_Disk_FullList 800240
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\gcntpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: GCntPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "GCntPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Timer ID
//

#define REFRESH_TIMER_ID    0x1234

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_GLOBC_LIST,                 IDH_DV_GlobalCounters,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CGlobalCountPage property page

IMPLEMENT_DYNCREATE(CGlobalCountPage, CVerifierPropertyPage)

CGlobalCountPage::CGlobalCountPage() : CVerifierPropertyPage(CGlobalCountPage::IDD)
{
	//{{AFX_DATA_INIT(CGlobalCountPage)
	//}}AFX_DATA_INIT

    m_nSortColumnIndex = 0;
    m_bAscendSortName = FALSE;
    m_bAscendSortValue = FALSE;

    m_uTimerHandler = 0;

    m_pParentSheet = NULL;
}

CGlobalCountPage::~CGlobalCountPage()
{
}

void CGlobalCountPage::DoDataExchange(CDataExchange* pDX)
{
    static BOOL bShownPoolCoverageWarning = FALSE;

    if( ! pDX->m_bSaveAndValidate )
    {
        //
        // Query the kernel
        //

        VrfGetRuntimeVerifierData( &m_RuntimeVerifierData );

        if( FALSE == bShownPoolCoverageWarning )
        {
            bShownPoolCoverageWarning = CheckAndShowPoolCoverageWarning();
        }
    }

    CVerifierPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGlobalCountPage)
    DDX_Control(pDX, IDC_GLOBC_LIST, m_CountersList);
    DDX_Control(pDX, IDC_GLOBC_NEXT_DESCR_STATIC, m_NextDescription);
    //}}AFX_DATA_MAP
}



BEGIN_MESSAGE_MAP(CGlobalCountPage, CVerifierPropertyPage)
    //{{AFX_MSG_MAP(CGlobalCountPage)
    ON_WM_TIMER()
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_GLOBC_LIST, OnColumnclickGlobcList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////

VOID CGlobalCountPage::SetupListHeader()
{
    LVCOLUMN lvColumn;
    CRect rectWnd;
    CString strCounter, strValue;
    
    VERIFY( strCounter.LoadString( IDS_COUNTER ) );
    VERIFY( strValue.LoadString( IDS_VALUE ) );

    //
    // List's regtangle
    //

    m_CountersList.GetClientRect( &rectWnd );
    
    //
    // Column 0 - counter
    //

    ZeroMemory( &lvColumn, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.50 );
    lvColumn.pszText = strCounter.GetBuffer( strCounter.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_CountersList.InsertColumn( 0, &lvColumn ) != -1 );
        strCounter.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_CountersList.InsertColumn( 0, &lvColumn ) != -1 );
    }

    //
    // Column 1
    //

    lvColumn.iSubItem = 1;
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    lvColumn.pszText = strValue.GetBuffer( strValue.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_CountersList.InsertColumn( 1, &lvColumn ) != -1 );
        strValue.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_CountersList.InsertColumn( 1, &lvColumn ) != -1 );
    }
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::FillTheList()
{
    //
    // N.B.
    //
    // If you change the first parameter (index - stored in the item's data) 
    // you need to change the switch statement in GetCounterValue as well
    //

    AddCounterInList( 0, IDS_ALLOCATIONSATTEMPTED_LIST,   m_RuntimeVerifierData.AllocationsAttempted );
    AddCounterInList( 1, IDS_ALLOCATIONSSUCCEEDED_LIST,   m_RuntimeVerifierData.AllocationsSucceeded );
    AddCounterInList( 2, IDS_ALLOCATIONSSUCCEEDEDSPECIALPOOL_LIST,    m_RuntimeVerifierData.AllocationsSucceededSpecialPool );
    AddCounterInList( 3, IDS_ALLOCATIONSWITHNOTAG_LIST,   m_RuntimeVerifierData.AllocationsWithNoTag );
    AddCounterInList( 4, IDS_UNTRACKEDPOOL_LIST,          m_RuntimeVerifierData.UnTrackedPool );
    AddCounterInList( 5, IDS_ALLOCATIONSFAILED_LIST,      m_RuntimeVerifierData.AllocationsFailed );
    AddCounterInList( 6, IDS_ALLOCATIONSFAILEDDELIBERATELY_LIST,      m_RuntimeVerifierData.AllocationsFailedDeliberately );
    AddCounterInList( 7, IDS_RAISEIRQLS_LIST,             m_RuntimeVerifierData.RaiseIrqls );
    AddCounterInList( 8, IDS_ACQUIRESPINLOCKS_LIST,       m_RuntimeVerifierData.AcquireSpinLocks );
    AddCounterInList( 9, IDS_SYNCHRONIZEEXECUTIONS_LIST,  m_RuntimeVerifierData.SynchronizeExecutions );
    AddCounterInList( 10, IDS_TRIMS_LIST,                 m_RuntimeVerifierData.Trims );
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::RefreshTheList()
{
    INT nListItems;
    INT nCrtListItem;
    INT_PTR nCrtCounterIndex;
    SIZE_T sizeValue;
 
    nListItems = m_CountersList.GetItemCount();

    for( nCrtListItem = 0; nCrtListItem < nListItems; nCrtListItem += 1 )
    {
        nCrtCounterIndex = m_CountersList.GetItemData( nCrtListItem );

        sizeValue = GetCounterValue( nCrtCounterIndex );

        UpdateCounterValueInList( nCrtListItem, sizeValue );
    }
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::SortTheList()
{
    if( 0 != m_nSortColumnIndex )
    {
        //
        // Sort by counter value - this is probably not very useful
        // but we are providing it to be consistent with all
        // the lists being sortable by any column
        //

        m_CountersList.SortItems( CounterValueCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by driver name
        //

        m_CountersList.SortItems( CounterNameCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
SIZE_T CGlobalCountPage::GetCounterValue( INT_PTR nCounterIndex )
{
    SIZE_T sizeValue;

    //
    // N.B. 
    //
    // If you change this switch statement you need to change FillTheList as well
    //

    switch( nCounterIndex )
    {
    case 0:
        sizeValue = m_RuntimeVerifierData.AllocationsAttempted;
        break;

    case 1:
        sizeValue = m_RuntimeVerifierData.AllocationsSucceeded;
        break;

    case 2:
        sizeValue = m_RuntimeVerifierData.AllocationsSucceededSpecialPool;
        break;

    case 3:
        sizeValue = m_RuntimeVerifierData.AllocationsWithNoTag;
        break;

    case 4:
        sizeValue = m_RuntimeVerifierData.UnTrackedPool;
        break;

    case 5:
        sizeValue = m_RuntimeVerifierData.AllocationsFailed;
        break;

    case 6:
        sizeValue = m_RuntimeVerifierData.AllocationsFailedDeliberately;
        break;

    case 7:
        sizeValue = m_RuntimeVerifierData.RaiseIrqls;
        break;

    case 8:
        sizeValue = m_RuntimeVerifierData.AcquireSpinLocks;
        break;

    case 9:
        sizeValue = m_RuntimeVerifierData.SynchronizeExecutions;
        break;

    case 10:
        sizeValue = m_RuntimeVerifierData.Trims;
        break;

    default:
        //
        // Oops, how did we get here ?!?
        //

        ASSERT( FALSE );

        sizeValue = 0;

        break;
    }

    return sizeValue;
}

/////////////////////////////////////////////////////////////
BOOL CGlobalCountPage::GetCounterName( LPARAM lItemData, 
                                       TCHAR *szCounterName,
                                       ULONG uCounterNameBufferLen )
{
    INT nItemIndex;
    BOOL bResult;
    LVFINDINFO FindInfo;
    LVITEM lvItem;

    bResult = FALSE;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lItemData;

    nItemIndex = m_CountersList.FindItem( &FindInfo );

    if( nItemIndex < 0 || nItemIndex > 10 )
    {
        ASSERT( FALSE );
    }
    else
    {
        //
        // Found our item - get the name
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nItemIndex;
        lvItem.iSubItem = 0;
        lvItem.pszText = szCounterName;
        lvItem.cchTextMax = uCounterNameBufferLen;

        bResult = m_CountersList.GetItem( &lvItem );
        
        if( bResult == FALSE )
        {
            //
            // Could not get the current item's attributes?!?
            //

            ASSERT( FALSE );
        }
    }

    return bResult;
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::AddCounterInList( INT nItemData, 
                                         ULONG  uIdResourceString,
                                         SIZE_T sizeValue )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strName;

    VERIFY( strName.LoadString( uIdResourceString ) );

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - counter's name
    //

    lvItem.pszText = strName.GetBuffer( strName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nItemData;
    lvItem.iItem = m_CountersList.GetItemCount();

    nActualIndex = m_CountersList.InsertItem( &lvItem );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    //
    // Sub-item 1 - counter's value
    //
    
    UpdateCounterValueInList( nActualIndex,
                              sizeValue );

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::RefreshInfo() 
{
    if( UpdateData( FALSE ) )
    {
        //
        // Refresh the settings bits list
        //

        RefreshTheList();
    }
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::UpdateCounterValueInList( INT nItemIndex,
                                                 SIZE_T sizeValue )
{
    TCHAR szValue[ 32 ];
    LVITEM lvItem;

#ifndef _WIN64

    //
    // 32 bit SIZE_T
    //

    _sntprintf( szValue,
                ARRAY_LENGTH( szValue ),
                _T( "%u" ),
                sizeValue );

#else

    //
    // 64 bit SIZE_T
    //

    _sntprintf( szValue,
                ARRAY_LENGTH( szValue ),
                _T( "%I64u" ),
                sizeValue );

#endif

    szValue[ ARRAY_LENGTH( szValue ) - 1 ] = 0;

    //
    // Update the list item
    //

    ZeroMemory( &lvItem, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = szValue;
    VERIFY( m_CountersList.SetItem( &lvItem ) );
}


/////////////////////////////////////////////////////////////
//
// Other methods
//

/////////////////////////////////////////////////////////////
#define MIN_MEM_SIZE_TO_DISABLE_WARNING 0x80000000  // 2 Gb
#define MIN_ALLOCATIONS_SIGNIFICANT     100
#define MIN_PERCENTAGE_AVOID_WARNING    95

BOOL CGlobalCountPage::CheckAndShowPoolCoverageWarning()
{
    BOOL bWarningDisplayed;
    ULONGLONG ullPercentageCoverage;
    TCHAR *szMessage;
    CString strMsgFormat;
    CString strWarnMsg;

    bWarningDisplayed = FALSE;

    if( m_RuntimeVerifierData.m_bSpecialPool &&
        m_RuntimeVerifierData.AllocationsSucceeded >= MIN_ALLOCATIONS_SIGNIFICANT  )
    {
        // 
        // Special pool verification is enabled &&
        // There is a significant number of allocations
        //

        ASSERT( m_RuntimeVerifierData.AllocationsSucceeded >= m_RuntimeVerifierData.AllocationsSucceededSpecialPool );

        //
        // The coverage percentage
        //

        ullPercentageCoverage = 
            ( (ULONGLONG)m_RuntimeVerifierData.AllocationsSucceededSpecialPool * (ULONGLONG) 100 ) / 
              (ULONGLONG)m_RuntimeVerifierData.AllocationsSucceeded;

        ASSERT( ullPercentageCoverage <= 100 );

        if( ullPercentageCoverage < MIN_PERCENTAGE_AVOID_WARNING )
        {
            //
            // Warn the user
            //

            if( strMsgFormat.LoadString( IDS_COVERAGE_WARNING_FORMAT ) )
            {
                szMessage = strWarnMsg.GetBuffer( strMsgFormat.GetLength() + 32 );

                if( szMessage != NULL )
                {
                    _stprintf( szMessage, (LPCTSTR)strMsgFormat, ullPercentageCoverage );
                    strWarnMsg.ReleaseBuffer();

                    AfxMessageBox( strWarnMsg,
                                   MB_OK | MB_ICONINFORMATION );
                }
            }
            else
            {
                ASSERT( FALSE );
            }

            bWarningDisplayed = TRUE;
        }
    }

    return bWarningDisplayed;
}

/////////////////////////////////////////////////////////////
int CALLBACK CGlobalCountPage::CounterValueCmpFunc( LPARAM lParam1,
                                                    LPARAM lParam2,
                                                    LPARAM lParamSort)
{
    SIZE_T size1;
    SIZE_T size2;
    int nCmpRez = 0;

    CGlobalCountPage *pThis = (CGlobalCountPage *)lParamSort;
    ASSERT_VALID( pThis );

    size1 = pThis->GetCounterValue( (INT) lParam1 );
    size2 = pThis->GetCounterValue( (INT) lParam2 );

    if( size1 > size2 )
    {
        nCmpRez = 1;
    }
    else
    {
        if( size1 < size2 )
        {
            nCmpRez = -1;
        }
    }

    if( FALSE != pThis->m_bAscendSortValue )
    {
        nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
int CALLBACK CGlobalCountPage::CounterNameCmpFunc( LPARAM lParam1,
                                                   LPARAM lParam2,
                                                   LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    TCHAR szCounterName1[ _MAX_PATH ];
    TCHAR szCounterName2[ _MAX_PATH ];

    CGlobalCountPage *pThis = (CGlobalCountPage *)lParamSort;
    ASSERT_VALID( pThis );

    //
    // Get the first counter name
    //

    bSuccess = pThis->GetCounterName( lParam1, 
                                      szCounterName1,
                                      ARRAY_LENGTH( szCounterName1 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second counter name
    //

    bSuccess = pThis->GetCounterName( lParam2, 
                                      szCounterName2,
                                      ARRAY_LENGTH( szCounterName2 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = _tcsicmp( szCounterName1, szCounterName2 );
    
    if( FALSE != pThis->m_bAscendSortName )
    {
        nCmpRez *= -1;
    }

Done:

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
// CGlobalCountPage message handlers

BOOL CGlobalCountPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    //
    // Setup the settings bits list
    //

    m_CountersList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_CountersList.GetExtendedStyle() );

    m_CountersList.SetBkColor( ::GetSysColor( COLOR_3DFACE ) );
    m_CountersList.SetTextBkColor( ::GetSysColor( COLOR_3DFACE ) );

    SetupListHeader();
    FillTheList();
    SortTheList();

    VrfSetWindowText( m_NextDescription, IDS_GCNT_PAGE_NEXT_DESCR );

    VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID, 
                                        5000,
                                        NULL ) );

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::OnTimer(UINT nIDEvent) 
{
    if( nIDEvent == REFRESH_TIMER_ID )
    {
        ASSERT_VALID( m_pParentSheet );

        if( m_pParentSheet->GetActivePage() == this )
        {
            //
            // Refresh the displayed data 
            //

            RefreshInfo();
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CGlobalCountPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                        PSWIZB_NEXT );
    	
	return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CGlobalCountPage::OnWizardNext() 
{
    GoingToNextPageNotify( IDD_PERDRIVER_COUNTERS_PAGE );

	return IDD_PERDRIVER_COUNTERS_PAGE;
}

/////////////////////////////////////////////////////////////////////////////
void CGlobalCountPage::OnColumnclickGlobcList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the counter value column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortValue = !m_bAscendSortValue;
        }
    }
    else
    {
        //
        // Clicked on the counter name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortName = !m_bAscendSortName;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
LONG CGlobalCountPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CGlobalCountPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\progctrl.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: ProgCtrl.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_PROGCTRL_H__3F75E128_8721_4421_B96B_9961A9A3C5B0__INCLUDED_)
#define AFX_PROGCTRL_H__3F75E128_8721_4421_B96B_9961A9A3C5B0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ProgCtrl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CVrfProgressCtrl window

class CVrfProgressCtrl : public CProgressCtrl
{
// Construction
public:
	CVrfProgressCtrl();

// Attributes
public:

// Operations
public:
    void SetRange32( INT_PTR nLower, INT_PTR nUpper )
    {
        ASSERT( ::IsWindow( m_hWnd ) );
        ::PostMessage( m_hWnd, PBM_SETRANGE32, (WPARAM) nLower, (LPARAM) nUpper);
    }

    int SetStep( INT_PTR nStep )
    {
        ASSERT(::IsWindow( m_hWnd) ); 
        return (int) ::PostMessage( m_hWnd, PBM_SETSTEP, nStep, 0L);
    }

    int SetPos(INT_PTR nPos)
    {
        ASSERT( ::IsWindow( m_hWnd ) );
        return (int) ::PostMessage(m_hWnd, PBM_SETPOS, nPos, 0L); 
    }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVrfProgressCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CVrfProgressCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CVrfProgressCtrl)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROGCTRL_H__3F75E128_8721_4421_B96B_9961A9A3C5B0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\progctrl.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: ProgCtrl.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"
#include "ProgCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVrfProgressCtrl

CVrfProgressCtrl::CVrfProgressCtrl()
{
}

CVrfProgressCtrl::~CVrfProgressCtrl()
{
}


BEGIN_MESSAGE_MAP(CVrfProgressCtrl, CProgressCtrl)
	//{{AFX_MSG_MAP(CVrfProgressCtrl)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVrfProgressCtrl message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\regpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: RegPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "RegPage.h"
#include "VGlobal.h"
#include "VrfUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_REGSETT_SETTBITS_LIST,      IDH_DV_SettingsEnabled_TestType,
    IDC_REGSETT_DRIVERS_LIST,       IDH_DV_VerifyAllDrivers_NameDesc,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CCrtRegSettingsPage property page

IMPLEMENT_DYNCREATE(CCrtRegSettingsPage, CVerifierPropertyPage)

CCrtRegSettingsPage::CCrtRegSettingsPage() 
    : CVerifierPropertyPage(CCrtRegSettingsPage::IDD)
{
	//{{AFX_DATA_INIT(CCrtRegSettingsPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    //
    // Driver list sort parameters
    //

    m_nSortColumnIndexDrv = 0;
    m_bAscendDrvNameSort = FALSE;
    m_bAscendDrvDescrSort = FALSE;

    //
    // Settings bits sort parameters
    //

    m_nSortColumnIndexSettbits = 1;
    m_bAscendSortEnabledBits = FALSE;
    m_bAscendSortNameBits = FALSE;

    m_pParentSheet = NULL;
}

CCrtRegSettingsPage::~CCrtRegSettingsPage()
{
}

void CCrtRegSettingsPage::DoDataExchange(CDataExchange* pDX)
{
    CVerifierPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CCrtRegSettingsPage)
    DDX_Control(pDX, IDC_REGSETT_VERIFIED_DRV_STATIC, m_VerifiedDrvStatic);
    DDX_Control(pDX, IDC_REGSETT_NEXT_DESCR_STATIC, m_NextDescription);
    DDX_Control(pDX, IDC_REGSETT_SETTBITS_LIST, m_SettBitsList);
    DDX_Control(pDX, IDC_REGSETT_DRIVERS_LIST, m_DriversList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCrtRegSettingsPage, CVerifierPropertyPage)
    //{{AFX_MSG_MAP(CCrtRegSettingsPage)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_REGSETT_DRIVERS_LIST, OnColumnclickDriversList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_REGSETT_SETTBITS_LIST, OnColumnclickRegsettSettbitsList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////
//
// Driver status list control methods
//

VOID CCrtRegSettingsPage::SetupListHeaderDrivers()
{
    LVCOLUMN lvColumn;
    CRect rectWnd;
    CString strName;
    CString strDescription;

    VERIFY( strName.LoadString( IDS_NAME ) );
    VERIFY( strDescription.LoadString( IDS_DESCRIPTION ) );

    //
    // List's regtangle
    //

    m_DriversList.GetClientRect( &rectWnd );
    
    //
    // Column 0
    //

    ZeroMemory( &lvColumn, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.30 );
    lvColumn.pszText = strName.GetBuffer( strName.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
        strName.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    }

    //
    // Column 1
    //

    lvColumn.iSubItem = 1;
    lvColumn.cx = (int)( rectWnd.Width() * 0.70 );
    lvColumn.pszText = strDescription.GetBuffer( strDescription.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
        strDescription.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    }
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::FillTheListDrivers()
{
    LVITEM lvItem;
    int nActualIndex; 
    BOOL *pbAlreadyInList;
    int nItemCount;
    int nCrtListItem;
    INT_PTR nCrtVerifiedDriver;
    INT_PTR nDriversNo;
    TCHAR szDriverName[ _MAX_PATH ];
    BOOL bResult;
    CString strText;

    if( g_bAllDriversVerified )
    {
        VERIFY( m_DriversList.DeleteAllItems() );
        goto Done;
    }

    //
    // The number of drivers marked to be verified in the registry
    //

    nDriversNo = g_astrVerifyDriverNamesRegistry.GetSize();

    if( nDriversNo == 0 )
    {
        //
        // Clear the list
        //

        VERIFY( m_DriversList.DeleteAllItems() );
        goto Done;
    }

    //
    // There are some drivers marked to be verified in the registry
    //

    pbAlreadyInList = new BOOL[ nDriversNo ];
    
    if( pbAlreadyInList == NULL )
    {
        goto Done;
    }
    
    for( nCrtVerifiedDriver = 0; nCrtVerifiedDriver < nDriversNo; nCrtVerifiedDriver++)
    {
        pbAlreadyInList[ nCrtVerifiedDriver ] = FALSE;
    }

    //
    // Parse all the current list items
    //

    nItemCount = m_DriversList.GetItemCount();

    for( nCrtListItem = 0; nCrtListItem < nItemCount; nCrtListItem++ )
    {
        //
        // Get the current driver's name from the list
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nCrtListItem;
        lvItem.iSubItem = 0;
        lvItem.pszText = szDriverName;
        lvItem.cchTextMax = ARRAY_LENGTH( szDriverName );

        bResult = m_DriversList.GetItem( &lvItem );
        
        if( bResult == FALSE )
        {
            //
            // Could not get the current item's attributes?!?
            //

            ASSERT( FALSE );

            //
            // Remove this item from the list
            //

            VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

            nCrtListItem -= 1;
            nItemCount -= 1;
        }
        else
        {
            //
            // See is the current driver is still in g_astrVerifyDriverNamesRegistry
            //

            for( nCrtVerifiedDriver = 0; nCrtVerifiedDriver < nDriversNo; nCrtVerifiedDriver++)
            {
                if( g_astrVerifyDriverNamesRegistry.GetAt( nCrtVerifiedDriver ).CompareNoCase( szDriverName ) == 0 )
                {
                    //
                    // update the item's data with the current index in the array
                    //

                    lvItem.mask = LVIF_PARAM;
                    lvItem.lParam = nCrtVerifiedDriver;
                    
                    VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );

                    //
                    // update the second column
                    //

                    UpdateDescriptionColumnDrivers( nCrtListItem, nCrtVerifiedDriver ); 

                    //
                    // mark the current driver as updated
                    //

                    pbAlreadyInList[ nCrtVerifiedDriver ] = TRUE;

                    break;
                }
            }

            //
            // If the driver is no longer verified, remove it from the list
            //

            if( nCrtVerifiedDriver >= nDriversNo )
            {
                VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                nCrtListItem -= 1;
                nItemCount -= 1;
            }
        }
    }

    //
    // Add the drivers that were not in the list before this update
    //

    for( nCrtVerifiedDriver = 0; nCrtVerifiedDriver < nDriversNo; nCrtVerifiedDriver++)
    {
        if( ! pbAlreadyInList[ nCrtVerifiedDriver ] )
        {
            // 
            // add a new item for this
            //

            ZeroMemory( &lvItem, sizeof( lvItem ) );

            //
            // sub-item 0
            //

            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.lParam = nCrtVerifiedDriver;
            lvItem.iItem = m_DriversList.GetItemCount();
            lvItem.iSubItem = 0;
            
            strText = g_astrVerifyDriverNamesRegistry.GetAt( nCrtVerifiedDriver );
            
            lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );

            if( NULL != lvItem.pszText  )
            {
                nActualIndex = m_DriversList.InsertItem( &lvItem );
                
                VERIFY( nActualIndex != -1 );

                strText.ReleaseBuffer();

                //
                // sub-item 1
                //

                UpdateDescriptionColumnDrivers( nActualIndex, nCrtVerifiedDriver ); 
            }
        }
    }

    ASSERT( NULL != pbAlreadyInList );
    delete [] pbAlreadyInList;

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::UpdateDescriptionColumnDrivers( INT_PTR nItemIndex, INT_PTR nCrtDriver )
{
    INT_PTR nInstalledDrivers;
    INT_PTR nCrtInstalledDriver;
    INT_PTR nNewDriverDataIndex;
    LVITEM lvItem;
    CString strDescription;
    CString strCrtDriverName;
    CDriverData *pCrtDriverData;
    CDriverDataArray &DriverDataArray = g_NewVerifierSettings.m_DriversSet.m_aDriverData;

    ASSERT( nItemIndex >= 0 && 
            nItemIndex < g_astrVerifyDriverNamesRegistry.GetSize() &&
            nItemIndex < m_DriversList.GetItemCount() &&
            nCrtDriver >= 0 &&
            nCrtDriver < g_astrVerifyDriverNamesRegistry.GetSize() &&
            nCrtDriver < m_DriversList.GetItemCount() );

    strCrtDriverName = g_astrVerifyDriverNamesRegistry.GetAt( nCrtDriver );

    ASSERT( strCrtDriverName.GetLength() > 0 );

    //
    // Search for this driver name in our g_NewVerifierSettings to get
    // the description
    //
    
    nInstalledDrivers = g_NewVerifierSettings.m_DriversSet.m_aDriverData.GetSize();

    for( nCrtInstalledDriver = 0; nCrtInstalledDriver < nInstalledDrivers; nCrtInstalledDriver += 1 )
    {
        pCrtDriverData = DriverDataArray.GetAt( nCrtInstalledDriver );

        ASSERT_VALID( pCrtDriverData );

        if( strCrtDriverName.CompareNoCase( pCrtDriverData->m_strName ) == 0 )
        {
            //
            // Found the driver version information
            //

            strDescription = pCrtDriverData->m_strFileDescription;

            break;
        }
    }

    if( nCrtInstalledDriver >= nInstalledDrivers )
    {
        //
        // Don't have already version information for this driver.
        // It may be one of the drivers that's not currently loaded so
        // try to get the version info.
        //

        nNewDriverDataIndex = g_NewVerifierSettings.m_DriversSet.AddNewDriverData( strCrtDriverName );

        if( nNewDriverDataIndex >= 0 )
        {
            //
            // Force refreshing the unsigned driver data 
            //

            g_NewVerifierSettings.m_DriversSet.m_bUnsignedDriverDataInitialized = FALSE;

            //
            // Get the version information
            //

            pCrtDriverData = DriverDataArray.GetAt( nNewDriverDataIndex );

            ASSERT_VALID( pCrtDriverData );
            ASSERT( strCrtDriverName.CompareNoCase( pCrtDriverData->m_strName ) == 0 );

            strDescription = pCrtDriverData->m_strFileDescription;
        }
    }

    if( strDescription.GetLength() == 0 )
    {
        //
        // Didn't find the version info for this driver
        //

        VERIFY( strDescription.LoadString( IDS_UNKNOWN ) );
    }

    //
    // Update the list item
    //

    ZeroMemory( &lvItem, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = (INT)nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = strDescription.GetBuffer( strDescription.GetLength() + 1 );

    if (NULL != lvItem.pszText)
    {
        VERIFY( m_DriversList.SetItem( &lvItem ) );
        strDescription.ReleaseBuffer();
    }
    else
    {
        lvItem.pszText = g_szVoidText;
        VERIFY( m_DriversList.SetItem( &lvItem ) );
    }
}

/////////////////////////////////////////////////////////////
int CALLBACK CCrtRegSettingsPage::DrvStringCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    CCrtRegSettingsPage *pThis = (CCrtRegSettingsPage *)lParamSort;
    ASSERT_VALID( pThis );

    return pThis->ListStrCmpFunc( lParam1,
                                  lParam2,
                                  pThis->m_DriversList,
                                  pThis->m_nSortColumnIndexDrv,
                                  (0 == pThis->m_nSortColumnIndexDrv) ? 
                                        pThis->m_bAscendDrvNameSort : pThis->m_bAscendDrvDescrSort );
}

/////////////////////////////////////////////////////////////
int CALLBACK CCrtRegSettingsPage::SettbitsStringCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    CCrtRegSettingsPage *pThis = (CCrtRegSettingsPage *)lParamSort;
    ASSERT_VALID( pThis );

    return pThis->ListStrCmpFunc( lParam1,
                                  lParam2,
                                  pThis->m_SettBitsList,
                                  pThis->m_nSortColumnIndexSettbits,
                                  (0 == pThis->m_nSortColumnIndexSettbits) ? 
                                        pThis->m_bAscendSortEnabledBits : pThis->m_bAscendSortNameBits );
}

/////////////////////////////////////////////////////////////
int CCrtRegSettingsPage::ListStrCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    CListCtrl &theList,
    INT nSortColumnIndex,
    BOOL bAscending )
{
    int nCmpRez = 0;
    BOOL bSuccess;
    TCHAR szName1[ _MAX_PATH ];
    TCHAR szName2[ _MAX_PATH ];

    //
    // Get the first name
    //

    bSuccess = GetNameFromItemData( theList,
                                    nSortColumnIndex,
                                    lParam1,
                                    szName1,
                                    ARRAY_LENGTH( szName1 ) );

    if( FALSE == bSuccess )
    {
        ASSERT( FALSE );

        goto Done;
    }

    //
    // Get the second name
    //

    bSuccess = GetNameFromItemData( theList,
                                    nSortColumnIndex,
                                    lParam2,
                                    szName2,
                                    ARRAY_LENGTH( szName2 ) );

    if( FALSE == bSuccess )
    {
        ASSERT( FALSE );

        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = _tcsicmp( szName1, szName2 );

    if( FALSE != bAscending )
    {
        nCmpRez *= -1;
    }

Done:

    return nCmpRez;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CCrtRegSettingsPage::GetNameFromItemData( CListCtrl &theList,
                                               INT nColumnIndex,
                                               LPARAM lParam,
                                               TCHAR *szName,
                                               ULONG uNameBufferLength )
{
    BOOL bSuccess = FALSE;
    INT nItemIndex;
    LVFINDINFO FindInfo;
    LVITEM lvItem;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam;

    nItemIndex = theList.FindItem( &FindInfo );

    if( nItemIndex >= 0 )
    {
        //
        // Found it
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nItemIndex;
        lvItem.iSubItem = nColumnIndex;
        lvItem.pszText = szName;
        lvItem.cchTextMax = uNameBufferLength;

        bSuccess = theList.GetItem( &lvItem );
        
        if( FALSE == bSuccess )
        {
            //
            // Could not get the current item's attributes?!?
            //

            ASSERT( FALSE );
        }
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////
//
// Settings bits list control methods
//

VOID CCrtRegSettingsPage::SetupListHeaderDriversSettBits()
{
    CString strTitle;
    CRect rectWnd;
    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_SettBitsList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
               sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0
    //

    VERIFY( strTitle.LoadString( IDS_ENABLED_QUESTION ) );

    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.25 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_SettBitsList.InsertColumn( 0, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_SettBitsList.InsertColumn( 0, &lvColumn ) != -1 );
    }

    //
    // Column 1
    //

    VERIFY( strTitle.LoadString( IDS_SETTING ) );

    lvColumn.iSubItem = 1;
    lvColumn.cx = (int)( rectWnd.Width() * 0.75 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_SettBitsList.InsertColumn( 1, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else 
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_SettBitsList.InsertColumn( 1, &lvColumn ) != -1 );
    }
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::FillTheListSettBits()
{
    //
    // N.B. 
    //
    // If you change this order you need to change IsSettBitEnabled as well
    //

    AddListItemSettBits( 0, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_SPECIAL_POOLING),           IDS_SPECIAL_POOL  );
    AddListItemSettBits( 1, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS),    IDS_POOL_TRACKING );
    AddListItemSettBits( 2, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_FORCE_IRQL_CHECKING),       IDS_FORCE_IRQL_CHECKING );
    AddListItemSettBits( 3, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_IO_CHECKING),               IDS_IO_VERIFICATION );
    AddListItemSettBits( 4, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_ENHANCED_IO_CHECKING),      IDS_ENH_IO_VERIFICATION );
    AddListItemSettBits( 5, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_DEADLOCK_DETECTION),        IDS_DEADLOCK_DETECTION );
    AddListItemSettBits( 6, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_DMA_VERIFIER),              IDS_DMA_CHECHKING );
    AddListItemSettBits( 7, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES),IDS_LOW_RESOURCE_SIMULATION );
    AddListItemSettBits( 8, g_OldDiskData.VerifyAnyDisk(), IDS_DISK_INTEGRITY_CHECKING );
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::RefreshListSettBits()
{
    INT nListItems;
    INT nCrtListItem;
    INT_PTR nCrtVerifierBit;
    BOOL bEnabled;
 
    nListItems = m_SettBitsList.GetItemCount();

    for( nCrtListItem = 0; nCrtListItem < nListItems; nCrtListItem += 1 )
    {
        nCrtVerifierBit = m_SettBitsList.GetItemData( nCrtListItem );

        bEnabled = IsSettBitEnabled( nCrtVerifierBit );

        UpdateStatusColumnSettBits( nCrtListItem, bEnabled );
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CCrtRegSettingsPage::IsSettBitEnabled( INT_PTR nBitIndex )
{
    BOOL bEnabled;

    //
    // N.B. 
    //
    // If you change this switch statement you need to change FillTheListSettBits as well
    //

    switch( nBitIndex )
    {
    case 0:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_SPECIAL_POOLING) );
        break;

    case 1:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS) );
        break;

    case 2:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_FORCE_IRQL_CHECKING) );
        break;

    case 3:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_IO_CHECKING) );
        break;

    case 4:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_ENHANCED_IO_CHECKING) );
        break;

    case 5:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_DEADLOCK_DETECTION) );
        break;

    case 6:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_DMA_VERIFIER) );
        break;

    case 7:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES) );
        break;

    case 8:
        bEnabled = g_OldDiskData.VerifyAnyDisk();
        break;

    default:
        //
        // Oops, how did we get here ?!?
        //

        ASSERT( FALSE );

        bEnabled = FALSE;

        break;
    }

    return bEnabled;
}


/////////////////////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::AddListItemSettBits( INT nItemData,
                                               BOOL bEnabled, 
                                               ULONG uIdResourceString )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strText;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - enabled/diabled 
    //

    if( FALSE == bEnabled )
    {
        VERIFY( strText.LoadString( IDS_NO ) );
    }
    else
    {
        VERIFY( strText.LoadString( IDS_YES ) );
    }

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nItemData;
    lvItem.iItem = m_SettBitsList.GetItemCount();
    lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );

    if (NULL != lvItem.pszText)
    {
        nActualIndex = m_SettBitsList.InsertItem( &lvItem );
        strText.ReleaseBuffer();
    }
    else
    {
        lvItem.pszText = g_szVoidText;
        nActualIndex = m_SettBitsList.InsertItem( &lvItem );
    }

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    //
    // Sub-item 1 - feature name
    //

    VERIFY( strText.LoadString( uIdResourceString ) );

    lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;
    
    VERIFY( m_SettBitsList.SetItem( &lvItem ) );

    strText.ReleaseBuffer();

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::UpdateStatusColumnSettBits( INT nItemIndex, BOOL bEnabled )
{
    LVITEM lvItem;
    CString strText;

    ASSERT( nItemIndex < m_SettBitsList.GetItemCount() );

    if( FALSE == bEnabled )
    {
        VERIFY( strText.LoadString( IDS_NO ) );
    }
    else
    {
        VERIFY( strText.LoadString( IDS_YES ) );
    }

    ZeroMemory( &lvItem, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 0;
    lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );

    if (NULL != lvItem.pszText)
    {
        VERIFY( m_SettBitsList.SetItem( &lvItem ) );
        strText.ReleaseBuffer();
    }
    else
    {
        lvItem.pszText = g_szVoidText;
        VERIFY( m_SettBitsList.SetItem( &lvItem ) );
    }
}

/////////////////////////////////////////////////////////////
//
// Other methods
//

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::SortTheListDrivers()
{
    m_DriversList.SortItems( DrvStringCmpFunc, (LPARAM)this );
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::SortTheListSettBits()
{
    m_SettBitsList.SortItems( SettbitsStringCmpFunc, (LPARAM)this );
}

/////////////////////////////////////////////////////////////
// CCrtRegSettingsPage message handlers

BOOL CCrtRegSettingsPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    //
    // Setup the settings bits list
    //

    m_SettBitsList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_SettBitsList.GetExtendedStyle() );

    m_SettBitsList.SetBkColor( ::GetSysColor( COLOR_3DFACE ) );
    m_SettBitsList.SetTextBkColor( ::GetSysColor( COLOR_3DFACE ) );

    SetupListHeaderDriversSettBits();
    FillTheListSettBits();
    //SortTheListSettBits();

    //
    // Setup the drivers list
    //

    m_DriversList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_DriversList.GetExtendedStyle() );

    m_DriversList.SetBkColor( ::GetSysColor( COLOR_3DFACE ) );
    m_DriversList.SetTextBkColor( ::GetSysColor( COLOR_3DFACE ) );

    SetupListHeaderDrivers();

    VrfSetWindowText( m_NextDescription, IDS_REGSETT_PAGE_NEXT_DESCR );

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
BOOL CCrtRegSettingsPage::OnSetActive() 
{
    CString strDriversToVerify;
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                        PSWIZB_FINISH );
    
    //
    // Update the settings list
    //
    
    RefreshListSettBits();

    //
    // Update the drivers list
    //

    FillTheListDrivers();
    SortTheListDrivers();

    //
    // Verify all or verify selected drivers
    //

    if( g_bAllDriversVerified )
    {
        VERIFY( strDriversToVerify.LoadString( IDS_ALL_LOADED_DRIVERS ) );
    }
    else
    {
        VERIFY( strDriversToVerify.LoadString( IDS_FOLLOWING_DRIVERS ) );
    }
        
    m_VerifiedDrvStatic.SetWindowText( strDriversToVerify );

    return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::OnColumnclickDriversList(NMHDR* pNMHDR, 
                                                   LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if( 0 == pNMListView->iSubItem )
    {
        if( m_nSortColumnIndexDrv == pNMListView->iSubItem )
        {
            m_bAscendDrvNameSort = !m_bAscendDrvNameSort;
        }
    }
    else
    {
        if( m_nSortColumnIndexDrv == pNMListView->iSubItem )
        {
            m_bAscendDrvDescrSort = !m_bAscendDrvDescrSort;
        }
    }

    m_nSortColumnIndexDrv = pNMListView->iSubItem;

    SortTheListDrivers();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
void CCrtRegSettingsPage::OnColumnclickRegsettSettbitsList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if( 0 == pNMListView->iSubItem )
    {
        if( m_nSortColumnIndexSettbits == pNMListView->iSubItem )
        {
            m_bAscendSortEnabledBits = !m_bAscendSortEnabledBits;
        }
    }
    else
    {
        if( m_nSortColumnIndexSettbits == pNMListView->iSubItem )
        {
            m_bAscendSortNameBits = !m_bAscendSortNameBits;
        }
    }

    m_nSortColumnIndexSettbits = pNMListView->iSubItem;

    SortTheListSettBits();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
LONG CCrtRegSettingsPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CCrtRegSettingsPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\gcntpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: GCntPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#if !defined(AFX_GCNTPAGE_H__45E55738_381A_49A1_B2A7_6DD5B0BBFF9C__INCLUDED_)
#define AFX_GCNTPAGE_H__45E55738_381A_49A1_B2A7_6DD5B0BBFF9C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GCntPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CGlobalCountPage dialog

class CGlobalCountPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CGlobalCountPage)

public:
    //
    // Construction
    //
	
    CGlobalCountPage();
	~CGlobalCountPage();

public:
    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

protected:
    VOID SetupListHeader();

    VOID FillTheList();
    VOID RefreshTheList();
    VOID SortTheList();
    
    VOID AddCounterInList( INT nItemData, 
                           ULONG  uIdResourceString,
                           SIZE_T sizeValue );
    
    SIZE_T GetCounterValue( INT_PTR nCounterIndex );
    
    BOOL   GetCounterName( LPARAM lItemData, 
                           TCHAR *szCounterName,
                           ULONG uCounterNameBufferLen );

    VOID RefreshInfo();

    VOID UpdateCounterValueInList( INT nItemIndex,
                                   SIZE_T sizeValue );

    VOID OnRefreshTimerChanged();

    BOOL CheckAndShowPoolCoverageWarning();

    static int CALLBACK CounterValueCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    static int CALLBACK CounterNameCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    //
    // Dialog Data
    //

    INT m_nSortColumnIndex;     // counter name (0) or counter value (1)
    BOOL m_bAscendSortName;     // sort ascendent the counter names
    BOOL m_bAscendSortValue;    // sort ascendent the counter values


    UINT_PTR m_uTimerHandler;   // timer handler, returned by SetTimer()

    //
    // Runtime data (obtained from the kernel)
    //

    CRuntimeVerifierData m_RuntimeVerifierData; 

    //
    // Dialog data
    //

    //{{AFX_DATA(CGlobalCountPage)
	enum { IDD = IDD_GLOBAL_COUNTERS_PAGE };
	CListCtrl	m_CountersList;
	CStatic	m_NextDescription;
	//}}AFX_DATA

protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CGlobalCountPage)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CGlobalCountPage)
    virtual BOOL OnInitDialog();
    afx_msg VOID OnTimer(UINT nIDEvent);
    afx_msg void OnColumnclickGlobcList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GCNTPAGE_H__45E55738_381A_49A1_B2A7_6DD5B0BBFF9C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\regpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: RegPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#if !defined(AFX_REGPAGE_H__CB260019_060D_45DC_8BB3_95DB1CB7B8F4__INCLUDED_)
#define AFX_REGPAGE_H__CB260019_060D_45DC_8BB3_95DB1CB7B8F4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RegPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CCrtRegSettingsPage dialog

class CCrtRegSettingsPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CCrtRegSettingsPage)

    //
    // Construction
    //
public:
	CCrtRegSettingsPage();
	~CCrtRegSettingsPage();

protected:
    //
    // Data
    //

    CPropertySheet *m_pParentSheet;

    //
    // Runtime data (obtained from the kernel)
    //

    CRuntimeVerifierData m_RuntimeVerifierData; 

    //
    // Driver list sort parameters
    //

    INT m_nSortColumnIndexDrv;      // sort by name (0) or by status (1)
    BOOL m_bAscendDrvNameSort;      // sort ascendent by name
    BOOL m_bAscendDrvDescrSort;     // sort ascendent by description

    //
    // Settings bits sort parameters
    //

    INT m_nSortColumnIndexSettbits; // sort by enabled/disabled (0) or by bit name (1)
    BOOL m_bAscendSortEnabledBits;  // sort ascendent by enabled/disabled
    BOOL m_bAscendSortNameBits;     // sort ascendent by bit name

    //
    // Dialog Data
    //

    //{{AFX_DATA(CCrtRegSettingsPage)
	enum { IDD = IDD_CRT_REGISTRY_SETTINGS_PAGE };
	CStatic	m_VerifiedDrvStatic;
	CStatic	m_NextDescription;
	CListCtrl	m_SettBitsList;
	CListCtrl	m_DriversList;
	//}}AFX_DATA

public:
    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

protected:
    //
    // Drivers list control methods
    //

    VOID SetupListHeaderDrivers();
    VOID FillTheListDrivers();
    VOID UpdateDescriptionColumnDrivers( INT_PTR nItemIndex, INT_PTR nCrtDriver );
    VOID SortTheListDrivers();
    VOID SortTheListSettBits();

    BOOL IsSettBitEnabled( INT_PTR nBitIndex );

    static int CALLBACK DrvStringCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    static int CALLBACK SettbitsStringCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    int ListStrCmpFunc(
        LPARAM lParam1, 
        LPARAM lParam2, 
        CListCtrl &theList,
        INT nSortColumnIndex,
        BOOL bAscending );

    BOOL GetNameFromItemData( CListCtrl &theList,
                              INT nColumnIndex,
                              LPARAM lParam,
                              TCHAR *szName,
                              ULONG uNameBufferLength );

    //
    // Settings bits list control methods
    //

    VOID SetupListHeaderDriversSettBits();
    VOID FillTheListSettBits();

    VOID AddListItemSettBits( INT nItemData,
                              BOOL bEnabled, 
                              ULONG uIdResourceString );
    
    VOID UpdateStatusColumnSettBits( INT nIndexInList, BOOL bEnabled );

    VOID RefreshListSettBits();

protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CCrtRegSettingsPage)
    protected:
    virtual BOOL OnSetActive();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CCrtRegSettingsPage)
    virtual BOOL OnInitDialog();
    afx_msg VOID OnColumnclickDriversList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnclickRegsettSettbitsList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGPAGE_H__CB260019_060D_45DC_8BB3_95DB1CB7B8F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\sdrvpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: SDrvPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_SDRIVPAGE_H__48B5863F_CB55_47F8_9084_1F5459093728__INCLUDED_)
#define AFX_SDRIVPAGE_H__48B5863F_CB55_47F8_9084_1F5459093728__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SDrivPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CSelectDriversPage dialog

class CSelectDriversPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CSelectDriversPage)

// Construction
public:
	CSelectDriversPage();
	~CSelectDriversPage();

public:
    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

protected:
    //
    // Methods
    //

    VOID SetupListHeader();
    VOID FillTheList();

    INT AddListItem( INT_PTR nIndexInArray, CDriverData *pCrtDrvData );

    BOOL GetNewVerifiedDriversList();

    VOID SortTheList();
    BOOL GetColumnStrValue( LPARAM lItemData, 
                            CString &strName );

    static int CALLBACK StringCmpFunc( LPARAM lParam1,
                                       LPARAM lParam2,
                                       LPARAM lParamSort);

    static int CALLBACK CheckedStatusCmpFunc( LPARAM lParam1,
                                              LPARAM lParam2,
                                              LPARAM lParamSort);

protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    INT m_nSortColumnIndex;        // verified status (0), driver name (1), provider name (2), version (3)
    BOOL m_bAscendSortVerified;    // sort ascendent the verified status
    BOOL m_bAscendSortDrvName;     // sort ascendent the driver names
    BOOL m_bAscendSortProvName;    // sort ascendent the provider names
    BOOL m_bAscendSortVersion;     // sort ascendent the version

    //
    // Dialog Data
    //

	//{{AFX_DATA(CSelectDriversPage)
	enum { IDD = IDD_SELECT_DRIVERS_PAGE };
	CStatic	m_NextDescription;
	CListCtrl	m_DriversList;
	//}}AFX_DATA


protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CSelectDriversPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnWizardFinish();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CSelectDriversPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnAddButton();
    afx_msg void OnColumnclickSeldrvList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SDRIVPAGE_H__48B5863F_CB55_47F8_9084_1F5459093728__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\sdrvpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: SDrvPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include <Cderr.h>
#include "verifier.h"

#include "SDrvPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_SELDRV_LIST,                IDH_DV_SelectDriversToVerify,
    IDC_SELDRV_ADD_BUTTON,          IDH_DV_Addbut_UnloadedDrivers,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CSelectDriversPage property page

IMPLEMENT_DYNCREATE(CSelectDriversPage, CVerifierPropertyPage)

CSelectDriversPage::CSelectDriversPage() 
    : CVerifierPropertyPage(CSelectDriversPage::IDD)
{
	//{{AFX_DATA_INIT(CSelectDriversPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pParentSheet = NULL;

    m_nSortColumnIndex = 1;
    m_bAscendSortVerified = FALSE;
    m_bAscendSortDrvName = FALSE;
    m_bAscendSortProvName = FALSE;
    m_bAscendSortVersion = FALSE;
}

CSelectDriversPage::~CSelectDriversPage()
{
}

void CSelectDriversPage::DoDataExchange(CDataExchange* pDX)
{
    CVerifierPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSelectDriversPage)
    DDX_Control(pDX, IDC_SELDRV_NEXT_DESCR_STATIC, m_NextDescription);
    DDX_Control(pDX, IDC_SELDRV_LIST, m_DriversList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectDriversPage, CVerifierPropertyPage)
    //{{AFX_MSG_MAP(CSelectDriversPage)
    ON_BN_CLICKED(IDC_SELDRV_ADD_BUTTON, OnAddButton)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_SELDRV_LIST, OnColumnclickSeldrvList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
VOID CSelectDriversPage::SetupListHeader()
{
    CString strTitle;
    CRect rectWnd;
    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_DriversList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
               sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0
    //

    VERIFY( strTitle.LoadString( IDS_VERIFICATION_STATUS ) );

    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.08 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    }

    //
    // Column 1
    //

    VERIFY( strTitle.LoadString( IDS_DRIVERS ) );

    lvColumn.iSubItem = 1;
    lvColumn.cx = (int)( rectWnd.Width() * 0.20 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    }

    //
    // Column 2
    //

    VERIFY( strTitle.LoadString( IDS_PROVIDER ) );

    lvColumn.iSubItem = 2;
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_DriversList.InsertColumn( 2, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_DriversList.InsertColumn( 2, &lvColumn ) != -1 );
    }

    //
    // Column 3
    //

    VERIFY( strTitle.LoadString( IDS_VERSION ) );

    lvColumn.iSubItem = 3;
    lvColumn.cx = (int)( rectWnd.Width() * 0.22 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_DriversList.InsertColumn( 3, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else
    {
        VERIFY( m_DriversList.InsertColumn( 3, &lvColumn ) != -1 );
        lvColumn.pszText = g_szVoidText;
    }
}

/////////////////////////////////////////////////////////////////////////////
VOID CSelectDriversPage::FillTheList()
{
    INT_PTR nDriversNo;
    INT_PTR nCrtDriverIndex;
    CDriverData *pCrtDrvData;
    const CDriverDataArray &DrvDataArray = g_NewVerifierSettings.m_DriversSet.m_aDriverData;

    m_DriversList.DeleteAllItems();

    //
    // Parse the driver data array
    //

    nDriversNo = DrvDataArray.GetSize();

    for( nCrtDriverIndex = 0; nCrtDriverIndex < nDriversNo; nCrtDriverIndex += 1)
    {
        pCrtDrvData = DrvDataArray.GetAt( nCrtDriverIndex );

        ASSERT_VALID( pCrtDrvData );

        AddListItem( nCrtDriverIndex, 
                     pCrtDrvData );
    }
}

/////////////////////////////////////////////////////////////////////////////
INT CSelectDriversPage::AddListItem( INT_PTR nIndexInArray, CDriverData *pCrtDrvData )
{
    INT nActualIndex;
    LVITEM lvItem;

    ASSERT_VALID( pCrtDrvData );

    nActualIndex = -1;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - verification status - empty text and a checkbox
    //

    lvItem.pszText = g_szVoidText;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nIndexInArray;
    lvItem.iItem = m_DriversList.GetItemCount();

    nActualIndex = m_DriversList.InsertItem( &lvItem );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    m_DriversList.SetCheck( nActualIndex, FALSE );

    //
    // Sub-item 1 - driver name
    //

    lvItem.pszText = pCrtDrvData->m_strName.GetBuffer( pCrtDrvData->m_strName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;
    
    VERIFY( m_DriversList.SetItem( &lvItem ) );

    pCrtDrvData->m_strName.ReleaseBuffer();

    //
    // Sub-item 2 - provider
    //

    lvItem.pszText = pCrtDrvData->m_strCompanyName.GetBuffer( 
        pCrtDrvData->m_strCompanyName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 2;

    VERIFY( m_DriversList.SetItem( &lvItem ) );
    
    pCrtDrvData->m_strCompanyName.ReleaseBuffer();

    //
    // Sub-item 3 - version
    //

    lvItem.pszText = pCrtDrvData->m_strFileVersion.GetBuffer( 
        pCrtDrvData->m_strFileVersion.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 3;

    VERIFY( m_DriversList.SetItem( &lvItem ) );
    
    pCrtDrvData->m_strFileVersion.ReleaseBuffer();

Done:
    //
    // All done
    //

    return nActualIndex;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSelectDriversPage::GetNewVerifiedDriversList()
{
    INT nListItemCount; 
    INT nCrtListItem;
    INT_PTR nCrtDriversArrayIndex;
    BOOL bVerified;
    CDriverData *pCrtDrvData;
    const CDriverDataArray &DrvDataArray = g_NewVerifierSettings.m_DriversSet.m_aDriverData;
    CDriverData::VerifyDriverTypeEnum VerifyStatus;
    
    nListItemCount = m_DriversList.GetItemCount();

    for( nCrtListItem = 0; nCrtListItem < nListItemCount; nCrtListItem += 1 )
    {
        //
        // Verification status for the current list item
        //

        bVerified = m_DriversList.GetCheck( nCrtListItem );

        if( bVerified )
        {
            VerifyStatus = CDriverData::VerifyDriverYes;
        }
        else
        {
            VerifyStatus = CDriverData::VerifyDriverNo;
        }

        //
        // Set the right verify state in our driver array 
        //

        nCrtDriversArrayIndex = m_DriversList.GetItemData( nCrtListItem );

        pCrtDrvData = DrvDataArray.GetAt( nCrtDriversArrayIndex );

        ASSERT_VALID( pCrtDrvData );

        pCrtDrvData->m_VerifyDriverStatus = VerifyStatus;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////
VOID CSelectDriversPage::SortTheList()
{
    if( 0 != m_nSortColumnIndex )
    {
        //
        // Sort by driver name, provider or version
        //

        m_DriversList.SortItems( StringCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by verified status
        //

        m_DriversList.SortItems( CheckedStatusCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
int CALLBACK CSelectDriversPage::StringCmpFunc( LPARAM lParam1,
                                                    LPARAM lParam2,
                                                    LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    CString strName1;
    CString strName2;

    CSelectDriversPage *pThis = (CSelectDriversPage *)lParamSort;
    ASSERT_VALID( pThis );

    ASSERT( 0 != pThis->m_nSortColumnIndex );

    //
    // Get the first name
    //

    bSuccess = pThis->GetColumnStrValue( lParam1, 
                                         strName1 );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second name
    //

    bSuccess = pThis->GetColumnStrValue( lParam2, 
                                         strName2 );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = strName1.CompareNoCase( strName2 );
    
    switch( pThis->m_nSortColumnIndex )
    {
    case 1:
        //
        // Sort by driver name
        //

        if( FALSE != pThis->m_bAscendSortDrvName )
        {
            nCmpRez *= -1;
        }

        break;

    case 2:
        //
        // Sort by provider name
        //

        if( FALSE != pThis->m_bAscendSortProvName )
        {
            nCmpRez *= -1;
        }

        break;

    case 3:
        //
        // Sort by version
        //

        if( FALSE != pThis->m_bAscendSortVersion )
        {
            nCmpRez *= -1;
        }

        break;

    default:
        //
        // Oops - how did we get here ?!?
        //

        ASSERT( FALSE );
        break;
    }

Done:

    return nCmpRez;

}

/////////////////////////////////////////////////////////////
int CALLBACK CSelectDriversPage::CheckedStatusCmpFunc( LPARAM lParam1,
                                                       LPARAM lParam2,
                                                       LPARAM lParamSort)
{
    int nCmpRez = 0;
    INT nItemIndex;
    BOOL bVerified1;
    BOOL bVerified2;
    LVFINDINFO FindInfo;

    CSelectDriversPage *pThis = (CSelectDriversPage *)lParamSort;
    ASSERT_VALID( pThis );

    ASSERT( 0 == pThis->m_nSortColumnIndex );

    //
    // Find the first item
    //

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam1;

    nItemIndex = pThis->m_DriversList.FindItem( &FindInfo );

    if( nItemIndex < 0 )
    {
        ASSERT( FALSE );

        goto Done;
    }

    bVerified1 = pThis->m_DriversList.GetCheck( nItemIndex );

    //
    // Find the second item
    //

    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam2;

    nItemIndex = pThis->m_DriversList.FindItem( &FindInfo );

    if( nItemIndex < 0 )
    {
        ASSERT( FALSE );

        goto Done;
    }

    bVerified2 = pThis->m_DriversList.GetCheck( nItemIndex );

    //
    // Compare them
    //
    
    if( bVerified1 != bVerified2 )
    {
        if( FALSE != bVerified1 )
        {
            nCmpRez = 1;
        }
        else
        {
            nCmpRez = -1;
        }

        if( FALSE != pThis->m_bAscendSortVerified )
        {
            nCmpRez *= -1;
        }
    }

Done:

    return nCmpRez;

}

/////////////////////////////////////////////////////////////
BOOL CSelectDriversPage::GetColumnStrValue( LPARAM lItemData, 
                                                CString &strName )
{
    CDriverData *pCrtDrvData;

    pCrtDrvData = g_NewVerifierSettings.m_DriversSet.m_aDriverData.GetAt( (INT_PTR) lItemData );

    ASSERT_VALID( pCrtDrvData );
    
    switch( m_nSortColumnIndex )
    {
    case 1:
        //
        // Sort by driver name
        //

        strName = pCrtDrvData->m_strName;
        
        break;

    case 2:
        //
        // Sort by provider name
        //

        strName = pCrtDrvData->m_strCompanyName;

        break;

    case 3:
        //
        // Sort by version
        //

        strName = pCrtDrvData->m_strFileVersion;

        break;

    default:
        //
        // Oops - how did we get here ?!?
        //

        ASSERT( FALSE );
        break;

    }
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSelectDriversPage::OnSetActive() 
{
    //
    // The wizard has at least one more step (display the summarry)
    //

    if( (FALSE == g_bShowDiskPropertyPage) &&
        (FALSE == g_NewVerifierSettings.m_aDiskData.VerifyAnyDisk()) )
    {
        //
        // Disk verifier is disabled.
        //

        m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                            PSWIZB_FINISH );

        VrfSetWindowText( m_NextDescription, IDS_SELDRV_PAGE_NEXT_DESCR_FINISH );
    }
    else
    {
        //
        // Disk verifier is enabled.
        //

        m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                            PSWIZB_NEXT );

        VrfSetWindowText( m_NextDescription, IDS_SELDRV_PAGE_NEXT_DESCR_NEXT );
    }

    return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
// CSelectDriversPage message handlers

BOOL CSelectDriversPage::OnInitDialog() 
{
	CVerifierPropertyPage::OnInitDialog();

    //
    // setup the list
    //

    m_DriversList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES | m_DriversList.GetExtendedStyle() );

    SetupListHeader();
    FillTheList();
    SortTheList();

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSelectDriversPage::OnWizardFinish() 
{
    BOOL bExitTheApp;

    bExitTheApp = FALSE;

    if( GetNewVerifiedDriversList() )
    {
        if( FALSE == g_NewVerifierSettings.m_DriversSet.ShouldVerifySomeDrivers() )
        {
            VrfErrorResourceFormat( IDS_SELECT_AT_LEAST_ONE_DRIVER );

            goto Done;
        }

        g_NewVerifierSettings.SaveToRegistry();
	    
        //
        // Exit the app
        //

	    bExitTheApp = CVerifierPropertyPage::OnWizardFinish();
    }

Done:

    return bExitTheApp;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CSelectDriversPage::OnWizardNext() 
{
    LRESULT lNextPageId;

    lNextPageId = -1;

    //
    // We can get here only if the disk integrity checking is enabled.
    //

    ASSERT( FALSE != g_bShowDiskPropertyPage ||
            FALSE != g_NewVerifierSettings.m_aDiskData.VerifyAnyDisk() );

    if( GetNewVerifiedDriversList() )
    {
        if( FALSE == g_NewVerifierSettings.m_DriversSet.ShouldVerifySomeDrivers() )
        {
            VrfErrorResourceFormat( IDS_SELECT_AT_LEAST_ONE_DRIVER );

            goto Done;
        }

        lNextPageId = IDD_DISK_LIST_PAGE;

        GoingToNextPageNotify( lNextPageId );
    }

Done:

    return lNextPageId;
}

/////////////////////////////////////////////////////////////////////////////
#define VRF_MAX_CHARS_FOR_OPEN  4096

void CSelectDriversPage::OnAddButton() 
{
    POSITION pos;
    DWORD dwRetValue;
    DWORD dwOldMaxFileName = 0;
    DWORD dwErrorCode;
    INT nFileNameStartIndex;
    INT nNewListItemIndex;
    INT_PTR nResult;
    INT_PTR nNewDriverDataIndex;
    CDriverData *pNewDrvData;
    TCHAR szDriversDir[ _MAX_PATH ];
    TCHAR szAppTitle[ _MAX_PATH ];
    TCHAR *szFilesBuffer = NULL;
    TCHAR *szOldFilesBuffer = NULL;
    CString strPathName;
    CString strFileName;

    CFileDialog fileDlg( 
        TRUE,                               // open file
        _T( "sys" ),                        // default extension
        NULL,                               // no initial file name
        OFN_ALLOWMULTISELECT    |           // multiple selection
        OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox
        OFN_NONETWORKBUTTON     |           // no network button
        OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
        OFN_SHAREAWARE,                     // don't check the existance of file with OpenFile
        _T( "Drivers (*.sys)|*.sys||" ) );  // only one filter

    //
    // check the max length for the returned string
    //

    if( fileDlg.m_ofn.nMaxFile < VRF_MAX_CHARS_FOR_OPEN )
    {
        //
        // allocate a new buffer for the file names
        // 

        szFilesBuffer = new TCHAR[ VRF_MAX_CHARS_FOR_OPEN ];
        
        if (NULL == szFilesBuffer)
        {
            VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
            goto Done;
        }

        szFilesBuffer[ 0 ] = (TCHAR)0;

        if( szFilesBuffer != NULL )
        {
            //
            // Save the old buffer address and length
            //

            dwOldMaxFileName = fileDlg.m_ofn.nMaxFile;
            szOldFilesBuffer = fileDlg.m_ofn.lpstrFile;
            
            //
            // Set the new buffer address and length
            //

            fileDlg.m_ofn.lpstrFile = szFilesBuffer;
            fileDlg.m_ofn.nMaxFile = VRF_MAX_CHARS_FOR_OPEN;
        }
    }

    //
    // Dialog title
    //

    if( VrfLoadString(
        IDS_APPTITLE,
        szAppTitle,
        ARRAY_LENGTH( szAppTitle ) ) )
    {
        fileDlg.m_ofn.lpstrTitle = szAppTitle;
    }

    //
    // We change directory first time we try this to %windir%\system32\drivers
    //

    dwRetValue = ExpandEnvironmentStrings(
        _T( "%windir%\\system32\\drivers" ),
        szDriversDir,
        ARRAY_LENGTH( szDriversDir ) );

    if( dwRetValue > 0 && dwRetValue <= ARRAY_LENGTH( szDriversDir ) )
    {
        fileDlg.m_ofn.lpstrInitialDir = szDriversDir;
    }

    //
    // Show the file selection dialog
    //

    nResult = fileDlg.DoModal();

    switch( nResult )
    {
    case IDOK:
        break;

    case IDCANCEL:
        goto cleanup;

    default:
        dwErrorCode = CommDlgExtendedError();

        if( dwErrorCode == FNERR_BUFFERTOOSMALL )
        {
            VrfErrorResourceFormat(
                IDS_TOO_MANY_FILES_SELECTED );
        }
        else
        {
            VrfErrorResourceFormat(
                IDS_CANNOT_OPEN_FILES,
                dwErrorCode );
        }

        goto cleanup;
    }

    //
    // Parse all the selected files and try to enable them for verification
    //

    pos = fileDlg.GetStartPosition();

    while( pos != NULL )
    {
        //
        // Get the full path for the next file
        //

        strPathName = fileDlg.GetNextPathName( pos );

        //
        // Split only the file name, without the directory
        //

        nFileNameStartIndex = strPathName.ReverseFind( _T( '\\' ) );
        
        if( nFileNameStartIndex < 0 )
        {
            //
            // This shoudn't happen but you never know :-)
            //

            nFileNameStartIndex = 0;
        }
        else
        {
            //
            // skip the backslash
            //

            nFileNameStartIndex += 1;
        }

        strFileName = strPathName.Right( strPathName.GetLength() - nFileNameStartIndex );

        //
        // Try to add this driver to our global driver list
        //

        if( g_NewVerifierSettings.m_DriversSet.IsDriverNameInList( strFileName ) )
        {
            VrfErrorResourceFormat( IDS_DRIVER_IS_ALREADY_IN_LIST,
                                    (LPCTSTR) strFileName );
        }
        else
        {
            nNewDriverDataIndex = g_NewVerifierSettings.m_DriversSet.AddNewDriverData( strFileName );

            if( nNewDriverDataIndex >= 0 )
            {
                //
                // Force refreshing the unsigned driver data 
                //

                g_NewVerifierSettings.m_DriversSet.m_bUnsignedDriverDataInitialized = FALSE;

                //
                // Add a new item to our list, for the new driver
                //

                pNewDrvData = g_NewVerifierSettings.m_DriversSet.m_aDriverData.GetAt( nNewDriverDataIndex );
            
                ASSERT_VALID( pNewDrvData );

                nNewListItemIndex = AddListItem( nNewDriverDataIndex, 
                                                 pNewDrvData );

                if( nNewListItemIndex >= 0 )
                {
                    m_DriversList.EnsureVisible( nNewListItemIndex, TRUE );
                }
            }
        }
    }

cleanup:
    if( szFilesBuffer != NULL )
    {
        fileDlg.m_ofn.nMaxFile = dwOldMaxFileName;
        fileDlg.m_ofn.lpstrFile = szOldFilesBuffer;

        delete [] szFilesBuffer;
    }

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
void CSelectDriversPage::OnColumnclickSeldrvList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    switch( pNMListView->iSubItem )
    {
    case 0:
        //
        // Clicked on the "verified" column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortVerified = !m_bAscendSortVerified;
        }

        break;

    case 1:
        //
        // Clicked on the driver name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortDrvName = !m_bAscendSortDrvName;
        }

        break;

    case 2:
        //
        // Clicked on the provider column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortProvName = !m_bAscendSortProvName;
        }

        break;

    case 3:
        //
        // Clicked on the version column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortVersion = !m_bAscendSortVersion;
        }

        break;

    default:
        //
        // Oops - how did we get here ?!?
        //

        ASSERT( FALSE );
        goto Done;
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

Done:

	*pResult = 0;
}

/////////////////////////////////////////////////////////////
LONG CSelectDriversPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CSelectDriversPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by verifier.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDS_ABOUTBOX                    101
#define IDS_APPTITLE                    102
#define IDS_CANNOT_LOAD_APP_TITLE       103
#define IDS_NOT_ENOUGH_MEMORY           104
#define IDS_NO_TESTS_SELECTED           105
#define IDS_CANNOT_GET_SYSTEM_DIRECTORY 106
#define IDS_NO_DRIVERS_FOUND            107
#define IDS_CANNOT_GET_CURRENT_DIRECTORY 108
#define IDS_CANNOT_SET_CURRENT_DIRECTORY 109
#define IDS_CANT_GET_ACTIVE_DRVLIST     110
#define IDS_NAME                        111
#define IDS_DESCRIPTION                 112
#define IDS_LOADING_DRIVER_INFORMATION  113
#define IDS_SEARCHING_FOR_UNSIGNED_DRIVERS 114
#define IDS_UNSIGNED_DRIVERS_LIST       115
#define IDS_OLD_DRIVERS_LIST            116
#define IDS_UNKNOWN                     117
#define IDS_SETTINGS_TYPE               118
#define IDS_TYPICAL                     119
#define IDS_CUSTOM                      120
#define IDS_DRIVERS_BUILT_FOR_OLD_WINDOWS 121
#define IDS_UNSIGNED                    122
#define IDS_ALL                         123
#define IDS_DRIVERS                     124
#define IDS_VERIFICATION_STATUS         125
#define IDS_PROVIDER                    126
#define IDS_VERSION                     127
#define IDR_MAINFRAME                   128
#define IDS_DRIVERS_TO_VERIFY           128
#define IDS_DISABLED                    129
#define IDS_ENABLED                     130
#define IDS_TAS_PAGE_NEXT_DESCR_STANDARD 131
#define IDS_TAS_PAGE_NEXT_DESCR_CUSTOM  132
#define IDS_TAS_PAGE_NEXT_DESCR_STATISTICS 133
#define IDS_TAS_PAGE_NEXT_DESCR_DELETE  134
#define IDS_DELETE_ALL_SETTINGS         135
#define IDS_DRVSET_PAGE_NEXT_DESCR_UNSIGNED 136
#define IDS_DRVSET_PAGE_NEXT_DESCR_ALL  137
#define IDS_DRVSET_PAGE_NEXT_DESCR_NAMELIST 138
#define IDS_DRVSET_PAGE_NEXT_DESCR_OLD  139
#define IDD_VOLATILE_BITS_DIALOG        139
#define IDS_CONFDRV_PAGE_NEXT_DESCR_FINISH 140
#define IDS_SELDRV_PAGE_NEXT_DESCR_FINISH 141
#define IDS_TAS_PAGE_NEXT_DESCR_PREDEFINED 142
#define IDS_TAS_PAGE_NEXT_DESCR_LIST    143
#define IDS_FLSETT_PAGE_NEXT_DESCR      144
#define IDS_ACCESS_IS_DENIED            145
#define IDS_REGOPENKEYEX_FAILED         146
#define IDS_REGSETVALUEEX_FAILED        147
#define IDS_NO_OLD_DRIVERS_FOUND        148
#define IDS_NO_UNSIGNED_DRIVERS_FOUND   149
#define IDS_REGDELETEVALUE_FAILED       150
#define IDS_STATUS                      151
#define IDS_NEVER_LOADED                152
#define IDS_UNLOADED                    153
#define IDS_LOADED                      154
#define IDS_COVERAGE_WARNING_FORMAT     155
#define IDS_QUERY_SYSINFO_FAILED        158
#define IDS_CRTSTAT_PAGE_NEXT_DESCR     159
#define IDS_HELP_CMDLINE_SWITCH         160
#define IDS_HELP_LINE1                  161
#define IDS_HELP_LINE3                  162
#define IDS_HELP_LINE4                  163
#define IDS_HELP_LINE5                  164
#define IDS_HELP_LINE6                  165
#define IDS_HELP_LINE7                  166
#define IDS_HELP_LINE8                  167
#define IDS_HELP_LINE9                  168
#define IDS_HELP_LINE10                 169
#define IDS_HELP_LINE11                 170
#define IDS_HELP_LINE12                 171
#define IDS_HELP_LINE13                 172
#define IDS_HELP_LINE14                 173
#define IDS_HELP_LINE15                 174
#define IDS_HELP_LINE16                 175
#define IDS_HELP_LINE17                 176
#define IDS_HELP_LINE18                 177
#define IDS_HELP_LINE19                 178
#define IDS_HELP_LINE20                 179
#define IDS_HELP_LINE21                 180
#define IDS_HELP_LINE22                 181
#define IDS_HELP_LINE23                 182
#define IDS_HELP_LINE24                 183
#define IDS_HELP_LINE25                 184
#define IDS_HELP_LINE26                 185
#define IDS_HELP_LINE27                 186
#define IDS_HELP_LINE28                 187
#define IDS_HELP_LINE29                 188
#define IDS_HELP_LINE30                 189
#define IDS_HELP_LINE31                 190
#define IDS_RESET_CMDLINE_SWITCH        191
#define IDS_LOG_CMDLINE_SWITCH          192
#define IDS_INTERVAL_CMDLINE_SWITCH     193
#define IDS_CANT_APPEND_FILE            194
#define IDS_CANT_WRITE_FILE             195
#define IDS_CANTGET_VERIF_STATE         196
#define IDS_NO_DRIVER_VERIFIED          197
#define IDS_LEVEL                       198
#define IDS_RAISEIRQLS                  199
#define IDS_ACQUIRESPINLOCKS            200
#define IDS_SYNCHRONIZEEXECUTIONS       201
#define IDS_ALLOCATIONSATTEMPTED        202
#define IDS_ALLOCATIONSSUCCEEDED        203
#define IDS_ALLOCATIONSSUCCEEDEDSPECIALPOOL 204
#define IDS_ALLOCATIONSWITHNOTAG        205
#define IDS_ALLOCATIONSFAILED           206
#define IDS_ALLOCATIONSFAILEDDELIBERATELY 207
#define IDS_TRIMS                       208
#define IDS_UNTRACKEDPOOL               209
#define IDS_THE_VERIFIED_DRIVERS        210
#define IDS_NAME_LOADS_UNLOADS          211
#define IDS_CURRENTPAGEDPOOLALLOCATIONS 212
#define IDS_CURRENTNONPAGEDPOOLALLOCATIONS 213
#define IDS_PEAKPAGEDPOOLALLOCATIONS    214
#define IDS_PEAKNONPAGEDPOOLALLOCATIONS 215
#define IDS_PAGEDPOOLUSAGEINBYTES       216
#define IDS_NONPAGEDPOOLUSAGEINBYTES    217
#define IDS_PEAKPAGEDPOOLUSAGEINBYTES   218
#define IDS_PEAKNONPAGEDPOOLUSAGEINBYTES 219
#define IDS_QUERY_CMDLINE_SWITCH        220
#define IDS_FLAGS_CMDLINE_SWITCH        221
#define IDS_ALL_CMDLINE_SWITCH          222
#define IDS_DONTREBOOT_CMDLINE_SWITCH   223
#define IDS_DRIVER_CMDLINE_SWITCH       224
#define IDS_ADDDRIVER_CMDLINE_SWITCH    225
#define IDS_REMOVEDRIVER_CMDLINE_SWITCH 226
#define IDS_CANNOT_CHANGE_SETTING_ON_FLY 227
#define IDS_VERIFIER_ADD_NOT_SUPPORTED  228
#define IDS_DYN_ADD_NOT_SUPPORTED       229
#define IDS_DYN_ADD_ALREADY_LOADED      230
#define IDS_DYN_ADD_INSUF_RESOURCES     231
#define IDS_DYN_ADD_ACCESS_DENIED       232
#define IDS_DYN_ADD_MISC_ERROR          233
#define IDS_VERIFIER_REMOVE_NOT_SUPPORTED 234
#define IDS_DYN_REMOVE_ALREADY_LOADED   235
#define IDS_DYN_REMOVE_INSUF_RESOURCES  236
#define IDS_DYN_REMOVE_ACCESS_DENIED    237
#define IDS_DYN_REMOVE_MISC_ERROR       238
#define IDS_NO_SETTINGS_WERE_CHANGED    239
#define IDS_CHANGED_SETTINGS_ARE        240
#define IDS_SPECIAL_POOL_ENABLED_NOW    241
#define IDS_SPECIAL_POOL_DISABLED_NOW   242
#define IDS_FORCE_IRQLCHECK_ENABLED_NOW 243
#define IDS_FORCE_IRQLCHECK_DISABLED_NOW 244
#define IDS_FAULT_INJECTION_ENABLED_NOW 245
#define IDS_POOL_TRACK_ENABLED_NOW      246
#define IDS_POOL_TRACK_DISABLED_NOW     247
#define IDS_IO_CHECKING_ENABLED_NOW     248
#define IDS_IO_CHECKING_DISABLED_NOW    249
#define IDS_CHANGES_ACTIVE_ONLY_BEFORE_REBOOT 250
#define IDS_FAULT_INJECTION_DISABLED_NOW 251
#define IDS_REBOOT                      255
#define IDS_SELECT_AT_LEAST_ONE_DRIVER  256
#define IDS_ENABLED_QUESTION            257
#define IDS_SETTING                     258
#define IDS_SPECIAL_POOL                259
#define IDS_POOL_TRACKING               260
#define IDS_IO_VERIFICATION             261
#define IDS_ENH_IO_VERIFICATION         262
#define IDS_FORCE_IRQL_CHECKING         263
#define IDS_DEADLOCK_DETECTION          264
#define IDS_DMA_CHECHKING               265
#define IDS_LOW_RESOURCE_SIMULATION     266
#define IDS_YES                         267
#define IDS_NO                          268
#define IDS_STANDARD_CMDLINE_SWITCH     269
#define IDS_REGQUERYVALUEEX_FAILED      272
#define IDS_REGSETT_PAGE_NEXT_DESCR     273
#define IDS_ALL_LOADED_DRIVERS          274
#define IDS_FOLLOWING_DRIVERS           275
#define IDS_COUNTER                     276
#define IDS_VALUE                       277
#define IDS_GCNT_PAGE_NEXT_DESCR        278
#define IDS_ALLOCATIONSATTEMPTED_LIST   279
#define IDS_ALLOCATIONSSUCCEEDED_LIST   280
#define IDS_ALLOCATIONSSUCCEEDEDSPECIALPOOL_LIST 281
#define IDS_ALLOCATIONSWITHNOTAG_LIST   282
#define IDS_UNTRACKEDPOOL_LIST          283
#define IDS_ALLOCATIONSFAILED_LIST      284
#define IDS_ALLOCATIONSFAILEDDELIBERATELY_LIST 285
#define IDS_RAISEIRQLS_LIST             286
#define IDS_ACQUIRESPINLOCKS_LIST       287
#define IDS_SYNCHRONIZEEXECUTIONS_LIST  288
#define IDS_TRIMS_LIST                  289
#define IDS_CURRENTPAGEDPOOLALLOCATIONS_LIST 290
#define IDS_PEAKPAGEDPOOLALLOCATIONS_LIST 291
#define IDS_PAGEDPOOLUSAGEINBYTES_LIST  292
#define IDS_PEAKPAGEDPOOLUSAGEINBYTES_LIST 293
#define IDS_CURRENTNONPAGEDPOOLALLOCATIONS_LIST 294
#define IDS_PEAKNONPAGEDPOOLALLOCATIONS_LIST 295
#define IDS_NONPAGEDPOOLUSAGEINBYTES_LIST 296
#define IDS_PEAKNONPAGEDPOOLUSAGEINBYTES_LIST 297
#define IDS_DCNT_PAGE_NEXT_DESCR        298
#define IDS_TOO_MANY_FILES_SELECTED     299
#define IDS_CANNOT_OPEN_FILES           300
#define IDS_DRIVER_IS_ALREADY_IN_LIST   301
#define IDS_QUERYSETT_CMDLINE_SWITCH    302
#define IDS_VERIFIED_DRIVERS            303
#define IDS_NEW_SETTINGS                304
#define IDS_NONE                        305
#define IDS_TAS_PAGE_NEXT_DESCR_REGISTRY 306
#define IDS_DISK_INTEGRITY_CHECKING     307
#define IDS_DISK                        308
#define IDS_SELECT_AT_LEAST_ONE_DISK    309
#define IDS_DISKLIST_PAGE_FINISH_DESCR  310
#define IDS_DRVSET_PAGE_NEXT_DESCR_ALL_HAVEDISKS 311
#define IDS_CANNOT_GET_DEVICES_LIST     312
#define IDS_NO_DEVICES_MATCH_NAME       313
#define IDS_CANNOT_SET_DEVICE_REGISTRY_PROPERTY       314
#define IDS_CANNOT_GET_DEVICE_REGISTRY_PROPERTY       315
#define IDS_CONFDRV_PAGE_NEXT_DESCR_NEXT 316
#define IDS_SELDRV_PAGE_NEXT_DESCR_NEXT 317
#define IDS_DISK_CMDLINE_SWITCH         318
#define IDS_VERIFIED_DISKS              319
#define IDD_CRT_REGISTRY_SETTINGS_PAGE  601
#define IDD_DRVSTATUS_STAT_PAGE         602
#define IDD_FULL_LIST_SETT_PAGE         603
#define IDD_SELECT_DRIVERS_PAGE         604
#define IDD_CONFIRM_DRIVERS_PAGE        605
#define IDD_DRVSET_PAGE                 606
#define IDD_TAS_PAGE                    607
#define IDD_CUSTSETT_PAGE               608
#define IDD_GLOBAL_COUNTERS_PAGE        609
#define IDD_BUILDING_UNSIGNED_LIST_DIALOG 610
#define IDD_PERDRIVER_COUNTERS_PAGE     611
#define IDD_DISK_LIST_PAGE              612
#define IDC_DRVSET_NOTSIGNED_RADIO      1004
#define IDC_DRVSET_OLDVER_RADIO         1005
#define IDC_DRVSET_ALLDRV_RADIO         1006
#define IDC_DRVSET_NAMESLIST_RADIO      1007
#define IDC_CUSTSETT_TYPICAL_CHECK      1008
#define IDC_CUSTSETT_EXCESS_CHECK       1009
#define IDC_CUSTSETT_LOWRES_CHECK       1010
#define IDC_CUSTSETT_DISK_CHECK         1011
#define IDC_UNSIGNED_PROGRESS           1012
#define IDC_UNSIGNED_STATIC             1013
#define IDC_UNSIGNED_CANCEL_BUTTON      1014
#define IDC_CONFDRV_LIST                1015
#define IDC_CONFDRV_TITLE_STATIC        1016
#define IDC_SELDRV_TITLE_STATIC         1019
#define IDC_SELDRV_LIST                 1020
#define IDC_CUSTSETT_PREDEF_RADIO       1022
#define IDC_CUSTSETT_FULLLIST_RADIO     1023
#define IDC_TAS_NEXT_DESCR_STATIC       1024
#define IDC_DRVSET_NEXT_DESCR_STATIC    1025
#define IDC_CONFDRV_NEXT_DESCR_STATIC   1026
#define IDC_SELDRV_NEXT_DESCR_STATIC    1027
#define IDC_CUSTSETT_NEXT_DESCR_STATIC  1028
#define IDC_CRTSTAT_NEXT_DESCR_STATIC   1029
#define IDC_FLSETT_NEXT_DESCR_STATIC    1030
#define IDC_FLSETT_LIST                 1031
#define IDC_CRTSTAT_DRIVERS_LIST        1032
#define IDC_CRTSTAT_SPECPOOL_EDIT       1033
#define IDC_CRTSTAT_IRQLCHCK_EDIT       1034
#define IDC_CRTSTAT_FAULTINJ_EDIT       1035
#define IDC_CRTSTAT_POOLT_EDIT          1036
#define IDC_CRTSTAT_IOVERIF_EDIT        1037
#define IDC_CRTSTAT_DEADLOCK_EDIT       1038
#define IDC_CRTSTAT_ENHIO_EDIT          1039
#define IDC_CRTSTAT_DMA_EDIT            1040
#define IDC_CRTSTAT_WARN_MSG            1041
#define IDC_CRTSTAT_SETTBITS_LIST       1042
#define IDC_REGSETT_NEXT_DESCR_STATIC   1043
#define IDC_REGSETT_SETTBITS_LIST       1044
#define IDC_REGSETT_DRIVERS_LIST        1045
#define IDC_TAS_TYPICAL_RADIO           1050
#define IDC_TAS_ADVANCED_RADIO          1051
#define IDC_TAS_DELETE_RADIO            1052
#define IDC_TAS_VIEWREGISTRY_RADIO      1053
#define IDC_TAS_STATISTICS_RADIO        1054
#define IDC_REGSETT_VERIFIED_DRV_STATIC 1061
#define IDC_GLOBC_NEXT_DESCR_STATIC     1062
#define IDC_GLOBC_LIST                  1063
#define IDC_PERDRVC_DRIVER_COMBO        1064
#define IDC_PERDRVC_LIST                1065
#define IDC_PERDRVC_NEXT_DESCR_STATIC   1066
#define IDC_VOLBITS_LIST                1067
#define IDC_CRTSTAT_CHSETT_BUTTON       1068
#define IDC_CRTSTAT_ADDDRV_BUTTON       1069
#define IDC_SELDRV_ADD_BUTTON           1069
#define IDC_CRTSTAT_REMDRVT_BUTTON      1070
#define IDC_DISKLIST_NEXT_DESCR_STATIC  1071
#define IDC_DISKLIST_LIST               1072

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        140
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1070
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\stdafx.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: stdafx.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  
// Include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#if !defined(AFX_STDAFX_H__E24BD541_BD54_42E0_BD79_8417041B8DA1__INCLUDED_)
#define AFX_STDAFX_H__E24BD541_BD54_42E0_BD79_8417041B8DA1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Use MFC ASSERT macro
//

#ifdef ASSERT
#undef ASSERT
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <locale.h>
#include <capi.h>
#include <softpub.h>
#include <Imagehlp.h>

#include <ntverp.h>
#include <common.ver>

#include "helpids.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E24BD541_BD54_42E0_BD79_8417041B8DA1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\slowdlg.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: SlowDlg.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_SIGNDLG_H__54E81D3F_0B31_477A_ABA7_E880D1F0F2BC__INCLUDED_)
#define AFX_SIGNDLG_H__54E81D3F_0B31_477A_ABA7_E880D1F0F2BC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SignDlg.h : header file
//

#include "VSetting.h"
#include "ProgCtrl.h"

/////////////////////////////////////////////////////////////////////////////
// CSlowProgressDlg dialog

class CSlowProgressDlg : public CDialog
{
// Construction
public:
	CSlowProgressDlg(CWnd* pParent = NULL);   // standard constructor
    virtual ~CSlowProgressDlg();

public:
    VOID KillWorkerThread();
    BOOL StartWorkerThread( LPTHREAD_START_ROUTINE pThreadStart,
                            ULONG uMessageResourceId );

    static DWORD WINAPI LoadDriverDataWorkerThread( PVOID p );
    static DWORD WINAPI SearchUnsignedDriversWorkerThread( PVOID p );

public:
    //
    // Data
    //

    //
    // Worker thread handle
    //

    HANDLE m_hWorkerThread;

    //
    // Event used to kill our worker thread
    //

    HANDLE m_hKillThreadEvent;

public:
// Dialog Data
	//{{AFX_DATA(CSlowProgressDlg)
	enum { IDD = IDD_BUILDING_UNSIGNED_LIST_DIALOG };
	CVrfProgressCtrl	m_ProgressCtl;
	CStatic	m_CurrentActionStatic;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSlowProgressDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSlowProgressDlg)
	afx_msg void OnCancelButton();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIGNDLG_H__54E81D3F_0B31_477A_ABA7_E880D1F0F2BC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\taspage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: taspage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "taspage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Change this if you add/remove/change order 
// of radio buttons on this page
//

#define FIRST_RADIO_BUTTON_ID   IDC_TAS_TYPICAL_RADIO

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_TAS_TYPICAL_RADIO,          IDH_DV_Settings_standard,
    IDC_TAS_ADVANCED_RADIO,         IDH_DV_Settings_custom,
    IDC_TAS_DELETE_RADIO,           IDH_DV_Settings_deleteexisting,
    IDC_TAS_VIEWREGISTRY_RADIO,     IDH_DV_Settings_displaycurrent,
    IDC_TAS_STATISTICS_RADIO,       IDH_DV_Settings_displayexisting,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CTypAdvStatPage

IMPLEMENT_DYNCREATE(CTypAdvStatPage, CVerifierPropertyPage)

CTypAdvStatPage::CTypAdvStatPage()
    : CVerifierPropertyPage( CTypAdvStatPage::IDD )
{
 	//{{AFX_DATA_INIT(CTypAdvStatPage)
	m_nCrtRadio = -1;
	//}}AFX_DATA_INIT
}


CTypAdvStatPage::~CTypAdvStatPage()
{
}

/////////////////////////////////////////////////////////////////////////////
//
// DDX support
//

void CTypAdvStatPage::DoDataExchange(CDataExchange* pDX) 
{
	CVerifierPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTypAdvStatPage)
	DDX_Control(pDX, IDC_TAS_NEXT_DESCR_STATIC, m_NextDescription);
	DDX_Radio(pDX, IDC_TAS_TYPICAL_RADIO, m_nCrtRadio);
	//}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////
//
// Message map
//

BEGIN_MESSAGE_MAP(CTypAdvStatPage, CVerifierPropertyPage)
	//{{AFX_MSG_MAP(CTypAdvStatPage)
	ON_BN_CLICKED(IDC_TAS_DELETE_RADIO, OnDeleteRadio)
	ON_BN_CLICKED(IDC_TAS_ADVANCED_RADIO, OnAdvancedRadio)
	ON_BN_CLICKED(IDC_TAS_STATISTICS_RADIO, OnStatisticsRadio)
	ON_BN_CLICKED(IDC_TAS_TYPICAL_RADIO, OnTypicalRadio)
	ON_BN_CLICKED(IDC_TAS_VIEWREGISTRY_RADIO, OnViewregistryRadio)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// All the property pages derived from this class should 
// provide these methods.
//

ULONG CTypAdvStatPage::GetDialogId() const
{
    return CTypAdvStatPage::IDD;
}

/////////////////////////////////////////////////////////////////////////////
// CTypAdvStatPage message handlers


LRESULT CTypAdvStatPage::OnWizardNext() 
{
    LRESULT lNextPageId;

    //
    // Kill a possible active worker thread
    //

    g_SlowProgressDlg.KillWorkerThread();

    //
    // Let's assume we cannot continue
    //

    lNextPageId = -1;

    if( UpdateData() == TRUE )
    {
        switch( m_nCrtRadio )
        {
        case IDC_TAS_TYPICAL_RADIO - FIRST_RADIO_BUTTON_ID:
            
            //
            // Set typical settings and go to driver selection page
            //

            g_NewVerifierSettings.m_SettingsBits.m_SettingsType = CSettingsBits::SettingsTypeTypical;
            g_NewVerifierSettings.m_SettingsBits.SetTypicalOnly();
            
            lNextPageId = IDD_DRVSET_PAGE;

            break;

        case IDC_TAS_ADVANCED_RADIO - FIRST_RADIO_BUTTON_ID:

            //
            // Start building custom settings (advanced, for developers)
            //

            g_NewVerifierSettings.m_SettingsBits.m_SettingsType = CSettingsBits::SettingsTypeCustom;

            lNextPageId = IDD_CUSTSETT_PAGE;

            break;

        case IDC_TAS_VIEWREGISTRY_RADIO - FIRST_RADIO_BUTTON_ID:

            //
            // Display the current registry settings
            //

            //
            // Load the current verified drivers string and flags from the registry
            //

            if( TRUE != VrtLoadCurrentRegistrySettings( g_bAllDriversVerified,
                                                        g_astrVerifyDriverNamesRegistry,
                                                        g_dwVerifierFlagsRegistry ) )
            {
                goto Done;
            }

            //
            // Look if we already have loaded the list of drivers
            // with version information, etc. and if we need it
            //

            if( TRUE != g_NewVerifierSettings.m_DriversSet.m_bDriverDataInitialized )
            {
                if( NULL == g_SlowProgressDlg.m_hWnd )
                {
                    //
                    // This is the first time we are showing the 
                    // "slow progress" dialog so create it first
                    //

                    g_SlowProgressDlg.Create( CSlowProgressDlg::IDD, AfxGetMainWnd() );
                }

                //
                // Show the dialog
                //

                g_SlowProgressDlg.ShowWindow( SW_SHOW );

                //
                // Start the worker thread to do the work in background
                // while the initial thread updates the GUI. If the thread ends
                // successfully it will press our "Next" button at the end, after setting
                // g_NewVerifierSettings.m_DriversSet.m_bDriverDataInitialized to TRUE
                //

                g_SlowProgressDlg.StartWorkerThread( CSlowProgressDlg::LoadDriverDataWorkerThread,
                                                     IDS_LOADING_DRIVER_INFORMATION );

                //
                // Wait for the "next" button again
                //

                goto Done;
            }

            //
            // We have already loaded information (name, version, etc.) about 
            // the currently loaded drivers if have gotten to this point.
            //
            // Go to the next page.
            //

            lNextPageId = IDD_CRT_REGISTRY_SETTINGS_PAGE;

            break;

        case IDC_TAS_STATISTICS_RADIO - FIRST_RADIO_BUTTON_ID:

            //
            // The user wants just statistics - nothing to change
            //
                
            lNextPageId = IDD_DRVSTATUS_STAT_PAGE;

            break;

        default:
            //
            // Oops. how did we get here?
            //
            // We shouldn't have had a "Next" button for the 
            // "delete settings" selection
            //

            ASSERT( FALSE );
        }
    }

    GoingToNextPageNotify( lNextPageId );

Done:
    return lNextPageId;
}

/////////////////////////////////////////////////////////////////////////////
void CTypAdvStatPage::OnDeleteRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_FINISH );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_DELETE );
}

void CTypAdvStatPage::OnAdvancedRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_CUSTOM );
}

void CTypAdvStatPage::OnStatisticsRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_STATISTICS );
}


void CTypAdvStatPage::OnTypicalRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_STANDARD );
}

void CTypAdvStatPage::OnViewregistryRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_REGISTRY );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CTypAdvStatPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

	return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CTypAdvStatPage::OnWizardFinish() 
{
    BOOL bFinish;
    INT nResponse;

    //
    // Kill a possible active worker thread
    //

    g_SlowProgressDlg.KillWorkerThread();


    bFinish = FALSE;

    if( TRUE == UpdateData( TRUE ) )
    {
        //
        // This must have been the "delete settings" selection
        // if we had a "Finish" button.
        //

        ASSERT( IDC_TAS_DELETE_RADIO - FIRST_RADIO_BUTTON_ID == m_nCrtRadio );

        nResponse = AfxMessageBox( IDS_DELETE_ALL_SETTINGS,
                                   MB_YESNO );
        
        if( IDYES == nResponse )
        {
            VrfDeleteAllVerifierSettings();

            if( FALSE != g_bSettingsSaved )
            {
                VrfMesssageFromResource( IDS_REBOOT );
            }
            else
            {
                VrfMesssageFromResource( IDS_NO_SETTINGS_WERE_CHANGED );
            }

            bFinish = CVerifierPropertyPage::OnWizardFinish();
        }
    }
	
	return bFinish;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CTypAdvStatPage::OnInitDialog() 
{
    //
    // Don't try to reconstruct the current data from the registry
    // to the GUI because it's too hard. Always start with the typical settings
    //

    m_nCrtRadio = IDC_TAS_TYPICAL_RADIO - FIRST_RADIO_BUTTON_ID;

    CVerifierPropertyPage::OnInitDialog();

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_STANDARD );
		
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////
LONG CTypAdvStatPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CTypAdvStatPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\slowdlg.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: SlowDlg.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "SlowDlg.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSlowProgressDlg dialog


CSlowProgressDlg::CSlowProgressDlg( CWnd* pParent /*=NULL*/ )
	: CDialog(CSlowProgressDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSlowProgressDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_hWorkerThread = NULL;

    //
    // Create the event used for killing the worker thread
    //

    m_hKillThreadEvent = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL );
}

CSlowProgressDlg::~CSlowProgressDlg()
{
    if( NULL != m_hKillThreadEvent )
    {
        CloseHandle( m_hKillThreadEvent );
    }
}

void CSlowProgressDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSlowProgressDlg)
	DDX_Control(pDX, IDC_UNSIGNED_PROGRESS, m_ProgressCtl);
	DDX_Control(pDX, IDC_UNSIGNED_STATIC, m_CurrentActionStatic);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSlowProgressDlg, CDialog)
	//{{AFX_MSG_MAP(CSlowProgressDlg)
	ON_BN_CLICKED(IDC_UNSIGNED_CANCEL_BUTTON, OnCancelButton)
	ON_WM_SHOWWINDOW()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CSlowProgressDlg::LoadDriverDataWorkerThread( PVOID p )
{
    CSlowProgressDlg *pThis;
    
    pThis = (CSlowProgressDlg *)p;
    
    //
    // Cannot ASSERT_VALID for a CWnd from a thread that didn't create the window in MFC...
    //
    
    ASSERT( NULL != pThis );
    
    //
    // Load all the drivers information (name, version, etc.)
    // if we haven't don that already
    //

    g_NewVerifierSettings.m_DriversSet.LoadAllDriversData( pThis->m_hKillThreadEvent,
                                                           pThis->m_ProgressCtl );

    //
    // Done - hide the "slow progress" dialog and press the wizard "next" button
    //

    pThis->ShowWindow( SW_HIDE );

    if( g_NewVerifierSettings.m_DriversSet.m_bDriverDataInitialized )
    {
        AfxGetMainWnd()->PostMessage(PSM_PRESSBUTTON, (WPARAM)PSBTN_NEXT, 0) ;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CSlowProgressDlg::SearchUnsignedDriversWorkerThread( PVOID p )
{
    CSlowProgressDlg *pThis;
    
    pThis = (CSlowProgressDlg *)p;
    
    //
    // Cannot ASSERT_VALID for a CWnd from a thread that didn't create the window in MFC...
    //
    
    ASSERT( NULL != pThis );
   
    //
    // Find out the unsigned drivers if we didn't do that already
    //

    g_NewVerifierSettings.m_DriversSet.FindUnsignedDrivers( pThis->m_hKillThreadEvent,
                                                                  pThis->m_ProgressCtl );

    //
    // Done - hide the "slow progress" dialog and press the wizard "next" button
    //

    pThis->ShowWindow( SW_HIDE );

    if( g_NewVerifierSettings.m_DriversSet.m_bUnsignedDriverDataInitialized )
    {
        AfxGetMainWnd()->PostMessage(PSM_PRESSBUTTON, (WPARAM)PSBTN_NEXT, 0) ;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSlowProgressDlg::StartWorkerThread( LPTHREAD_START_ROUTINE pThreadStart,
                                          ULONG uMessageResourceId )
{
    DWORD dwThreadId;
    CString strWorkMessage;

    //
    // Load a description of the current "work item"
    // and show it to the user
    //

    VERIFY( strWorkMessage.LoadString( uMessageResourceId ) );
    m_CurrentActionStatic.SetWindowText( strWorkMessage );
    m_CurrentActionStatic.RedrawWindow();

    //
    // Kill a possible currently running worker thread
    //

    KillWorkerThread();

    ASSERT( NULL == m_hWorkerThread );
    
    //
    // Make sure the "kill thread" event is not signaled
    //

    if( NULL != m_hKillThreadEvent )
    {
        ResetEvent( m_hKillThreadEvent );
    }

    //
    // Create the new worker thread
    //

    m_hWorkerThread = CreateThread( 
        NULL,
        0,
        pThreadStart,
        this,
        0,
        &dwThreadId );

    if( NULL == m_hWorkerThread )
    {
        //
        // Could not create the worker thread - bail out
        //

        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

        PostMessage( WM_COMMAND,
                     IDC_UNSIGNED_CANCEL_BUTTON );

        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
VOID CSlowProgressDlg::KillWorkerThread()
{
    DWORD dwWaitResult;
    MSG msg;

    if( NULL != m_hWorkerThread )
    {
        if( NULL != m_hKillThreadEvent )
        {
            //
            // Ask the worker thread to die asap
            //

            SetEvent( m_hKillThreadEvent );
        }

        //
        // Wait forever for a decent death from the worker thread.
        //
        // We cannot TerminateThread on our worker thread because
        // it could be killed while holding locks (e.g. the heap lock)
        // and that would deadlock our whole process.
        //

        while( m_hWorkerThread != NULL )
        {
            dwWaitResult = MsgWaitForMultipleObjects( 1,
                                                      &m_hWorkerThread, 
                                                      FALSE,
                                                      INFINITE,
                                                      QS_ALLINPUT );

            ASSERT( NULL != WAIT_FAILED );

            if( WAIT_OBJECT_0 != dwWaitResult )
            {
                //
                // Our thread didn't exit but we have some messages to dispatch.
                //

                while( PeekMessage( &msg, NULL, NULL, NULL, PM_REMOVE ) )
                {
                    TranslateMessage( &msg );
                    DispatchMessage( &msg );
                }

                //
                // During the DispatchMessage above we could process another 
                // click of the Cancel button or the Back button of the wizard. 
                // The KillWorkerThread recursive call will wait until the worker 
                // thread dies then will sets m_hWorkerThread to NULL. 
                // So we need to check for m_hWorkerThread != NULL before each new
                // MsgWaitForMultipleObjects.
                //
            }
            else
            {
                //
                // The worker thread finished execution.
                //

                break;
            }
        }

        if( m_hWorkerThread != NULL )
        {
            //
            // Close the thread handle
            //

            CloseHandle( m_hWorkerThread );

            m_hWorkerThread = NULL;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CSlowProgressDlg message handlers

void CSlowProgressDlg::OnCancelButton() 
{
    KillWorkerThread();

    ShowWindow( SW_HIDE );
}

/////////////////////////////////////////////////////////////////////////////
void CSlowProgressDlg::OnShowWindow(BOOL bShow, UINT nStatus) 
{
    CDialog::OnShowWindow(bShow, nStatus);
	
    if( TRUE == bShow )
    {
        CenterWindow();
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSlowProgressDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\taspage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: paspage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_TASPAGE_H__6F4DFFE1_A07F_403D_A580_CCB25C729FC2__INCLUDED_)
#define AFX_TASPAGE_H__6F4DFFE1_A07F_403D_A580_CCB25C729FC2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// taspage.h : header file
//

#include "vsetting.h"
#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTypAdvStatPage

class CTypAdvStatPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CTypAdvStatPage)

public:
    //
    // Construction/destruction
    //

    CTypAdvStatPage();
    ~CTypAdvStatPage();


    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }


protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const;

    //
	// ClassWizard generated virtual function overrides
    //

	//{{AFX_VIRTUAL(CTypAdvStatPage)
	public:
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);
	//}}AFX_VIRTUAL

    //
    // Dialog Data
    //

    //{{AFX_DATA(CTypAdvStatPage)
	enum { IDD = IDD_TAS_PAGE };
	CStatic	m_NextDescription;
	int		m_nCrtRadio;
	//}}AFX_DATA

protected:
    //
    // Generated message map functions
    //

    //{{AFX_MSG(CTypAdvStatPage)
	afx_msg void OnDeleteRadio();
	afx_msg void OnAdvancedRadio();
	afx_msg void OnStatisticsRadio();
	afx_msg void OnTypicalRadio();
	virtual BOOL OnInitDialog();
	afx_msg void OnViewregistryRadio();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TASPAGE_H__6F4DFFE1_A07F_403D_A580_CCB25C729FC2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\verfpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VerfPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"
#include "VerfPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Previous page IDs - used for implementing the "back"
// button functionality
//

CPtrArray g_aPageIds;

//
// The one and only "slow progress" dialog
//

CSlowProgressDlg g_SlowProgressDlg;

/////////////////////////////////////////////////////////////////////////////
// CVerifierPropertyPage property page

IMPLEMENT_DYNAMIC(CVerifierPropertyPage, CPropertyPage)

CVerifierPropertyPage::CVerifierPropertyPage(ULONG uDialogId) : 
    CPropertyPage( uDialogId )
{
	//{{AFX_DATA_INIT(CVerifierPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CVerifierPropertyPage::~CVerifierPropertyPage()
{
}

BEGIN_MESSAGE_MAP(CVerifierPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CVerifierPropertyPage)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
ULONG CVerifierPropertyPage::GetDialogId() const
{ 
    //
    // Oops, how did we get here ?!?
    // This is a virtual pure function.
    //

    //ASSERT( FALSE ); 

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
// Return the previous page ID, based on our history array
// and remove it from the array because will activate. Called
// by our property pages when the "back" button is clicked
//

ULONG CVerifierPropertyPage::GetAndRemovePreviousDialogId()
{
    ULONG uPrevId;
    INT_PTR nPageIdsArraySize;

    nPageIdsArraySize = g_aPageIds.GetSize();

    ASSERT( nPageIdsArraySize > 0 );

    uPrevId = PtrToUlong( g_aPageIds.GetAt( nPageIdsArraySize - 1 ) );

    g_aPageIds.RemoveAt( nPageIdsArraySize - 1 ); 

    return uPrevId;
}

/////////////////////////////////////////////////////////////////////////////
//
// Property pages derived from this class should notify us 
// whenever we go to a next page to record the current page ID in 
// the global array g_aPageIds
//

VOID CVerifierPropertyPage::GoingToNextPageNotify( LRESULT lNextPageId )
{
    ULONG uMyDialogId;

    if( -1 != lNextPageId )
    {
        //
        // Will go to the next page. Add our ID to the global IDs array 
        // used for implementing the "back" button functionality.
        //

        uMyDialogId = GetDialogId();

        ASSERT( ( 0 == g_aPageIds.GetSize() ) || ( ULongToPtr( uMyDialogId ) != g_aPageIds.GetAt( g_aPageIds.GetSize() - 1 ) ) );

        g_aPageIds.Add( ULongToPtr( uMyDialogId ) );
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Use this to kill any currently running worker threads
//

BOOL CVerifierPropertyPage::OnQueryCancel( )
{
    g_SlowProgressDlg.KillWorkerThread();

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
LRESULT CVerifierPropertyPage::OnWizardBack() 
{
    return GetAndRemovePreviousDialogId();
}

/////////////////////////////////////////////////////////////////////////////
// CVerifierPropertyPage message handlers

BOOL CVerifierPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\vglobal.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VGlobal.cpp
// author: DMihai
// created: 11/1/00
//
// Description
//

#include "stdafx.h"
#include "verifier.h"

#include "vglobal.h"
#include "VrfUtil.h"

//
// Help file name
//

TCHAR g_szVerifierHelpFile[] = _T( "verifier.hlp" );

//
// Application name ("Driver Verifier Manager")
//

CString g_strAppName;

//
// Exe module handle - used for loading resources
//

HMODULE g_hProgramModule;

//
// GUI mode or command line mode?
//

BOOL g_bCommandLineMode = FALSE;

//
// Brush used to fill out the background of our steps lists
//

HBRUSH g_hDialogColorBrush = NULL;

//
// Path to %windir%\system32
//

CString g_strSystemDir;

//
// Path to %windir%\system32\drivers
//

CString g_strDriversDir;

//
// Initial current directory
//

CString g_strInitialCurrentDirectory;

//
// Filled out by CryptCATAdminAcquireContext
//

HCATADMIN g_hCatAdmin = NULL;

//
// Highest user address - used to filter out user-mode stuff
// returned by NtQuerySystemInformation ( SystemModuleInformation )
//

PVOID g_pHighestUserAddress;

//
// Did we enable the debug privilege already?
//

BOOL g_bPrivilegeEnabled = FALSE;

//
// Need to reboot ?
//

BOOL g_bSettingsSaved = FALSE;

//
// Dummy text used to insert an item in a list control with checkboxes
//

TCHAR g_szVoidText[] = _T( "" );

//
// New registry settings
//

CVerifierSettings   g_NewVerifierSettings;

//
// Are all drivers verified? (loaded from the registry)
//

BOOL g_bAllDriversVerified;

//
// Drivers to be verified names (loaded from the registry)
// We have data in this array only if g_bAllDriversVerified == FALSE.
//

CStringArray g_astrVerifyDriverNamesRegistry;

//
// Verifier flags (loaded from the registry)
//

DWORD g_dwVerifierFlagsRegistry;

//
// Old disk integrity verifier settings.
//

CDiskDataArray g_OldDiskData;

//
// Disk verifier filter name.
//

TCHAR g_szFilter[] = _T( "crcdisk" );

//
// Show the disk selection page or not. 
// Used to force displaying this property page even when
// no disk in g_NewVerifierSettings.m_aDiskData has the 
// verifier flag turned on.
// 

BOOL g_bShowDiskPropertyPage = FALSE;


////////////////////////////////////////////////////////////////
BOOL VerifInitalizeGlobalData( VOID )
{
    BOOL bSuccess;
    LPTSTR szDirectory;
    ULONG uCharacters;
    MEMORYSTATUSEX MemoryStatusEx;

    //
    // Exe module handle - used for loading resources
    //

    g_hProgramModule = GetModuleHandle( NULL );

	bSuccess = FALSE;

	//
	// Load the app name from the resources
	//

	TRY
	{
		bSuccess = VrfLoadString( IDS_APPTITLE,
                                  g_strAppName );

		if( FALSE == bSuccess )
		{
			VrfErrorResourceFormat( IDS_CANNOT_LOAD_APP_TITLE );
		}
	}
	CATCH( CMemoryException, pMemException )
	{
		VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
	}
    END_CATCH

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Save the %windir%\system32 and %windir%\system32\drivers 
    // paths in some global variables
    //

    szDirectory = g_strSystemDir.GetBuffer( MAX_PATH );

    if( NULL == szDirectory )
    {
        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

        goto Done;
    }

    uCharacters = GetSystemDirectory( szDirectory,
                                      MAX_PATH );

    g_strSystemDir.ReleaseBuffer();

    if( uCharacters == 0 || uCharacters >= MAX_PATH )
    {
        VrfErrorResourceFormat( IDS_CANNOT_GET_SYSTEM_DIRECTORY );

        bSuccess = FALSE;

        goto Done;
    }

    g_strDriversDir = g_strSystemDir + "\\drivers" ;

    //
    // Save the initial current directory
    //

    szDirectory = g_strInitialCurrentDirectory.GetBuffer( MAX_PATH );

    if( NULL == szDirectory )
    {
        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

        goto Done;
    }

    uCharacters = GetCurrentDirectory( MAX_PATH,
                                       szDirectory );

    g_strInitialCurrentDirectory.ReleaseBuffer();

    if( uCharacters == 0 || uCharacters >= MAX_PATH )
    {
        VrfErrorResourceFormat( IDS_CANNOT_GET_CURRENT_DIRECTORY );

        bSuccess = FALSE;

        goto Done;
    }

    //
    // We need the highest user-mode address to filter out user-mode stuff
    // returned by NtQuerySystemInformation ( SystemModuleInformation )
    //

    ZeroMemory( &MemoryStatusEx,
                sizeof( MemoryStatusEx ) );

    MemoryStatusEx.dwLength = sizeof( MemoryStatusEx );

    bSuccess = GlobalMemoryStatusEx( &MemoryStatusEx );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    g_pHighestUserAddress = (PVOID) MemoryStatusEx.ullTotalVirtual;

    //
    // Initialize the list of physical disks.
    //

    bSuccess = g_OldDiskData.InitializeDiskList();
    if( FALSE == bSuccess )
    {
        goto Done;
    }

    g_NewVerifierSettings.m_aDiskData = g_OldDiskData;

    //
    // Always start with fresh data (don't verify any disks).
    //

    g_NewVerifierSettings.m_aDiskData.SetVerifyAllDisks( FALSE );

Done:

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\vglobal.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VGlobal.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#ifndef __VGLOBAL_H_INCLUDED__
#define __VGLOBAL_H_INCLUDED__

#include "vsheet.h"

//
// Help file name
//

extern TCHAR g_szVerifierHelpFile[];

//
// Application name ("Driver Verifier Manager")
//

extern CString g_strAppName;

//
// Exe module handle - used for loading resources
//

extern HMODULE g_hProgramModule;

//
// GUI mode or command line mode?
//

extern BOOL g_bCommandLineMode;

//
// Brush used to fill out the background of our steps lists
//

extern HBRUSH g_hDialogColorBrush;

//
// Path to %windir%\system32
//

extern CString g_strSystemDir;

//
// Path to %windir%\system32\drivers
//

extern CString g_strDriversDir;

//
// Initial current directory
//

extern CString g_strInitialCurrentDirectory;

//
// Filled out by CryptCATAdminAcquireContext
//

extern HCATADMIN g_hCatAdmin;

//
// Highest user address - used to filter out user-mode stuff
// returned by NtQuerySystemInformation ( SystemModuleInformation )
//

extern PVOID g_pHighestUserAddress;

//
// Did we enable the debug privilege already?
//

extern BOOL g_bPrivilegeEnabled;

//
// Need to reboot ?
//

extern BOOL g_bSettingsSaved;

//
// Dummy text used to insert an item in a list control with checkboxes
//

extern TCHAR g_szVoidText[];

//
// New registry settings
//

extern CVerifierSettings   g_NewVerifierSettings;

//
// Are all drivers verified? (loaded from the registry)
//

extern BOOL g_bAllDriversVerified;

//
// Drivers to be verified names (loaded from the registry)
// We have data in this array only if g_bAllDriversVerified == FALSE.
//

extern CStringArray g_astrVerifyDriverNamesRegistry;

//
// Verifier flags (loaded from the registry)
//

extern DWORD g_dwVerifierFlagsRegistry;

//
// Old disk integrity verifier settings.
//

extern CDiskDataArray g_OldDiskData;

//
// Disk verifier filter name.
//

extern TCHAR g_szFilter[];

//
// Show the disk selection page or not. 
// Used to force displaying this property page even when
// no disk in g_NewVerifierSettings.m_aDiskData has the 
// verifier flag turned on.
// 

extern BOOL g_bShowDiskPropertyPage;

////////////////////////////////////////////////////////////////
BOOL VerifInitalizeGlobalData( VOID );

#endif //#ifndef __VGLOBAL_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\vbitsdlg.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VBitsDlg.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//


#include "stdafx.h"
#include "verifier.h"

#include "VBitsDlg.h"
#include "VGlobal.h"
#include "VrfUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVolatileBitsDlg dialog


CVolatileBitsDlg::CVolatileBitsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CVolatileBitsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CVolatileBitsDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CVolatileBitsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVolatileBitsDlg)
	DDX_Control(pDX, IDC_VOLBITS_LIST, m_SettingsList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVolatileBitsDlg, CDialog)
	//{{AFX_MSG_MAP(CVolatileBitsDlg)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
VOID CVolatileBitsDlg::SetupListHeader()
{
    CString strTitle;
    CRect rectWnd;
    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_SettingsList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
               sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0
    //

    VERIFY( strTitle.LoadString( IDS_ENABLED_QUESTION ) );

    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.20 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_SettingsList.InsertColumn( 0, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_SettingsList.InsertColumn( 0, &lvColumn ) != -1 );
    }

    //
    // Column 1
    //

    VERIFY( strTitle.LoadString( IDS_SETTING ) );

    lvColumn.iSubItem = 1;
    lvColumn.cx = (int)( rectWnd.Width() * 0.79 );
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if (NULL != lvColumn.pszText)
    {
        VERIFY( m_SettingsList.InsertColumn( 1, &lvColumn ) != -1 );
        strTitle.ReleaseBuffer();
    }
    else
    {
        lvColumn.pszText = g_szVoidText;
        VERIFY( m_SettingsList.InsertColumn( 1, &lvColumn ) != -1 );
    }
}

/////////////////////////////////////////////////////////////////////////////
VOID CVolatileBitsDlg::FillTheList( DWORD dwVerifierBits )
{
    //
    // N.B.
    //
    // If you change this order then you need to
    // change GetNewVerifierFlags as well
    //

    AddListItem( IDS_SPECIAL_POOL,          ( ( dwVerifierBits & DRIVER_VERIFIER_SPECIAL_POOLING ) != 0 ) );
    AddListItem( IDS_FORCE_IRQL_CHECKING,   ( ( dwVerifierBits & DRIVER_VERIFIER_FORCE_IRQL_CHECKING ) != 0 ) );
    AddListItem( IDS_LOW_RESOURCE_SIMULATION,( ( dwVerifierBits & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES ) != 0 ) );
}

/////////////////////////////////////////////////////////////////////////////
DWORD CVolatileBitsDlg::GetNewVerifierFlags()
{
    //
    // N.B.
    //
    // If you change this order then you need to
    // change FillTheList as well
    //

    DWORD dwNewFlags;

    dwNewFlags = 0;

    if( m_SettingsList.GetCheck( 0 ) )
    {
        dwNewFlags |= DRIVER_VERIFIER_SPECIAL_POOLING;
    }

    if( m_SettingsList.GetCheck( 1 ) )
    {
        dwNewFlags |= DRIVER_VERIFIER_FORCE_IRQL_CHECKING;
    }

    if( m_SettingsList.GetCheck( 2 ) )
    {
        dwNewFlags |= DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES;
    }

    return dwNewFlags;
}

/////////////////////////////////////////////////////////////////////////////
VOID CVolatileBitsDlg::AddListItem( ULONG uIdResourceString, BOOL bInitiallyEnabled )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strName;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - enabled/diabled - empty text and a checkbox
    //

    lvItem.pszText = g_szVoidText;
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = m_SettingsList.GetItemCount();

    nActualIndex = m_SettingsList.InsertItem( &lvItem );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    m_SettingsList.SetCheck( nActualIndex, bInitiallyEnabled );

    //
    // Sub-item 1 - feature name
    //

    VERIFY( strName.LoadString( uIdResourceString ) );

    lvItem.pszText = strName.GetBuffer( strName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;
    
    VERIFY( m_SettingsList.SetItem( &lvItem ) );

    strName.ReleaseBuffer();

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
// CVolatileBitsDlg message handlers

BOOL CVolatileBitsDlg::OnInitDialog() 
{
    CRuntimeVerifierData RuntimeVerifierData;
    
    //
    // Start with the current settings
    //

    VrfGetRuntimeVerifierData( &RuntimeVerifierData );

	CDialog::OnInitDialog();

    m_SettingsList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES | m_SettingsList.GetExtendedStyle() );

    SetupListHeader();
    FillTheList( RuntimeVerifierData.Level );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CVolatileBitsDlg::OnOK() 
{
    DWORD dwNewVerifierBits;

    dwNewVerifierBits = GetNewVerifierFlags();

    if( VrfSetNewFlagsVolatile( dwNewVerifierBits ) )
    {
		CDialog::OnOK();
    }

    //
    // If VrfSetNewFlagsVolatile fails we wait for the Cancel button
    //
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVolatileBitsDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\vbitsdlg.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VBitsDlg.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#if !defined(AFX_VBITSDLG_H__AEF2E123_B664_41DC_9257_21CA6DF54CF6__INCLUDED_)
#define AFX_VBITSDLG_H__AEF2E123_B664_41DC_9257_21CA6DF54CF6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// VBitsDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CVolatileBitsDlg dialog

class CVolatileBitsDlg : public CDialog
{
public:
    //
    // Construction
    //

	CVolatileBitsDlg(CWnd* pParent = NULL);   // standard constructor

protected:
    //
    // Methods
    //

    VOID SetupListHeader();
    VOID FillTheList( DWORD dwVerifierBits );
    VOID AddListItem( ULONG uIdResourceString, BOOL bInitiallyEnabled );

    DWORD GetNewVerifierFlags();

protected:
    //
    // Data
    //

    //
    // Dialog Data
    //

	//{{AFX_DATA(CVolatileBitsDlg)
	enum { IDD = IDD_VOLATILE_BITS_DIALOG };
	CListCtrl	m_SettingsList;
	//}}AFX_DATA


protected:
    //
    // Overrides
    //

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVolatileBitsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CVolatileBitsDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VBITSDLG_H__AEF2E123_B664_41DC_9257_21CA6DF54CF6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\verfpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VerfPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_VERFPAGE_H__FCFF7AE3_57F4_4762_BEBD_F84C571B533A__INCLUDED_)
#define AFX_VERFPAGE_H__FCFF7AE3_57F4_4762_BEBD_F84C571B533A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// VerfPage.h : header file
//

#include "SlowDlg.h"

//
// The one and only "slow progress" dialog
//

extern CSlowProgressDlg g_SlowProgressDlg;

/////////////////////////////////////////////////////////////////////////////
// CVerifierPropertyPage dialog

class CVerifierPropertyPage : public CPropertyPage
{
    DECLARE_DYNAMIC(CVerifierPropertyPage)

// Construction
public:
	CVerifierPropertyPage( ULONG uDialogId );
	~CVerifierPropertyPage();

protected:
    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const = 0;

    //
    // Return the previous page ID, based on our history array
    // and remove it from the array because will activate. Called
    // by our property pages when the "back" button is clicked
    //

    ULONG GetAndRemovePreviousDialogId();

    //
    // Property pages derived from this class should notify us 
    // whenever we go to a next page to record the current page ID in 
    // the global array m_aPageIds
    //

    VOID GoingToNextPageNotify( LRESULT lNextPageId );

protected:
    //
    // Overrides
    //

    //
    // Use this to kill any currently running worker threads
    //

    virtual BOOL OnQueryCancel( );

    //
	// ClassWizard generate virtual function overrides
    //

	//{{AFX_VIRTUAL(CVerifierPropertyPage)
	virtual LRESULT OnWizardBack();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CVerifierPropertyPage)
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VERFPAGE_H__FCFF7AE3_57F4_4762_BEBD_F84C571B533A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\verifier.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: verifier.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  
// Main header file for the VERIFIER application
//

#if !defined(AFX_VERIFIER_H__0B3398A6_AD3D_482C_B915_670BA4D7F6E1__INCLUDED_)
#define AFX_VERIFIER_H__0B3398A6_AD3D_482C_B915_670BA4D7F6E1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols


//
// Exit codes for cmd line execution
//

#define EXIT_CODE_SUCCESS       0
#define EXIT_CODE_ERROR         1
#define EXIT_CODE_REBOOT_NEEDED 2


/////////////////////////////////////////////////////////////////////////////
// CVerifierApp:
// See verifier.cpp for the implementation of this class
//

class CVerifierApp : public CWinApp
{
public:
	CVerifierApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVerifierApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CVerifierApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VERIFIER_H__0B3398A6_AD3D_482C_B915_670BA4D7F6E1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\verifier.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: verifier.cpp 
// author: DMihai
// created: 11/1/00
//
// Description
//
// Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "verifier.h"

#include "vsheet.h"
#include "vrfutil.h"
#include "vglobal.h"
#include "CmdLine.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVerifierApp

BEGIN_MESSAGE_MAP(CVerifierApp, CWinApp)
	//{{AFX_MSG_MAP(CVerifierApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVerifierApp construction

CVerifierApp::CVerifierApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance

    CString strAppName;

    if( VrfLoadString( IDS_APPTITLE, strAppName ) )
    {
        m_pszAppName = _tcsdup( (LPCTSTR)strAppName );
    }
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CVerifierApp object

CVerifierApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CVerifierApp initialization

BOOL CVerifierApp::InitInstance()
{
	DWORD dwExitCode;
    BOOL bGlobalDataInitialized;
    static CVerifierPropSheet MainDlg;

	//
	// Assume program will run fine and will not change any settings
	//

	dwExitCode = EXIT_CODE_SUCCESS;

    bGlobalDataInitialized = VerifInitalizeGlobalData();

	if( TRUE != bGlobalDataInitialized )
	{
		//
		// Cannot run the app
		//

		dwExitCode = EXIT_CODE_ERROR;

		goto ExitApp;
	}

    //
    // Check for command line arguments
    //

    if( __argc > 1 )
    {
        //
        // Run just in command line mode
        //

        _tsetlocale( LC_ALL, _T( ".OCP" ) );

        g_bCommandLineMode = TRUE;

        dwExitCode = CmdLineExecute( __argc, __targv );

        goto ExitApp;
    }
    else
    {
        FreeConsole();
    }

	//
	// Standard MFC initialization
	//

	AfxEnableControlContainer();

    //
    // Create our brush used to fill out the background of our steps lists
    //

    g_hDialogColorBrush = GetSysColorBrush( COLOR_3DFACE );

    //
    // There is only one property sheet in this program so we declared it static
    //

	m_pMainWnd = &MainDlg;
	
	MainDlg.DoModal();

    if( g_bSettingsSaved )
    {
        dwExitCode = EXIT_CODE_REBOOT_NEEDED;
    }
    else
    {
        dwExitCode = EXIT_CODE_SUCCESS;
    }
    
    goto ExitApp;

ExitApp:

    //
    // All done, exit the app
    //
	
	exit( dwExitCode );

    //
    // not reached
    // 

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\vrfutil.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VrfUtil.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#ifndef __VRF_UTIL_H_INCLUDED__
#define __VRF_UTIL_H_INCLUDED__

//
// ARRAY_LENGTH macro
//

#ifndef ARRAY_LENGTH
#define ARRAY_LENGTH( array )   ( sizeof( array ) / sizeof( array[ 0 ] ) )
#endif //#ifndef ARRAY_LENGTH

//
// Forward declarations
//

class CRuntimeVerifierData;

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message format string is loaded from the resources.
//

void __cdecl VrfErrorResourceFormat( UINT uIdResourceFormat,
                                     ... );

///////////////////////////////////////////////////////////////////////////
//
// Print out a message to the console
// The message string is loaded from the resources.
//

void __cdecl VrfTPrintfResourceFormat( UINT uIdResourceFormat,
                                       ... );

///////////////////////////////////////////////////////////////////////////
//
// Print out a simple (non-formatted) message to the console
// The message string is loaded from the resources.
//

void __cdecl VrfPrintStringFromResources( UINT uIdString );

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message string is loaded from the resources.
//

void __cdecl VrfMesssageFromResource( UINT uIdString );


///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//
// N.B. CString::LoadString doesn't work in cmd line mode
//

BOOL VrfLoadString( ULONG uIdResource,
                    TCHAR *szBuffer,
                    ULONG uBufferLength );

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//
// N.B. CString::LoadString doesn't work in cmd line mode
//

BOOL VrfLoadString( ULONG uIdResource,
                    CString &strText );

///////////////////////////////////////////////////////////////////////////
VOID CopyStringArray( const CStringArray &strArraySource,
                      CStringArray &strArrayDest );


/////////////////////////////////////////////////////////////////////////////
BOOL IsDriverSigned( LPCTSTR szDriverName );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfSetWindowText( CWnd &Wnd,
                       ULONG uIdResourceString );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfWriteVerifierSettings( BOOL bHaveNewDrivers,
                               const CString &strDriversToVerify,
                               BOOL bHaveNewFlags,
                               DWORD dwVerifyFlags );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfWriteRegistryDwordValue( HKEY hKey,
                                 LPCTSTR szValueName,
                                 DWORD dwValue );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfWriteRegistryStringValue( HKEY hKey,
                                  LPCTSTR szValueName,
                                  LPCTSTR szValue );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfReadVerifierSettings( CString &strDriversToVerify,
                              DWORD &dwVerifyFlags );

/////////////////////////////////////////////////////////////////////////////
BOOL VrtLoadCurrentRegistrySettings( BOOL &bAllDriversVerified,
                                     CStringArray &astrDriversToVerify,
                                     DWORD &dwVerifyFlags );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsDriversSetDifferent( CString strAllDrivers1, 
                               const CStringArray &astrVerifyDriverNames2 );

/////////////////////////////////////////////////////////////////////////////
VOID VrfSplitDriverNamesSpaceSeparated( CString strAllDrivers,
                                        CStringArray &astrVerifyDriverNames );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfReadRegistryDwordValue( HKEY hKey,
                                LPCTSTR szValueName,
                                DWORD &dwValue );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfReadRegistryStringValue( HKEY hKey,
                                 LPCTSTR szValueName,
                                 CString &strDriversToVerify );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfDeleteAllVerifierSettings();

/////////////////////////////////////////////////////////////////////////////
BOOL DeleteAllDiskVerifierSettings();

/////////////////////////////////////////////////////////////////////////////
BOOL VrfGetRuntimeVerifierData( CRuntimeVerifierData *pRuntimeVerifierData );

/////////////////////////////////////////////////////////////////////////////
PLOADED_IMAGE VrfImageLoad( LPTSTR szBinaryName,
                            LPTSTR szDirectory );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfDumpStateToFile( FILE *file );
                         
/////////////////////////////////////////////////////////////////////////////
BOOL __cdecl VrfFTPrintf( FILE *file,
                          LPCTSTR szFormat,
                          ... );

/////////////////////////////////////////////////////////////////////////////
BOOL __cdecl VrfFTPrintfResourceFormat( FILE *file,
                                        UINT uIdResourceFormat,
                                        ... );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfOuputStringFromResources( UINT uIdString,
                                  FILE *file );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfSetNewFlagsVolatile( DWORD dwNewFlags );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfAddDriversVolatile( const CStringArray &astrNewDrivers );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfAddDriverVolatile( const CString &strCrtDriver );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfRemoveDriversVolatile( const CStringArray &astrNewDrivers );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfRemoveDriverVolatile( const CString &strDriverName );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfEnableDebugPrivilege();

/////////////////////////////////////////////////////////////////////////////
VOID VrfDumpChangedSettings( UINT OldFlags,
                             UINT NewFlags,
                             INT_PTR nDriversVerified );

/////////////////////////////////////////////////////////////////////////////
DWORD VrfGetStandardFlags();

/////////////////////////////////////////////////////////////////////////////
VOID VrfAddMiniports( CStringArray &astrVerifiedDrivers );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsDriverMiniport( CString &strCrtDriver,
                          CString &strLinkedDriver );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsDriverMiniport( PLOADED_IMAGE pLoadedImage,
                          CString &strLinkedDriver );

/////////////////////////////////////////////////////////////////////////////
VOID VrfDumpRegistrySettingsToConsole();

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsNameAlreadyInList( LPCTSTR szDriver,
                             LPCTSTR szAllDrivers );

/////////////////////////////////////////////////////////////////////////////
VOID VrfAddDriverNameNoDuplicates( LPCTSTR szDriver,
                                   CString &strAllDrivers );        

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsStringInArray( LPCTSTR szText,
                         const CStringArray &astrAllTexts );

#endif //#ifndef __VRF_UTIL_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\vsheet.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VSheet.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_VSHEET_H__74939F02_3402_4E14_8B25_6B791960958B__INCLUDED_)
#define AFX_VSHEET_H__74939F02_3402_4E14_8B25_6B791960958B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "vsetting.h"
#include "taspage.h"
#include "dsetpage.h"
#include "csetpage.h"
#include "CDLPage.h"
#include "SDrvPage.h"
#include "FLPage.h"
#include "DStsPage.h"
#include "RegPage.h"
#include "GCntPage.h"
#include "DCntPage.h"
#include "DCntPage.h"
#include "DiskPage.h"

/////////////////////////////////////////////////////////////////////////////
// CVerifierPropSheet dialog

class CVerifierPropSheet : public CPropertySheet
{
// Construction
public:
	CVerifierPropSheet();	

protected:
	HICON m_hIcon;

	//
	// Typical Settings/Advanced Settings/Statistics page
	//

    CTypAdvStatPage     m_TypAdvStatPage;

    //
    // Driver Set page
    //

    CDriverSetPage      m_DriverSetPage;

    //
    // Custom Settings page
    //

    CCustSettPage       m_CustSettPage;

    //
    // Confirm the list of verified drivers page
    //

    CConfirmDriverListPage m_ConfDriversListPage;

    //
    // Select custom set of drivers page
    //

    CSelectDriversPage  m_SelectDriversPage;

    //
    // Full list of settings page
    //

    CFullListSettingsPage m_FullListSettingsPage;

    //
    // Driver Status page
    //

    CDriverStatusPage m_DriverStatusPage;

    //
    // Current registry settings page
    //

    CCrtRegSettingsPage m_CrtRegSettingsPage;

    //
    // Global counters page
    //

    CGlobalCountPage m_GlobalCountPage;

    //
    // Per-driver counters page
    //

    CDriverCountersPage m_DriverCountersPage;

    //
    // Disks to verify list page.
    //

    CDiskListPage m_DiskListPage;

    //
    // Dialog Data
    //

    //{{AFX_DATA(CVerifierPropSheet)
	    // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

public:

    BOOL SetContextStrings( ULONG uTitleResId );

    VOID HideHelpButton();

protected:
    //
    // Methods
    //


    //
    // ClassWizard generated virtual function overrides
    //

    //{{AFX_VIRTUAL(CVerifierPropSheet)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
    virtual BOOL OnInitDialog();
    //}}AFX_VIRTUAL

    //
    // Generated message map functions
    //

    //{{AFX_MSG(CVerifierPropSheet)
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VSHEET_H__74939F02_3402_4E14_8B25_6B791960958B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\vsetting.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VSetting.cpp
// author: DMihai
// created: 11/1/00
//
// Description
//
// Implementation of the CVerifierSettings class.
//


#include "stdafx.h"
#include "verifier.h"

#include "VSetting.h"
#include "VrfUtil.h"
#include "VGlobal.h"
#include "disk.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// CDriverData Class
//////////////////////////////////////////////////////////////////////
CDriverData::CDriverData()
{
    m_SignedStatus = SignedNotVerifiedYet;
    m_VerifyDriverStatus = VerifyDriverNo;
}

CDriverData::CDriverData( const CDriverData &DriverData )
{
    m_strName           = DriverData.m_strName;
    m_SignedStatus      = DriverData.m_SignedStatus;
    m_VerifyDriverStatus= DriverData.m_VerifyDriverStatus;
}

CDriverData::CDriverData( LPCTSTR szDriverName )
{
    m_SignedStatus = SignedNotVerifiedYet;
    m_VerifyDriverStatus = VerifyDriverNo;

    m_strName = szDriverName;
}

CDriverData::~CDriverData()
{
}

//////////////////////////////////////////////////////////////////////
BOOL CDriverData::LoadDriverHeaderData()
{
    //
    // N.B. 
    //
    // The imagehlp functions are not multithreading safe 
    // (see Whistler bug #88373) so if we want to use them from more than
    // one thread we will have to aquire some critical section before.
    //
    // Currently only one thread is using the imagehlp APIs in this app
    // (CSlowProgressDlg::LoadDriverDataWorkerThread) so we don't need
    // our synchronization.
    //

    LPTSTR szDriverName;
    LPTSTR szDriversDir;
    PLOADED_IMAGE pLoadedImage;
    BOOL bSuccess;
    BOOL bUnloaded;

    bSuccess = FALSE;

    ASSERT( m_strName.GetLength() > 0 );

    //
    // ImageLoad doesn't know about const pointers so
    // we have to GetBuffer here :-(
    //

    szDriverName = m_strName.GetBuffer( m_strName.GetLength() + 1 );

    if( NULL == szDriverName )
    {
        goto Done;
    }

    szDriversDir = g_strDriversDir.GetBuffer( g_strDriversDir.GetLength() + 1 );

    if( NULL == szDriversDir )
    {
        m_strName.ReleaseBuffer();

        goto Done;
    }

    //
    // Load the image
    //

    pLoadedImage = VrfImageLoad( szDriverName,
                                 szDriversDir );

    if( NULL == pLoadedImage )
    {
        //
        // Could not load the image from %windir%\system32\drivers
        // Try again from the PATH
        //

        pLoadedImage = VrfImageLoad( szDriverName,
                                     NULL );
    }

    //
    // Give our string buffers back to MFC
    //

    m_strName.ReleaseBuffer();
    g_strDriversDir.ReleaseBuffer();

    if( NULL == pLoadedImage )
    {
        //
        // We couldn't load this image - bad luck
        //

        TRACE( _T( "ImageLoad failed for %s, error %u\n" ),
            (LPCTSTR) m_strName,
            GetLastError() );

        goto Done;
    }

    //
    // Keep the OS and image version information (4 means NT 4 etc.)
    //

    m_wMajorOperatingSystemVersion = 
        pLoadedImage->FileHeader->OptionalHeader.MajorOperatingSystemVersion;

    m_wMajorImageVersion = 
        pLoadedImage->FileHeader->OptionalHeader.MajorImageVersion;

    //
    // Check if the current driver is a miniport
    //

    VrfIsDriverMiniport( pLoadedImage,
                         m_strMiniportName );

    //
    // Clean-up
    //

    bUnloaded = ImageUnload( pLoadedImage );

    //
    // If ImageUnload fails we cannot do much about it...
    //

    ASSERT( bUnloaded );

    bSuccess = TRUE;

Done:

    return bSuccess;
}


//////////////////////////////////////////////////////////////////////
BOOL CDriverData::LoadDriverVersionData()
{
    BOOL bResult;
    PVOID pWholeVerBlock;
    PVOID pTranslationInfoBuffer;
    LPCTSTR szVariableValue;
    LPTSTR szDriverPath;
    DWORD dwWholeBlockSize;
    DWORD dwDummyHandle;
    UINT uInfoLengthInTChars;
    TCHAR szLocale[ 32 ];
    TCHAR szBlockName[ 64 ];
    CString strDriverPath;

    bResult = FALSE;

    //
    // Get the size of the file info block
    //
    // GetFileVersionInfoSize doesn't know about 
    // const pointers so we need to GetBuffer here :-(
    //

    strDriverPath = g_strDriversDir + '\\' + m_strName;

    szDriverPath = strDriverPath.GetBuffer( strDriverPath.GetLength() + 1 );

    if( NULL == szDriverPath )
    {
        goto InitializeWithDefaults;
    }

    dwWholeBlockSize = GetFileVersionInfoSize(
        szDriverPath,
        &dwDummyHandle );

    strDriverPath.ReleaseBuffer();

    if( dwWholeBlockSize == 0 )
    {
        //
        // Couldn't find the binary in %windir%\system32\drivers
        // Try %windir%\system32 too
        //

        strDriverPath = g_strSystemDir + '\\' + m_strName;

        szDriverPath = strDriverPath.GetBuffer( strDriverPath.GetLength() + 1 );

        if( NULL == szDriverPath )
        {
            goto InitializeWithDefaults;
        }

        dwWholeBlockSize = GetFileVersionInfoSize(
            szDriverPath,
            &dwDummyHandle );

        strDriverPath.ReleaseBuffer();

        if( dwWholeBlockSize == 0 )
        {
            //
            // Couldn't read version information
            //

            goto InitializeWithDefaults;
        }
    }

    //
    // Allocate the buffer for the version information
    //

    pWholeVerBlock = malloc( dwWholeBlockSize );

    if( pWholeVerBlock == NULL )
    {
        goto InitializeWithDefaults;
    }

    //
    // Get the version information
    //
    // GetFileVersionInfo doesn't know about 
    // const pointers so we need to GetBuffer here :-(
    //

    szDriverPath = strDriverPath.GetBuffer( strDriverPath.GetLength() + 1 );

    if( NULL == szDriverPath )
    {
        free( pWholeVerBlock );

        goto InitializeWithDefaults;
    }

    bResult = GetFileVersionInfo(
        szDriverPath,
        dwDummyHandle,
        dwWholeBlockSize,
        pWholeVerBlock );

    strDriverPath.ReleaseBuffer();

    if( bResult != TRUE )
    {
        free( pWholeVerBlock );

        goto InitializeWithDefaults;
    }

    //
    // Get the locale info
    //

    bResult = VerQueryValue(
        pWholeVerBlock,
        _T( "\\VarFileInfo\\Translation" ),
        &pTranslationInfoBuffer,
        &uInfoLengthInTChars );

    if( TRUE != bResult || NULL == pTranslationInfoBuffer )
    {
        free( pWholeVerBlock );

        goto InitializeWithDefaults;
    }

    //
    // Locale info comes back as two little endian words.
    // Flip 'em, 'cause we need them big endian for our calls.
    //

    _stprintf(
        szLocale,
        _T( "%02X%02X%02X%02X" ),
		(ULONG) HIBYTE( LOWORD ( * (LPDWORD) pTranslationInfoBuffer) ),
		(ULONG) LOBYTE( LOWORD ( * (LPDWORD) pTranslationInfoBuffer) ),
		(ULONG) HIBYTE( HIWORD ( * (LPDWORD) pTranslationInfoBuffer) ),
		(ULONG) LOBYTE( HIWORD ( * (LPDWORD) pTranslationInfoBuffer) ) );

    //
    // Get the file version
    //

    _stprintf(
        szBlockName,
        _T( "\\StringFileInfo\\%s\\FileVersion" ),
        szLocale );

    bResult = VerQueryValue(
        pWholeVerBlock,
        szBlockName,
        (PVOID*) &szVariableValue,
        &uInfoLengthInTChars );

    if( TRUE != bResult || 0 == uInfoLengthInTChars )
    {
        //
        // Couldn't find the version
        //

        VERIFY( m_strFileVersion.LoadString( IDS_UNKNOWN ) );
    }
    else
    {
        //
        // Found the version
        //

        m_strFileVersion = szVariableValue;
    }

    //
    // Get the company name
    //

    _stprintf(
        szBlockName,
        _T( "\\StringFileInfo\\%s\\CompanyName" ),
        szLocale );

    bResult = VerQueryValue(
        pWholeVerBlock,
        szBlockName,
        (PVOID*) &szVariableValue,
        &uInfoLengthInTChars );

    if( TRUE != bResult || uInfoLengthInTChars == 0 )
    {
        //
        // Coudln't find the company name
        //

        m_strCompanyName.LoadString( IDS_UNKNOWN );
    }
    else
    {
        m_strCompanyName = szVariableValue;
    }

    //
    // Get the FileDescription
    //

    _stprintf(
        szBlockName,
        _T( "\\StringFileInfo\\%s\\FileDescription" ),
        szLocale );

    bResult = VerQueryValue(
        pWholeVerBlock,
        szBlockName,
        (PVOID*) &szVariableValue,
        &uInfoLengthInTChars );

    if( TRUE != bResult || uInfoLengthInTChars == 0 )
    {
        //
        // Coudln't find the FileDescription
        //

        m_strFileDescription.LoadString( IDS_UNKNOWN );
    }
    else
    {
        m_strFileDescription = szVariableValue;
    }

    //
    // clean-up
    //

    free( pWholeVerBlock );

    goto Done;

InitializeWithDefaults:
    
    m_strCompanyName.LoadString( IDS_UNKNOWN );
    m_strFileVersion.LoadString( IDS_UNKNOWN );
    m_strFileDescription.LoadString( IDS_UNKNOWN );

Done:
    //
    // We always return TRUE from this function because 
    // the app will work fine without the version info - 
    // it's just something that we would like to be able to display
    //

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
BOOL CDriverData::LoadDriverImageData()
{
    BOOL bResult1;
    BOOL bResult2;

    bResult1 = LoadDriverHeaderData();
    bResult2 = LoadDriverVersionData();

    return ( bResult1 && bResult2 );
}

//////////////////////////////////////////////////////////////////////
void CDriverData::AssertValid() const
{
    ASSERT( SignedNotVerifiedYet    == m_SignedStatus ||
            SignedYes               == m_SignedStatus ||
            SignedNo                == m_SignedStatus );

    ASSERT( VerifyDriverNo          == m_VerifyDriverStatus  ||
            VerifyDriverYes         == m_VerifyDriverStatus  );

    CObject::AssertValid();
}

//////////////////////////////////////////////////////////////////////
// CDriverDataArray Class
//////////////////////////////////////////////////////////////////////

CDriverDataArray::~CDriverDataArray()
{
    DeleteAll();
}

//////////////////////////////////////////////////////////////////////
VOID CDriverDataArray::DeleteAll()
{
    INT_PTR nArraySize;
    CDriverData *pCrtDriverData;

    nArraySize = GetSize();

    while( nArraySize > 0 )
    {
        nArraySize -= 1;

        pCrtDriverData = GetAt( nArraySize );

        ASSERT_VALID( pCrtDriverData );

        delete pCrtDriverData;
    }

    RemoveAll();
}

//////////////////////////////////////////////////////////////////////
CDriverData *CDriverDataArray::GetAt( INT_PTR nIndex ) const
{
    return (CDriverData *)CObArray::GetAt( nIndex );
}

//////////////////////////////////////////////////////////////////////
CDriverDataArray &CDriverDataArray::operator = (const CDriverDataArray &DriversDataArray)
{
    INT_PTR nNewArraySize;
    INT_PTR nCrtElement;
    CDriverData *pCopiedDriverData;
    CDriverData *pNewDriverData;

    DeleteAll();

    nNewArraySize = DriversDataArray.GetSize();

    for( nCrtElement = 0; nCrtElement < nNewArraySize; nCrtElement += 1 )
    {
        pCopiedDriverData = DriversDataArray.GetAt( nCrtElement );
        ASSERT_VALID( pCopiedDriverData );

        pNewDriverData = new CDriverData( *pCopiedDriverData );

        if( NULL != pNewDriverData )
        {
            ASSERT_VALID( pNewDriverData );

            Add( pNewDriverData );
        }
        else
        {
            VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
            goto Done;
        }
    }

Done:
    //
    // All done, assert that our data is consistent
    //

    ASSERT_VALID( this );

    return *this;
}


//////////////////////////////////////////////////////////////////////
// CDriversSet Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDriversSet::CDriversSet()
{
    m_DriverSetType = DriversSetNotSigned;
    m_bDriverDataInitialized = FALSE;
    m_bUnsignedDriverDataInitialized = FALSE; 
}

CDriversSet::~CDriversSet()
{

}

//////////////////////////////////////////////////////////////////////
BOOL CDriversSet::FindUnsignedDrivers( HANDLE hAbortEvent,
                                       CVrfProgressCtrl &ProgressCtl)
{
    INT_PTR nAllDriverNames;
    INT_PTR nCrtDriverName;
    DWORD dwWaitResult;
    BOOL bSigned;
    BOOL bChangedCurrentDirectory;
    CDriverData *pDriverData;

    ProgressCtl.SetRange32(0, 100);
    ProgressCtl.SetStep( 1 );
    ProgressCtl.SetPos( 0 );

    bChangedCurrentDirectory = FALSE;

    if( TRUE != m_bUnsignedDriverDataInitialized )
    {
        ASSERT( TRUE == m_bDriverDataInitialized );

        //
        // We are going to check all drivers' signature
        // so change directory to %windir%\system32\drivers first
        // 

        bChangedCurrentDirectory = SetCurrentDirectory( g_strDriversDir );

        if( TRUE != bChangedCurrentDirectory )
        {
            VrfErrorResourceFormat( IDS_CANNOT_SET_CURRENT_DIRECTORY,
                                    (LPCTSTR) g_strDriversDir );
        }

        //
        // The unsigned drivers data is not initialized yet.
        // Try to initialize it now.
        //

        nAllDriverNames = m_aDriverData.GetSize();

        ProgressCtl.SetRange32(0, nAllDriverNames );

        for( nCrtDriverName = 0; nCrtDriverName < nAllDriverNames; nCrtDriverName+=1 )
        {
            if( NULL != hAbortEvent )
            {
                //
                // Check if the thread has to die
                //

                dwWaitResult = WaitForSingleObject( hAbortEvent,
                                                    0 );

                if( WAIT_OBJECT_0 == dwWaitResult )
                {
                    //
                    // We have to die...
                    //

                    TRACE( _T( "CDriversSet::FindUnsignedDrivers : aborting at driver %d of %d\n" ),
                        nCrtDriverName,
                        nAllDriverNames );

                    goto Done;
                }
            }

            pDriverData = m_aDriverData.GetAt( nCrtDriverName );

            ASSERT_VALID( pDriverData );

            //
            // If we already checked the signature of this driver before
            // don't spend any more time on it - use the cached data
            //

            if( CDriverData::SignedNotVerifiedYet == pDriverData->m_SignedStatus )
            {
                bSigned = IsDriverSigned( pDriverData->m_strName );

                if( TRUE != bSigned )
                {
                    //
                    // This driver is not signed
                    //

                    pDriverData->m_SignedStatus = CDriverData::SignedNo;

                }
                else
                {
                    //
                    // This driver is signed
                    //

                    pDriverData->m_SignedStatus = CDriverData::SignedYes;
                }
            }

            ProgressCtl.StepIt();
        }
        
        m_bUnsignedDriverDataInitialized = TRUE;
    }

Done:

    if( TRUE == bChangedCurrentDirectory )
    {
        SetCurrentDirectory( g_strInitialCurrentDirectory );
    }

    return m_bUnsignedDriverDataInitialized;
}

//////////////////////////////////////////////////////////////////////
BOOL CDriversSet::LoadAllDriversData( HANDLE hAbortEvent,
                                      CVrfProgressCtrl	&ProgressCtl )
{
    ULONG uBufferSize;
    ULONG uCrtModule;
    PVOID pBuffer;
    INT nCrtModuleNameLength;
    INT nBackSlashIndex;
    INT_PTR nDrvDataIndex;
    NTSTATUS Status;
    LPTSTR szCrtModuleName;
    DWORD dwWaitResult;
    CString strCrModuleName;
    CDriverData *pDriverData;
    PRTL_PROCESS_MODULES Modules;

    ProgressCtl.SetPos( 0 );
    ProgressCtl.SetRange32( 0, 100 );
    ProgressCtl.SetStep( 1 );

    m_aDriverData.DeleteAll();

    if( TRUE != m_bDriverDataInitialized )
    {
        for( uBufferSize = 0x10000; TRUE; uBufferSize += 0x1000) 
        {
            //
            // Allocate a new buffer
            //

            pBuffer = new BYTE[ uBufferSize ];

            if( NULL == pBuffer ) 
            {
                goto Done;
            }

            //
            // Query the kernel
            //

            Status = NtQuerySystemInformation ( SystemModuleInformation,
                                                pBuffer,
                                                uBufferSize,
                                                NULL);

            if( ! NT_SUCCESS( Status ) ) 
            {
                delete [] pBuffer;

                if (Status == STATUS_INFO_LENGTH_MISMATCH) 
                {
                    //
                    // Try with a bigger buffer
                    //

                    continue;
                }
                else 
                {
                    //
                    // Fatal error - we cannot query
                    //

                    VrfErrorResourceFormat( IDS_CANT_GET_ACTIVE_DRVLIST,
                                            Status );

                    goto Done;
                }
            }
            else 
            {
                //
                // Got all the information we needed
                //

                break;
            }
        }

        Modules = (PRTL_PROCESS_MODULES)pBuffer;

        ProgressCtl.SetRange32(0, Modules->NumberOfModules );

        for( uCrtModule = 0; uCrtModule < Modules->NumberOfModules; uCrtModule += 1 ) 
        {
            //
            // Check if the user wants to abort this long file processing...
            //

            if( NULL != hAbortEvent )
            {
                //
                // Check if the thread has to die
                //

                dwWaitResult = WaitForSingleObject( hAbortEvent,
                                                    0 );

                if( WAIT_OBJECT_0 == dwWaitResult )
                {
                    //
                    // We have to die...
                    //

                    TRACE( _T( "CDriversSet::LoadAllDriversData : aborting at driver %u of %u\n" ),
                           uCrtModule,
                           (ULONG) Modules->NumberOfModules );

                    delete [] pBuffer;

                    goto Done;
                }
            }

            if( Modules->Modules[uCrtModule].ImageBase < g_pHighestUserAddress )
            {
                //
                // This is a user-mode module - we don't care about it
                //

                ProgressCtl.StepIt();

                continue;
            }

            //
            // Add this driver to our list
            //

            nCrtModuleNameLength = strlen( (const char*)&Modules->Modules[uCrtModule].FullPathName[0] );

            szCrtModuleName = strCrModuleName.GetBuffer( nCrtModuleNameLength + 1 );

            if( NULL == szCrtModuleName )
            {
                VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

                goto Done;
            }

#ifdef UNICODE

            MultiByteToWideChar( CP_ACP, 
                                 0, 
                                 (const char*)&Modules->Modules[uCrtModule].FullPathName[0],
                                 -1, 
                                 szCrtModuleName, 
                                 ( nCrtModuleNameLength + 1 ) * sizeof( TCHAR ) );

#else
            strcpy( szCrtModuleName, 
                    (const char*)&Modules->Modules[uCrtModule].FullPathName[0] );
#endif

            strCrModuleName.ReleaseBuffer();

            //
            // Keep only the file name, without the path
            //
            // It turns out that NtQuerySystemInformation ( SystemModuleInformation )
            // can return the path in several different formats
            //
            // E.g.
            //
            // \winnt\system32\ntoskrnl.exe
            // acpi.sys
            // \winnt\system32\drivers\battc.sys
            // \systemroot\system32\drivers\videoprt.sys
            //

            nBackSlashIndex = strCrModuleName.ReverseFind( _T( '\\' ) );
            
            if( nBackSlashIndex > 0 )
            {
                strCrModuleName = strCrModuleName.Right( nCrtModuleNameLength - nBackSlashIndex - 1 );
            }

            //
            // Add a data entry for this driver
            //

            strCrModuleName.MakeLower();

            nDrvDataIndex = AddNewDriverData( strCrModuleName );

            //
            // Deal with the kernel and HAL differently
            //

            if( ( uCrtModule == 0 || uCrtModule == 1 ) && nDrvDataIndex >= 0)
            {
                pDriverData = m_aDriverData.GetAt( nDrvDataIndex );

                ASSERT_VALID( pDriverData );

                if( 0 == uCrtModule )
                {
                    //
                    // This is the kernel
                    //

                    pDriverData->m_strReservedName = _T( "ntoskrnl.exe" );
                }
                else
                {
                    //
                    // This is the kernel
                    //

                    pDriverData->m_strReservedName = _T( "hal.dll" );
                }
            }

            ProgressCtl.StepIt();
        }

        delete [] pBuffer;

        m_bDriverDataInitialized = TRUE;
    }
    
Done:

    return m_bDriverDataInitialized;
}

//////////////////////////////////////////////////////////////////////
BOOL CDriversSet::ShouldDriverBeVerified( const CDriverData *pDriverData ) const
{
    BOOL bResult;

    bResult = FALSE;

    switch( m_DriverSetType )
    {
    case DriversSetNotSigned:
        bResult = ( CDriverData::SignedNo == pDriverData->m_SignedStatus );
        break;

    case DriversSetOldOs:
        bResult = ( 0 != pDriverData->m_wMajorOperatingSystemVersion && 5 > pDriverData->m_wMajorOperatingSystemVersion ) ||
                  ( 0 != pDriverData->m_wMajorImageVersion && 5 > pDriverData->m_wMajorImageVersion );
        break;

    case DriversSetAllDrivers:
        bResult = TRUE;
        break;

    case DriversSetCustom:
        bResult = ( CDriverData::VerifyDriverYes == pDriverData->m_VerifyDriverStatus );
        break;
        
    default:
        //
        // Oops, how did we get here?!?
        //

        ASSERT( FALSE );
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////
BOOL CDriversSet::ShouldVerifySomeDrivers( ) const
{
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    CDriverData *pDriverData;
    BOOL bShouldVerifySome;

    bShouldVerifySome = FALSE;

    nDrivers = m_aDriverData.GetSize();

    for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
    {
         pDriverData = m_aDriverData.GetAt( nCrtDriver );

         ASSERT_VALID( pDriverData );

         if( ShouldDriverBeVerified( pDriverData ) )
         {
             bShouldVerifySome = TRUE;
             break;
         }
    }

    return bShouldVerifySome;
}

//////////////////////////////////////////////////////////////////////
BOOL CDriversSet::GetDriversToVerify( CString &strDriversToVerify )
{
    INT_PTR nDriversNo;
    INT_PTR nCrtDriver;
    CDriverData *pCrtDrvData;

    if( DriversSetAllDrivers == m_DriverSetType )
    {
        //
        // Verify all drivers
        //

        strDriversToVerify = _T( '*' );
    }
    else
    {
        //
        // Parse all the drivers list and see which ones should be verified
        //

        strDriversToVerify = _T( "" );

        nDriversNo = m_aDriverData.GetSize();

        for( nCrtDriver = 0; nCrtDriver < nDriversNo; nCrtDriver += 1 )
        {
            pCrtDrvData = m_aDriverData.GetAt( nCrtDriver );

            ASSERT_VALID( pCrtDrvData );

            if( ShouldDriverBeVerified( pCrtDrvData ) )
            {
                if( pCrtDrvData->m_strReservedName.GetLength() > 0 )
                {
                    //
                    // Kernel or HAL
                    //

                    VrfAddDriverNameNoDuplicates( pCrtDrvData->m_strReservedName,
                                                  strDriversToVerify );        
                }
                else
                {
                    //
                    // Regular driver
                    //

                    VrfAddDriverNameNoDuplicates( pCrtDrvData->m_strName,
                                                  strDriversToVerify );        
                }

                if( pCrtDrvData->m_strMiniportName.GetLength() > 0 )
                {
                    //
                    // This is a miniport - auto-enable the corresponding driver
                    //

                    TRACE( _T( "Auto-enabling %s\n" ), (LPCTSTR)pCrtDrvData->m_strMiniportName );

                    VrfAddDriverNameNoDuplicates( pCrtDrvData->m_strMiniportName,
                                                  strDriversToVerify );        
                }
            }
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
INT_PTR CDriversSet::AddNewDriverData( LPCTSTR szDriverName )
{
    INT_PTR nIndexInArray;
    CDriverData *pNewDriverData;
    BOOL bSuccess;

    ASSERT( IsDriverNameInList( szDriverName ) == FALSE );

    nIndexInArray = -1;

    pNewDriverData = new CDriverData( szDriverName );
    
    if( NULL != pNewDriverData )
    {
        pNewDriverData->LoadDriverImageData();

        TRY
        {
            nIndexInArray = m_aDriverData.Add( pNewDriverData );
        }
	    CATCH( CMemoryException, pMemException )
	    {
		    VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
            nIndexInArray = -1;

            //
            // Clean-up the allocation since we cannot add it to our list
            //

            delete pNewDriverData;
        }
        END_CATCH
    }

    return nIndexInArray;
}

//////////////////////////////////////////////////////////////////////
//
// Is this driver name already in our list?
//

BOOL CDriversSet::IsDriverNameInList( LPCTSTR szDriverName )
{
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    CDriverData *pCrtDriverData;
    BOOL bIsInList;

    bIsInList = FALSE;

    nDrivers = m_aDriverData.GetSize();

    for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
    {
        pCrtDriverData = m_aDriverData.GetAt( nCrtDriver );

        ASSERT_VALID( pCrtDriverData );

        if( pCrtDriverData->m_strName.CompareNoCase( szDriverName ) == 0 )
        {
            bIsInList = TRUE;

            break;
        }
    }

    return bIsInList;
}

//////////////////////////////////////////////////////////////////////
//
// Operators
//

CDriversSet & CDriversSet::operator = (const CDriversSet &DriversSet)
{
    m_DriverSetType                     = DriversSet.m_DriverSetType;
    m_aDriverData                       = DriversSet.m_aDriverData;
    m_bDriverDataInitialized            = DriversSet.m_bDriverDataInitialized;
    m_bUnsignedDriverDataInitialized    = DriversSet.m_bUnsignedDriverDataInitialized;

    ::CopyStringArray(
        DriversSet.m_astrNotInstalledDriversToVerify,
        m_astrNotInstalledDriversToVerify );

    //
    // All done - assert that our data is consistent
    //

    ASSERT_VALID( this );

    return *this;
}

//////////////////////////////////////////////////////////////////////
//
// Overrides
//

void CDriversSet::AssertValid() const
{
    ASSERT( DriversSetCustom    == m_DriverSetType ||
            DriversSetOldOs     == m_DriverSetType ||
            DriversSetNotSigned == m_DriverSetType ||
            DriversSetAllDrivers== m_DriverSetType );

    ASSERT( TRUE    == m_bDriverDataInitialized ||
            FALSE   == m_bDriverDataInitialized );

    ASSERT( TRUE    == m_bUnsignedDriverDataInitialized ||
            FALSE   == m_bUnsignedDriverDataInitialized );

    m_aDriverData.AssertValid();
    m_astrNotInstalledDriversToVerify.AssertValid();

    CObject::AssertValid();
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// CSettingsBits Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSettingsBits::CSettingsBits()
{
    m_SettingsType = SettingsTypeTypical;
}

CSettingsBits::~CSettingsBits()
{

}

//////////////////////////////////////////////////////////////////////
//
// Operators
//

CSettingsBits & CSettingsBits::operator = (const CSettingsBits &SettingsBits)
{
    m_SettingsType          = SettingsBits.m_SettingsType;

    m_bSpecialPoolEnabled   = SettingsBits.m_bSpecialPoolEnabled;
    m_bForceIrqlEnabled     = SettingsBits.m_bForceIrqlEnabled;
    m_bLowResEnabled        = SettingsBits.m_bLowResEnabled;
    m_bPoolTrackingEnabled  = SettingsBits.m_bPoolTrackingEnabled;
    m_bIoEnabled            = SettingsBits.m_bIoEnabled;
    m_bDeadlockDetectEnabled= SettingsBits.m_bDeadlockDetectEnabled;
    m_bDMAVerifEnabled      = SettingsBits.m_bDMAVerifEnabled;
    m_bEnhIoEnabled         = SettingsBits.m_bEnhIoEnabled;

    //
    // All done, assert that our data is consistent
    //

    ASSERT_VALID( this );

    return *this;
}

//////////////////////////////////////////////////////////////////////
//
// Overrides
//

void CSettingsBits::AssertValid() const
{
    CObject::AssertValid();
}

//////////////////////////////////////////////////////////////////////
VOID CSettingsBits::SetTypicalOnly()
{
    m_SettingsType = SettingsTypeTypical;

    m_bSpecialPoolEnabled   = TRUE;
    m_bForceIrqlEnabled     = TRUE;
    m_bPoolTrackingEnabled  = TRUE;
    m_bIoEnabled            = TRUE;
    m_bDeadlockDetectEnabled= TRUE;
    m_bDMAVerifEnabled      = TRUE;
    
    //
    // Low resource simulation
    //

    m_bLowResEnabled        = FALSE;

    //
    // Extreme or spurious tests
    //

    m_bEnhIoEnabled         = FALSE;
}

//////////////////////////////////////////////////////////////////////
VOID CSettingsBits::EnableTypicalTests( BOOL bEnable )
{
    ASSERT( SettingsTypeTypical == m_SettingsType ||
            SettingsTypeCustom  == m_SettingsType );

    m_bSpecialPoolEnabled   = ( FALSE != bEnable );
    m_bForceIrqlEnabled     = ( FALSE != bEnable );
    m_bPoolTrackingEnabled  = ( FALSE != bEnable );
    m_bIoEnabled            = ( FALSE != bEnable );
    m_bDeadlockDetectEnabled= ( FALSE != bEnable );
    m_bDMAVerifEnabled      = ( FALSE != bEnable );
}

//////////////////////////////////////////////////////////////////////
VOID CSettingsBits::EnableExcessiveTests( BOOL bEnable )
{
    m_bEnhIoEnabled         = ( FALSE != bEnable );
}

//////////////////////////////////////////////////////////////////////
VOID CSettingsBits::EnableLowResTests( BOOL bEnable )
{
    m_bLowResEnabled        = ( FALSE != bEnable );
}

//////////////////////////////////////////////////////////////////////
BOOL CSettingsBits::GetVerifierFlags( DWORD &dwVerifyFlags )
{
    dwVerifyFlags = 0;

    if( FALSE != m_bSpecialPoolEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_SPECIAL_POOLING;
    }

    if( FALSE != m_bForceIrqlEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_FORCE_IRQL_CHECKING;
    }

    if( FALSE != m_bLowResEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES;
    }

    if( FALSE != m_bPoolTrackingEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS;
    }

    if( FALSE != m_bIoEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_IO_CHECKING;
    }

    if( FALSE != m_bDeadlockDetectEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_DEADLOCK_DETECTION;
    }

    if( FALSE != m_bDMAVerifEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_DMA_VERIFIER;
    }

    if( FALSE != m_bEnhIoEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_ENHANCED_IO_CHECKING;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// CVerifierSettings Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CVerifierSettings::CVerifierSettings()
{
}

CVerifierSettings::~CVerifierSettings()
{
}

//////////////////////////////////////////////////////////////////////
CVerifierSettings &CVerifierSettings::operator = (const CVerifierSettings &VerifSettings)
{
    m_SettingsBits = VerifSettings.m_SettingsBits;
    m_DriversSet   = VerifSettings.m_DriversSet;
    m_aDiskData    = VerifSettings.m_aDiskData;

    //
    // All done - assert that our data is consistent
    //

    ASSERT_VALID( this );

    return *this;
}

//////////////////////////////////////////////////////////////////////
BOOL CVerifierSettings::SaveToRegistry()
{
    DWORD dwVerifyFlags;
    DWORD dwPrevFlags;
    BOOL bSuccess;
    CString strDriversToVerify;
    CString strPrevVerifiedDrivers;
    CString strDisksToVerify;

    dwVerifyFlags = 0;

    //
    // Get the list of drivers to verify 
    //

    bSuccess = m_DriversSet.GetDriversToVerify( strDriversToVerify ) &&
               m_SettingsBits.GetVerifierFlags( dwVerifyFlags );
    
    if( FALSE != bSuccess )
    {
        //
        // Have something to write to the registry
        //

        //
        // Try to get the old settings
        //

        dwPrevFlags = 0;

        VrfReadVerifierSettings( strPrevVerifiedDrivers,
                                 dwPrevFlags );

        if( strDriversToVerify.CompareNoCase( strPrevVerifiedDrivers ) != 0 ||
            dwVerifyFlags != dwPrevFlags )
        {
            bSuccess = VrfWriteVerifierSettings( TRUE,
                                                 strDriversToVerify,
                                                 TRUE,
                                                 dwVerifyFlags );

        }
    }

    if( FALSE != bSuccess )
    {
        bSuccess = m_aDiskData.SaveNewSettings();
    }

    if( FALSE != bSuccess )
    {
        if( FALSE == g_bSettingsSaved )
        {
            VrfMesssageFromResource( IDS_NO_SETTINGS_WERE_CHANGED );
        }
        else
        {
            VrfMesssageFromResource( IDS_REBOOT );
        }
    }
    
    return bSuccess;
}

//////////////////////////////////////////////////////////////////////
//
// Overrides
//

void CVerifierSettings::AssertValid() const
{
    m_SettingsBits.AssertValid();
    m_DriversSet.AssertValid();
    m_aDiskData.AssertValid();


    CObject::AssertValid();
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Runtime data - queried from the kernel
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
// class CRuntimeDriverData
//

CRuntimeDriverData::CRuntimeDriverData()
{
    Loads = 0;
    Unloads = 0;

    CurrentPagedPoolAllocations = 0;
    CurrentNonPagedPoolAllocations = 0;
    PeakPagedPoolAllocations = 0;
    PeakNonPagedPoolAllocations = 0;

    PagedPoolUsageInBytes = 0;
    NonPagedPoolUsageInBytes = 0;
    PeakPagedPoolUsageInBytes = 0;
    PeakNonPagedPoolUsageInBytes = 0;
}

//////////////////////////////////////////////////////////////////////
//
// class CRuntimeDriverDataArray
//

CRuntimeDriverDataArray::~CRuntimeDriverDataArray()
{
    DeleteAll();
}

//////////////////////////////////////////////////////////////////////
CRuntimeDriverData *CRuntimeDriverDataArray::GetAt( INT_PTR nIndex )
{
    CRuntimeDriverData *pRetVal = (CRuntimeDriverData *)CObArray::GetAt( nIndex );

    ASSERT_VALID( pRetVal );

    return pRetVal;
}

//////////////////////////////////////////////////////////////////////
VOID CRuntimeDriverDataArray::DeleteAll()
{
    INT_PTR nArraySize;
    CRuntimeDriverData *pCrtDriverData;

    nArraySize = GetSize();

    while( nArraySize > 0 )
    {
        nArraySize -= 1;

        pCrtDriverData = GetAt( nArraySize );

        ASSERT_VALID( pCrtDriverData );

        delete pCrtDriverData;
    }

    RemoveAll();
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// class CRuntimeVerifierData
//

CRuntimeVerifierData::CRuntimeVerifierData()
{
    FillWithDefaults();
}

//////////////////////////////////////////////////////////////////////
VOID CRuntimeVerifierData::FillWithDefaults()
{
    m_bSpecialPool      = FALSE;
    m_bPoolTracking     = FALSE;
    m_bForceIrql        = FALSE;
    m_bIo               = FALSE;
    m_bEnhIo            = FALSE;
    m_bDeadlockDetect   = FALSE;
    m_bDMAVerif         = FALSE;
    m_bLowRes           = FALSE;

    RaiseIrqls                      = 0;
    AcquireSpinLocks                = 0;
    SynchronizeExecutions           = 0;
    AllocationsAttempted            = 0;

    AllocationsSucceeded            = 0;
    AllocationsSucceededSpecialPool = 0;
    AllocationsWithNoTag;

    Trims                           = 0;
    AllocationsFailed               = 0;
    AllocationsFailedDeliberately   = 0;

    UnTrackedPool                   = 0;

    Level = 0;

    m_RuntimeDriverDataArray.DeleteAll();
}

//////////////////////////////////////////////////////////////////////
BOOL CRuntimeVerifierData::IsDriverVerified( LPCTSTR szDriveName )
{
    CRuntimeDriverData *pCrtDriverData;
    INT_PTR nDrivers;
    BOOL bFound;

    bFound = FALSE;

    nDrivers = m_RuntimeDriverDataArray.GetSize();

    while( nDrivers > 0 )
    {
        nDrivers -= 1;

        pCrtDriverData = m_RuntimeDriverDataArray.GetAt( nDrivers );

        ASSERT_VALID( pCrtDriverData );

        if( 0 == pCrtDriverData->m_strName.CompareNoCase( szDriveName ) )
        {
            bFound = TRUE;
            break;
        }
    }

    return bFound;
}
    
//////////////////////////////////////////////////////////////////////
// CDiskData Class
//////////////////////////////////////////////////////////////////////

CDiskData::CDiskData( LPCTSTR szVerifierEnabled,
                      LPCTSTR szDiskDevicesForDisplay, 
                      LPCTSTR szDiskDevicesPDOName )
{
    m_bVerifierEnabled = ( 0 != _ttoi( szVerifierEnabled ) );

    m_strDiskDevicesForDisplay = szDiskDevicesForDisplay;
    m_strDiskDevicesPDOName = szDiskDevicesPDOName;
}

CDiskData::CDiskData( const CDiskData &DiskData )
{
    m_bVerifierEnabled = DiskData.m_bVerifierEnabled;
    m_strDiskDevicesForDisplay = DiskData.m_strDiskDevicesForDisplay;
    m_strDiskDevicesPDOName = DiskData.m_strDiskDevicesPDOName;
}


CDiskData::~CDiskData()
{
}

//////////////////////////////////////////////////////////////////////
void CDiskData::AssertValid() const
{
    ASSERT( m_bVerifierEnabled == FALSE || m_bVerifierEnabled == TRUE );
    ASSERT( m_strDiskDevicesForDisplay.GetLength() > 0 );
    ASSERT( m_strDiskDevicesPDOName.GetLength() > 0 );

    CObject::AssertValid();
}

//////////////////////////////////////////////////////////////////////
// CDiskDataArray Class
//////////////////////////////////////////////////////////////////////

CDiskDataArray::CDiskDataArray()
{
}

CDiskDataArray::~CDiskDataArray()
{
    DeleteAll();
}

//////////////////////////////////////////////////////////////////////
VOID CDiskDataArray::DeleteAll()
{
    INT_PTR nArraySize;
    CDiskData *pCrtDiskData;

    nArraySize = GetSize();

    while( nArraySize > 0 )
    {
        nArraySize -= 1;

        pCrtDiskData = GetAt( nArraySize );

        ASSERT_VALID( pCrtDiskData );

        delete pCrtDiskData;
    }

    RemoveAll();
}

//////////////////////////////////////////////////////////////////////
CDiskData *CDiskDataArray::GetAt( INT_PTR nIndex ) const
{
    return (CDiskData *)CObArray::GetAt( nIndex );
}

//////////////////////////////////////////////////////////////////////
CDiskDataArray &CDiskDataArray::operator = (const CDiskDataArray &DiskDataArray)
{
    INT_PTR nNewArraySize;
    INT_PTR nCrtElement;
    CDiskData *pCopiedDiskData;
    CDiskData *pNewDiskData;

    DeleteAll();

    nNewArraySize = DiskDataArray.GetSize();

    for( nCrtElement = 0; nCrtElement < nNewArraySize; nCrtElement += 1 )
    {
        pCopiedDiskData = DiskDataArray.GetAt( nCrtElement );
        ASSERT_VALID( pCopiedDiskData );

        pNewDiskData = new CDiskData( *pCopiedDiskData );

        if( NULL != pNewDiskData )
        {
            ASSERT_VALID( pNewDiskData );

            Add( pNewDiskData );
        }
        else
        {
            VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
            goto Done;
        }
    }

Done:
    //
    // All done, assert that our data is consistent
    //

    ASSERT_VALID( this );

    return *this;
}

//////////////////////////////////////////////////////////////////////
BOOL CDiskDataArray::InitializeDiskList()
{
    BOOLEAN bSuccess;
    INT nCrtLength;
    CDiskData *pNewDiskData;
    LPTSTR DiskDevicesForDisplay = NULL;
    LPTSTR DiskDevicesPDOName = NULL;
    LPTSTR VerifierEnabled = NULL;
    LPTSTR DiskDevicesForDisplayCrt;
    LPTSTR DiskDevicesPDONameCrt;
    LPTSTR VerifierEnabledCrt;
    
    DeleteAll();

    bSuccess = DiskEnumerate( g_szFilter,
                              &DiskDevicesForDisplay,
                              &DiskDevicesPDOName,
                              &VerifierEnabled );

    if( FALSE != bSuccess )
    {

        DiskDevicesForDisplayCrt = DiskDevicesForDisplay;
        DiskDevicesPDONameCrt = DiskDevicesPDOName;
        VerifierEnabledCrt = VerifierEnabled;

        do
        {
            pNewDiskData = new CDiskData( VerifierEnabledCrt,
                                          DiskDevicesForDisplayCrt,
                                          DiskDevicesPDONameCrt );

            if( NULL == pNewDiskData )
            {
                bSuccess = FALSE;
                break;
            }

            ASSERT_VALID( pNewDiskData );

            nCrtLength = pNewDiskData->m_strDiskDevicesForDisplay.GetLength();
            if( nCrtLength == 0 )
            {
                delete pNewDiskData;
                break;
            }
            DiskDevicesForDisplayCrt += (nCrtLength + 1);

            nCrtLength = pNewDiskData->m_strDiskDevicesPDOName.GetLength();
            if( nCrtLength == 0 )
            {
                delete pNewDiskData;
                break;
            }
            DiskDevicesPDONameCrt += (nCrtLength + 1);

            VerifierEnabledCrt += ( _tcslen( VerifierEnabledCrt ) + 1 );

            Add( pNewDiskData );
        }
        while( TRUE );

        FreeDiskMultiSz( DiskDevicesForDisplay );
        FreeDiskMultiSz( DiskDevicesPDOName );
        FreeDiskMultiSz( VerifierEnabled );
    }

    return (FALSE != bSuccess);
}

//////////////////////////////////////////////////////////////////////
BOOL CDiskDataArray::VerifyAnyDisk()
{
    INT_PTR nArraySize;
    CDiskData *pDiskData;

    nArraySize = GetSize();

    while( nArraySize > 0 )
    {
        nArraySize -= 1;
        
        pDiskData = GetAt( nArraySize );
        ASSERT_VALID( pDiskData );

        if( FALSE != pDiskData->m_bVerifierEnabled )
        {
            return TRUE;
        }
    }

    return FALSE;
}

//////////////////////////////////////////////////////////////////////
BOOL CDiskDataArray::SaveNewSettings()
{
    BOOL bSuccess;
    INT_PTR nArraySize;
    CDiskData *pNewDiskData;
    CDiskData *pOldDiskData;
    LPTSTR szDiskDevicesPDOName;

    bSuccess = TRUE;

    nArraySize = GetSize();

    while( nArraySize > 0 )
    {
        nArraySize -= 1;
        
        pNewDiskData = GetAt( nArraySize );
        ASSERT_VALID( pNewDiskData );

        pOldDiskData = g_OldDiskData.GetAt( nArraySize );
        ASSERT_VALID( pOldDiskData );

        if( pNewDiskData->m_bVerifierEnabled != pOldDiskData->m_bVerifierEnabled )
        {
            szDiskDevicesPDOName = pNewDiskData->m_strDiskDevicesPDOName.GetBuffer( 
                pNewDiskData->m_strDiskDevicesPDOName.GetLength() + 1 );

            if( NULL == szDiskDevicesPDOName )
            {
                bSuccess = FALSE;
                break;
            }

            if( FALSE != pNewDiskData->m_bVerifierEnabled )
            {
                //
                // Verifier will be enabled for this disk.
                //

                bSuccess = ( AddFilter( g_szFilter,
                                        szDiskDevicesPDOName) != FALSE);
            }
            else
            {
                //
                // Verifier will be disabled for this disk.
                //

                bSuccess = ( DelFilter( g_szFilter,
                                        szDiskDevicesPDOName ) != FALSE);
            }

            pNewDiskData->m_strDiskDevicesPDOName.ReleaseBuffer();

            if( FALSE == bSuccess )
            {
                break;
            }
            else
            {
                g_bSettingsSaved = TRUE;
            }
        }
    }

    return bSuccess;
}


//////////////////////////////////////////////////////////////////////
VOID CDiskDataArray::SetVerifyAllDisks( BOOL bEnabled )
{
    INT_PTR nArraySize;
    CDiskData *pDiskData;

    nArraySize = GetSize();

    while( nArraySize > 0 )
    {
        nArraySize -= 1;
        
        pDiskData = GetAt( nArraySize );
        ASSERT_VALID( pDiskData );

        pDiskData->m_bVerifierEnabled = bEnabled;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\vrfutil.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VrfUtil.cpp
// author: DMihai
// created: 11/1/00
//
// Description
//

#include "stdafx.h"
#include "verifier.h"

#include "vrfutil.h"
#include "vglobal.h"
#include "VSetting.h"
#include "disk.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Global data
//

const TCHAR RegMemoryManagementKeyName[] =
    _T( "System\\CurrentControlSet\\Control\\Session Manager\\Memory Management" );

const TCHAR RegVerifyDriverLevelValueName[] =
    _T( "VerifyDriverLevel" );

const TCHAR RegVerifyDriversValueName[] =
    _T( "VerifyDrivers" );

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message format string is loaded from the resources.
//

void __cdecl VrfErrorResourceFormat( UINT uIdResourceFormat,
                                     ... )
{
    TCHAR szMessage[ 256 ];
    TCHAR strFormat[ 256 ];
    BOOL bResult;
    va_list prms;

    //
    // Load the format string from the resources
    //

    bResult = VrfLoadString( uIdResourceFormat,
                             strFormat,
                             ARRAY_LENGTH( strFormat ) );

    ASSERT( bResult );

    if( bResult )
    {
        va_start (prms, uIdResourceFormat);

        //
        // Format the message in our local buffer
        //

        _vsntprintf ( szMessage, 
                      ARRAY_LENGTH( szMessage ), 
                      strFormat, 
                      prms);

        szMessage[ ARRAY_LENGTH( szMessage ) - 1 ] = (TCHAR)0;

        if( g_bCommandLineMode )
        {
            //
            // Command console mode
            //

            _putts( szMessage );
            
            TRACE( _T( "%s\n" ), szMessage );
        }
        else
        {
            //
            // GUI mode
            //

            AfxMessageBox( szMessage, 
                           MB_OK | MB_ICONSTOP );
        }

        va_end (prms);
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Print out a message to the console
// The message string is loaded from the resources.
//

void __cdecl VrfTPrintfResourceFormat( UINT uIdResourceFormat,
                                       ... )
{
    TCHAR szMessage[ 256 ];
    TCHAR strFormat[ 256 ];
    BOOL bResult;
    va_list prms;

    ASSERT( g_bCommandLineMode );

    //
    // Load the format string from the resources
    //

    bResult = VrfLoadString( uIdResourceFormat,
                             strFormat,
                             ARRAY_LENGTH( strFormat ) );

    ASSERT( bResult );

    if( bResult )
    {
        va_start (prms, uIdResourceFormat);

        //
        // Format the message in our local buffer
        //

        _vsntprintf ( szMessage, 
                      ARRAY_LENGTH( szMessage ), 
                      strFormat, 
                      prms);

        szMessage[ ARRAY_LENGTH( szMessage ) - 1 ] = (TCHAR)0;

        _putts( szMessage );

        va_end (prms);
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Print out a simple (non-formatted) message to the console
// The message string is loaded from the resources.
//

void __cdecl VrfPrintStringFromResources( UINT uIdString )
{
    TCHAR szMessage[ 256 ];

    ASSERT( g_bCommandLineMode );

    VERIFY( VrfLoadString( uIdString,
                           szMessage,
                           ARRAY_LENGTH( szMessage ) ) );

    _putts( szMessage );
}

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message string is loaded from the resources.
//

void __cdecl VrfMesssageFromResource( UINT uIdString )
{
    TCHAR szMessage[ 256 ];

    VERIFY( VrfLoadString( uIdString,
                           szMessage,
                           ARRAY_LENGTH( szMessage ) ) );

    if( g_bCommandLineMode )
    {
        //
        // Command console mode
        //

        _putts( szMessage );
    }
    else
    {
        //
        // GUI mode
        //

        AfxMessageBox( szMessage, 
                       MB_OK | MB_ICONINFORMATION );
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//

BOOL VrfLoadString( ULONG uIdResource,
                    TCHAR *szBuffer,
                    ULONG uBufferLength )
{
    ULONG uLoadStringResult;

    if( uBufferLength < 1 )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    uLoadStringResult = LoadString (
        g_hProgramModule,
        uIdResource,
        szBuffer,
        uBufferLength );

    //
    // We should never try to load non-existent strings.
    //

    ASSERT (uLoadStringResult > 0);

    return (uLoadStringResult > 0);
}

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//

BOOL VrfLoadString( ULONG uIdResource,
                    CString &strText )
{
    TCHAR szText[ 256 ];
    BOOL bSuccess;

    bSuccess = VrfLoadString( uIdResource,
                          szText,
                          ARRAY_LENGTH( szText ) );

    if( TRUE == bSuccess )
    {
        strText = szText;
    }
    else
    {
        strText = "";
    }

    return bSuccess;
}


///////////////////////////////////////////////////////////////////////////
VOID
CopyStringArray( const CStringArray &strArraySource,
                 CStringArray &strArrayDest )
{
    INT_PTR nNewSize;
    INT_PTR nCrtElem;

    strArrayDest.RemoveAll();

    nNewSize = strArraySource.GetSize();

    for( nCrtElem = 0; nCrtElem < nNewSize; nCrtElem += 1 )
    {
        strArrayDest.Add( strArraySource.GetAt( nCrtElem ) );
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Copied from sdktools\bvtsigvf
//

BOOL VerifyIsFileSigned( LPCTSTR pcszMatchFile, 
                         PDRIVER_VER_INFO lpVerInfo)
{
    HRESULT             hRes;
    WINTRUST_DATA       WinTrustData;
    WINTRUST_FILE_INFO  WinTrustFile;
    GUID                gOSVerCheck = DRIVER_ACTION_VERIFY;
    GUID                gPublishedSoftware = WINTRUST_ACTION_GENERIC_VERIFY_V2;
#ifndef UNICODE
    INT                 iRet;
    WCHAR               wszFileName[MAX_PATH];
#endif

    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pFile = &WinTrustFile;
    WinTrustData.pPolicyCallbackData = (LPVOID)lpVerInfo;
    
    ZeroMemory(lpVerInfo, sizeof(DRIVER_VER_INFO));
    lpVerInfo->cbStruct = sizeof(DRIVER_VER_INFO);

    ZeroMemory(&WinTrustFile, sizeof(WINTRUST_FILE_INFO));
    WinTrustFile.cbStruct = sizeof(WINTRUST_FILE_INFO);

#ifndef UNICODE
    iRet = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcszMatchFile, -1, wszFileName, ARRAY_LENGTH(wszFileName));
    WinTrustFile.pcwszFilePath = wszFileName;
#else
    WinTrustFile.pcwszFilePath = pcszMatchFile;
#endif

    hRes = WinVerifyTrust( AfxGetMainWnd()->m_hWnd, &gOSVerCheck, &WinTrustData);
    if (hRes != ERROR_SUCCESS)
        hRes = WinVerifyTrust( AfxGetMainWnd()->m_hWnd, &gPublishedSoftware, &WinTrustData);

    //
    // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
    // that was allocated in our call to WinVerifyTrust.
    //

    if (lpVerInfo && lpVerInfo->pcSignerCertContext) {

        CertFreeCertificateContext(lpVerInfo->pcSignerCertContext);
        lpVerInfo->pcSignerCertContext = NULL;
    }

    return (hRes == ERROR_SUCCESS);
}

#define HASH_SIZE   100

BOOL IsDriverSigned( LPCTSTR szDriverFileName )
{
    HANDLE hFile;
    BOOL bSigned;
    BOOL bSuccess;
    HRESULT hTrustResult;
    DWORD dwHashSize;
    GUID guidSubSystemDriver = DRIVER_ACTION_VERIFY;
    HCATINFO hCatInfo;
    HCATINFO hPrevCatInfo;
    BYTE Hash[ HASH_SIZE ];
    WINTRUST_DATA WinTrustData;
    DRIVER_VER_INFO VerInfo;
    WINTRUST_CATALOG_INFO WinTrustCatalogInfo;
    CATALOG_INFO CatInfo;

#ifndef UNICODE
    WCHAR szUnicodeFileName[MAX_PATH];
#endif

    ASSERT( NULL != szDriverFileName );

    bSigned = FALSE;

    //
    // Open the file
    //

    hFile = CreateFile( szDriverFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
                        
    if( hFile == INVALID_HANDLE_VALUE )
    {
        //
        // ISSUE:
        //
        // If we cannot find the file we assume it's signed
        //

        bSigned = TRUE;

        goto Done;
    }

    //
    // Generate the hash from the file handle and store it in Hash
    //

    dwHashSize = ARRAY_LENGTH( Hash );

    ZeroMemory( Hash, 
                sizeof( Hash ) );

    bSuccess = CryptCATAdminCalcHashFromFileHandle( hFile, 
                                                          &dwHashSize, 
                                                          Hash, 
                                                          0);

    CloseHandle( hFile );

    if( TRUE != bSuccess )
    {
        //
        // If we couldn't generate a hash assume the file is not signed
        //

        goto Done;
    }

    //
    // Now we have the file's hash.  Initialize the structures that
    // will be used later on in calls to WinVerifyTrust.
    //

    //
    // Initialize the VerInfo structure
    //

    ZeroMemory( &VerInfo, sizeof( VerInfo ) );

    VerInfo.cbStruct = sizeof( VerInfo );

    //
    // Initialize the WinTrustCatalogInfo structure
    //

    ZeroMemory( &WinTrustCatalogInfo, sizeof( WinTrustCatalogInfo ) );

    WinTrustCatalogInfo.cbStruct = sizeof(WinTrustCatalogInfo);
    WinTrustCatalogInfo.pbCalculatedFileHash = Hash;
    WinTrustCatalogInfo.cbCalculatedFileHash = dwHashSize;

#ifdef UNICODE

    WinTrustCatalogInfo.pcwszMemberTag = szDriverFileName;

#else

    MultiByteToWideChar( CP_ACP, 
                         0, 
                         szDriverFileName, 
                         -1, 
                         szUnicodeFileName, 
                         ARRAY_LENGTH( szUnicodeFileName ) );

    WinTrustCatalogInfo.pcwszMemberTag = szUnicodeFileName;

#endif
    
    //
    // Initialize the WinTrustData structure
    //

    ZeroMemory( &WinTrustData, sizeof( WinTrustData ) );
    
    WinTrustData.cbStruct = sizeof( WinTrustData );
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pPolicyCallbackData = (LPVOID)&VerInfo;
    
    WinTrustData.pCatalog = &WinTrustCatalogInfo;

    //
    // If we don't have a g_hCatAdmin yet, acquire one
    //

    if( NULL == g_hCatAdmin )
    {
        CryptCATAdminAcquireContext( &g_hCatAdmin, 
                                     NULL, 
                                     0);

        if( NULL == g_hCatAdmin )
        {
            //
            // Bad luck - consider that the file is not signed and bail out
            //

            goto Done;            
        }
    }
    
    //
    // Now we try to find the file hash in the catalog list, via CryptCATAdminEnumCatalogFromHash
    //

    hPrevCatInfo = NULL;
    
    hCatInfo = CryptCATAdminEnumCatalogFromHash(
        g_hCatAdmin, 
        Hash, 
        dwHashSize, 
        0, 
        &hPrevCatInfo );

    while( TRUE != bSigned && NULL != hCatInfo )
    {
        ZeroMemory( &CatInfo, sizeof( CatInfo ) );
        CatInfo.cbStruct = sizeof( CatInfo );

        bSuccess = CryptCATCatalogInfoFromContext( hCatInfo, 
                                                   &CatInfo, 
                                                   0);

        if( FALSE != bSuccess )
        {
            WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

            //
            // Now verify that the file is an actual member of the catalog.
            //

            hTrustResult = WinVerifyTrust( AfxGetMainWnd()->m_hWnd, 
                                           &guidSubSystemDriver, 
                                           &WinTrustData );

            bSigned = SUCCEEDED( hTrustResult );

            //
            // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
            // that was allocated in our call to WinVerifyTrust.
            //

            if( VerInfo.pcSignerCertContext != NULL ) 
            {
                CertFreeCertificateContext( VerInfo.pcSignerCertContext );
                VerInfo.pcSignerCertContext = NULL;
            }
        }

        if( TRUE != bSigned )
        {
            //
            // The hash was in this catalog, but the file wasn't a member... so off to the next catalog
            //

            hPrevCatInfo = hCatInfo;

            hCatInfo = CryptCATAdminEnumCatalogFromHash( g_hCatAdmin, 
                                                         Hash, 
                                                         dwHashSize, 
                                                         0, 
                                                         &hPrevCatInfo );
        }
    }

    if( NULL == hCatInfo )
    {
        //
        // If it wasn't found in the catalogs, check if the file is individually signed.
        //

        bSigned = VerifyIsFileSigned( szDriverFileName,
                                      &VerInfo );
    }

Done:

    return bSigned;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfSetWindowText( CWnd &Wnd,
                       ULONG uIdResourceString )
{
    BOOL bLoaded;
    CString strText;

    //
    // It's safe to use CString::LoadString here because we are 
    // in GUI mode
    //

    ASSERT( FALSE == g_bCommandLineMode );

    bLoaded = strText.LoadString( uIdResourceString );

    ASSERT( TRUE == bLoaded );

    Wnd.SetWindowText( strText );

    return ( TRUE == bLoaded );
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfWriteVerifierSettings( BOOL bHaveNewDrivers,
                               const CString &strDriversToVerify,
                               BOOL bHaveNewFlags,
                               DWORD dwVerifyFlags )
{
    HKEY hMmKey = NULL;
    LONG lResult;
    BOOL bSuccess;

    ASSERT( bHaveNewDrivers || bHaveNewFlags );

    if( bHaveNewDrivers && strDriversToVerify.GetLength() == 0 )
    {
        //
        // No drivers to verify
        //

        return VrfDeleteAllVerifierSettings();
    }

    if( bHaveNewFlags )
    {
        TRACE( _T( "VrfWriteVerifierSettings: New verifier flags = %#x\n" ),
            dwVerifyFlags );
    }
    
    if( bHaveNewDrivers )
    {
        TRACE( _T( "VrfWriteVerifierSettings: New drivers = %s\n" ),
            (LPCTSTR) strDriversToVerify );
    }

    //
    // Open the Mm key
    //

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            RegMemoryManagementKeyName,
                            0,
                            KEY_SET_VALUE,
                            &hMmKey );

    if( lResult != ERROR_SUCCESS ) 
    {
        if( lResult == ERROR_ACCESS_DENIED ) 
        {
            VrfErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            VrfErrorResourceFormat(
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lResult);
        }

        goto Done;
    }

    if( bHaveNewFlags )
    {
        //
        // Write VerifyDriverLevel value
        //

        if( VrfWriteRegistryDwordValue( hMmKey, 
                                        RegVerifyDriverLevelValueName, 
                                        dwVerifyFlags ) == FALSE ) 
        {
            RegCloseKey (hMmKey);

            goto Done;
        }
    }

    if( bHaveNewDrivers )
    {
        //
        // Write VerifyDrivers value
        //

        if( VrfWriteRegistryStringValue( hMmKey, 
                                         RegVerifyDriversValueName, 
                                         strDriversToVerify ) == FALSE ) 
        {
            RegCloseKey (hMmKey);
        
            goto Done;
        }
    }

    //
    // Close the Mm key and return success
    //

    RegCloseKey( hMmKey );

Done:
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfWriteRegistryDwordValue( HKEY hKey,
                                 LPCTSTR szValueName,
                                 DWORD dwValue )
{
    LONG lResult;
    BOOL bSuccess;

    lResult = RegSetValueEx( hKey,
                            szValueName,
                            0,
                            REG_DWORD,
                            ( LPBYTE ) &dwValue,
                            sizeof( dwValue ) );

    bSuccess = ( lResult == ERROR_SUCCESS );

    g_bSettingsSaved = g_bSettingsSaved | bSuccess;

    if( TRUE != bSuccess ) 
    {
        VrfErrorResourceFormat(
            IDS_REGSETVALUEEX_FAILED,
            szValueName,
            (DWORD) lResult );
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfWriteRegistryStringValue( HKEY hKey,
                                  LPCTSTR szValueName,
                                  LPCTSTR szValue )
{
    BOOL bSuccess;
    LONG lResult;

    lResult = RegSetValueEx ( hKey,
                              szValueName,
                              0,
                              REG_SZ,
                              (LPBYTE) szValue,
                              ( _tcslen( szValue ) + 1 ) * sizeof (TCHAR) );

    bSuccess = ( lResult == ERROR_SUCCESS );

    g_bSettingsSaved = g_bSettingsSaved | bSuccess;

    if( TRUE != bSuccess ) 
    {
        VrfErrorResourceFormat(
            IDS_REGSETVALUEEX_FAILED,
            szValueName,
            (DWORD) lResult);
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfReadVerifierSettings( CString &strDriversToVerify,
                              DWORD &dwVerifyFlags )
{
    HKEY hMmKey = NULL;
    LONG lResult;
    BOOL bSuccess;

    bSuccess = FALSE;

    //
    // Open the Mm key
    //

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            RegMemoryManagementKeyName,
                            0,
                            KEY_QUERY_VALUE,
                            &hMmKey );

    if( lResult != ERROR_SUCCESS ) 
    {
        if( lResult == ERROR_ACCESS_DENIED ) 
        {
            VrfErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            VrfErrorResourceFormat(
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lResult);
        }

        goto Done;
    }

    //
    // Read VerifyDriverLevel value
    //

    if( VrfReadRegistryDwordValue( hMmKey, 
                                   RegVerifyDriverLevelValueName, 
                                   dwVerifyFlags ) == FALSE ) 
    {
        RegCloseKey (hMmKey);

        goto Done;
    }

    //
    // Read VerifyDrivers value
    //

    if( VrfReadRegistryStringValue( hMmKey, 
                                    RegVerifyDriversValueName, 
                                    strDriversToVerify ) == FALSE ) 
    {
        RegCloseKey (hMmKey);
        
        goto Done;
    }

    //
    // Close the Mm key and return success
    //

    RegCloseKey( hMmKey );

    bSuccess = TRUE;

Done:
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrtLoadCurrentRegistrySettings( BOOL &bAllDriversVerified,
                                     CStringArray &astrDriversToVerify,
                                     DWORD &dwVerifyFlags )
{
    BOOL bResult;
    CString strDriversToVerify;

    astrDriversToVerify.RemoveAll();
    dwVerifyFlags = 0;
    bAllDriversVerified = FALSE;

    bResult = VrfReadVerifierSettings( strDriversToVerify,
                                       dwVerifyFlags );

    strDriversToVerify.TrimLeft();
    strDriversToVerify.TrimRight();

    if( strDriversToVerify.CompareNoCase( _T( "*" ) ) == 0 )
    {
        bAllDriversVerified = TRUE;
    }
    else
    {
        VrfSplitDriverNamesSpaceSeparated( strDriversToVerify,
                                           astrDriversToVerify );
    }

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
VOID VrfSplitDriverNamesSpaceSeparated( CString strAllDrivers,
                                        CStringArray &astrVerifyDriverNames )
{
    INT nCharIndex;
    CString strCrtDriverName;

    astrVerifyDriverNames.RemoveAll();

    //
    // Split the space separated driver names in astrDriversToVerify
    //

    strAllDrivers.TrimRight();

    while( TRUE )
    {
        strAllDrivers.TrimLeft();

        if( strAllDrivers.GetLength() == 0 )
        {
            //
            // We are done parsing the whole string
            //

            break;
        }

        //
        // Look for a space or a tab
        //

        nCharIndex = strAllDrivers.Find( _T( ' ' ) );

        if( nCharIndex < 0 )
        {
            nCharIndex = strAllDrivers.Find( _T( '\t' ) );
        }

        if( nCharIndex >= 0 )
        {
            //
            // Found a separator  character
            //

            strCrtDriverName = strAllDrivers.Left( nCharIndex );

            if( strCrtDriverName.GetLength() > 0 &&
                FALSE == VrfIsStringInArray( strCrtDriverName,
                                             astrVerifyDriverNames ) )
            {
                astrVerifyDriverNames.Add( strCrtDriverName );
            }

            strAllDrivers = strAllDrivers.Right( strAllDrivers.GetLength() - nCharIndex - 1 );
        }
        else
        {
            //
            // This is the last driver name
            //

            if( FALSE == VrfIsStringInArray( strAllDrivers,
                                             astrVerifyDriverNames ) )
            {
                astrVerifyDriverNames.Add( strAllDrivers );
            }

            break;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsDriversSetDifferent( CString strAllDrivers1, 
                               const CStringArray &astrVerifyDriverNames2 )
{
    BOOL bDifferent;
    INT_PTR nDriverNames1;
    INT_PTR nDriverNames2;
    INT_PTR nCrtDriver1;
    INT_PTR nCrtDriver2;
    CString strDriver1;
    CString strDriver2;
    CStringArray astrVerifyDriverNames1;

    bDifferent = TRUE;

    VrfSplitDriverNamesSpaceSeparated( strAllDrivers1,
                                       astrVerifyDriverNames1 );

    nDriverNames1 = astrVerifyDriverNames1.GetSize();
    nDriverNames2 = astrVerifyDriverNames2.GetSize();

    if( nDriverNames1 == nDriverNames2 )
    {
        //
        // Same number of drivers
        //

        bDifferent = FALSE;

        for( nCrtDriver1 = 0; nCrtDriver1 < nDriverNames1; nCrtDriver1 += 1 )
        {
            strDriver1 = astrVerifyDriverNames1.GetAt( nCrtDriver1 );

            bDifferent = TRUE;

            //
            // Look for strDriver1 in astrVerifyDriverNames2
            //

            for( nCrtDriver2 = 0; nCrtDriver2 < nDriverNames2; nCrtDriver2 += 1 )
            {
                strDriver2 = astrVerifyDriverNames2.GetAt( nCrtDriver2 );

                if( strDriver1.CompareNoCase( strDriver2 ) == 0 )
                {
                    bDifferent = FALSE;

                    break;
                }
            }

            if( TRUE == bDifferent )
            {
                //
                // Did not find strDriver1 in astrVerifyDriverNames2
                //

                break;
            }
        }
    }

    return bDifferent;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfReadRegistryDwordValue( HKEY hKey,
                                LPCTSTR szValueName,
                                DWORD &dwValue )
{
    LONG lResult;
    BOOL bSuccess;
    DWORD dwType;
    DWORD dwDataSize;

    dwDataSize = sizeof( dwValue );

    lResult = RegQueryValueEx( hKey,
                               szValueName,
                               0,
                               &dwType,
                               ( LPBYTE ) &dwValue,
                               &dwDataSize );

    if( lResult == ERROR_FILE_NOT_FOUND )
    {
        //
        // The value doesn't currently exist
        //

        dwValue = 0;
        bSuccess = TRUE;
    }
    else
    {
        bSuccess = ( ERROR_SUCCESS == lResult && 
                     REG_DWORD == dwType &&
                     dwDataSize == sizeof( dwValue ) );
    }

    if( TRUE != bSuccess ) 
    {
        VrfErrorResourceFormat(
            IDS_REGQUERYVALUEEX_FAILED,
            szValueName,
            (DWORD) lResult );
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfReadRegistryStringValue( HKEY hKey,
                                 LPCTSTR szValueName,
                                 CString &strDriversToVerify )
{
    BOOL bSuccess;
    LONG lResult;
    LPTSTR szDriversToVerify;
    ULONG uRegKeyLength;
    DWORD dwType;
    DWORD dwDataSize;

    bSuccess = FALSE;
    lResult = ERROR_NOT_ENOUGH_MEMORY;
    szDriversToVerify = NULL;

    for( uRegKeyLength = 128; uRegKeyLength < 4096; uRegKeyLength += 128 )
    {
        //
        // Try allocate a local buffer and use it to query
        //

        szDriversToVerify = new TCHAR[ uRegKeyLength ];

        if( NULL != szDriversToVerify )
        {
            dwDataSize = uRegKeyLength * sizeof (TCHAR);

            lResult = RegQueryValueEx( hKey,
                                       szValueName,
                                       0,
                                       &dwType,
                                       (LPBYTE) szDriversToVerify,
                                       &dwDataSize );

            switch( lResult )
            {
            case ERROR_FILE_NOT_FOUND:
                //
                // Return an empty string
                //

                szDriversToVerify[ 0 ] = (TCHAR)0;

                bSuccess = TRUE;
                
                break;

            case ERROR_SUCCESS:
                //
                // Got the driver names from the registry
                //

                bSuccess = ( REG_SZ == dwType );

                break;

            default:
                //
                // Try with a bigger buffer
                //

                break;
            }

        }

        if( FALSE != bSuccess )
        {
            //
            // Got what we needed
            //

            break;
        }
        else
        {
            //
            // Delete the current buffer and try with a bigger one
            //

            ASSERT( NULL != szDriversToVerify );

            strDriversToVerify = szDriversToVerify;

            delete [] szDriversToVerify;
            szDriversToVerify = NULL;
        }
    }

    if( TRUE != bSuccess ) 
    {
        VrfErrorResourceFormat(
            IDS_REGSETVALUEEX_FAILED,
            szValueName,
            (DWORD) lResult);
    }
    else
    {
        ASSERT( NULL != szDriversToVerify );

        strDriversToVerify = szDriversToVerify;

        delete [] szDriversToVerify;
        szDriversToVerify = NULL;
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfDeleteAllVerifierSettings()
{
    HKEY hMmKey = NULL;
    LONG lResult;
    BOOL bSuccess;

    bSuccess = FALSE;

    //
    // Open the Mm key
    //

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            RegMemoryManagementKeyName,
                            0,
                            KEY_SET_VALUE,
                            &hMmKey );

    if( lResult != ERROR_SUCCESS ) 
    {
        if( lResult == ERROR_ACCESS_DENIED ) 
        {
            VrfErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            VrfErrorResourceFormat(
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lResult);
        }

        goto Done;
    }

    //
    // Delete VerifyDriverLevel value
    //

    lResult = RegDeleteValue( hMmKey, 
                              RegVerifyDriverLevelValueName );

    if( lResult != ERROR_SUCCESS && lResult != ERROR_FILE_NOT_FOUND ) 
    {
        VrfErrorResourceFormat(
            IDS_REGDELETEVALUE_FAILED,
            RegVerifyDriverLevelValueName,
            (DWORD) lResult );

        RegCloseKey (hMmKey);

        goto Done;
    }

    g_bSettingsSaved = g_bSettingsSaved | ( lResult != ERROR_FILE_NOT_FOUND );

    //
    // Delete VerifyDrivers value
    //

    lResult = RegDeleteValue( hMmKey, 
                              RegVerifyDriversValueName );
 
    if( lResult != ERROR_SUCCESS && lResult != ERROR_FILE_NOT_FOUND ) 
    {
        VrfErrorResourceFormat(
            IDS_REGDELETEVALUE_FAILED,
            RegVerifyDriversValueName,
            (DWORD) lResult );

        RegCloseKey (hMmKey);
        
        goto Done;
    }

    g_bSettingsSaved = g_bSettingsSaved | ( lResult != ERROR_FILE_NOT_FOUND );

    //
    // Close the Mm key and return success
    //

    RegCloseKey( hMmKey );

    //
    // Delete the disk verifier settings.
    //

    bSuccess = DeleteAllDiskVerifierSettings();

Done:
    
    return bSuccess;
}

//////////////////////////////////////////////////////////////////////
BOOL DeleteAllDiskVerifierSettings()
{
    BOOL bSuccess;
    INT_PTR nArraySize;
    CDiskData *pOldDiskData;
    LPTSTR szDiskDevicesPDOName;

    bSuccess = TRUE;

    nArraySize = g_OldDiskData.GetSize();

    while( nArraySize > 0 )
    {
        nArraySize -= 1;
        
        pOldDiskData = g_OldDiskData.GetAt( nArraySize );
        ASSERT_VALID( pOldDiskData );

        if( FALSE != pOldDiskData->m_bVerifierEnabled )
        {
            szDiskDevicesPDOName = pOldDiskData->m_strDiskDevicesPDOName.GetBuffer( 
                pOldDiskData->m_strDiskDevicesPDOName.GetLength() + 1 );

            if( NULL == szDiskDevicesPDOName )
            {
                bSuccess = FALSE;
                break;
            }

            //
            // Verifier will be disabled for this disk.
            //

            bSuccess = ( DelFilter( g_szFilter,
                                    szDiskDevicesPDOName ) != FALSE);

            pOldDiskData->m_strDiskDevicesPDOName.ReleaseBuffer();

            if( FALSE == bSuccess )
            {
                break;
            }
            else
            {
                g_bSettingsSaved = TRUE;
            }
        }
    }

    return bSuccess;
}


/////////////////////////////////////////////////////////////////////////////
BOOL VrfGetRuntimeVerifierData( CRuntimeVerifierData *pRuntimeVerifierData )
{
    NTSTATUS Status;
    ULONG Length = 0;
    ULONG buffersize;
    BOOL bSuccess;
    PSYSTEM_VERIFIER_INFORMATION VerifierInfo;
    PSYSTEM_VERIFIER_INFORMATION VerifierInfoBase;
    CRuntimeDriverData *pCrtDriverData;
    LPTSTR szName;

    ASSERT_VALID( pRuntimeVerifierData );

    pRuntimeVerifierData->FillWithDefaults();

    pRuntimeVerifierData->m_RuntimeDriverDataArray.DeleteAll();

    bSuccess = FALSE;

    //
    // Try to get the right size for the NtQuery buffer
    //

    buffersize = 1024;

    do 
    {
        VerifierInfo = (PSYSTEM_VERIFIER_INFORMATION)malloc (buffersize);
        
        if (VerifierInfo == NULL) 
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = NtQuerySystemInformation (SystemVerifierInformation,
                                           VerifierInfo,
                                           buffersize,
                                           &Length);

        if (Status != STATUS_INFO_LENGTH_MISMATCH) 
        {
            break;
        }

        free (VerifierInfo);
        buffersize += 1024;

    } while (1);

    if (! NT_SUCCESS(Status)) 
    {
        VrfErrorResourceFormat(
            IDS_QUERY_SYSINFO_FAILED,
            Status);

        goto Done;
    }

    //
    // If no info fill out return success but no info.
    //

    if (Length == 0) 
    {
        free (VerifierInfo);
        
        bSuccess = TRUE;

        goto Done;
    }

    //
    // Fill out the cumulative-driver stuff.
    //

    VerifierInfoBase = VerifierInfo;

    pRuntimeVerifierData->m_bSpecialPool    = (VerifierInfo->Level & DRIVER_VERIFIER_SPECIAL_POOLING) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bForceIrql      = (VerifierInfo->Level & DRIVER_VERIFIER_FORCE_IRQL_CHECKING) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bLowRes         = (VerifierInfo->Level & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bPoolTracking   = (VerifierInfo->Level & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bIo             = (VerifierInfo->Level & DRIVER_VERIFIER_IO_CHECKING) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bDeadlockDetect = (VerifierInfo->Level & DRIVER_VERIFIER_DEADLOCK_DETECTION) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bDMAVerif       = (VerifierInfo->Level & DRIVER_VERIFIER_DMA_VERIFIER) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bEnhIo          = (VerifierInfo->Level & DRIVER_VERIFIER_ENHANCED_IO_CHECKING) ? TRUE : FALSE;

    pRuntimeVerifierData->RaiseIrqls = VerifierInfo->RaiseIrqls;
    pRuntimeVerifierData->AcquireSpinLocks = VerifierInfo->AcquireSpinLocks;
    pRuntimeVerifierData->SynchronizeExecutions = VerifierInfo->SynchronizeExecutions;
    pRuntimeVerifierData->AllocationsAttempted = VerifierInfo->AllocationsAttempted;
    pRuntimeVerifierData->AllocationsSucceeded = VerifierInfo->AllocationsSucceeded;
    pRuntimeVerifierData->AllocationsSucceededSpecialPool = VerifierInfo->AllocationsSucceededSpecialPool;
    pRuntimeVerifierData->AllocationsWithNoTag = VerifierInfo->AllocationsWithNoTag;

    pRuntimeVerifierData->Trims = VerifierInfo->Trims;
    pRuntimeVerifierData->AllocationsFailed = VerifierInfo->AllocationsFailed;
    pRuntimeVerifierData->AllocationsFailedDeliberately = VerifierInfo->AllocationsFailedDeliberately;

    pRuntimeVerifierData->UnTrackedPool = VerifierInfo->UnTrackedPool;
    
    pRuntimeVerifierData->Level = VerifierInfo->Level;

    //
    // Fill out the per-driver stuff.
    //

    VerifierInfo = VerifierInfoBase;

    do 
    {
        //
        // Allocate a new driver data structure
        //

        pCrtDriverData = new CRuntimeDriverData;
        
        if( NULL == pCrtDriverData )
        {
            VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

            break;
        }

#ifndef UNICODE
        ANSI_STRING Name;
        NTSTATUS Status;

        Status = RtlUnicodeStringToAnsiString (
            & Name,
            & VerifierInfo->DriverName,
            TRUE);

        if (! (NT_SUCCESS(Status) ) ) 
        {
            VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

            break;
        }

        szName = pCrtDriverData->m_strName.GetBuffer( Name.Length + 1 );

        if( NULL != szName )
        {
            CopyMemory( szName,
                        Name.Buffer,
                        ( Name.Length + 1 ) * sizeof( Name.Buffer[ 0 ] ) );

            szName[ Name.Length ] = 0;

            pCrtDriverData->m_strName.ReleaseBuffer();
        }

        RtlFreeAnsiString (& Name);

#else

        szName = pCrtDriverData->m_strName.GetBuffer( VerifierInfo->DriverName.Length + 1 );

        if( NULL != szName )
        {
            CopyMemory( szName,
                        VerifierInfo->DriverName.Buffer,
                        ( VerifierInfo->DriverName.Length + 1 ) * sizeof( VerifierInfo->DriverName.Buffer[ 0 ] ) );

            szName[ VerifierInfo->DriverName.Length ] = 0;
            
            pCrtDriverData->m_strName.ReleaseBuffer();
        }

#endif //#ifndef UNICODE

        if( FALSE != pRuntimeVerifierData->IsDriverVerified( pCrtDriverData->m_strName ) )
        {
            //
            // This is a duplicate entry - ignore it.
            //

            delete pCrtDriverData;
        }
        else 
        {
            pCrtDriverData->Loads = VerifierInfo->Loads;
            pCrtDriverData->Unloads = VerifierInfo->Unloads;

            pCrtDriverData->CurrentPagedPoolAllocations = VerifierInfo->CurrentPagedPoolAllocations;
            pCrtDriverData->CurrentNonPagedPoolAllocations = VerifierInfo->CurrentNonPagedPoolAllocations;
            pCrtDriverData->PeakPagedPoolAllocations = VerifierInfo->PeakPagedPoolAllocations;
            pCrtDriverData->PeakNonPagedPoolAllocations = VerifierInfo->PeakNonPagedPoolAllocations;

            pCrtDriverData->PagedPoolUsageInBytes = VerifierInfo->PagedPoolUsageInBytes;
            pCrtDriverData->NonPagedPoolUsageInBytes = VerifierInfo->NonPagedPoolUsageInBytes;
            pCrtDriverData->PeakPagedPoolUsageInBytes = VerifierInfo->PeakPagedPoolUsageInBytes;
            pCrtDriverData->PeakNonPagedPoolUsageInBytes = VerifierInfo->PeakNonPagedPoolUsageInBytes;

            pRuntimeVerifierData->m_RuntimeDriverDataArray.Add( pCrtDriverData );
        }

        if (VerifierInfo->NextEntryOffset == 0) {
            break;
        }

        VerifierInfo = (PSYSTEM_VERIFIER_INFORMATION)((PCHAR)VerifierInfo + VerifierInfo->NextEntryOffset);

    } 
    while (1);

    free (VerifierInfoBase);

Done:
    return TRUE;

}

/////////////////////////////////////////////////////////////////////
PLOADED_IMAGE VrfImageLoad( LPTSTR szBinaryName,
                            LPTSTR szDirectory )
{
#ifdef UNICODE

    char *szOemImageName;
    char *szOemDirectory;
    int nStringLength;
    PLOADED_IMAGE pLoadedImage;

    pLoadedImage = NULL;
        
    nStringLength = wcslen( szBinaryName );

    szOemImageName = new char [ nStringLength + 1 ];
    
    if( NULL != szOemImageName )
    {
        CharToOem( szBinaryName,
                   szOemImageName );

        if( NULL == szDirectory )
        {
            szOemDirectory = NULL;
        }
        else
        {
            nStringLength = wcslen( szDirectory );
            
            szOemDirectory = new char [ nStringLength + 1 ];

            if (NULL != szOemDirectory)
            {
                CharToOem( szDirectory,
                        szOemDirectory );
            }
        }

        pLoadedImage = ImageLoad( szOemImageName,
                                  szOemDirectory );

        if( NULL != szOemDirectory )
        {
            delete [] szOemDirectory;
        }

        delete [] szOemImageName;
    }

    return pLoadedImage;

#else

    //
    // Already have ANSI strings
    //

    return ImageLoad( szBinaryName,
                      szDirectory );

#endif //#ifdef UNICODE
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfDumpStateToFile( FILE *file )
{
    BOOL bSuccess;
    INT_PTR nDriversNo;
    INT_PTR nCrtDriver;
    SYSTEMTIME SystemTime;
    TCHAR strLocalTime[ 64 ];
    TCHAR strLocalDate[ 64 ];
    CRuntimeDriverData *pRunDriverData;
    CRuntimeVerifierData RunTimeVerifierData;

    //
    // Output the date&time in the current user format
    //

    GetLocalTime( &SystemTime );

    if( GetDateFormat(
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        NULL,
        strLocalDate,
        ARRAY_LENGTH( strLocalDate ) ) )
    {
        VrfFTPrintf(
            file,
            _T( "%s, " ),
            strLocalDate );
    }
    else
    {
        ASSERT( FALSE );
    }

    if( GetTimeFormat(
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        NULL,
        strLocalTime,
        ARRAY_LENGTH( strLocalTime ) ) )
    {
        VrfFTPrintf(
            file,
            _T( "%s\n" ),
            strLocalTime);
    }
    else
    {
        ASSERT( FALSE );

        VrfFTPrintf(
            file,
            _T( "\n" ) );
    }

    //
    // Get the current verifier statistics
    //

    if( VrfGetRuntimeVerifierData( &RunTimeVerifierData ) == FALSE) {

       VrfOuputStringFromResources(
            IDS_CANTGET_VERIF_STATE,
            file );

        bSuccess = FALSE;
        
        goto Done;
    }

    nDriversNo = RunTimeVerifierData.m_RuntimeDriverDataArray.GetSize();

    if( 0 == nDriversNo ) 
    {
        //
        // no statistics to dump
        //

        bSuccess = VrfOuputStringFromResources(
            IDS_NO_DRIVER_VERIFIED,
            file );
    }
    else 
    {
        //
        // dump the counters
        //

        //
        // global counters
        //

        if( ( ! VrfFTPrintfResourceFormat( file, IDS_LEVEL, RunTimeVerifierData.Level ) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_RAISEIRQLS, RunTimeVerifierData.RaiseIrqls ) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_ACQUIRESPINLOCKS, RunTimeVerifierData.AcquireSpinLocks ) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_SYNCHRONIZEEXECUTIONS, RunTimeVerifierData.SynchronizeExecutions) ) ||

            ( ! VrfFTPrintfResourceFormat( file, IDS_ALLOCATIONSATTEMPTED, RunTimeVerifierData.AllocationsAttempted) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_ALLOCATIONSSUCCEEDED, RunTimeVerifierData.AllocationsSucceeded) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_ALLOCATIONSSUCCEEDEDSPECIALPOOL, RunTimeVerifierData.AllocationsSucceededSpecialPool) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_ALLOCATIONSWITHNOTAG, RunTimeVerifierData.AllocationsWithNoTag) ) ||

            ( ! VrfFTPrintfResourceFormat( file, IDS_ALLOCATIONSFAILED, RunTimeVerifierData.AllocationsFailed) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_ALLOCATIONSFAILEDDELIBERATELY, RunTimeVerifierData.AllocationsFailedDeliberately) ) ||

            ( ! VrfFTPrintfResourceFormat( file, IDS_TRIMS, RunTimeVerifierData.Trims) ) ||

            ( ! VrfFTPrintfResourceFormat( file, IDS_UNTRACKEDPOOL, RunTimeVerifierData.UnTrackedPool) ) )
        {

            bSuccess = FALSE;

            goto Done;
        }

        //
        // per driver counters
        //

        if( ! VrfOuputStringFromResources(
            IDS_THE_VERIFIED_DRIVERS,
            file ) )
        {
            bSuccess = FALSE;

            goto Done;
        }

        for( nCrtDriver = 0; nCrtDriver < nDriversNo; nCrtDriver += 1 ) 
        {
            VrfFTPrintf(
                file,
                _T( "\n" ) );

            pRunDriverData = RunTimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtDriver ) ;

            ASSERT_VALID( pRunDriverData );

            if( VrfFTPrintfResourceFormat(
                    file,
                    IDS_NAME_LOADS_UNLOADS,
                    (LPCTSTR)pRunDriverData->m_strName,
                    pRunDriverData->Loads,
                    pRunDriverData->Unloads) == FALSE )
            {
                bSuccess = FALSE;

                goto Done;
            }

            //
            // pool statistics
            //

            if( ( ! VrfFTPrintfResourceFormat( file, IDS_CURRENTPAGEDPOOLALLOCATIONS, pRunDriverData->CurrentPagedPoolAllocations) ) ||
                ( ! VrfFTPrintfResourceFormat( file, IDS_CURRENTNONPAGEDPOOLALLOCATIONS, pRunDriverData->CurrentNonPagedPoolAllocations) ) ||
                ( ! VrfFTPrintfResourceFormat( file, IDS_PEAKPAGEDPOOLALLOCATIONS, pRunDriverData->PeakPagedPoolAllocations) ) ||
                ( ! VrfFTPrintfResourceFormat( file, IDS_PEAKNONPAGEDPOOLALLOCATIONS, pRunDriverData->PeakNonPagedPoolAllocations) ) ||

                ( ! VrfFTPrintfResourceFormat( file, IDS_PAGEDPOOLUSAGEINBYTES, (ULONG) pRunDriverData->PagedPoolUsageInBytes) ) ||
                ( ! VrfFTPrintfResourceFormat( file, IDS_NONPAGEDPOOLUSAGEINBYTES, (ULONG) pRunDriverData->NonPagedPoolUsageInBytes) ) ||
                ( ! VrfFTPrintfResourceFormat( file, IDS_PEAKPAGEDPOOLUSAGEINBYTES, (ULONG) pRunDriverData->PeakPagedPoolUsageInBytes) ) ||
                ( ! VrfFTPrintfResourceFormat( file, IDS_PEAKNONPAGEDPOOLUSAGEINBYTES, (ULONG) pRunDriverData->PeakNonPagedPoolUsageInBytes) ) )
            {
                bSuccess = FALSE;

                goto Done;
            }
        }
    }

Done:

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL __cdecl VrfFTPrintf( FILE *file,
                          LPCTSTR szFormat,
                          ... )
{
    TCHAR szMessage[ 256 ];
    BOOL bResult;
    va_list prms;

    ASSERT( NULL != file );
    ASSERT( g_bCommandLineMode );

    va_start (prms, szFormat);

    //
    // Format the message in our local buffer
    //

    _vsntprintf ( szMessage, 
                  ARRAY_LENGTH( szMessage ), 
                  szFormat, 
                  prms );

    szMessage[ ARRAY_LENGTH( szMessage ) - 1 ] = 0;

    bResult = ( _fputts( szMessage, file ) >= 0 );

    va_end (prms);

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
BOOL __cdecl VrfFTPrintfResourceFormat( FILE *file,
                                        UINT uIdResourceFormat,
                                        ... )
{
    TCHAR szMessage[ 256 ];
    TCHAR strFormat[ 256 ];
    BOOL bResult;
    va_list prms;
    
    ASSERT( NULL != file );

    //
    // Load the format string from the resources
    //

    bResult = VrfLoadString( uIdResourceFormat,
                             strFormat,
                             ARRAY_LENGTH( strFormat ) );

    ASSERT( bResult );

    if( bResult )
    {
        va_start (prms, uIdResourceFormat);

        //
        // Format the message in our local buffer
        //

        _vsntprintf ( szMessage, 
                      ARRAY_LENGTH( szMessage ), 
                      strFormat, 
                      prms);

        szMessage[ ARRAY_LENGTH( szMessage ) - 1 ] = (TCHAR)0;

        bResult = ( _fputts( szMessage, file ) >= 0 );

        va_end (prms);
    }

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfOuputStringFromResources( UINT uIdString,
                                  FILE *file )
{
    TCHAR szText[ 256 ];
    BOOL bResult;

    ASSERT( NULL != file );

    bResult = VrfLoadString( uIdString,
                             szText,
                             ARRAY_LENGTH( szText ) );

    if( FALSE == bResult )
    {
        goto Done;
    }

    bResult = ( _fputts( szText, file ) >= 0 );

Done:

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfSetNewFlagsVolatile( DWORD dwNewFlags )
{
    BOOL bResult;
    NTSTATUS Status;
    INT_PTR nCurrentlyVerifiedDrivers;
    CRuntimeVerifierData RunTimeVerifierData;

    bResult = TRUE;

    nCurrentlyVerifiedDrivers = 0;

    if( VrfGetRuntimeVerifierData( &RunTimeVerifierData ) == FALSE )
    {
        //
        // Cannot get current verifier settings
        //

        VrfErrorResourceFormat( IDS_CANTGET_VERIF_STATE );

        bResult = FALSE;

        goto Done;
    }

    nCurrentlyVerifiedDrivers = RunTimeVerifierData.m_RuntimeDriverDataArray.GetSize();

    if( nCurrentlyVerifiedDrivers > 0 )
    {
        //
        // There are some drivers currently verified
        //

        if( RunTimeVerifierData.Level != dwNewFlags )
        {
            //
            // Just use NtSetSystemInformation to set the flags
            // that can be modified on the fly. Don't write anything to the registry.
            //

            //
            // Enable debug privilege
            //

            if( g_bPrivilegeEnabled != TRUE )
            {
                g_bPrivilegeEnabled = VrfEnableDebugPrivilege();

                if( g_bPrivilegeEnabled != TRUE )
                {
                    bResult = FALSE;

                    goto Done;
                }
            }

            //
            // Set the new flags
            //

            Status = NtSetSystemInformation(
                SystemVerifierInformation,
                &dwNewFlags,
                sizeof( dwNewFlags ) );

            if( ! NT_SUCCESS( Status ) )
            {
                if( Status == STATUS_ACCESS_DENIED )
                {
                    //
                    // Access denied
                    //

                    VrfErrorResourceFormat(
                        IDS_ACCESS_IS_DENIED );
                }
                else
                {
                    //
                    // Some other error
                    //

                    VrfErrorResourceFormat(
                        IDS_CANNOT_CHANGE_SETTING_ON_FLY );
                }

                bResult = FALSE;

                goto Done;
            }
        }
    }
    
Done:

    if( g_bCommandLineMode )
    {
        VrfDumpChangedSettings( RunTimeVerifierData.Level,
                                dwNewFlags,
                                nCurrentlyVerifiedDrivers );
    }

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfAddDriversVolatile( const CStringArray &astrNewDrivers )
{
    BOOL bSuccess;
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    CString strCrtDriver;

    bSuccess = TRUE;

    nDrivers = astrNewDrivers.GetSize();

    for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
    {
        strCrtDriver = astrNewDrivers.GetAt( nCrtDriver );

        if( TRUE != VrfAddDriverVolatile( strCrtDriver ) )
        {
            bSuccess = FALSE;
        }
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfAddDriverVolatile( const CString &strCrtDriver )
{
    NTSTATUS Status;
    UINT uIdErrorString;
    BOOL bSuccess;
    UNICODE_STRING usDriverName;
#ifndef UNICODE

    WCHAR *szUnicodeName = NULL;
    INT_PTR nNameLength;

#endif //#ifndef UNICODE


    bSuccess = TRUE;

    //
    // Enable debug privilege
    //

    if( g_bPrivilegeEnabled != TRUE )
    {
        g_bPrivilegeEnabled = VrfEnableDebugPrivilege();

        if( g_bPrivilegeEnabled != TRUE )
        {
            bSuccess = FALSE;

            goto Done;
        }
    }

    //
    // Must have driver name as a UNICODE_STRING
    //

#ifdef UNICODE

    //
    // UNICODE
    //

    RtlInitUnicodeString(
        &usDriverName,
        (LPCTSTR) strCrtDriver );

#else
    //
    // ANSI
    //
    
    nNameLength = strCrtDriver.GetLength();

    szUnicodeName = new WCHAR[ nNameLength + 1 ];

    if( NULL == szUnicodeName )
    {
        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

        bSuccess  = FALSE;

        goto Done;
    }

    MultiByteToWideChar( CP_ACP, 
                         0, 
                         (LPCSTR) strCrtDriver, 
                         -1, 
                         szUnicodeName, 
                         nNameLength + 1 );

    RtlInitUnicodeString(
        &usDriverName,
        szUnicodeName );

#endif //#ifdef UNICODE

    Status = NtSetSystemInformation(
        SystemVerifierAddDriverInformation,
        &usDriverName,
        sizeof( UNICODE_STRING ) );

    if( ! NT_SUCCESS( Status ) )
    {
        switch( Status )
        {
        case STATUS_INVALID_INFO_CLASS:
            uIdErrorString = IDS_VERIFIER_ADD_NOT_SUPPORTED;
            break;

        case STATUS_NOT_SUPPORTED:
            uIdErrorString = IDS_DYN_ADD_NOT_SUPPORTED;
            break;

        case STATUS_IMAGE_ALREADY_LOADED:
            uIdErrorString = IDS_DYN_ADD_ALREADY_LOADED;
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_NO_MEMORY:
            uIdErrorString = IDS_DYN_ADD_INSUF_RESOURCES;
            break;

        case STATUS_PRIVILEGE_NOT_HELD:
            uIdErrorString = IDS_DYN_ADD_ACCESS_DENIED;
            break;

        default:
            VrfErrorResourceFormat(
                IDS_DYN_ADD_MISC_ERROR,
                (LPCTSTR) strCrtDriver,
                Status );

            bSuccess  = FALSE;
        }

        VrfErrorResourceFormat(
            uIdErrorString,
            (LPCTSTR) strCrtDriver );

        bSuccess  = FALSE;
    }

#ifndef UNICODE

    if( NULL != szUnicodeName )
    {
        delete [] szUnicodeName;
    }

#endif //#ifndef UNICODE

Done:

    return bSuccess;
}


/////////////////////////////////////////////////////////////////////////////
BOOL VrfRemoveDriversVolatile( const CStringArray &astrNewDrivers )
{
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    BOOL bSuccess;
    CString strCrtDriver;

    bSuccess = TRUE;

    nDrivers = astrNewDrivers.GetSize();

    for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
    {
        strCrtDriver = astrNewDrivers.GetAt( nCrtDriver );

        if( TRUE != VrfRemoveDriverVolatile( strCrtDriver ) )
        {
            bSuccess = FALSE;
        }
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfRemoveDriverVolatile( const CString &strDriverName )
{
    NTSTATUS Status;
    UINT uIdErrorString;
    BOOL bSuccess;
    UNICODE_STRING usDriverName;
#ifndef UNICODE

    WCHAR *szUnicodeName = NULL;
    INT_PTR nNameLength;

#endif //#ifndef UNICODE

    bSuccess = TRUE;

    //
    // Enable debug privilege
    //

    if( g_bPrivilegeEnabled != TRUE )
    {
        g_bPrivilegeEnabled = VrfEnableDebugPrivilege();

        if( g_bPrivilegeEnabled != TRUE )
        {
            bSuccess = FALSE;

            goto Done;
        }
    }

    //
    // Must have driver name as a UNICODE_STRING
    //

#ifdef UNICODE

    //
    // UNICODE
    //

    RtlInitUnicodeString(
        &usDriverName,
        (LPCTSTR) strDriverName );

#else
    //
    // ANSI
    //
    
    nNameLength = strDriverName.GetLength();

    szUnicodeName = new WCHAR[ nNameLength + 1 ];

    if( NULL == szUnicodeName )
    {
        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

        bSuccess  = FALSE;

        goto Done;
    }

    MultiByteToWideChar( CP_ACP, 
                         0, 
                         (LPCSTR) strDriverName, 
                         -1, 
                         szUnicodeName, 
                         nNameLength + 1 );

    RtlInitUnicodeString(
        &usDriverName,
        szUnicodeName );

#endif //#ifdef UNICODE

    Status = NtSetSystemInformation(
        SystemVerifierRemoveDriverInformation,
        &usDriverName,
        sizeof( UNICODE_STRING ) );

    if( ! NT_SUCCESS( Status ) )
    {
        switch( Status )
        {
        case STATUS_INVALID_INFO_CLASS:
            uIdErrorString = IDS_VERIFIER_REMOVE_NOT_SUPPORTED;
            break;

        case STATUS_NOT_SUPPORTED:
            //
            // the driver verifier is not currently active at all -> success
            //

        case STATUS_NOT_FOUND:
            //
            // the driver is not currently verified -> success
            //

            return TRUE;

        case STATUS_IMAGE_ALREADY_LOADED:
            uIdErrorString = IDS_DYN_REMOVE_ALREADY_LOADED;
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_NO_MEMORY:
            uIdErrorString = IDS_DYN_REMOVE_INSUF_RESOURCES;
            break;

        case STATUS_PRIVILEGE_NOT_HELD:
            uIdErrorString = IDS_DYN_REMOVE_ACCESS_DENIED;
            break;

        default:
            VrfErrorResourceFormat(
                IDS_DYN_REMOVE_MISC_ERROR,
                (LPCTSTR) strDriverName,
                Status );

            bSuccess  = FALSE;
        }

        VrfErrorResourceFormat(
            uIdErrorString,
            (LPCTSTR) strDriverName );

        bSuccess  = FALSE;
    }

Done:

#ifndef UNICODE

    if( NULL != szUnicodeName )
    {
        delete [] szUnicodeName;
    }

#endif //#ifndef UNICODE

    return bSuccess;
}


//////////////////////////////////////////////////////////////////////
BOOL VrfEnableDebugPrivilege( )
{
    struct
    {
        DWORD Count;
        LUID_AND_ATTRIBUTES Privilege [1];

    } Info;

    HANDLE Token;
    BOOL Result;

    //
    // Open the process token
    //

    Result = OpenProcessToken (
        GetCurrentProcess (),
        TOKEN_ADJUST_PRIVILEGES,
        & Token);

    if( Result != TRUE )
    {
        VrfErrorResourceFormat(
            IDS_ACCESS_IS_DENIED );

        return FALSE;
    }

    //
    // Prepare the info structure
    //

    Info.Count = 1;
    Info.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

    Result = LookupPrivilegeValue (
        NULL,
        SE_DEBUG_NAME,
        &(Info.Privilege[0].Luid));

    if( Result != TRUE )
    {
        VrfErrorResourceFormat(
            IDS_ACCESS_IS_DENIED );

        CloseHandle( Token );

        return FALSE;
    }

    //
    // Adjust the privileges
    //

    Result = AdjustTokenPrivileges (
        Token,
        FALSE,
        (PTOKEN_PRIVILEGES) &Info,
        NULL,
        NULL,
        NULL);

    if( Result != TRUE || GetLastError() != ERROR_SUCCESS )
    {
        VrfErrorResourceFormat(
            IDS_ACCESS_IS_DENIED );

        CloseHandle( Token );

        return FALSE;
    }

    CloseHandle( Token );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
VOID VrfDumpChangedSettings( UINT OldFlags,
                             UINT NewFlags,
                             INT_PTR nDriversVerified )
{
    UINT uDifferentFlags;

    if( nDriversVerified == 0 )
    {
        VrfPrintStringFromResources( 
            IDS_NO_DRIVER_VERIFIED );

        goto Done;
    }

    if( OldFlags == NewFlags )
    {
        //
        // no settings were changed
        //

        VrfPrintStringFromResources(
            IDS_NO_SETTINGS_WERE_CHANGED );
    }
    else
    {
        VrfPrintStringFromResources(
            IDS_CHANGED_SETTINGS_ARE );

        uDifferentFlags = OldFlags ^ NewFlags;

        //
        // changed DRIVER_VERIFIER_SPECIAL_POOLING ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_SPECIAL_POOLING )
        {
            if( NewFlags & DRIVER_VERIFIER_SPECIAL_POOLING )
            {
                VrfPrintStringFromResources(
                    IDS_SPECIAL_POOL_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_SPECIAL_POOL_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_FORCE_IRQL_CHECKING ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_FORCE_IRQL_CHECKING )
        {
            if( NewFlags & DRIVER_VERIFIER_FORCE_IRQL_CHECKING )
            {
                VrfPrintStringFromResources(
                    IDS_FORCE_IRQLCHECK_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_FORCE_IRQLCHECK_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES )
        {
            if( NewFlags & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES )
            {
                VrfPrintStringFromResources(
                    IDS_FAULT_INJECTION_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_FAULT_INJECTION_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS )
        {
            if( NewFlags & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS )
            {
                VrfPrintStringFromResources(
                    IDS_POOL_TRACK_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_POOL_TRACK_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_IO_CHECKING ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_IO_CHECKING )
        {
            if( NewFlags & DRIVER_VERIFIER_IO_CHECKING )
            {
                VrfPrintStringFromResources(
                    IDS_IO_CHECKING_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_IO_CHECKING_DISABLED_NOW );
            }
        }

        //
        // the changes are not saved to the registry
        //

        VrfPrintStringFromResources(
            IDS_CHANGES_ACTIVE_ONLY_BEFORE_REBOOT );
    }

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
DWORD VrfGetStandardFlags()
{
    DWORD dwStandardFlags;

    dwStandardFlags = DRIVER_VERIFIER_SPECIAL_POOLING           |
                      DRIVER_VERIFIER_FORCE_IRQL_CHECKING       |
                      DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS    |
                      DRIVER_VERIFIER_IO_CHECKING               |
                      DRIVER_VERIFIER_DEADLOCK_DETECTION        |
                      DRIVER_VERIFIER_DMA_VERIFIER;

    return dwStandardFlags;
}

/////////////////////////////////////////////////////////////////////////////
VOID VrfAddMiniports( CStringArray &astrVerifiedDrivers )
{
    CStringArray astrToAdd;
    CString strCrtDriver;
    CString strCrtDriverToAdd;
    CString strLinkedDriver;
    INT_PTR nVerifiedDrivers;
    INT_PTR nCrtDriver;
    INT_PTR nDriversToAdd;
    INT_PTR nCrtDriverToAdd;

    nVerifiedDrivers = astrVerifiedDrivers.GetSize();

    for( nCrtDriver = 0; nCrtDriver < nVerifiedDrivers; nCrtDriver += 1 )
    {
        //
        // This will be a verified driver
        //

        strCrtDriver = astrVerifiedDrivers.GetAt( nCrtDriver );

        //
        // Check if it is a miniport driver
        //

        if( VrfIsDriverMiniport( strCrtDriver,
                                 strLinkedDriver ) )
        {
            //
            // Check if we didn't add already strLinkedDriver
            //

            nDriversToAdd = astrToAdd.GetSize();

            for( nCrtDriverToAdd = 0; nCrtDriverToAdd < nDriversToAdd; nCrtDriverToAdd += 1 )
            {
                strCrtDriverToAdd = astrToAdd.GetAt( nCrtDriverToAdd );

                if( strCrtDriverToAdd.CompareNoCase( strLinkedDriver ) == 0 )
                {
                    //
                    // We already wanted to add this driver
                    //

                    break;
                }
            }

            if( nCrtDriverToAdd >= nDriversToAdd )
            {
                //
                // Add this new driver (strLinkedDriver)
                //

                astrToAdd.Add( strLinkedDriver );
            }
        }
    }

    //
    // Flush astrToAdd into  astrVerifiedDrivers
    //

    nDriversToAdd = astrToAdd.GetSize();

    for( nCrtDriverToAdd = 0; nCrtDriverToAdd < nDriversToAdd; nCrtDriverToAdd += 1 )
    {
        strCrtDriverToAdd = astrToAdd.GetAt( nCrtDriverToAdd );

        astrVerifiedDrivers.Add( strCrtDriverToAdd );
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsDriverMiniport( CString &strCrtDriver,
                          CString &strLinkedDriver )
{
    //
    // N.B. 
    //
    // The imagehlp functions are not multithreading safe 
    // (see Whistler bug #88373) so if we want to use them from more than
    // one thread we will have to aquire some critical section before.
    //
    // Currently only one thread is using the imagehlp APIs in this app
    // (CSlowProgressDlg::LoadDriverDataWorkerThread) so we don't need
    // our synchronization.
    //

    LPTSTR szDriverName;
    LPTSTR szDriversDir;
    PLOADED_IMAGE pLoadedImage;
    BOOL bIsMiniport;
    BOOL bUnloaded;

    bIsMiniport = FALSE;

    ASSERT( strCrtDriver.GetLength() > 0 );

    //
    // ImageLoad doesn't know about const pointers so
    // we have to GetBuffer here :-(
    //

    szDriverName = strCrtDriver.GetBuffer( strCrtDriver.GetLength() + 1 );

    if( NULL == szDriverName )
    {
        goto Done;
    }

    szDriversDir = g_strDriversDir.GetBuffer( g_strDriversDir.GetLength() + 1 );

    if( NULL == szDriversDir )
    {
        strCrtDriver.ReleaseBuffer();

        goto Done;
    }

    //
    // Load the image
    //

    pLoadedImage = VrfImageLoad( szDriverName,
                                 szDriversDir );

    if( NULL == pLoadedImage )
    {
        //
        // Could not load the image from %windir%\system32\drivers
        // Try again from the PATH
        //

        pLoadedImage = VrfImageLoad( szDriverName,
                                     NULL );
    }

    //
    // Give our string buffers back to MFC
    //

    strCrtDriver.ReleaseBuffer();
    g_strDriversDir.ReleaseBuffer();

    if( NULL == pLoadedImage )
    {
        //
        // We couldn't load this image - bad luck
        //

        TRACE( _T( "ImageLoad failed for %s, error %u\n" ),
            (LPCTSTR) strCrtDriver,
            GetLastError() );

        goto Done;
    }

    //
    // Check if the current driver is a miniport
    //

    bIsMiniport = VrfIsDriverMiniport( pLoadedImage,
                                       strLinkedDriver );

    //
    // Clean-up
    //

    bUnloaded = ImageUnload( pLoadedImage );

    //
    // If ImageUnload fails we cannot do much about it...
    //

    ASSERT( bUnloaded );

Done:

    return bIsMiniport;
}

/////////////////////////////////////////////////////////////////////////////
LPSTR g_szSpecialDrivers[] = 
{
    "videoprt.sys",
    "scsiport.sys"
};

BOOL VrfpLookForAllImportDescriptors( PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor,
                                      ULONG_PTR uVACorrection,
                                      CString &strLinkedAgainst )
{
    PIMAGE_IMPORT_DESCRIPTOR pCurrentDescriptor;
    PCHAR pCrtName;
    ULONG uCrtSpecialDriver;
    BOOL bIsMiniport;
#ifdef UNICODE
    //
    // UNICODE
    //

    INT nCrtStringLength;
    PWSTR szMiniportName;

#endif //#ifdef UNICODE

    bIsMiniport = FALSE;

    for( uCrtSpecialDriver = 0; ! bIsMiniport && uCrtSpecialDriver < ARRAY_LENGTH( g_szSpecialDrivers ); uCrtSpecialDriver += 1 )
    {
        pCurrentDescriptor = pImportDescriptor;

        while( pCurrentDescriptor->Characteristics != NULL )
        {
            pCrtName = (PCHAR)UlongToPtr( pCurrentDescriptor->Name ) + uVACorrection;

            if( lstrcmpiA( g_szSpecialDrivers[ uCrtSpecialDriver ] , pCrtName ) == 0 )
            {
                //
                // This is a miniport
                //

#ifndef UNICODE

                //
                // ANSI
                //

                strLinkedAgainst = g_szSpecialDrivers[ uCrtSpecialDriver ];

#else
                //
                // UNICODE
                //

                nCrtStringLength = strlen( g_szSpecialDrivers[ uCrtSpecialDriver ] );

                szMiniportName = strLinkedAgainst.GetBuffer( nCrtStringLength + 1 );

                if( NULL != szMiniportName )
                {
                    MultiByteToWideChar( CP_ACP, 
                                         0, 
                                         g_szSpecialDrivers[ uCrtSpecialDriver ],
                                         -1, 
                                         szMiniportName, 
                                         ( nCrtStringLength + 1 ) * sizeof( TCHAR ) );

                    strLinkedAgainst.ReleaseBuffer();
                }
#endif

                bIsMiniport = TRUE;

                break;
            }

            pCurrentDescriptor += 1;
        }
    }

    return bIsMiniport;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsDriverMiniport( PLOADED_IMAGE pLoadedImage,
                          CString &strLinkedDriver )
{
    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor;
    PIMAGE_SECTION_HEADER pSectionHeader;
    ULONG_PTR uVACorrection;
    ULONG uDataSize;
    BOOL bIsMiniport;

    bIsMiniport = FALSE;

    //
    // We are protecting ourselves against corrupted binaries 
    // with this exception handler
    //

    try
    {
        pSectionHeader = NULL;

        pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToDataEx(
            pLoadedImage->MappedAddress,
            FALSE,
            IMAGE_DIRECTORY_ENTRY_IMPORT,
            &uDataSize,
            &pSectionHeader );

        if( NULL == pSectionHeader )
        {
            goto Done;
        }

        uVACorrection = (ULONG_PTR) pLoadedImage->MappedAddress +
                        pSectionHeader->PointerToRawData -
                        pSectionHeader->VirtualAddress;

        bIsMiniport = VrfpLookForAllImportDescriptors( pImportDescriptor, 
                                                       uVACorrection,
                                                       strLinkedDriver );
#ifdef _DEBUG
        if( bIsMiniport )
        {
            TRACE( _T( "%s will be auto-enabled\n" ),
                   (LPCTSTR) strLinkedDriver );
        }
#endif //#ifdef DEBUG
    }
    catch( ... )
    {
        TRACE( _T( "VrfIsDriverMiniport: Caught exception\n" ) );
    }

Done:

    return bIsMiniport;
}

/////////////////////////////////////////////////////////////////////////////
VOID VrfpDumpSettingToConsole( ULONG uIdResourceString,
                               BOOL bEnabled )
{
    CString strTitle;
    CString strEnabled;
    ULONG uIdEnabledString;
    TCHAR szBigBuffer[ 128 ];

    VERIFY( VrfLoadString( uIdResourceString, strTitle ) );

    if( FALSE == bEnabled )
    {
        uIdEnabledString = IDS_DISABLED;
    }
    else
    {
        uIdEnabledString = IDS_ENABLED;
    }

    VERIFY( VrfLoadString( uIdEnabledString, strEnabled ) );

    _sntprintf( szBigBuffer,
                ARRAY_LENGTH( szBigBuffer ),
                _T( "%s: %s" ),
                (LPCTSTR) strTitle,
                (LPCTSTR) strEnabled );

    szBigBuffer[ ARRAY_LENGTH( szBigBuffer ) - 1 ] = 0;

    _putts( szBigBuffer );
}

/////////////////////////////////////////////////////////////////////////////
VOID VrfDumpRegistrySettingsToConsole()
{
    BOOL bLoaded;
    BOOL bAllDriversVerified;
    BOOL bDiskVerifierEnabled;
    DWORD dwVerifyFlags;
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    CDiskData *pOldDiskData;
    CString strCrtDriver;
    CStringArray astrDriversToVerify;
    
    bLoaded = VrtLoadCurrentRegistrySettings( bAllDriversVerified,
                                              astrDriversToVerify,
                                              dwVerifyFlags );

    if( FALSE != bLoaded )
    {
        VrfpDumpSettingToConsole( IDS_SPECIAL_POOL,             ( dwVerifyFlags & DRIVER_VERIFIER_SPECIAL_POOLING ) != 0 );
        VrfpDumpSettingToConsole( IDS_FORCE_IRQL_CHECKING,      ( dwVerifyFlags & DRIVER_VERIFIER_FORCE_IRQL_CHECKING ) != 0 );
        VrfpDumpSettingToConsole( IDS_LOW_RESOURCE_SIMULATION,  ( dwVerifyFlags & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES ) != 0 );
        VrfpDumpSettingToConsole( IDS_POOL_TRACKING,            ( dwVerifyFlags & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS ) != 0 );
        VrfpDumpSettingToConsole( IDS_IO_VERIFICATION,          ( dwVerifyFlags & DRIVER_VERIFIER_IO_CHECKING ) != 0 );
        VrfpDumpSettingToConsole( IDS_DEADLOCK_DETECTION,       ( dwVerifyFlags & DRIVER_VERIFIER_DEADLOCK_DETECTION ) != 0 );
        VrfpDumpSettingToConsole( IDS_ENH_IO_VERIFICATION,      ( dwVerifyFlags & DRIVER_VERIFIER_ENHANCED_IO_CHECKING ) != 0 );
        VrfpDumpSettingToConsole( IDS_DMA_CHECHKING,            ( dwVerifyFlags & DRIVER_VERIFIER_DMA_VERIFIER ) != 0 );

        bDiskVerifierEnabled = g_OldDiskData.VerifyAnyDisk();

        VrfpDumpSettingToConsole( IDS_DISK_INTEGRITY_CHECKING, bDiskVerifierEnabled );

        //
        // List of verified drivers.
        //

        VrfPrintStringFromResources( IDS_VERIFIED_DRIVERS );
        
        if( FALSE != bAllDriversVerified )
        {
            VrfPrintStringFromResources( IDS_ALL );
        }
        else
        {
            nDrivers = astrDriversToVerify.GetSize();

            if( nDrivers > 0 )
            {
                for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
                {
                    strCrtDriver = astrDriversToVerify.GetAt( nCrtDriver );

                    _putts( (LPCTSTR) strCrtDriver );
                }
            }
            else
            {
                VrfPrintStringFromResources( IDS_NONE );
            }
        }

        if( FALSE != bDiskVerifierEnabled )
        {
            //
            // List of verified disks.
            //

            VrfPrintStringFromResources( IDS_VERIFIED_DISKS );

            nDrivers = g_OldDiskData.GetSize();

            for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
            {
                pOldDiskData = g_OldDiskData.GetAt( nCrtDriver );
                ASSERT_VALID( pOldDiskData );

                if( FALSE != pOldDiskData->m_bVerifierEnabled )
                {
                    _putts( (LPCTSTR) pOldDiskData->m_strDiskDevicesForDisplay );
                }
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsNameAlreadyInList( LPCTSTR szDriver,
                             LPCTSTR szAllDrivers )
{
    INT nNameLength;
    INT nLastIndex;
    INT nIndex;
    BOOL bFoundIt;
    CString strDriver( szDriver );
    CString strAllDrivers( szAllDrivers );

    bFoundIt = FALSE;

    strDriver.MakeLower();
    strAllDrivers.MakeLower();

    nNameLength = strDriver.GetLength();

    nLastIndex = 0;
    
    do
    {
        nIndex = strAllDrivers.Find( (LPCTSTR)strDriver, nLastIndex );

        if( nIndex >= 0 )
        {
            //
            // Found the substring. Verify it is separated of spaces, etc.
            //

            if( (nIndex == 0 || _T( ' ' ) == strAllDrivers[ nIndex - 1 ]) &&
                ( (TCHAR)0 == strAllDrivers[ nNameLength + nIndex ] || _T( ' ' ) == strAllDrivers[ nNameLength + nIndex ]) )
            {
                //
                // This is our driver.
                //

                bFoundIt = TRUE;

                break;
            }
            else
            {
                //
                // Continue searching.
                //

                nLastIndex = nIndex + 1;
            }
        }
    }
    while( nIndex >= 0 );

    return bFoundIt;
}

/////////////////////////////////////////////////////////////////////////////
VOID VrfAddDriverNameNoDuplicates( LPCTSTR szDriver,
                                   CString &strAllDrivers )
{
    if( FALSE == VrfIsNameAlreadyInList( szDriver,
                                         strAllDrivers ) )
    {
        if( strAllDrivers.GetLength() > 0 )
        {
            strAllDrivers += _T( ' ' );
        }

        strAllDrivers += szDriver;
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsStringInArray( LPCTSTR szText,
                         const CStringArray &astrAllTexts )
{
    INT_PTR nTexts;
    BOOL bFound;

    bFound = FALSE;

    nTexts = astrAllTexts.GetSize();

    while( nTexts > 0 )
    {
        nTexts -= 1;

        if( 0 == astrAllTexts.GetAt( nTexts ).CompareNoCase( szText ) )
        {
            bFound = TRUE;
            break;
        }
    }

    return bFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\vsheet.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VSheet.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "vsheet.h"
#include "taspage.h"
#include "vglobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CVerifierPropSheet dialog

CVerifierPropSheet::CVerifierPropSheet()
	: CPropertySheet(IDS_APPTITLE)
{
	//{{AFX_DATA_INIT(CVerifierPropSheet)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32

    m_TypAdvStatPage.SetParentSheet( this );
    m_DriverSetPage.SetParentSheet( this );
    m_CustSettPage.SetParentSheet( this );
    m_ConfDriversListPage.SetParentSheet( this );
    m_SelectDriversPage.SetParentSheet( this );
    m_FullListSettingsPage.SetParentSheet( this );
    m_DriverStatusPage.SetParentSheet( this );
    m_CrtRegSettingsPage.SetParentSheet( this );
    m_GlobalCountPage.SetParentSheet( this );
    m_DriverCountersPage.SetParentSheet( this );
    m_DiskListPage.SetParentSheet( this );

    m_TypAdvStatPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_DriverSetPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_CustSettPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_ConfDriversListPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_SelectDriversPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_FullListSettingsPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_DriverStatusPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_CrtRegSettingsPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_GlobalCountPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_DriverCountersPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_DiskListPage.m_psp.dwFlags &= ~PSH_HASHELP;

    m_psh.dwFlags &= ~PSH_HASHELP;
    m_psh.dwFlags |= PSH_WIZARDCONTEXTHELP;

    AddPage( &m_TypAdvStatPage );
    AddPage( &m_DriverSetPage );
    AddPage( &m_CustSettPage );
    AddPage( &m_ConfDriversListPage );
    AddPage( &m_SelectDriversPage );
    AddPage( &m_FullListSettingsPage );
    AddPage( &m_CrtRegSettingsPage );
    AddPage( &m_DriverStatusPage );
    AddPage( &m_GlobalCountPage );
    AddPage( &m_DriverCountersPage );
    AddPage( &m_DiskListPage );
    
    SetWizardMode();

    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CVerifierPropSheet::DoDataExchange(CDataExchange* pDX)
{
	CPropertySheet::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVerifierPropSheet)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CVerifierPropSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CVerifierPropSheet)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
    ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CVerifierPropSheet::SetContextStrings( ULONG uTitleResId )
{
    return m_ConfDriversListPage.SetContextStrings( uTitleResId );
}

/////////////////////////////////////////////////////////////////////////////
VOID CVerifierPropSheet::HideHelpButton()
{
    INT xDelta;
    CRect rect1;
    CRect rect2;
    CWnd *pButton;

    //
    // Help button
    //

    pButton = GetDlgItem( IDHELP );

    if( NULL == pButton )
    {
        //
        // No help button?!?
        //

        goto Done;
    }

    pButton->ShowWindow( SW_HIDE );

    pButton->GetWindowRect( &rect1 );
    ScreenToClient( &rect1 );

    //
    // Cancel button
    //

    pButton = GetDlgItem( IDCANCEL );

    if( NULL == pButton )
    {
        //
        // No Cancel button?!?
        //

        goto Done;
    }

    pButton->GetWindowRect( &rect2 );
    ScreenToClient( &rect2 );

    xDelta = rect1.left - rect2.left;
    
    rect2.OffsetRect( xDelta, 0 );
    pButton->MoveWindow( rect2 );

    //
    // Back button
    //

    pButton = GetDlgItem( ID_WIZBACK );

    if( NULL != pButton )
    {
        pButton->GetWindowRect( &rect2 );
        ScreenToClient( &rect2 );
        rect2.OffsetRect( xDelta, 0 );
        pButton->MoveWindow( rect2 );
    }

    //
    // Next button
    //

    pButton = GetDlgItem( ID_WIZNEXT );

    if( NULL != pButton )
    {
        pButton->GetWindowRect( &rect2 );
        ScreenToClient( &rect2 );
        rect2.OffsetRect( xDelta, 0 );
        pButton->MoveWindow( rect2 );
    }

    //
    // Finish button
    //

    pButton = GetDlgItem( ID_WIZFINISH );

    if( NULL != pButton )
    {
        pButton->GetWindowRect( &rect2 );
        ScreenToClient( &rect2 );
        rect2.OffsetRect( xDelta, 0 );
        pButton->MoveWindow( rect2 );
    }

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
// CVerifierPropSheet message handlers

BOOL CVerifierPropSheet::OnInitDialog()
{
	CPropertySheet::OnInitDialog();

    //
	// Add "About..." menu item to system menu.
    //

    //
	// IDM_ABOUTBOX must be in the system command range.
    //

	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

    //
	// Set the icon for this dialog.  The framework does this automatically
	// when the application's main window is not a dialog.
    //

	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

    //
    // Hide the big Help button - NT keeps creating it even if we
    // have specified ~PSH_HASHELP
    //

    HideHelpButton();

    //
    // Add the context sensitive button to the titlebar
    //

    LONG lStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
    lStyle |= WS_EX_CONTEXTHELP;
    ::SetWindowLong(m_hWnd, GWL_EXSTYLE, lStyle);

    return TRUE;  // return TRUE  unless you set the focus to a control
}

/////////////////////////////////////////////////////////////////////////////
void CVerifierPropSheet::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
        ShellAbout( m_hWnd, 
                    (LPCTSTR)g_strAppName, 
                    NULL, 
                    m_hIcon );
	}
	else
	{
		CPropertySheet::OnSysCommand( nID, 
                                      lParam);
	}
}

/////////////////////////////////////////////////////////////////////////////
//
// If you add a minimize button to your dialog, you will need the code below
// to draw the icon.  For MFC applications using the document/view model,
// this is automatically done for you by the framework.
//

void CVerifierPropSheet::OnPaint() 
{
	if (IsIconic())
	{
        //
        // Device context for painting
        //

		CPaintDC dc(this); 

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        //
		// Center icon in client rectangle
        //

		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

        //
		// Draw the icon
        //

		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CPropertySheet::OnPaint();
	}
}

/////////////////////////////////////////////////////////////////////////////
//
// The system calls this to obtain the cursor to display while the user drags
// the minimized window.
//

HCURSOR CVerifierPropSheet::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVerifierPropSheet::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	return TRUE;
}

/////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\cntpage.cxx ===
//
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: CntPage.cxx
// author: DMihai
// created: 01/04/98
//
// Description:
//
//      Global Counters PropertyPage.

#include "stdafx.h"
#include "drvvctrl.hxx"
#include "CntPage.hxx"

#include "DrvCSht.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// timer ID
#define REFRESH_TIMER_ID    0x4321

// manual, high, normal, low speed
#define REFRESH_SPEED_VARS  4

// timer intervals in millisec for manual, high, normal, low speed
static UINT uTimerIntervals[ REFRESH_SPEED_VARS ] =
{
    0,      // Manual
    1000,   // High Speed
    5000,   // Normal Speed
    10000   // Low Speed
};

//
// help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_COUNT_RAISEIRQL_EDIT,       IDH_DV_CountersTab_other_irql,
    IDC_COUNT_ACQSPINL_EDIT,        IDH_DV_CountersTab_other_spinlocks,
    IDC_COUNT_SYNCREX_EDIT,         IDH_DV_CountersTab_other_sync,
    IDC_COUNT_TRIMS_EDIT,           IDH_DV_CountersTab_other_trims,
    IDC_COUNT_ALLOC_ATTEMPT_EDIT,   IDH_DV_CountersTab_allocations_attempt,
    IDC_COUNT_ALLOC_SUCC_EDIT,      IDH_DV_CountersTab_allocations_succeed,
    IDC_COUNT_ALLOCSUCC_SPECPOOL_EDIT, IDH_DV_CountersTab_allocations_succeed_pool,
    IDC_COUNT_ALLOC_NOTAG_EDIT,     IDH_DV_CountersTab_allocations_wotag,
    IDC_COUNT_ALLOC_FAILED_EDIT,    IDH_DV_CountersTab_allocations_failed,
    IDC_COUNT_ALLOC_FAILEDDEL_EDIT, IDH_DV_CountersTab_other_faults,

    IDC_COUNT_REFRESH_BUTTON,     IDH_DV_common_refresh_nowbutton,
    IDC_COUNT_MANUAL_RADIO,       IDH_DV_common_refresh_manual,
    IDC_COUNT_HSPEED_RADIO,       IDH_DV_common_refresh_high,
    IDC_COUNT_NORM_RADIO,         IDH_DV_common_refresh_normal,
    IDC_COUNT_LOW_RADIO,          IDH_DV_common_refresh_low,
    0,                              0
};

/////////////////////////////////////////////////////////////////////
static void GetStringFromULONG( CString &strValue, ULONG uValue )
{
    LPTSTR lptstrValue = strValue.GetBuffer( 64 );
    if( lptstrValue != NULL )
    {
        _stprintf( lptstrValue, _T( "%lu" ), uValue );
        strValue.ReleaseBuffer();
    }
    else
    {
        ASSERT( FALSE );
        strValue.Empty();
    }
}


/////////////////////////////////////////////////////////////////////
// CCountersPage property page

IMPLEMENT_DYNCREATE(CCountersPage, CPropertyPage)

CCountersPage::CCountersPage()
	: CPropertyPage(CCountersPage::IDD)
{
    //{{AFX_DATA_INIT(CCountersPage)
    m_strAcqSpinlEdit = _T("");
    m_strAllocAttemptEdit = _T("");
    m_strAllocFailed = _T("");
    m_strAllocFailedDelEdit = _T("");
    m_strAllocNoTagEdit = _T("");
    m_strAllocSucc = _T("");
    m_strAllocSuccSpecPool = _T("");
    m_strRaiseIrqLevelEdit = _T("");
    m_strSyncrExEdit = _T("");
    m_strTrimsEdit = _T("");
    m_nUpdateIntervalIndex = 2;
    //}}AFX_DATA_INIT

    m_uTimerHandler = 0;
}


void CCountersPage::DoDataExchange(CDataExchange* pDX)
{
    if( ! pDX->m_bSaveAndValidate )
    {
        // query the kernel
        if( KrnGetSystemVerifierState( &m_KrnVerifState ) &&
            m_KrnVerifState.DriverCount > 0 )
        {
            // RaiseIrqls
            GetStringFromULONG( m_strRaiseIrqLevelEdit,
                m_KrnVerifState.RaiseIrqls );

            // AcquireSpinLocks
            GetStringFromULONG( m_strAcqSpinlEdit,
                m_KrnVerifState.AcquireSpinLocks );

            // SynchronizeExecutions
            GetStringFromULONG( m_strSyncrExEdit,
                m_KrnVerifState.SynchronizeExecutions );

            // AllocationsAttempted
            GetStringFromULONG( m_strAllocAttemptEdit,
                m_KrnVerifState.AllocationsAttempted );

            // AllocationsSucceeded
            GetStringFromULONG( m_strAllocSucc,
                m_KrnVerifState.AllocationsSucceeded );

            // AllocationsSucceededSpecialPool
            GetStringFromULONG( m_strAllocSuccSpecPool,
                m_KrnVerifState.AllocationsSucceededSpecialPool );

            // AllocationsWithNoTag
            GetStringFromULONG( m_strAllocNoTagEdit,
                m_KrnVerifState.AllocationsWithNoTag );

            // Trims
            GetStringFromULONG( m_strTrimsEdit,
                m_KrnVerifState.Trims );

            // AllocationsFailed
            GetStringFromULONG( m_strAllocFailed,
                m_KrnVerifState.AllocationsFailed );

            // AllocationsFailedDeliberately
            GetStringFromULONG( m_strAllocFailedDelEdit,
                m_KrnVerifState.AllocationsFailedDeliberately );
        }
        else
        {
            // RaiseIrqls
            VERIFY( m_strRaiseIrqLevelEdit.LoadString( IDS_ZERO ) );

            // AcquireSpinLocks
            VERIFY( m_strAcqSpinlEdit.LoadString( IDS_ZERO ) );

            // SynchronizeExecutions
            VERIFY( m_strSyncrExEdit.LoadString( IDS_ZERO ) );

            // AllocationsAttempted
            VERIFY( m_strAllocAttemptEdit.LoadString( IDS_ZERO ) );

            // AllocationsSucceeded
            VERIFY( m_strAllocSucc.LoadString( IDS_ZERO ) );

            // AllocationsSucceededSpecialPool
            VERIFY( m_strAllocSuccSpecPool.LoadString( IDS_ZERO ) );

            // AllocationsWithNoTag
            VERIFY( m_strAllocNoTagEdit.LoadString( IDS_ZERO ) );

            // Trims
            VERIFY( m_strTrimsEdit.LoadString( IDS_ZERO ) );

            // AllocationsFailed
            VERIFY( m_strAllocFailed.LoadString( IDS_ZERO ) );

            // AllocationsFailedDeliberately
            VERIFY( m_strAllocFailedDelEdit.LoadString( IDS_ZERO ) );

        }
    }

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCountersPage)
    DDX_Text(pDX, IDC_COUNT_ACQSPINL_EDIT, m_strAcqSpinlEdit);
    DDX_Text(pDX, IDC_COUNT_ALLOC_ATTEMPT_EDIT, m_strAllocAttemptEdit);
    DDX_Text(pDX, IDC_COUNT_ALLOC_FAILED_EDIT, m_strAllocFailed);
    DDX_Text(pDX, IDC_COUNT_ALLOC_FAILEDDEL_EDIT, m_strAllocFailedDelEdit);
    DDX_Text(pDX, IDC_COUNT_ALLOC_NOTAG_EDIT, m_strAllocNoTagEdit);
    DDX_Text(pDX, IDC_COUNT_ALLOC_SUCC_EDIT, m_strAllocSucc);
    DDX_Text(pDX, IDC_COUNT_ALLOCSUCC_SPECPOOL_EDIT, m_strAllocSuccSpecPool);
    DDX_Text(pDX, IDC_COUNT_RAISEIRQL_EDIT, m_strRaiseIrqLevelEdit);
    DDX_Text(pDX, IDC_COUNT_SYNCREX_EDIT, m_strSyncrExEdit);
    DDX_Text(pDX, IDC_COUNT_TRIMS_EDIT, m_strTrimsEdit);
    DDX_Radio(pDX, IDC_COUNT_MANUAL_RADIO, m_nUpdateIntervalIndex);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCountersPage, CPropertyPage)
    //{{AFX_MSG_MAP(CCountersPage)
    ON_BN_CLICKED(IDC_COUNT_REFRESH_BUTTON, OnCountRefreshButton)
    ON_WM_TIMER()
    ON_BN_CLICKED(IDC_COUNT_HSPEED_RADIO, OnCountHspeedRadio)
    ON_BN_CLICKED(IDC_COUNT_LOW_RADIO, OnCountLowRadio)
    ON_BN_CLICKED(IDC_COUNT_MANUAL_RADIO, OnCountManualRadio)
    ON_BN_CLICKED(IDC_COUNT_NORM_RADIO, OnCountNormRadio)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_MESSAGE( WM_CONTEXTMENU, OnContextMenu )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////
void CCountersPage::OnRefreshTimerChanged()
{
    UINT uTimerElapse = 0;

    // kill the pending timer
    if( m_uTimerHandler != 0 )
    {
        VERIFY( KillTimer( REFRESH_TIMER_ID ) );
    }

    // sanity check
    if( m_nUpdateIntervalIndex < 0 ||
        m_nUpdateIntervalIndex >= REFRESH_SPEED_VARS )
    {
        m_nUpdateIntervalIndex = 0;
        CheckRadioButton( IDC_COUNT_MANUAL_RADIO, IDC_COUNT_LOW_RADIO,
            IDC_COUNT_MANUAL_RADIO );
    }

    // new timer interval
    uTimerElapse = uTimerIntervals[ m_nUpdateIntervalIndex ];
    if( uTimerElapse > 0 )
    {
        VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID,
            uTimerElapse, NULL ) );
    }
}

/////////////////////////////////////////////////////////////////////
// CCountersPage message handlers
BOOL CCountersPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    OnRefreshTimerChanged();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////
void CCountersPage::OnCountRefreshButton()
{
    UpdateData( FALSE );
}

/////////////////////////////////////////////////////////////////////
void CCountersPage::OnTimer(UINT nIDEvent)
{
    if( nIDEvent == REFRESH_TIMER_ID )
    {
        CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
        if( pParentSheet != NULL )
        {
            ASSERT_VALID( pParentSheet );
            if( pParentSheet->GetActivePage() == this )
            {
                // refresh the displayed data
                OnCountRefreshButton();
            }
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////
BOOL CCountersPage::OnQueryCancel()
{
    // give parent PropertySheet a chance to refuse the Cancel if needed

    CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
    if( pParentSheet != NULL )
    {
        ASSERT_VALID( pParentSheet );
        if( ! pParentSheet->OnQueryCancel() )
        {
            return FALSE;
        }
    }

    return CPropertyPage::OnQueryCancel();
}

/////////////////////////////////////////////////////////////////////
BOOL CCountersPage::OnApply()
{
    // refuse to apply
    // (we don't use the standard PropertSheet buttons; Apply, OK)
    return FALSE;
}

/////////////////////////////////////////////////////////////////////
void CCountersPage::OnCountManualRadio()
{
    // switch to manual refresh
    m_nUpdateIntervalIndex = 0;
    OnRefreshTimerChanged();
}

void CCountersPage::OnCountHspeedRadio()
{
    // switch to high speed refresh
    m_nUpdateIntervalIndex = 1;
    OnRefreshTimerChanged();
}

void CCountersPage::OnCountNormRadio()
{
    // switch to normal speed refresh
    m_nUpdateIntervalIndex = 2;
    OnRefreshTimerChanged();
}

void CCountersPage::OnCountLowRadio()
{
    // switch to low speed refresh
    m_nUpdateIntervalIndex = 3;
    OnRefreshTimerChanged();
}

/////////////////////////////////////////////////////////////
LONG CCountersPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        VERIFIER_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////
LONG CCountersPage::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;

    ::WinHelp( 
        (HWND) wParam,
        VERIFIER_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\crtspage.cxx ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: CrtSPage.cxx
// author: DMihai
// created: 01/04/99
//
// Description:
//
//      Current settings PropertyPage. 

#include "stdafx.h"
#include "drvvctrl.hxx"
#include "CrtSPage.hxx"

#include "DrvCSht.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MIN_MEM_SIZE_TO_DISABLE_WARNING 0x80000000  // 2 Gb
#define MIN_ALLOCATIONS_SIGNIFICANT     100
#define MIN_PERCENTAGE_AVOID_WARNING    95

//
// timer ID
//

#define REFRESH_TIMER_ID    0x1234

//
// manual, high, normal, low speed
//

#define REFRESH_SPEED_VARS  4

//
// timer intervals in millisec for manual, high, normal, low speed
//

static UINT uTimerIntervals[ REFRESH_SPEED_VARS ] =
{
    0,      // Manual
    1000,   // High Speed
    5000,   // Normal Speed
    10000   // Low Speed
};

//
// help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_CRTSTAT_DRIVERS_LIST,       IDH_DV_VolatileTab_driver_details,
    IDC_CRTSTAT_IRQLCHCK_EDIT,      IDH_DV_StatusTab_flag_irql,
    IDC_CRTSTAT_FAULTINJ_EDIT,      IDH_DV_StatusTab_flag_resource,
    IDC_CRTSTAT_POOLT_EDIT,         IDH_DV_StatusTab_flag_tracking,
    IDC_CRTSTAT_IOVERIF_EDIT,       IDH_DV_StatusTab_flag_io,
    IDC_CRTSTAT_SPECPOOL_EDIT,      IDH_DV_StatusTab_flag_pool,
    IDC_CRTSTAT_REFRESH_BUTTON,     IDH_DV_common_refresh_nowbutton,
    IDC_CRTSTAT_MANUAL_RADIO,       IDH_DV_common_refresh_manual,
    IDC_CRTSTAT_HSPEED_RADIO,       IDH_DV_common_refresh_high,
    IDC_CRTSTAT_NORM_RADIO,         IDH_DV_common_refresh_normal,
    IDC_CRTSTAT_LOW_RADIO,          IDH_DV_common_refresh_low,
    0,                              0
};

/////////////////////////////////////////////////////////////
static void GetEnabledStringFromBool( BOOL bEnabled, CString &strValue )
{
    if( bEnabled )
        VERIFY( strValue.LoadString( IDS_ENABLED ) );
    else
        VERIFY( strValue.LoadString( IDS_DISABLED ) );
}

/////////////////////////////////////////////////////////////
// CCrtSettPage property page

IMPLEMENT_DYNCREATE(CCrtSettPage, CPropertyPage)

CCrtSettPage::CCrtSettPage() : CPropertyPage(CCrtSettPage::IDD)
{
    //{{AFX_DATA_INIT(CCrtSettPage)
    m_strSpecPool = _T("");
    m_strIrqLevelCheckEdit = _T("");
    m_strFaultInjEdit = _T("");
    m_strPoolTrackEdit = _T("");
    m_strIoVerifEdit = _T("");
    m_strWarnMsg = _T("");
    m_nUpdateIntervalIndex = 2;
    //}}AFX_DATA_INIT

    m_bAscendDrvNameSort = FALSE;
    m_bAscendDrvStatusSort = FALSE;

    m_uTimerHandler = 0;

    m_nSortColumnIndex = 0;
}

CCrtSettPage::~CCrtSettPage()
{
}

void CCrtSettPage::DoDataExchange(CDataExchange* pDX)
{
    if( ! pDX->m_bSaveAndValidate )
    {
        // query the kernel
        if( KrnGetSystemVerifierState( &m_KrnVerifState ) && 
            m_KrnVerifState.DriverCount > 0 )
        {
            // SpecialPool
            GetEnabledStringFromBool( m_KrnVerifState.SpecialPool, m_strSpecPool );

            // IrqlChecking
            GetEnabledStringFromBool( m_KrnVerifState.IrqlChecking, m_strIrqLevelCheckEdit );

            // FaultInjection
            GetEnabledStringFromBool( m_KrnVerifState.FaultInjection, m_strFaultInjEdit );

            // PoolTrack
            GetEnabledStringFromBool( m_KrnVerifState.PoolTrack, m_strPoolTrackEdit );

            // IoVerif
            GetEnabledStringFromBool( m_KrnVerifState.IoVerif, m_strIoVerifEdit );

            // warning message
            GetPoolCoverageWarnMessage();
        }
        else
        {
            // SpecialPool
            VERIFY( m_strSpecPool.LoadString( IDS_DISABLED ) );

            // IrqlChecking
            VERIFY( m_strIrqLevelCheckEdit.LoadString( IDS_DISABLED ) );

            // FaultInjection
            VERIFY( m_strFaultInjEdit.LoadString( IDS_DISABLED ) );

            // PoolTrack
            VERIFY( m_strPoolTrackEdit.LoadString( IDS_DISABLED ) );

            //IoVerif
            VERIFY( m_strIoVerifEdit.LoadString( IDS_DISABLED ) );

            // warning message
            m_strWarnMsg.Empty();
        }
    }

    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CCrtSettPage)
    DDX_Control(pDX, IDC_CRTSTAT_DRIVERS_LIST, m_DriversList);
    DDX_Text(pDX, IDC_CRTSTAT_SPECPOOL_EDIT, m_strSpecPool);
    DDX_Text(pDX, IDC_CRTSTAT_IRQLCHCK_EDIT, m_strIrqLevelCheckEdit);
    DDX_Text(pDX, IDC_CRTSTAT_FAULTINJ_EDIT, m_strFaultInjEdit);
    DDX_Text(pDX,IDC_CRTSTAT_POOLT_EDIT, m_strPoolTrackEdit);
    DDX_Text(pDX,IDC_CRTSTAT_IOVERIF_EDIT, m_strIoVerifEdit);
    DDX_Text(pDX,IDC_CRTSTAT_WARN_MSG, m_strWarnMsg);
    DDX_Radio(pDX, IDC_CRTSTAT_MANUAL_RADIO, m_nUpdateIntervalIndex);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCrtSettPage, CPropertyPage)
    //{{AFX_MSG_MAP(CCrtSettPage)
    ON_BN_CLICKED(IDC_CRTSTAT_REFRESH_BUTTON, OnCrtstatRefreshButton)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_CRTSTAT_DRIVERS_LIST, OnColumnclickCrtstatDriversList)
    ON_WM_TIMER()
    ON_BN_CLICKED(IDC_CRTSTAT_HSPEED_RADIO, OnCrtstatHspeedRadio)
    ON_BN_CLICKED(IDC_CRTSTAT_LOW_RADIO, OnCrtstatLowRadio)
    ON_BN_CLICKED(IDC_CRTSTAT_MANUAL_RADIO, OnCrtstatManualRadio)
    ON_BN_CLICKED(IDC_CRTSTAT_NORM_RADIO, OnCrtstatNormRadio)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_MESSAGE( WM_CONTEXTMENU, OnContextMenu )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////
void CCrtSettPage::SetupListHeader()
{
    CString strDrivers, strStatus;
    VERIFY( strDrivers.LoadString( IDS_DRIVERS ) );
    VERIFY( strStatus.LoadString( IDS_STATUS ) );

    // list's regtangle
    CRect rectWnd;
    m_DriversList.GetClientRect( &rectWnd );
    
    LVCOLUMN lvColumn;

    // column 0
    memset( &lvColumn, 0, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.pszText = strDrivers.GetBuffer( strDrivers.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    strDrivers.ReleaseBuffer();

    // column 1
    lvColumn.iSubItem = 1;
    lvColumn.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    strStatus.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::FillTheList()
{
    LVITEM lvItem;
    int nActualIndex; 
    BOOL *pbAlreadyInList;
    ULONG uCrtVerifiedDriver;
    int nItemCount;
    int nCrtListItem;
    TCHAR strDriverName[ _MAX_PATH ];
    BOOL bResult;

    if( m_KrnVerifState.DriverCount == 0 )
    {
        //
        // clear the list
        //

        VERIFY( m_DriversList.DeleteAllItems() );
    }
    else
    {
        //
        // there are some drivers currently verified
        //

        pbAlreadyInList = new BOOL[ m_KrnVerifState.DriverCount ];
        if( pbAlreadyInList == NULL )
        {
            return;
        }
        
        for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++)
        {
            pbAlreadyInList[ uCrtVerifiedDriver ] = FALSE;
        }

        //
        // parse all the current list items
        //

        nItemCount = m_DriversList.GetItemCount();

        for( nCrtListItem = 0; nCrtListItem < nItemCount; nCrtListItem++ )
        {
            //
            // get the current driver's name from the list
            //

            ZeroMemory( &lvItem, sizeof( lvItem ) );

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = nCrtListItem;
            lvItem.iSubItem = 0;
            lvItem.pszText = strDriverName;
            lvItem.cchTextMax = sizeof( strDriverName ) / sizeof( strDriverName[0] );

            bResult = m_DriversList.GetItem( &lvItem );
            if( bResult == FALSE )
            {
                //
                // could not get the current item's attributes?
                //

                ASSERT( FALSE );

                //
                // remove this item from the list
                //

                VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                nCrtListItem--;
                nItemCount--;
            }
            else
            {
                //
                // see is the current driver is still in m_KrnVerifState
                //

                for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++)
                {
                    if( _tcsicmp( strDriverName, 
                        m_KrnVerifState.DriverInfo[ uCrtVerifiedDriver ].Name ) == 0 )
                    {
                        //
                        // update the item's data with the current index in the array
                        //

                        lvItem.mask = LVIF_PARAM;
                        lvItem.lParam = uCrtVerifiedDriver;
                        
                        VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );

                        //
                        // update the second column
                        //

                        UpdateStatusColumn( nCrtListItem, uCrtVerifiedDriver ); 

                        //
                        // mark the current driver as updated
                        //

                        pbAlreadyInList[ uCrtVerifiedDriver ] = TRUE;

                        break;
                    }
                }

                //
                // If the driver is no longer verified, remove it from the list
                //

                if( uCrtVerifiedDriver >= m_KrnVerifState.DriverCount )
                {
                    VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                    nCrtListItem--;
                    nItemCount--;
                }
            }
        }

        //
        // add the drivers that were not in the list before this update
        //

        for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++)
        {
            if( ! pbAlreadyInList[ uCrtVerifiedDriver ] )
            {
                // 
                // add a new item for this
                //

                ZeroMemory( &lvItem, sizeof( lvItem ) );

                //
                // sub-item 0
                //

                lvItem.mask = LVIF_TEXT | LVIF_PARAM;
                lvItem.lParam = uCrtVerifiedDriver;
                lvItem.iItem = m_DriversList.GetItemCount();
                lvItem.iSubItem = 0;
                lvItem.pszText = m_KrnVerifState.DriverInfo[ uCrtVerifiedDriver ].Name;
                nActualIndex = m_DriversList.InsertItem( &lvItem );
                VERIFY( nActualIndex != -1 );

                //
                // sub-item 1
                //

                UpdateStatusColumn( nActualIndex, uCrtVerifiedDriver ); 
            }
        }

        delete pbAlreadyInList;
    }
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::UpdateStatusColumn( int nItemIndex, ULONG uCrtDriver )
{
    LVITEM lvItem;
    CString strStatus;

    ASSERT( nItemIndex >= 0 && 
            (UINT)nItemIndex < m_KrnVerifState.DriverCount &&
            nItemIndex < m_DriversList.GetItemCount() &&
            uCrtDriver >= 0 &&
            uCrtDriver < m_KrnVerifState.DriverCount &&
            uCrtDriver < (ULONG)m_DriversList.GetItemCount() );

    // determine what's the appropriate value for the second column
    if( ! m_KrnVerifState.DriverInfo[ uCrtDriver ].Loads )
    {
        VERIFY( strStatus.LoadString( IDS_NEVER_LOADED ) );
    }
    else
    {
        if( m_KrnVerifState.DriverInfo[ uCrtDriver ].Loads == 
            m_KrnVerifState.DriverInfo[ uCrtDriver ].Unloads )
        {
            VERIFY( strStatus.LoadString( IDS_UNLOADED ) );
        }
        else
        {
            if( m_KrnVerifState.DriverInfo[ uCrtDriver ].Loads > 
                m_KrnVerifState.DriverInfo[ uCrtDriver ].Unloads )
            {
                VERIFY( strStatus.LoadString( IDS_LOADED ) );
            }
            else
            {
                ASSERT( FALSE );
                VERIFY( strStatus.LoadString( IDS_UNKNOWN ) );
            }
        }
    }

    // update the list item
    memset( &lvItem, 0, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );
    VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );
    strStatus.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
int CALLBACK CCrtSettPage::DrvStatusCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CCrtSettPage *pThis = (CCrtSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    // sanity check
    if( uIndex1 > pThis->m_KrnVerifState.DriverCount || 
        uIndex2 > pThis->m_KrnVerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    // difference between loads and unloads #
    LONG lLoadDiff1 = (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex1 ].Loads -
                      (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex1 ].Unloads;
    LONG lLoadDiff2 = (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex2 ].Loads - 
                      (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex2 ].Unloads;

    if( lLoadDiff1 == lLoadDiff2 )
    {
        nCmpRez = 0;
    }
    else
    {
        if( lLoadDiff1 > lLoadDiff2 )
            nCmpRez = 1;
        else
            nCmpRez = -1;
    }

    if( pThis->m_bAscendDrvStatusSort )
        nCmpRez *= -1;

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
int CALLBACK CCrtSettPage::DrvNameCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CCrtSettPage *pThis = (CCrtSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    // sanity check
    if( uIndex1 > pThis->m_KrnVerifState.DriverCount || 
        uIndex2 > pThis->m_KrnVerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    nCmpRez = _tcsicmp( pThis->m_KrnVerifState.DriverInfo[ uIndex1 ].Name, 
                        pThis->m_KrnVerifState.DriverInfo[ uIndex2 ].Name );
    if( ! nCmpRez )
    {
        // same name ???
        nCmpRez = 0;
    }
    else
    {
        if( pThis->m_bAscendDrvNameSort )
            nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::OnRefreshTimerChanged()
{
    UINT uTimerElapse = 0;

    // kill the pending timer
    if( m_uTimerHandler != 0 )
    {
        VERIFY( KillTimer( REFRESH_TIMER_ID ) );
    }

    // sanity check
    if( m_nUpdateIntervalIndex < 0 || 
        m_nUpdateIntervalIndex >= REFRESH_SPEED_VARS )
    {
        m_nUpdateIntervalIndex = 0;
        CheckRadioButton( IDC_CRTSTAT_MANUAL_RADIO, IDC_CRTSTAT_LOW_RADIO, 
            IDC_CRTSTAT_MANUAL_RADIO );
    }

    // new timer interval
    uTimerElapse = uTimerIntervals[ m_nUpdateIntervalIndex ];
    if( uTimerElapse > 0 )
    {
        VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID, 
            uTimerElapse, NULL ) );
    }
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::SortTheList()
{
    if( m_nSortColumnIndex )
    {
        m_DriversList.SortItems( DrvStatusCmpFunc, (LPARAM)this );
    }
    else
    {
        m_DriversList.SortItems( DrvNameCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::GetPoolCoverageWarnMessage()
{
    ULONGLONG ullPercentageCoverage;
    CString strMsgFormat;

    if( m_KrnVerifState.SpecialPool &&
        m_KrnVerifState.AllocationsSucceeded > MIN_ALLOCATIONS_SIGNIFICANT  )
    {
        // 
        // special pool verification is enabled
        // there is a significant number of allocations
        //

        ASSERT( m_KrnVerifState.AllocationsSucceeded >= m_KrnVerifState.AllocationsSucceededSpecialPool );

        //
        // the coverage percentage
        //

        ullPercentageCoverage = 
            ( (ULONGLONG)m_KrnVerifState.AllocationsSucceededSpecialPool * (ULONGLONG) 100 ) / 
            (ULONGLONG)m_KrnVerifState.AllocationsSucceeded;

        ASSERT( ullPercentageCoverage <= 100 );

        if( ullPercentageCoverage < MIN_PERCENTAGE_AVOID_WARNING )
        {
            //
            // warn the user
            //

            if( strMsgFormat.LoadString( IDS_COVERAGE_WARNING_FORMAT ) )
            {
                TCHAR *strMessage = m_strWarnMsg.GetBuffer( strMsgFormat.GetLength() + 32 );

                if( strMessage != NULL )
                {
                    _stprintf( strMessage, (LPCTSTR)strMsgFormat, ullPercentageCoverage );
                    m_strWarnMsg.ReleaseBuffer();
                    return;
                }
            }
            else
            {
                ASSERT( FALSE );
            }
        }
    }

    //
    // no warning message
    //

    m_strWarnMsg.Empty();
}

/////////////////////////////////////////////////////////////
// CCrtSettPage message handlers

BOOL CCrtSettPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    SetupListHeader();
    FillTheList();
    SortTheList();

    OnRefreshTimerChanged();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::OnCrtstatRefreshButton() 
{
    if( UpdateData( FALSE ) )
    {
        FillTheList();
        SortTheList();
    }
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::OnColumnclickCrtstatDriversList(NMHDR* pNMHDR, 
                                                   LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if( pNMListView->iSubItem )
    {
        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            // change the current ascend/descend order for this column
            m_bAscendDrvStatusSort = !m_bAscendDrvStatusSort;
        }
    }
    else
    {
        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            // change the current ascend/descend order for this column
            m_bAscendDrvNameSort = !m_bAscendDrvNameSort;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::OnTimer(UINT nIDEvent) 
{
    if( nIDEvent == REFRESH_TIMER_ID )
    {
        CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
        if( pParentSheet != NULL )
        {
            ASSERT_VALID( pParentSheet );
            if( pParentSheet->GetActivePage() == this )
            {
                // refresh the displayed data 
                OnCrtstatRefreshButton();
            }
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////
BOOL CCrtSettPage::OnQueryCancel() 
{
    // give parent PropertySheet a chance to refuse the Cancel if needed

    CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
    if( pParentSheet != NULL )
    {
        ASSERT_VALID( pParentSheet );
        if( ! pParentSheet->OnQueryCancel() )
        {
            return FALSE;
        }
    }

    return CPropertyPage::OnQueryCancel();
}

/////////////////////////////////////////////////////////////
BOOL CCrtSettPage::OnApply() 
{
    // refuse to apply 
    // (we don't use the standard PropertSheet buttons; Apply, OK)
    return FALSE;
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::OnCrtstatManualRadio() 
{
    // switch to manual refresh
    m_nUpdateIntervalIndex = 0;
    OnRefreshTimerChanged();
}

void CCrtSettPage::OnCrtstatHspeedRadio() 
{
    // switch to high speed refresh
    m_nUpdateIntervalIndex = 1;
    OnRefreshTimerChanged();
}

void CCrtSettPage::OnCrtstatNormRadio() 
{
    // switch to normal speed refresh
    m_nUpdateIntervalIndex = 2;
    OnRefreshTimerChanged();
}

void CCrtSettPage::OnCrtstatLowRadio() 
{
    // switch to low speed refresh
    m_nUpdateIntervalIndex = 3;
    OnRefreshTimerChanged();
}

/////////////////////////////////////////////////////////////
LONG CCrtSettPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        VERIFIER_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////
LONG CCrtSettPage::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;

    ::WinHelp( 
        (HWND) wParam,
        VERIFIER_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\vsetting.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VSetting.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VSETTING_H__478A94E4_3D60_4419_950C_2144CB86691D__INCLUDED_)
#define AFX_VSETTING_H__478A94E4_3D60_4419_950C_2144CB86691D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ProgCtrl.h"

///////////////////////////////////////////////////////////////
//
// CDriverData class
//
// Has information about one driver
//

class CDriverData : public CObject
{
public:
    CDriverData();
    CDriverData( const CDriverData &DriverData );
    CDriverData( LPCTSTR szDriverName );
    virtual ~CDriverData();

public:
    //
    // Operators
    //

    //
    // Methods
    //

    BOOL LoadDriverImageData();

    //
    // Overrides
    //

    virtual void AssertValid( ) const;

protected:
    BOOL LoadDriverHeaderData();
    BOOL LoadDriverVersionData();

public:
    //
    // Type definitions
    //
    
    typedef enum
    {
        SignedNotVerifiedYet = 1,
        SignedYes,
        SignedNo
    } SignedTypeEnum;

    typedef enum
    {
        VerifyDriverNo = 1,
        VerifyDriverYes
    } VerifyDriverTypeEnum;

public:
    //
    // Data
    //

    CString                 m_strName;
    
    SignedTypeEnum          m_SignedStatus;
    VerifyDriverTypeEnum    m_VerifyDriverStatus;

    //
    // If the current driver is a miniport then 
    // m_strMiniportName is the driver it is linked against (videoprt.sys, etc.)
    //

    CString                 m_strMiniportName;

    //
    // If this is a "special driver" this is the name to add to the verification list
    //
    // - hal.dll for the HAL
    // - ntoskrnl.exe fro the kernel
    //

    CString                 m_strReservedName;

    //
    // Binary header info
    //

    WORD                    m_wMajorOperatingSystemVersion;
    WORD                    m_wMajorImageVersion;

    //
    // Version info
    //

    CString                 m_strCompanyName;
    CString                 m_strFileVersion;
    CString                 m_strFileDescription;
};

///////////////////////////////////////////////////////////////
//
// CDriverDataArray class
//
// ObArray of CDriverData
//

class CDriverDataArray : public CObArray
{
public:
    ~CDriverDataArray();

public:
    VOID DeleteAll();
    CDriverData *GetAt( INT_PTR nIndex ) const;
    
public:
    //
    // Operators
    //

    CDriverDataArray &operator = (const CDriverDataArray &DriversSet);
};

///////////////////////////////////////////////////////////////
//
// CDriversSet class 
//
// Describes a set of drivers to verify
//

class CDriversSet : public CObject  
{
public:
	CDriversSet();
	virtual ~CDriversSet();

public:
    //
    // Find all installed unsigned drivers if we didn't do that already
    //

    BOOL LoadAllDriversData( HANDLE hAbortEvent,
                             CVrfProgressCtrl	&ProgressCtl );

    BOOL FindUnsignedDrivers( HANDLE hAbortEvent,
                              CVrfProgressCtrl	&ProgressCtl );

    BOOL ShouldDriverBeVerified( const CDriverData *pDriverData ) const;
    BOOL ShouldVerifySomeDrivers( ) const;

    BOOL GetDriversToVerify( CString &strDriversToVerify );

    //
    // Operators
    //

    CDriversSet &operator = (const CDriversSet &DriversSet);

    //
    // Add a new verifier data structure based on the name
    // Returns the new item's index in the array.
    //

    INT_PTR AddNewDriverData( LPCTSTR szDriverName );

    //
    // Is this driver name already in our list?
    //

    BOOL IsDriverNameInList( LPCTSTR szDriverName );

    //
    // Overrides
    //

    virtual void AssertValid( ) const;

protected:

    //
    // Load all installed driver names if we didn't do this already
    // 

    BOOL LoadAllDriversNames( HANDLE hAbortEvent );

public:
    //
    // Types
    //

    typedef enum
    {
        DriversSetCustom = 1,
        DriversSetOldOs,
        DriversSetNotSigned,
        DriversSetAllDrivers
    } DriversSetTypeEnum;

    //
    // Data
    //

    //
    // Standard, custom, etc.
    //

    DriversSetTypeEnum  m_DriverSetType;

    //
    // Array with data for all the currently installed drivers
    //

    CDriverDataArray    m_aDriverData;

    //
    // Extra drivers (not currenly installed) to verify
    //

    CStringArray        m_astrNotInstalledDriversToVerify;

    //
    // Did we initialize already the driver data array?
    //

    BOOL                m_bDriverDataInitialized;

    //
    // Did we initialize already the unsigned drivers member 
    // of the driver data structure?
    //

    BOOL                m_bUnsignedDriverDataInitialized;
};


///////////////////////////////////////////////////////////////
//
// CSettingsBits class 
//
// Describes a set of verifier settings bits
//

class CSettingsBits : public CObject  
{
public:
	CSettingsBits();
	virtual ~CSettingsBits();

public:
    //
    // Type definitions
    //

    typedef enum
    {
        SettingsTypeTypical = 1,
        SettingsTypeCustom,
    } SettingsTypeEnum;

public:
    //
    // Operators
    //

    CSettingsBits &operator = (const CSettingsBits &VerifSettings);

    //
    // Overrides
    //

    virtual void AssertValid() const;

    //
    // Methods
    //

    VOID SetTypicalOnly();

    VOID EnableTypicalTests( BOOL bEnable );
    VOID EnableExcessiveTests( BOOL bEnable );
    VOID EnableLowResTests( BOOL bEnable );

    BOOL GetVerifierFlags( DWORD &dwVerifyFlags );

public:
    //
    // Data
    //

    SettingsTypeEnum    m_SettingsType;

    BOOL            m_bSpecialPoolEnabled;
    BOOL            m_bForceIrqlEnabled;
    BOOL            m_bLowResEnabled;
    BOOL            m_bPoolTrackingEnabled;
    BOOL            m_bIoEnabled;
    BOOL            m_bDeadlockDetectEnabled;
    BOOL            m_bDMAVerifEnabled;
    BOOL            m_bEnhIoEnabled;
};

///////////////////////////////////////////////////////////////
//
// CDiskData class
//
// Has information about one disk.
//

class CDiskData : public CObject
{
public:
    CDiskData( LPCTSTR szVerifierEnabled, 
               LPCTSTR szDiskDevicesForDisplay, 
               LPCTSTR szDiskDevicesPDOName );
    CDiskData( const CDiskData &DiskData );
    virtual ~CDiskData();

public:
    //
    // Operators
    //

    //
    // Methods
    //

    //
    // Overrides
    //

    virtual void AssertValid( ) const;

protected:

public:
    //
    // Data
    //

    BOOL    m_bVerifierEnabled;
    CString m_strDiskDevicesForDisplay;
    CString m_strDiskDevicesPDOName;
};

///////////////////////////////////////////////////////////////
//
// CDiskDataArray class
//
// ObArray of CDiskData
//

class CDiskDataArray : public CObArray
{
public:
    CDiskDataArray();
    ~CDiskDataArray();

public:
    VOID DeleteAll();
    CDiskData *GetAt( INT_PTR nIndex ) const;

    BOOL InitializeDiskList();
    BOOL VerifyAnyDisk();
    BOOL SaveNewSettings();
    BOOL DeleteAllSettings();
    VOID SetVerifyAllDisks( BOOL bEnabled );
        
public:
    //
    // Operators
    //

    CDiskDataArray &operator = (const CDiskDataArray &DiskDataArray);

public:
    //
    // Data.
    //
};

///////////////////////////////////////////////////////////////
//
// CVerifierSettings class 
//
// Describes a set of drivers and/or disks to verify and 
// the verifier settings bits
//

class CVerifierSettings : public CObject  
{
public:
	CVerifierSettings();
	virtual ~CVerifierSettings();

public:
    //
    // Operators
    //

    CVerifierSettings &operator = (const CVerifierSettings &VerifSettings);

    //
    // Overrides
    //

    virtual void AssertValid() const;

    //
    // Methods
    //

    BOOL SaveToRegistry();

public:
    //
    // Data
    //

    //
    // XP and earlier driver verifier settings.
    //

    CSettingsBits   m_SettingsBits;
    CDriversSet     m_DriversSet;

    //
    // Disk integrity verifier settings.
    //

    CDiskDataArray  m_aDiskData;
};

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Runtime data - queried from the kernel
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
// class CRuntimeDriverData
//

class CRuntimeDriverData : public CObject
{
public:
    //
    // Construction
    //

    CRuntimeDriverData();

public:
    //
    // Data
    //

    CString m_strName;

    ULONG Loads;
    ULONG Unloads;

    ULONG CurrentPagedPoolAllocations;
    ULONG CurrentNonPagedPoolAllocations;
    ULONG PeakPagedPoolAllocations;
    ULONG PeakNonPagedPoolAllocations;

    SIZE_T PagedPoolUsageInBytes;
    SIZE_T NonPagedPoolUsageInBytes;
    SIZE_T PeakPagedPoolUsageInBytes;
    SIZE_T PeakNonPagedPoolUsageInBytes;
};

//////////////////////////////////////////////////////////////////////
//
// class CRuntimeDriverDataArray
//

class CRuntimeDriverDataArray : public CObArray
{
public:
    ~CRuntimeDriverDataArray();

public:
    CRuntimeDriverData *GetAt( INT_PTR nIndex );

    VOID DeleteAll();
};

//////////////////////////////////////////////////////////////////////
//
// class CRuntimeVerifierData
//

class CRuntimeVerifierData : public CObject
{
public:
    //
    // Construction
    //

    CRuntimeVerifierData();

public:
    //
    // Methods
    //

    VOID FillWithDefaults();
    BOOL IsDriverVerified( LPCTSTR szDriveName );

public:
    //
    // Data
    //

    BOOL            m_bSpecialPool;
    BOOL            m_bPoolTracking;
    BOOL            m_bForceIrql;
    BOOL            m_bIo;
    BOOL            m_bEnhIo;
    BOOL            m_bDeadlockDetect;
    BOOL            m_bDMAVerif;
    BOOL            m_bLowRes;

    ULONG RaiseIrqls;
    ULONG AcquireSpinLocks;
    ULONG SynchronizeExecutions;
    ULONG AllocationsAttempted;

    ULONG AllocationsSucceeded;
    ULONG AllocationsSucceededSpecialPool;
    ULONG AllocationsWithNoTag;

    ULONG Trims;
    ULONG AllocationsFailed;
    ULONG AllocationsFailedDeliberately;

    ULONG UnTrackedPool;

    DWORD Level;

    CRuntimeDriverDataArray m_RuntimeDriverDataArray;
};


#endif // !defined(AFX_VSETTING_H__478A94E4_3D60_4419_950C_2144CB86691D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\drvcsht.cxx ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
// module: DrvCSht.cxx
// author: DMihai
// created: 01/04/98
//
// Description:
//
//      App's PropertySheet. 
//

#include "stdafx.h"
#include "drvvctrl.hxx"
#include "DrvCSht.hxx"

//
// help IDs
//

static DWORD MyHelpIds[] =
{
    IDCANCEL,                       IDH_DV_common_exit,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CDrvChkSheet property sheet

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDrvChkSheet::CDrvChkSheet()
: CPropertySheet(IDS_APPTITLE)
{
    //{{AFX_DATA_INIT(CDrvChkSheet)
    //}}AFX_DATA_INIT

    AddPage( &m_CrtSettPage );
    AddPage( &m_CountPage );
    AddPage( &m_PoolCountersPage );
    AddPage( &m_ModifPage );
    AddPage( &m_VolatilePage );

    m_psh.dwFlags |= PSH_NOAPPLYNOW;

    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

CDrvChkSheet::~CDrvChkSheet()
{
}

//////////////////////////////////////////////////////////////////////
void CDrvChkSheet::DoDataExchange(CDataExchange* pDX)
{
    CPropertySheet::DoDataExchange( pDX );

    //{{AFX_DATA_MAP(CDrvChkSheet)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDrvChkSheet, CPropertySheet)
    //{{AFX_MSG_MAP(CDrvChkSheet)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_MESSAGE( WM_CONTEXTMENU, OnContextMenu )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
void CDrvChkSheet::ModifyButtons()
{
    BOOL bHaveHelpButton = FALSE;
    CWnd *pWnd;
    CString strQuit;
    CRect rectHelp;

    //
    // Hide the OK button
    //

    pWnd = GetDlgItem( IDOK );
    
    if( pWnd != NULL )
    {
        ASSERT_VALID( pWnd );

        pWnd->ShowWindow( SW_HIDE );
    }

    //
    // Hide the Help button
    //

    pWnd = GetDlgItem( IDHELP );

    if( pWnd != NULL )
    {
        ASSERT_VALID( pWnd );

        pWnd->GetWindowRect( rectHelp );
        ScreenToClient( rectHelp );
        bHaveHelpButton = TRUE;

        pWnd->ShowWindow( SW_HIDE );
    }

    //
    // Cancel button becomes Exit
    //

    pWnd = GetDlgItem( IDCANCEL );
    
    if( pWnd != NULL )
    {
        ASSERT_VALID( pWnd );

        VERIFY( strQuit.LoadString( IDS_QUIT ) );
        pWnd->SetWindowText( strQuit );

        if( bHaveHelpButton )
        {
            pWnd->MoveWindow( rectHelp );
        }
    }
}

//////////////////////////////////////////////////////////////////////
// message handlers
BOOL CDrvChkSheet::OnInitDialog() 
{
    BOOL bResult = CPropertySheet::OnInitDialog();

    //
    // Add the context sensitive button to the titlebar
    //

    LONG lStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
    lStyle |= WS_EX_CONTEXTHELP;
    ::SetWindowLong(m_hWnd, GWL_EXSTYLE, lStyle);

    // Add "About..." menu item to system menu.

    // IDM_ABOUTBOX must be in the system command range.
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    if (pSysMenu != NULL)
    {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);
        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    // Set the icon for this dialog.  The framework does this automatically
    //  when the application's main window is not a dialog
    SetIcon(m_hIcon, TRUE);			// Set big icon
    SetIcon(m_hIcon, FALSE);		// Set small icon

    // TODO: Add extra initialization here
    ModifyButtons();

    return bResult;
}

//////////////////////////////////////////////////////////////////////
void CDrvChkSheet::OnSysCommand(UINT nID, LPARAM lParam)
{
    CString strWndTitle;
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        GetWindowText( strWndTitle );
        ShellAbout( m_hWnd, (LPCTSTR)strWndTitle, NULL, m_hIcon );
    }
    else
    {
        CPropertySheet::OnSysCommand(nID, lParam);
    }
}

//////////////////////////////////////////////////////////////////////
// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CDrvChkSheet::OnPaint() 
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CPropertySheet::OnPaint();
    }
}

//////////////////////////////////////////////////////////////////////
// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CDrvChkSheet::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}


//////////////////////////////////////////////////////////////////////
BOOL CDrvChkSheet::OnQueryCancel()
{
    if( GetActivePage() != &m_ModifPage )
    {
        return m_ModifPage.OnQueryCancel();
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////
LONG CDrvChkSheet::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        VERIFIER_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////
LONG CDrvChkSheet::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;

    ::WinHelp( 
        (HWND) wParam,
        VERIFIER_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\drvvctrl.cxx ===
//
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: DrvVCtrl.cxx
// author: DMihai
// created: 01/04/98
//
// Description:
//
//      Defines the class behaviors for the application..
//


#include "stdafx.h"
#include "DrvVCtrl.hxx"

#include "DrvCSht.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static BOOL IsBuildNumberAcceptable()
{
    if( g_OsVersion.dwMajorVersion < 5 || g_OsVersion.dwBuildNumber < 1954 )
    {
        ::AfxMessageBox( IDS_BUILD_WARN,
            MB_OK | MB_ICONSTOP );
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDrvVCtrlApp

BEGIN_MESSAGE_MAP(CDrvVCtrlApp, CWinApp)
    //{{AFX_MSG_MAP(CDrvVCtrlApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDrvVCtrlApp construction

CDrvVCtrlApp::CDrvVCtrlApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance

    CString strAppName;

    if( strAppName.LoadString( IDS_APPTITLE ) )
    {
        m_pszAppName = _tcsdup( (LPCTSTR)strAppName );
    }
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDrvVCtrlApp object

CDrvVCtrlApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDrvVCtrlApp initialization

BOOL CDrvVCtrlApp::InitInstance()
{
    DWORD dwExitCode;

    //
    // Get the OS version and build nuber
    //

    ZeroMemory (&g_OsVersion, sizeof g_OsVersion);
    g_OsVersion.dwOSVersionInfoSize = sizeof g_OsVersion;
    GetVersionEx (&g_OsVersion);

    //
    // check for command line arguments
    //

    if( __argc > 1 )
    {
        //
        // run just in command line mode
        //

        dwExitCode = VrfExecuteCommandLine( __argc, __targv );
        exit( dwExitCode );
    }
    else
    {
        FreeConsole();

        //
        // check if the build # is acceptable
        //

        if( ! ::IsBuildNumberAcceptable() )
        {
            return FALSE;
        }
    }

    AfxEnableControlContainer();

    //
    // There is only one property sheet in this program so
    // we declare it static. It is embedding very big KRN_VERIFIER_STATE and
    // VRF_VERIFIER_STATE structures so we don't want them pushed on the stack
    //
    
    static CDrvChkSheet dlg;

    //
    // show the dialog
    //

    m_pMainWnd = &dlg;
    dlg.DoModal();

    //
    // all done, exit the application
    //
    
    if( g_bSettingsSaved )
    {
        exit( EXIT_CODE_REBOOT_NEEDED );
    }
    else
    {
        exit( EXIT_CODE_SUCCESS );
    }

    //
    // not reached
    // 
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\pcntpage.cxx ===
// PCntPage.cpp : implementation file
//

#include "stdafx.h"
#include "drvvctrl.hxx"
#include "PCntPage.hxx"

#include "DrvCSht.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// timer ID
#define REFRESH_TIMER_ID    0x1243

// manual, high, normal, low speed
#define REFRESH_SPEED_VARS  4

// timer intervals in millisec for manual, high, normal, low speed
static UINT uTimerIntervals[ REFRESH_SPEED_VARS ] =
{
    0,      // Manual
    1000,   // High Speed
    5000,   // Normal Speed
    10000   // Low Speed
};

//
// help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_POOLCNT_CRT_PPOOL_ALLOC_EDIT,       IDH_DV_PoolTab_paged_allocations_current,
    IDC_POOLCNT_CRT_NPPOOL_ALLOC_EDIT,      IDH_DV_PoolTab_nonpaged_allocations_current,
    IDC_POOLCNT_PEAK_PPOOL_ALLOC_EDIT,      IDH_DV_PoolTab_paged_allocations_peak,
    IDC_POOLCNT_PEAK_NPPOOL_ALLOC_EDIT,     IDH_DV_PoolTab_nonpaged_allocations_peak,
    IDC_POOLCNT_UNTRACK_ALLOC_EDIT,         IDH_DV_PoolTab_globalcounters,
    IDC_POOLCNT_CRT_PPOOL_BYTES_EDIT,       IDH_DV_PoolTab_paged_currentbytes,
    IDC_POOLCNT_CRT_NPPOOL_BYTES_EDIT,      IDH_DV_PoolTab_nonpaged_currentbytes,
    IDC_POOLCNT_PEAK_PPOOL_BYTES_EDIT,      IDH_DV_PoolTab_paged_peakbytes,
    IDC_POOLCNT_PEAK_NPPOOL_BYTES_EDIT,     IDH_DV_PoolTab_nonpaged_peakbytes,
    IDC_POOLCNT_DRVNAME_COMBO,              IDH_DV_PoolTab_indivcounters,

    IDC_POOLCNT_REFRESH_BUTTON,     IDH_DV_common_refresh_nowbutton,
    IDC_POOLCNT_MANUAL_RADIO,       IDH_DV_common_refresh_manual,
    IDC_POOLCNT_HSPEED_RADIO,       IDH_DV_common_refresh_high,
    IDC_POOLCNT_NORM_RADIO,         IDH_DV_common_refresh_normal,
    IDC_POOLCNT_LOW_RADIO,          IDH_DV_common_refresh_low,
    0,                              0
};


/////////////////////////////////////////////////////////////////////
static void GetStringFromULONG( CString &strValue, ULONG_PTR uValue )
{
    LPTSTR lptstrValue = strValue.GetBuffer( 64 );
    if( lptstrValue != NULL )
    {
        _stprintf( lptstrValue, _T( "%lu" ), uValue );
        strValue.ReleaseBuffer();
    }
    else
    {
        ASSERT( FALSE );
        strValue.Empty();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CPoolCntPage property page

IMPLEMENT_DYNCREATE(CPoolCntPage, CPropertyPage)

CPoolCntPage::CPoolCntPage()
	: CPropertyPage(CPoolCntPage::IDD)
{
	//{{AFX_DATA_INIT(CPoolCntPage)
    m_nUpdateIntervalIndex = 2;
	m_strCrtNPAlloc = _T("");
	m_strCrtNPBytes = _T("");
	m_strCrtPPAlloc = _T("");
	m_strCrtPPBytes = _T("");
	m_strPeakNPPAlloc = _T("");
	m_strPeakNPPBytes = _T("");
	m_strPeakPPAlloc = _T("");
	m_strPeakPPBytes = _T("");
	m_strUnTrackedAlloc = _T("");
	//}}AFX_DATA_INIT

    m_uTimerHandler = 0;
}


void CPoolCntPage::DoDataExchange(CDataExchange* pDX)
{
    TCHAR szCrtDriverName [ _MAX_PATH ];
    BOOL bComboEnabled;

	CPropertyPage::DoDataExchange(pDX);

    //
    // subclass the combo-box
    //

	DDX_Control(pDX, IDC_POOLCNT_DRVNAME_COMBO, m_DrvNamesCombo);

    //
    // get the date from the kernel
    //

    bComboEnabled = TRUE;

    if( ! pDX->m_bSaveAndValidate )
    {
        //
        // get the currently selected driver name
        //

        GetCurrentSelDriverName( szCrtDriverName, ARRAY_LENGTH( szCrtDriverName ) );

        //
        // query the kernel
        //

        if( KrnGetSystemVerifierState( &m_KrnVerifState ) && 
            m_KrnVerifState.DriverCount > 0 )
        {
            //
            // UnTrackedPool - global counter
            //

            GetStringFromULONG( m_strUnTrackedAlloc, 
                m_KrnVerifState.UnTrackedPool );

            //
            // update combo content
            //
            
            FillDriversNameCombo( szCrtDriverName );
        }
        else
        {
            //
            // UnTrackedPool - global counter
            //

            VERIFY( m_strUnTrackedAlloc.LoadString( IDS_ZERO ) );

            //
            // disable the drivers name list
            //

            bComboEnabled = FALSE;
            
            m_DrvNamesCombo.ResetContent();

            //
            // this is used by OnDriversNameSelChanged
            //
            
            m_KrnVerifState.DriverCount = 0;
        }

        //
        // update per driver counters
        //

        OnDriversNameSelChanged();
    }

	//{{AFX_DATA_MAP(CPoolCntPage)
    DDX_Radio(pDX, IDC_POOLCNT_MANUAL_RADIO, m_nUpdateIntervalIndex);
	DDX_Text(pDX, IDC_POOLCNT_UNTRACK_ALLOC_EDIT, m_strUnTrackedAlloc);
	//}}AFX_DATA_MAP

    if( ! pDX->m_bSaveAndValidate )
    {
        m_DrvNamesCombo.EnableWindow( bComboEnabled );
    }
}


BEGIN_MESSAGE_MAP(CPoolCntPage, CPropertyPage)
	//{{AFX_MSG_MAP(CPoolCntPage)
    ON_BN_CLICKED(IDC_POOLCNT_REFRESH_BUTTON, OnCountRefreshButton)
    ON_WM_TIMER()
    ON_BN_CLICKED(IDC_POOLCNT_HSPEED_RADIO, OnCountHspeedRadio)
    ON_BN_CLICKED(IDC_POOLCNT_LOW_RADIO, OnCountLowRadio)
    ON_BN_CLICKED(IDC_POOLCNT_MANUAL_RADIO, OnCountManualRadio)
    ON_BN_CLICKED(IDC_POOLCNT_NORM_RADIO, OnCountNormRadio)
	ON_CBN_SELENDOK(IDC_POOLCNT_DRVNAME_COMBO, OnDriversNameSelChanged)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_MESSAGE( WM_CONTEXTMENU, OnContextMenu )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPoolCntPage message handlers

/////////////////////////////////////////////////////////////////////
void CPoolCntPage::OnRefreshTimerChanged()
{
    UINT uTimerElapse = 0;

    // kill the pending timer
    if( m_uTimerHandler != 0 )
    {
        VERIFY( KillTimer( REFRESH_TIMER_ID ) );
    }

    // sanity check
    if( m_nUpdateIntervalIndex < 0 || 
        m_nUpdateIntervalIndex >= REFRESH_SPEED_VARS )
    {
        m_nUpdateIntervalIndex = 0;
        CheckRadioButton( IDC_POOLCNT_MANUAL_RADIO, IDC_POOLCNT_LOW_RADIO, 
            IDC_POOLCNT_MANUAL_RADIO );
    }

    // new timer interval
    uTimerElapse = uTimerIntervals[ m_nUpdateIntervalIndex ];
    if( uTimerElapse > 0 )
    {
        VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID, 
            uTimerElapse, NULL ) );
    }
}

/////////////////////////////////////////////////////////////////////
// CPoolCntPage message handlers
BOOL CPoolCntPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    OnRefreshTimerChanged();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////
void CPoolCntPage::OnCountRefreshButton() 
{
    UpdateData( FALSE );
}

/////////////////////////////////////////////////////////////////////
void CPoolCntPage::OnTimer(UINT nIDEvent) 
{
    if( nIDEvent == REFRESH_TIMER_ID )
    {
        CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
        if( pParentSheet != NULL )
        {
            ASSERT_VALID( pParentSheet );
            if( pParentSheet->GetActivePage() == this )
            {
                // refresh the displayed data 
                OnCountRefreshButton();
            }
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////
BOOL CPoolCntPage::OnQueryCancel() 
{
    // give parent PropertySheet a chance to refuse the Cancel if needed

    CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
    if( pParentSheet != NULL )
    {
        ASSERT_VALID( pParentSheet );
        if( ! pParentSheet->OnQueryCancel() )
        {
            return FALSE;
        }
    }

    return CPropertyPage::OnQueryCancel();
}

/////////////////////////////////////////////////////////////////////
BOOL CPoolCntPage::OnApply() 
{
    // refuse to apply 
    // (we don't use the standard PropertSheet buttons; Apply, OK)
    return FALSE;
}

/////////////////////////////////////////////////////////////////////
void CPoolCntPage::OnCountManualRadio() 
{
    // switch to manual refresh
    m_nUpdateIntervalIndex = 0;
    OnRefreshTimerChanged();
}

void CPoolCntPage::OnCountHspeedRadio() 
{
    // switch to high speed refresh
    m_nUpdateIntervalIndex = 1;
    OnRefreshTimerChanged();
}

void CPoolCntPage::OnCountNormRadio() 
{
    // switch to normal speed refresh
    m_nUpdateIntervalIndex = 2;
    OnRefreshTimerChanged();
}

void CPoolCntPage::OnCountLowRadio() 
{
    // switch to low speed refresh
    m_nUpdateIntervalIndex = 3;
    OnRefreshTimerChanged();
}

/////////////////////////////////////////////////////////////////////
void CPoolCntPage::OnDriversNameSelChanged() 
{
	int nCrtSelItem;
    int nIndexInArray;
    BOOL bAllCountersZero;

    bAllCountersZero = TRUE;

    nCrtSelItem = m_DrvNamesCombo.GetCurSel();

    if( nCrtSelItem >= 0 && nCrtSelItem < (int)m_KrnVerifState.DriverCount )
    {
        nIndexInArray = (int)m_DrvNamesCombo.GetItemData( nCrtSelItem );

        if( nIndexInArray >= 0 && nIndexInArray < (int)m_KrnVerifState.DriverCount )
        {
            bAllCountersZero = FALSE;

            // CurrentPagedPoolAllocations
            GetStringFromULONG( m_strCrtPPAlloc, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].CurrentPagedPoolAllocations );

            // CurrentNonPagedPoolAllocations
            GetStringFromULONG( m_strCrtNPAlloc, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].CurrentNonPagedPoolAllocations );

            // PeakPagedPoolAllocations
            GetStringFromULONG( m_strPeakPPAlloc, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].PeakPagedPoolAllocations );

            // PeakNonPagedPoolAllocations
            GetStringFromULONG( m_strPeakNPPAlloc, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].PeakNonPagedPoolAllocations );

            // PagedPoolUsageInBytes
            GetStringFromULONG( m_strCrtPPBytes, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].PagedPoolUsageInBytes );

            // NonPagedPoolUsageInBytes
            GetStringFromULONG( m_strCrtNPBytes, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].NonPagedPoolUsageInBytes );

            // PeakPagedPoolUsageInBytes
            GetStringFromULONG( m_strPeakPPBytes, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].PeakPagedPoolUsageInBytes );

            // PeakNonPagedPoolUsageInBytes
            GetStringFromULONG( m_strPeakNPPBytes, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].PeakNonPagedPoolUsageInBytes );
        }
        else
        {
            ASSERT( FALSE );
        }
    }

    if( bAllCountersZero )
    {
        // CurrentPagedPoolAllocations
        VERIFY( m_strCrtPPAlloc.LoadString( IDS_ZERO ) );

        // CurrentNonPagedPoolAllocations
        VERIFY( m_strCrtNPAlloc.LoadString( IDS_ZERO ) );

        // PeakPagedPoolAllocations
        VERIFY( m_strPeakPPAlloc.LoadString( IDS_ZERO ) );

        // PeakNonPagedPoolAllocations
        VERIFY( m_strPeakNPPAlloc.LoadString( IDS_ZERO ) );

        // PagedPoolUsageInBytes
        VERIFY( m_strCrtPPBytes.LoadString( IDS_ZERO ) );

        // NonPagedPoolUsageInBytes
        VERIFY( m_strCrtNPBytes.LoadString( IDS_ZERO ) );

        // PeakPagedPoolUsageInBytes
        VERIFY( m_strPeakPPBytes.LoadString( IDS_ZERO ) );

        // PeakNonPagedPoolUsageInBytes
        VERIFY( m_strPeakNPPBytes.LoadString( IDS_ZERO ) );
    }

    //
    // set the text in edit controls
    //
	
    SetDlgItemText( IDC_POOLCNT_CRT_NPPOOL_ALLOC_EDIT, m_strCrtNPAlloc);
	SetDlgItemText( IDC_POOLCNT_CRT_NPPOOL_BYTES_EDIT, m_strCrtNPBytes);
	SetDlgItemText( IDC_POOLCNT_CRT_PPOOL_ALLOC_EDIT, m_strCrtPPAlloc);
	SetDlgItemText( IDC_POOLCNT_CRT_PPOOL_BYTES_EDIT, m_strCrtPPBytes);
	SetDlgItemText( IDC_POOLCNT_PEAK_NPPOOL_ALLOC_EDIT, m_strPeakNPPAlloc);
	SetDlgItemText( IDC_POOLCNT_PEAK_NPPOOL_BYTES_EDIT, m_strPeakNPPBytes);
	SetDlgItemText( IDC_POOLCNT_PEAK_PPOOL_ALLOC_EDIT, m_strPeakPPAlloc);
	SetDlgItemText( IDC_POOLCNT_PEAK_PPOOL_BYTES_EDIT, m_strPeakPPBytes);
}

/////////////////////////////////////////////////////////////////////
// operations

void CPoolCntPage::GetCurrentSelDriverName( 
    TCHAR *szCrtDriverName,
    int nBufferLength )
{
    int nCrtSel;
    int nNameLength;
    int nDriverEntryIndex;

    if( nBufferLength < 1 )
    {
        ASSERT( FALSE );
        return;
    }

    szCrtDriverName[ 0 ] = (TCHAR)0;

    nCrtSel = m_DrvNamesCombo.GetCurSel();
    
    if( nCrtSel != CB_ERR && nCrtSel < (int)m_KrnVerifState.DriverCount )
    {
        nDriverEntryIndex = (int)m_DrvNamesCombo.GetItemData( nCrtSel );

        if( nDriverEntryIndex >= 0 && nDriverEntryIndex < (int)m_KrnVerifState.DriverCount )
        {
            nNameLength = _tcslen( m_KrnVerifState.DriverInfo[ nDriverEntryIndex ].Name );

            if( nNameLength < nBufferLength )
            {
                _tcscpy( szCrtDriverName, m_KrnVerifState.DriverInfo[ nDriverEntryIndex ].Name );
            }
        }
        else
        {
            ASSERT( FALSE );
        }
    }
}

/////////////////////////////////////////////////////////////////////
void CPoolCntPage::FillDriversNameCombo(
    TCHAR *strNameToSelect )
{
    BOOL *pbAlreadyInCombo;
    CString strDriverName;
    UINT uCrtVerifiedDriver;
    int nCrtItemIndex;
    int nCrtSelectedItem;
    int nComboItemCount;
    int nActualIndex;

    nCrtSelectedItem = 0;

    if( m_KrnVerifState.DriverCount > 0 )
    {
        //
        // allocate a logical value for each currently verified driver 
        // with initial value FALSE
        //

        pbAlreadyInCombo = new BOOL[ m_KrnVerifState.DriverCount ];
    
        if( pbAlreadyInCombo == NULL )
        {
            m_DrvNamesCombo.ResetContent();
            return;
        }

        for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++ )
        {
            pbAlreadyInCombo[ uCrtVerifiedDriver ] = FALSE;
        }

        //
        // parse each name currently in combo
        //

        nComboItemCount = m_DrvNamesCombo.GetCount();

        for( nCrtItemIndex = 0; nCrtItemIndex < nComboItemCount; nCrtItemIndex++ )
        {
            m_DrvNamesCombo.GetLBText( nCrtItemIndex, strDriverName );

            //
            // parse the driver names in m_KrnVerifState and see if we have a match
            //

            for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++ )
            {
                if( _tcsicmp( (LPCTSTR)strDriverName, m_KrnVerifState.DriverInfo[ uCrtVerifiedDriver ].Name ) == 0 )
                {
                    //
                    // it's still verified
                    //

                    pbAlreadyInCombo[ uCrtVerifiedDriver ] = TRUE;

                    //
                    // update the index in m_KrnVerifState.DriverInfo array
                    //

                    m_DrvNamesCombo.SetItemData( nCrtItemIndex, uCrtVerifiedDriver );
                    
                    break;
                }
            }

            if( uCrtVerifiedDriver >= m_KrnVerifState.DriverCount )
            {
                //
                // this driver is no longer verified, remove it from the list
                //

                m_DrvNamesCombo.DeleteString( nCrtItemIndex );

                nCrtItemIndex--;
                nComboItemCount--;
            }
        }

        //
        // add the new verified drivers
        //

        for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++ )
        {
            if( pbAlreadyInCombo[ uCrtVerifiedDriver ] == FALSE )
            {
                nActualIndex = m_DrvNamesCombo.AddString( m_KrnVerifState.DriverInfo[ uCrtVerifiedDriver ].Name );

                if( nActualIndex != CB_ERR )
                {   
                    m_DrvNamesCombo.SetItemData( nActualIndex, uCrtVerifiedDriver );
                }   
            }
        }

        ASSERT( m_DrvNamesCombo.GetCount() == m_KrnVerifState.DriverCount );

        //
        // current selection
        //

        nComboItemCount = m_DrvNamesCombo.GetCount();

        for( nCrtItemIndex = 0; nCrtItemIndex < nComboItemCount; nCrtItemIndex++ )
        {
            m_DrvNamesCombo.GetLBText( nCrtItemIndex, strDriverName );

            if( _tcsicmp( (LPCTSTR)strDriverName, strNameToSelect ) == 0 )
            {
                nCrtSelectedItem = nCrtItemIndex;
                break;
            }
        }

        delete pbAlreadyInCombo;
    }
    else
    {
        m_DrvNamesCombo.ResetContent();
    }

    m_DrvNamesCombo.SetCurSel( nCrtSelectedItem );
}

/////////////////////////////////////////////////////////////
LONG CPoolCntPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        VERIFIER_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////
LONG CPoolCntPage::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;

    ::WinHelp( 
        (HWND) wParam,
        VERIFIER_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\image.cxx ===
//
// Driver Verifier Control Applet
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: image.cxx
// author: silviuc
// created: Thu Jan 07 20:05:09 1999
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <tchar.h>
#include <windows.h>

#include "image.hxx"
#include "verify.hxx"


//
// Function:
//
//     ImgInitializeBrowseInfo
//
// Description:
//
//     This functions fills oout the `Info' structure with
//     various pointers to PE data from the mapped image file.
//
//     Note. Even if the function returned false the destructor
//     `ImgDeleteBrowseInfo' should be called because it does some
//     cleanup.
//
// Return:
//
//     True if all the PE data pointers have been obtained.
//

BOOL
ImgInitializeBrowseInfo (

    LPCTSTR FilePath,
    PIMAGE_BROWSE_INFO Info)
{
    DWORD Index;

    if (Info == NULL) {
        return FALSE;
    }

    ZeroMemory (Info, sizeof *Info);

    Info->File = CreateFile (

        FilePath,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (Info->File == INVALID_HANDLE_VALUE) {

      return FALSE;
    }

    Info->Section = CreateFileMapping (

        Info->File,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL);

    if (Info->Section == NULL) {

      return FALSE;
    }

    Info->ImageBase = (LPBYTE) MapViewOfFile (

        Info->Section,
        FILE_MAP_READ,
        0,
        0,
        0);

    if (Info->ImageBase == NULL) {

      return FALSE;
    }

    //
    // Check the signature
    //

    Info->DosHeader = (PIMAGE_DOS_HEADER)Info->ImageBase;

    if (Info->DosHeader->e_magic != 'ZM') {

      return FALSE;
    }

    Info->FileHeader = (PIMAGE_FILE_HEADER)
        (Info->ImageBase + Info->DosHeader->e_lfanew + sizeof(DWORD));

    Info->FileSignature = *((DWORD *)Info->FileHeader - 1);

    if (Info->FileSignature != IMAGE_NT_SIGNATURE) {

      return FALSE;
    }


    Info->OptionalHeader = (PIMAGE_OPTIONAL_HEADER)(Info->FileHeader + 1);
    Info->ImportDirectory = & (Info->OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);
    Info->SectionHeader = (PIMAGE_SECTION_HEADER)(Info->OptionalHeader + 1);
    Info->ImportSection = NULL;

    //
    // Find the section containing the import table
    //

    for (Index = 0; Index < Info->FileHeader->NumberOfSections; Index++) {

        DWORD Start = (Info->SectionHeader + Index)->VirtualAddress;
        DWORD Size =  (Info->SectionHeader + Index)->SizeOfRawData;
        DWORD Import = Info->ImportDirectory->VirtualAddress;

        if (Start <= Import && Start + Size > Import) {

            Info->ImportSection = &(Info->SectionHeader[Index]);
            break;
        }
    }

    if (Info->ImportSection == NULL) {

        return FALSE;
    }

    //
    // Find the address of import data in the section body.
    //

    Info->AddressCorrection = (DWORD_PTR)Info->ImageBase 
        + Info->ImportSection->PointerToRawData
        - Info->ImportSection->VirtualAddress;

    Info->ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(Info->AddressCorrection
         + Info->ImportDirectory->VirtualAddress);

    //
    // Finish
    //

    return TRUE;
}


//
// Function:
//
//     ImgDeleteBrowseInfo
//
// Description:
//
//     This function cleans up the `Info' structure, unmaps views, 
//     closes handles, etc.
//

BOOL
ImgDeleteBrowseInfo (

    PIMAGE_BROWSE_INFO Info)
{
    if (Info == NULL)
        return FALSE;

    UnmapViewOfFile (Info->ImageBase);
    CloseHandle (Info->Section);
    CloseHandle (Info->File);

    ZeroMemory (Info, sizeof *Info);

    return TRUE;
}


//
// Function:
//
//     ImgSearchDriverName
//
// Description:
//
//     This function checks if a driver is in `system32' or
//     `drivers\system32' directory. If it is then the full
//     path to the driver is written in `DriverPath'.
//
// Return:
//
//     True if driver found in system 32 or system32\drivers.
//

BOOL
ImgSearchDriverImage (

    LPCTSTR DriverName,
    LPTSTR DriverPath,
    UINT DriverPathBufferLength )
{
    HANDLE File;
    UINT SysDirPathLength;

    if (DriverName == NULL)
        return FALSE;

    //
    // Search in `system32\drivers'
    //

    SysDirPathLength = GetSystemDirectory (DriverPath, DriverPathBufferLength );

    if( 0 == SysDirPathLength || SysDirPathLength > DriverPathBufferLength ) {

        //
        // Bad luck - we couldn't read the %windir%\system32 value
        //

        return FALSE;
    }

    _tcscat (DriverPath, TEXT("\\drivers\\"));
    _tcscat (DriverPath, DriverName);

    File = CreateFile (

        DriverPath,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (File != INVALID_HANDLE_VALUE) {

      CloseHandle (File);
      return TRUE;
    }

    //
    // Search in `system32'
    //

    GetSystemDirectory (DriverPath, MAX_PATH);
    _tcscat (DriverPath, TEXT("\\"));
    _tcscat (DriverPath, DriverName);

    File = CreateFile (

        DriverPath,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (File != INVALID_HANDLE_VALUE) {

      CloseHandle (File);
      return TRUE;
    }

    //
    // Nothing found.
    //

    return FALSE;
}



//
// end of module: image.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\modspage.cxx ===
//
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
// module: ModSPage.cxx
// author: DMihai
// created: 01/04/98
//
// Description:
//
//      Modify settings PropertyPage.

#include "stdafx.h"
#include "drvvctrl.hxx"
#include "ModSPage.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// if this is FALSE we will prompt the user when Exit is clicked
//

BOOL g_bSettingsSaved = FALSE;

//
// help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_DRIVERS_LIST,               IDH_DV_SettingsTab_driver_details,
    IDC_VERIFALL_RADIO,             IDH_DV_SettingsTab_verifyall,
    IDC_VERIFSEL_RADIO,             IDH_DV_SettingsTab_verifyselec,
    IDC_NORMAL_VERIF_CHECK,         IDH_DV_SettingsTab_verifytype_sppool,
    IDC_PAGEDC_VERIF_CHECK,         IDH_DV_SettingsTab_verifytype_irql,
    IDC_ALLOCF_VERIF_CHECK,         IDH_DV_SettingsTab_verifytype_resource,
    IDC_POOLT_VERIF_CHECK,          IDH_DV_SettingsTab_verifytype_pooltrack,
    IDC_IO_VERIF_CHECK,             IDH_DV_SettingsTab_verifytype_io,
    IDC_VERIFY_BUTTON,              IDH_DV_SettingsTab_verifybut,
    IDC_DONTVERIFY_BUTTON,          IDH_DV_SettingsTab_noverifybut,
    ID_APPLY_BUTTON,                IDH_DV_SettingsTab_applybut,
    IDC_ADDIT_DRVNAMES_EDIT,        IDH_DV_SettingsTab_verifyaddfield,
    ID_RESETALL_BUTTON,             IDH_DV_SettingsTab_resetallbut,
    ID_PREF_BUTTON,                 IDH_DV_SettingsTab_prefsetbut,
    IDC_MODSETT_IO_SELDRIVERS_RADIO,IDH_DV_SettingsTab_verifytype_io_level1,
    IDC_MODSETT_IO_SYSWIDE_RADIO,   IDH_DV_SettingsTab_verifytype_io_level2,
    0,                              0
};

/////////////////////////////////////////
void __cdecl VrfError ( TCHAR *fmt, ...)
{
    TCHAR strMessage[ 256 ];
    va_list prms;

    if( fmt == NULL )
        return;

    va_start (prms, fmt);

    _vsntprintf ( strMessage, ARRAY_LENGTH( strMessage ), fmt, prms);

    if( g_bCommandLineMode )
    {
        VrfPutTS( strMessage );
    }
    else
    {
        AfxMessageBox( strMessage, MB_OK | MB_ICONSTOP );
    }

    va_end (prms);
}

/////////////////////////////////////////
void
__cdecl
VrfErrorResourceFormat(
    UINT uIdResourceFormat,
    ... )
{
    TCHAR strMessage[ 256 ];
    TCHAR strFormat[ 256 ];
    va_list prms;

    if( GetStringFromResources(
        uIdResourceFormat,
        strFormat,
        ARRAY_LENGTH( strFormat ) ) )
    {
        va_start (prms, uIdResourceFormat);

        _vsntprintf ( strMessage, ARRAY_LENGTH( strMessage ), strFormat, prms);

        if( g_bCommandLineMode )
        {
            VrfPutTS( strMessage );
        }
        else
        {
            AfxMessageBox( strMessage, MB_OK | MB_ICONSTOP );
        }

        va_end (prms);
    }
    else
    {
        ASSERT( FALSE );
    }
}


/////////////////////////////////////////////////////////////////////////////
// CModifSettPage property page

IMPLEMENT_DYNCREATE(CModifSettPage, CPropertyPage)

CModifSettPage::CModifSettPage() : CPropertyPage(CModifSettPage::IDD)
{
    //{{AFX_DATA_INIT(CModifSettPage)
    m_bAllocFCheck = FALSE;
    m_bSpecialPoolCheck = FALSE;
    m_bPagedCCheck = FALSE;
    m_bPoolTCheck = FALSE;
    m_bIoVerifierCheck = FALSE;
    m_nVerifyAllRadio = -1;
    m_strAdditDrivers = _T("");
    //}}AFX_DATA_INIT

    m_nIoVerTypeRadio = 0;

    m_eListState = vrfControlEnabled;
    m_eApplyButtonState = vrfControlDisabled;

    m_bAscendDrvVerifSort = FALSE;
    m_bAscendDrvNameSort = FALSE;
    m_bAscendProviderSort = FALSE;
    m_bAscendVersionSort = FALSE;

    m_nLastColumnClicked = -1;
}

CModifSettPage::~CModifSettPage()
{
}

void CModifSettPage::DoDataExchange(CDataExchange* pDX)
{
//    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CModifSettPage)
    DDX_Control(pDX, IDC_PAGEDC_VERIF_CHECK, m_PagedCCheck);
    DDX_Control(pDX, IDC_NORMAL_VERIF_CHECK, m_SpecialPoolVerifCheck);
    DDX_Control(pDX, IDC_ALLOCF_VERIF_CHECK, m_AllocFCheck);
    DDX_Control(pDX, IDC_POOLT_VERIF_CHECK, m_PoolTCheck);
    DDX_Control(pDX, IDC_IO_VERIF_CHECK, m_IOVerifCheck);
    DDX_Control(pDX, IDC_ADDIT_DRVNAMES_EDIT, m_AdditDrvEdit);
    DDX_Control(pDX, ID_RESETALL_BUTTON, m_ResetAllButton);
    DDX_Control(pDX, IDC_VERIFY_BUTTON, m_VerifyButton);
    DDX_Control(pDX, IDC_DRIVERS_LIST, m_DriversList);
    DDX_Control(pDX, IDC_DONTVERIFY_BUTTON, m_DontVerifButton);
    DDX_Control(pDX, ID_APPLY_BUTTON, m_ApplyButton);
    DDX_Check(pDX, IDC_ALLOCF_VERIF_CHECK, m_bAllocFCheck);
    DDX_Check(pDX, IDC_NORMAL_VERIF_CHECK, m_bSpecialPoolCheck);
    DDX_Check(pDX, IDC_PAGEDC_VERIF_CHECK, m_bPagedCCheck);
    DDX_Check(pDX, IDC_POOLT_VERIF_CHECK, m_bPoolTCheck);
    DDX_Check(pDX, IDC_IO_VERIF_CHECK, m_bIoVerifierCheck);
    DDX_Radio(pDX, IDC_VERIFALL_RADIO, m_nVerifyAllRadio);
    DDX_Radio(pDX, IDC_MODSETT_IO_SELDRIVERS_RADIO, m_nIoVerTypeRadio);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_ADDIT_DRVNAMES_EDIT, m_strAdditDrivers);
    DDV_MaxChars(pDX, m_strAdditDrivers, MI_SUSPECT_DRIVER_BUFFER_LENGTH - 1 );

    if( pDX->m_bSaveAndValidate )
    {
        m_VerifState.AllDriversVerified = ( m_nVerifyAllRadio == 0 );

        m_VerifState.SpecialPoolVerification = m_bSpecialPoolCheck;
        m_VerifState.PagedCodeVerification = m_bPagedCCheck;
        m_VerifState.AllocationFaultInjection = m_bAllocFCheck;
        m_VerifState.PoolTracking = m_bPoolTCheck;
        m_VerifState.IoVerifier = m_bIoVerifierCheck;
        m_VerifState.SysIoVerifierLevel = m_nIoVerTypeRadio + 1;

        _tcscpy( m_VerifState.AdditionalDriverNames,
            (LPCTSTR)m_strAdditDrivers );
    }
}


BEGIN_MESSAGE_MAP(CModifSettPage, CPropertyPage)
    //{{AFX_MSG_MAP(CModifSettPage)
    ON_BN_CLICKED(IDC_VERIFALL_RADIO, OnVerifallRadio)
    ON_BN_CLICKED(IDC_VERIFSEL_RADIO, OnVerifselRadio)
    ON_BN_CLICKED(IDC_ALLOCF_VERIF_CHECK, OnCheck )
    ON_BN_CLICKED(IDC_VERIFY_BUTTON, OnVerifyButton)
    ON_BN_CLICKED(IDC_DONTVERIFY_BUTTON, OnDontverifyButton)
    ON_BN_CLICKED(ID_APPLY_BUTTON, OnApplyButton)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_DRIVERS_LIST, OnColumnclickDriversList)
    ON_EN_CHANGE(IDC_ADDIT_DRVNAMES_EDIT, OnChangeAdditDrvnamesEdit)
    ON_BN_CLICKED(ID_RESETALL_BUTTON, OnResetallButton)
    ON_BN_CLICKED(ID_PREF_BUTTON, OnPrefButton)
    ON_BN_CLICKED(IDC_NORMAL_VERIF_CHECK, OnCheck )
    ON_BN_CLICKED(IDC_PAGEDC_VERIF_CHECK, OnCheck )
    ON_BN_CLICKED(IDC_POOLT_VERIF_CHECK, OnCheck )
    ON_BN_CLICKED(IDC_IO_VERIF_CHECK, OnIoCheck )
    ON_NOTIFY(NM_RCLICK, IDC_DRIVERS_LIST, OnRclickDriversList)
    ON_COMMAND(ID_MODIF_DO_VERIFY, OnDoVerify)
    ON_COMMAND(ID_MODIF_DONT_VERIFY, OnDontVerify)
    ON_BN_CLICKED(IDC_MODSETT_IO_SELDRIVERS_RADIO, OnCheck)
    ON_BN_CLICKED(IDC_MODSETT_IO_SYSWIDE_RADIO, OnCheck)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_MESSAGE( WM_CONTEXTMENU, OnContextMenu )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CModifSettPage implementation

void CModifSettPage::GetDlgDataFromSett()
{
    m_strAdditDrivers = m_VerifState.AdditionalDriverNames;

    // all drivers verified ?
    if( m_VerifState.AllDriversVerified )
    {
        m_nVerifyAllRadio = 0;

        // list state
        m_eListState = vrfControlDisabled;
    }
    else
    {
        m_nVerifyAllRadio = 1;

        // list state
        m_eListState = vrfControlEnabled;
    }

    // SpecialPoolVerification
    m_bSpecialPoolCheck = m_VerifState.SpecialPoolVerification;

    // PagedCodeVerification
    m_bPagedCCheck = m_VerifState.PagedCodeVerification;

    // AllocationFaultInjection
    m_bAllocFCheck = m_VerifState.AllocationFaultInjection;

    // PoolTracking
    m_bPoolTCheck = m_VerifState.PoolTracking;

    // IoVerifier
    m_bIoVerifierCheck = m_VerifState.IoVerifier;

    if( m_bIoVerifierCheck )
    {
        m_eIoRadioState = vrfControlEnabled;
    }
    else
    {
        m_eIoRadioState = vrfControlDisabled;
    }

    // SysIoVerifierLevel
    if( m_VerifState.SysIoVerifierLevel )
    {
        ASSERT( m_bIoVerifierCheck );

        m_nIoVerTypeRadio = m_VerifState.SysIoVerifierLevel - 1;
    }
    else
    {
        m_nIoVerTypeRadio = 0;
    }

    // Apply button state
    m_eApplyButtonState = vrfControlDisabled;
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::UpdateControlsState()
{
    CWnd *pRadioButton;

    EnableControl( m_DriversList, m_eListState );
    EnableControl( m_VerifyButton, m_eListState );
    EnableControl( m_DontVerifButton, m_eListState );
    EnableControl( m_AdditDrvEdit, m_eListState );

    EnableControl( m_ApplyButton, m_eApplyButtonState );

    pRadioButton = GetDlgItem( IDC_MODSETT_IO_SELDRIVERS_RADIO );
    if( pRadioButton != NULL )
    {
        EnableControl( *pRadioButton, m_eIoRadioState );
    }
    else
    {
        ASSERT( FALSE );
    }

    pRadioButton = GetDlgItem( IDC_MODSETT_IO_SYSWIDE_RADIO );
    if( pRadioButton != NULL )
    {
        EnableControl( *pRadioButton, m_eIoRadioState );
    }
    else
    {
        ASSERT( FALSE );
    }
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::EnableControl( CWnd &wndCtrl,
                                   VRF_CONTROL_STATE eNewState )
{
    BOOL bEnabled = wndCtrl.IsWindowEnabled();
    if( bEnabled )
    {
        if( eNewState == vrfControlDisabled )
            wndCtrl.EnableWindow( FALSE );
    }
    else
    {
        if( eNewState == vrfControlEnabled )
            wndCtrl.EnableWindow( TRUE );
    }
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::SetupTheList()
{
    SetupListHeader();
    AddTheListItems();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::SetupListHeader()
{
    CString strDrivers, strStatus, strProvider, strVersion;

    VERIFY( strDrivers.LoadString( IDS_DRIVERS ) );
    VERIFY( strStatus.LoadString( IDS_VERIFICATION_STATUS ) );
    VERIFY( strProvider.LoadString( IDS_PROVIDER ) );
    VERIFY( strVersion.LoadString( IDS_VERSION ) );

    CRect rectWnd;
    m_DriversList.GetClientRect( &rectWnd );

    LVCOLUMN lvColumn;

    // column 0
    memset( &lvColumn, 0, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    lvColumn.iSubItem = 0;
    lvColumn.pszText = strDrivers.GetBuffer( strDrivers.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.17 );
    VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    strDrivers.ReleaseBuffer();

    // column 1
    lvColumn.iSubItem = 1;
    lvColumn.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.34 );
    VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    strStatus.ReleaseBuffer();

    // column 2
    lvColumn.iSubItem = 2;
    lvColumn.pszText = strProvider.GetBuffer( strProvider.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.27 );
    VERIFY( m_DriversList.InsertColumn( 2, &lvColumn ) != -1 );
    strProvider.ReleaseBuffer();

    // column 3
    lvColumn.iSubItem = 3;
    lvColumn.pszText = strVersion.GetBuffer( strVersion.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.19 );
    VERIFY( m_DriversList.InsertColumn( 3, &lvColumn ) != -1 );
    strVersion.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::AddTheListItems()
{
    LVITEM lvItem;
    int nActualIndex;

    VERIFY( m_DriversList.DeleteAllItems() );

    ASSERT( m_VerifState.DriverCount == 0 ||
            ::AfxIsValidAddress(
                m_VerifState.DriverInfo,
                m_VerifState.DriverCount * sizeof( PVRF_DRIVER_STATE ),
                TRUE)
          );

    memset( &lvItem, 0, sizeof( lvItem ) );

    for(UINT uCrtItem = 0; uCrtItem < m_VerifState.DriverCount; uCrtItem++ )
    {
        //
        // sub-item 0
        //

        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.lParam = uCrtItem;
        lvItem.iItem = m_DriversList.GetItemCount();
        lvItem.iSubItem = 0;
        lvItem.pszText = m_VerifState.DriverInfo[ uCrtItem ].Name;
        nActualIndex = m_DriversList.InsertItem( &lvItem );

        if( nActualIndex != -1 )
        {
            //
            // sub-item 1
            //

            UpdateSecondColumn( nActualIndex,
                m_VerifState.DriverInfo[ uCrtItem ].Verified,
                m_VerifState.DriverInfo[ uCrtItem ].CurrentlyVerified );

            //
            // sub-item 2
            //

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = nActualIndex;
            lvItem.iSubItem = 2;
            lvItem.pszText = m_VerifState.DriverInfo[ uCrtItem ].Provider;
            VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );

            //
            // sub-item 3
            //

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = nActualIndex;
            lvItem.iSubItem = 3;
            lvItem.pszText = m_VerifState.DriverInfo[ uCrtItem ].Version;
            VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );
        }
        else
        {
            //
            // cannot add a list item?!?
            //

            ASSERT( FALSE );
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::UpdateSecondColumn( int nItemIndex,
    BOOL bVerifiedAfterBoot, BOOL bVerifiedNow )
{
    LVITEM lvItem;
    CString strValue;

    ASSERT( nItemIndex >= 0 &&
            (UINT)nItemIndex < m_VerifState.DriverCount &&
            nItemIndex < m_DriversList.GetItemCount() );

    // determine what's the status
    if( bVerifiedAfterBoot )
    {
        if( bVerifiedNow )
        {
            VERIFY( strValue.LoadString( IDS_VERIFIED ) );
        }
        else
        {
            VERIFY( strValue.LoadString( IDS_VERIFIED_AFTER_BOOT ) );
        }
    }
    else
    {
        if( bVerifiedNow )
        {
            VERIFY( strValue.LoadString( IDS_NOT_VERIFIED_AFTER_BOOT ) );
        }
        else
        {
            VERIFY( strValue.LoadString( IDS_NOT_VERIFIED ) );
        }
    }

    // update the list item
    memset( &lvItem, 0, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = strValue.GetBuffer( strValue.GetLength() + 1 );
    VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );
    strValue.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////////////////////
int CALLBACK CModifSettPage::DrvVerifCmpFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CModifSettPage *pThis = (CModifSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    // sanity check
    if( uIndex1 > pThis->m_VerifState.DriverCount ||
        uIndex2 > pThis->m_VerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified ==
        pThis->m_VerifState.DriverInfo[ uIndex2 ].Verified )
    {
        // same flag for after boot verified

        if( pThis->m_VerifState.DriverInfo[ uIndex1 ].CurrentlyVerified ==
            pThis->m_VerifState.DriverInfo[ uIndex2 ].CurrentlyVerified )
        {
            // same flag for currently verified

            nCmpRez = _tcsicmp( pThis->m_VerifState.DriverInfo[ uIndex1 ].Name,
                                pThis->m_VerifState.DriverInfo[ uIndex2 ].Name );
        }
        else
        {
            // different flags for currently verified
            if( pThis->m_VerifState.DriverInfo[ uIndex1 ].CurrentlyVerified )
            {
                nCmpRez = 1;
            }
            else
            {
                nCmpRez = -1;
            }
        }
    }
    else
    {
        // different flags for after boot verified

        if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified )
        {
            nCmpRez = 1;
        }
        else
        {
            nCmpRez = -1;
        }
    }

    if( pThis->m_bAscendDrvVerifSort )
        nCmpRez *= -1;

    return nCmpRez;
}

/////////////////////////////////////////////////////////////////////////////
int CALLBACK CModifSettPage::DrvNameCmpFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CModifSettPage *pThis = (CModifSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    // sanity check
    if( uIndex1 > pThis->m_VerifState.DriverCount ||
        uIndex2 > pThis->m_VerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    // compare the names
    nCmpRez = _tcsicmp( pThis->m_VerifState.DriverInfo[ uIndex1 ].Name,
                        pThis->m_VerifState.DriverInfo[ uIndex2 ].Name );
    if( ! nCmpRez )
    {
        // same name ???
        if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified ==
            pThis->m_VerifState.DriverInfo[ uIndex2 ].Verified )
        {
            // same flag
            return 0;
        }
        else
        {
            if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified )
            {
                if( pThis->m_bAscendDrvVerifSort )
                    return 1;
                else
                    return -1;
            }
            else
            {
                if( pThis->m_bAscendDrvVerifSort )
                    return -1;
                else
                    return 1;
            }
        }
    }
    else
    {
        if( pThis->m_bAscendDrvNameSort )
            nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////////////////////
int CALLBACK CModifSettPage::ProviderCmpFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort)
{
    BOOL bNotAvailable1;
    BOOL bNotAvailable2;
    CString strNotAvailable;

    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;

    CModifSettPage *pThis = (CModifSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    //
    // sanity checks
    //

    if( uIndex1 > pThis->m_VerifState.DriverCount ||
        uIndex2 > pThis->m_VerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    //
    // are the strings valid or (Not Available)?
    //

    VERIFY( strNotAvailable.LoadString( IDS_NOT_AVAILABLE ) );

    bNotAvailable1 = ( strNotAvailable.CompareNoCase(
        pThis->m_VerifState.DriverInfo[ uIndex1 ].Provider ) == 0 );

    bNotAvailable2 = ( strNotAvailable.CompareNoCase(
        pThis->m_VerifState.DriverInfo[ uIndex2 ].Provider ) == 0 );

    if( bNotAvailable1 )
    {
        if( bNotAvailable2 )
        {
            return 0;
        }
        else
        {
            if( pThis->m_bAscendProviderSort )
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }
    }
    else
    {
        if( bNotAvailable2 )
        {
            if( pThis->m_bAscendProviderSort )
            {
                return 1;
            }
            else
            {
                return -1;
            }
        }
    }

    //
    // compare the names of the providers
    //

    nCmpRez = _tcsicmp( pThis->m_VerifState.DriverInfo[ uIndex1 ].Provider,
                        pThis->m_VerifState.DriverInfo[ uIndex2 ].Provider );
    if( ! nCmpRez )
    {
        //
        // same name for the provider
        //

        if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified ==
            pThis->m_VerifState.DriverInfo[ uIndex2 ].Verified )
        {
            //
            // same verified flag
            //

            return 0;
        }
        else
        {
            if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified )
            {
                return 1;
            }
            else
            {
                return -1;
            }
        }
    }
    else
    {
        if( pThis->m_bAscendProviderSort )
            nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////////////////////
int CALLBACK CModifSettPage::VersionCmpFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort)
{
    BOOL bNotAvailable1;
    BOOL bNotAvailable2;
    CString strNotAvailable;

    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;

    CModifSettPage *pThis = (CModifSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    //
    // sanity checks
    //

    if( uIndex1 > pThis->m_VerifState.DriverCount ||
        uIndex2 > pThis->m_VerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    //
    // are the strings valid or (Not Available)?
    //

    VERIFY( strNotAvailable.LoadString( IDS_NOT_AVAILABLE ) );

    bNotAvailable1 = ( strNotAvailable.CompareNoCase(
        pThis->m_VerifState.DriverInfo[ uIndex1 ].Version ) == 0 );

    bNotAvailable2 = ( strNotAvailable.CompareNoCase(
        pThis->m_VerifState.DriverInfo[ uIndex2 ].Version ) == 0 );

    if( bNotAvailable1 )
    {
        if( bNotAvailable2 )
        {
            return 0;
        }
        else
        {
            if( pThis->m_bAscendVersionSort )
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }
    }
    else
    {
        if( bNotAvailable2 )
        {
            if( pThis->m_bAscendVersionSort )
            {
                return 1;
            }
            else
            {
                return -1;
            }
        }
    }

    //
    // compare the names of the providers
    //

    nCmpRez = _tcsicmp( pThis->m_VerifState.DriverInfo[ uIndex1 ].Version,
                        pThis->m_VerifState.DriverInfo[ uIndex2 ].Version );
    if( ! nCmpRez )
    {
        //
        // same name for the provider
        //

        if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified ==
            pThis->m_VerifState.DriverInfo[ uIndex2 ].Verified )
        {
            //
            // same verified flag
            //

            return 0;
        }
        else
        {
            if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified )
            {
                return 1;
            }
            else
            {
                return -1;
            }
        }
    }
    else
    {
        if( pThis->m_bAscendVersionSort )
            nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////////////////////
// CModifSettPage message handlers

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnVerifallRadio()
{
    m_eListState = vrfControlDisabled;
    m_eApplyButtonState = vrfControlEnabled;
    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnVerifselRadio()
{
    m_eListState = vrfControlEnabled;
    m_eApplyButtonState = vrfControlEnabled;
    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnIoCheck()
{
    if( m_IOVerifCheck.GetCheck() == 1 )
    {
        m_eIoRadioState = vrfControlEnabled;
    }
    else
    {
        m_eIoRadioState = vrfControlDisabled;
    }

    OnCheck();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnCheck()
{
    m_eApplyButtonState = vrfControlEnabled;
    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::ToggleItemsState( BOOL bVerified )
{
    BOOL bChanged = FALSE;

    if( m_eListState != vrfControlEnabled )
        return;

    int nItems = m_DriversList.GetItemCount();
    for(int nCrtItem = 0; nCrtItem < nItems; nCrtItem++ )
    {
        if( m_DriversList.GetItemState( nCrtItem, LVIS_SELECTED ) &
            LVIS_SELECTED )
        {
            UINT uIndexInArray = (UINT)m_DriversList.GetItemData( nCrtItem );

            if( m_VerifState.DriverInfo[ uIndexInArray ].Verified !=
                bVerified )
            {
                //
                // Toggle its state
                //

                m_VerifState.DriverInfo[ uIndexInArray ].Verified = bVerified;

                if( bVerified )
                {
                    //
                    // Will be verified from now on.
                    // Send a notification about this, in order to detect any miniports.
                    //

                    VrfNotifyDriverSelection( &m_VerifState, uIndexInArray );
                }

                bChanged = TRUE;
            }
        }
    }

    // refill the second column of the list
    for(nCrtItem = 0; nCrtItem < nItems; nCrtItem++ )
    {
        UINT uIndexInArray = (UINT)m_DriversList.GetItemData( nCrtItem );
        UpdateSecondColumn( nCrtItem,
            m_VerifState.DriverInfo[ uIndexInArray ].Verified,
            m_VerifState.DriverInfo[ uIndexInArray ].CurrentlyVerified );
    }

    // some status changed, enable the Apply button
    if( bChanged )
    {
        m_eApplyButtonState = vrfControlEnabled;
        UpdateControlsState();
    }
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnVerifyButton()
{
    ToggleItemsState( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnDontverifyButton()
{
    ToggleItemsState( FALSE );
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnApplyButton()
{
    if( ApplyTheChanges() )
    {
        CWaitCursor WaitCursor;

        g_bSettingsSaved = TRUE;

        VrfGetVerifierState( &m_VerifState );

        GetDlgDataFromSett();

        UpdateData( FALSE );

        AddTheListItems();

        // all updated
        m_eApplyButtonState = vrfControlDisabled;
        UpdateControlsState();

        WaitCursor.Restore();
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CModifSettPage::ApplyTheChanges()
{
	if( UpdateData( TRUE ) )
    {
        // check if we have to clean-up all the registry values
        BOOL bAnythingEnabled = FALSE;

        if( m_VerifState.AllDriversVerified ||
            m_VerifState.SpecialPoolVerification ||
            m_VerifState.PagedCodeVerification ||
            m_VerifState.AllocationFaultInjection ||
            m_VerifState.PoolTracking ||
            m_VerifState.IoVerifier )
        {
            bAnythingEnabled = TRUE;
        }
        else
        {
            for( ULONG uCrtDriver = 0; uCrtDriver < m_VerifState.DriverCount; uCrtDriver++ )
            {
                if( m_VerifState.DriverInfo[ uCrtDriver ].Verified )
                {
                    bAnythingEnabled = TRUE;
                    break;
                }
            }

            if( ! bAnythingEnabled )
            {
                // check if we have some significative characters in Additional... edit
                int nBufferSize = sizeof( m_VerifState.AdditionalDriverNames ) / sizeof( TCHAR );
                for(int nCrtChar = 0; nCrtChar < nBufferSize; nCrtChar++ )
                {
                    if( m_VerifState.AdditionalDriverNames[nCrtChar] == (TCHAR)0 )
                    {
                        // end of string
                        break;
                    }

                    if( m_VerifState.AdditionalDriverNames[nCrtChar] != _T(' ') )
                    {
                        // significant char
                        bAnythingEnabled = TRUE;
                        break;
                    }
                }
            }
        }

        if( bAnythingEnabled )
            return VrfSetVerifierState( &m_VerifState );
        else
            return VrfClearAllVerifierSettings();
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnColumnclickDriversList(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    switch( pNMListView->iSubItem )
    {
    case 0:
        if( m_nLastColumnClicked == pNMListView->iSubItem )
        {
            //
            // change the sort order for this sub-item
            //

            m_bAscendDrvNameSort = !m_bAscendDrvNameSort;
        }

        m_DriversList.SortItems( DrvNameCmpFunc, (LPARAM)this );

        break;

    case 1:
        if( m_nLastColumnClicked == pNMListView->iSubItem )
        {
            //
            // change the sort order for this sub-item
            //
            m_bAscendDrvVerifSort = !m_bAscendDrvVerifSort;
        }

        m_DriversList.SortItems( DrvVerifCmpFunc, (LPARAM)this );

        break;

    case 2:
        if( m_nLastColumnClicked == pNMListView->iSubItem )
        {
            //
            // change the sort order for this sub-item
            //

            m_bAscendProviderSort = !m_bAscendProviderSort;
        }

        m_DriversList.SortItems( ProviderCmpFunc, (LPARAM)this );

        break;

    case 3:
        if( m_nLastColumnClicked == pNMListView->iSubItem )
        {
            //
            // change the sort order for this sub-item
            //

            m_bAscendVersionSort = !m_bAscendVersionSort;
        }

        m_DriversList.SortItems( VersionCmpFunc, (LPARAM)this );

        break;

    default:
        ASSERT( FALSE );
    }	

    //
    // keep the index of the last clicked column
    //

    m_nLastColumnClicked = pNMListView->iSubItem;

    *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnChangeAdditDrvnamesEdit()
{
    // send this notification unless you override the CDialog::OnInitDialog()
    // function and call CRichEditCtrl().SetEventMask()
    // with the ENM_CHANGE flag ORed into the mask.

    // TODO: Add your control notification handler code here
    m_eApplyButtonState = vrfControlEnabled;
    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnResetallButton()
{
    m_VerifState.AllDriversVerified = FALSE;

    m_VerifState.SpecialPoolVerification = FALSE;
    m_VerifState.PagedCodeVerification = FALSE;
    m_VerifState.AllocationFaultInjection = FALSE;
    m_VerifState.PoolTracking = FALSE;
    m_VerifState.IoVerifier = FALSE;

    for(ULONG uCrtDriver = 0; uCrtDriver < m_VerifState.DriverCount;
        uCrtDriver++ )
    {
        m_VerifState.DriverInfo[ uCrtDriver ].Verified = FALSE;
    }

    m_VerifState.AdditionalDriverNames[0] = (TCHAR)0;

    AddTheListItems();
    CheckRadioButton( IDC_VERIFALL_RADIO, IDC_VERIFSEL_RADIO,
        IDC_VERIFSEL_RADIO );

    m_PagedCCheck.SetCheck( 0 );
    m_SpecialPoolVerifCheck.SetCheck( 0 );
    m_AllocFCheck.SetCheck( 0 );
    m_PoolTCheck.SetCheck( 0 );
    m_IOVerifCheck.SetCheck( 0 );
    m_AdditDrvEdit.SetWindowText( _T("") );

    m_eListState = vrfControlEnabled;
    m_eApplyButtonState = vrfControlEnabled;

    m_eIoRadioState = vrfControlDisabled;

    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnPrefButton()
{
    m_VerifState.AllDriversVerified = TRUE;

    m_VerifState.SpecialPoolVerification = TRUE;
    m_VerifState.PagedCodeVerification = TRUE;
    m_VerifState.AllocationFaultInjection = FALSE;
    m_VerifState.PoolTracking = TRUE;
    m_VerifState.IoVerifier = TRUE;
    m_VerifState.SysIoVerifierLevel = 1;

    m_VerifState.AdditionalDriverNames[0] = (TCHAR)0;

    CheckRadioButton( IDC_VERIFALL_RADIO, IDC_VERIFSEL_RADIO,
        IDC_VERIFALL_RADIO );

    m_PagedCCheck.SetCheck( 1 );
    m_SpecialPoolVerifCheck.SetCheck( 1 );
    m_PoolTCheck.SetCheck( 1 );
    m_AllocFCheck.SetCheck( 0 );
    m_IOVerifCheck.SetCheck( 1 );

    m_eListState = vrfControlDisabled;
    m_eApplyButtonState = vrfControlEnabled;

    m_eIoRadioState = vrfControlEnabled;
    CheckRadioButton(
        IDC_MODSETT_IO_SELDRIVERS_RADIO,
        IDC_MODSETT_IO_SYSWIDE_RADIO,
        IDC_MODSETT_IO_SYSWIDE_RADIO );

    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CModifSettPage::OnInitDialog()
{
    //
    // get the current status
    //

    CWaitCursor WaitCursor;

    VrfGetVerifierState( &m_VerifState );

    if( m_VerifState.IoVerifier == TRUE )
    {
        m_eIoRadioState = vrfControlEnabled;
    }
    else
    {
        m_eIoRadioState = vrfControlDisabled;
    }

    GetDlgDataFromSett();

    CPropertyPage::OnInitDialog();

    //
    // the list of drivers
    //

    SetupTheList();

    //
    // sort the list by the driver name
    //

    m_nLastColumnClicked = 0;
    m_DriversList.SortItems( DrvNameCmpFunc, (LPARAM)this );

    //
    // update all controls
    //

    UpdateControlsState();

    WaitCursor.Restore();

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnRclickDriversList(NMHDR* pNMHDR, LRESULT* pResult)
{
    POINT point;
    CMenu theMenu, *pTrackedMenu = NULL;
    BOOL bVerifiedMenu = FALSE, bNotVerifiedMenu = FALSE;

    if( m_eListState != vrfControlEnabled )
        return;

    int nItems = m_DriversList.GetItemCount();
    for(int nCrtItem = 0; nCrtItem < nItems; nCrtItem++ )
    {
        if( m_DriversList.GetItemState( nCrtItem, LVIS_SELECTED ) &
            LVIS_SELECTED )
        {
            UINT uIndexInArray = (UINT)m_DriversList.GetItemData( nCrtItem );

            if( m_VerifState.DriverInfo[ uIndexInArray ].Verified )
            {
                bVerifiedMenu = TRUE;
            }
            else
            {
                bNotVerifiedMenu = TRUE;
            }
        }
    }

    if( bVerifiedMenu && bNotVerifiedMenu )
    {
        VERIFY( theMenu.LoadMenu( IDM_BOTH_VERIFIED_ITEM ) );
    }
    else
    {
        if( bVerifiedMenu )
        {
            VERIFY( theMenu.LoadMenu( IDM_VERIFIED_ITEM ) );
        }
        else
        {
            if( bNotVerifiedMenu )
            {
                VERIFY( theMenu.LoadMenu( IDM_NOT_VERIFIED_ITEM ) );
            }
        }
    }

    pTrackedMenu = theMenu.GetSubMenu( 0 );
    if( pTrackedMenu != NULL )
    {
        ASSERT_VALID( pTrackedMenu );
        VERIFY( ::GetCursorPos( &point ) );
        VERIFY( pTrackedMenu->TrackPopupMenu(
                TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                point.x, point.y,
                this ) );
    }
    else
    {
        ASSERT( FALSE );
    }

      *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnDoVerify()
{
    OnVerifyButton();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnDontVerify()
{
    OnDontverifyButton();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnCancel()
{
    if( g_bSettingsSaved )
    {
        ::AfxMessageBox( IDS_REBOOT, MB_OK | MB_ICONINFORMATION );
    }

    CPropertyPage::OnCancel();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnOK()
{
    if( g_bSettingsSaved )
    {
        ::AfxMessageBox( IDS_REBOOT, MB_OK | MB_ICONINFORMATION );
    }
	
    CPropertyPage::OnOK();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CModifSettPage::OnQueryCancel()
{
    if( m_eApplyButtonState == vrfControlEnabled )
    {
        if( ::AfxMessageBox( IDS_CHANGES_NOT_SAVED,
            MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2 ) == IDNO )
            return FALSE;
    }
	
    return CPropertyPage::OnQueryCancel();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CModifSettPage::OnApply()
{
    return FALSE;
}

/////////////////////////////////////////////////////////////
LONG CModifSettPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        VERIFIER_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////
LONG CModifSettPage::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;

    ::WinHelp( 
        (HWND) wParam,
        VERIFIER_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\stdafx.cxx ===
// stdafx.cpp : source file that includes just the standard includes
//	DrvVCtrl.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\makefile.inc ===
!IF "$(BUILD_ALT_DIR)" == "d"
VERIFIER_BIN_DIR=binD
!ELSE
VERIFIER_BIN_DIR=bin
!ENDIF

copyexe:
    if exist $(_OBJ_DIR)\i386\*.exe copy $(_OBJ_DIR)\i386\*.exe ..\$(VERIFIER_BIN_DIR)\i386
    if exist $(_OBJ_DIR)\i386\*.dll copy $(_OBJ_DIR)\i386\*.exe ..\$(VERIFIER_BIN_DIR)\i386
    if exist $(_OBJ_DIR)\Alpha\*.exe copy $(_OBJ_DIR)\Alpha\*.exe ..\$(VERIFIER_BIN_DIR)\alpha
    if exist $(_OBJ_DIR)\Alpha\*.dll copy $(_OBJ_DIR)\Alpha\*.exe ..\$(VERIFIER_BIN_DIR)\alpha
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__94E2C131_A3FC_11D2_98C6_00A0C9A26FFC__INCLUDED_)
#define AFX_STDAFX_H__94E2C131_A3FC_11D2_98C6_00A0C9A26FFC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
// #include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <Afxdlgs.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__94E2C131_A3FC_11D2_98C6_00A0C9A26FFC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by drvvctrl.rc
//

//////////////////////////////////////////////////////

//
// first icon ID
//

#define ID_ICON_FIRST                   128

//
// first string ID
//

#define ID_STRING_FIRST                 10000

//
// first menu ID
//

#define ID_MENU_FIRST                   0x0010

//
// first dialog ID
//

#define ID_DIALOG_FIRST                 1001

//
// first control ID in a dialog
//

#define ID_CONTROL_FIRST                5000

//////////////////////////////////////////////////////
//
// menu & menu items IDs
//

#define IDM_ABOUTBOX                    16  // ID_MENU_FIRST
#define IDM_VERIFIED_ITEM               17  // ( ID_MENU_FIRST + 1 )
#define IDM_NOT_VERIFIED_ITEM           18  // ( ID_MENU_FIRST + 2 )
#define IDM_BOTH_VERIFIED_ITEM          19  // ( ID_MENU_FIRST + 3 )
#define IDM_ADD_REMOVE_DRIVERS          20  // ( ID_MENU_FIRST + 4 )
#define IDM_ADD_DRIVERS                 21  // ( ID_MENU_FIRST + 5 )

#define ID_MODIF_DO_VERIFY              26  // ( ID_MENU_FIRST + 10 )
#define ID_MODIF_DONT_VERIFY            27  // ( ID_MENU_FIRST + 11 )
#define ID_VOLATILE_ADD_DRIVERS         28  // ( ID_MENU_FIRST + 12 )
#define ID_VOLATILE_REMOVE_DRIVERS      29  // ( ID_MENU_FIRST + 13 )

//////////////////////////////////////////////////////
//
// icon IDs
//

#define IDR_MAINFRAME                   ID_ICON_FIRST

//////////////////////////////////////////////////////
//
// dialog IDs
//

#define IDD_MODIF_PAGE                  1001    // ID_DIALOG_FIRST
#define IDD_GCOUNT_PAGE                 1002    // ( ID_DIALOG_FIRST + 1 )
#define IDD_DRVSTAT_PAGE                1003    // ( ID_DIALOG_FIRST + 2 )
#define IDD_POOLTRACK_PAGE              1004    // ( ID_DIALOG_FIRST + 3 )
#define IDD_VSETTINGS_PAGE              1005    // ( ID_DIALOG_FIRST + 4 )

//
// control IDs for IDD_MODIF_PAGE
//

#define IDC_DRIVERS_LIST                ID_CONTROL_FIRST
#define IDC_VERIFALL_RADIO              ( ID_CONTROL_FIRST + 1 )
#define IDC_VERIFSEL_RADIO              ( ID_CONTROL_FIRST + 2 )
#define IDC_NORMAL_VERIF_CHECK          ( ID_CONTROL_FIRST + 3 )
#define IDC_PAGEDC_VERIF_CHECK          ( ID_CONTROL_FIRST + 4 )
#define IDC_ALLOCF_VERIF_CHECK          ( ID_CONTROL_FIRST + 5 )
#define IDC_POOLT_VERIF_CHECK           ( ID_CONTROL_FIRST + 6 )
#define IDC_IO_VERIF_CHECK              ( ID_CONTROL_FIRST + 7 )
#define IDC_VERIFY_BUTTON               ( ID_CONTROL_FIRST + 8 )
#define IDC_DONTVERIFY_BUTTON           ( ID_CONTROL_FIRST + 9 )
#define ID_APPLY_BUTTON                 ( ID_CONTROL_FIRST + 10 )
#define IDC_ADDIT_DRVNAMES_EDIT         ( ID_CONTROL_FIRST + 11 )
#define ID_RESETALL_BUTTON              ( ID_CONTROL_FIRST + 12 )
#define ID_PREF_BUTTON                  ( ID_CONTROL_FIRST + 13 )
#define IDC_MODSETT_IO_SELDRIVERS_RADIO ( ID_CONTROL_FIRST + 14 )
#define IDC_MODSETT_IO_SYSWIDE_RADIO    ( ID_CONTROL_FIRST + 15 )
//
// control IDs for IDD_GCOUNT_PAGE
//

#define IDC_COUNT_RAISEIRQL_EDIT        ( ID_CONTROL_FIRST + 50 )
#define IDC_COUNT_ACQSPINL_EDIT         ( ID_CONTROL_FIRST + 51 )
#define IDC_COUNT_SYNCREX_EDIT          ( ID_CONTROL_FIRST + 52 )
#define IDC_COUNT_TRIMS_EDIT            ( ID_CONTROL_FIRST + 54 )
#define IDC_COUNT_ALLOC_ATTEMPT_EDIT    ( ID_CONTROL_FIRST + 55 )
#define IDC_COUNT_ALLOC_SUCC_EDIT       ( ID_CONTROL_FIRST + 56 )
#define IDC_COUNT_ALLOCSUCC_SPECPOOL_EDIT ( ID_CONTROL_FIRST + 57 )
#define IDC_COUNT_ALLOC_NOTAG_EDIT      ( ID_CONTROL_FIRST + 58 )
#define IDC_COUNT_ALLOC_FAILED_EDIT     ( ID_CONTROL_FIRST + 59 )
#define IDC_COUNT_ALLOC_FAILEDDEL_EDIT  ( ID_CONTROL_FIRST + 60 )
#define IDC_COUNT_MANUAL_RADIO          ( ID_CONTROL_FIRST + 61 )
#define IDC_COUNT_HSPEED_RADIO          ( ID_CONTROL_FIRST + 62 )
#define IDC_COUNT_NORM_RADIO            ( ID_CONTROL_FIRST + 63 )
#define IDC_COUNT_LOW_RADIO             ( ID_CONTROL_FIRST + 64 )
#define IDC_COUNT_REFRESH_BUTTON        ( ID_CONTROL_FIRST + 65 )

//
// control IDs for IDD_POOLTRACK_PAGE
//

#define IDC_POOLCNT_REFRESH_BUTTON              ( ID_CONTROL_FIRST + 100 )
#define IDC_POOLCNT_MANUAL_RADIO                ( ID_CONTROL_FIRST + 101 )
#define IDC_POOLCNT_HSPEED_RADIO                ( ID_CONTROL_FIRST + 102 )
#define IDC_POOLCNT_NORM_RADIO                  ( ID_CONTROL_FIRST + 103 )
#define IDC_POOLCNT_LOW_RADIO                   ( ID_CONTROL_FIRST + 104 )
#define IDC_POOLCNT_CRT_PPOOL_ALLOC_EDIT        ( ID_CONTROL_FIRST + 105 )
#define IDC_POOLCNT_CRT_NPPOOL_ALLOC_EDIT       ( ID_CONTROL_FIRST + 106 )
#define IDC_POOLCNT_PEAK_PPOOL_ALLOC_EDIT       ( ID_CONTROL_FIRST + 107 )
#define IDC_POOLCNT_PEAK_NPPOOL_ALLOC_EDIT      ( ID_CONTROL_FIRST + 108 )
#define IDC_POOLCNT_UNTRACK_ALLOC_EDIT          ( ID_CONTROL_FIRST + 109 )
#define IDC_POOLCNT_CRT_PPOOL_BYTES_EDIT        ( ID_CONTROL_FIRST + 110 )
#define IDC_POOLCNT_CRT_NPPOOL_BYTES_EDIT       ( ID_CONTROL_FIRST + 111 )
#define IDC_POOLCNT_PEAK_PPOOL_BYTES_EDIT       ( ID_CONTROL_FIRST + 112 )
#define IDC_POOLCNT_PEAK_NPPOOL_BYTES_EDIT      ( ID_CONTROL_FIRST + 113 )
#define IDC_POOLCNT_DRVNAME_COMBO               ( ID_CONTROL_FIRST + 114 )

//
// control IDs for IDD_DRVSTAT_PAGE
//

#define IDC_CRTSTAT_DRIVERS_LIST        ( ID_CONTROL_FIRST + 150 )
#define IDC_CRTSTAT_SPECPOOL_EDIT       ( ID_CONTROL_FIRST + 151 )
#define IDC_CRTSTAT_IRQLCHCK_EDIT       ( ID_CONTROL_FIRST + 152 )
#define IDC_CRTSTAT_FAULTINJ_EDIT       ( ID_CONTROL_FIRST + 153 )
#define IDC_CRTSTAT_POOLT_EDIT          ( ID_CONTROL_FIRST + 154 )
#define IDC_CRTSTAT_IOVERIF_EDIT        ( ID_CONTROL_FIRST + 155 )
#define IDC_CRTSTAT_POOLUSAGE_EDIT      ( ID_CONTROL_FIRST + 156 )
#define IDC_CRTSTAT_REFRESH_BUTTON      ( ID_CONTROL_FIRST + 157 )
#define IDC_CRTSTAT_MANUAL_RADIO        ( ID_CONTROL_FIRST + 158 )
#define IDC_CRTSTAT_HSPEED_RADIO        ( ID_CONTROL_FIRST + 159 )
#define IDC_CRTSTAT_NORM_RADIO          ( ID_CONTROL_FIRST + 160 )
#define IDC_CRTSTAT_LOW_RADIO           ( ID_CONTROL_FIRST + 161 )
#define IDC_CRTSTAT_WARN_MSG            ( ID_CONTROL_FIRST + 162 )


//
// control IDs for IDD_VSETTINGS_PAGE
//

#define IDC_VSETTINGS_REFRESH_BUTTON    ( ID_CONTROL_FIRST + 200 )
#define IDC_VSETTINGS_MANUAL_RADIO      ( ID_CONTROL_FIRST + 201 )
#define IDC_VSETTINGS_HSPEED_RADIO      ( ID_CONTROL_FIRST + 202 )
#define IDC_VSETTINGS_NORM_RADIO        ( ID_CONTROL_FIRST + 203 )
#define IDC_VSETTINGS_LOW_RADIO         ( ID_CONTROL_FIRST + 204 )
#define IDC_VSETTINGS_DRIVERS_LIST      ( ID_CONTROL_FIRST + 205 )
#define IDC_VSETTINGS_NORMAL_VERIF_CHECK    ( ID_CONTROL_FIRST + 206 )
#define IDC_VSETTINGS_PAGEDC_VERIF_CHECK    ( ID_CONTROL_FIRST + 207 )
#define IDC_VSETTINGS_ALLOCF_VERIF_CHECK    ( ID_CONTROL_FIRST + 208 )
#define IDC_VSETTINGS_APPLY_BUTTON      ( ID_CONTROL_FIRST + 209 )
#define IDC_VSETTINGS_WARN_STATIC       ( ID_CONTROL_FIRST + 210 )
#define IDC_VSETTINGS_ADD_BUTTON        ( ID_CONTROL_FIRST + 211 )
#define IDC_VSETTINGS_DONTVERIFY_BUTTON ( ID_CONTROL_FIRST + 212 )

//////////////////////////////////////////////////////
//
// string IDs
//

#define IDS_ABOUTBOX                    ID_STRING_FIRST
#define IDS_DRIVERS                     ( ID_STRING_FIRST + 1 )
#define IDS_STATUS                      ( ID_STRING_FIRST + 2 )
#define IDS_VERIFIED                    ( ID_STRING_FIRST + 3 )
#define IDS_NOT_VERIFIED                ( ID_STRING_FIRST + 4 )
#define IDS_REBOOT                      ( ID_STRING_FIRST + 5 )
#define IDS_APPTITLE                    ( ID_STRING_FIRST + 6 )
#define IDS_ENABLED                     ( ID_STRING_FIRST + 7 )
#define IDS_DISABLED                    ( ID_STRING_FIRST + 8 )
#define IDS_LOADS                       ( ID_STRING_FIRST + 9 )
#define IDS_UNLOADS                     ( ID_STRING_FIRST + 10 )
#define IDS_NEVER_LOADED                ( ID_STRING_FIRST + 11 )
#define IDS_UNLOADED                    ( ID_STRING_FIRST + 12 )
#define IDS_LOADED                      ( ID_STRING_FIRST + 13)
#define IDS_UNKNOWN                     ( ID_STRING_FIRST + 14 )
#define IDS_QUIT                        ( ID_STRING_FIRST + 15 )
#define IDS_CHANGES_NOT_SAVED           ( ID_STRING_FIRST + 16 )
#define IDS_ZERO                        ( ID_STRING_FIRST + 17 )
#define IDS_VERIFIED_AFTER_BOOT         ( ID_STRING_FIRST + 18 )
#define IDS_NOT_VERIFIED_AFTER_BOOT     ( ID_STRING_FIRST + 19 )
#define IDS_FAULT_INJECTION_DISABLED_NOW ( ID_STRING_FIRST + 20 )
#define IDS_BUILD_WARN                  ( ID_STRING_FIRST + 21 )
#define IDS_ACCESS_IS_DENIED            ( ID_STRING_FIRST + 22 )
#define IDS_REGOPENKEYEX_FAILED         ( ID_STRING_FIRST + 23 )
#define IDS_REGDELETEVALUE_FAILED       ( ID_STRING_FIRST + 24 )
#define IDS_QUERY_SYSINFO_FAILED        ( ID_STRING_FIRST + 25 )
#define IDS_REGQUERYVALUEEX_FAILED      ( ID_STRING_FIRST + 26 )
#define IDS_REGQUERYVALUEEX_UNEXP_TYPE  ( ID_STRING_FIRST + 27 )
#define IDS_REGQUERYVALUEEX_UNEXP_SIZE  ( ID_STRING_FIRST + 28 )
#define IDS_REGSETVALUEEX_FAILED        ( ID_STRING_FIRST + 29 )
#define IDS_CANT_GET_ACTIVE_DRVLIST     ( ID_STRING_FIRST + 30 )
#define IDS_CANT_FIND_IMAGE             ( ID_STRING_FIRST + 31 )
#define IDS_INVALID_IMAGE               ( ID_STRING_FIRST + 32 )
#define IDS_CANTGET_VERIF_STATE         ( ID_STRING_FIRST + 33 )
#define IDS_NAME_LOADS_UNLOADS          ( ID_STRING_FIRST + 34 )
#define IDS_NO_DRIVER_VERIFIED          ( ID_STRING_FIRST + 35 )
#define IDS_LEVEL                       ( ID_STRING_FIRST + 36 )
#define IDS_RAISEIRQLS                  ( ID_STRING_FIRST + 37 )
#define IDS_ACQUIRESPINLOCKS            ( ID_STRING_FIRST + 38 )
#define IDS_SYNCHRONIZEEXECUTIONS       ( ID_STRING_FIRST + 39 )
#define IDS_ALLOCATIONSATTEMPTED        ( ID_STRING_FIRST + 40 )
#define IDS_ALLOCATIONSSUCCEEDED        ( ID_STRING_FIRST + 41 )
#define IDS_ALLOCATIONSSUCCEEDEDSPECIALPOOL ( ID_STRING_FIRST + 42 )
#define IDS_ALLOCATIONSWITHNOTAG        ( ID_STRING_FIRST + 43 )
#define IDS_ALLOCATIONSFAILED           ( ID_STRING_FIRST + 44 )
#define IDS_ALLOCATIONSFAILEDDELIBERATELY ( ID_STRING_FIRST + 45 )
#define IDS_TRIMS                       ( ID_STRING_FIRST + 46 )
#define IDS_UNTRACKEDPOOL               ( ID_STRING_FIRST + 47 )
#define IDS_CURRENTPAGEDPOOLALLOCATIONS ( ID_STRING_FIRST + 48 )
#define IDS_CURRENTNONPAGEDPOOLALLOCATIONS ( ID_STRING_FIRST + 49 )
#define IDS_PEAKPAGEDPOOLALLOCATIONS    ( ID_STRING_FIRST + 50 )
#define IDS_PEAKNONPAGEDPOOLALLOCATIONS ( ID_STRING_FIRST + 51 )
#define IDS_PAGEDPOOLUSAGEINBYTES       ( ID_STRING_FIRST + 52 )
#define IDS_NONPAGEDPOOLUSAGEINBYTES    ( ID_STRING_FIRST + 53 )
#define IDS_PEAKPAGEDPOOLUSAGEINBYTES   ( ID_STRING_FIRST + 54 )
#define IDS_PEAKNONPAGEDPOOLUSAGEINBYTES ( ID_STRING_FIRST + 55 )
#define IDS_HELP_CMDLINE_SWITCH         ( ID_STRING_FIRST + 56 )
#define IDS_LOG_CMDLINE_SWITCH          ( ID_STRING_FIRST + 57 )
#define IDS_INTERVAL_CMDLINE_SWITCH     ( ID_STRING_FIRST + 58 )
#define IDS_CANT_APPEND_FILE            ( ID_STRING_FIRST + 59 )
#define IDS_CANT_WRITE_FILE             ( ID_STRING_FIRST + 60 )
#define IDS_QUERY_CMDLINE_SWITCH        ( ID_STRING_FIRST + 61 )
#define IDS_FLAGS_CMDLINE_SWITCH        ( ID_STRING_FIRST + 62 )
#define IDS_ALL_CMDLINE_SWITCH          ( ID_STRING_FIRST + 63 )
#define IDS_DRIVER_CMDLINE_SWITCH       ( ID_STRING_FIRST + 64 )
#define IDS_RESET_CMDLINE_SWITCH        ( ID_STRING_FIRST + 65 )
#define IDS_COVERAGE_WARNING_FORMAT     ( ID_STRING_FIRST + 66 )
#define IDS_THE_VERIFIED_DRIVERS        ( ID_STRING_FIRST + 67 )
#define IDS_DONTREBOOT_CMDLINE_SWITCH   ( ID_STRING_FIRST + 68 )
#define IDS_CANNOT_CHANGE_SETTING_ON_FLY ( ID_STRING_FIRST + 69 )
#define IDS_SAME_FLAGS_AS_ACTIVE        ( ID_STRING_FIRST + 70 )
#define IDS_CANT_CHANGE_SETTINGS_BUILD_OLD ( ID_STRING_FIRST + 71 )
#define IDS_NO_SETTINGS_WERE_CHANGED    ( ID_STRING_FIRST + 72 )
#define IDS_SPECIAL_POOL_ENABLED_NOW    ( ID_STRING_FIRST + 73 )
#define IDS_SPECIAL_POOL_DISABLED_NOW   ( ID_STRING_FIRST + 74 )
#define IDS_FORCE_IRQLCHECK_ENABLED_NOW ( ID_STRING_FIRST + 75 )
#define IDS_FORCE_IRQLCHECK_DISABLED_NOW ( ID_STRING_FIRST + 76 )
#define IDS_FAULT_INJECTION_ENABLED_NOW ( ID_STRING_FIRST + 77 )
#define IDS_POOL_TRACK_ENABLED_NOW      ( ID_STRING_FIRST + 78 )
#define IDS_POOL_TRACK_DISABLED_NOW     ( ID_STRING_FIRST + 79 )
#define IDS_IO_CHECKING_ENABLED_NOW     ( ID_STRING_FIRST + 80 )
#define IDS_IO_CHECKING_DISABLED_NOW    ( ID_STRING_FIRST + 81 )
#define IDS_CHANGES_ACTIVE_ONLY_BEFORE_REBOOT ( ID_STRING_FIRST + 82 )
#define IDS_MUST_SPECIFY_NEW_FLAGS      ( ID_STRING_FIRST + 83 )
#define IDS_CHANGED_SETTINGS_ARE        ( ID_STRING_FIRST + 84 )
#define IDS_REGCREATEKEYEX_FAILED       ( ID_STRING_FIRST + 85 )
#define IDS_VERIFICATION_STATUS         ( ID_STRING_FIRST + 86 )
#define IDS_PROVIDER                    ( ID_STRING_FIRST + 87 )
#define IDS_VERSION                     ( ID_STRING_FIRST + 88 )
#define IDS_NOT_AVAILABLE               ( ID_STRING_FIRST + 89 )
#define IDS_IOLEVEL_CMDLINE_SWITCH      ( ID_STRING_FIRST + 90 )
#define IDS_DYN_REMOVE_NOT_SUPPORTED    ( ID_STRING_FIRST + 91 )
#define IDS_DYN_REMOVE_ALREADY_LOADED   ( ID_STRING_FIRST + 92 ) 
#define IDS_DYN_REMOVE_MISC_ERROR       ( ID_STRING_FIRST + 93 )
#define IDS_DYN_REMOVE_INSUF_RESOURCES  ( ID_STRING_FIRST + 94 )
#define IDS_DYN_REMOVE_ACCESS_DENIED    ( ID_STRING_FIRST + 95 )
#define IDS_DYN_ADD_NOT_SUPPORTED       ( ID_STRING_FIRST + 96 )
#define IDS_DYN_ADD_ALREADY_LOADED      ( ID_STRING_FIRST + 97 )
#define IDS_DYN_ADD_MISC_ERROR          ( ID_STRING_FIRST + 98 )
#define IDS_DYN_ADD_INSUF_RESOURCES     ( ID_STRING_FIRST + 99 )
#define IDS_DYN_ADD_ACCESS_DENIED       ( ID_STRING_FIRST + 100 )
#define IDS_ADDDRIVER_CMDLINE_SWITCH    ( ID_STRING_FIRST + 101 )
#define IDS_REMOVEDRIVER_CMDLINE_SWITCH ( ID_STRING_FIRST + 102 )
#define IDS_CANT_CHANGE_SETTINGS_BUILD_OLD2 ( ID_STRING_FIRST + 103 )
#define IDS_INSUFFICIENT_MEMORY         ( ID_STRING_FIRST + 104 )
#define IDS_TOO_MANY_FILES_SELECTED     ( ID_STRING_FIRST + 105 )
#define IDS_CANNOT_OPEN_FILES           ( ID_STRING_FIRST + 106 )
#define IDS_DYN_ADD_VERIFIED_NOW        ( ID_STRING_FIRST + 107 )
#define IDS_DYN_ADD_NOT_VERIFIED_NOW    ( ID_STRING_FIRST + 108 )
#define IDS_VERIFIER_ADD_NOT_SUPPORTED  ( ID_STRING_FIRST + 109 )
#define IDS_VERIFIER_REMOVE_NOT_SUPPORTED  ( ID_STRING_FIRST + 110 )


#define IDS_HELP_LINE1                  ( ID_STRING_FIRST + 500 )
#define IDS_HELP_LINE3                  ( ID_STRING_FIRST + 501 )
#define IDS_HELP_LINE4                  ( ID_STRING_FIRST + 502 )
#define IDS_HELP_LINE5                  ( ID_STRING_FIRST + 503 )
#define IDS_HELP_LINE6                  ( ID_STRING_FIRST + 504 )
#define IDS_HELP_LINE7                  ( ID_STRING_FIRST + 505 )
#define IDS_HELP_LINE8                  ( ID_STRING_FIRST + 506 )
#define IDS_HELP_LINE9                  ( ID_STRING_FIRST + 507 )
#define IDS_HELP_LINE10                 ( ID_STRING_FIRST + 508 )
#define IDS_HELP_LINE11                 ( ID_STRING_FIRST + 509 )
#define IDS_HELP_LINE12                 ( ID_STRING_FIRST + 510 )
#define IDS_HELP_LINE13                 ( ID_STRING_FIRST + 511 )
#define IDS_HELP_LINE14                 ( ID_STRING_FIRST + 512 )
#define IDS_HELP_LINE15                 ( ID_STRING_FIRST + 513 )
#define IDS_HELP_LINE16                 ( ID_STRING_FIRST + 514 )
#define IDS_HELP_LINE17                 ( ID_STRING_FIRST + 515 )
#define IDS_HELP_LINE18                 ( ID_STRING_FIRST + 516 )
#define IDS_HELP_LINE19                 ( ID_STRING_FIRST + 517 )
#define IDS_HELP_LINE20                 ( ID_STRING_FIRST + 518 )
#define IDS_HELP_LINE21                 ( ID_STRING_FIRST + 519 )
#define IDS_HELP_LINE22                 ( ID_STRING_FIRST + 520 )
#define IDS_HELP_LINE23                 ( ID_STRING_FIRST + 521 )
#define IDS_HELP_LINE24                 ( ID_STRING_FIRST + 522 )
#define IDS_HELP_LINE25                 ( ID_STRING_FIRST + 523 )
#define IDS_HELP_LINE26                 ( ID_STRING_FIRST + 524 )
#define IDS_HELP_LINE27                 ( ID_STRING_FIRST + 525 )
#define IDS_HELP_LINE28                 ( ID_STRING_FIRST + 526 )
#define IDS_HELP_LINE29                 ( ID_STRING_FIRST + 527 )
#define IDS_HELP_LINE30                 ( ID_STRING_FIRST + 528 )
#define IDS_HELP_LINE31                 ( ID_STRING_FIRST + 529 )


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        20000
#define _APS_NEXT_COMMAND_VALUE         30000
#define _APS_NEXT_CONTROL_VALUE         40000
#define _APS_NEXT_SYMED_VALUE           50000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\ascii.h ===
/* $Header: /nw/tony/src/stevie/src/RCS/ascii.h,v 1.2 89/03/11 22:42:03 tony Exp $
 *
 * Definitions of various common control characters
 */

#define NUL     '\0'
#define BS      '\010'
#define TAB     '\011'
#define NL      '\012'
#define CR      '\015'
#define ESC     '\033'

#define CTRL(x) ((x) & 0x1f)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\verify.cxx ===
//
// Driver Verifier Control Applet
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: verify.cxx
// author: silviuc
// created: Mon Jan 04 12:40:57 1999
//



extern "C" {
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
}

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <tchar.h>
#include <windows.h>
#include <time.h>
#include <ntverp.h>
#include <common.ver>

#include "verify.hxx"
#include "image.hxx"
#include "resource.h"

//
// IO verification levels
//

#define IO_VERIFICATION_LEVEL_MAX   3

//
// all the possible verification flags
//

const UINT VerifierAllOptions = (DRIVER_VERIFIER_SPECIAL_POOLING |
                                 DRIVER_VERIFIER_FORCE_IRQL_CHECKING |
                                 DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES |
                                 DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS |
                                 DRIVER_VERIFIER_IO_CHECKING |
                                 DRIVER_VERIFIER_DEADLOCK_DETECTION );

//
// the options that can be modified on the fly
//

const UINT VerifierModifyableOptions = (DRIVER_VERIFIER_SPECIAL_POOLING |
                                 DRIVER_VERIFIER_FORCE_IRQL_CHECKING |
                                 DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES);

//
// system IO verifier values
//

#define SYS_IO_VERIFIER_DISABLED_VALUE  0
#define SYS_IO_VERIFIER_BASE_VALUE   1


//////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////// Global Data
//////////////////////////////////////////////////////////////////////

//
// Command line / GUI
//

BOOL g_bCommandLineMode = FALSE;

//
// OS version and build number information
//

OSVERSIONINFO g_OsVersion;

//
// Was the debug privilege already enabled?
// We need this privilege to set volatile options.
//

BOOL g_bPrivegeEnabled = FALSE;

//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Registry Strings
//////////////////////////////////////////////////////////////////////

LPCTSTR RegMemoryManagementKeyName =
TEXT ("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

LPCTSTR RegVerifyDriversValueName =
TEXT ("VerifyDrivers");

LPCTSTR RegVerifyDriverLevelValueName =
TEXT ("VerifyDriverLevel");

LPCTSTR RegSessionManagerKeyName =
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager");

LPCTSTR RegIOVerifyKeyName =
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager\\I/O System");

LPCTSTR RegIOVerifySubKeyName =
    TEXT ("I/O System");

LPCTSTR RegIOVerifyLevelValueName =
    TEXT ("IoVerifierLevel");

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////// command line support
//////////////////////////////////////////////////////////////////////

void
VrfDumpChangedSettings(

    UINT OldFlags,
    UINT NewFlags );

BOOL
VrfEnableDebugPrivilege (
    );

//////////////////////////////////////////////////////////////////////
/////////////// Forward decl for local registry manipulation functions
//////////////////////////////////////////////////////////////////////

BOOL
ReadRegistryValue (

    HKEY HKey,
    LPCTSTR Name,
    DWORD * Value,
    DWORD DefaultValue);

BOOL
WriteRegistryValue (

    HKEY HKey,
    LPCTSTR Name,
    DWORD Value);

BOOL
ReadMmString (

    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Buffer,
    DWORD BufferSize);

BOOL
WriteMmString (

    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Value);

//////////////////////////////////////////////////////////////////////
/////////////// Forward decl for local sys level IO verifier functions
//////////////////////////////////////////////////////////////////////

BOOL
SetSysIoVerifierSettings(
    ULONG SysIoVerifierLevel );


//////////////////////////////////////////////////////////////////////
/////////////////////// Forward decl for driver manipulation functions
//////////////////////////////////////////////////////////////////////

typedef enum {

    VRF_DRIVER_LOAD_SUCCESS,
    VRF_DRIVER_LOAD_CANNOT_FIND_IMAGE,
    VRF_DRIVER_LOAD_INVALID_IMAGE

} VRF_DRIVER_LOAD_STATUS;


ULONG
GetActiveDriversList (

    PVRF_DRIVER_STATE DriverInfo,
    ULONG MaxNumberOfDrivers);

BOOL
SetVerifiedDriversFromNamesString (

    PVRF_VERIFIER_STATE VrfState );

BOOL
GetVerifiedDriversToString (

    PVRF_VERIFIER_STATE VrfState );

BOOL
SetAllDriversStatus (

    PVRF_VERIFIER_STATE VrfState,
    BOOL Verified);


BOOL
VrfSearchVerifierDriver (

    PVRF_VERIFIER_STATE VrfState,
    LPCTSTR DriverName,
    ULONG & HitIndex);

BOOL
KrnSearchVerifierDriver (

    LPCTSTR DriverName,
    ULONG & HitIndex);

LPCTSTR
IsMiniportDriver (

    LPCTSTR DriverName, VRF_DRIVER_LOAD_STATUS &ErrorCode);

BOOL
VrfGetVersionInfo(
    LPTSTR lptstrFileName,
    LPTSTR lptstrCompany,
    int nCompanyBufferLength,
    LPTSTR lptstrVersion,
    int nVersionBufferLength );

BOOL
ConvertAnsiStringToTcharString (

    LPBYTE Source,
    ULONG SourceLength,
    LPTSTR Destination,
    ULONG DestinationLength);

//
// Support for dynamic set of verified drivers
//

BOOL
VrfVolatileAddOrRemoveDriversCmdLine(

    int nArgsNo,
    LPTSTR szCmdLineArgs[] );


//////////////////////////////////////////////////////////////////////
////////////////////////////////////////// Exported Verifier Functions
//////////////////////////////////////////////////////////////////////

//
// Function:
//
//     VrfGetVerifierState
//
// Description:
//
//     Reads all Mm related registry settings and fills the structure
//     with the appropriate BOOLean values.
//

BOOL
VrfGetVerifierState (

    PVRF_VERIFIER_STATE VrfState)
{
    static KRN_VERIFIER_STATE KrnState;

    HKEY MmKey = NULL;
    HKEY IoKey = NULL;
    LONG Result;
    DWORD Value;
    DWORD IoValue;
    ULONG Index;
    ULONG FoundIndex;

    if (VrfState == NULL) {

        return FALSE;
    }

    //
    // Open the Mm key
    //

    Result = RegOpenKeyEx (

        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE,
        &MmKey);

    if (Result != ERROR_SUCCESS) {

        if( Result == ERROR_ACCESS_DENIED ) {

            VrfErrorResourceFormat ( IDS_ACCESS_IS_DENIED );
        }
        else {

            VrfErrorResourceFormat (
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)Result);
        }

        return FALSE;
    }

    //
    // Set the driver specific information.
    //

    VrfState->DriverNames[ 0 ] = 0;
    VrfState->AdditionalDriverNames[ 0 ] = 0;

    VrfState->DriverCount = GetActiveDriversList (
        VrfState->DriverInfo, ARRAY_LENGTH( VrfState->DriverInfo ) );

    //
    // Read VerifyDriverLevel value
    //

    if (ReadRegistryValue (MmKey, RegVerifyDriverLevelValueName, &Value, 0) == FALSE) {

        RegCloseKey (MmKey);
        return FALSE;
    }

    VrfState->SpecialPoolVerification = (Value & DRIVER_VERIFIER_SPECIAL_POOLING) ? TRUE : FALSE;
    VrfState->PagedCodeVerification = (Value & DRIVER_VERIFIER_FORCE_IRQL_CHECKING) ? TRUE : FALSE;
    VrfState->AllocationFaultInjection = (Value & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES) ? TRUE : FALSE;
    VrfState->PoolTracking = (Value & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS) ? TRUE : FALSE;
    VrfState->IoVerifier = (Value & DRIVER_VERIFIER_IO_CHECKING) ? TRUE : FALSE;

    //
    // the sys level IO verifier can be enabled only if VrfState->IoVerifier == TRUE
    //

    if( VrfState->IoVerifier == TRUE )
    {
        //
        // don't know yet if the sys level IO verifier is enabled
        //

        IoValue = SYS_IO_VERIFIER_DISABLED_VALUE;

        //
        // Open the IO key
        //

        Result = RegOpenKeyEx (

            HKEY_LOCAL_MACHINE,
            RegIOVerifyKeyName,
            0,
            KEY_QUERY_VALUE,
            &IoKey);

        if (Result != ERROR_SUCCESS ) {

            //
            // if Result == ERROR_FILE_NOT_FOUND just use out default value for IoValue
            //

            if( Result != ERROR_FILE_NOT_FOUND ) {

                //
                // the key is there but we cannot read it, fatal error
                //

                if( Result == ERROR_ACCESS_DENIED ) {

                    VrfErrorResourceFormat(
                        IDS_ACCESS_IS_DENIED );
                }
                else {

                    VrfErrorResourceFormat(
                        IDS_REGOPENKEYEX_FAILED,
                        RegIOVerifyKeyName,
                        (DWORD)Result);
                }

                RegCloseKey (MmKey);
                return FALSE;
            }
        }
        else {

            //
            // IO key opened, read the IoVerifierLevel value
            //

            if ( ReadRegistryValue (
                    IoKey,
                    RegIOVerifyLevelValueName,
                    &IoValue,
                    SYS_IO_VERIFIER_DISABLED_VALUE ) == FALSE) {

                RegCloseKey (IoKey);
                RegCloseKey (MmKey);
                return FALSE;
            }

            //
            // done with the IO key
            //

            RegCloseKey (IoKey);
        }
        
        if (IoValue) 
        {
            VrfState->SysIoVerifierLevel = IoValue - SYS_IO_VERIFIER_BASE_VALUE;
        }
        
    }

    //
    // Read VerifyDrivers value
    //

    VrfState->AllDriversVerified = FALSE;

    if (ReadMmString (MmKey, 
            RegVerifyDriversValueName, 
            VrfState->DriverNames, 
            sizeof( VrfState->DriverNames ) ) == FALSE) {

        RegCloseKey (MmKey);
        return FALSE;
    }

    if ( VrfState->DriverNames[ 0 ] == TEXT('*') ) {

        VrfState->AllDriversVerified = TRUE;
        SetAllDriversStatus (VrfState, TRUE);
    }
    else {

        SetVerifiedDriversFromNamesString ( VrfState );
    }

    //
    // Get the kernel verifier state and mark any active drivers
    // as already verified.
    //

    if (KrnGetSystemVerifierState ( &KrnState ) == TRUE) {

        for (Index = 0; Index < KrnState.DriverCount; Index++) {

            if (VrfSearchVerifierDriver (
                VrfState, 
                KrnState.DriverInfo[Index].Name, 
                FoundIndex) == TRUE) {

                VrfState->DriverInfo[FoundIndex].CurrentlyVerified = TRUE;
            }
        }
    }

    //
    // Close the Mm key and return success
    //

    RegCloseKey (MmKey);
    return TRUE;
}


//
// Function:
//
//     VrfSetVerifierState
//
// Description:
//
//     Writes all Mm related registry settings according with
//     the structure.
//

BOOL
VrfSetVerifierState (

    PVRF_VERIFIER_STATE VrfState)
{
    HKEY MmKey = NULL;
    LONG Result;
    DWORD Value;
    size_t StringLength;
    size_t CrtCharIndex;

    //
    // Open the Mm key
    //

    Result = RegOpenKeyEx (

        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_SET_VALUE,
        &MmKey);

    if (Result != ERROR_SUCCESS) {

        if( Result == ERROR_ACCESS_DENIED ) {

            VrfErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else {

            VrfErrorResourceFormat(
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)Result);
        }

        return FALSE;
    }

    //
    // Write VerifyDriverLevel value
    //

    Value = (VrfState->SpecialPoolVerification ? DRIVER_VERIFIER_SPECIAL_POOLING : 0);
    Value |= (VrfState->PagedCodeVerification ? DRIVER_VERIFIER_FORCE_IRQL_CHECKING : 0);
    Value |= (VrfState->AllocationFaultInjection ? DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES : 0);
    Value |= (VrfState->PoolTracking ? DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS : 0);
    Value |= (VrfState->IoVerifier ? DRIVER_VERIFIER_IO_CHECKING : 0);

    if (WriteRegistryValue (MmKey, RegVerifyDriverLevelValueName, Value) == FALSE) {

        RegCloseKey (MmKey);
        return FALSE;
    }

    //
    // enable/disable system level IO verifier
    //   
    if ( VrfState->IoVerifier == FALSE ) 
    {
        VrfState->SysIoVerifierLevel = 0;
    }    

    if( ! SetSysIoVerifierSettings(
        VrfState->SysIoVerifierLevel ) )
    {
        RegCloseKey (MmKey);
        return FALSE;
    }

    //
    // Write VerifyDrivers value
    //

    if (VrfState->AllDriversVerified) {

        if (WriteMmString (MmKey, RegVerifyDriversValueName, TEXT("*")) == FALSE) {

            RegCloseKey (MmKey);
            return FALSE;
        }
    }
    else {

        GetVerifiedDriversToString (
            VrfState );

        //
        // do we have any significant characters in VrfState->DriverNames?
        //

        StringLength = _tcslen( VrfState->DriverNames );

        for( CrtCharIndex = 0; CrtCharIndex < StringLength; CrtCharIndex++ ) {

            if( VrfState->DriverNames[ CrtCharIndex ] != _T( ' ' ) &&
                VrfState->DriverNames[ CrtCharIndex ] != _T( '\t' ) ) {

                break;
            }

        }

        if( CrtCharIndex < StringLength )
        {
            //
            // we have at least one significant character in the string
            //

            if (WriteMmString (MmKey, RegVerifyDriversValueName, VrfState->DriverNames) == FALSE) {

                RegCloseKey (MmKey);
                return FALSE;
            }
        }
        else {

            //
            // no drivers will be verified, erase the driver list from the registry
            //

            Result = RegDeleteValue (MmKey, RegVerifyDriversValueName);

            if (Result != ERROR_SUCCESS && Result != ERROR_FILE_NOT_FOUND) {

                VrfErrorResourceFormat(
                    IDS_REGDELETEVALUE_FAILED,
                    RegVerifyDriversValueName,
                    (DWORD)Result);

                RegCloseKey (MmKey);
                return FALSE;
            }

        }
    }

    //
    // Close the Mm key and return success
    //

    RegCloseKey (MmKey);
    return TRUE;
}


//
// Function:
//
//     VrfSetVolatileFlags
//
// Description:
//
//     This functions modifies verifier options on the fly.
//

BOOL
VrfSetVolatileFlags (

    UINT uNewFlags)
{
    NTSTATUS Status;

    //
    // Just use NtSetSystemInformation to set the flags
    // that can be modified on the fly. Don't write anything to the registry.
    //

    //
    // enable debug privilege
    //

    if( g_bPrivegeEnabled != TRUE )
    {
        g_bPrivegeEnabled = VrfEnableDebugPrivilege();

        if( g_bPrivegeEnabled != TRUE )
        {
            return FALSE;
        }
    }

    //
    // set the new flags
    //

    Status = NtSetSystemInformation(
        SystemVerifierInformation,
        &uNewFlags,
        sizeof( uNewFlags ) );

    if( ! NT_SUCCESS( Status ) )
    {
        if( Status == STATUS_ACCESS_DENIED )
        {
            //
            // access denied
            //

            VrfErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else
        {
            //
            // some other error
            //

            VrfErrorResourceFormat(
                IDS_CANNOT_CHANGE_SETTING_ON_FLY );
        }

        return FALSE;
    }

    return TRUE;
}

//
// Function:
//
//     VrfSetVolatileOptions
//
// Description:
//
//     This functions modifies verifier options on the fly.
//

BOOL
VrfSetVolatileOptions(

    BOOL bSpecialPool,
    BOOL bIrqlChecking,
    BOOL bFaultInjection )
{
    ULONG uNewFlags;

    uNewFlags = 0;

    if( bSpecialPool )
    {
        uNewFlags |= DRIVER_VERIFIER_SPECIAL_POOLING;
    }

    if( bIrqlChecking )
    {
        uNewFlags |= DRIVER_VERIFIER_FORCE_IRQL_CHECKING;
    }

    if( bFaultInjection )
    {
        uNewFlags |= DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES;
    }

    return VrfSetVolatileFlags( uNewFlags );
}


//
// Function:
//
//     VrfClearAllVerifierSettings
//
// Description:
//
//     This functions deletes all registry values that control in one
//     way or another the Driver Verifier.
//

BOOL
VrfClearAllVerifierSettings (

    )
{
    HKEY MmKey = NULL;
    HKEY IoKey = NULL;
    LONG Result;
    LPTSTR ValueName;

    //
    // Open the Mm key
    //

    Result = RegOpenKeyEx (

        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_SET_VALUE,
        &MmKey);

    if (Result != ERROR_SUCCESS) {

        if( Result == ERROR_ACCESS_DENIED ) {

            VrfErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else {

            VrfErrorResourceFormat(
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)Result);
        }

        return FALSE;
    }

    //
    // Delete VerifyDriverLevel value
    //

    ValueName = (LPTSTR)RegVerifyDriverLevelValueName;
    Result = RegDeleteValue (MmKey, ValueName);

    if (Result != ERROR_SUCCESS && Result != ERROR_FILE_NOT_FOUND) {

        VrfErrorResourceFormat(
            IDS_REGDELETEVALUE_FAILED,
            ValueName,
            (DWORD)Result);

        RegCloseKey (MmKey);
        return FALSE;
    }

    //
    // Delete VerifyDrivers value
    //

    ValueName = (LPTSTR)RegVerifyDriversValueName;
    Result = RegDeleteValue (MmKey, ValueName);

    if (Result != ERROR_SUCCESS && Result != ERROR_FILE_NOT_FOUND) {

        VrfErrorResourceFormat(
            IDS_REGDELETEVALUE_FAILED,
            ValueName,
            (DWORD)Result);

        RegCloseKey (MmKey);
        return FALSE;
    }

    //
    // Close the Mm key
    //

    RegCloseKey (MmKey);

    //
    // delete the sys level IO verifier value
    //

    return SetSysIoVerifierSettings( 0 );
}


//
// Function:
//
//     VrfSearchVerifiedDriver
//
// Description:
//
//     This function searches the VerifierState->DriverInfo database for the specified
//     driver. It sets the index if something has been found.
//

BOOL
VrfSearchVerifierDriver (

    PVRF_VERIFIER_STATE VrfState,
    LPCTSTR DriverName,
    ULONG & HitIndex)
{
    ULONG Index;

    ASSERT (DriverName != NULL);

    for (Index = 0; Index < VrfState->DriverCount; Index++) {

        if (_tcsicmp (DriverName, VrfState->DriverInfo[Index].Name) == 0) {

            HitIndex = Index;
            return TRUE;
        }
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////
////////////////////////////////////////// System verifier information
//////////////////////////////////////////////////////////////////////


//
// Function:
//
//     KrnGetSystemVerifierState
//
// Description:
//
//     This function queries the system verifier state using
//     NtQuerysystemInformation().
//

BOOL
KrnGetSystemVerifierState (

    PKRN_VERIFIER_STATE KrnState)
{
    ULONG Index;
    NTSTATUS Status;
    ULONG Length = 0;
    ULONG buffersize;
    PSYSTEM_VERIFIER_INFORMATION VerifierInfo;
    PSYSTEM_VERIFIER_INFORMATION VerifierInfoBase;

    //
    // Sanity checks
    //

    if (KrnState == NULL) {

        return FALSE;
    }

    //
    // Initalize the returned structure and global vars
    // before the search.
    //

    VerifierInfo = NULL;

    KrnState->DriverCount = 0;

    //
    // Try to get the right size for the NtQuery buffer
    //

    buffersize = 1024;

    do {
        VerifierInfo = (PSYSTEM_VERIFIER_INFORMATION)malloc (buffersize);
        if (VerifierInfo == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = NtQuerySystemInformation (SystemVerifierInformation,
                                           VerifierInfo,
                                           buffersize,
                                           &Length);

        if (Status != STATUS_INFO_LENGTH_MISMATCH) {
            break;
        }

        free (VerifierInfo);
        buffersize += 1024;
    } while (1);

    if (! NT_SUCCESS(Status)) {

        VrfErrorResourceFormat(
            IDS_QUERY_SYSINFO_FAILED,
            Status);

        return FALSE;
    }

    //
    // If no info fill out return success but no info.
    //

    if (Length == 0) {

        free (VerifierInfo);
        return TRUE;
    }

    //
    // Fill out the cumulative-driver stuff.
    //

    VerifierInfoBase = VerifierInfo;

    KrnState->Level = VerifierInfo->Level;
    KrnState->SpecialPool = (VerifierInfo->Level & DRIVER_VERIFIER_SPECIAL_POOLING) ? TRUE : FALSE;
    KrnState->IrqlChecking = (VerifierInfo->Level & DRIVER_VERIFIER_FORCE_IRQL_CHECKING) ? TRUE : FALSE;
    KrnState->FaultInjection = (VerifierInfo->Level & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES) ? TRUE : FALSE;
    KrnState->PoolTrack = (VerifierInfo->Level & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS) ? TRUE : FALSE;
    KrnState->IoVerif = (VerifierInfo->Level & DRIVER_VERIFIER_IO_CHECKING) ? TRUE : FALSE;

    KrnState->RaiseIrqls = VerifierInfo->RaiseIrqls;
    KrnState->AcquireSpinLocks = VerifierInfo->AcquireSpinLocks;
    KrnState->SynchronizeExecutions = VerifierInfo->SynchronizeExecutions;
    KrnState->AllocationsAttempted = VerifierInfo->AllocationsAttempted;
    KrnState->AllocationsSucceeded = VerifierInfo->AllocationsSucceeded;
    KrnState->AllocationsSucceededSpecialPool = VerifierInfo->AllocationsSucceededSpecialPool;
    KrnState->AllocationsWithNoTag = VerifierInfo->AllocationsWithNoTag;

    KrnState->Trims = VerifierInfo->Trims;
    KrnState->AllocationsFailed = VerifierInfo->AllocationsFailed;
    KrnState->AllocationsFailedDeliberately = VerifierInfo->AllocationsFailedDeliberately;

    KrnState->UnTrackedPool = VerifierInfo->UnTrackedPool;

    //
    // Fill out the per-driver stuff.
    //

    VerifierInfo = VerifierInfoBase;
    Index = 0;

    do {

        ANSI_STRING Name;
        NTSTATUS Status;

        Status = RtlUnicodeStringToAnsiString (
            & Name,
            & VerifierInfo->DriverName,
            TRUE);

        if (! (NT_SUCCESS(Status))) {

            free (VerifierInfoBase);
            return FALSE;
        }

        ConvertAnsiStringToTcharString (

            (LPBYTE)(Name.Buffer),
            Name.Length,
            KrnState->DriverInfo[Index].Name,
            ARRAY_LENGTH( KrnState->DriverInfo[Index].Name ) - 1 );

        RtlFreeAnsiString (& Name);

        KrnState->DriverInfo[Index].Loads = VerifierInfo->Loads;
        KrnState->DriverInfo[Index].Unloads = VerifierInfo->Unloads;

        KrnState->DriverInfo[Index].CurrentPagedPoolAllocations = VerifierInfo->CurrentPagedPoolAllocations;
        KrnState->DriverInfo[Index].CurrentNonPagedPoolAllocations = VerifierInfo->CurrentNonPagedPoolAllocations;
        KrnState->DriverInfo[Index].PeakPagedPoolAllocations = VerifierInfo->PeakPagedPoolAllocations;
        KrnState->DriverInfo[Index].PeakNonPagedPoolAllocations = VerifierInfo->PeakNonPagedPoolAllocations;

        KrnState->DriverInfo[Index].PagedPoolUsageInBytes = VerifierInfo->PagedPoolUsageInBytes;
        KrnState->DriverInfo[Index].NonPagedPoolUsageInBytes = VerifierInfo->NonPagedPoolUsageInBytes;
        KrnState->DriverInfo[Index].PeakPagedPoolUsageInBytes = VerifierInfo->PeakPagedPoolUsageInBytes;
        KrnState->DriverInfo[Index].PeakNonPagedPoolUsageInBytes = VerifierInfo->PeakNonPagedPoolUsageInBytes;

        KrnState->DriverCount++;
        Index++;

        if (VerifierInfo->NextEntryOffset == 0) {
            break;
        }

        VerifierInfo = (PSYSTEM_VERIFIER_INFORMATION)((PCHAR)VerifierInfo + VerifierInfo->NextEntryOffset);

    } 
    while (1);

    free (VerifierInfoBase);
    return TRUE;
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////// Read/write Mm Registry Values
//////////////////////////////////////////////////////////////////////

BOOL
ReadRegistryValue (

    HKEY HKey,
    LPCTSTR Name,
    DWORD * Value,
    DWORD DefaultValue)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;

    //
    // default value
    //

    *Value = DefaultValue;
    Size = sizeof *Value;

    Result = RegQueryValueEx (

        HKey,
        Name,
        0,
        &Type,
        (LPBYTE)(Value),
        &Size);

    //
    // Deal with a value that is not defined.
    //

    if (Result == ERROR_FILE_NOT_FOUND) {
        *Value = 0;
        return TRUE;
    }

    if (Result != ERROR_SUCCESS) {

        VrfErrorResourceFormat(
            IDS_REGQUERYVALUEEX_FAILED,
            Name,
            (DWORD)Result);

        return FALSE;
    }

    if (Type != REG_DWORD) {

        VrfErrorResourceFormat(
            IDS_REGQUERYVALUEEX_UNEXP_TYPE,
            Name);

        return FALSE;
    }

    if (Size != sizeof *Value) {

        VrfErrorResourceFormat(
            IDS_REGQUERYVALUEEX_UNEXP_SIZE,
            Name);

        return FALSE;
    }

    return TRUE;
}



BOOL
WriteRegistryValue (

    HKEY HKey,
    LPCTSTR Name,
    DWORD Value)
{
    LONG Result;

    Result = RegSetValueEx (

        HKey,
        Name,
        0,
        REG_DWORD,
        (LPBYTE)(&Value),
        sizeof Value);


    if (Result != ERROR_SUCCESS) {

        VrfErrorResourceFormat(
            IDS_REGSETVALUEEX_FAILED,
            Name,
            (DWORD)Result);

        return FALSE;
    }

    return TRUE;
}


BOOL
ReadMmString (

    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Buffer,
    DWORD BufferSize)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;

    //
    // default value
    //

    *Buffer = 0;
    Size = BufferSize;

    Result = RegQueryValueEx (

        MmKey,
        Name,
        0,
        &Type,
        (LPBYTE)(Buffer),
        &Size);

    //
    // Deal with a value that is not defined.
    //

    if (Result == ERROR_FILE_NOT_FOUND) {
        *Buffer = 0;
        return TRUE;
    }

    if (Result != ERROR_SUCCESS) {

        VrfErrorResourceFormat(
            IDS_REGQUERYVALUEEX_FAILED,
            Name,
            (DWORD)Result);

        return FALSE;
    }

    if (Type != REG_SZ) {

        VrfErrorResourceFormat(
            IDS_REGQUERYVALUEEX_UNEXP_TYPE,
            Name);

        return FALSE;
    }

    return TRUE;
}


BOOL
WriteMmString (

    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Value)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;

    Result = RegSetValueEx (

        MmKey,
        Name,
        0,
        REG_SZ,
        (LPBYTE)(Value),
        (_tcslen (Value) + 1) * sizeof (TCHAR));

    if (Result != ERROR_SUCCESS) {

        VrfErrorResourceFormat(
            IDS_REGSETVALUEEX_FAILED,
            Name,
            (DWORD)Result);

        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
BOOL
SetSysIoVerifierSettings(
    ULONG SysIoVerifierLevel )
{
    HKEY IoKey = NULL;
    HKEY SmKey = NULL;
    BOOL IoKeyOpened;
    LONG Result;
    BOOL bSuccess;

    bSuccess = TRUE;

    //
    // Open the "I/O System" key
    //

    IoKeyOpened = FALSE;

    Result = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegIOVerifyKeyName,
        0,
        KEY_QUERY_VALUE | KEY_WRITE,
        &IoKey);

    if( Result != ERROR_SUCCESS ) {

        if( Result == ERROR_FILE_NOT_FOUND ) {

            if( SysIoVerifierLevel != 0 ) {

                //
                // the IO key doesn't exist, try to create it
                //

                //
                // open the "Session Manager" key
                //

                Result = RegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    RegSessionManagerKeyName,
                    0,
                    KEY_QUERY_VALUE | KEY_WRITE,
                    &SmKey);

                if( Result != ERROR_SUCCESS ) {

                    VrfErrorResourceFormat(
                        IDS_REGOPENKEYEX_FAILED,
                        RegSessionManagerKeyName,
                        (DWORD)Result);

                    return FALSE;
                }

                //
                // create the IO key
                //

                Result = RegCreateKeyEx(
                    SmKey,
                    RegIOVerifySubKeyName,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE | KEY_QUERY_VALUE,
                    NULL,
                    &IoKey,
                    NULL );

                if( Result != ERROR_SUCCESS ) {

                    VrfErrorResourceFormat(
                        IDS_REGCREATEKEYEX_FAILED,
                        RegIOVerifyKeyName,
                        (DWORD)Result);

                    RegCloseKey (SmKey);
                    return FALSE;
                }

                //
                // IO key creation successful
                //

                RegCloseKey (SmKey);

                IoKeyOpened = TRUE;
            }

            //
            // else ( SysIoVerifierLevel == 0 )
            // don't need to create the IO key
            //

        }
        else {

            if( Result == ERROR_ACCESS_DENIED ) {

                //
                // access is denied
                //

                VrfErrorResourceFormat(
                    IDS_ACCESS_IS_DENIED );
            }
            else {

                //
                // other error opening the IO key
                //

                VrfErrorResourceFormat(
                    IDS_REGOPENKEYEX_FAILED,
                    RegIOVerifyKeyName,
                    (DWORD)Result);
            }

            return FALSE;
        }
    }
    else {

        IoKeyOpened = TRUE;
    }

    if( SysIoVerifierLevel != 0 ) {

        ASSERT( IoKeyOpened == TRUE );

        //
        // set the key
        //

        bSuccess = WriteRegistryValue(
            IoKey,
            RegIOVerifyLevelValueName,
            SYS_IO_VERIFIER_BASE_VALUE + SysIoVerifierLevel );

        RegCloseKey (IoKey);
    }
    else {

        if( IoKeyOpened == TRUE ) {

            //
            // the IO key exists, delete the value
            //

            Result = RegDeleteValue (IoKey, RegIOVerifyLevelValueName);

            if (Result != ERROR_SUCCESS && Result != ERROR_FILE_NOT_FOUND) {

                VrfErrorResourceFormat(
                    IDS_REGDELETEVALUE_FAILED,
                    RegIOVerifyLevelValueName,
                    (DWORD)Result);

                bSuccess = FALSE;
            }

            RegCloseKey (IoKey);
        }
    }

    return bSuccess;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// Driver Management
//////////////////////////////////////////////////////////////////////

//
// Function:
//
//     GetActiveDriversList
//
// Description:
//
//     This function determines all the drivers that are currently
//     loaded in the system. It will fill the 'DriverInfo' vector
//     with the drivers' names.
//
// Return:
//
//     The number of drivers detected whose names are written in
//     the 'DriverInfo' vector.
//

ULONG
GetActiveDriversList (

    PVRF_DRIVER_STATE DriverInfo,
    ULONG MaxNumberOfDrivers)
{
    LPTSTR Buffer;
    ULONG BufferSize;
    NTSTATUS Status;
    PRTL_PROCESS_MODULES Modules;
    ULONG Index;
    ULONG DriverIndex;
    BOOL bResult;
    TCHAR TcharBuffer [MAX_PATH];

    for (BufferSize = 0x10000; TRUE; BufferSize += 0x1000) {

        Buffer = (LPTSTR) malloc (BufferSize);

        if (Buffer == NULL) {
            return 0;
        }

        Status = NtQuerySystemInformation (

            SystemModuleInformation,
            (PVOID)Buffer,
            BufferSize,
            NULL);

        if (! NT_SUCCESS(Status)) {

            if (Status == STATUS_INFO_LENGTH_MISMATCH) {

                free( Buffer );

                continue;
            }
            else {

                VrfErrorResourceFormat(
                    IDS_CANT_GET_ACTIVE_DRVLIST,
                    Status);

                free (Buffer);
                return 0;
            }
        }
        else {
            break;
        }
    }

    Modules = (PRTL_PROCESS_MODULES)Buffer;

    for (   Index = 0, DriverIndex = 0; 
            Index < Modules->NumberOfModules && DriverIndex < MaxNumberOfDrivers; 
            Index++ ) 
    {

        TCHAR *First, *Last, *Current;

        //
        // Get to work in processing the full path driver.
        //

        ConvertAnsiStringToTcharString (

            Modules->Modules[Index].FullPathName,
            strlen( (const char *)(Modules->Modules[Index].FullPathName) ),
            TcharBuffer,
            ARRAY_LENGTH( TcharBuffer ) - 1 );

        First = TcharBuffer;
        Last = First + _tcslen (TcharBuffer);

        //
        // Filter modules not ending in ".sys"
        //

        if (Last - 4 <= First || _tcsicmp (Last - 4, TEXT(".sys")) != 0)
            continue;

        //
        // Extract the file name from the full path name
        //

        for (Current = Last; Current >= First; Current--) {

            if (*Current == TEXT('\\')) {
                break;
            }
        }

        ZeroMemory (&(DriverInfo[DriverIndex]), sizeof (DriverInfo[DriverIndex]));
        _tcsncpy ((DriverInfo[DriverIndex].Name), Current + 1, 30);

        bResult = VrfGetVersionInfo(
            DriverInfo[DriverIndex].Name,
            DriverInfo[DriverIndex].Provider,
            ARRAY_LENGTH( DriverInfo[DriverIndex].Provider ),
            DriverInfo[DriverIndex].Version,
            ARRAY_LENGTH( DriverInfo[DriverIndex].Version ) );

        if( bResult != TRUE )
        {
            //
            // defaults
            //

            bResult = GetStringFromResources(
                IDS_NOT_AVAILABLE,
                DriverInfo[DriverIndex].Provider,
                ARRAY_LENGTH( DriverInfo[DriverIndex].Provider ) );

            if( bResult != TRUE )
            {
                ASSERT( FALSE );
                DriverInfo[DriverIndex].Provider[ 0 ] = 0;
            }

            bResult = GetStringFromResources(
                IDS_NOT_AVAILABLE,
                DriverInfo[DriverIndex].Version,
                ARRAY_LENGTH( DriverInfo[DriverIndex].Version ) );

            if( bResult != TRUE )
            {
                ASSERT( FALSE );
                DriverInfo[DriverIndex].Version[ 0 ] = 0;
            }
        }

        DriverIndex++;
    }

    free (Buffer);
    return DriverIndex;
}


//
// Function:
//
//     SetVerifiedDriversFromNamesString
//
// Description:
//
//     This function parses the string containing all the 
//     verified drivers as it was read from the  registry, 
//     marks corresponding entries in the DriverInfo array
//     as verified and adds the rest of the driver names to 
//     AdditionalDriverNames.
//

BOOL
SetVerifiedDriversFromNamesString (

    PVRF_VERIFIER_STATE VrfState )
{
    ULONG Index;
    LPTSTR First, Last, Current, End;
    TCHAR Save;

    //
    // Sanity checks
    //

    if ( VrfState == NULL ) {

        return FALSE;
    }

    VrfState->AdditionalDriverNames[0] = 0;
    First = VrfState->DriverNames;
    Last = First + _tcslen (VrfState->DriverNames);

    for (Current = First; Current < Last; Current++) {

        if (*Current == TEXT(' ')
            || *Current == TEXT('\t')
            || *Current == TEXT('\n')) {

            continue;
        }

        //
        // Search for a driver name.
        //

        for (End = Current;
             *End != 0 && *End != TEXT(' ') && *End != TEXT('\n') && *End != TEXT('\t');
             End++) {

            // nothing
        }

        Save = *End;
        *End = 0;

        //
        // Search for the found driver in the VrfState->DriverInfo vector.
        //

        for (Index = 0; Index < VrfState->DriverCount; Index++) {

            if (_tcsicmp (VrfState->DriverInfo[Index].Name, Current) == 0) {

                VrfState->DriverInfo[Index].Verified = TRUE;
                break;
            }
        }

        //
        // Add the driver to the string with unloaded drivers if this is
        // not in the list.
        //

        if (Index == VrfState->DriverCount) {

            if( _tcslen( VrfState->AdditionalDriverNames ) + _tcslen( Current ) >= ARRAY_LENGTH( VrfState->AdditionalDriverNames ) )
            {
                //
                // Cannot strcat to AdditionalDriverNames, overflow 
                //

                return FALSE;
            }

            _tcscat (VrfState->AdditionalDriverNames, Current);
            _tcscat (VrfState->AdditionalDriverNames, TEXT(" "));
        }

        //
        // Restore written character and resume search for the next driver.
        //

        *End = Save;
        Current = End;
    }


    //
    // Now we have to mark miniports as checked in case we get something
    // from the registry string that links against a miniport.
    //

    for (Index = 0; Index < VrfState->DriverCount; Index++) {

        if (VrfState->DriverInfo[Index].Verified == TRUE) {

            VrfNotifyDriverSelection (VrfState, Index);
        }
    }

    //
    // The same check should happen for drivers that appear
    // in the AdditionalDriverNames buffer. These are drivers
    // that are not loaded right now but they still need the miniport
    // check.
    //

    First = VrfState->AdditionalDriverNames;
    Last = First + _tcslen (VrfState->AdditionalDriverNames);

    for (Current = First; Current < Last; Current++) {

        if (*Current == TEXT(' ') || *Current == TEXT('\t') || *Current == TEXT('\n')) {

            continue;
        }

        //
        // Search for a driver name.
        //

        for (End = Current;
             *End != 0 && *End != TEXT(' ') && *End != TEXT('\n') && *End != TEXT('\t');
             End++) {

            // nothing
        }

        Save = *End;
        *End = 0;

        //
        // Find out if there is a miniport linked against this driver.
        //

        {
            LPCTSTR Miniport;
            ULONG FoundIndex;
            VRF_DRIVER_LOAD_STATUS LoadStatus;

            Miniport = IsMiniportDriver (Current, LoadStatus);

            if (Miniport != NULL) {

                if (VrfSearchVerifierDriver (VrfState, Miniport, FoundIndex)) {

                    VrfState->DriverInfo[FoundIndex].Verified = TRUE;
                }
            }
        }

        //
        // Restore written character and resume search for the next driver.
        //

        *End = Save;
        Current = End;
    }

    //
    // Finally return
    //

    return TRUE;
}


//
// Function:
//
//     GetVerifiedDriversToString
//
// Description:
//
//     This function gets the state of settings as they are kept
//     in VrfState->DriverInfo and VrfState->AdditionalDriverNames and 
//     fills VrfState->DriverNames with driver names without duplicates.
//

BOOL
GetVerifiedDriversToString (

    PVRF_VERIFIER_STATE VrfState )
{
    ULONG Index;
    LPTSTR First, Last, Current;
    ULONG NameLength;
    TCHAR *Buffer;

    //
    // Sanity checks
    //

    if (VrfState == NULL) {

        return FALSE;
    }

    Buffer = VrfState->DriverNames;

    First = Buffer;
    Last = First + ARRAY_LENGTH( VrfState->DriverNames );
    Current = First;
    *Current = 0;

    for (Index = 0; Index < VrfState->DriverCount; Index++) {

        if ( VrfState->DriverInfo[Index].Verified ) {

            NameLength = _tcslen (VrfState->DriverInfo[Index].Name);

            if (Current + NameLength + 2 >= Last) {

                //
                // Buffer overflow
                //

                return FALSE;
            }

            _tcscpy (Current, VrfState->DriverInfo[Index].Name);
            Current += NameLength;
            *Current++ = TEXT(' ');
            *Current = 0;
        }
    }

    //
    // Copy the additional drivers at the end of the driver string
    // and avoid duplicates.
    //

    {
        LPTSTR FirstAddtl, CurrentAddtl, LastAddtl, EndAddtl;
        TCHAR SaveAddtl;

        _tcslwr (Buffer);
        _tcslwr (VrfState->AdditionalDriverNames);

        FirstAddtl = VrfState->AdditionalDriverNames;
        LastAddtl = FirstAddtl + _tcslen (VrfState->AdditionalDriverNames);

        for (CurrentAddtl = FirstAddtl; CurrentAddtl < LastAddtl; CurrentAddtl++) {

            if (*CurrentAddtl == TEXT(' ') || *CurrentAddtl == TEXT('\t') || *CurrentAddtl == TEXT('\n')) {

                continue;
            }

            //
            // Search for a driver name.
            //

            for (EndAddtl = CurrentAddtl;
                 *EndAddtl != TEXT('\0') && *EndAddtl != TEXT(' ') && *EndAddtl != TEXT('\n') && *EndAddtl != TEXT('\t');
                 EndAddtl++) {

                // nothing
            }

            SaveAddtl = *EndAddtl;
            *EndAddtl = 0;

            if (_tcsstr (Buffer, CurrentAddtl) == NULL) {

                _tcscat (Buffer, TEXT(" "));
                _tcscat (Buffer, CurrentAddtl);

                //
                // Figure out if we need to add a miniport to the checked
                // drivers string.
                //

                {
                    LPCTSTR MiniportName;
                    VRF_DRIVER_LOAD_STATUS LoadStatus;

                    MiniportName = IsMiniportDriver (CurrentAddtl, LoadStatus);

                    if (MiniportName == NULL && LoadStatus != VRF_DRIVER_LOAD_SUCCESS) {

                        switch (LoadStatus) {

                        case VRF_DRIVER_LOAD_SUCCESS:
                            break;

                        case VRF_DRIVER_LOAD_CANNOT_FIND_IMAGE:

                            VrfErrorResourceFormat(
                                IDS_CANT_FIND_IMAGE,
                                CurrentAddtl);

                            break;

                        case VRF_DRIVER_LOAD_INVALID_IMAGE:

                            VrfErrorResourceFormat(
                                IDS_INVALID_IMAGE,
                                CurrentAddtl);

                            break;

                        default:
                            ASSERT ( FALSE );
                            break;
                        }

                    }
                    else if (MiniportName != NULL && _tcsstr (Buffer, MiniportName) == NULL) {

                        _tcscat (Buffer, TEXT(" "));
                        _tcscat (Buffer, MiniportName);
                    }
                }
            }

            //
            // Restore written character and resume search for the next driver.
            //

            *EndAddtl = SaveAddtl;
            CurrentAddtl = EndAddtl;
        }

    }


    //
    // Finish
    //

    return TRUE;
}


BOOL
SetAllDriversStatus (

    PVRF_VERIFIER_STATE VrfState,
    BOOL Verified)
{
    ULONG Index;

    for (Index = 0; Index < VrfState->DriverCount; Index++) {

        VrfState->DriverInfo[Index].Verified = Verified;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////// Driver selection notification
//////////////////////////////////////////////////////////////////////


LPTSTR Miniport [] = {

    TEXT ("videoprt.sys"),
    TEXT ("scsiport.sys"),
    NULL
};


LPCTSTR
IsMiniportDriver (

    LPCTSTR DriverName,
    VRF_DRIVER_LOAD_STATUS &ErrorCode)
{
    IMAGE_BROWSE_INFO Info;
    TCHAR DriverPath [MAX_PATH];
    ULONG Index;
    BOOL TryAgain = FALSE;


    ErrorCode = VRF_DRIVER_LOAD_SUCCESS;

    //
    // Search for the driver image.
    //

    if (ImgSearchDriverImage (DriverName, DriverPath, ARRAY_LENGTH( DriverPath ) ) == FALSE) {

        ErrorCode = VRF_DRIVER_LOAD_CANNOT_FIND_IMAGE;
        return NULL;
    }

    //
    // Parse the image
    //

    if (ImgInitializeBrowseInfo (DriverPath, &Info) == FALSE) {

        ImgDeleteBrowseInfo (& Info);
        ErrorCode = VRF_DRIVER_LOAD_INVALID_IMAGE;
        return NULL;
    }

    //
    // Iterate import modules
    //

    {
        PIMAGE_IMPORT_DESCRIPTOR CurrentDescriptor;

        CurrentDescriptor = Info.ImportDescriptor;

        while (CurrentDescriptor->Characteristics) {

            for (Index = 0; Miniport[Index]; Index++) {

                //
                // We need to apply an address correction to the descriptor name
                // because the address in an RVA for the loaded image not for the
                // file layout.
                //

                {
                    TCHAR NameBuffer [MAX_PATH];

                    ConvertAnsiStringToTcharString (
                        (LPBYTE)(CurrentDescriptor->Name + Info.AddressCorrection),
                        strlen( (const char *)( CurrentDescriptor->Name + Info.AddressCorrection ) ),
                        NameBuffer,
                        ARRAY_LENGTH( NameBuffer ) - 1 );

                    if (_tcsicmp (NameBuffer, Miniport[Index]) == 0) {

                        ImgDeleteBrowseInfo (& Info);
                        return Miniport[Index];
                    }
                }
            }

            CurrentDescriptor++;
        }
    }

    ImgDeleteBrowseInfo (& Info);
    return NULL;
}


//
// Function:
//
//     VrfNotifyDriverSelection
//
// Description:
//
//     This function is called from GUI part when a driver is
//     selected. In case the driver is linked against a miniport
//     driver we have to automatically add to the verified
//     drivers list the specific miniport.
//
// Return:
//
//     TRUE if an additional driver has been marked selected
//     due to indirect linking. FALSE if no change has been
//     made.
//

BOOL
VrfNotifyDriverSelection (

    PVRF_VERIFIER_STATE VerifierState,
    ULONG Index)
{
    LPCTSTR MiniportName;
    ULONG FoundIndex;
    VRF_DRIVER_LOAD_STATUS LoadStatus;

    //
    // Sanity checks
    //

    if ( Index >= VerifierState->DriverCount ) {

        return FALSE;
    }

    //
    // If this is a driver that links against a miniport as
    // opposed to ntoskrnl we should add the miniport to the
    // verified list.
    //

    try {

        MiniportName = IsMiniportDriver (

            VerifierState->DriverInfo[Index].Name,
            LoadStatus);

        switch (LoadStatus) {

        case VRF_DRIVER_LOAD_SUCCESS:
            break;

        case VRF_DRIVER_LOAD_CANNOT_FIND_IMAGE:

            VrfErrorResourceFormat(
                IDS_CANT_FIND_IMAGE,
                VerifierState->DriverInfo[Index].Name);

            break;

        case VRF_DRIVER_LOAD_INVALID_IMAGE:

            VrfErrorResourceFormat(
                IDS_INVALID_IMAGE,
                VerifierState->DriverInfo[Index].Name);

            break;

        default:
            ASSERT ( FALSE );
            break;
        }

    } catch (...) {

        //
        // Protect against a blunder in the image parsing code
        //

        VrfErrorResourceFormat(
            IDS_INVALID_IMAGE,
            VerifierState->DriverInfo[Index].Name);

        return FALSE;
    }

    if (MiniportName != NULL) {

        if (VrfSearchVerifierDriver (VerifierState, MiniportName, FoundIndex) == FALSE) {

            return FALSE;
        }

        VerifierState->DriverInfo[FoundIndex].Verified = TRUE;
        return TRUE;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////
BOOL
VrfGetVersionInfo(
    LPTSTR lptstrFileName,
    LPTSTR lptstrCompany,
    int nCompanyBufferLength,
    LPTSTR lptstrVersion,
    int nVersionBufferLength )
{
    DWORD dwWholeBlockSize;
    DWORD dwDummyHandle;
    UINT uInfoLengthInTChars;
    LPVOID lpWholeVerBlock;
    LPVOID lpTranslationInfoBuffer;
    LPVOID lpVersionString;
    LPVOID lpCompanyString;
    BOOL bResult;
    TCHAR strLocale[ 32 ];
    TCHAR strBlockName[ 64 ];
    TCHAR strDriverPath[ MAX_PATH ];

    //
    // sanity checks
    //

    if( lptstrFileName == NULL ||
        lptstrCompany == NULL || nCompanyBufferLength <= 0 ||
        lptstrVersion == NULL || nVersionBufferLength <= 0 )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    //
    // get the full driver path
    //

    bResult = ImgSearchDriverImage(
        lptstrFileName,
        strDriverPath,
        ARRAY_LENGTH( strDriverPath ) );

    if( bResult != TRUE )
    {
        return FALSE;
    }

    //
    // get the size of the file info block
    //

    dwWholeBlockSize = GetFileVersionInfoSize(
        strDriverPath,
        &dwDummyHandle );

    if( dwWholeBlockSize == 0 )
    {
        return FALSE;
    }

    //
    // allocate the buffer for the version information
    //

    lpWholeVerBlock = malloc( dwWholeBlockSize );

    if( lpWholeVerBlock == NULL )
    {
        return FALSE;
    }

    //
    // get the version information
    //

    bResult = GetFileVersionInfo(
        strDriverPath,
        dwDummyHandle,
        dwWholeBlockSize,
        lpWholeVerBlock );

    if( bResult != TRUE )
    {
        free( lpWholeVerBlock );

        return FALSE;
    }

    //
    // get the locale info
    //

    bResult = VerQueryValue(
        lpWholeVerBlock,
        _T( "\\VarFileInfo\\Translation" ),
        &lpTranslationInfoBuffer,
        &uInfoLengthInTChars );

    if( bResult != TRUE || lpTranslationInfoBuffer == NULL )
    {
        free( lpWholeVerBlock );

        return FALSE;
    }

    //
    // Locale info comes back as two little endian words.
    // Flip 'em, 'cause we need them big endian for our calls.
    //

    _stprintf(
        strLocale,
        _T( "%02X%02X%02X%02X" ),
		HIBYTE( LOWORD ( * (LPDWORD) lpTranslationInfoBuffer) ),
		LOBYTE( LOWORD ( * (LPDWORD) lpTranslationInfoBuffer) ),
		HIBYTE( HIWORD ( * (LPDWORD) lpTranslationInfoBuffer) ),
		LOBYTE( HIWORD ( * (LPDWORD) lpTranslationInfoBuffer) ) );

    //
    // get the file version
    //

    _stprintf(
        strBlockName,
        _T( "\\StringFileInfo\\%s\\FileVersion" ),
        strLocale );

    bResult = VerQueryValue(
        lpWholeVerBlock,
        strBlockName,
        &lpVersionString,
        &uInfoLengthInTChars );

    if( bResult != TRUE )
    {
        free( lpWholeVerBlock );

        return FALSE;
    }

    if( uInfoLengthInTChars > (UINT)nVersionBufferLength )
    {
        uInfoLengthInTChars = (UINT)nVersionBufferLength;
    }

    if( uInfoLengthInTChars == 0 )
    {
        *lptstrVersion = 0;
    }
    else
    {
        MoveMemory(
            lptstrVersion,
            lpVersionString,
            uInfoLengthInTChars * sizeof( TCHAR ) );

        //
        // we need to zero terminate the string for above case
        // uInfoLengthInTChars > (UINT)nVersionBufferLength
        //

        lptstrVersion[ uInfoLengthInTChars - 1 ] = 0;
    }

    //
    // get the company name
    //

    _stprintf(
        strBlockName,
        _T( "\\StringFileInfo\\%s\\CompanyName" ),
        strLocale );

    bResult = VerQueryValue(
        lpWholeVerBlock,
        strBlockName,
        &lpCompanyString,
        &uInfoLengthInTChars );

    if( bResult != TRUE )
    {
        free( lpWholeVerBlock );

        return FALSE;
    }

    if( uInfoLengthInTChars > (UINT)nCompanyBufferLength )
    {
        uInfoLengthInTChars = (UINT)nCompanyBufferLength;
    }

    if( uInfoLengthInTChars == 0 )
    {
        *lptstrCompany = 0;
    }
    else
    {
        MoveMemory(
            lptstrCompany,
            lpCompanyString,
            uInfoLengthInTChars * sizeof( TCHAR ) );

        //
        // we need to zero terminate the string for above case
        // uInfoLengthInTChars > (UINT)nCompanyBufferLength
        //

        lptstrCompany[ uInfoLengthInTChars - 1 ] = 0;
    }

    //
    // clean-up
    //

    free( lpWholeVerBlock );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// String conversion
//////////////////////////////////////////////////////////////////////

//
// Function:
//
//     ConvertAnsiStringToTcharString
//
// Description:
//
//     This function converts an ANSI string to a TCHAR string,
//     that is ANSO or UNICODE.
//
//     The function is needed because the system returns the active
//     modules as ANSI strings.
//

BOOL
ConvertAnsiStringToTcharString (

    LPBYTE Source,
    ULONG SourceLength,
    LPTSTR Destination,
    ULONG DestinationLength)
{
    int nCharsConverted;
    int nBytesToTranslate;

    nBytesToTranslate = (int)( (SourceLength < DestinationLength) ? SourceLength : DestinationLength ) * sizeof( char );

    nCharsConverted = MultiByteToWideChar(
        CP_ACP,
        MB_ERR_INVALID_CHARS,
        (LPCSTR)Source,
        nBytesToTranslate,
        Destination,
        DestinationLength );

    ASSERT( nBytesToTranslate == nCharsConverted );

    if( nCharsConverted > 0 )
    {
        Destination[ nCharsConverted ] = 0;

        CharLower( Destination );
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////
////////////////////////////////////////////// Command-line processing
//////////////////////////////////////////////////////////////////////

BOOL
VrfDumpStateToFile(
    FILE *file,
    BOOL bConvertToOEM
)
{
    static KRN_VERIFIER_STATE KrnState;

    UINT Index;
    SYSTEMTIME SystemTime;
    TCHAR strLocalTime[ 64 ];
    TCHAR strLocalDate[ 64 ];


    if( file == NULL )
        return FALSE;

    //
    // output the date&time in the current user format
    //

    GetLocalTime( &SystemTime );

    if( GetDateFormat(
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        NULL,
        strLocalDate,
        ARRAY_LENGTH( strLocalDate ) ) )
    {
        VrfFTPrintf(
            bConvertToOEM,
            file,
            _T( "%s, " ),
            strLocalDate );
    }
    else
    {
        ASSERT( FALSE );
    }

    if( GetTimeFormat(
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        NULL,
        strLocalTime,
        ARRAY_LENGTH( strLocalTime ) ) )
    {
        VrfFTPrintf(
            bConvertToOEM,
            file,
            _T( "%s\n" ),
            strLocalTime);
    }
    else
    {
        ASSERT( FALSE );

        VrfFTPrintf(
            bConvertToOEM,
            file,
            _T( "\n" ) );
    }

    //
    // get the current verifier statistics
    //

    if (KrnGetSystemVerifierState (& KrnState) == FALSE) {

       VrfOuputStringFromResources(
            IDS_CANTGET_VERIF_STATE,
            bConvertToOEM,
            file );

        return FALSE;
    }

    if (KrnState.DriverCount == 0) {

        //
        // no statistics to dump
        //

        return VrfOuputStringFromResources(
            IDS_NO_DRIVER_VERIFIED,
            bConvertToOEM,
            file );
    }
    else {

        //
        // dump the counters
        //

        //
        // global counters
        //

        if( ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_LEVEL, KrnState.Level ) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_RAISEIRQLS, KrnState.RaiseIrqls ) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ACQUIRESPINLOCKS, KrnState.AcquireSpinLocks ) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_SYNCHRONIZEEXECUTIONS, KrnState.SynchronizeExecutions) ) ||

            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ALLOCATIONSATTEMPTED, KrnState.AllocationsAttempted) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ALLOCATIONSSUCCEEDED, KrnState.AllocationsSucceeded) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ALLOCATIONSSUCCEEDEDSPECIALPOOL, KrnState.AllocationsSucceededSpecialPool) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ALLOCATIONSWITHNOTAG, KrnState.AllocationsWithNoTag) ) ||

            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ALLOCATIONSFAILED, KrnState.AllocationsFailed) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ALLOCATIONSFAILEDDELIBERATELY, KrnState.AllocationsFailedDeliberately) ) ||

            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_TRIMS, KrnState.Trims) ) ||

            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_UNTRACKEDPOOL, KrnState.UnTrackedPool) ) )
        {

            return FALSE;
        }

        //
        // per driver counters
        //

        if( ! VrfOuputStringFromResources(
            IDS_THE_VERIFIED_DRIVERS,
            bConvertToOEM,
            file ) )
        {
            return FALSE;
        }

        for ( Index = 0; Index < KrnState.DriverCount; Index++) {

            VrfFTPrintf(
                bConvertToOEM,
                file,
                _T( "\n" ) );

            if( VrfFTPrintfResourceFormat(
                    bConvertToOEM,
                    file,
                    IDS_NAME_LOADS_UNLOADS,
                    KrnState.DriverInfo[Index].Name,
                    KrnState.DriverInfo[Index].Loads,
                    KrnState.DriverInfo[Index].Unloads) == FALSE )
            {
                return FALSE;
            }

            //
            // pool statistics
            //

            if( ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_CURRENTPAGEDPOOLALLOCATIONS, KrnState.DriverInfo[Index].CurrentPagedPoolAllocations) ) ||
                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_CURRENTNONPAGEDPOOLALLOCATIONS, KrnState.DriverInfo[Index].CurrentNonPagedPoolAllocations) ) ||
                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_PEAKPAGEDPOOLALLOCATIONS, KrnState.DriverInfo[Index].PeakPagedPoolAllocations) ) ||
                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_PEAKNONPAGEDPOOLALLOCATIONS, KrnState.DriverInfo[Index].PeakNonPagedPoolAllocations) ) ||

                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_PAGEDPOOLUSAGEINBYTES, (ULONG) KrnState.DriverInfo[Index].PagedPoolUsageInBytes) ) ||
                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_NONPAGEDPOOLUSAGEINBYTES, (ULONG) KrnState.DriverInfo[Index].NonPagedPoolUsageInBytes) ) ||
                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_PEAKPAGEDPOOLUSAGEINBYTES, (ULONG) KrnState.DriverInfo[Index].PeakPagedPoolUsageInBytes) ) ||
                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_PEAKNONPAGEDPOOLUSAGEINBYTES, (ULONG) KrnState.DriverInfo[Index].PeakNonPagedPoolUsageInBytes) ) )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
void
PrintHelpInformation()
{
    VrfTPrintfResourceFormat( IDS_HELP_LINE1, VER_PRODUCTVERSION_STR );

    VrfPrintNarrowStringOEMFormat( VER_LEGALCOPYRIGHT_STR );

    VrfPrintStringFromResources( IDS_HELP_LINE3 );
    VrfPrintStringFromResources( IDS_HELP_LINE4 );
    VrfPrintStringFromResources( IDS_HELP_LINE5 );
    VrfPrintStringFromResources( IDS_HELP_LINE6 );
    VrfPrintStringFromResources( IDS_HELP_LINE7 );
    VrfPrintStringFromResources( IDS_HELP_LINE8 );
    VrfPrintStringFromResources( IDS_HELP_LINE9 );
    VrfPrintStringFromResources( IDS_HELP_LINE10 );
    VrfPrintStringFromResources( IDS_HELP_LINE11 );
    VrfPrintStringFromResources( IDS_HELP_LINE12 );
    VrfPrintStringFromResources( IDS_HELP_LINE13 );
    VrfPrintStringFromResources( IDS_HELP_LINE14 );
    VrfPrintStringFromResources( IDS_HELP_LINE15 );
    VrfPrintStringFromResources( IDS_HELP_LINE16 );
    VrfPrintStringFromResources( IDS_HELP_LINE17 );
    VrfPrintStringFromResources( IDS_HELP_LINE18 );
    VrfPrintStringFromResources( IDS_HELP_LINE19 );
    VrfPrintStringFromResources( IDS_HELP_LINE20 );
    VrfPrintStringFromResources( IDS_HELP_LINE21 );
    VrfPrintStringFromResources( IDS_HELP_LINE22 );
    VrfPrintStringFromResources( IDS_HELP_LINE23 );
    VrfPrintStringFromResources( IDS_HELP_LINE24 );
    VrfPrintStringFromResources( IDS_HELP_LINE25 );
    VrfPrintStringFromResources( IDS_HELP_LINE26 );
    VrfPrintStringFromResources( IDS_HELP_LINE27 );
    VrfPrintStringFromResources( IDS_HELP_LINE28 );
    VrfPrintStringFromResources( IDS_HELP_LINE29 );
    VrfPrintStringFromResources( IDS_HELP_LINE30 );
    VrfPrintStringFromResources( IDS_HELP_LINE31 );
}

//////////////////////////////////////////////////////////////////////
DWORD
VrfExecuteCommandLine (

    int Count,
    LPTSTR Args[])
{
    static KRN_VERIFIER_STATE KrnState;

    ULONG Flags;
    ULONG IoLevel;
    int Index;
    UINT LoadStringResult;
    VRF_DRIVER_LOAD_STATUS LoadStatus;
    BOOL CreateLog;
    LPTSTR LogFileName;
    DWORD LogInterval;
    FILE *file;
    BOOL bFlagsSpecified = FALSE;
    BOOL bIoLevelSpecified = FALSE;
    BOOL bNamesSpecified = FALSE;
    BOOL bVolatileSpecified = FALSE;
    TCHAR strDriver[ 64 ];
    DWORD nReturnValue;
    NTSTATUS Status;
    BOOL bResult;
    BOOL bIoVerifierEnabled;
    ULONG SysIoVerifierLevel;
    TCHAR Names [4196];
    TCHAR OldNames [4196];
    TCHAR strCmdLineOption[ 128 ];
    TCHAR WarningBuffer [256];

    g_bCommandLineMode = TRUE;
    nReturnValue = EXIT_CODE_SUCCESS;

    ASSERT (Count != 0);

    Flags = 1;
    Names[0] = 0;

    //
    // Search for help
    //

    if( GetStringFromResources(
        IDS_HELP_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        if (Count == 2 && _tcsicmp (Args[1], strCmdLineOption) == 0)
        {
            PrintHelpInformation();

            return nReturnValue;
        }
    }

    //
    // Figure out if we are on a valid build for the
    // driver verifier functionality.
    //

    if (g_OsVersion.dwMajorVersion < 5 || g_OsVersion.dwBuildNumber < 1954) {

        //
        // Right now we do not do anything if we do not have the right build.
        //

        VrfPrintStringFromResources( IDS_BUILD_WARN );

        return nReturnValue;
    }

    //
    // Search for /reset
    //

    if( GetStringFromResources(
        IDS_RESET_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        if (Count == 2 && _tcsicmp (Args[1], strCmdLineOption) == 0)
        {
            if( VrfClearAllVerifierSettings() )
            {
                return EXIT_CODE_REBOOT_NEEDED;
            }
            else
            {
                return EXIT_CODE_ERROR;
            }
        }
    }

    //
    // Search for /log
    //

    CreateLog = FALSE;

    if( GetStringFromResources(
        IDS_LOG_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {

        for (Index = 1; Index < Count - 1; Index++)
        {
            if (_tcsicmp (Args[Index], strCmdLineOption ) == 0)
            {
                CreateLog = TRUE;

                LogFileName = Args[Index + 1];

                break;
            }
        }
    }

    if( CreateLog )
    {
        //
        // Default Value
        //

        LogInterval = 30000; // 30 sec

        //
        // Search for /interval
        //

        if( GetStringFromResources(
            IDS_INTERVAL_CMDLINE_SWITCH,
            strCmdLineOption,
            ARRAY_LENGTH( strCmdLineOption ) ) )
        {
            for (Index = 1; Index < Count - 1; Index++)
            {
                if (_tcsicmp (Args[Index], strCmdLineOption) == 0)
                {
                    LogInterval = _ttoi (Args[Index + 1]) * 1000;

                    if( LogInterval == 0 )
                    {
                        LogInterval = 30000; // 30 sec
                    }
                }
            }
        }

        //
        // Infinite loop
        //

        while( TRUE )
        {
            //
            // Open the file
            //

            file = _tfopen( LogFileName, TEXT("a+") );

            if( file == NULL )
            {
                //
                // print a error message
                //

                VrfTPrintfResourceFormat(
                    IDS_CANT_APPEND_FILE,
                    LogFileName );

                break;
            }

            //
            // Dump current information
            //

            if( ! VrfDumpStateToFile ( file, FALSE ) ) {

                //
                // Insufficient disk space ?
                //

                VrfTPrintfResourceFormat(
                    IDS_CANT_WRITE_FILE,
                    LogFileName );
            }

            fflush( file );

            VrfFTPrintf(
                FALSE,
                file,
                TEXT("\n\n") );

            //
            // Close the file
            //

            fclose( file );

            //
            // Sleep
            //

            Sleep( LogInterval );
        }

        return nReturnValue;
    }

    //
    // Search for /query
    //

    if( GetStringFromResources(
        IDS_QUERY_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        if (Count == 2 && _tcsicmp (Args[1], strCmdLineOption) == 0)
        {
            VrfDumpStateToFile ( stdout, TRUE );
            fflush( stdout );

            return nReturnValue;
        }
    }

    //
    // Search for /flags
    //

    if( GetStringFromResources(
        IDS_FLAGS_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        for (Index = 1; Index < Count - 1; Index++)
        {
            if (_tcsicmp (Args[Index], strCmdLineOption) == 0)
            {
                Flags = _ttoi (Args[Index + 1]);

                Flags &= VerifierAllOptions;

                bFlagsSpecified = TRUE;
            }
        }
    }

    //
    // Search for /iolevel
    //

    if( GetStringFromResources(
        IDS_IOLEVEL_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        for (Index = 1; Index < Count - 1; Index++)
        {
            if (_tcsicmp (Args[Index], strCmdLineOption) == 0)
            {
                IoLevel = _ttoi (Args[Index + 1]);

                if( ( IoLevel != 0 ) && ( IoLevel <= IO_VERIFICATION_LEVEL_MAX ) )
                {
                    bIoLevelSpecified = TRUE;
                }
            }
        }
    }

    //
    // Search for /all
    //

    if( GetStringFromResources(
        IDS_ALL_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        for (Index = 1; Index < Count; Index++)
        {
            if (_tcsicmp (Args[Index], strCmdLineOption) == 0)
            {
                _tcscat (Names, TEXT("*"));

                bNamesSpecified = TRUE;
            }
        }
    }

    //
    // Search for /driver
    //

    LoadStringResult = LoadString (         // cannot reuse the static string buffer

        GetModuleHandle (NULL),
        IDS_DRIVER_CMDLINE_SWITCH,
        strDriver,
        sizeof strDriver / sizeof (TCHAR));

    ASSERT (LoadStringResult > 0);

    if (LoadStringResult > 0) {

        for (Index = 1; Index < Count - 1; Index++) {

            if (_tcsicmp (Args[Index], strDriver) == 0) {

                int NameIndex;
                LPCTSTR MiniportName;

                bNamesSpecified = ( Index < ( Count - 1 ) ); // have some driver names?

                for (NameIndex = Index + 1; NameIndex < Count; NameIndex++) {

                    _tcscat (Names, Args[NameIndex]);
                    _tcscat (Names, TEXT(" "));

                    MiniportName = IsMiniportDriver (Args[NameIndex], LoadStatus);

                    if (MiniportName == NULL && LoadStatus != VRF_DRIVER_LOAD_SUCCESS) {

                        switch (LoadStatus) {
                        case VRF_DRIVER_LOAD_SUCCESS:
                            break;

                        case VRF_DRIVER_LOAD_CANNOT_FIND_IMAGE:

                            VrfTPrintfResourceFormat(
                                IDS_CANT_FIND_IMAGE,
                                Args[NameIndex] );

                            //
                            // newline
                            //

                            VrfPutTS( _TEXT( "" ) );

                            break;

                        case VRF_DRIVER_LOAD_INVALID_IMAGE:

                            VrfTPrintfResourceFormat(
                                IDS_INVALID_IMAGE,
                                Args[NameIndex] );

                            //
                            // newline
                            //

                            VrfPutTS( _TEXT( "" ) );

                            break;

                        default:
                            ASSERT ( FALSE );
                            break;
                        }
                    }
                    else if (MiniportName != NULL && _tcsstr (Names, MiniportName) == NULL) {

                        _tcscat (Names, MiniportName);
                        _tcscat (Names, TEXT(" "));
                    }
                }

                break;
            }
        }
    }

    //
    // Search for /volatile
    //

    if( GetStringFromResources(
        IDS_DONTREBOOT_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        for (Index = 1; Index < Count; Index++)
        {

            if (_tcsicmp (Args[Index], strCmdLineOption) == 0)
            {
                bVolatileSpecified = TRUE;

                //
                // found /volatile in the command line
                //

                if( bFlagsSpecified && ! bNamesSpecified )
                {
                    if( g_OsVersion.dwBuildNumber >= 2055 )
                    {
                        //
                        // see if there are any verifier flags active
                        //

                        if (KrnGetSystemVerifierState (& KrnState) == FALSE)
                        {
                            //
                            // cannot get current verifier settings
                            //

                            VrfPrintStringFromResources( IDS_CANTGET_VERIF_STATE );

                            return EXIT_CODE_ERROR;
                        }
                        else
                        {
                            //
                            // compare the active flags with the new ones
                            //

                            if( KrnState.DriverCount != 0 )
                            {
                                //
                                // there are some drivers currently verified
                                //

                                if( KrnState.Level != Flags )
                                {
                                    //
                                    // try to change something on the fly
                                    //

                                    bResult = VrfSetVolatileFlags(
                                        Flags );

                                    if( bResult )
                                    {
                                        //
                                        // success - tell the user what flags have changed
                                        //

                                        VrfDumpChangedSettings(
                                            KrnState.Level,
                                            Flags );

                                        return EXIT_CODE_SUCCESS;
                                    }
                                    else
                                    {
                                        //
                                        // cannot change settings
                                        //

                                        return EXIT_CODE_ERROR;
                                    }
                                }
                                else
                                {
                                    //
                                    // the specified flags are the same as the active ones
                                    //

                                    VrfPrintStringFromResources( IDS_SAME_FLAGS_AS_ACTIVE );

                                    return EXIT_CODE_SUCCESS;
                                }
                            }
                            else
                            {
                                VrfPrintStringFromResources( IDS_NO_DRIVER_VERIFIED );

                                return EXIT_CODE_SUCCESS;
                            }
                        }
                    }
                    else
                    {
                        //
                        // the build is too old - we cannot change options on the fly
                        //

                        VrfPrintStringFromResources( IDS_CANT_CHANGE_SETTINGS_BUILD_OLD );

                        return EXIT_CODE_ERROR;
                    }
                }
                else
                {
                    //
                    // the flags were not specified - look for /adddriver, /removedriver
                    //
                    
                    if( VrfVolatileAddOrRemoveDriversCmdLine( Count, Args ) == TRUE )
                    {
                        //
                        // changed the verified drivers list
                        //

                        return EXIT_CODE_SUCCESS;
                    }
                    else
                    {
                        //
                        // nothing to change
                        //

                        VrfPrintStringFromResources( IDS_NO_SETTINGS_WERE_CHANGED );

                        return EXIT_CODE_ERROR;
                    }
                }

                //
                // Unreached - the code above will always return from the function.
                //

                ASSERT( FALSE );

                return EXIT_CODE_ERROR;
            }
        }
    }
    else
    {
        ASSERT( FALSE );
    }

    //
    // Write everything to the registry
    //

    if( !bVolatileSpecified && ( bFlagsSpecified || bNamesSpecified ) )
    {
        HKEY MmKey = NULL;
        LONG Result;
        DWORD Value;
        DWORD OldValue;

        Result = RegOpenKeyEx (

            HKEY_LOCAL_MACHINE,
            RegMemoryManagementKeyName,
            0,
            KEY_SET_VALUE | KEY_QUERY_VALUE,
            &MmKey);

        if (Result != ERROR_SUCCESS) {

            if( Result == ERROR_ACCESS_DENIED ) {

                VrfPrintStringFromResources(
                    IDS_ACCESS_IS_DENIED );

                return EXIT_CODE_ERROR;
            }
            else {

                VrfTPrintfResourceFormat(
                    IDS_REGOPENKEYEX_FAILED,
                    RegMemoryManagementKeyName,
                    (DWORD)Result);

                //
                // newline
                //

                VrfPutTS( _TEXT( "" ) );

                return EXIT_CODE_ERROR;
            }
        }

        if( bFlagsSpecified )
        {
            Value = Flags;

            if( ReadRegistryValue ( MmKey, RegVerifyDriverLevelValueName, &OldValue, 0) == FALSE) {
                RegCloseKey (MmKey);
                return EXIT_CODE_ERROR;
            }

            if (WriteRegistryValue (MmKey, RegVerifyDriverLevelValueName, Value) == FALSE) {
                RegCloseKey (MmKey);
                return EXIT_CODE_ERROR;
            }

            bIoVerifierEnabled = ( (Flags & DRIVER_VERIFIER_IO_CHECKING) != 0 );

            if( bIoVerifierEnabled && bIoLevelSpecified == TRUE )
            {
                SysIoVerifierLevel = IoLevel;                               
            }
            else
            {
                SysIoVerifierLevel = 0;
            }

            if ( ! SetSysIoVerifierSettings ( SysIoVerifierLevel ) )
            {
                RegCloseKey (MmKey);
                return EXIT_CODE_ERROR;
            }

            if( OldValue != Value ) {

                nReturnValue = EXIT_CODE_REBOOT_NEEDED;
            }
        }

        if( bNamesSpecified )
        {
            if (ReadMmString (MmKey, RegVerifyDriversValueName, OldNames, sizeof( OldNames ) ) == FALSE) {
                RegCloseKey (MmKey);
                return EXIT_CODE_ERROR;
            }

            if (WriteMmString (MmKey, RegVerifyDriversValueName, Names) == FALSE) {
                RegCloseKey (MmKey);
                return EXIT_CODE_ERROR;
            }

            if( _tcsicmp (OldNames, Names) ){

                nReturnValue = EXIT_CODE_REBOOT_NEEDED;
            }
        }

        RegCloseKey (MmKey);

    }
    else
    {
        PrintHelpInformation();
    }

    return nReturnValue;
}

//////////////////////////////////////////////////////////////////////

BOOL
GetStringFromResources(

    UINT uIdResource,
    TCHAR *strBuffer,
    int nBufferLength )
{
    UINT LoadStringResult;

    if( strBuffer == NULL || nBufferLength < 1 )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    LoadStringResult = LoadString (

        GetModuleHandle (NULL),
        uIdResource,
        strBuffer,
        nBufferLength );

    ASSERT (LoadStringResult > 0);

    return (LoadStringResult > 0);
}

//////////////////////////////////////////////////////////////////////

void
VrfPrintStringFromResources(

    UINT uIdResource)
{
    TCHAR strText[ 256 ];

    if( GetStringFromResources(
        uIdResource,
        strText,
        ARRAY_LENGTH( strText ) ) )
    {
        VrfOutputWideStringOEMFormat( strText, TRUE, stdout );
    }
}

//////////////////////////////////////////////////////////////////////

BOOL
VrfOuputStringFromResources(

    UINT uIdResource,
    BOOL bConvertToOEM,
    FILE *file )
{
    TCHAR strText[ 256 ];

    BOOL bResult;

    bResult = TRUE;

    if( GetStringFromResources(
        uIdResource,
        strText,
        ARRAY_LENGTH( strText ) ) )
    {
        if( bConvertToOEM )
        {
            VrfOutputWideStringOEMFormat( strText, TRUE, file );
        }
        else
        {
            bResult = ( _fputts( strText, file ) >= 0 );
        }
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////

void
VrfDumpChangedSettings(

    UINT OldFlags,
    UINT NewFlags )
{
    UINT uDifferentFlags;

    OldFlags &= VerifierModifyableOptions;
    NewFlags &= VerifierModifyableOptions;

    if( OldFlags == NewFlags )
    {
        //
        // no settings were changed
        //

        VrfPrintStringFromResources(
            IDS_NO_SETTINGS_WERE_CHANGED );
    }
    else
    {
        VrfPrintStringFromResources(
            IDS_CHANGED_SETTINGS_ARE );

        uDifferentFlags = OldFlags ^ NewFlags;

        //
        // changed DRIVER_VERIFIER_SPECIAL_POOLING ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_SPECIAL_POOLING )
        {
            if( NewFlags & DRIVER_VERIFIER_SPECIAL_POOLING )
            {
                VrfPrintStringFromResources(
                    IDS_SPECIAL_POOL_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_SPECIAL_POOL_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_FORCE_IRQL_CHECKING ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_FORCE_IRQL_CHECKING )
        {
            if( NewFlags & DRIVER_VERIFIER_FORCE_IRQL_CHECKING )
            {
                VrfPrintStringFromResources(
                    IDS_FORCE_IRQLCHECK_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_FORCE_IRQLCHECK_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES )
        {
            if( NewFlags & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES )
            {
                VrfPrintStringFromResources(
                    IDS_FAULT_INJECTION_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_FAULT_INJECTION_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS )
        {
            if( NewFlags & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS )
            {
                VrfPrintStringFromResources(
                    IDS_POOL_TRACK_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_POOL_TRACK_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_IO_CHECKING ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_IO_CHECKING )
        {
            if( NewFlags & DRIVER_VERIFIER_IO_CHECKING )
            {
                VrfPrintStringFromResources(
                    IDS_IO_CHECKING_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_IO_CHECKING_DISABLED_NOW );
            }
        }

        //
        // the changes are not saved to the registry
        //

        VrfPrintStringFromResources(
            IDS_CHANGES_ACTIVE_ONLY_BEFORE_REBOOT );
    }
}


//////////////////////////////////////////////////////////////////////

BOOL
VrfEnableDebugPrivilege (
    )
{
    struct
    {
        DWORD Count;
        LUID_AND_ATTRIBUTES Privilege [1];

    } Info;

    HANDLE Token;
    BOOL Result;

    //
    // open the process token
    //

    Result = OpenProcessToken (
        GetCurrentProcess (),
        TOKEN_ADJUST_PRIVILEGES,
        & Token);

    if( Result != TRUE )
    {
        VrfErrorResourceFormat(
            IDS_ACCESS_IS_DENIED );

        return FALSE;
    }

    //
    // prepare the info structure
    //

    Info.Count = 1;
    Info.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

    Result = LookupPrivilegeValue (
        NULL,
        SE_DEBUG_NAME,
        &(Info.Privilege[0].Luid));

    if( Result != TRUE )
    {
        VrfErrorResourceFormat(
            IDS_ACCESS_IS_DENIED );

        CloseHandle( Token );

        return FALSE;
    }

    //
    // adjust the privileges
    //

    Result = AdjustTokenPrivileges (
        Token,
        FALSE,
        (PTOKEN_PRIVILEGES) &Info,
        NULL,
        NULL,
        NULL);

    if( Result != TRUE || GetLastError() != ERROR_SUCCESS )
    {
        VrfErrorResourceFormat(
            IDS_ACCESS_IS_DENIED );

        CloseHandle( Token );

        return FALSE;
    }

    CloseHandle( Token );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////

void
VrfPrintNarrowStringOEMFormat(

    char *szText )
{
    char szTextOEM[ 512 ];

    ASSERT( szText != NULL );

    //
    // make a copy of the string
    //

    strncpy( szTextOEM, szText, ARRAY_LENGTH( szTextOEM ) - 1 );

    szTextOEM[ ARRAY_LENGTH( szTextOEM ) - 1 ] = (char)0;

    //
    // convert the string to OEM
    //

    if( CharToOemA( szTextOEM, szTextOEM ) )
    {
        puts( szTextOEM );
    }
    else
    {
        ASSERT( FALSE );
    }
}

//////////////////////////////////////////////////////////////////////

BOOL
VrfOutputWideStringOEMFormat(

    LPTSTR strText,
    BOOL bAppendNewLine,
    FILE *file )
{
    TCHAR strTextCopy[ 512 ];
    BOOL bResult;
    char szTextOEM[ 512 ];

    if( strText == NULL || file == NULL )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    //
    // make a copy of the string
    //

    _tcsncpy( strTextCopy, strText, ARRAY_LENGTH( strTextCopy ) - 1 );

    strTextCopy[ ARRAY_LENGTH( strTextCopy ) - 1 ] = (TCHAR)0;

    //
    // convert the string to OEM
    //

    if( CharToOem( strTextCopy, szTextOEM ) )
    {
        bResult = ( fputs( szTextOEM, file ) >= 0 );

        if( bResult && bAppendNewLine )
        {
            bResult = ( fputs( "\n", file ) >= 0 );
        }
    }
    else
    {
        ASSERT( FALSE );
        bResult = FALSE;
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////

BOOL
__cdecl
VrfFTPrintf(
    BOOL bConvertToOEM,
    FILE *file,
    LPTSTR fmt,
    ...)
{
    BOOL bResult;
    TCHAR strMessage[ 256 ];
    va_list prms;

    if( fmt == NULL || file == NULL )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    va_start (prms, fmt);

    _vsntprintf ( strMessage, ARRAY_LENGTH( strMessage ), fmt, prms);

    if( bConvertToOEM )
    {
        bResult = VrfOutputWideStringOEMFormat(
            strMessage,
            FALSE,
            file );
    }
    else
    {
        bResult = ( _ftprintf( file, _T( "%s" ), strMessage ) >= 0 );
    }

    va_end (prms);

    return bResult;
}

//////////////////////////////////////////////////////////////////////

BOOL
__cdecl
VrfFTPrintfResourceFormat(
    BOOL bConvertToOEM,
    FILE *file,
    UINT uIdResFmtString,
    ...)
{
    TCHAR strFormat[ 256 ];
    TCHAR strMessage[ 256 ];
    va_list prms;
    BOOL bResult;

    bResult = TRUE;

    if( GetStringFromResources(
        uIdResFmtString,
        strFormat,
        ARRAY_LENGTH( strFormat ) ) )
    {
        va_start (prms, uIdResFmtString);

        _vsntprintf ( strMessage, ARRAY_LENGTH( strMessage ), strFormat, prms);

        if( bConvertToOEM )
        {
            bResult = VrfOutputWideStringOEMFormat(
                strMessage,
                FALSE,
                file );
        }
        else
        {
            bResult = ( _ftprintf( file, _T( "%s" ), strMessage ) >= 0 );
        }

        va_end (prms);
    }
    else
    {
        ASSERT( FALSE );
        bResult = FALSE;
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////

void
__cdecl
VrfTPrintfResourceFormat(
    UINT uIdResFmtString,
    ...)
{
    TCHAR strMessage[ 256 ];
    TCHAR strFormat[ 256 ];
    va_list prms;

    //
    // get the format string
    //

    if( GetStringFromResources(
            uIdResFmtString,
            strFormat,
            ARRAY_LENGTH( strFormat ) ) )
    {
        va_start (prms, uIdResFmtString);

        //
        // get the message string as UNICODE
        //

        _vsntprintf (
            strMessage,
            ARRAY_LENGTH( strMessage ),
            strFormat,
            prms);

        //
        // output it as OEM
        //

        VrfOutputWideStringOEMFormat(
            strMessage,
            FALSE,
            stdout );

        va_end (prms);
    }

    return;
}

//////////////////////////////////////////////////////////////////////

void
VrfPutTS(
    LPTSTR strText )
{
    if( strText == NULL )
    {
        ASSERT( FALSE );
        return;
    }

    VrfOutputWideStringOEMFormat(
        strText,
        TRUE,
        stdout );
}

//////////////////////////////////////////////////////////////////////
//
// Support for dynamic set of verified drivers
//

BOOL VrfVolatileAddDriver( 

    const WCHAR *szDriverName )
{
    UNICODE_STRING usDriverName;
    NTSTATUS Status;
    UINT uIdErrorString;

    //
    // enable debug privilege
    //

    if( g_bPrivegeEnabled != TRUE )
    {
        g_bPrivegeEnabled = VrfEnableDebugPrivilege();

        if( g_bPrivegeEnabled != TRUE )
        {
            return FALSE;
        }
    }

    //
    // Must driver name as a UNICODE_STRING
    //

    ASSERT( szDriverName != NULL );
        
    RtlInitUnicodeString(
        &usDriverName,
        szDriverName );

    Status = NtSetSystemInformation(
        SystemVerifierAddDriverInformation,
        &usDriverName,
        sizeof( UNICODE_STRING ) );

    if( ! NT_SUCCESS( Status ) )
    {
        switch( Status )
        {
        case STATUS_INVALID_INFO_CLASS:
            uIdErrorString = IDS_VERIFIER_ADD_NOT_SUPPORTED;
            break;

        case STATUS_NOT_SUPPORTED:
            uIdErrorString = IDS_DYN_ADD_NOT_SUPPORTED;
            break;

        case STATUS_IMAGE_ALREADY_LOADED:
            uIdErrorString = IDS_DYN_ADD_ALREADY_LOADED;
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_NO_MEMORY:
            uIdErrorString = IDS_DYN_ADD_INSUF_RESOURCES;
            break;

        case STATUS_PRIVILEGE_NOT_HELD:
            uIdErrorString = IDS_DYN_ADD_ACCESS_DENIED;
            break;

        default:
            VrfErrorResourceFormat(
                IDS_DYN_ADD_MISC_ERROR,
                szDriverName,
                Status );

            return FALSE;
        }

        VrfErrorResourceFormat(
            uIdErrorString,
            szDriverName );

        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
BOOL VrfVolatileRemoveDriver( 

    const WCHAR *szDriverName )
{
    UNICODE_STRING usDriverName;
    NTSTATUS Status;
    UINT uIdErrorString;

    //
    // enable debug privilege
    //

    if( g_bPrivegeEnabled != TRUE )
    {
        g_bPrivegeEnabled = VrfEnableDebugPrivilege();

        if( g_bPrivegeEnabled != TRUE )
        {
            return FALSE;
        }
    }

    //
    // Must driver name as a UNICODE_STRING
    //

    ASSERT( szDriverName != NULL );
        
    RtlInitUnicodeString(
        &usDriverName,
        szDriverName );

    Status = NtSetSystemInformation(
        SystemVerifierRemoveDriverInformation,
        &usDriverName,
        sizeof( UNICODE_STRING ) );

    if( ! NT_SUCCESS( Status ) )
    {
        switch( Status )
        {
        case STATUS_INVALID_INFO_CLASS:
            uIdErrorString = IDS_VERIFIER_REMOVE_NOT_SUPPORTED;
            break;

        case STATUS_NOT_SUPPORTED:
            //
            // the driver verifier is not currently active at all -> success
            //

        case STATUS_NOT_FOUND:
            //
            // the driver is not currently verified -> success
            //

            return TRUE;

        case STATUS_IMAGE_ALREADY_LOADED:
            uIdErrorString = IDS_DYN_REMOVE_ALREADY_LOADED;
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_NO_MEMORY:
            uIdErrorString = IDS_DYN_REMOVE_INSUF_RESOURCES;
            break;

        case STATUS_PRIVILEGE_NOT_HELD:
            uIdErrorString = IDS_DYN_REMOVE_ACCESS_DENIED;
            break;

        default:
            VrfErrorResourceFormat(
                IDS_DYN_REMOVE_MISC_ERROR,
                szDriverName,
                Status );

            return FALSE;
        }

        VrfErrorResourceFormat(
            uIdErrorString,
            szDriverName );

        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
BOOL
VrfVolatileAddOrRemoveDriversCmdLine(

    int nArgsNo,
    LPTSTR szCmdLineArgs[] )
{
    int nCrtArg;
    BOOL bChangedSomething;
    BOOL bResult;
    BOOL bAddDriverSpecified = FALSE;
    BOOL bRemoveDriverSpecified  = FALSE;
    TCHAR szAddDriverOption[ 128 ];
    TCHAR szRemoveDriverOption[ 128 ];

    //
    // /loaddriver and /removedriver command line options
    //

    bResult = GetStringFromResources(
        IDS_ADDDRIVER_CMDLINE_SWITCH,
        szAddDriverOption,
        ARRAY_LENGTH( szAddDriverOption ) );

    if( bResult != TRUE )
    {
        return FALSE;
    }

    bResult = GetStringFromResources(
        IDS_REMOVEDRIVER_CMDLINE_SWITCH,
        szRemoveDriverOption,
        ARRAY_LENGTH( szRemoveDriverOption ) );

    if( bResult != TRUE )
    {
        return FALSE;
    }

    //
    // parse all the cmd line args
    //

    for( nCrtArg = 0; nCrtArg < nArgsNo; nCrtArg++ )
    {
        if( _tcsicmp( szCmdLineArgs[ nCrtArg ], szAddDriverOption ) == 0 )
        {
            //
            // /adddriver
            //

            bAddDriverSpecified = TRUE;
            bRemoveDriverSpecified = FALSE;
        }
        else
        {
            if( _tcsicmp( szCmdLineArgs[ nCrtArg ], szRemoveDriverOption ) == 0 )
            {
                //
                // /removedriver
                //

                bRemoveDriverSpecified = TRUE;
                bAddDriverSpecified = FALSE;
            }
            else
            {
                if( bAddDriverSpecified )
                {
                    //
                    // this must be a driver name to be added
                    // 
                    
                    if( VrfVolatileAddDriver( szCmdLineArgs[ nCrtArg ] ) )
                    {
                        bChangedSomething = TRUE;

                        VrfTPrintfResourceFormat(
                            IDS_DYN_ADD_VERIFIED_NOW,
                            szCmdLineArgs[ nCrtArg ] );
                    }
                }
                else
                {
                    if( bRemoveDriverSpecified )
                    {
                        //
                        // this must be a driver name to be added
                        // 
                    
                        if( VrfVolatileRemoveDriver( szCmdLineArgs[ nCrtArg ] ) )
                        {
                            bChangedSomething = TRUE;

                            VrfTPrintfResourceFormat(
                                IDS_DYN_ADD_NOT_VERIFIED_NOW,
                                szCmdLineArgs[ nCrtArg ] );
                        }
                    }
                }
            }
        }
    }

    return bChangedSomething;
}


//
// end of module: verify.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\verifier\win2k\vsetpage.cxx ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: VSetPage.cxx
// author: DMihai
// created: 07/07/99
//
// Description:
//
//      Volatile settings PropertyPage.

#include "stdafx.h"
#include "drvvctrl.hxx"
#include "VSetPage.hxx"

#include "DrvCSht.hxx"
#include <Cderr.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// timer ID
#define REFRESH_TIMER_ID    0x1324

// manual, high, normal, low speed
#define REFRESH_SPEED_VARS  4

// timer intervals in millisec for manual, high, normal, low speed
static UINT uTimerIntervals[ REFRESH_SPEED_VARS ] =
{
    0,      // Manual
    1000,   // High Speed
    5000,   // Normal Speed
    10000   // Low Speed
};

//
// help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_VSETTINGS_DRIVERS_LIST,         IDH_DV_VolatileTab_driver_details,
    IDC_VSETTINGS_NORMAL_VERIF_CHECK,   IDH_DV_SettingsTab_verifytype_sppool,
    IDC_VSETTINGS_PAGEDC_VERIF_CHECK,   IDH_DV_SettingsTab_verifytype_irql,
    IDC_VSETTINGS_ALLOCF_VERIF_CHECK,   IDH_DV_SettingsTab_verifytype_resource,
    IDC_VSETTINGS_APPLY_BUTTON,         IDH_DV_VolatileTab_Applybut,
    IDC_VSETTINGS_ADD_BUTTON,           IDH_DV_VolatileTab_Addbut,
    IDC_VSETTINGS_DONTVERIFY_BUTTON,    IDH_DV_VolatileTab_Removebut,
    
    IDC_VSETTINGS_REFRESH_BUTTON,     IDH_DV_common_refresh_nowbutton,
    IDC_VSETTINGS_MANUAL_RADIO,       IDH_DV_common_refresh_manual,
    IDC_VSETTINGS_HSPEED_RADIO,       IDH_DV_common_refresh_high,
    IDC_VSETTINGS_NORM_RADIO,         IDH_DV_common_refresh_normal,
    IDC_VSETTINGS_LOW_RADIO,          IDH_DV_common_refresh_low,
    0,                              0
};

/////////////////////////////////////////////////////////////
// CVolatileSettPage property page

IMPLEMENT_DYNCREATE(CVolatileSettPage, CPropertyPage)

CVolatileSettPage::CVolatileSettPage() : CPropertyPage(CVolatileSettPage::IDD)
{
    //{{AFX_DATA_INIT(CVolatileSettPage)
    m_nUpdateIntervalIndex = 2;
    m_bAllocFCheck = FALSE;
    m_bNormalCheck = FALSE;
    m_bPagedCCheck = FALSE;
    //}}AFX_DATA_INIT

    m_bAscendDrvNameSort = FALSE;
    m_bAscendDrvStatusSort = FALSE;

    m_uTimerHandler = 0;

    m_nSortColumnIndex = 0;

    m_eApplyButtonState = vrfControlDisabled;

    m_bTimerBlocked = FALSE;
}

CVolatileSettPage::~CVolatileSettPage()
{
}

void CVolatileSettPage::DoDataExchange(CDataExchange* pDX)
{
    if( ! pDX->m_bSaveAndValidate )
    {
        // query the kernel
        
        KrnGetSystemVerifierState( &m_KrnVerifState );
    }

    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVolatileSettPage)
    DDX_Control(pDX, IDC_VSETTINGS_DRIVERS_LIST, m_DriversList);
    DDX_Control(pDX, IDC_VSETTINGS_PAGEDC_VERIF_CHECK, m_PagedCCheck);
    DDX_Control(pDX, IDC_VSETTINGS_NORMAL_VERIF_CHECK, m_NormalVerifCheck);
    DDX_Control(pDX, IDC_VSETTINGS_ALLOCF_VERIF_CHECK, m_AllocFCheck);
    DDX_Control(pDX, IDC_VSETTINGS_APPLY_BUTTON, m_ApplyButton);
    DDX_Radio(pDX, IDC_VSETTINGS_MANUAL_RADIO, m_nUpdateIntervalIndex);
	//}}AFX_DATA_MAP

    if( pDX->m_bSaveAndValidate )
    {
        DDX_Check(pDX, IDC_VSETTINGS_NORMAL_VERIF_CHECK, m_bNormalCheck);
        DDX_Check(pDX, IDC_VSETTINGS_PAGEDC_VERIF_CHECK, m_bPagedCCheck);
        DDX_Check(pDX, IDC_VSETTINGS_ALLOCF_VERIF_CHECK, m_bAllocFCheck);
    }
}


BEGIN_MESSAGE_MAP(CVolatileSettPage, CPropertyPage)
    //{{AFX_MSG_MAP(CVolatileSettPage)
    ON_BN_CLICKED(IDC_VSETTINGS_REFRESH_BUTTON, OnCrtstatRefreshButton)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_VSETTINGS_DRIVERS_LIST, OnColumnclickCrtstatDriversList)
    ON_WM_TIMER()
    ON_BN_CLICKED(IDC_VSETTINGS_HSPEED_RADIO, OnCrtstatHspeedRadio)
    ON_BN_CLICKED(IDC_VSETTINGS_LOW_RADIO, OnCrtstatLowRadio)
    ON_BN_CLICKED(IDC_VSETTINGS_MANUAL_RADIO, OnCrtstatManualRadio)
    ON_BN_CLICKED(IDC_VSETTINGS_NORM_RADIO, OnCrtstatNormRadio)
    ON_BN_CLICKED(IDC_VSETTINGS_APPLY_BUTTON, OnApplyButton)
    ON_BN_CLICKED(IDC_VSETTINGS_ALLOCF_VERIF_CHECK, OnCheck )
    ON_BN_CLICKED(IDC_VSETTINGS_ADD_BUTTON, OnAddButton)
    ON_BN_CLICKED(IDC_VSETTINGS_DONTVERIFY_BUTTON, OnDontVerifyButton)
    ON_BN_CLICKED(IDC_VSETTINGS_NORMAL_VERIF_CHECK, OnCheck )
    ON_BN_CLICKED(IDC_VSETTINGS_PAGEDC_VERIF_CHECK, OnCheck )
    ON_NOTIFY(NM_RCLICK, IDC_VSETTINGS_DRIVERS_LIST, OnRclickDriversList)
    ON_COMMAND(ID_VOLATILE_ADD_DRIVERS, OnAddButton)
    ON_COMMAND(ID_VOLATILE_REMOVE_DRIVERS, OnDontVerifyButton)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_MESSAGE( WM_CONTEXTMENU, OnContextMenu )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
void CVolatileSettPage::UpdateControlsState()
{
    EnableControl( m_ApplyButton, m_eApplyButtonState );
}

/////////////////////////////////////////////////////////////////////////////
void CVolatileSettPage::EnableControl( CWnd &wndCtrl, 
                                   VRF_CONTROL_STATE eNewState )
{
    BOOL bEnabled = wndCtrl.IsWindowEnabled();
    if( bEnabled )
    {
        if( eNewState == vrfControlDisabled )
            wndCtrl.EnableWindow( FALSE );
    }
    else
    {
        if( eNewState == vrfControlEnabled )
            wndCtrl.EnableWindow( TRUE );
    }
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::SetupListHeader()
{
    CString strDrivers, strStatus;
    VERIFY( strDrivers.LoadString( IDS_DRIVERS ) );
    VERIFY( strStatus.LoadString( IDS_STATUS ) );

    // list's regtangle
    CRect rectWnd;
    m_DriversList.GetClientRect( &rectWnd );
    
    LVCOLUMN lvColumn;

    // column 0
    memset( &lvColumn, 0, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.pszText = strDrivers.GetBuffer( strDrivers.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    strDrivers.ReleaseBuffer();

    // column 1
    lvColumn.iSubItem = 1;
    lvColumn.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    strStatus.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::FillTheList()
{
    LVITEM lvItem;
    int nActualIndex; 
    BOOL *pbAlreadyInList;
    ULONG uCrtVerifiedDriver;
    int nItemCount;
    int nCrtListItem;
    TCHAR strDriverName[ _MAX_PATH ];
    BOOL bResult;

    if( m_KrnVerifState.DriverCount == 0 )
    {
        //
        // clear the list
        //

        VERIFY( m_DriversList.DeleteAllItems() );
    }
    else
    {
        //
        // there are some drivers currently verified
        //

        pbAlreadyInList = new BOOL[ m_KrnVerifState.DriverCount ];
        if( pbAlreadyInList == NULL )
        {
            return;
        }
        
        for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++)
        {
            pbAlreadyInList[ uCrtVerifiedDriver ] = FALSE;
        }

        //
        // parse all the current list items
        //

        nItemCount = m_DriversList.GetItemCount();

        for( nCrtListItem = 0; nCrtListItem < nItemCount; nCrtListItem++ )
        {
            //
            // get the current driver's name from the list
            //

            ZeroMemory( &lvItem, sizeof( lvItem ) );

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = nCrtListItem;
            lvItem.iSubItem = 0;
            lvItem.pszText = strDriverName;
            lvItem.cchTextMax = sizeof( strDriverName ) / sizeof( strDriverName[0] );

            bResult = m_DriversList.GetItem( &lvItem );
            if( bResult == FALSE )
            {
                //
                // could not get the current item's attributes?
                //

                ASSERT( FALSE );

                //
                // remove this item from the list
                //

                VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                nCrtListItem--;
                nItemCount--;
            }
            else
            {
                //
                // see is the current driver is still in m_KrnVerifState
                //

                for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++)
                {
                    if( _tcsicmp( strDriverName, 
                        m_KrnVerifState.DriverInfo[ uCrtVerifiedDriver ].Name ) == 0 )
                    {
                        //
                        // update the item's data with the current index in the array
                        //

                        lvItem.mask = LVIF_PARAM;
                        lvItem.lParam = uCrtVerifiedDriver;
                        
                        VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );

                        //
                        // update the second column
                        //

                        UpdateStatusColumn( nCrtListItem, uCrtVerifiedDriver ); 

                        //
                        // mark the current driver as updated
                        //

                        pbAlreadyInList[ uCrtVerifiedDriver ] = TRUE;

                        break;
                    }
                }

                //
                // If the driver is no longer verified, remove it from the list
                //

                if( uCrtVerifiedDriver >= m_KrnVerifState.DriverCount )
                {
                    VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                    nCrtListItem--;
                    nItemCount--;
                }
            }
        }

        //
        // add the drivers that were not in the list before this update
        //

        for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++)
        {
            if( ! pbAlreadyInList[ uCrtVerifiedDriver ] )
            {
                // 
                // add a new item for this
                //

                ZeroMemory( &lvItem, sizeof( lvItem ) );

                //
                // sub-item 0
                //

                lvItem.mask = LVIF_TEXT | LVIF_PARAM;
                lvItem.lParam = uCrtVerifiedDriver;
                lvItem.iItem = m_DriversList.GetItemCount();
                lvItem.iSubItem = 0;
                lvItem.pszText = m_KrnVerifState.DriverInfo[ uCrtVerifiedDriver ].Name;
                nActualIndex = m_DriversList.InsertItem( &lvItem );
                VERIFY( nActualIndex != -1 );

                //
                // sub-item 1
                //

                UpdateStatusColumn( nActualIndex, uCrtVerifiedDriver ); 
            }
        }

        delete pbAlreadyInList;
    }
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::UpdateStatusColumn( int nItemIndex, ULONG uCrtDriver )
{
    LVITEM lvItem;
    CString strStatus;

    ASSERT( nItemIndex >= 0 && 
            (UINT)nItemIndex < m_KrnVerifState.DriverCount &&
            nItemIndex < m_DriversList.GetItemCount() &&
            uCrtDriver >= 0 &&
            uCrtDriver < m_KrnVerifState.DriverCount &&
            uCrtDriver < (ULONG)m_DriversList.GetItemCount() );

    // determine what's the appropriate value for the second column
    if( ! m_KrnVerifState.DriverInfo[ uCrtDriver ].Loads )
    {
        VERIFY( strStatus.LoadString( IDS_NEVER_LOADED ) );
    }
    else
    {
        if( m_KrnVerifState.DriverInfo[ uCrtDriver ].Loads == 
            m_KrnVerifState.DriverInfo[ uCrtDriver ].Unloads )
        {
            VERIFY( strStatus.LoadString( IDS_UNLOADED ) );
        }
        else
        {
            if( m_KrnVerifState.DriverInfo[ uCrtDriver ].Loads > 
                m_KrnVerifState.DriverInfo[ uCrtDriver ].Unloads )
            {
                VERIFY( strStatus.LoadString( IDS_LOADED ) );
            }
            else
            {
                ASSERT( FALSE );
                VERIFY( strStatus.LoadString( IDS_UNKNOWN ) );
            }
        }
    }

    // update the list item
    memset( &lvItem, 0, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );
    VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );
    strStatus.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
int CALLBACK CVolatileSettPage::DrvStatusCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CVolatileSettPage *pThis = (CVolatileSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    // sanity check
    if( uIndex1 > pThis->m_KrnVerifState.DriverCount || 
        uIndex2 > pThis->m_KrnVerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    // difference between loads and unloads #
    LONG lLoadDiff1 = (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex1 ].Loads -
                      (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex1 ].Unloads;
    LONG lLoadDiff2 = (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex2 ].Loads - 
                      (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex2 ].Unloads;

    if( lLoadDiff1 == lLoadDiff2 )
    {
        nCmpRez = 0;
    }
    else
    {
        if( lLoadDiff1 > lLoadDiff2 )
            nCmpRez = 1;
        else
            nCmpRez = -1;
    }

    if( pThis->m_bAscendDrvStatusSort )
        nCmpRez *= -1;

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
int CALLBACK CVolatileSettPage::DrvNameCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CVolatileSettPage *pThis = (CVolatileSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    // sanity check
    if( uIndex1 > pThis->m_KrnVerifState.DriverCount || 
        uIndex2 > pThis->m_KrnVerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    nCmpRez = _tcsicmp( pThis->m_KrnVerifState.DriverInfo[ uIndex1 ].Name, 
                        pThis->m_KrnVerifState.DriverInfo[ uIndex2 ].Name );
    if( ! nCmpRez )
    {
        // same name ???
        nCmpRez = 0;
    }
    else
    {
        if( pThis->m_bAscendDrvNameSort )
            nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnRefreshTimerChanged()
{
    UINT uTimerElapse = 0;

    // kill the pending timer
    if( m_uTimerHandler != 0 )
    {
        VERIFY( KillTimer( REFRESH_TIMER_ID ) );
    }

    // sanity check
    if( m_nUpdateIntervalIndex < 0 || 
        m_nUpdateIntervalIndex >= REFRESH_SPEED_VARS )
    {
        m_nUpdateIntervalIndex = 0;
        CheckRadioButton( IDC_VSETTINGS_MANUAL_RADIO, IDC_VSETTINGS_LOW_RADIO, 
            IDC_VSETTINGS_MANUAL_RADIO );
    }

    // new timer interval
    uTimerElapse = uTimerIntervals[ m_nUpdateIntervalIndex ];
    if( uTimerElapse > 0 )
    {
        VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID, 
            uTimerElapse, NULL ) );
    }
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::SortTheList()
{
    if( m_nSortColumnIndex )
    {
        m_DriversList.SortItems( DrvStatusCmpFunc, (LPARAM)this );
    }
    else
    {
        m_DriversList.SortItems( DrvNameCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
// CVolatileSettPage message handlers

BOOL CVolatileSettPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    //
    // set the checkboxes state
    //

    if( KrnGetSystemVerifierState( &m_KrnVerifState ) && 
        m_KrnVerifState.DriverCount > 0 )
    {
        m_NormalVerifCheck.SetCheck( m_KrnVerifState.SpecialPool );
        m_PagedCCheck.SetCheck( m_KrnVerifState.IrqlChecking );
        m_AllocFCheck.SetCheck( m_KrnVerifState.FaultInjection );
    }

    //
    // see if we can modify options on the fly
    //

    if( g_OsVersion.dwMajorVersion < 5 || g_OsVersion.dwBuildNumber < 2055 )
    {
        m_NormalVerifCheck.EnableWindow( FALSE );
        m_PagedCCheck.EnableWindow( FALSE );
        m_AllocFCheck.EnableWindow( FALSE );
    }

    //
    // setup the list
    //

    SetupListHeader();
    FillTheList();
    SortTheList();

    OnRefreshTimerChanged();

    UpdateControlsState();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnCrtstatRefreshButton() 
{
    if( UpdateData( FALSE ) )
    {
        FillTheList();
        SortTheList();
    }
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnColumnclickCrtstatDriversList(NMHDR* pNMHDR, 
                                                   LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if( pNMListView->iSubItem )
    {
        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            // change the current ascend/descend order for this column
            m_bAscendDrvStatusSort = !m_bAscendDrvStatusSort;
        }
    }
    else
    {
        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            // change the current ascend/descend order for this column
            m_bAscendDrvNameSort = !m_bAscendDrvNameSort;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnRclickDriversList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    POINT point;
    CMenu theMenu, *pTrackedMenu = NULL;
    BOOL bShowRemoveMenuItem = FALSE;

    int nItems = m_DriversList.GetItemCount();

    for(int nCrtItem = 0; nCrtItem < nItems; nCrtItem++ )
    {
        if( m_DriversList.GetItemState( nCrtItem, LVIS_SELECTED ) &
            LVIS_SELECTED )
        {
            bShowRemoveMenuItem = TRUE;
        }
    }

    if( bShowRemoveMenuItem )
    {
        VERIFY( theMenu.LoadMenu( IDM_ADD_REMOVE_DRIVERS ) );
    }
    else
    {
        VERIFY( theMenu.LoadMenu( IDM_ADD_DRIVERS ) );
    }

    pTrackedMenu = theMenu.GetSubMenu( 0 );
    if( pTrackedMenu != NULL )
    {
        ASSERT_VALID( pTrackedMenu );
        VERIFY( ::GetCursorPos( &point ) );
        VERIFY( pTrackedMenu->TrackPopupMenu(
                TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                point.x, point.y,
                this ) );
    }
    else
    {
        ASSERT( FALSE );
    }

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnTimer(UINT nIDEvent) 
{
    if( m_bTimerBlocked != TRUE && nIDEvent == REFRESH_TIMER_ID )
    {
        CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
        if( pParentSheet != NULL )
        {
            ASSERT_VALID( pParentSheet );
            if( pParentSheet->GetActivePage() == this )
            {
                // refresh the displayed data 
                OnCrtstatRefreshButton();
            }
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////////////
void CVolatileSettPage::OnCheck() 
{
    m_eApplyButtonState = vrfControlEnabled;
    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
void CVolatileSettPage::OnApplyButton() 
{
    if( ApplyTheChanges() )
    {
        m_eApplyButtonState = vrfControlDisabled;
        UpdateControlsState();
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVolatileSettPage::ApplyTheChanges()
{
    if( UpdateData( TRUE ) )
    {
        return VrfSetVolatileOptions( 
            m_bNormalCheck,
            m_bPagedCCheck,
            m_bAllocFCheck );
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////
BOOL CVolatileSettPage::OnQueryCancel() 
{
    // give parent PropertySheet a chance to refuse the Cancel if needed

    CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
    if( pParentSheet != NULL )
    {
        ASSERT_VALID( pParentSheet );
        if( ! pParentSheet->OnQueryCancel() )
        {
            return FALSE;
        }
    }

    return CPropertyPage::OnQueryCancel();
}

/////////////////////////////////////////////////////////////
BOOL CVolatileSettPage::OnApply() 
{
    // refuse to apply 
    // (we don't use the standard PropertSheet buttons; Apply, OK)
    return FALSE;
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnCrtstatManualRadio() 
{
    // switch to manual refresh
    m_nUpdateIntervalIndex = 0;
    OnRefreshTimerChanged();
}

void CVolatileSettPage::OnCrtstatHspeedRadio() 
{
    // switch to high speed refresh
    m_nUpdateIntervalIndex = 1;
    OnRefreshTimerChanged();
}

void CVolatileSettPage::OnCrtstatNormRadio() 
{
    // switch to normal speed refresh
    m_nUpdateIntervalIndex = 2;
    OnRefreshTimerChanged();
}

void CVolatileSettPage::OnCrtstatLowRadio() 
{
    // switch to low speed refresh
    m_nUpdateIntervalIndex = 3;
    OnRefreshTimerChanged();
}

/////////////////////////////////////////////////////////////

#define VRF_MAX_CHARS_FOR_OPEN  4096

void CVolatileSettPage::OnAddButton() 
{
    static BOOL bChangedDirectory = FALSE;

    POSITION pos;
    BOOL bEnabledSome = FALSE;
    DWORD dwRetValue;
    DWORD dwOldMaxFileName = 0;
    DWORD dwErrorCode;
    int nFileNameStartIndex;
    INT_PTR nResult;
    TCHAR szDriversDir[ _MAX_PATH ];
    TCHAR szAppTitle[ _MAX_PATH ];
    TCHAR *szFilesBuffer = NULL;
    TCHAR *szOldFilesBuffer = NULL;
    CString strPathName;
    CString strFileName;

    CFileDialog fileDlg( 
        TRUE,                               // open file
        _T( "sys" ),                        // default extension
        NULL,                               // no initial file name
        OFN_ALLOWMULTISELECT    |           // multiple selection
        OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox
        OFN_NONETWORKBUTTON     |           // no network button
        OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
        OFN_SHAREAWARE,                     // don't check the existance of file with OpenFile
        _T( "Drivers (*.sys)|*.sys||" ) );  // only one filter

    //
    // check the max length for the returned string
    //

    if( fileDlg.m_ofn.nMaxFile < VRF_MAX_CHARS_FOR_OPEN )
    {
        //
        // allocate a new buffer for the file names
        // 

        szFilesBuffer = new TCHAR[ VRF_MAX_CHARS_FOR_OPEN ];
        szFilesBuffer[ 0 ] = (TCHAR)0;

        if( szFilesBuffer != NULL )
        {
            //
            // Save the old buffer address and length
            //

            dwOldMaxFileName = fileDlg.m_ofn.nMaxFile;
            szOldFilesBuffer = fileDlg.m_ofn.lpstrFile;
            
            //
            // Set the new buffer address and length
            //

            fileDlg.m_ofn.lpstrFile = szFilesBuffer;
            fileDlg.m_ofn.nMaxFile = VRF_MAX_CHARS_FOR_OPEN;
        }
    }

    //
    // Dialog title
    //

    if( GetStringFromResources(
        IDS_APPTITLE,
        szAppTitle,
        ARRAY_LENGTH( szAppTitle ) ) )
    {
        fileDlg.m_ofn.lpstrTitle = szAppTitle;
    }

    //
    // We change directory first time we try this to %windir%\system32\drivers
    //

    if( bChangedDirectory == FALSE )
    {

        dwRetValue = ExpandEnvironmentStrings(
            _T( "%windir%\\system32\\drivers" ),
            szDriversDir,
            ARRAY_LENGTH( szDriversDir ) );

        if( dwRetValue > 0 && dwRetValue <= ARRAY_LENGTH( szDriversDir ) )
        {
            fileDlg.m_ofn.lpstrInitialDir = szDriversDir;
        }

        bChangedDirectory = TRUE;
    }

    //
    // show the file selection dialog
    //

    nResult = fileDlg.DoModal();

    switch( nResult )
    {
    case IDOK:
        break;

    case IDCANCEL:
        goto cleanup;

    default:
        dwErrorCode = CommDlgExtendedError();

        if( dwErrorCode == FNERR_BUFFERTOOSMALL )
        {
            VrfErrorResourceFormat(
                IDS_TOO_MANY_FILES_SELECTED );
        }
        else
        {
            VrfErrorResourceFormat(
                IDS_CANNOT_OPEN_FILES,
                dwErrorCode );
        }

        goto cleanup;
    }

    //
    // Block the timer
    //

    m_bTimerBlocked = TRUE;

    //
    // Parse all the selected files and try to enable them for verification
    //

    pos = fileDlg.GetStartPosition();

    while( pos != NULL )
    {
        //
        // Get the full path for the next file
        //

        strPathName = fileDlg.GetNextPathName( pos );

        //
        // split only the file name, without the directory
        //

        nFileNameStartIndex = strPathName.ReverseFind( _T( '\\' ) );
        
        if( nFileNameStartIndex < 0 )
        {
            //
            // this shoudn't happen but you never know :-)
            //

            nFileNameStartIndex = 0;
        }
        else
        {
            //
            // skip the backslash
            //

            nFileNameStartIndex++;
        }

        strFileName = strPathName.Right( strPathName.GetLength() - nFileNameStartIndex );

        //
        // Try to add this driver to the current verification list
        //

        if( VrfVolatileAddDriver( (LPCTSTR)strFileName ) )
        {
            bEnabledSome = TRUE;
        }
    }

    //
    // Enable the timer
    //

    m_bTimerBlocked = FALSE;

    //
    // Refresh
    //

    if( bEnabledSome == TRUE )
    {
        OnCrtstatRefreshButton();
    }

cleanup:
    if( szFilesBuffer != NULL )
    {
        fileDlg.m_ofn.nMaxFile = dwOldMaxFileName;
        fileDlg.m_ofn.lpstrFile = szOldFilesBuffer;

        delete szFilesBuffer;
    }
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnDontVerifyButton() 
{
    int nItems;
    UINT uIndexInArray;
    BOOL bDisabledSome = FALSE;

    //
    // Block the timer
    //

    m_bTimerBlocked = TRUE;

    //
    // The number of items in the list
    //

    nItems = m_DriversList.GetItemCount();
    
    //
    // Parse all the items, looking for the selected ones.
    //

    for(int nCrtItem = 0; nCrtItem < nItems; nCrtItem++ )
    {
        if( m_DriversList.GetItemState( nCrtItem, LVIS_SELECTED ) & LVIS_SELECTED )
        {
            //
            // Get the index of the corresponding entry in the array
            //

            uIndexInArray = (UINT)m_DriversList.GetItemData( nCrtItem );

            //
            // sanity checks
            //

            if( uIndexInArray >= m_KrnVerifState.DriverCount )
            {
                ASSERT( FALSE );
                continue;
            }

            if( VrfVolatileRemoveDriver( m_KrnVerifState.DriverInfo[ uIndexInArray ].Name ) )
            {
                bDisabledSome = TRUE;
            }
        }
    }

    //
    // Enable the timer
    //

    m_bTimerBlocked = FALSE;

    //
    // If we disabled some drivers' verification we need to refresh the list
    //

    if( bDisabledSome )
    {
        OnCrtstatRefreshButton();
    }
}

/////////////////////////////////////////////////////////////
LONG CVolatileSettPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        VERIFIER_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////
LONG CVolatileSettPage::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;

    ::WinHelp( 
        (HWND) wParam,
        VERIFIER_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\cmdline.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/cmdline.c,v 1.20 89/08/13 11:41:23 tony Exp $
 *
 * Routines to parse and execute "command line" commands, such as searches
 * or colon commands.
 */

#include "stevie.h"

static  char    *altfile = NULL;        /* alternate file */
static  int     altline;                /* line # in alternate file */

static  char    *nowrtmsg = "No write since last change (use ! to override)";
static  char    *nooutfile = "No output file";
static  char    *morefiles = "more files to edit";

extern  char    **files;                /* used for "n" and "rew" */
extern  int     numfiles, curfile;

#define CMDSZ   100             /* size of the command buffer */

bool_t rangeerr;
static  bool_t	doecmd(char*arg, bool_t force);
static	void   badcmd(void);
static	void get_range(char**cp, LNPTR*lower, LNPTR*upper);
static	LNPTR	*get_line(char**cp);
void   ex_delete(LINE *l,LINE *u);
void   dolist(LINE *l,LINE *u);

extern char    *lastcmd;	/* in dofilter */

/*
 * getcmdln() - read a command line from the terminal
 *
 * Reads a command line started by typing '/', '?', '!', or ':'. Returns a
 * pointer to the string that was read. For searches, an optional trailing
 * '/' or '?' is removed.
 */
char *
getcmdln(firstc)
char    firstc;
{
        static  char    buff[CMDSZ];
        register char   *p = buff;
        register int    c;
        register char   *q;

        gotocmd(TRUE, firstc);

        /* collect the command string, handling '\b' and @ */
        do {
                switch (c = vgetc()) {

                default:                /* a normal character */
                        outchar(c);
                        *p++ = (char)c;
                        break;

                case BS:
                        if (p > buff) {
                                /*
                                 * this is gross, but it relies
                                 * only on 'gotocmd'
                                 */
                                p--;
                                gotocmd(TRUE, firstc);
                                for (q = buff; q < p ;q++)
                                        outchar(*q);
                        } else {
                                msg("");
                                return NULL;            /* back to cmd mode */
                        }
                        break;
#if 0
                case '@':                       /* line kill */
                        p = buff;
                        gotocmd(TRUE, firstc);
                        break;
#endif
                case NL:                        /* done reading the line */
                case CR:
                        break;
                }
        } while (c != NL && c != CR);

        *p = '\0';

        if (firstc == '/' || firstc == '?') {   /* did we do a search? */
                /*
                 * Look for a terminating '/' or '?'. This will be the first
                 * one that isn't quoted. Truncate the search string there.
                 */
                for (p = buff; *p ;) {
                        if (*p == firstc) {     /* we're done */
                                *p = '\0';
                                break;
                        } else if (*p == '\\')  /* next char quoted */
                                p += 2;
                        else
                                p++;            /* normal char */
                }
        }
        return buff;
}

/*
 * docmdln() - handle a colon command
 *
 * Handles a colon command received interactively by getcmdln() or from
 * the environment variable "EXINIT" (or eventually .virc).
 */
void
docmdln(cmdline)
char    *cmdline;
{
        char    buff[CMDSZ];
        char    cmdbuf[CMDSZ];
        char    argbuf[CMDSZ];
        char    *cmd, *arg;
        register char   *p;
        /*
         * The next two variables contain the bounds of any range given in a
         * command. If no range was given, both contain null line pointers.
         * If only a single line was given, u_pos will contain a null line
         * pointer.
         */
        LNPTR    l_pos, u_pos;


        /*
         * Clear the range variables.
         */
        l_pos.linep = (struct line *) NULL;
        u_pos.linep = (struct line *) NULL;

        if (cmdline == NULL)
                return;

        if (strlen(cmdline) > CMDSZ-2) {
                msg("Error: command line too long");
                return;
        }
        strcpy(buff, cmdline);

        /* skip any initial white space */
        for (cmd = buff; *cmd != NUL && isspace(*cmd) ;cmd++)
                ;

        if (*cmd == '%') {              /* change '%' to "1,$" */
                strcpy(cmdbuf, "1,$");  /* kind of gross... */
                strcat(cmdbuf, cmd+1);
                strcpy(cmd, cmdbuf);
        }

        while ((p=strchr(cmd, '%')) != NULL && *(p-1) != '\\') {
                                        /* change '%' to Filename */
                if (Filename == NULL) {
                        emsg("No filename");
                        return;
                }
                *p= NUL;
                strcpy (cmdbuf, cmd);
                strcat (cmdbuf, Filename);
                strcat (cmdbuf, p+1);
                strcpy(cmd, cmdbuf);
                msg(cmd);                       /*repeat */
        }

        while ((p=strchr(cmd, '#')) != NULL && *(p-1) != '\\') {
                                        /* change '#' to Altname */
                if (altfile == NULL) {
                        emsg("No alternate file");
                        return;
                }
                *p= NUL;
                strcpy (cmdbuf, cmd);
                strcat (cmdbuf, altfile);
                strcat (cmdbuf, p+1);
                strcpy(cmd, cmdbuf);
                msg(cmd);                       /*repeat */
        }

        /*
         * Parse a range, if present (and update the cmd pointer).
         */
        rangeerr = FALSE;
        get_range(&cmd, &l_pos, &u_pos);
        if(rangeerr) {
            return;
        }

        if (l_pos.linep != NULL) {
                if (LINEOF(&l_pos) > LINEOF(&u_pos)) {
                        emsg("Invalid range");
                        return;
                }
        }

        strcpy(cmdbuf, cmd);    /* save the unmodified command */

        /* isolate the command and find any argument */
        for ( p=cmd; *p != NUL && ! isspace(*p); p++ )
                ;
        if ( *p == NUL )
                arg = NULL;
        else {
                *p = NUL;
                for (p++; *p != NUL && isspace(*p) ;p++)
                        ;
                if (*p == NUL)
                        arg = NULL;
                else {
                        strcpy(argbuf, p);
                        arg = argbuf;
                }
        }
        if (strcmp(cmd,"q!") == 0)
                getout();
        if (strcmp(cmd,"q") == 0) {
                if (Changed)
                        emsg(nowrtmsg);
                else {
                        if ((curfile + 1) < numfiles)
                                emsg(morefiles);
                        else
                                getout();
                }
                return;
        }
        if ((strcmp(cmd,"w") == 0) ||
            (strcmp(cmd,"w!") == 0)) {
                if (arg == NULL) {
                        if (Filename != NULL) {
                                writeit(Filename, &l_pos, &u_pos);
                        } else
                                emsg(nooutfile);
                }
                else {
                        if (altfile)
                                free(altfile);
                        altfile = strsave(arg);
                        writeit(arg, &l_pos, &u_pos);
                }
                return;
        }
        if (strcmp(cmd,"wq") == 0) {
                if (Filename != NULL) {
                        if (writeit(Filename, (LNPTR *)NULL, (LNPTR *)NULL))
                                getout();
                } else
                        emsg(nooutfile);
                return;
        }
        if (strcmp(cmd, "x") == 0) {
                doxit();
                return;
        }

        if (strcmp(cmd,"f") == 0 && arg == NULL) {
                fileinfo();
                return;
        }
        if (*cmd == 'n') {
                if ((curfile + 1) < numfiles) {
                        /*
                         * stuff ":e[!] FILE\n"
                         */
                        stuffin(":e");
                        if (cmd[1] == '!')
                                stuffin("!");
                        stuffin(" ");
                        stuffin(files[++curfile]);
                        stuffin("\n");
                } else
                        emsg("No more files!");
                return;
        }
        if (*cmd == 'N') {
                if (curfile > 0) {
                        /*
                         * stuff ":e[!] FILE\n"
                         */
                        stuffin(":e");
                        if (cmd[1] == '!')
                                stuffin("!");
                        stuffin(" ");
                        stuffin(files[--curfile]);
                        stuffin("\n");
                } else
                        emsg("No more files!");
                return;
        }
        if(*cmd == 'l' || !strncmp(cmd,"li",2)) {
            if(arg != NULL) {
                msg("extra characters at end of \"list\" command");
            } else {
                dolist(l_pos.linep,u_pos.linep);
            }
            return;
        }
        if (strncmp(cmd, "rew", 3) == 0) {
                if (numfiles <= 1)              /* nothing to rewind */
                        return;
                curfile = 0;
                /*
                 * stuff ":e[!] FILE\n"
                 */
                stuffin(":e");
                if (cmd[3] == '!')
                        stuffin("!");
                stuffin(" ");
                stuffin(files[0]);
                stuffin("\n");
                return;
        }
        if (strcmp(cmd,"e") == 0 || strcmp(cmd,"e!") == 0) {
                (void) doecmd(arg, cmd[1] == '!');
                return;
        }
        /*
         * The command ":e#" gets expanded to something like ":efile", so
         * detect that case here.
         */
        if (*cmd == 'e' && arg == NULL) {
                if (cmd[1] == '!')
                        (void) doecmd(&cmd[2], TRUE);
                else
                        (void) doecmd(&cmd[1], FALSE);
                return;
        }
        if (strcmp(cmd,"f") == 0) {
                Filename = strsave(arg);
                setviconsoletitle();
                filemess("");
                return;
        }
        if (strcmp(cmd,"r") == 0) {
                if (arg == NULL) {
                        badcmd();
                        return;
                }
                if (readfile(arg, Curschar, 1)) {
                        emsg("Can't open file");
                        return;
                }
                updatescreen();
                CHANGED;
                return;
        }
        if (*cmd == 'd') {
            if(arg != NULL) {
                msg("extra characters at end of \"delete\" command");
            } else {
                ex_delete(l_pos.linep,u_pos.linep);
            }
            return;
        }
        if (strcmp(cmd,"=") == 0) {
                smsg("%d", cntllines(Filemem, &l_pos));
                return;
        }
        if (strncmp(cmd,"ta", 2) == 0) {
                dotag(arg, cmd[2] == '!');
                return;
        }
        if (strncmp(cmd,"set", 2) == 0) {
                doset(arg);
                return;
        }
        if (strcmp(cmd,"help") == 0) {
                if (help()) {
                        screenclear();
                        updatescreen();
                }
                return;
        }
        if (strncmp(cmd, "ve", 2) == 0) {
                extern  char    *Version;

                msg(Version);
                return;
        }
        if (strcmp(cmd, "sh") == 0) {
                doshell(NULL, FALSE);
                return;
        }
        if (strcmp(cmd, "source") == 0 ||
            strcmp(cmd, "so") == 0) {
                if(l_pos.linep != NULL) {
                    emsg("No range allowed on this command");
                } else {
                    dosource(arg,TRUE);
                }
                return;
        }
        if (*cmd == '!' || *cmd == '@') {
                if (*(cmd+1) == *cmd) {
	                if (lastcmd == (char*)NULL) {
	                        emsg("No previous command");
	                        return;
	                }
	                msg(lastcmd);
	                doshell(lastcmd, *cmd == '@');
                }
                else {
	                doshell(cmdbuf+1, *cmd == '@');
	                if (lastcmd == (char*)NULL)
	                	lastcmd = (char*)alloc(CMDSZ);
	                strcpy(lastcmd, cmdbuf+1);
                }
                return;
        }
        if (strncmp(cmd, "s/", 2) == 0) {
                dosub(&l_pos, &u_pos, cmdbuf+1);
                return;
        }
        if (strncmp(cmd, "g/", 2) == 0) {
                doglob(&l_pos, &u_pos, cmdbuf+1);
                return;
        }
        if (strcmp(cmd, "cd") == 0) {
                dochdir(arg);
                return;
        }
        /*
         * If we got a line, but no command, then go to the line.
         */
        if (*cmd == NUL && l_pos.linep != NULL) {
                *Curschar = l_pos;
                return;
        }

        badcmd();
}


void doxit()
{
        if (Changed) {
                if (Filename != NULL) {
                        if (!writeit(Filename, (LNPTR *)NULL, (LNPTR *)NULL))
                                return;
                } else {
                        emsg(nooutfile);
                        return;
                }
        }
        if ((curfile + 1) < numfiles)
                emsg(morefiles);
        else
                getout();
}

void dosource(char *arg,bool_t giveerror)
{
    FILE *f;
    char string[256];

    if(arg == NULL) {
        emsg("No filename given");
        return;
    }
    if((f = fopen(arg,"r")) == NULL) {
        if(giveerror) {
            emsg("No such file or error opening file");
        }
    } else {
        while(fgets(string,sizeof(string),f) != NULL) {
            docmdln(string);
        }
    }
}

void ex_delete(LINE *l,LINE *u)
{
    int ndone = 0;
    LINE *cp;
    LINE *np;
    LNPTR savep;

    if (l == NULL) {                // no address?  use current line.
        l = u = Curschar->linep;
    }

    u_save(l->prev,u->next);        // save for undo

    for(cp = l; cp != NULL && !got_int; cp = np) {
        np = cp->next;              // set next before we delete the line
        if(Curschar->linep != cp) {
            savep = *Curschar;
            Curschar->linep = cp;
            Curschar->index = 0;
            delline(1,FALSE);
            *Curschar = savep;
        } else {
            delline(1,FALSE);
        }
        ndone++;
        if(cp == u) {
            break;
        }
    }
    updatescreen();
    if((ndone >= P(P_RP)) || got_int) {
        smsg("%s%d fewer line%c",
             got_int ? "Interrupt: " : "",
             ndone,
             ndone == 1 ? ' ' : 's');
    }
}

void dolist(LINE *l,LINE *u)
{
    LINE *cp;
    char  ch;
    char *txt;

    if(l == NULL) {
        l = u = Curschar->linep;
    }

    puts("");         // scroll one line

    for(cp = l; cp != NULL && !got_int; cp = cp->next) {

        for(txt = cp->s,ch = *txt; ch; ch = *(++txt)) {

            if(chars[ch].ch_size > 1) {
                outstr(chars[ch].ch_str);
            } else {
                outchar(ch);
            }
        }
        outstr("$\n");
        if(cp == u) {
            break;
        }
    }
    if(got_int) {
        puts("Interrupt");
    }
    wait_return();
}

/*
 * get_range - parse a range specifier
 *
 * Ranges are of the form:
 *
 * addr[,addr]
 *
 * where 'addr' is:
 *
 * $  [+- NUM]
 * 'x [+- NUM]  (where x denotes a currently defined mark)
 * .  [+- NUM]
 * NUM
 *
 * The pointer *cp is updated to point to the first character following
 * the range spec. If an initial address is found, but no second, the
 * upper bound is equal to the lower.
 */
static void
get_range(cp, lower, upper)
register char   **cp;
LNPTR    *lower, *upper;
{
        register LNPTR   *l;
        register char   *p;

        if ((l = get_line(cp)) == NULL)
                return;

        *lower = *l;

        for (p = *cp; *p != NUL && isspace(*p) ;p++)
                ;

        *cp = p;

        if (*p != ',') {                /* is there another line spec ? */
                *upper = *lower;
                return;
        }

        *cp = ++p;

        if ((l = get_line(cp)) == NULL) {
                *upper = *lower;
                return;
        }

        *upper = *l;
}

static LNPTR *
get_line(cp)
char    **cp;
{
        static  LNPTR    pos;
        LNPTR    *lp;
        register char   *p, c;
        register int    lnum;

        pos.index = 0;          /* shouldn't matter... check back later */

        p = *cp;
        /*
         * Determine the basic form, if present.
         */
        switch (c = *p++) {

        case '$':
                pos.linep = Fileend->linep->prev;
                break;

        case '.':
                pos.linep = Curschar->linep;
                break;

        case '\'':
                if ((lp = getmark(*p++)) == NULL) {
                        emsg("Unknown mark");
                        rangeerr = TRUE;
                        return (LNPTR *) NULL;
                }
                pos = *lp;
                break;

        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
                for (lnum = c - '0'; isdigit(*p) ;p++)
                        lnum = (lnum * 10) + (*p - '0');

                pos = *gotoline(lnum);
                break;

        default:
                return (LNPTR *) NULL;
        }

        while (*p != NUL && isspace(*p))
                p++;

        if (*p == '-' || *p == '+') {
                bool_t  neg = (*p++ == '-');

                for (lnum = 0; isdigit(*p) ;p++)
                        lnum = (lnum * 10) + (*p - '0');

                if (neg)
                        lnum = -lnum;

                pos = *gotoline( cntllines(Filemem, &pos) + lnum );
        }

        *cp = p;
        return &pos;
}

static void
badcmd()
{
        emsg("Unrecognized command");
}

#define LSIZE   256     /* max. size of a line in the tags file */

/*
 * dotag(tag, force) - goto tag
 */
void
dotag(tag, force)
char    *tag;
bool_t  force;
{
        FILE    *tp;
        char    lbuf[LSIZE];            /* line buffer */
        char    pbuf[LSIZE];            /* search pattern buffer */
        bool_t  match;
        register char   *fname, *str;
        register char   *p;

        if ((tp = fopen("tags", "r")) == NULL) {
                emsg("Can't open tags file");
                return;
        }

        while (fgets(lbuf, LSIZE, tp) != NULL) {

                if (lbuf[0] == ';') {
			/* Allow comment line. */
			continue;
		}
                if ((fname = strchr(lbuf, TAB)) == NULL) {
                        emsg("Format error in tags file");
                        return;
                }
                *fname++ = '\0';
                if ((str = strchr(fname, TAB)) == NULL) {
                        emsg("Format error in tags file");
                        return;
                }
                *str++ = '\0';

                if (P(P_IC)) {
	                match = _stricmp(lbuf, tag) == 0;
	        } else {
	                match = strcmp(lbuf, tag) == 0;
	        }
                if (match) {

                        /*
                         * Scan through the search string. If we see a magic
                         * char, we have to quote it. This lets us use "real"
                         * implementations of ctags.
                         */
                        p = pbuf;
                        *p++ = *str++;          /* copy the '/' or '?' */
                        *p++ = *str++;          /* copy the '^' */

                        for (; *str != NUL ;str++) {
                                if (*str == '\\') {
                                        *p++ = *str++;
                                        *p++ = *str;
                                } else if (strchr("/?", *str) != NULL) {
                                        if (str[1] != '\n') {
                                                *p++ = '\\';
                                                *p++ = *str;
                                        } else
                                                *p++ = *str;
                                } else if (strchr("^()*.", *str) != NULL) {
                                        *p++ = '\\';
                                        *p++ = *str;
                                } else
                                        *p++ = *str;
                        }
                        *p = NUL;

                        /*
                         * This looks out of order, but by calling stuffin()
                         * before doecmd() we keep an extra screen update
                         * from occuring. This stuffins() have no effect
                         * until we get back to the main loop, anyway.
                         */
                        stuffin(pbuf);          /* str has \n at end */
                        stuffin("\007");        /* CTRL('g') */

                        if (doecmd(fname, force)) {
                                fclose(tp);
                                return;
                        } else
                                stuffin(NULL);  /* clear the input */
                }
        }
        emsg("tag not found");
        fclose(tp);
}

static  bool_t
doecmd(arg, force)
char    *arg;
bool_t  force;
{
        int     line = 1;               /* line # to go to in new file */

        if (!force && Changed) {
                emsg(nowrtmsg);
                if ( arg != NULL ) {
                        if (altfile)
                                free(altfile);
                        altfile = strsave(arg);
                }
                return FALSE;
        }
        if (arg != NULL) {
                /*
                 * First detect a ":e" on the current file. This is mainly
                 * for ":ta" commands where the destination is within the
                 * current file.
                 */
                if (Filename != NULL && strcmp(arg, Filename) == 0) {
                        if (!Changed || (Changed && !force))
                                return TRUE;
                }
                if (altfile) {
                        if (strcmp (arg, altfile) == 0)
                                line = altline;
                        free(altfile);
                }
                altfile = Filename;
                altline = cntllines(Filemem, Curschar);
                Filename = strsave(arg);
        }
        if (Filename == NULL) {
                emsg("No filename");
                return FALSE;
        }

        /* clear mem and read file */
        freeall();
        filealloc();
        UNCHANGED;

        if (readfile(Filename, Filemem, 0))
                filemess("[New File]");
        setviconsoletitle();

        *Topchar = *Curschar;
        if (line != 1) {
                stuffnum(line);
                stuffin("G");
        }
        do_mlines();
        setpcmark();
        updatescreen();
        return TRUE;
}

void
gotocmd(clr, firstc)
bool_t  clr;
char    firstc;
{
        windgoto(Rows-1,0);
        if (clr)
                EraseLine();            /* clear the bottom line */
        if (firstc)
                outchar(firstc);
}

/*
 * msg(s) - displays the string 's' on the status line
 */
void
msg(s)
char    *s;
{
        gotocmd(TRUE, 0);
        outstr(s);
        flushbuf();
}

/*VARARGS1*/
void
smsg(s, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16)
char    *s;
int     a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16;
{
        char    sbuf[256];   /* Status line, > 80 chars to allow wrap. */

        sprintf(sbuf, s,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16);
        msg(sbuf);
}

/*
 * emsg() - display an error message
 *
 * Rings the bell, if appropriate, and calls message() to do the real work
 */
void
emsg(s)
char    *s;
{
        if (P(P_EB))
                beep();
        msg(s);
}

int
wait_return0()
{
        register char   c;
        if (got_int)
                outstr("Interrupt: ");

        outstr("Press RETURN to continue");

        do {
                c = (char)vgetc();
        } while (c != CR && c != NL && c != ' ' && c != ':');

        return c;
}

void
wait_return()
{
        char c = (char)wait_return0();

        if (c == ':') {
                outchar(NL);
                docmdln(getcmdln(c));
        } else
                screenclear();

        updatescreen();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\edit.c ===
/*
 * The main edit loop as well as some other simple cursor movement routines.
 */

#include "stevie.h"

/*
 * This flag is used to make auto-indent work right on lines where only
 * a <RETURN> or <ESC> is typed. It is set when an auto-indent is done,
 * and reset when any other editting is done on the line. If an <ESC>
 * or <RETURN> is received, and did_ai is TRUE, the line is truncated.
 */
bool_t  did_ai = FALSE;

void
edit()
{
    extern  bool_t  need_redraw;
    int     c;
    register char   *p, *q;

    Prenum = 0;

    /* position the display and the cursor at the top of the file. */
    *Topchar = *Filemem;
    *Curschar = *Filemem;
    Cursrow = Curscol = 0;

    do_mlines();            /* check for mode lines before starting */

    updatescreen();

    for ( ;; ) {

        /* Figure out where the cursor is based on Curschar. */
        cursupdate();

        if (need_redraw && !anyinput()) {
                updatescreen();
                need_redraw = FALSE;
        }

        if (!anyinput())
                windgoto(Cursrow,Curscol);


        c = vgetc();

        if (State == NORMAL) {

                /* We're in the normal (non-insert) mode. */

                /* Pick up any leading digits and compute 'Prenum' */
                if ( (Prenum>0 && isdigit(c)) || (isdigit(c) && c!='0') ){
                        Prenum = Prenum*10 + (c-'0');
                        continue;
                }
                /* execute the command */
                normal(c);
                Prenum = 0;

        } else {

                /*
                 * Insert or Replace mode.
                 */
                switch (c) {

                case ESC:       /* an escape ends input mode */

                        /*
                         * If we just did an auto-indent, truncate the
                         * line, and put the cursor back.
                         */
                        if (did_ai) {
                                Curschar->linep->s[0] = NUL;
                                Curschar->index = 0;
                                did_ai = FALSE;
                        }

                        set_want_col = TRUE;

                        /* Don't end up on a '\n' if you can help it. */
                        if (gchar(Curschar) == NUL && Curschar->index != 0)
                                dec(Curschar);

                        /*
                         * The cursor should end up on the last inserted
                         * character. This is an attempt to match the real
                         * 'vi', but it may not be quite right yet.
                         */
                        if (Curschar->index != 0 && !endofline(Curschar))
                                dec(Curschar);

                        State = NORMAL;
                        msg("");

                        /* construct the Redo buffer */
                        p = ralloc(Redobuff,
                                   Ninsert+2 < REDOBUFFMIN
                                   ? REDOBUFFMIN : Ninsert+2);
                        if(p == NULL) {
                            msg("Insufficient memory -- command not saved for redo");
                        } else {
                            Redobuff=p;
                            q=Insbuff;
                            while ( q < Insptr )
                                *p++ = *q++;
                            *p++ = ESC;
                            *p = NUL;
                        }
                        updatescreen();
                        break;

                case CTRL('D'):
                        /*
                         * Control-D is treated as a backspace in insert
                         * mode to make auto-indent easier. This isn't
                         * completely compatible with vi, but it's a lot
                         * easier than doing it exactly right, and the
                         * difference isn't very noticeable.
                         */
                case BS:
                        /* can't backup past starting point */
                        if (Curschar->linep == Insstart->linep &&
                            Curschar->index <= Insstart->index) {
                                beep();
                                break;
                        }

                        /* can't backup to a previous line */
                        if (Curschar->linep != Insstart->linep &&
                            Curschar->index <= 0) {
                                beep();
                                break;
                        }

                        did_ai = FALSE;
                        dec(Curschar);
                        if (State == INSERT)
                                delchar(TRUE);
                        /*
                         * It's a little strange to put backspaces into
                         * the redo buffer, but it makes auto-indent a
                         * lot easier to deal with.
                         */
                        insertchar(BS);
                        cursupdate();
                        updateline();
                        break;

                case CR:
                case NL:
                        insertchar(NL);
                        opencmd(FORWARD, TRUE);         /* open a new line */
                        break;

                case TAB:
                        if (!P(P_HT)) {
                            /* fake TAB with spaces */
                            int i = P(P_TS) - (Curscol % P(P_TS));
                            did_ai = FALSE;
                            while (i--) {
                                inschar(' ');
                                insertchar(' ');
                            }
                            updateline();
                            break;
                        }

                        /* else fall through to normal case */

                default:
                        did_ai = FALSE;
                        inschar(c);
                        insertchar(c);
                        updateline();
                        break;
                }
        }
    }
}

void
insertchar(c)
int     c;
{
    char *p;

    *Insptr++ = (char)c;
    Ninsert++;

    if(Ninsert == InsbuffSize) {        // buffer is full -- enlarge it

        if((p = ralloc(Insbuff,InsbuffSize+INSERTSLOP)) != NULL) {

            Insptr += p - Insbuff;
            Insbuff = p;
            InsbuffSize += INSERTSLOP;

        } else {                            // could not get bigger buffer

            stuffin(mkstr(ESC));            // just end insert mode
        }
    }
}

void
getout()
{
        windgoto(Rows-1,0);
        //putchar('\r');
        putchar('\n');
        windexit(0);
}

void
scrolldown(nlines)
int     nlines;
{
    register LNPTR   *p;
        register int    done = 0;       /* total # of physical lines done */

        /* Scroll up 'nlines' lines. */
        while (nlines--) {
                if ((p = prevline(Topchar)) == NULL)
                        break;
                done += plines(p);
                *Topchar = *p;
                /*
                 * If the cursor is on the bottom line, we need to
                 * make sure it gets moved up the appropriate number
                 * of lines so it stays on the screen.
                 */
                if (Curschar->linep == Botchar->linep->prev) {
                        int     i = 0;
                        while (i < done) {
                                i += plines(Curschar);
                                *Curschar = *prevline(Curschar);
                        }
                }
        }
        s_ins(0, done);
}

void
scrollup(nlines)
int     nlines;
{
    register LNPTR   *p;
        register int    done = 0;       /* total # of physical lines done */
        register int    pl;             /* # of plines for the current line */

        /* Scroll down 'nlines' lines. */
        while (nlines--) {
                pl = plines(Topchar);
                if ((p = nextline(Topchar)) == NULL)
                        break;
                done += pl;
                if (Curschar->linep == Topchar->linep)
                        *Curschar = *p;
                *Topchar = *p;

        }
        s_del(0, done);
}

/*
 * oneright
 * oneleft
 * onedown
 * oneup
 *
 * Move one char {right,left,down,up}.  Return TRUE when
 * sucessful, FALSE when we hit a boundary (of a line, or the file).
 */

bool_t
oneright()
{
        set_want_col = TRUE;

        switch (inc(Curschar)) {

        case 0:
                return TRUE;

        case 1:
                dec(Curschar);          /* crossed a line, so back up */
                /* fall through */
        case -1:
                return FALSE;

        DEFAULT_UNREACHABLE;
        }
        /*NOTREACHED*/
}

bool_t
oneleft()
{
        set_want_col = TRUE;

        switch (dec(Curschar)) {

        case 0:
                return TRUE;

        case 1:
                inc(Curschar);          /* crossed a line, so back up */
                /* fall through */
        case -1:
                return FALSE;

        DEFAULT_UNREACHABLE;
        }
        /*NOTREACHED*/
}

void
beginline(flag)
bool_t  flag;
{
        while ( oneleft() )
                ;
        if (flag) {
                while (isspace(gchar(Curschar)) && oneright())
                        ;
        }
        set_want_col = TRUE;
}

bool_t
oneup(n)
int     n;
{
    LNPTR    p, *np;
        register int    k;

        p = *Curschar;
        for ( k=0; k<n; k++ ) {
                /* Look for the previous line */
                if ( (np=prevline(&p)) == NULL ) {
                        /* If we've at least backed up a little .. */
                        if ( k > 0 )
                                break;  /* to update the cursor, etc. */
                        else
                                return FALSE;
                }
                p = *np;
        }
        *Curschar = p;
        /* This makes sure Topchar gets updated so the complete line */
        /* is one the screen. */
        cursupdate();
        /* try to advance to the column we want to be at */
        *Curschar = *coladvance(&p, Curswant);
        return TRUE;
}

bool_t
onedown(n)
int     n;
{
    LNPTR    p, *np;
        register int    k;

        p = *Curschar;
        for ( k=0; k<n; k++ ) {
                /* Look for the next line */
                if ( (np=nextline(&p)) == NULL ) {
                        if ( k > 0 )
                                break;
                        else
                                return FALSE;
                }
                p = *np;
        }
        /* try to advance to the column we want to be at */
        *Curschar = *coladvance(&p, Curswant);
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\alloc.c ===
/*
 * Various allocation routines and routines returning information about
 * allocated objects.
 */

#include "stevie.h"

char *
alloc(size)
unsigned size;
{
        char    *p;             /* pointer to new storage space */

        p = malloc(size);
        if ( p == (char *)NULL ) {      /* if there is no more room... */
                emsg("Insufficient memory");
        }
        return(p);
}

char *
ralloc(char *block,unsigned newsize)
{
    char *p;

    if((p = realloc(block,newsize)) == NULL) {
        emsg("Insufficient memory");
    }
    return(p);
}

char *
strsave(string)
char    *string;
{
        return(strcpy(alloc((unsigned)(strlen(string)+1)),string));
}

void
screenalloc()
{
        /*
         * If we're changing the size of the screen, free the old arrays
         */
        if (Realscreen != NULL)
                free(Realscreen);
        if (Nextscreen != NULL)
                free(Nextscreen);

        Realscreen = malloc((unsigned)(Rows*Columns));
        Nextscreen = malloc((unsigned)(Rows*Columns));
}

/*
 * Allocate and initialize a new line structure with room for
 * 'nchars'+1 characters. We add one to nchars here to allow for
 * null termination because all the callers would just do it otherwise.
 */
LINE *
newline(nchars)
int     nchars;
{
        register LINE   *l;

        if ((l = (LINE *) alloc(sizeof(LINE))) == NULL)
                return (LINE *) NULL;

        l->s = alloc((unsigned) (nchars+1));    /* the line is empty */
        l->s[0] = NUL;
        l->size = nchars + 1;

        l->prev = (LINE *) NULL;        /* should be initialized by caller */
        l->next = (LINE *) NULL;

        return l;
}

/*
 * filealloc() - construct an initial empty file buffer
 */
void
filealloc()
{
        if ((Filemem->linep = newline(0)) == NULL) {
                fprintf(stderr,"Unable to allocate file memory!\n");
                exit(1);
        }
        if ((Filetop->linep = newline(0)) == NULL) {
                fprintf(stderr,"Unable to allocate file memory!\n");
                exit(1);
        }
        if ((Fileend->linep = newline(0)) == NULL) {
                fprintf(stderr,"Unable to allocate file memory!\n");
                exit(1);
        }
        Filemem->index = 0;
        Filetop->index = 0;
        Fileend->index = 0;

        Filetop->linep->next = Filemem->linep;  /* connect Filetop to Filemem */
        Filemem->linep->prev = Filetop->linep;

        Filemem->linep->next = Fileend->linep;  /* connect Filemem to Fileend */
        Fileend->linep->prev = Filemem->linep;

        *Curschar = *Filemem;
        *Topchar  = *Filemem;

        Filemem->linep->num = 0;
        Fileend->linep->num = 0xffff;

        clrall();               /* clear all marks */
        u_clear();              /* clear the undo buffer */
}

/*
 * freeall() - free the current buffer
 *
 * Free all lines in the current buffer.
 */
void
freeall()
{
        register LINE   *lp, *xlp;

        for (lp = Filetop->linep; lp != NULL ;lp = xlp) {
                if (lp->s != NULL)
                        free(lp->s);
                xlp = lp->next;
                free((char *)lp);
        }

        Curschar->linep = NULL;         /* clear pointers */
        Filetop->linep = NULL;
        Filemem->linep = NULL;
        Fileend->linep = NULL;

        u_clear();
        /* _heapmin(); */
}

/*
 * bufempty() - return TRUE if the buffer is empty
 */
bool_t
bufempty()
{
        return (buf1line() && Filemem->linep->s[0] == NUL);
}

/*
 * buf1line() - return TRUE if there is only one line
 */
bool_t
buf1line()
{
        return (Filemem->linep->next == Fileend->linep);
}

/*
 * lineempty() - return TRUE if the current line is empty
 */
bool_t
lineempty()
{
        return (Curschar->linep->s[0] == NUL);
}

/*
 * endofline() - return TRUE if the given position is at end of line
 *
 * This routine will probably never be called with a position resting
 * on the NUL byte, but handle it correctly in case it happens.
 */
bool_t
endofline(p)
register LNPTR   *p;
{
        return (p->linep->s[p->index] == NUL || p->linep->s[p->index+1] == NUL);
}
/*
 * canincrease(n) - returns TRUE if the current line can be increased 'n' bytes
 *
 * This routine returns immediately if the requested space is available.
 * If not, it attempts to allocate the space and adjust the data structures
 * accordingly. If everything fails it returns FALSE.
 */
bool_t
canincrease(n)
register int    n;
{
        register int    nsize;
        register char   *s;             /* pointer to new space */

        nsize = strlen(Curschar->linep->s) + 1 + n;     /* size required */

        if (nsize <= Curschar->linep->size)
                return TRUE;

        /*
         * Need to allocate more space for the string. Allow some extra
         * space on the assumption that we may need it soon. This avoids
         * excessive numbers of calls to malloc while entering new text.
         */
        if ((s = alloc((unsigned) (nsize + SLOP))) == NULL) {
                emsg("Can't add anything, file is too big!");
                State = NORMAL;
                return FALSE;
        }

        Curschar->linep->size = nsize + SLOP;
        strcpy(s, Curschar->linep->s);
        free(Curschar->linep->s);
        Curschar->linep->s = s;

        return TRUE;
}

char *
mkstr(c)
char    c;
{
        static  char    s[2];

        s[0] = c;
        s[1] = NUL;

        return s;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\env.h ===
/*
 * The defines in this file establish the environment we're compiling
 * in. Set these appropriately before compiling the editor.
 */

/*
 * One (and only 1) of the following defines should be uncommented.
 * Most of the code is pretty machine-independent. Machine dependent
 * code goes in a file like tos.c or unix.c. The only other place
 * where machine dependent code goes is term.h for escape sequences.
 */

#define NT
/* #define      ATARI                   /* For the Atari ST */
/* #define      UNIX                    /* System V or BSD */
/* #define      OS2                     /* Microsoft OS/2 1.1 */
/* #define      DOS                     /* MSDOS 3.3 (on AT) */

/*
 * If UNIX is defined above, then BSD may be defined.
 */
#ifdef  UNIX
/* #define      BSD                     /* Berkeley UNIX */
#endif

/*
 * If ATARI is defined, MINIX may be defined. Otherwise, the editor
 * is set up to compile using the Sozobon C compiler under TOS.
 */
#ifdef  ATARI
#define MINIX                   /* Minix for the Atari ST */
#endif

/*
 * The yank buffer is still static, but its size can be specified
 * here to override the default of 4K.
 */
/* #define      YBSIZE  8192            /* yank buffer size */

/*
 * STRCSPN should be defined if the target system doesn't have the
 * routine strcspn() available. See regexp.c for details.
 */

#ifdef  ATARI

#ifdef  MINIX
#define STRCSPN
#endif

#endif

/*
 * The following defines control the inclusion of "optional" features. As
 * the code size of the editor grows, it will probably be useful to be able
 * to tailor the editor to get the features you most want in environments
 * with code size limits.
 *
 * TILDEOP
 *      Normally the '~' command works on a single character. This define
 *      turns on code that allows it to work like an operator. This is
 *      then enabled at runtime with the "tildeop" parameter.
 *
 * HELP
 *      If defined, a series of help screens may be views with the ":help"
 *      command. This eats a fair amount of data space.
 *
 * TERMCAP
 *      Where termcap support is provided, it is generally optional. If
 *      not enabled, you generally get hard-coded escape sequences for
 *      some "reasonable" terminal. In Minix, this means the console. For
 *      UNIX, this means an ANSI standard terminal. See the file "term.h"
 *      for details about specific environments.
 *
 */
#define TILDEOP         /* enable tilde to be an operator */
#define HELP            /* enable help command */
#ifndef NT
#define TERMCAP         /* enable termcap support */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\help.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/help.c,v 1.9 89/08/06 09:50:09 tony Exp $
 *
 * Routine to display a command summary.
 */

#include "stevie.h"

extern  char    *Version;

static  int     helprow;

#ifdef  HELP

static  void    longline();

bool_t
help()
{

/***********************************************************************
 * First Screen:   Positioning within file, Adjusting the Screen
 ***********************************************************************/

        ClearDisplay();
        windgoto(helprow = 0, 0);

longline(
"   Positioning within file\n"
"   =======================\n"
"      ^F             Forward screenfull             Developed by:\n"
"      ^B             Backward screenfull                Tony Andrews\n");
longline(
"      ^D             scroll down half screen\n"
"      ^U             scroll up half screen          Based on a program by:\n");
longline(
"      G              Goto line (end default)            Tim Thompson\n"
"      ]]             next function\n"
"      [[             previous function\n"
"      /re            next occurence of regular expression 're'\n");
longline(
"      ?re            prior occurence of regular expression 're'\n"
"      n              repeat last / or ?\n"
"      N              reverse last / or ?\n"
"      %              find matching (, ), {, }, [, or ]\n");
longline(
"\n"
"   Adjusting the screen\n"
"   ====================\n"
"      ^L             Redraw the screen\n"
"      ^E             scroll window down 1 line\n"
"      ^Y             scroll window up 1 line\n");
longline(
"      z<RETURN>      redraw, current line at top\n"
"      z-             ... at bottom\n"
"      z.             ... at center\n");

        windgoto(0, 52);
        longline(Version);

        windgoto(helprow = Rows-2, 47);
        longline("<Press space bar to continue>\n");
        windgoto(helprow = Rows-1, 47);
        longline("<Any other key will quit>");

        if ( vgetc() != ' ' )
                return TRUE;

/***********************************************************************
 * Second Screen:   Character positioning
 ***********************************************************************/

        ClearDisplay();
        windgoto(helprow = 0, 0);

longline(
"   Character Positioning\n"
"   =====================\n"
"      ^              first non-white\n"
"      0              beginning of line\n"
"      $              end of line\n"
"      h              backward\n");
longline(
"      l              forward\n"
"      ^H             same as h\n"
"      space          same as l\n"
"      fx             find 'x' forward\n");
longline(
"      Fx             find 'x' backward\n"
"      tx             upto 'x' forward\n"
"      Tx             upto 'x' backward\n"
"      ;              Repeat last f, F, t, or T\n");
longline(
"      ,              inverse of ;\n"
"      |              to specified column\n"
"      %              find matching (, ), {, }, [, or ]\n");

        windgoto(helprow = Rows-2, 47);
        longline("<Press space bar to continue>\n");
        windgoto(helprow = Rows-1, 47);
        longline("<Any other key will quit>");

        if ( vgetc() != ' ' )
                return TRUE;

/***********************************************************************
 * Third Screen:   Line Positioning, Marking and Returning
 ***********************************************************************/

        ClearDisplay();
        windgoto(helprow = 0, 0);

longline(
"    Line Positioning\n"
"    ================\n"
"    H           home window line\n"
"    L           last window line\n"
"    M           middle window line\n");
longline(
"    +           next line, at first non-white\n"
"    -           previous line, at first non-white\n"
"    CR          return, same as +\n"
"    j           next line, same column\n"
"    k           previous line, same column\n");

longline(
"\n"
"    Marking and Returning\n"
"    =====================\n"
"    ``          previous context\n"
"    ''          ... at first non-white in line\n");
longline(
"    mx          mark position with letter 'x'\n"
"    `x          to mark 'x'\n"
"    'x          ... at first non-white in line\n");

longline("\n"
"    Undo  &  Redo\n"
"    =============\n"
"    u           undo last change\n"
"    U           restore current line\n"
"    .           repeat last change\n");

        windgoto(helprow = Rows-2, 47);
        longline("<Press space bar to continue>\n");
        windgoto(helprow = Rows-1, 47);
        longline("<Any other key will quit>");

        if ( vgetc() != ' ' )
                return TRUE;
/***********************************************************************
 * Fourth Screen:   Insert & Replace,
 ***********************************************************************/

        ClearDisplay();
        windgoto(helprow = 0, 0);

longline(
"    Insert and Replace\n"
"    ==================\n"
"    a           append after cursor\n"
"    i           insert before cursor\n"
"    A           append at end of line\n"
"    I           insert before first non-blank\n");
longline(
"    o           open line below\n"
"    O           open line above\n"
"    rx          replace single char with 'x'\n"
"    R           replace characters\n");

longline(
"\n"
"    Words, sentences, paragraphs\n"
"    ============================\n"
"    w           word forward\n"
"    b           back word\n"
"    e           end of word\n"
"    )           to next sentence (not yet)\n"
"    }           to next paragraph (not yet)\n");
longline(
"    (           back sentence (not yet)\n"
"    {           back paragraph (not yet)\n"
"    W           blank delimited word\n"
"    B           back W\n"
"    E           to end of W\n");

        windgoto(helprow = Rows-2, 47);
        longline("<Press space bar to continue>\n");
        windgoto(helprow = Rows-1, 47);
        longline("<Any other key will quit>");

        if ( vgetc() != ' ' )
                return TRUE;

/***********************************************************************
 * Fifth Screen:   Misc. operations,
 ***********************************************************************/

        ClearDisplay();
        windgoto(helprow = 0, 0);

longline(
"    Miscellaneous Commands\n"
"    ======================\n");
longline(
"    :w          write back changes\n"
"    :wq         write and quit\n"
"    :x          write if modified, and quit\n"
"    :q          quit\n"
"    :q!         quit, discard changes\n"
"    :e name     edit file 'name'\n");
longline(
"    :e!         reedit, discard changes\n"
"    :e #        edit alternate file\n"
"    :w name     write file 'name'\n");
longline(
"    :n          edit next file in arglist\n"
"    :N          edit prior file in arglist\n"
"    :n args     specify new arglist (not yet)\n"
"    :rew        rewind arglist\n"
"    :f          show current file and lines\n");
longline(
"    :f file     change current file name\n"
"    :g/pat/p|d  global command (print or delete only)\n"
"    :s/p1/p2/   text substitution (trailing 'g' optional)\n"
"");
longline(
"    :ta tag     to tag file entry 'tag'\n"
"    ^]          :ta, current word is tag\n"
"    :sh         run an interactive shell\n"
"    :!cmd       execute a shell command\n"
"");

        windgoto(helprow = Rows-2, 47);
        longline("<Press space bar to continue>\n");
        windgoto(helprow = Rows-1, 47);
        longline("<Any other key will quit>");

        if ( vgetc() != ' ' )
                return TRUE;

/***********************************************************************
 * Sixth Screen:   Operators, Misc. operations, Yank & Put
 ***********************************************************************/

        ClearDisplay();
        windgoto(helprow = 0, 0);

longline(
"    Operators (double to affect lines)\n"
"    ==================================\n"
"    d           delete\n"
"    c           change\n");
longline(
"    <           left shift\n"
"    >           right shift\n"
"    y           yank to buffer\n"
"    !           filter lines\n");

longline("\n"
"    Miscellaneous operations\n"
"    ========================\n"
"    C           change rest of line\n"
"    D           delete rest of line\n"
"    s           substitute chars\n");
longline(
"    S           substitute lines (not yet)\n"
"    J           join lines\n"
"    x           delete characters\n"
"    X           ... before cursor\n");

longline("\n"
"    Yank and Put\n"
"    ============\n"
"    p           put back text\n"
"    P           put before\n"
"    Y           yank lines");

        windgoto(helprow = Rows-1, 47);
        longline("<Press any key>");

        (void) vgetc();

        return TRUE;
}

static void
longline(p)
char    *p;
{
        register char   *s;

        for ( s = p; *s ;s++ ) {
                if ( *s == '\n' )
                        windgoto(++helprow, 0);
                else
                        outchar(*s);
        }
}
#else

bool_t
help()
{
        msg("Sorry, help not configured");
        return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\fileio.c ===
/*
 *
 * Basic file I/O routines.
 */


#include "stevie.h"
#include <io.h>
#include <errno.h>

void
filemess(s)
char    *s;
{
        smsg("\"%s\" %s", (Filename == NULL) ? "" : Filename, s);
        flushbuf();
}

void
renum()
{
    LNPTR    *p;
        unsigned long l = 0;

        for (p = Filemem; p != NULL ;p = nextline(p), l += LINEINC)
                if (p->linep)
			p->linep->num = l;

        Fileend->linep->num = 0xffffffff;
}

#define MAXLINE 512     /* maximum size of a line */

bool_t
readfile(fname,fromp,nochangename)
char    *fname;
LNPTR    *fromp;
bool_t  nochangename;   /* if TRUE, don't change the Filename */
{
        FILE    *f;
        register LINE   *curr;
        char    buff[MAXLINE], buf2[80];
        register int    i, c;
        register long   nchars = 0;
        int     linecnt = 0;
        bool_t  wasempty = bufempty();
        int     nulls = 0;              /* count nulls */
        bool_t  incomplete = FALSE;     /* was the last line incomplete? */
        bool_t  toolong = FALSE;        /* a line was too long */
        int	ctoolong = 0;
        bool_t  readonly = FALSE;       /* file is not writable */

        curr = fromp->linep;

        if ( ! nochangename ) {
                Filename = strsave(fname);
                setviconsoletitle();
        }

        if((_access(fname,2) == -1) && (errno == EACCES)) {
            readonly = TRUE;
        }

        {
            char *FixedName = fixname(fname);
            if (!FixedName) {
                return TRUE;
            }

            if ( (f=fopen(FixedName,"r")) == NULL )
                return TRUE;
        }

        filemess("");

        i = 0;
        do {
                c = getc(f);

                if (c == EOF) {
                        if (i == 0)     /* normal loop termination */
                                break;

                        /*
                         * If we get EOF in the middle of a line, note the
                         * fact and complete the line ourselves.
                         */
                        incomplete = TRUE;
                        c = NL;
                }

                /*
                 * Abort if we get an interrupt, but finished reading the
                 * current line first.
                 */
                if (got_int && i == 0)
                        break;

                /*
                 * If we reached the end of the line, OR we ran out of
                 * space for it, then process the complete line.
                 */
                if (c == NL || i == (MAXLINE-1)) {
                        LINE    *lp;

                        if (c != NL) {
                                toolong = TRUE;
                                ctoolong++;
                        }

                        buff[i] = '\0';
                        if ((lp = newline(strlen(buff))) == NULL)
                                exit(1);

                        strcpy(lp->s, buff);

                        curr->next->prev = lp;  /* new line to next one */
                        lp->next = curr->next;

                        curr->next = lp;        /* new line to prior one */
                        lp->prev = curr;

                        curr = lp;              /* new line becomes current */
                        i = 0;
                        linecnt++;
                        if (toolong) {
                        	buff[i++] = (char)c;
                        	toolong = FALSE;
                        }

                } else if (c == NUL)
                        nulls++;                /* count and ignore nulls */
                else {
                        buff[i++] = (char)c;    /* normal character */
                }

                nchars++;

        } while (!incomplete);

        fclose(f);

        /*
         * If the buffer was empty when we started, we have to go back
         * and remove the "dummy" line at Filemem and patch up the ptrs.
         */
        if (wasempty && nchars != 0) {
                LINE    *dummy = Filemem->linep;        /* dummy line ptr */

                free(dummy->s);                         /* free string space */
                Filemem->linep = Filemem->linep->next;
                free((char *)dummy);                    /* free LINE struct */
                Filemem->linep->prev = Filetop->linep;
                Filetop->linep->next = Filemem->linep;

                Curschar->linep = Filemem->linep;
                Topchar->linep  = Filemem->linep;
        }

        renum();

        if (got_int) {
                smsg("\"%s\" Interrupt", fname);
                got_int = FALSE;
                return FALSE;           /* an interrupt isn't really an error */
        }

        if (ctoolong != 0) {
                smsg("\"%s\" %d Line(s) too long - split", fname, ctoolong);
                return FALSE;
        }

        sprintf(buff, "\"%s\" %s%s%d line%s, %ld character%s",
                fname,
                readonly ? "[Read only] " : "",
                incomplete ? "[Incomplete last line] " : "",
                linecnt, (linecnt != 1) ? "s" : "",
                nchars, (nchars != 1) ? "s" : "");

        buf2[0] = NUL;

        if (nulls) {
           sprintf(buf2, " (%d null)", nulls);
        }
        strcat(buff, buf2);
        msg(buff);

        return FALSE;
}


/*
 * writeit - write to file 'fname' lines 'start' through 'end'
 *
 * If either 'start' or 'end' contain null line pointers, the default
 * is to use the start or end of the file respectively.
 */
bool_t
writeit(fname, start, end)
char    *fname;
LNPTR    *start, *end;
{
        FILE    *f;
        FILE    *fopenb();              /* open in binary mode, where needed */
        char    *backup;
        register char   *s;
        register long   nchars;
        register int    lines;
        register LNPTR   *p;


        if((_access(fname,2) == -1) && (errno == EACCES)) {
            msg("Write access to file is denied");
            return FALSE;
        }

        smsg("\"%s\"", fname);

        /*
         * Form the backup file name - change foo.* to foo.bak
         */
        backup = alloc((unsigned) (strlen(fname) + 5));
        strcpy(backup, fname);
        for (s = backup; *s && *s != '.' ;s++)
                ;
        *s = NUL;
        strcat(backup, ".bak");

        /*
         * Delete any existing backup and move the current version
         * to the backup. For safety, we don't remove the backup
         * until the write has finished successfully. And if the
         * 'backup' option is set, leave it around.
         */
        rename(fname, backup);

        {
            char *FixedName = fixname(fname);
            if (!FixedName) {
                f= NULL;
            } else {
                f = P(P_CR) ? fopen(FixedName, "w") : fopenb(FixedName, "w");
            }
        }

        if (f == NULL) {
                emsg("Can't open file for writing!");
                free(backup);
                return FALSE;
        }

        /*
         * If we were given a bound, start there. Otherwise just
         * start at the beginning of the file.
         */
        if (start == NULL || start->linep == NULL)
                p = Filemem;
        else
                p = start;

        lines = nchars = 0;
        do {
                if (p->linep) {
	                if (fprintf(f, "%s\n", p->linep->s) < 0) {
	                    emsg("Can't write file!");
	                    return FALSE;
	                }
	                nchars += strlen(p->linep->s) + 1;
	                lines++;
	
                }
                /*
                 * If we were given an upper bound, and we just did that
                 * line, then bag it now.
                 */
                if (end != NULL && end->linep != NULL) {
                        if (end->linep == p->linep)
                                break;
                }

        } while ((p = nextline(p)) != NULL);

        fclose(f);
        smsg("\"%s\" %d line%s, %ld character%s", fname,
                lines, (lines > 1) ? "s" : "",
                nchars, (nchars > 1) ? "s" : "");

        UNCHANGED;

        /*
         * Remove the backup unless they want it left around
         */
        if (!P(P_BK))
                remove(backup);

        free(backup);

        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\keymap.h ===
/*
 *
 *
 * Keycode definitions for special keys
 *
 * On systems that have any of these keys, the routine 'inchar' in the
 * machine-dependent code should return one of the codes here.
 */

#define K_HOME          0x80
#define K_END           0x81
#define K_INSERT        0x82
#define K_DELETE        0x83
#define K_UARROW        0x84
#define K_DARROW        0x85
#define K_LARROW        0x86
#define K_RARROW        0x87
#define K_CGRAVE        0x88    /* control grave accent */
#define K_PAGEUP        0x89
#define K_PAGEDOWN      0x8a

#define K_F1            0x91    /* function keys */
#define K_F2            0x92
#define K_F3            0x93
#define K_F4            0x94
#define K_F5            0x95
#define K_F6            0x96
#define K_F7            0x97
#define K_F8            0x98
#define K_F9            0x99
#define K_F10           0x9a
#define K_F11           0x9b
#define K_F12           0x9c

#define K_SF1           0xa1    /* shifted function keys */
#define K_SF2           0xa2
#define K_SF3           0xa3
#define K_SF4           0xa4
#define K_SF5           0xa5
#define K_SF6           0xa6
#define K_SF7           0xa7
#define K_SF8           0xa8
#define K_SF9           0xa9
#define K_SF10          0xaa
#define K_SF11          0xab
#define K_SF12          0xac

/*
    for keyboard translation tables
*/

#define K_EN            K_END
#define K_HO            K_HOME
#define K_LE            K_LARROW
#define K_RI            K_RARROW
#define K_UP            K_UARROW
#define K_DO            K_DARROW
#define K_IN            K_INSERT
#define K_DE            K_DELETE
#define K_CG            K_CGRAVE
#define K_PU            K_PAGEUP
#define K_PD            K_PAGEDOWN

#define K_FA            K_F10
#define K_FB            K_F11
#define K_FC            K_F12

#define K_S1            K_SF1
#define K_S2            K_SF2
#define K_S3            K_SF3
#define K_S4            K_SF4
#define K_S5            K_SF5
#define K_S6            K_SF6
#define K_S7            K_SF7
#define K_S8            K_SF8
#define K_S9            K_SF9
#define K_SA            K_SF10
#define K_SB            K_SF11
#define K_SC            K_SF12
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\hexchars.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/hexchars.c,v 1.4 89/03/11 22:42:27 tony Exp $
 *
 * Contains information concerning the representation of characters for
 * visual output by the editor.
 */

#include "stevie.h"

/*
 * This file shows how to display characters on the screen. This is
 * approach is something of an overkill. It's a remnant from the
 * original code that isn't worth messing with for now. TABS are
 * special-cased depending on the value of the "list" parameter.
 */

struct charinfo chars[] = {
        /* 000 */       1, NULL,
        /* 001 */       2, "^A",
        /* 002 */       2, "^B",
        /* 003 */       2, "^C",
        /* 004 */       2, "^D",
        /* 005 */       2, "^E",
        /* 006 */       2, "^F",
        /* 007 */       2, "^G",
        /* 010 */       2, "^H",
        /* 011 */       2, "^I",
        /* 012 */       7, "[ERROR]",   /* shouldn't occur */
        /* 013 */       2, "^K",
        /* 014 */       2, "^L",
        /* 015 */       2, "^M",
        /* 016 */       2, "^N",
        /* 017 */       2, "^O",
        /* 020 */       2, "^P",
        /* 021 */       2, "^Q",
        /* 022 */       2, "^R",
        /* 023 */       2, "^S",
        /* 024 */       2, "^T",
        /* 025 */       2, "^U",
        /* 026 */       2, "^V",
        /* 027 */       2, "^W",
        /* 030 */       2, "^X",
        /* 031 */       2, "^Y",
        /* 032 */       2, "^Z",
        /* 033 */       2, "^[",
        /* 034 */       2, "^\\",
        /* 035 */       2, "^]",
        /* 036 */       2, "^^",
        /* 037 */       2, "^_",
        /* 040 */       1, NULL,
        /* 041 */       1, NULL,
        /* 042 */       1, NULL,
        /* 043 */       1, NULL,
        /* 044 */       1, NULL,
        /* 045 */       1, NULL,
        /* 046 */       1, NULL,
        /* 047 */       1, NULL,
        /* 050 */       1, NULL,
        /* 051 */       1, NULL,
        /* 052 */       1, NULL,
        /* 053 */       1, NULL,
        /* 054 */       1, NULL,
        /* 055 */       1, NULL,
        /* 056 */       1, NULL,
        /* 057 */       1, NULL,
        /* 060 */       1, NULL,
        /* 061 */       1, NULL,
        /* 062 */       1, NULL,
        /* 063 */       1, NULL,
        /* 064 */       1, NULL,
        /* 065 */       1, NULL,
        /* 066 */       1, NULL,
        /* 067 */       1, NULL,
        /* 070 */       1, NULL,
        /* 071 */       1, NULL,
        /* 072 */       1, NULL,
        /* 073 */       1, NULL,
        /* 074 */       1, NULL,
        /* 075 */       1, NULL,
        /* 076 */       1, NULL,
        /* 077 */       1, NULL,
        /* 100 */       1, NULL,
        /* 101 */       1, NULL,
        /* 102 */       1, NULL,
        /* 103 */       1, NULL,
        /* 104 */       1, NULL,
        /* 105 */       1, NULL,
        /* 106 */       1, NULL,
        /* 107 */       1, NULL,
        /* 110 */       1, NULL,
        /* 111 */       1, NULL,
        /* 112 */       1, NULL,
        /* 113 */       1, NULL,
        /* 114 */       1, NULL,
        /* 115 */       1, NULL,
        /* 116 */       1, NULL,
        /* 117 */       1, NULL,
        /* 120 */       1, NULL,
        /* 121 */       1, NULL,
        /* 122 */       1, NULL,
        /* 123 */       1, NULL,
        /* 124 */       1, NULL,
        /* 125 */       1, NULL,
        /* 126 */       1, NULL,
        /* 127 */       1, NULL,
        /* 130 */       1, NULL,
        /* 131 */       1, NULL,
        /* 132 */       1, NULL,
        /* 133 */       1, NULL,
        /* 134 */       1, NULL,
        /* 135 */       1, NULL,
        /* 136 */       1, NULL,
        /* 137 */       1, NULL,
        /* 140 */       1, NULL,
        /* 141 */       1, NULL,
        /* 142 */       1, NULL,
        /* 143 */       1, NULL,
        /* 144 */       1, NULL,
        /* 145 */       1, NULL,
        /* 146 */       1, NULL,
        /* 147 */       1, NULL,
        /* 150 */       1, NULL,
        /* 151 */       1, NULL,
        /* 152 */       1, NULL,
        /* 153 */       1, NULL,
        /* 154 */       1, NULL,
        /* 155 */       1, NULL,
        /* 156 */       1, NULL,
        /* 157 */       1, NULL,
        /* 160 */       1, NULL,
        /* 161 */       1, NULL,
        /* 162 */       1, NULL,
        /* 163 */       1, NULL,
        /* 164 */       1, NULL,
        /* 165 */       1, NULL,
        /* 166 */       1, NULL,
        /* 167 */       1, NULL,
        /* 170 */       1, NULL,
        /* 171 */       1, NULL,
        /* 172 */       1, NULL,
        /* 173 */       1, NULL,
        /* 174 */       1, NULL,
        /* 175 */       1, NULL,
        /* 176 */       1, NULL,
        /* 177 */       2, "^?",
        /* 200 */       2, "^?",
        /* 201 */       2, "^?",
        /* 202 */       2, "^?",
        /* 203 */       2, "^?",
        /* 204 */       2, "^?",
        /* 205 */       2, "^?",
        /* 206 */       2, "^?",
        /* 207 */       2, "^?",
        /* 210 */       2, "^?",
        /* 211 */       2, "^?",
        /* 212 */       2, "^?",
        /* 213 */       2, "^?",
        /* 214 */       2, "^?",
        /* 215 */       2, "^?",
        /* 216 */       2, "^?",
        /* 217 */       2, "^?",
        /* 220 */       2, "^?",
        /* 221 */       2, "^?",
        /* 222 */       2, "^?",
        /* 223 */       2, "^?",
        /* 224 */       2, "^?",
        /* 225 */       2, "^?",
        /* 226 */       2, "^?",
        /* 227 */       2, "^?",
        /* 230 */       2, "^?",
        /* 231 */       2, "^?",
        /* 232 */       2, "^?",
        /* 233 */       2, "^?",
        /* 234 */       2, "^?",
        /* 235 */       2, "^?",
        /* 236 */       2, "^?",
        /* 237 */       2, "^?",
        /* 240 */       2, "^?",
        /* 241 */       2, "^?",
        /* 242 */       2, "^?",
        /* 243 */       2, "^?",
        /* 244 */       2, "^?",
        /* 245 */       2, "^?",
        /* 246 */       2, "^?",
        /* 247 */       2, "^?",
        /* 250 */       2, "^?",
        /* 251 */       2, "^?",
        /* 252 */       2, "^?",
        /* 253 */       2, "^?",
        /* 254 */       2, "^?",
        /* 255 */       2, "^?",
        /* 256 */       2, "^?",
        /* 257 */       2, "^?",
        /* 260 */       2, "^?",
        /* 261 */       2, "^?",
        /* 262 */       2, "^?",
        /* 263 */       2, "^?",
        /* 264 */       2, "^?",
        /* 265 */       2, "^?",
        /* 266 */       2, "^?",
        /* 267 */       2, "^?",
        /* 270 */       2, "^?",
        /* 271 */       2, "^?",
        /* 272 */       2, "^?",
        /* 273 */       2, "^?",
        /* 274 */       2, "^?",
        /* 275 */       2, "^?",
        /* 276 */       2, "^?",
        /* 277 */       2, "^?",
        /* 300 */       2, "^?",
        /* 301 */       2, "^?",
        /* 302 */       2, "^?",
        /* 303 */       2, "^?",
        /* 304 */       2, "^?",
        /* 305 */       2, "^?",
        /* 306 */       2, "^?",
        /* 307 */       2, "^?",
        /* 310 */       2, "^?",
        /* 311 */       2, "^?",
        /* 312 */       2, "^?",
        /* 313 */       2, "^?",
        /* 314 */       2, "^?",
        /* 315 */       2, "^?",
        /* 316 */       2, "^?",
        /* 317 */       2, "^?",
        /* 320 */       2, "^?",
        /* 321 */       2, "^?",
        /* 322 */       2, "^?",
        /* 323 */       2, "^?",
        /* 324 */       2, "^?",
        /* 325 */       2, "^?",
        /* 326 */       2, "^?",
        /* 327 */       2, "^?",
        /* 330 */       2, "^?",
        /* 331 */       2, "^?",
        /* 332 */       2, "^?",
        /* 333 */       2, "^?",
        /* 334 */       2, "^?",
        /* 335 */       2, "^?",
        /* 336 */       2, "^?",
        /* 337 */       2, "^?",
        /* 340 */       2, "^?",
        /* 341 */       2, "^?",
        /* 342 */       2, "^?",
        /* 343 */       2, "^?",
        /* 344 */       2, "^?",
        /* 345 */       2, "^?",
        /* 346 */       2, "^?",
        /* 347 */       2, "^?",
        /* 350 */       2, "^?",
        /* 351 */       2, "^?",
        /* 352 */       2, "^?",
        /* 353 */       2, "^?",
        /* 354 */       2, "^?",
        /* 355 */       2, "^?",
        /* 356 */       2, "^?",
        /* 357 */       2, "^?",
        /* 360 */       2, "^?",
        /* 361 */       2, "^?",
        /* 362 */       2, "^?",
        /* 363 */       2, "^?",
        /* 364 */       2, "^?",
        /* 365 */       2, "^?",
        /* 366 */       2, "^?",
        /* 367 */       2, "^?",
        /* 370 */       2, "^?",
        /* 371 */       2, "^?",
        /* 372 */       2, "^?",
        /* 373 */       2, "^?",
        /* 374 */       2, "^?",
        /* 375 */       2, "^?",
        /* 376 */       2, "^?",
        /* 377 */       2, "^?"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\linefunc.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/linefunc.c,v 1.2 89/03/11 22:42:32 tony Exp $
 *
 * Basic line-oriented motions.
 */

#include "stevie.h"

/*
 * nextline(curr)
 *
 * Return a pointer to the beginning of the next line after the one
 * referenced by 'curr'. Return NULL if there is no next line (at EOF).
 */

LNPTR *
nextline(curr)
LNPTR    *curr;
{
    static  LNPTR    next;

        if (curr->linep && curr->linep->next != Fileend->linep) {
                next.index = 0;
                next.linep = curr->linep->next;
                return &next;
        }
    return (LNPTR *) NULL;
}

/*
 * prevline(curr)
 *
 * Return a pointer to the beginning of the line before the one
 * referenced by 'curr'. Return NULL if there is no prior line.
 */

LNPTR *
prevline(curr)
LNPTR    *curr;
{
    static  LNPTR    prev;

        if (curr->linep->prev != Filetop->linep) {
                prev.index = 0;
                prev.linep = curr->linep->prev;
                return &prev;
        }
    return (LNPTR *) NULL;
}

/*
 * coladvance(p,col)
 *
 * Try to advance to the specified column, starting at p.
 */

LNPTR *
coladvance(p, col)
LNPTR    *p;
register int    col;
{
        static  LNPTR    lp;
        register int    c, in;

        lp.linep = p->linep;
        lp.index = p->index;

        /* If we're on a blank ('\n' only) line, we can't do anything */
        if (lp.linep->s[lp.index] == '\0')
                return &lp;
        /* try to advance to the specified column */
        for ( c=0; col-- > 0; c++ ) {
                /* Count a tab for what it's worth (if list mode not on) */
                if ( gchar(&lp) == TAB && !P(P_LS) ) {
                        in = ((P(P_TS)-1) - c%P(P_TS));
                        col -= in;
                        c += in;
                }
                /* Don't go past the end of */
                /* the file or the line. */
                if (inc(&lp)) {
                        dec(&lp);
                        break;
                }
        }
        return &lp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\mark.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/mark.c,v 1.3 89/03/11 22:42:39 tony Exp $
 *
 * Routines to save and retrieve marks.
 */

#include "stevie.h"

#define	NMARKS	10		/* max. # of marks that can be saved */

struct	mark {
	char	name;
    LNPTR    pos;
};

static	struct	mark	mlist[NMARKS];
static	struct	mark	pcmark;		/* previous context mark */
static	bool_t	pcvalid = FALSE;	/* true if pcmark is valid */

/*
 * setmark(c) - set mark 'c' at current cursor position
 *
 * Returns TRUE on success, FALSE if no room for mark or bad name given.
 */
bool_t
setmark(c)
register char	c;
{
	register int	i;

	if (!isalpha(c))
		return FALSE;

	/*
	 * If there is already a mark of this name, then just use the
	 * existing mark entry.
	 */
	for (i=0; i < NMARKS ;i++) {
		if (mlist[i].name == c) {
			mlist[i].pos = *Curschar;
			return TRUE;
		}
	}

	/*
	 * There wasn't a mark of the given name, so find a free slot
	 */
	for (i=0; i < NMARKS ;i++) {
		if (mlist[i].name == NUL) {	/* got a free one */
			mlist[i].name = c;
			mlist[i].pos = *Curschar;
			return TRUE;
		}
	}
	return FALSE;
}

/*
 * setpcmark() - set the previous context mark to the current position
 */
void
setpcmark()
{
	pcmark.pos = *Curschar;
	pcvalid = TRUE;
}

/*
 * getmark(c) - find mark for char 'c'
 *
 * Return pointer to LNPTR or NULL if no such mark.
 */
LNPTR *
getmark(c)
register char	c;
{
	register int	i;

	if (c == '\'' || c == '`')	/* previous context mark */
        return pcvalid ? &(pcmark.pos) : (LNPTR *) NULL;

	for (i=0; i < NMARKS ;i++) {
		if (mlist[i].name == c)
			return &(mlist[i].pos);
	}
    return (LNPTR *) NULL;
}

/*
 * clrall() - clear all marks
 *
 * Used mainly when trashing the entire buffer during ":e" type commands
 */
void
clrall()
{
	register int	i;

	for (i=0; i < NMARKS ;i++)
		mlist[i].name = NUL;
	pcvalid = FALSE;
}

/*
 * clrmark(line) - clear any marks for 'line'
 *
 * Used any time a line is deleted so we don't have marks pointing to
 * non-existent lines.
 */
void
clrmark(line)
register LINE	*line;
{
	register int	i;

	for (i=0; i < NMARKS ;i++) {
		if (mlist[i].pos.linep == line)
			mlist[i].name = NUL;
	}
	if (pcvalid && (pcmark.pos.linep == line))
		pcvalid = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\normal.c ===
/*
 *
 * Contains the main routine for processing characters in command mode.
 * Communicates closely with the code in ops.c to handle the operators.
 */

#include "stevie.h"
#include "ops.h"

/*
 * Generally speaking, every command in normal() should either clear any
 * pending operator (with CLEAROP), or set the motion type variable.
 */

#define CLEAROP (operator=NOP, namedbuff = -1)  /* clear any pending operator */

int     operator = NOP;         /* current pending operator */
int     mtype;                  /* type of the current cursor motion */
bool_t  mincl;                  /* true if char motion is inclusive */
LNPTR    startop;        /* cursor pos. at start of operator */

/*
 * Operators can have counts either before the operator, or between the
 * operator and the following cursor motion as in:
 *
 *      d3w or 3dw
 *
 * If a count is given before the operator, it is saved in opnum. If
 * normal() is called with a pending operator, the count in opnum (if
 * present) overrides any count that came later.
 */
static  int     opnum = 0;

#define DEFAULT1(x)     (((x) == 0) ? 1 : (x))

void HighlightCheck();

/*
 * normal(c)
 *
 * Execute a command in command mode.
 *
 * This is basically a big switch with the cases arranged in rough categories
 * in the following order:
 *
 *      1. File positioning commands
 *      2. Control commands (e.g. ^G, Z, screen redraw, etc)
 *      3. Character motions
 *      4. Search commands (of various kinds)
 *      5. Edit commands (e.g. J, x, X)
 *      6. Insert commands (e.g. i, o, O, A)
 *      7. Operators
 *      8. Abbreviations (e.g. D, C)
 *      9. Marks
 */
void
normal(c)
register int    c;
{
        register int    n;
        register char   *s;     /* temporary variable for misc. strings */
        bool_t  flag = FALSE;
        int     type = 0;       /* used in some operations to modify type */
        int     dir = FORWARD;  /* search direction */
        int     nchar = NUL;
        bool_t  finish_op;

        /*
         * If there is an operator pending, then the command we take
         * this time will terminate it. Finish_op tells us to finish
         * the operation before returning this time (unless the operation
         * was cancelled.
         */
        finish_op = (operator != NOP);

        /*
         * If we're in the middle of an operator AND we had a count before
         * the operator, then that count overrides the current value of
         * Prenum. What this means effectively, is that commands like
         * "3dw" get turned into "d3w" which makes things fall into place
         * pretty neatly.
         */
        if (finish_op) {
                if (opnum != 0)
                        Prenum = opnum;
        } else {
                opnum = 0;
        }

        u_lcheck();     /* clear the "line undo" buffer if we've moved */
        HighlightCheck();

        switch (c & 0xff) {

        /*
         * named buffer support
         */

        case('"'):
            // not allowed anywhere but at the beginning of a command
            if(finish_op || !isalpha(namedbuff = vgetc())) {
                CLEAROP;
                beep();
            } else {
            }
            break;

        /*
         * Screen positioning commands
         */
        case CTRL('D'):
                CLEAROP;
                if (Prenum)
                        P(P_SS) = (Prenum > Rows-1) ? Rows-1 : Prenum;
                scrollup(P(P_SS));
                onedown(P(P_SS));
                updatescreen();
                break;

        case CTRL('U'):
                CLEAROP;
                if (Prenum)
                        P(P_SS) = (Prenum > Rows-1) ? Rows-1 : Prenum;
                scrolldown(P(P_SS));
                oneup(P(P_SS));
                updatescreen();
                break;

        /*
         * This is kind of a hack. If we're moving by one page, the calls
         * to stuffin() do exactly the right thing in terms of leaving
         * some context, and so on. If a count was given, we don't have
         * to worry about these issues.
         */
        case K_PAGEDOWN:
        case CTRL('F'):
                CLEAROP;
                n = DEFAULT1(Prenum);
                if (n > 1) {
                        if ( ! onedown(Rows * n) )
                                beep();
                        cursupdate();
                } else {
                        screenclear();
                        stuffin("Lz\nM");
                }
                break;

        case K_PAGEUP:
        case CTRL('B'):
                CLEAROP;
                n = DEFAULT1(Prenum);
                if (n > 1) {
                        if ( ! oneup(Rows * n) )
                                beep();
                        cursupdate();
                } else {
                        screenclear();
                        stuffin("Hz-M");
                }
                break;

        case CTRL('E'):
                CLEAROP;
                scrollup(DEFAULT1(Prenum));
                updatescreen();
                break;

        case CTRL('Y'):
                CLEAROP;
                scrolldown(DEFAULT1(Prenum));
                updatescreen();
                break;

        case 'z':
                CLEAROP;
                switch (vgetc()) {
                case NL:                /* put Curschar at top of screen */
                case CR:
                        *Topchar = *Curschar;
                        Topchar->index = 0;
                        updatescreen();
                        break;

                case '.':               /* put Curschar in middle of screen */
                        n = Rows/2;
                        goto dozcmd;

                case '-':               /* put Curschar at bottom of screen */
                        n = Rows-1;
                        /* fall through */

                dozcmd:
                        {
                register LNPTR   *lp = Curschar;
                                register int    l = 0;

                                while ((l < n) && (lp != NULL)) {
                                        l += plines(lp);
                                        *Topchar = *lp;
                                        lp = prevline(lp);
                                }
                        }
                        Topchar->index = 0;
                        updatescreen();
                        break;

                default:
                        beep();
                }
                break;

        /*
         * Control commands
         */
        case ':':
                CLEAROP;
                if ((s = getcmdln(c)) != NULL)
                        docmdln(s);
                break;

        case CTRL('L'):
                CLEAROP;
                screenclear();
                updatescreen();
                break;


        case CTRL('O'):                 /* ignored */
                /*
                 * A command that's ignored can be useful. We use it at
                 * times when we want to postpone redraws. By stuffing
                 * in a control-o, redraws get suspended until the editor
                 * gets back around to processing input.
                 */
                break;

        case CTRL('G'):
                CLEAROP;
                fileinfo();
                break;

        case K_CGRAVE:                  /* shorthand command */
                CLEAROP;
                stuffin(":e #\n");
                break;

        case 'Z':                       /* write, if changed, and exit */
                if (vgetc() != 'Z') {
                        beep();
                        break;
                }
                doxit();
                break;

        /*
         * Macro evaluates true if char 'c' is a valid identifier character
         */
#       define  IDCHAR(c)       (isalpha(c) || isdigit(c) || (c) == '_')

        case CTRL(']'):                 /* :ta to current identifier */
                CLEAROP;
                {
                        char    ch;
                        LNPTR    save;

                        save = *Curschar;
                        /*
                         * First back up to start of identifier. This
                         * doesn't match the real vi but I like it a
                         * little better and it shouldn't bother anyone.
                         */
                        ch = (char)gchar(Curschar);
                        while (IDCHAR(ch)) {
                                if (!oneleft())
                                        break;
                                ch = (char)gchar(Curschar);
                        }
                        if (!IDCHAR(ch))
                                oneright();

                        stuffin(":ta ");
                        /*
                         * Now grab the chars in the identifier
                         */
                        ch = (char)gchar(Curschar);
                        while (IDCHAR(ch)) {
                                stuffin(mkstr(ch));
                                if (!oneright())
                                        break;
                                ch = (char)gchar(Curschar);
                        }
                        stuffin("\n");

                        *Curschar = save;       /* restore, in case of error */
                }
                break;

        /*
         * Character motion commands
         */
        case 'G':
                mtype = MLINE;
                *Curschar = *gotoline(Prenum);
                beginline(TRUE);
                break;

        case 'H':
                mtype = MLINE;
                *Curschar = *Topchar;
                for (n = Prenum; n && onedown(1) ;n--)
                        ;
                beginline(TRUE);
                break;

        case 'M':
                mtype = MLINE;
                *Curschar = *Topchar;
                for (n = 0; n < Rows/2 && onedown(1) ;n++)
                        ;
                beginline(TRUE);
                break;

        case 'L':
                mtype = MLINE;
                *Curschar = *prevline(Botchar);
                for (n = Prenum; n && oneup(1) ;n--)
                        ;
                beginline(TRUE);
                break;

        case 'l':
        case K_RARROW:
        case ' ':
                mtype = MCHAR;
                mincl = FALSE;
                n = DEFAULT1(Prenum);
                while (n--) {
                        if ( ! oneright() )
                                beep();
                }
                set_want_col = TRUE;
                break;

        case 'h':
        case K_LARROW:
        case CTRL('H'):
                mtype = MCHAR;
                mincl = FALSE;
                n = DEFAULT1(Prenum);
                while (n--) {
                        if ( ! oneleft() )
                                beep();
                }
                set_want_col = TRUE;
                break;

        case '-':
                flag = TRUE;
                /* fall through */

        case 'k':
        case K_UARROW:
        case CTRL('P'):
                mtype = MLINE;
                if ( ! oneup(DEFAULT1(Prenum)) )
                        beep();
                if (flag)
                        beginline(TRUE);
                break;

        case '+':
        case CR:
        case NL:
                flag = TRUE;
                /* fall through */

        case 'j':
        case K_DARROW:
        case CTRL('N'):
                mtype = MLINE;
                if ( ! onedown(DEFAULT1(Prenum)) )
                        beep();
                if (flag)
                        beginline(TRUE);
                break;

        /*
         * This is a strange motion command that helps make operators
         * more logical. It is actually implemented, but not documented
         * in the real 'vi'. This motion command actually refers to "the
         * current line". Commands like "dd" and "yy" are really an alternate
         * form of "d_" and "y_". It does accept a count, so "d3_" works to
         * delete 3 lines.
         */
        case '_':
        lineop:
                mtype = MLINE;
                onedown(DEFAULT1(Prenum)-1);
                break;

        case '|':
                mtype = MCHAR;
                mincl = TRUE;
                beginline(FALSE);
                if (Prenum > 0)
                        *Curschar = *coladvance(Curschar, Prenum-1);
                Curswant = Prenum - 1;
                break;

        /*
         * Word Motions
         */

        case 'B':
                type = 1;
                /* fall through */

        case 'b':
                mtype = MCHAR;
                mincl = FALSE;
                set_want_col = TRUE;
                for (n = DEFAULT1(Prenum); n > 0 ;n--) {
            LNPTR    *pos;

                        if ((pos = bck_word(Curschar, type)) == NULL) {
                                beep();
                                CLEAROP;
                                break;
                        } else
                                *Curschar = *pos;
                }
                break;

        case 'W':
                type = 1;
                /* fall through */

        case 'w':
                /*
                 * This is a little strange. To match what the real vi
                 * does, we effectively map 'cw' to 'ce', and 'cW' to 'cE'.
                 * This seems impolite at first, but it's really more
                 * what we mean when we say 'cw'.
                 */
                if (operator == CHANGE)
                        goto doecmd;

                mtype = MCHAR;
                mincl = FALSE;
                set_want_col = TRUE;
                for (n = DEFAULT1(Prenum); n > 0 ;n--) {
                        LNPTR    *pos;

                        if ((pos = fwd_word(Curschar, type)) == NULL) {
                                beep();
                                CLEAROP;
                                break;
                        } else
                                *Curschar = *pos;
                }
                break;

        case 'E':
                type = 1;
                /* fall through */

        case 'e':
        doecmd:
                mtype = MCHAR;
                mincl = TRUE;
                set_want_col = TRUE;
                for (n = DEFAULT1(Prenum); n > 0 ;n--) {
            LNPTR    *pos;

                        /*
                         * The first motion gets special treatment if we're
                         * do a 'CHANGE'.
                         */
                        if (n == DEFAULT1(Prenum))
                                pos = end_word(Curschar,type,operator==CHANGE);
                        else
                                pos = end_word(Curschar, type, FALSE);

                        if (pos == NULL) {
                                beep();
                                CLEAROP;
                                break;
                        } else
                                *Curschar = *pos;
                }
                break;

        case '$':
                mtype = MCHAR;
                mincl = TRUE;
                while ( oneright() )
                        ;
                Curswant = 999;         /* so we stay at the end */
                break;

        case '^':
                mtype = MCHAR;
                mincl = FALSE;
                beginline(TRUE);
                break;

        case '0':
                mtype = MCHAR;
                mincl = TRUE;
                beginline(FALSE);
                break;

        /*
         * Searches of various kinds
         */
        case '?':
        case '/':
                s = getcmdln(c);        /* get the search string */

                /*
                 * If they backspaced out of the search command,
                 * just bag everything.
                 */
                if (s == NULL) {
                        CLEAROP;
                        break;
                }

                mtype = MCHAR;
                mincl = FALSE;
                set_want_col = TRUE;

                /*
                 * If no string given, pass NULL to repeat the prior search.
                 * If the search fails, abort any pending operator.
                 */
                if (!dosearch(
                                (c == '/') ? FORWARD : BACKWARD,
                                (*s == NUL) ? NULL : s
                             ))
                        CLEAROP;
                break;

        case 'n':
                mtype = MCHAR;
                mincl = FALSE;
                set_want_col = TRUE;
                if (!repsearch(0))
                        CLEAROP;
                break;

        case 'N':
                mtype = MCHAR;
                mincl = FALSE;
                set_want_col = TRUE;
                if (!repsearch(1))
                        CLEAROP;
                break;

        /*
         * Character searches
         */
        case 'T':
                dir = BACKWARD;
                /* fall through */

        case 't':
                type = 1;
                goto docsearch;

        case 'F':
                dir = BACKWARD;
                /* fall through */

        case 'f':
        docsearch:
                mtype = MCHAR;
                mincl = TRUE;
                set_want_col = TRUE;
                if ((nchar = vgetc()) == ESC)   /* search char */
                        break;

                for (n = DEFAULT1(Prenum); n > 0 ;n--) {
                        if (!searchc(nchar, dir, type)) {
                                CLEAROP;
                                beep();
                        }
                }
                break;

        case ',':
                flag = 1;
                /* fall through */

        case ';':
                mtype = MCHAR;
                mincl = TRUE;
                set_want_col = TRUE;
                for (n = DEFAULT1(Prenum); n > 0 ;n--) {
                        if (!crepsearch(flag)) {
                                CLEAROP;
                                beep();
                        }
                }
                break;

        case '[':                       /* function searches */
                dir = BACKWARD;
                /* fall through */

        case ']':
                mtype = MLINE;
                set_want_col = TRUE;
                if (vgetc() != c) {
                        beep();
                        CLEAROP;
                        break;
                }

                if (!findfunc(dir)) {
                        beep();
                        CLEAROP;
                }
                break;

        case '%':
        {
                char   initc;
                LNPTR *pos;
                LNPTR  save;
                int    done = 0;

                mtype = MCHAR;
                mincl = TRUE;

                save = *Curschar;  /* save position in case we fail */
                while (!done) {
                        initc = (char)gchar(Curschar);
                        switch (initc) {
                        case '(':
                        case ')':
                        case '{':
                        case '}':
                        case '[':
                        case ']':

                                //
                                // Currently on a showmatch character.
                                //

                                done = 1;
                                break;
                        default:

                                //
                                // Didn't find anything try next character.
                                //

                                if (oneright() == FALSE) {

                                        //
                                        // no more on the line.  Restore
                                        // location and let the showmatch()
                                        // call fail and beep the user.
                                        //

                                        *Curschar = save;
                                        done = 1;
                                }
                                break;
                        }
                }

                if ((pos = showmatch()) == NULL) {
                        beep();
                        CLEAROP;
                } else {
                        setpcmark();
                        *Curschar = *pos;
                        set_want_col = TRUE;
                }
                break;
        }

        /*
         * Edits
         */
        case '.':               /* repeat last change (usually) */
                /*
                 * If a delete is in effect, we let '.' help out the same
                 * way that '_' helps for some line operations. It's like
                 * an 'l', but subtracts one from the count and is inclusive.
                 */
                if (operator == DELETE || operator == CHANGE) {
                        if (Prenum != 0) {
                                n = DEFAULT1(Prenum) - 1;
                                while (n--)
                                        if (! oneright())
                                                break;
                        }
                        mtype = MCHAR;
                        mincl = TRUE;
                } else {                        /* a normal 'redo' */
                        CLEAROP;
                        stuffin(Redobuff);
                }
                break;

        case 'u':
                CLEAROP;
                u_undo();
                break;

        case 'U':
                CLEAROP;
                u_lundo();
                break;

        case 'x':
                CLEAROP;
                if (lineempty())        /* can't do it on a blank line */
                        beep();
                if (Prenum)
                        stuffnum(Prenum);
                stuffin("d.");
                break;

        case 'X':
                CLEAROP;
                if (!oneleft())
                        beep();
                else {
                        u_saveline();
	                if (Prenum) {
	                	int i=Prenum;
		                sprintf(Redobuff, "%dX", i);
	                	while (--i)
	                		oneleft();
	                        stuffnum(Prenum);
		                stuffin("d.");
	                }
			else {
	                        strcpy(Redobuff, "X");
				delchar(TRUE);
	                        updateline();
	                }
                }
                break;

        case 'r':
                CLEAROP;
                if (lineempty()) {      /* Nothing to replace */
                        beep();
                        break;
                }
                if ((nchar = vgetc()) == ESC)
                        break;

                if ((nchar & 0x80) || nchar == CR || nchar == NL) {
                        beep();
                        break;
                }
                u_saveline();

                /* Change current character. */
                pchar(Curschar, nchar);

                /* Save stuff necessary to redo it */
                sprintf(Redobuff, "r%c", nchar);

                CHANGED;
                updateline();
                break;

        case '~':               /* swap case */
                if (!P(P_TO)) {
                        CLEAROP;
                        if (lineempty()) {
                                beep();
                                break;
                        }
                        c = gchar(Curschar);

                        if (isalpha(c)) {
                                if (islower(c))
                                        c = toupper(c);
                                else
                                        c = tolower(c);
                        }
                        u_saveline();

                        pchar(Curschar, c);     /* Change current character. */
                        oneright();

                        strcpy(Redobuff, "~");

                        CHANGED;
                        updateline();
                }
#ifdef  TILDEOP
                else {
                        if (operator == TILDE)          /* handle '~~' */
                                goto lineop;
                        if (Prenum != 0)
                                opnum = Prenum;
                        startop = *Curschar;
                        operator = TILDE;
                }
#endif

                break;

        case 'J':
                CLEAROP;

                u_save(Curschar->linep->prev, Curschar->linep->next->next);

                if (!dojoin(TRUE))
                        beep();

                strcpy(Redobuff, "J");
                updatescreen();
                break;

        /*
         * Inserts
         */
        case 'A':
                set_want_col = TRUE;
                while (oneright())
                        ;
                /* fall through */

        case 'a':
                CLEAROP;
                /* Works just like an 'i'nsert on the next character. */
                if (!lineempty())
                        inc(Curschar);
                u_saveline();
                startinsert(mkstr(c), FALSE);
                break;

        case 'I':
                beginline(TRUE);
                /* fall through */

        case 'i':
        case K_INSERT:
                CLEAROP;
                u_saveline();
                startinsert(mkstr(c), FALSE);
                break;

        case 'o':
                CLEAROP;
                u_save(Curschar->linep, Curschar->linep->next);
                opencmd(FORWARD, TRUE);
                startinsert("o", TRUE);
                break;

        case 'O':
                CLEAROP;
                u_save(Curschar->linep->prev, Curschar->linep);
                opencmd(BACKWARD, TRUE);
                startinsert("O", TRUE);
                break;

        case 'R':
                CLEAROP;
                u_saveline();
                startinsert("R", FALSE);
                break;

        /*
         * Operators
         */
        case 'd':
                if (operator == DELETE)         /* handle 'dd' */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = DELETE;
                break;

        case 'c':
                if (operator == CHANGE)         /* handle 'cc' */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = CHANGE;
                break;

        case 'y':
                if (operator == YANK)           /* handle 'yy' */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = YANK;
                break;

        case '>':
                if (operator == RSHIFT)         /* handle >> */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = RSHIFT;
                break;

        case '<':
                if (operator == LSHIFT)         /* handle << */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;    /* save current position */
                operator = LSHIFT;
                break;

        case '!':
                if (operator == FILTER)         /* handle '!!' */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = FILTER;
                break;

        case 'p':
                doput(FORWARD);
                break;

        case 'P':
                doput(BACKWARD);
                break;

        case 'v':
                if (operator == LOWERCASE)         /* handle 'vv' */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = LOWERCASE;
                break;

        case 'V':
                if (operator == UPPERCASE)         /* handle 'VV' */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = UPPERCASE;
                break;

        /*
         * Abbreviations
         */
        case 'D':
                stuffin("d$");
                break;

        case 'Y':
                if (Prenum)
                        stuffnum(Prenum);
                stuffin("yy");
                break;

        case 'C':
                stuffin("c$");
                break;

        case 's':                               /* substitute characters */
                if (Prenum)
                        stuffnum(Prenum);
                stuffin("c.");
                break;

        /*
         * Marks
         */
        case 'm':
                CLEAROP;
                if (!setmark(vgetc()))
                        beep();
                break;

        case '\'':
                flag = TRUE;
                /* fall through */

        case '`':
                {
            LNPTR    mtmp, *mark = getmark(vgetc());

                        if (mark == NULL) {
                                beep();
                                CLEAROP;
                        } else {
                                mtmp = *mark;
                                setpcmark();
                                *Curschar = mtmp;
                                if (flag)
                                        beginline(TRUE);
                        }
                        mtype = flag ? MLINE : MCHAR;
                        mincl = TRUE;           /* ignored if not MCHAR */
                        set_want_col = TRUE;
                }
                break;

        default:
                CLEAROP;
                beep();
                break;
        }

        /*
         * If an operation is pending, handle it...
         */
        if (finish_op) {                /* we just finished an operator */
                if (operator == NOP)    /* ... but it was cancelled */
                        return;

                switch (operator) {

                case LSHIFT:
                case RSHIFT:
                        doshift(operator, c, nchar, Prenum);
                        break;

                case DELETE:
                        dodelete(c, nchar, Prenum);
                        break;

                case YANK:
                        (void) doyank();        /* no redo on yank... */
                        break;

                case CHANGE:
                        dochange(c, nchar, Prenum);
                        break;

                case FILTER:
                        dofilter(c, nchar, Prenum);
                        break;

#ifdef  TILDEOP
                case TILDE:
                        dotilde(c, nchar, Prenum);
                        break;
#endif

                case LOWERCASE:
                case UPPERCASE:
                        docasechange((char)c,
                                     (char)nchar,
                                     Prenum,
                                     operator == UPPERCASE);
                        break;

                default:
                        beep();
                }
                operator = NOP;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\nt.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/os2.c,v 1.7 89/08/07 05:49:19 tony Exp $
 *
 * NT System-dependent routines.
 */

/*
 * Revision history:
 *
 *      6/1/93 - Joe Mitchell
 *      Add support to create a new screen buffer. This fixes the
 *      problem of scrolling the number of lines that "screen buffer size
 *      height" is set to when a vertical scroll bar is present.
 *      Allow filenames longer than 8.3 for use with HPFS/NTFS.
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <signal.h>
#include <conio.h>
#include <io.h>
#include <direct.h>
#undef max
#undef min
#include "stevie.h"

#define     MAX_VK   0x7f
#define     UCHR     unsigned char      // so table looks nice


UCHR RegularTable[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 08 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 10 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 18 */  0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00,
              /* 20 */  0x00, K_PU, K_PD, K_EN, K_HO, K_LE, K_UP, K_RI,
              /* 28 */  K_DO, 0x00, 0x00, 0x00, 0x00, K_IN, K_DE, 0x00,
              /* 30 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 38 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 40 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 48 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 50 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 58 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 60 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 68 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 70 */  K_F1, K_F2, K_F3, K_F4, K_F5, K_F6, K_F7, K_F8,
              /* 78 */  K_F9, K_FA, K_FB, K_FC, 0x00, 0x00, 0x00, 0x00 };

UCHR ShiftedTable[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 08 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 10 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 18 */  0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00,
              /* 20 */  0x00, K_PU, K_PD, K_EN, K_HO, K_LE, K_UP, K_RI,
              /* 28 */  K_DO, 0x00, 0x00, 0x00, 0x00, K_IN, K_DE, 0x00,
              /* 30 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 38 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 40 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 48 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 50 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 58 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 60 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 68 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 70 */  K_S1, K_S2, K_S3, K_S4, K_S5, K_S6, K_S7, K_S8,
              /* 78 */  K_S9, K_SA, K_SB, K_SC, 0x00, 0x00, 0x00, 0x00 };

UCHR ControlTable[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 08 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 10 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 18 */  0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, K_CG, 0x00,
              /* 20 */  0x00, K_PU, K_PD, K_EN, K_HO, K_LE, K_UP, K_RI,
              /* 28 */  K_DO, 0x00, 0x00, 0x00, 0x00, K_IN, K_DE, 0x00,
              /* 30 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 38 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 40 */  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
              /* 48 */  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
              /* 50 */  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
              /* 58 */  0x18, 0x19, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 60 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 68 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 70 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 78 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

#define ALT_PRESSED (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)
#define CTL_PRESSED (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)
#define CONTROL_ALT (ALT_PRESSED | CTL_PRESSED)

#define OMODE (ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT)
static HANDLE CurrConsole;
static HANDLE ViConsole,ConsoleIn;
static HANDLE PrevConsole; // [jrm 6/93] Save previous screen buffer
static DWORD OldConsoleMode;
static DWORD ViConsoleInputMode;

/*
 * inchar() - get a character from the keyboard
 */
int
inchar()
{
    INPUT_RECORD    InputRec;
    DWORD           NumRead;

    got_int = FALSE;

    flushbuf(); /* flush any pending output */

    while(1) {    /* loop until we get a valid console event */

        ReadConsoleInput(ConsoleIn,&InputRec,1,&NumRead);
        if((InputRec.EventType == KEY_EVENT)
        && (InputRec.Event.KeyEvent.bKeyDown))
        {
            KEY_EVENT_RECORD *KE = &InputRec.Event.KeyEvent;
            unsigned char *Table;

            if(KE->dwControlKeyState & ALT_PRESSED) {
                continue;       // no ALT keys allowed.
            } else if(KE->dwControlKeyState & CTL_PRESSED) {
                Table = ControlTable;
            } else if(KE->uChar.AsciiChar) {    // no control, no alt
                return(KE->uChar.AsciiChar);
            } else if(KE->dwControlKeyState & SHIFT_PRESSED) {
                Table = ShiftedTable;
            } else {
                Table = RegularTable;
            }

            if((KE->wVirtualKeyCode > MAX_VK) || !Table[KE->wVirtualKeyCode]) {
                continue;
            }
            return(Table[KE->wVirtualKeyCode]);
        }
    }
}

#if 0
        switch (c = _getch()) {
        case 0x1e:
            return K_CGRAVE;
        case 0:             /* special key */
            if (State != NORMAL) {
                c = _getch();    /* throw away next char */
                continue;   /* and loop for another char */
            }
            switch (c = _getch()) {
            case 0x50:
                return K_DARROW;
            case 0x48:
                return K_UARROW;
            case 0x4b:
                return K_LARROW;
            case 0x4d:
                return K_RARROW;
            case 0x52:
                return K_INSERT;
            case 0x47:
                stuffin("1G");
                return -1;
            case 0x4f:
                stuffin("G");
                return -1;
            case 0x51:
                stuffin(mkstr(CTRL('F')));
                return -1;
            case 0x49:
                stuffin(mkstr(CTRL('B')));
                return -1;
            /*
             * Hard-code some useful function key macros.
             */
            case 0x3b: /* F1 */
                stuffin(":N\n");
                return -1;
            case 0x54: /* SF1 */
                stuffin(":N!\n");
                return -1;
            case 0x3c: /* F2 */
                stuffin(":n\n");
                return -1;
            case 0x55: /* SF2 */
                stuffin(":n!\n");
                return -1;
            case 0x3d: /* F3 */
                stuffin(":e #\n");
                return -1;
            case 0x3e: /* F4 */
                stuffin(":rew\n");
                return -1;
            case 0x57: /* SF4 */
                stuffin(":rew!\n");
                return -1;
            case 0x3f: /* F5 */
                stuffin("[[");
                return -1;
            case 0x40: /* F6 */
                stuffin("]]");
                return -1;
            case 0x41: /* F7 - explain C declaration */
                stuffin("yyp^iexplain \033!!cdecl\n");
                return -1;
            case 0x42: /* F8 - declare C variable */
                stuffin("yyp!!cdecl\n");
                return -1;
            case 0x43: /* F9 */
                stuffin(":x\n");
                return -1;
            case 0x44: /* F10 */
                stuffin(":help\n");
                return -1;
            default:
                break;
            }
            break;

        default:
            return c;
        }
    }
}
#endif

#define BSIZE   2048
static  char    outbuf[BSIZE];
static  int bpos = 0;
DWORD CursorSize;
DWORD OrgCursorSize;

void
flushbuf()
{
    BOOL st;     // [jrm 6/93]
    DWORD count; // [jrm 6/93]

    //
    // [jrm 6/93] Use WriteFile rather than "write" to take advantage of
    // new screen buffer.
    //
    if (bpos != 0) {
//jrm   write(1, outbuf, bpos);
        st = WriteFile(CurrConsole, outbuf, bpos, &count, NULL);
        if (!st) {
            fprintf(stderr, "vi: Error calling WriteFile");
        }
    }

    bpos = 0;
}

/*
 * Macro to output a character. Used within this file for speed.
 */
#define outone(c)   outbuf[bpos++] = c; if (bpos >= BSIZE) flushbuf()

/*
 * Function version for use outside this file.
 */
void
outchar(c)
register char   c;
{
    outbuf[bpos++] = c;
    if (bpos >= BSIZE)
        flushbuf();
}

/*
 * outstr(s) - write a string to the console
 */
void
outstr(s)
register char   *s;
{
    while (*s) {
        outone(*s++);
    }
}

void
beep()
{
	Beep(500,50);      // 500Hz for 1/4 sec
}

void sleep(n)
int n;
{
    Sleep(1000L * n);
}

void
delay()
{
    flushbuf();
    Sleep(300L);
}

void
sig()
{
//  signal(SIGINT, sig);

    got_int = TRUE;
}

WORD  Attribute;
WORD  HighlightAttribute;

void
useviconsole()
{
    flushbuf();

    SetConsoleActiveScreenBuffer(CurrConsole = ViConsole);
    CursorSize = P(P_CS);
    VisibleCursor();
    FlushConsoleInputBuffer(ConsoleIn);
    SetConsoleMode(ConsoleIn,ViConsoleInputMode);
}

void
usecmdconsole()
{
    flushbuf();

    SetConsoleActiveScreenBuffer(CurrConsole = PrevConsole);
    CursorSize = OrgCursorSize;
    VisibleCursor();
    FlushConsoleInputBuffer(ConsoleIn);
    SetConsoleMode(ConsoleIn,OldConsoleMode);
}

void
windinit()
{
    COORD coord;
    CONSOLE_SCREEN_BUFFER_INFO Info;
    CONSOLE_CURSOR_INFO Info2;
    DWORD NumRead;

    ConsoleIn=GetStdHandle(STD_INPUT_HANDLE);

    //
    // [jrm 6/93] Create a new screen buffer. This fixes the scroll problem
    // when there is a vertical scroll bar.
    //
    PrevConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    CurrConsole =
    ViConsole = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                                          NULL,
                                          CONSOLE_TEXTMODE_BUFFER,
                                          NULL);
    if (ViConsole == INVALID_HANDLE_VALUE) {
        printf("CreateConsoleScreenBuffer failed in windinit\n");
        printf("LastError = 0x%lx\n", GetLastError());
        exit(0);
    }
    SetConsoleActiveScreenBuffer(ViConsole);
    SetConsoleMode(ViConsole, OMODE);

    GetConsoleScreenBufferInfo(ViConsole,&Info);
    P(P_CO) = Columns = Info.dwSize.X;
    P(P_LI) = Rows = Info.dwSize.Y;
    P(P_SS) = Rows / 2;

    GetConsoleCursorInfo(ViConsole,&Info2);
    P(P_CS) = OrgCursorSize = CursorSize = Info2.dwSize;
    coord.X = coord.Y = 0;
    ReadConsoleOutputAttribute(ViConsole,
                               &Attribute,
                               sizeof(Attribute)/sizeof(WORD),
                               coord,
                               &NumRead);
    GetConsoleMode(ConsoleIn,&OldConsoleMode);
    ViConsoleInputMode = OldConsoleMode & ~(ENABLE_PROCESSED_INPUT |
                                            ENABLE_LINE_INPUT |
                                            ENABLE_ECHO_INPUT |
                                            ENABLE_WINDOW_INPUT |
                                            ENABLE_MOUSE_INPUT
                                           );
    SetConsoleMode(ConsoleIn,ViConsoleInputMode);







    setviconsoletitle();

//  signal(SIGINT, sig);

    //
    // Calculate a reasonable default search highlight
    // by flipping colors for the current screen.
    //

    HighlightAttribute = ((Attribute & 0xff00) | ((Attribute & 0x00f0) >> 4) |
                         ((Attribute & 0x000f) << 4));
}

void
setviconsoletitle()
{
    char title[2000];
    strcpy(title, Appname);
    if (Filename) {
        strcat(title, " ");
        strcat(title, Filename);
    }
    SetConsoleTitle(title);
}

void
wchangescreen(NewRows, NewColumns)
int NewRows;
int NewColumns;
{
#if 0
    CONSOLE_SCREEN_BUFFER_INFO info;
#endif
    SMALL_RECT                 screenRect;
    COORD                      screenSize;

#if 0
    GetConsoleScreenBufferInfo(ViConsole,&info);

    info.dwSize.X = NewRows;
    info.dwSize.Y = NewColumns;
#endif

    screenSize.X = (short)NewColumns;
    screenSize.Y = (short)NewRows;

    SetConsoleScreenBufferSize(ViConsole, screenSize);

    screenRect.Top = 0;
    screenRect.Left = 0;
    screenRect.Right = NewColumns - 1;
    screenRect.Bottom = NewRows - 1;

    SetConsoleWindowInfo(ViConsole, TRUE, &screenRect);
}

void
windexit(r)
int r;
{
    usecmdconsole();
    exit(r);
}

void
windgoto(r, c)
register int    r, c;
{
    COORD coord;

    flushbuf();
    coord.X = (SHORT)c;
    coord.Y = (SHORT)r;
    SetConsoleCursorPosition(ViConsole,coord);
}

FILE *
fopenb(fname, mode)
char    *fname;
char    *mode;
{
    char    modestr[16];

    sprintf(modestr, "%sb", mode);
    return fopen(fname, modestr);
}

/*
 * fixname(s) - fix up a dos name
 *
 * Takes a name like:
 *
 *  d:\x\y\z\base.ext
 *
 * and trims 'base' to 8 characters, and 'ext' to 3.
 */
char *
fixname(char *s)
{
    static  char f[_MAX_PATH+1];
    char    base[_MAX_FNAME+1];
    char    ext[_MAX_EXT+1];
    char    *p;
    int	d = 0;
    int i, stringsize, fBackslashFound=FALSE;

    stringsize = strlen(s);
    if (stringsize > _MAX_PATH) {
        return NULL;
    }

    ZeroMemory(f, sizeof(f));
    memcpy(f, s, stringsize);

    if (f[1] == ':') {
    	if (('a' <= f[0] && f[0] <= 'z') ||
    	    ('A' <= f[0] && f[0] <= 'Z')) {
    	    d = 2;
    	}
    }

    for (i=0; d+i < stringsize ;i++) {
        if (f[d+i] == '/')
            f[d+i] = '\\';
    }

    /*
     * Split the name into directory, base, extension.
     */

    if ((p = strrchr(f+d, '\\')) != NULL) {
        if ((strlen(p+1) > sizeof(base)-1))
            return NULL;
        strcpy(base, p+1);
        p[1] = '\0';
    } else {
        if ((strlen(f+d) > sizeof(base)-1))
            return NULL;
        strcpy(base, f+d);
        f[d] = '\0';
    }

    if ((p = strchr(base, '.')) != NULL) {
        if ((strlen(p+1) > sizeof(ext)-1))
            return NULL;
        strcpy(ext, p+1);
        *p = '\0';
    } else
        ext[0] = '\0';

    /*
     * Paste it all back together
     */
    strcat(f, base);
    strcat(f, ".");
    strcat(f, ext);

    return f;
}

LONG
mysystem(cmd, async)
char *cmd;
int  async;
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL ok;
    DWORD status;
    char *cmdline;
    char title[200];
    char *title2;

    char *shell = getenv("SHELL");

    if (!shell) {
        shell = getenv("COMSPEC");
    }

    if (!shell) {
        shell = "cmd.exe";
    }

    if (!cmd) {
        return !_access(shell,0);
    }

    if (!*cmd) {
        cmdline = _strdup(shell);
    } else {
        cmdline = malloc(strlen(shell) + strlen(cmd) + 5);
        strcpy(cmdline, shell);
        strcat(cmdline, " /c ");
        strcat(cmdline, cmd);
    }


    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);

    if (async) {
        si.dwFlags = STARTF_USESHOWWINDOW;
        si.wShowWindow = SW_SHOWNA;
    }

    if (!async) {
        GetConsoleTitle(title, sizeof(title));
        title2 = malloc(strlen(title) + 4 + strlen(cmdline));
        strcpy(title2, title);
        strcat(title2, " - ");
        strcat(title2, cmdline);
        SetConsoleTitle(title2);
        free(title2);
    }

    ok = CreateProcess(NULL,
                       cmdline,
                       NULL,
                       NULL,
                       FALSE,
                       CREATE_NEW_PROCESS_GROUP |
                        (async ? CREATE_NEW_CONSOLE : 0),
                       NULL,
                       NULL,
                       &si,
                       &pi
                       );
    free(cmdline);

    if (!ok) {
        status = (DWORD)-1;
    } else {
        if (async) {
            status = 0;
        } else {
            SetConsoleCtrlHandler(NULL, TRUE);
            WaitForSingleObject(pi.hProcess, INFINITE);
            SetConsoleCtrlHandler(NULL, FALSE);
            GetExitCodeProcess(pi.hProcess, &status);
        }
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }

    if (!async) {
        SetConsoleTitle(title);
    }

    return (LONG)status;
}

void
doshell(cmd, async)
char    *cmd;
int     async;
{
    int c;

    if (async) {

        mysystem(cmd? cmd : "", async);

    } else {

        usecmdconsole();

        if (!cmd) {
            mysystem("", async);
        } else {
            outchar('!');
            outstr(cmd);
            outchar('\n');
            flushbuf();
            mysystem(cmd, async);
        }

        c = wait_return0();
        outchar('\n');
        useviconsole();

        if (c == ':') {
            outchar(NL);
            docmdln(getcmdln(c));
        } else {
           screenclear();
        }
        updatescreen();
    }
}

void
dochdir(arg)
char *arg;
{
    if (_chdir(arg)) {
        emsg("bad directory");
    }
}


/*
    NT console stuff
*/

static DWORD RowSave,ColSave;

void Scroll(int t,int l,int b,int r,int Row,int Col)
{
    SMALL_RECT  ScrollRect;
    COORD       Coord;
    CHAR_INFO   CharInfo;

    ScrollRect.Left = (SHORT)l;
    ScrollRect.Right = (SHORT)r;
    ScrollRect.Top = (SHORT)t;
    ScrollRect.Bottom = (SHORT)b;
    Coord.X = (SHORT)Col;
    Coord.Y = (SHORT)Row;
    CharInfo.Char.AsciiChar = ' ';
    CharInfo.Attributes = Attribute;
    ScrollConsoleScreenBuffer(ViConsole,&ScrollRect,NULL,Coord,&CharInfo);
}

void EraseLine(void)
{
    CONSOLE_SCREEN_BUFFER_INFO Info;
    DWORD NumWritten;

    flushbuf();
    GetConsoleScreenBufferInfo(ViConsole,&Info);
    Info.dwCursorPosition.X = 0;
    SetConsoleCursorPosition(ViConsole,Info.dwCursorPosition);
    FillConsoleOutputCharacter(ViConsole,' ',Columns,Info.dwCursorPosition, &NumWritten);
}

void EraseNLinesAtRow(int n,int row)
{
    COORD coord;
    DWORD NumWritten;

    flushbuf();
    coord.X = 0;
    coord.Y = (short)row;
    FillConsoleOutputCharacter(ViConsole,' ',n*Columns,coord, &NumWritten);
}

void ClearDisplay(void)
{
    COORD c;
    DWORD NumWritten;

    flushbuf();
    c.X = c.Y = 0;
    SetConsoleCursorPosition(ViConsole,c);
    FillConsoleOutputCharacter(ViConsole,' ',Rows*Columns,c, &NumWritten);
}

void SaveCursor(void)
{
    CONSOLE_SCREEN_BUFFER_INFO Info;

    flushbuf();
    GetConsoleScreenBufferInfo(ViConsole,&Info);
    ColSave = Info.dwCursorPosition.X;
    RowSave = Info.dwCursorPosition.Y;
}

void RestoreCursor(void)
{
    COORD c;

    flushbuf();
    c.X = (SHORT)ColSave;
    c.Y = (SHORT)RowSave;
    SetConsoleCursorPosition(ViConsole,c);
}

void InvisibleCursor(void)
{
    CONSOLE_CURSOR_INFO Info;

    flushbuf();
    Info.dwSize = CursorSize;
    Info.bVisible = FALSE;
    SetConsoleCursorInfo(CurrConsole,&Info);
}

void VisibleCursor(void)
{
    CONSOLE_CURSOR_INFO Info;

    flushbuf();
    Info.dwSize = CursorSize;
    Info.bVisible = TRUE;
    SetConsoleCursorInfo(CurrConsole,&Info);
}

int CurHighlightLine = -1;
int CurHighlightColumn = -1;
int CurHighlightLength = -1;
char CurHighlightString[512];

int
StrLength(char *cp)
{
    int length = 0;
    int diff;

    while (*cp) {
        if (*cp == '\t') {
            diff = P(P_TS) - (length % P(P_TS));
            length += diff;
        } else {
            length++;
        }
        cp++;
    }
    return length;
}

void HighlightLine( int col, unsigned long line, char *string )
{
    COORD	dwWriteCoord;
    DWORD   dwNumWritten;
    int     length;

    if (P(P_HS) == FALSE)
        return;

    length = StrLength(string);

    if (length > Columns) {
        length = Columns;
    }
    if (col >= (Columns - 1)) {
        col--;
    }
    dwWriteCoord.X = CurHighlightColumn = col;
    dwWriteCoord.Y = CurHighlightLine = line;
    FillConsoleOutputAttribute(ViConsole,
                               HighlightAttribute,
                               length,
                               dwWriteCoord,
                               &dwNumWritten);
    updateline();
#if 0
    WriteConsoleOutputCharacter(ViConsole,
                                string,
                                length,
                                dwWriteCoord,
                                &dwNumWritten);
#endif
    strcpy(CurHighlightString, string);
    CurHighlightLength = length;
}

#define FOREGROUND_WHITE (FOREGROUND_BLUE | \
                          FOREGROUND_GREEN | \
                          FOREGROUND_RED | \
                          FOREGROUND_INTENSITY)

void RemoveHighlight( int col, unsigned long line, int length, char *string )
{
    COORD	dwWriteCoord;
    DWORD   dwNumWritten;

    length = StrLength(string);
    if (length > Columns) {
        length = Columns;
    }
    dwWriteCoord.X = (short)col;
    dwWriteCoord.Y = (int)line;
    FillConsoleOutputAttribute(ViConsole,
                               Attribute,
                               length,
                               dwWriteCoord,
                               &dwNumWritten);
    updateline();
#if 0
    WriteConsoleOutputCharacter(ViConsole,
                                string,
                                length,
                                dwWriteCoord,
                                &dwNumWritten);

#endif
}

void HighlightCheck()
{
    if (P(P_HS) == FALSE)
        return;

    if (CurHighlightLine != -1) {
        RemoveHighlight(CurHighlightColumn,
                        CurHighlightLine,
                        CurHighlightLength,
                        CurHighlightString);
        CurHighlightLine = -1;
        CurHighlightColumn = -1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\misccmds.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/misccmds.c,v 1.14 89/08/06 09:50:17 tony Exp $
 *
 * Various routines to perform specific editing operations or return
 * useful information about the file.
 */

#include "stevie.h"
#include <io.h>
#include <errno.h>

static  void    openfwd(), openbwd();

extern  bool_t  did_ai;

/*
 * opencmd
 *
 * Add a blank line above or below the current line.
 */

void
opencmd(dir, can_ai)
int     dir;
int     can_ai;                 /* if true, consider auto-indent */
{
        if (dir == FORWARD)
                openfwd(can_ai);
        else
                openbwd(can_ai);
}

static void
openfwd(can_ai)
int     can_ai;
{
        register LINE   *l;
        LNPTR    *next;
        register char   *s;     /* string to be moved to new line, if any */
        int     newindex = 0;   /* index of the cursor on the new line */

        /*
         * If we're in insert mode, we need to move the remainder of the
         * current line onto the new line. Otherwise the new line is left
         * blank.
         */
        if (State == INSERT || State == REPLACE)
                s = &Curschar->linep->s[Curschar->index];
        else
                s = "";

        if ((next = nextline(Curschar)) == NULL)        /* open on last line */
                next = Fileend;

        /*
         * By asking for as much space as the prior line had we make sure
         * that we'll have enough space for any auto-indenting.
         */
        if ((l = newline(strlen(Curschar->linep->s) + SLOP)) == NULL)
                return;

        if (*s != NUL)
                strcpy(l->s, s);                /* copy string to new line */

        else if (can_ai && P(P_AI) && !anyinput()) {
                char    *p;

                /*
                 * Copy prior line, and truncate after white space
                 */
                strcpy(l->s, Curschar->linep->s);

                for (p = l->s; *p == ' ' || *p == TAB ;p++)
                        ;
                *p = NUL;
                newindex = (int)(p - l->s);

                /*
                 * If we just did an auto-indent, then we didn't type
                 * anything on the prior line, and it should be truncated.
                 */
                if (did_ai)
                        Curschar->linep->s[0] = NUL;

                did_ai = TRUE;
        }

        /* truncate current line at cursor */
        if (State == INSERT || State == REPLACE)
                *s = NUL;


        Curschar->linep->next = l;      /* link neighbors to new line */
        next->linep->prev = l;

        l->prev = Curschar->linep;      /* link new line to neighbors */
        l->next = next->linep;

        if (next == Fileend)                    /* new line at end */
                l->num = Curschar->linep->num + LINEINC;

        else if ((l->prev->num) + 1 == l->next->num)    /* no gap, renumber */
                renum();

        else {                                  /* stick it in the middle */
                unsigned long   lnum;
                lnum = ((long)l->prev->num + (long)l->next->num) / 2;
                l->num = lnum;
        }

        /*
         * Get the cursor to the start of the line, so that 'Cursrow'
         * gets set to the right physical line number for the stuff
         * that follows...
         */
        Curschar->index = 0;
        cursupdate();

        /*
         * If we're doing an open on the last logical line, then
         * go ahead and scroll the screen up. Otherwise, just insert
         * a blank line at the right place. We use calls to plines()
         * in case the cursor is resting on a long line.
         */
        if (Cursrow + plines(Curschar) == (Rows - 1))
                scrollup(1);
        else
                s_ins(Cursrow+plines(Curschar), 1);

        *Curschar = *nextline(Curschar);        /* cursor moves down */
        Curschar->index = newindex;

        updatescreen();         /* because Botchar is now invalid... */

        cursupdate();           /* update Cursrow before insert */
}

static void
openbwd(can_ai)
int     can_ai;
{
        register LINE   *l;
        LINE    *prev;
        int     newindex = 0;

        prev = Curschar->linep->prev;

        if ((l = newline(strlen(Curschar->linep->s) + SLOP)) == NULL)
                return;

        Curschar->linep->prev = l;      /* link neighbors to new line */
        prev->next = l;

        l->next = Curschar->linep;      /* link new line to neighbors */
        l->prev = prev;

        if (can_ai && P(P_AI) && !anyinput()) {
                char    *p;

                /*
                 * Copy current line, and truncate after white space
                 */
                strcpy(l->s, Curschar->linep->s);

                for (p = l->s; *p == ' ' || *p == TAB ;p++)
                        ;
                *p = NUL;
                newindex = (int)(p - l->s);

                did_ai = TRUE;
        }

        Curschar->linep = Curschar->linep->prev;
        Curschar->index = newindex;

        if (prev == Filetop->linep)             /* new start of file */
                Filemem->linep = l;

        renum();        /* keep it simple - we don't do this often */

        cursupdate();                   /* update Cursrow before insert */
        if (Cursrow != 0)
                s_ins(Cursrow, 1);              /* insert a physical line */

        updatescreen();
}

int
cntllines(pbegin,pend)
register LNPTR   *pbegin, *pend;
{
        register LINE   *lp;
        int     lnum = 1;

        if (pbegin->linep && pend->linep)
	        for (lp = pbegin->linep; lp != pend->linep ;lp = lp->next)
	                lnum++;

        return(lnum);
}

/*
 * plines(p) - return the number of physical screen lines taken by line 'p'
 */
int
plines(p)
LNPTR    *p;
{
        register int    col = 0;
        register char   *s;

        s = p->linep->s;

        if (*s == NUL)          /* empty line */
                return 1;

        for (; *s != NUL ;s++) {
                if ( *s == TAB && !P(P_LS))
                        col += P(P_TS) - (col % P(P_TS));
                else
                        col += chars[(unsigned)(*s & 0xff)].ch_size;
        }

        /*
         * If list mode is on, then the '$' at the end of
         * the line takes up one extra column.
         */
        if (P(P_LS))
                col += 1;
        /*
         * If 'number' mode is on, add another 8.
         */
        if (P(P_NU))
                col += 8;

        return ((col + (Columns-1)) / Columns);
}

void
fileinfo()
{
        extern  int     numfiles, curfile;
        register long   l1, l2;
        bool_t readonly = FALSE;

        if (Filename != NULL) {
            if((_access(Filename,2) == -1) && (errno == EACCES)) {
                readonly = TRUE;
            }
        }

        if (bufempty()) {
                l1 = 0;
                l2 = 1;                 /* don't div by zero */
        } else {
                l1 = cntllines(Filemem, Curschar);
                l2 = cntllines(Filemem, Fileend) - 1;
        }

        if (numfiles > 1)
                smsg("\"%s\"%s%s line %ld of %ld -- %ld %% -- (file %d of %d)",
                        (Filename != NULL) ? Filename : "No File",
                        Changed ? " [Modified]" : "",
                        readonly == TRUE ? " [Read only]" : "",
                        l1, l2, (l1 * 100)/l2,
                        curfile+1, numfiles);
        else
                smsg("\"%s\"%s%s line %ld of %ld -- %ld %% --",
                        (Filename != NULL) ? Filename : "No File",
                        Changed ? " [Modified]" : "",
                        readonly == TRUE ? " [Read only]" : "",
                        l1, l2, (l1 * 100)/l2);
}

/*
 * gotoline(n) - return a pointer to line 'n'
 *
 * Returns a pointer to the last line of the file if n is zero, or
 * beyond the end of the file.
 */
LNPTR *
gotoline(n)
register int    n;
{
    static  LNPTR    l;

        l.index = 0;

        if ( n == 0 )
                l = *prevline(Fileend);
        else {
        LNPTR    *p;

                for (l = *Filemem; --n > 0 ;l = *p)
                        if ((p = nextline(&l)) == NULL)
                                break;
        }
        return &l;
}

void
inschar(c)
int     c;
{
        register char   *p, *pend;

        /* make room for the new char. */
        if ( ! canincrease(1) )
                return;

        if (State != REPLACE) {
                p = &Curschar->linep->s[strlen(Curschar->linep->s) + 1];
                pend = &Curschar->linep->s[Curschar->index];

                for (; p > pend ;p--)
                        *p = *(p-1);

                *p = (char)c;

        } else {        /* replace mode */
                /*
                 * Once we reach the end of the line, we are effectively
                 * inserting new text, so make sure the string terminator
                 * stays out there.
                 */
                if (gchar(Curschar) == NUL)
                        Curschar->linep->s[Curschar->index+1] = NUL;
                pchar(Curschar, c);
        }

        /*
         * If we're in insert mode and showmatch mode is set, then
         * check for right parens and braces. If there isn't a match,
         * then beep. If there is a match AND it's on the screen, then
         * flash to it briefly. If it isn't on the screen, don't do anything.
         */
        if (P(P_SM) && State == INSERT && (c == ')' || c == '}' || c == ']')) {
        LNPTR    *lpos, csave;

                if ((lpos = showmatch()) == NULL)       /* no match, so beep */
                        beep();
                else if (LINEOF(lpos) >= LINEOF(Topchar)) {
                        updatescreen();         /* show the new char first */
                        csave = *Curschar;
                        *Curschar = *lpos;      /* move to matching char */
                        cursupdate();
                        windgoto(Cursrow, Curscol);
                        delay();                /* brief pause */
                        *Curschar = csave;      /* restore cursor position */
                        cursupdate();
                }
        }

        inc(Curschar);
        CHANGED;
}

bool_t
delchar(fixpos)
bool_t  fixpos;         /* if TRUE, fix the cursor position when done */
{
        register int    i;

        /* Check for degenerate case; there's nothing in the file. */
        if (bufempty())
                return FALSE;

        if (lineempty())        /* can't do anything */
                return FALSE;

        /* Delete the char. at Curschar by shifting everything */
        /* in the line down. */
        for ( i=Curschar->index+1; i < Curschar->linep->size ;i++)
                Curschar->linep->s[i-1] = Curschar->linep->s[i];

        /* If we just took off the last character of a non-blank line, */
        /* we don't want to end up positioned at the newline. */
        if (fixpos) {
                if (gchar(Curschar)==NUL && Curschar->index>0 && State!=INSERT)
                        Curschar->index--;
        }
        CHANGED;

        return TRUE;
}


void
delline(nlines, can_update)
int     nlines;
bool_t  can_update;
{
        register LINE   *p, *q;
        int      dlines = 0;
        bool_t   do_update = FALSE;

        while ( nlines-- > 0 ) {

                if (bufempty())                 /* nothing to delete */
                        break;

                if (buf1line()) {               /* just clear the line */
                        Curschar->linep->s[0] = NUL;
                        Curschar->index = 0;
                        break;
                }

                p = Curschar->linep->prev;
                q = Curschar->linep->next;

                if (p == Filetop->linep) {      /* first line of file so... */
                        Filemem->linep = q;     /* adjust start of file */
                        Topchar->linep = q;     /* and screen */
                }
                p->next = q;
                if (q)
		    q->prev = p;

                clrmark(Curschar->linep);       /* clear marks for the line */

                /*
                 * Delete the correct number of physical lines on the screen
                 */
                if (can_update) {
                        do_update = TRUE;
                        dlines += plines(Curschar);
                }

                /*
                 * If deleting the top line on the screen, adjust Topchar
                 */
                if (Topchar->linep == Curschar->linep)
                        Topchar->linep = q;

                free(Curschar->linep->s);
                free((char *) Curschar->linep);

                Curschar->linep = q;
                Curschar->index = 0;            /* is this right? */
                CHANGED;

                /* If we delete the last line in the file, back up */
                if ( Curschar->linep == Fileend->linep) {
                        Curschar->linep = Curschar->linep->prev;
                        /* and don't try to delete any more lines */
                        break;
                }
        }
        if(do_update) {
                s_del(Cursrow, dlines);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\ops.h ===
/* $Header: /nw/tony/src/stevie/src/RCS/ops.h,v 1.2 89/07/19 08:08:21 tony Exp $
 *
 * Macros and declarations for the operator code in ops.c
 */

/*
 * Operators
 */
#define	NOP	0		/* no pending operation */
#define DELETE    1
#define YANK      2
#define CHANGE    3
#define LSHIFT    4
#define RSHIFT    5
#define FILTER    6
#define TILDE     7
#define LOWERCASE 8
#define UPPERCASE 9

extern	int	operator;		/* current pending operator */

/*
 * When a cursor motion command is made, it is marked as being a character
 * or line oriented motion. Then, if an operator is in effect, the operation
 * becomes character or line oriented accordingly.
 *
 * Character motions are marked as being inclusive or not. Most char.
 * motions are inclusive, but some (e.g. 'w') are not.
 */

/*
 * Cursor motion types
 */
#define	MBAD	(-1)		/* 'bad' motion type marks unusable yank buf */
#define	MCHAR	0
#define	MLINE	1

extern	int	mtype;			/* type of the current cursor motion */
extern	bool_t	mincl;			/* true if char motion is inclusive */

extern  LNPTR    startop;        /* cursor pos. at start of operator */

/*
 * Functions defined in ops.c
 */
void    doshift(), dodelete(), doput(), dochange(), dofilter();
void    docasechange(char,char,int,bool_t);
#ifdef	TILDEOP
void	dotilde();
#endif
bool_t	dojoin(), doyank();
void	startinsert();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\param.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/param.c,v 1.10 89/08/02 10:59:10 tony Exp $
 *
 * Code to handle user-settable parameters. This is all pretty much table-
 * driven. To add a new parameter, put it in the params array, and add a
 * macro for it in param.h. If it's a numeric parameter, add any necessary
 * bounds checks to doset(). String parameters aren't currently supported.
 */

#include "stevie.h"

extern long CursorSize;

struct  param   params[] = {

        { "tabstop",    "ts",           4,      P_NUM },
        { "scroll",     "scroll",       12,     P_NUM },
        { "report",     "report",       5,      P_NUM },
        { "lines",      "lines",        25,     P_NUM },
        { "vbell",      "vb",           TRUE,   P_BOOL },
        { "showmatch",  "sm",           FALSE,  P_BOOL },
        { "wrapscan",   "ws",           TRUE,   P_BOOL },
        { "errorbells", "eb",           FALSE,  P_BOOL },
        { "showmode",   "mo",           FALSE,  P_BOOL },
        { "backup",     "bk",           FALSE,  P_BOOL },
        { "return",     "cr",           TRUE,   P_BOOL },
        { "list",       "list",         FALSE,  P_BOOL },
        { "ignorecase", "ic",           FALSE,  P_BOOL },
        { "autoindent", "ai",           FALSE,  P_BOOL },
        { "number",     "nu",           FALSE,  P_BOOL },
        { "modelines",  "ml",           FALSE,  P_BOOL },
        { "tildeop",    "to",           FALSE,  P_BOOL },
        { "terse",      "terse",        FALSE,  P_BOOL },
        { "cursorsize", "cs",           25,     P_NUM },
        { "highlightsearch", "hs",      TRUE,   P_BOOL },
        { "columns",    "co",           80,     P_NUM },
        { "hardtabs",   "ht",           FALSE,  P_BOOL },
        { "shiftwidth", "sw",           4,      P_NUM },
        { "",           "",             0,      0, }            /* end marker */

};

static  void    showparms();
void wchangescreen();

void
doset(arg)
char    *arg;           /* parameter string */
{
        register int    i;
        register char   *s;
        bool_t  did_lines = FALSE;
        bool_t  state = TRUE;           /* new state of boolean parms. */

        if (arg == NULL) {
                showparms(FALSE);
                return;
        }
        if (strncmp(arg, "all", 3) == 0) {
                showparms(TRUE);
                return;
        }
        if (strncmp(arg, "no", 2) == 0) {
                state = FALSE;
                arg += 2;
        }

        for (i=0; params[i].fullname[0] != NUL ;i++) {
                s = params[i].fullname;
                if (strncmp(arg, s, strlen(s)) == 0)    /* matched full name */
                        break;
                s = params[i].shortname;
                if (strncmp(arg, s, strlen(s)) == 0)    /* matched short name */
                        break;
        }

        if (params[i].fullname[0] != NUL) {     /* found a match */
                if (params[i].flags & P_NUM) {
                        did_lines = ((i == P_LI) || (i == P_CO));
                        if (arg[strlen(s)] != '=' || state == FALSE)
                                emsg("Invalid set of numeric parameter");
                        else {
                                params[i].value = atoi(arg+strlen(s)+1);
                                params[i].flags |= P_CHANGED;
                        }
                } else /* boolean */ {
                        if (arg[strlen(s)] == '=')
                                emsg("Invalid set of boolean parameter");
                        else {
                                params[i].value = state;
                                params[i].flags |= P_CHANGED;
                        }
                }
        } else
                emsg("Unrecognized 'set' option");

        /*
         * Update the screen in case we changed something like "tabstop"
         * or "list" that will change its appearance.
         */
        updatescreen();

        CursorSize = P(P_CS);
        VisibleCursor();

        if (did_lines) {
                Rows = P(P_LI);
                Columns = P(P_CO);
                screenalloc();          /* allocate new screen buffers */
                screenclear();
                (void)wchangescreen(Rows, Columns);
                updatescreen();
        }
        /*
         * Check the bounds for numeric parameters here
         */
        if (P(P_TS) <= 0 || P(P_TS) > 32) {
                emsg("Invalid tab size specified");
                P(P_TS) = 8;
                return;
        }

        if (P(P_SS) <= 0 || P(P_SS) > Rows) {
                emsg("Invalid scroll size specified");
                P(P_SS) = 12;
                return;
        }

#ifndef TILDEOP
        if (P(P_TO)) {
                emsg("Tilde-operator not enabled");
                P(P_TO) = FALSE;
                return;
        }
#endif
        /*
         * Check for another argument, and call doset() recursively, if
         * found. If any argument results in an error, no further
         * parameters are processed.
         */
        while (*arg != ' ' && *arg != '\t') {   /* skip to next white space */
                if (*arg == NUL)
                        return;                 /* end of parameter list */
                arg++;
        }
        while (*arg == ' ' || *arg == '\t')     /* skip to next non-white */
                arg++;

        if (*arg)
                doset(arg);     /* recurse on next parameter */
}

static  void
showparms(all)
bool_t  all;    /* show ALL parameters */
{
        register struct param   *p;
        char    buf[64];

        gotocmd(TRUE, 0);
        outstr("Parameters:\r\n");

        for (p = &params[0]; p->fullname[0] != NUL ;p++) {
                if (!all && ((p->flags & P_CHANGED) == 0))
                        continue;
                if (p->flags & P_BOOL)
                        sprintf(buf, "\t%s%s\r\n",
                                (p->value ? "" : "no"), p->fullname);
                else
                        sprintf(buf, "\t%s=%d\r\n", p->fullname, p->value);

                outstr(buf);
        }
        wait_return();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\ops.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/ops.c,v 1.5 89/08/06 09:50:42 tony Exp $
 *
 * Contains routines that implement the operators in vi. Everything in this
 * file is called only from code in normal.c
 */

#include "stevie.h"
#include <io.h>
#include "ops.h"

char    *lastcmd = NULL;/* the last thing we did */

static void inslines();
static void tabinout();

/*
 * doshift - handle a shift operation
 */
void
doshift(op, c1, c2, num)
int     op;
char    c1, c2;
int     num;
{
        LNPTR   top, bot;
        int     nlines;
        char    opchar;

        top = startop;
        bot = *Curschar;

        if (lt(&bot, &top))
                pswap(&top, &bot);

        u_save(top.linep->prev, bot.linep->next);

        nlines = cntllines(&top, &bot);
        *Curschar = top;
        tabinout((op == LSHIFT), nlines);

        /* construct Redo buff */
        opchar = (char)((op == LSHIFT) ? '<' : '>');
        if (num != 0)
                sprintf(Redobuff, "%c%d%c%c", opchar, num, c1, c2);
        else
                sprintf(Redobuff, "%c%c%c", opchar, c1, c2);

        /*
         * The cursor position afterward is the prior of the two positions.
         */
        *Curschar = top;

        /*
         * If we were on the last char of a line that got shifted left,
         * then move left one so we aren't beyond the end of the line
         */
        if (gchar(Curschar) == NUL && Curschar->index > 0)
                Curschar->index--;

        updatescreen();

        if (nlines > P(P_RP))
                smsg("%d lines %ced", nlines, opchar);
}

/*
 * dodelete - handle a delete operation
 */
void
dodelete(c1, c2, num)
char    c1, c2;
int     num;
{
        LNPTR    top, bot;
        int     nlines;
        register int    n;

        /*
         * Do a yank of whatever we're about to delete. If there's too much
         * stuff to fit in the yank buffer, then get a confirmation before
         * doing the delete. This is crude, but simple. And it avoids doing
         * a delete of something we can't put back if we want.
         */
        if (!doyank()) {
                msg("yank buffer exceeded: press <y> to confirm");
                if (vgetc() != 'y') {
                        msg("delete aborted");
                        *Curschar = startop;
                        return;
                }
        }

        top = startop;
        bot = *Curschar;

        if (lt(&bot, &top))
                pswap(&top, &bot);

        u_save(top.linep->prev, bot.linep->next);

        nlines = cntllines(&top, &bot);
        *Curschar = top;
        cursupdate();

        if (mtype == MLINE) {
                delline(nlines, TRUE);
        } else {
                if (!mincl && bot.index != 0)
                        dec(&bot);

                if (top.linep == bot.linep) {           /* del. within line */
                        n = bot.index - top.index + 1;
                        while (n--)
                                if (!delchar(TRUE))
                                        break;
                } else {                                /* del. between lines */
                        n = Curschar->index;
                        while (Curschar->index >= n)
                                if (!delchar(TRUE))
                                        break;

                        top = *Curschar;
                        *Curschar = *nextline(Curschar);
                        delline(nlines-2, TRUE);
                        Curschar->index = 0;
                        n = bot.index + 1;
                        while (n--)
                                if (!delchar(TRUE))
                                        break;
                        *Curschar = top;
                        (void) dojoin(FALSE);
                        oneright();     /* we got bumped left up above */
                }
        }

        /* construct Redo buff */
        if (num != 0)
                sprintf(Redobuff, "d%d%c%c", num, c1, c2);
        else
                sprintf(Redobuff, "d%c%c", c1, c2);

        if (mtype == MCHAR && nlines == 1)
                updateline();
        else
                updatescreen();

        if (nlines > P(P_RP))
                smsg("%d fewer lines", nlines);
}

/*
 * dofilter - handle a filter operation
 */

#define ITMP    "viXXXXXX"
#define OTMP    "voXXXXXX"

static  char    itmp[32];
static  char    otmp[32];


/*
 * dofilter - filter lines through a command given by the user
 *
 * We use temp files and the system() routine here. This would normally
 * be done using pipes on a UNIX machine, but this is more portable to
 * the machines we usually run on. The system() routine needs to be able
 * to deal with redirection somehow, and should handle things like looking
 * at the PATH env. variable, and adding reasonable extensions to the
 * command name given by the user. All reasonable versions of system()
 * do this.
 */
void
dofilter(c1, c2, num)
char    c1, c2;
int     num;
{
        char    *buff;                  /* cmd buffer from getcmdln() */
        char    cmdln[200];             /* filtering command line */
        LNPTR    top, bot;
        int     nlines;

        top = startop;
        bot = *Curschar;

        buff = getcmdln('!');

        if (buff == NULL)       /* user backed out of the command prompt */
                return;

        if (*buff == '!') {             /* use the 'last' command */
                if (lastcmd == NULL) {
                        emsg("No previous command");
                        return;
                }
                buff = lastcmd;
        }

        /*
         * Remember the current command
         */
        if (lastcmd != NULL)
                free(lastcmd);
        lastcmd = strsave(buff);

        if (lt(&bot, &top))
                pswap(&top, &bot);

        u_save(top.linep->prev, bot.linep->next);

        nlines = cntllines(&top, &bot);
        *Curschar = top;
        cursupdate();

        /*
         * 1. Form temp file names
         * 2. Write the lines to a temp file
         * 3. Run the filter command on the temp file
         * 4. Read the output of the command into the buffer
         * 5. Delete the original lines to be filtered
         * 6. Remove the temp files
         */

#ifdef  TMPDIR
        strcpy(itmp, TMPDIR);
        strcpy(otmp, TMPDIR);
#else
        itmp[0] = otmp[0] = NUL;
#endif
        strcat(itmp, ITMP);
        strcat(otmp, OTMP);

        if (_mktemp(itmp) == NULL || _mktemp(otmp) == NULL) {
                emsg("Can't get temp file names");
                return;
        }

        if (!writeit(itmp, &top, &bot)) {
                emsg("Can't create input temp file");
                return;
        }

        sprintf(cmdln, "%s <%s >%s", buff, itmp, otmp);

        if (system(cmdln) != 0) {
                emsg("Filter command failed");
                remove(ITMP);
                return;
        }

        if (readfile(otmp, &bot, TRUE)) {
                emsg("Can't read filter output");
                return;
        }

        delline(nlines, TRUE);

        remove(itmp);
        remove(otmp);

        /* construct Redo buff */
        if (num != 0)
                sprintf(Redobuff, "d%d%c%c", num, c1, c2);
        else
                sprintf(Redobuff, "d%c%c", c1, c2);

        updatescreen();

        if (nlines > P(P_RP))
                smsg("%d lines filtered", nlines);
}

#ifdef  TILDEOP
void
dotilde(c1, c2, num)
char    c1, c2;
int     num;
{
    LNPTR    top, bot;
        register char   c;

        /* construct Redo buff */
        if (num != 0)
                sprintf(Redobuff, "~%d%c%c", num, c1, c2);
        else
                sprintf(Redobuff, "~%c%c", c1, c2);

        top = startop;
        bot = *Curschar;

        if (lt(&bot, &top))
                pswap(&top, &bot);

        u_save(top.linep->prev, bot.linep->next);

        if (mtype == MLINE) {
                top.index = 0;
                bot.index = strlen(bot.linep->s);
        } else {
                if (!mincl) {
                        if (bot.index)
                                bot.index--;
                }
        }

        for (; ltoreq(&top, &bot) ;inc(&top)) {
                /*
                 * Swap case through the range
                 */
                c = (char)gchar(&top);
                if (isalpha(c)) {
                        if (islower(c))
                                c = (char)toupper(c);
                        else
                                c = (char)tolower(c);

                        pchar(&top, c);         /* Change current character. */
                        CHANGED;
                }
        }
        *Curschar = startop;
        updatescreen();
}
#endif

/*
 * dochange - handle a change operation
 */
void
dochange(c1, c2, num)
char    c1, c2;
int     num;
{
        char    sbuf[16];
        bool_t  doappend;       /* true if we should do append, not insert */
        bool_t  at_eof;         /* changing through the end of file */
    LNPTR    top, bot;

        top = startop;
        bot = *Curschar;

        if (lt(&bot, &top))
                pswap(&top, &bot);

        doappend = endofline(&bot);
        at_eof = (bot.linep->next == Fileend->linep);

        dodelete(c1, c2, num);

        if (mtype == MLINE) {
                /*
                 * If we made a change through the last line of the file,
                 * then the cursor got backed up, and we need to open a
                 * new line forward, otherwise we go backward.
                 */
                if (at_eof)
                        opencmd(FORWARD, FALSE);
                else
                        opencmd(BACKWARD, FALSE);
        } else {
                if (doappend && !lineempty())
                        inc(Curschar);
        }

        if (num)
                sprintf(sbuf, "c%d%c%c", num, c1, c2);
        else
                sprintf(sbuf, "c%c%c", c1, c2);

        startinsert(sbuf, mtype == MLINE);
}


/*
 * docasechange - handle a case change operation
 */
void
docasechange(char c1, char c2, int num, bool_t fToUpper)
{
        LNPTR         top, bot;
        register char c;

        /* construct Redo buff */
        if (num != 0)
                sprintf(Redobuff, "%c%d%c%c", fToUpper ? 'V' : 'v',num, c1, c2);
        else
                sprintf(Redobuff, "%c%c%c", fToUpper ? 'V' : 'v',c1, c2);

        top = startop;
        bot = *Curschar;

        if (lt(&bot, &top))
                pswap(&top, &bot);

        u_save(top.linep->prev, bot.linep->next);

        if (mtype == MLINE) {
                top.index = 0;
                bot.index = strlen(bot.linep->s);
        } else {
                if (!mincl) {
                        if (bot.index)
                                bot.index--;
                }
        }

        for (; ltoreq(&top, &bot) ;inc(&top)) {
                /*
                 * change case through the range
                 */
                c = (char)gchar(&top);
                if (isalpha(c)) {

                        c = fToUpper ? (char)toupper(c) : (char)tolower(c);

                        pchar(&top, c);         /* Change current character. */
                        CHANGED;
                }
        }
        *Curschar = startop;
        updatescreen();
}

#define YBSLOP  2048                // yank buffer initial and incr size
char    *YankBuffers[27];
int     CurrentYBSize[27];
int     ybtype[27];

void
inityank()
{
    int i;

    for(i=0; i<27; i++) {
        ybtype[i] = MBAD;
        if((YankBuffers[i] = malloc(CurrentYBSize[i] = YBSLOP)) == NULL) {
            fprintf(stderr,"Cannot allocate initial yank buffers\n");
            windexit(1);
        }
        YankBuffers[i][0] = '\0';
    }
}

void GetBufferIndex(int *index,bool_t *append)
{
    int     i;
    bool_t  a = FALSE;

    if(namedbuff == -1) {
        i = 26;
    } else if(islower(namedbuff)) {
        i = namedbuff - (int)'a';
    } else {
        i = namedbuff - (int)'A';
        a = TRUE;
    }
    *index = i;
    *append = a;
    return;
}

bool_t
doyank()
{
        LNPTR   top, bot;
        char    *ybuf;
        char    *ybstart;
        char    *ybend;
        char    *yptr;
        int     nlines;
        int     buffindex;
        bool_t  buffappend;

        GetBufferIndex(&buffindex,&buffappend);
        namedbuff = -1;

        if(!buffappend) {
            // the given buffer may have grown huge.  Shrink it here.  The
            // realloc should never fail because the buffer is either being
            // shrunk or is staying the same size.
            YankBuffers[buffindex] = ralloc(YankBuffers[buffindex],YBSLOP);
            CurrentYBSize[buffindex] = YBSLOP;
        }

        ybuf = YankBuffers[buffindex];

        ybstart = ybuf;
        yptr = ybstart;
        if(buffappend) {
            yptr += strlen(ybstart);
        }
        ybend = &ybuf[CurrentYBSize[buffindex]-1];

        top = startop;
        bot = *Curschar;

        if (lt(&bot, &top))
                pswap(&top, &bot);

        nlines = cntllines(&top, &bot);

        ybtype[buffindex] = mtype;           /* set the yank buffer type */

        if (mtype == MLINE) {
                top.index = 0;
                bot.index = strlen(bot.linep->s);
                /*
                 * The following statement checks for the special case of
                 * yanking a blank line at the beginning of the file. If
                 * not handled right, we yank an extra char (a newline).
                 */
                if (dec(&bot) == -1) {
                        *yptr = NUL;
                        if (operator == YANK)
                                *Curschar = startop;
                        return TRUE;
                }
        } else {
                if (!mincl) {
                        if (bot.index)
                                bot.index--;
                }
        }

        for (; ltoreq(&top, &bot) ;inc(&top)) {

                // See if we've filled the buffer as currently
                // allocated.  If so, reallocate the buffer and
                // update pointers accordingly before we store the
                // current character.  This is necessary because we will
                // always be storing at least one more char (the NUL)
                // and probably more.

                if(yptr == ybend) {
                        ybstart = ralloc(ybuf,CurrentYBSize[buffindex] + YBSLOP);
                        if(ybstart == NULL) {
                                ybtype[buffindex] = MBAD;
                                return(FALSE);
                        }
                        CurrentYBSize[buffindex] += YBSLOP;
                        yptr += ybstart - ybuf;
                        ybend = &ybstart[CurrentYBSize[buffindex] - 1];
                        ybuf = ybstart;
                        YankBuffers[buffindex] = ybuf;
                }

                *yptr++ = (char)((gchar(&top) != NUL) ? gchar(&top) : NL);
        }

        *yptr = NUL;

        if (operator == YANK) { /* restore Curschar if really doing yank */
                *Curschar = startop;

                if (nlines > P(P_RP))
                        smsg("%d lines yanked", nlines);
        }
        return TRUE;
}

/*
 * doput(dir)
 *
 * Put the yank buffer at the current location, using the direction given
 * by 'dir'.
 */
void
doput(dir)
int     dir;
{
        int     buffindex;
        bool_t  buffappend;
        char   *ybuf;
        int     nb = namedbuff;

        GetBufferIndex(&buffindex,&buffappend);
        namedbuff = -1;
        ybuf = YankBuffers[buffindex];

        if (ybtype[buffindex] == MBAD) {
                char msgbuff[30];
                sprintf(msgbuff,"Nothing in register %c",nb);
                emsg(msgbuff);
                return;
        }

        u_saveline();

        if (ybtype[buffindex] == MLINE)
                inslines(Curschar->linep, dir, ybuf);
        else {
                /*
                 * If we did a character-oriented yank, and the buffer
                 * contains multiple lines, the situation is more complex.
                 * For the moment, we punt, and pretend the user did a
                 * line-oriented yank. This doesn't actually happen that
                 * often.
                 */
                if (strchr(ybuf, NL) != NULL)
                        inslines(Curschar->linep, dir, ybuf);
                else {
                        char    *s;
                        int     len;

                        len = strlen(Curschar->linep->s) + strlen(ybuf) + 1;
                        s = alloc((unsigned) len);
                        strcpy(s, Curschar->linep->s);
                        if (dir == FORWARD)
                                Curschar->index++;
                        strcpy(s + Curschar->index, ybuf);
                        strcat(s, &Curschar->linep->s[Curschar->index]);
                        free(Curschar->linep->s);
                        Curschar->linep->s = s;
                        Curschar->linep->size = len;
                        updateline();
                }
        }

        CHANGED;
}

bool_t
dojoin(join_cmd)
bool_t  join_cmd;               /* handling a real "join" command? */
{
        int     scol;           /* save cursor column */
        int     size;           /* size of the joined line */

        if (nextline(Curschar) == NULL)         /* on last line */
                return FALSE;

        if (!canincrease(size = strlen(Curschar->linep->next->s)))
                return FALSE;

        while (oneright())                      /* to end of line */
                ;

        strcat(Curschar->linep->s, Curschar->linep->next->s);

        /*
         * Delete the following line. To do this we move the cursor
         * there briefly, and then move it back. Don't back up if the
         * delete made us the last line.
         */
        Curschar->linep = Curschar->linep->next;
        scol = Curschar->index;

        if (nextline(Curschar) != NULL) {
                delline(1, TRUE);
                Curschar->linep = Curschar->linep->prev;
        } else
                delline(1, TRUE);

        Curschar->index = scol;

        if (join_cmd)
                oneright();     /* go to first char. of joined line */

        if (join_cmd && size != 0) {
                /*
                 * Delete leading white space on the joined line
                 * and insert a single space.
                 */
                while (gchar(Curschar) == ' ' || gchar(Curschar) == TAB)
                        delchar(TRUE);
                inschar(' ');
        }

        return TRUE;
}

void
startinsert(initstr, startln)
char    *initstr;
int     startln;        /* if set, insert point really at start of line */
{
        register char   *p, c;

        *Insstart = *Curschar;
        if (startln)
                Insstart->index = 0;
        Ninsert = 0;
        Insptr = Insbuff;
        for (p=initstr; (c=(*p++))!='\0'; ) {
                *Insptr++ = c;
                Ninsert++;
        }

        if (*initstr == 'R')
                State = REPLACE;
        else
                State = INSERT;

        if (P(P_MO))
                msg((State == INSERT) ? "Insert Mode" : "Replace Mode");
}
/*
 * tabinout(inout,num)
 *
 * If inout==0, add a tab to the begining of the next num lines.
 * If inout==1, delete a tab from the beginning of the next num lines.
 */
static void
tabinout(inout, num)
int     inout;
int     num;
{
    int     ntodo = num;
    int     c;
    int     col;
    LNPTR    *p;

    while (ntodo-- > 0) {

        beginline(FALSE);

        /*
         * eat leading space, calc the column of first non-white
         */
        col = 0;
        while ((c = gchar(Curschar)) == ' ' || c == TAB) {
            if (c == ' ') {
                ++col;
            } else {
                col += P(P_TS);
                col -= (col % P(P_TS));
            }
            delchar(TRUE);
        }

        /*
         * add or subtract shiftwidth spaces
         */


        if (inout == 0) {
            col += P(P_SW);
        } else {
            col -= P(P_SW);
        }

        if (col < 0) {
            col = 0;
        }

        /*
         * insert space, using TABS if hardtabs is set
         */
        while (col % P(P_TS)) {
            inschar(' ');
            col--;
        }
        if (P(P_HT)) {
            while (col) {
                inschar(TAB);
                col -= P(P_TS);
            }
        } else {
            while (col--) {
                inschar(' ');
            }
        }

        /*
         * next line
         */
        if ( ntodo > 0 ) {
            if ((p = nextline(Curschar)) != NULL) {
                *Curschar = *p;
            }
        }
    }
}

/*
 * inslines(lp, dir, buf)
 *
 * Inserts lines in the file from the given buffer. Lines are inserted
 * before or after "lp" according to the given direction flag. Newlines
 * in the buffer result in multiple lines being inserted. The cursor
 * is left on the first of the inserted lines.
 */
static void
inslines(lp, dir, buf)
LINE    *lp;
int     dir;
char    *buf;
{
        register char   *cp = buf;
        register size_t  len;
        char    *ep;
        LINE    *l, *nc = NULL;

        if (dir == BACKWARD)
                lp = lp->prev;

        do {
                if ((ep = strchr(cp, NL)) == NULL)
                        len = strlen(cp);
                else
                        len = (size_t)(ep - cp);

                l = newline(len);
                if (len != 0)
                        strncpy(l->s, cp, len);
                l->s[len] = NUL;

                l->next = lp->next;
                l->prev = lp;
                lp->next->prev = l;
                lp->next = l;

                if (nc == NULL)
                        nc = l;

                lp = lp->next;

                cp = ep + 1;
        } while (ep != NULL);

        if (dir == BACKWARD)    /* fix the top line in case we were there */
                Filemem->linep = Filetop->linep->next;

        renum();

        updatescreen();
        Curschar->linep = nc;
        Curschar->index = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\param.h ===
/* $Header: /nw/tony/src/stevie/src/RCS/param.h,v 1.8 89/08/02 10:59:35 tony Exp $
 *
 * Settable parameters
 */

struct  param {
        char    *fullname;      /* full parameter name */
        char    *shortname;     /* permissible abbreviation */
        int     value;          /* parameter value */
        int     flags;
};

extern  struct  param   params[];

/*
 * Flags
 */
#define P_BOOL          0x01    /* the parameter is boolean */
#define P_NUM           0x02    /* the parameter is numeric */
#define P_CHANGED       0x04    /* the parameter has been changed */

/*
 * The following are the indices in the params array for each parameter
 */

/*
 * Numeric parameters
 */
#define P_TS            0       /* tab size */
#define P_SS            1       /* scroll size */
#define P_RP            2       /* report */
#define P_LI            3       /* lines */

/*
 * Boolean parameters
 */
#define P_VB            4       /* visual bell */
#define P_SM            5       /* showmatch */
#define P_WS            6       /* wrap scan */
#define P_EB            7       /* error bells */
#define P_MO            8       /* show mode */
#define P_BK            9       /* make backups when writing out files */
#define P_CR            10      /* use cr-lf to terminate lines on writes */
#define P_LS            11      /* show tabs and newlines graphically */
#define P_IC            12      /* ignore case in searches */
#define P_AI            13      /* auto-indent */
#define P_NU            14      /* number lines on the screen */
#define P_ML            15      /* enables mode-lines processing */
#define P_TO            16      /* if true, tilde is an operator */
#define P_TE            17      /* ignored; here for compatibility */
#define P_CS            18      /* Cursor size */
#define P_HS            19      /* Highlight search result */
#define P_CO            20      /* Number of columns */
#define P_HT            21      /* hard tabs flag */
#define P_SW            22      /* shift width for << and >> */

/*
 * Macro to get the value of a parameter
 */
#define P(n)    (params[n].value)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\ptrfunc.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/ptrfunc.c,v 1.5 89/03/11 22:43:12 tony Exp $
 *
 * The routines in this file attempt to imitate many of the operations
 * that used to be performed on simple character pointers and are now
 * performed on LNPTR's. This makes it easier to modify other sections
 * of the code. Think of an LNPTR as representing a position in the file.
 * Positions can be incremented, decremented, compared, etc. through
 * the functions implemented here.
 */

#include "stevie.h"

/*
 * inc(p)
 *
 * Increment the line pointer 'p' crossing line boundaries as necessary.
 * Return 1 when crossing a line, -1 when at end of file, 0 otherwise.
 */
int
inc(lp)
register LNPTR   *lp;
{
	register char	*p;

	if (lp && lp->linep)
		p = &(lp->linep->s[lp->index]);
	else
		return -1;

	if (*p != NUL) {			/* still within line */
		lp->index++;
		return ((p[1] != NUL) ? 0 : 1);
	}

	if (lp->linep->next != Fileend->linep) {  /* there is a next line */
		lp->index = 0;
		lp->linep = lp->linep->next;
		return 1;
	}

	return -1;
}

/*
 * dec(p)
 *
 * Decrement the line pointer 'p' crossing line boundaries as necessary.
 * Return 1 when crossing a line, -1 when at start of file, 0 otherwise.
 */
int
dec(lp)
register LNPTR   *lp;
{
	if (lp->index > 0) {			/* still within line */
		lp->index--;
		return 0;
	}

	if (lp->linep &&
	    lp->linep->prev != Filetop->linep) { /* there is a prior line */
		lp->linep = lp->linep->prev;
		lp->index = strlen(lp->linep->s);
		return 1;
	}

	lp->index = 0;				/* stick at first char */
	return -1;				/* at start of file */
}

/*
 * gchar(lp) - get the character at position "lp"
 */
int
gchar(lp)
register LNPTR   *lp;
{
	if (lp && lp->linep)
		return (lp->linep->s[lp->index]);
	else
		return 0;
}

/*
 * pchar(lp, c) - put character 'c' at position 'lp'
 */
void
pchar(lp, c)
register LNPTR   *lp;
char	c;
{
	lp->linep->s[lp->index] = c;
}

/*
 * pswap(a, b) - swap two position pointers
 */
void
pswap(a, b)
register LNPTR   *a, *b;
{
    LNPTR    tmp;

	tmp = *a;
	*a  = *b;
	*b  = tmp;
}

/*
 * Position comparisons
 */

bool_t
lt(a, b)
register LNPTR   *a, *b;
{
	register int	an, bn;

	an = LINEOF(a);
	bn = LINEOF(b);

	if (an != bn)
		return (an < bn);
	else
		return (a->index < b->index);
}

#if 0
bool_t
gt(a, b)
LNPTR    *a, *b;
{
	register int an, bn;

	an = LINEOF(a);
	bn = LINEOF(b);

	if (an != bn)
		return (an > bn);
	else
		return (a->index > b->index);
}
#endif

bool_t
equal(a, b)
register LNPTR   *a, *b;
{
	return (a->linep == b->linep && a->index == b->index);
}

bool_t
ltoreq(a, b)
register LNPTR   *a, *b;
{
	return (lt(a, b) || equal(a, b));
}

#if 0
bool_t
gtoreq(a, b)
LNPTR    *a, *b;
{
	return (gt(a, b) || equal(a, b));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\regexp.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/regexp.c,v 1.5 89/07/07 16:27:11 tony Exp $
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by
 * Henry Spencer. This code has been modified specifically for use
 * with the STEVIE editor, and should not be used apart from compiling
 * STEVIE. If you want a good regular expression library, get the
 * original code. The copyright notice that follows is from the
 * original.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 *
 * regcomp and regexec -- regsub and regerror are elsewhere
 *
 *      Copyright (c) 1986 by University of Toronto.
 *      Written by Henry Spencer.  Not derived from licensed software.
 *
 *      Permission is granted to anyone to use this software for any
 *      purpose on any computer system, and to redistribute it freely,
 *      subject to the following restrictions:
 *
 *      1. The author is not responsible for the consequences of use of
 *              this software, no matter how awful, even if they arise
 *              from defects in it.
 *
 *      2. The origin of this software must not be misrepresented, either
 *              by explicit claim or by omission.
 *
 *      3. Altered versions must be plainly marked as such, and must not
 *              be misrepresented as being the original software.
 *
 * Beware that some of this code is subtly aware of the way operator
 * precedence is structured in regular expressions.  Serious changes in
 * regular-expression syntax might require a total rethink.
 *
 */

#include "env.h"

#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include "regexp.h"
#include "regmagic.h"

int cstrncmp(char *,char *,int);
char *cstrchr(char *,char);
/*
 * The "internal use only" fields in regexp.h are present to pass info from
 * compile to execute that permits the execute phase to run lots faster on
 * simple cases.  They are:
 *
 * regstart     char that must begin a match; '\0' if none obvious
 * reganch      is the match anchored (at beginning-of-line only)?
 * regmust      string (pointer into program) that match must include, or NULL
 * regmlen      length of regmust string
 *
 * Regstart and reganch permit very fast decisions on suitable starting points
 * for a match, cutting down the work a lot.  Regmust permits fast rejection
 * of lines that cannot possibly match.  The regmust tests are costly enough
 * that regcomp() supplies a regmust only if the r.e. contains something
 * potentially expensive (at present, the only such thing detected is * or +
 * at the start of the r.e., which can involve a lot of backup).  Regmlen is
 * supplied because the test in regexec() needs it and regcomp() is computing
 * it anyway.
 */

/*
 * Structure for regexp "program".  This is essentially a linear encoding
 * of a nondeterministic finite-state machine (aka syntax charts or
 * "railroad normal form" in parsing technology).  Each node is an opcode
 * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
 * all nodes except BRANCH implement concatenation; a "next" pointer with
 * a BRANCH on both ends of it is connecting two alternatives.  (Here we
 * have one of the subtle syntax dependencies:  an individual BRANCH (as
 * opposed to a collection of them) is never concatenated with anything
 * because of operator precedence.)  The operand of some types of node is
 * a literal string; for others, it is a node leading into a sub-FSM.  In
 * particular, the operand of a BRANCH node is the first node of the branch.
 * (NB this is *not* a tree structure:  the tail of the branch connects
 * to the thing following the set of BRANCHes.)  The opcodes are:
 */

/* definition   number  opnd?   meaning */
#define END     0       /* no   End of program. */
#define BOL     1       /* no   Match "" at beginning of line. */
#define EOL     2       /* no   Match "" at end of line. */
#define ANY     3       /* no   Match any one character. */
#define ANYOF   4       /* str  Match any character in this string. */
#define ANYBUT  5       /* str  Match any character not in this string. */
#define BRANCH  6       /* node Match this alternative, or the next... */
#define BACK    7       /* no   Match "", "next" ptr points backward. */
#define EXACTLY 8       /* str  Match this string. */
#define NOTHING 9       /* no   Match empty string. */
#define STAR    10      /* node Match this (simple) thing 0 or more times. */
#define PLUS    11      /* node Match this (simple) thing 1 or more times. */
#define OPEN    20      /* no   Mark this point in input as start of #n. */
                        /*      OPEN+1 is number 1, etc. */
#define CLOSE   30      /* no   Analogous to OPEN. */

/*
 * Opcode notes:
 *
 * BRANCH       The set of branches constituting a single choice are hooked
 *              together with their "next" pointers, since precedence prevents
 *              anything being concatenated to any individual branch.  The
 *              "next" pointer of the last BRANCH in a choice points to the
 *              thing following the whole choice.  This is also where the
 *              final "next" pointer of each individual branch points; each
 *              branch starts with the operand node of a BRANCH node.
 *
 * BACK         Normal "next" pointers all implicitly point forward; BACK
 *              exists to make loop structures possible.
 *
 * STAR,PLUS    '?', and complex '*' and '+', are implemented as circular
 *              BRANCH structures using BACK.  Simple cases (one character
 *              per match) are implemented with STAR and PLUS for speed
 *              and to minimize recursive plunges.
 *
 * OPEN,CLOSE   ...are numbered at compile time.
 */

/*
 * A node is one char of opcode followed by two chars of "next" pointer.
 * "Next" pointers are stored as two 8-bit pieces, high order first.  The
 * value is a positive offset from the opcode of the node containing it.
 * An operand, if any, simply follows the node.  (Note that much of the
 * code generation knows about this implicit relationship.)
 *
 * Using two bytes for the "next" pointer is vast overkill for most things,
 * but allows patterns to get big without disasters.
 */
#define OP(p)   (*(p))
#define NEXT(p) (((*((p)+1)&0377)<<8) + (*((p)+2)&0377))
#define OPERAND(p)      ((p) + 3)

/*
 * See regmagic.h for one further detail of program structure.
 */


/*
 * Utility definitions.
 */
#ifndef CHARBITS
#define UCHARAT(p)      ((int)*(unsigned char *)(p))
#else
#define UCHARAT(p)      ((int)*(p)&CHARBITS)
#endif

#define FAIL(m) { regerror(m); return(NULL); }
#define ISMULT(c)       ((c) == '*' || (c) == '+' || (c) == '?')
#define META    "^$.[()|?+*\\"

/*
 * Flags to be passed up and down.
 */
#define HASWIDTH        01      /* Known never to match null string. */
#define SIMPLE          02      /* Simple enough to be STAR/PLUS operand. */
#define SPSTART         04      /* Starts with * or +. */
#define WORST           0       /* Worst case. */

#ifndef ORIGINAL
/*
 * The following supports the ability to ignore case in searches.
 */

#include <ctype.h>

int reg_ic = 0;                 /* set by callers to ignore case */

/*
 * mkup - convert to upper case IF we're doing caseless compares
 */
#define mkup(c)         ((reg_ic && islower(c)) ? toupper(c) : (c))

#endif

/*
 * Global work variables for regcomp().
 */
static char *regparse;          /* Input-scan pointer. */
static int regnpar;             /* () count. */
static char regdummy;
static char *regcode;           /* Code-emit pointer; &regdummy = don't. */
static long regsize;            /* Code size. */

/*
 * Forward declarations for regcomp()'s friends.
 */
#ifndef STATIC
#define STATIC  static
#endif
STATIC char *reg();
STATIC char *regbranch();
STATIC char *regpiece();
STATIC char *regatom();
STATIC char *regnode();
STATIC char *regnext();
STATIC void regc();
STATIC void reginsert();
STATIC void regtail();
STATIC void regoptail();
#ifdef STRCSPN
STATIC int strcspn();
#endif

/*
 - regcomp - compile a regular expression into internal code
 *
 * We can't allocate space until we know how big the compiled form will be,
 * but we can't compile it (and thus know how big it is) until we've got a
 * place to put the code.  So we cheat:  we compile it twice, once with code
 * generation turned off and size counting turned on, and once "for real".
 * This also means that we don't allocate space until we are sure that the
 * thing really will compile successfully, and we never have to move the
 * code and thus invalidate pointers into it.  (Note that it has to be in
 * one piece because free() must be able to free it all.)
 *
 * Beware that the optimization-preparation code in here knows about some
 * of the structure of the compiled regexp.
 */
regexp *
regcomp(exp)
char *exp;
{
        register regexp *r;
        register char *scan;
        register char *longest;
        register int len;
        int flags;

        if (exp == NULL)
                FAIL("NULL argument");

        /* First pass: determine size, legality. */
        regparse = exp;
        regnpar = 1;
        regsize = 0L;
        regcode = &regdummy;
        regc(MAGIC);
        if (reg(0, &flags) == NULL)
                return(NULL);

        /* Small enough for pointer-storage convention? */
        if (regsize >= 32767L)          /* Probably could be 65535L. */
                FAIL("regexp too big");

        /* Allocate space. */
        r = (regexp *)malloc(sizeof(regexp) + (unsigned)regsize);
        if (r == NULL)
                FAIL("out of space");

        /* Second pass: emit code. */
        regparse = exp;
        regnpar = 1;
        regcode = r->program;
        regc(MAGIC);
        if (reg(0, &flags) == NULL)
                return(NULL);

        /* Dig out information for optimizations. */
        r->regstart = '\0';     /* Worst-case defaults. */
        r->reganch = 0;
        r->regmust = NULL;
        r->regmlen = 0;
        scan = r->program+1;                    /* First BRANCH. */
        if (OP(regnext(scan)) == END) {         /* Only one top-level choice. */
                scan = OPERAND(scan);

                /* Starting-point info. */
                if (OP(scan) == EXACTLY)
                        r->regstart = *OPERAND(scan);
                else if (OP(scan) == BOL)
                        r->reganch++;

                /*
                 * If there's something expensive in the r.e., find the
                 * longest literal string that must appear and make it the
                 * regmust.  Resolve ties in favor of later strings, since
                 * the regstart check works with the beginning of the r.e.
                 * and avoiding duplication strengthens checking.  Not a
                 * strong reason, but sufficient in the absence of others.
                 */
                if (flags&SPSTART) {
                        longest = NULL;
                        len = 0;
                        for (; scan != NULL; scan = regnext(scan))
                                if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= (size_t)len) {
                                        longest = OPERAND(scan);
                                        len = strlen(OPERAND(scan));
                                }
                        r->regmust = longest;
                        r->regmlen = len;
                }
        }

        return(r);
}

/*
 - reg - regular expression, i.e. main body or parenthesized thing
 *
 * Caller must absorb opening parenthesis.
 *
 * Combining parenthesis handling with the base level of regular expression
 * is a trifle forced, but the need to tie the tails of the branches to what
 * follows makes it hard to avoid.
 */
static char *
reg(paren, flagp)
int paren;                      /* Parenthesized? */
int *flagp;
{
        register char *ret;
        register char *br;
        register char *ender;
        register int parno;
        int flags;

        *flagp = HASWIDTH;      /* Tentatively. */

        /* Make an OPEN node, if parenthesized. */
        if (paren) {
                if (regnpar >= NSUBEXP)
                        FAIL("too many ()");
                parno = regnpar;
                regnpar++;
                ret = regnode(OPEN+parno);
        } else
                ret = NULL;

        /* Pick up the branches, linking them together. */
        br = regbranch(&flags);
        if (br == NULL)
                return(NULL);
        if (ret != NULL)
                regtail(ret, br);       /* OPEN -> first. */
        else
                ret = br;
        if (!(flags&HASWIDTH))
                *flagp &= ~HASWIDTH;
        *flagp |= flags&SPSTART;
        while (*regparse == '|') {
                regparse++;
                br = regbranch(&flags);
                if (br == NULL)
                        return(NULL);
                regtail(ret, br);       /* BRANCH -> BRANCH. */
                if (!(flags&HASWIDTH))
                        *flagp &= ~HASWIDTH;
                *flagp |= flags&SPSTART;
        }

        /* Make a closing node, and hook it on the end. */
        ender = regnode((paren) ? CLOSE+parno : END);
        regtail(ret, ender);

        /* Hook the tails of the branches to the closing node. */
        for (br = ret; br != NULL; br = regnext(br))
                regoptail(br, ender);

        /* Check for proper termination. */
        if (paren && *regparse++ != ')') {
                FAIL("unmatched ()");
        } else if (!paren && *regparse != '\0') {
                if (*regparse == ')') {
                        FAIL("unmatched ()");
                } else
                        FAIL("junk on end");    /* "Can't happen". */
                /* NOTREACHED */
        }

        return(ret);
}

/*
 - regbranch - one alternative of an | operator
 *
 * Implements the concatenation operator.
 */
static char *
regbranch(flagp)
int *flagp;
{
        register char *ret;
        register char *chain;
        register char *latest;
        int flags;

        *flagp = WORST;         /* Tentatively. */

        ret = regnode(BRANCH);
        chain = NULL;
        while (*regparse != '\0' && *regparse != '|' && *regparse != ')') {
                latest = regpiece(&flags);
                if (latest == NULL)
                        return(NULL);
                *flagp |= flags&HASWIDTH;
                if (chain == NULL)      /* First piece. */
                        *flagp |= flags&SPSTART;
                else
                        regtail(chain, latest);
                chain = latest;
        }
        if (chain == NULL)      /* Loop ran zero times. */
                (void) regnode(NOTHING);

        return(ret);
}

/*
 - regpiece - something followed by possible [*+?]
 *
 * Note that the branching code sequences used for ? and the general cases
 * of * and + are somewhat optimized:  they use the same NOTHING node as
 * both the endmarker for their branch list and the body of the last branch.
 * It might seem that this node could be dispensed with entirely, but the
 * endmarker role is not redundant.
 */
static char *
regpiece(flagp)
int *flagp;
{
        register char *ret;
        register char op;
        register char *next;
        int flags;

        ret = regatom(&flags);
        if (ret == NULL)
                return(NULL);

        op = *regparse;
        if (!ISMULT(op)) {
                *flagp = flags;
                return(ret);
        }

        if (!(flags&HASWIDTH) && op != '?')
                FAIL("*+ operand could be empty");
        *flagp = (op != '+') ? (WORST|SPSTART) : (WORST|HASWIDTH);

        if (op == '*' && (flags&SIMPLE))
                reginsert(STAR, ret);
        else if (op == '*') {
                /* Emit x* as (x&|), where & means "self". */
                reginsert(BRANCH, ret);                 /* Either x */
                regoptail(ret, regnode(BACK));          /* and loop */
                regoptail(ret, ret);                    /* back */
                regtail(ret, regnode(BRANCH));          /* or */
                regtail(ret, regnode(NOTHING));         /* null. */
        } else if (op == '+' && (flags&SIMPLE))
                reginsert(PLUS, ret);
        else if (op == '+') {
                /* Emit x+ as x(&|), where & means "self". */
                next = regnode(BRANCH);                 /* Either */
                regtail(ret, next);
                regtail(regnode(BACK), ret);            /* loop back */
                regtail(next, regnode(BRANCH));         /* or */
                regtail(ret, regnode(NOTHING));         /* null. */
        } else if (op == '?') {
                /* Emit x? as (x|) */
                reginsert(BRANCH, ret);                 /* Either x */
                regtail(ret, regnode(BRANCH));          /* or */
                next = regnode(NOTHING);                /* null. */
                regtail(ret, next);
                regoptail(ret, next);
        }
        regparse++;
        if (ISMULT(*regparse))
                FAIL("nested *?+");

        return(ret);
}

/*
 - regatom - the lowest level
 *
 * Optimization:  gobbles an entire sequence of ordinary characters so that
 * it can turn them into a single node, which is smaller to store and
 * faster to run.  Backslashed characters are exceptions, each becoming a
 * separate node; the code is simpler that way and it's not worth fixing.
 */
static char *
regatom(flagp)
int *flagp;
{
        register char *ret;
        int flags;

        *flagp = WORST;         /* Tentatively. */

        switch (*regparse++) {
        case '^':
                ret = regnode(BOL);
                break;
        case '$':
                ret = regnode(EOL);
                break;
        case '.':
                ret = regnode(ANY);
                *flagp |= HASWIDTH|SIMPLE;
                break;
        case '[': {
                        register int class;
                        register int classend;

                        if (*regparse == '^') { /* Complement of range. */
                                ret = regnode(ANYBUT);
                                regparse++;
                        } else
                                ret = regnode(ANYOF);
                        if (*regparse == ']' || *regparse == '-')
                                regc(*regparse++);
                        while (*regparse != '\0' && *regparse != ']') {
                                if (*regparse == '-') {
                                        regparse++;
                                        if (*regparse == ']' || *regparse == '\0')
                                                regc('-');
                                        else {
                                                class = UCHARAT(regparse-2)+1;
                                                classend = UCHARAT(regparse);
                                                if (class > classend+1)
                                                        FAIL("invalid [] range");
                                                for (; class <= classend; class++)
                                                        regc(class);
                                                regparse++;
                                        }
                                } else
                                        regc(*regparse++);
                        }
                        regc('\0');
                        if (*regparse != ']')
                                FAIL("unmatched []");
                        regparse++;
                        *flagp |= HASWIDTH|SIMPLE;
                }
                break;
        case '(':
                ret = reg(1, &flags);
                if (ret == NULL)
                        return(NULL);
                *flagp |= flags&(HASWIDTH|SPSTART);
                break;
        case '\0':
        case '|':
        case ')':
                FAIL("internal urp");   /* Supposed to be caught earlier. */
                break;
        case '?':
        case '+':
        case '*':
                FAIL("?+* follows nothing");
                break;
        case '\\':
                if (*regparse == '\0')
                        FAIL("trailing \\");
                ret = regnode(EXACTLY);
                regc(*regparse++);
                regc('\0');
                *flagp |= HASWIDTH|SIMPLE;
                break;
        default: {
                        register int len;
                        register char ender;

                        regparse--;
                        len = strcspn(regparse, META);
                        if (len <= 0)
                                FAIL("internal disaster");
                        ender = *(regparse+len);
                        if (len > 1 && ISMULT(ender))
                                len--;          /* Back off clear of ?+* operand. */
                        *flagp |= HASWIDTH;
                        if (len == 1)
                                *flagp |= SIMPLE;
                        ret = regnode(EXACTLY);
                        while (len > 0) {
                                regc(*regparse++);
                                len--;
                        }
                        regc('\0');
                }
                break;
        }

        return(ret);
}

/*
 - regnode - emit a node
 */
static char *                   /* Location. */
regnode(op)
char op;
{
        register char *ret;
        register char *ptr;

        ret = regcode;
        if (ret == &regdummy) {
                regsize += 3;
                return(ret);
        }

        ptr = ret;
        *ptr++ = op;
        *ptr++ = '\0';          /* Null "next" pointer. */
        *ptr++ = '\0';
        regcode = ptr;

        return(ret);
}

/*
 - regc - emit (if appropriate) a byte of code
 */
static void
regc(b)
char b;
{
        if (regcode != &regdummy)
                *regcode++ = b;
        else
                regsize++;
}

/*
 - reginsert - insert an operator in front of already-emitted operand
 *
 * Means relocating the operand.
 */
static void
reginsert(op, opnd)
char op;
char *opnd;
{
        register char *src;
        register char *dst;
        register char *place;

        if (regcode == &regdummy) {
                regsize += 3;
                return;
        }

        src = regcode;
        regcode += 3;
        dst = regcode;
        while (src > opnd)
                *--dst = *--src;

        place = opnd;           /* Op node, where operand used to be. */
        *place++ = op;
        *place++ = '\0';
        *place++ = '\0';
}

/*
 - regtail - set the next-pointer at the end of a node chain
 */
static void
regtail(p, val)
char *p;
char *val;
{
        register char *scan;
        register char *temp;
        register int offset;

        if (p == &regdummy)
                return;

        /* Find last node. */
        scan = p;
        for (;;) {
                temp = regnext(scan);
                if (temp == NULL)
                        break;
                scan = temp;
        }

        if (OP(scan) == BACK)
                offset = (int)(scan - val);
        else
                offset = (int)(val - scan);
        *(scan+1) = (char)((offset>>8)&0377);
        *(scan+2) = (char)(offset&0377);
}

/*
 - regoptail - regtail on operand of first argument; nop if operandless
 */
static void
regoptail(p, val)
char *p;
char *val;
{
        /* "Operandless" and "op != BRANCH" are synonymous in practice. */
        if (p == NULL || p == &regdummy || OP(p) != BRANCH)
                return;
        regtail(OPERAND(p), val);
}

/*
 * regexec and friends
 */

/*
 * Global work variables for regexec().
 */
static char *reginput;          /* String-input pointer. */
static char *regbol;            /* Beginning of input, for ^ check. */
static char **regstartp;        /* Pointer to startp array. */
static char **regendp;          /* Ditto for endp. */

/*
 * Forwards.
 */
STATIC int regtry();
STATIC int regmatch();
STATIC int regrepeat();

#ifdef DEBUG
int regnarrate = 0;
void regdump();
STATIC char *regprop();
#endif

/*
 - regexec - match a regexp against a string
 */
int
regexec(regexp *prog, char *string, int at_bol)
{
        register char *s;

        /* Be paranoid... */
        if (prog == NULL || string == NULL) {
                regerror("NULL parameter");
                return(0);
        }

        /* Check validity of program. */
        if (UCHARAT(prog->program) != MAGIC) {
                regerror("corrupted program");
                return(0);
        }

        /* If there is a "must appear" string, look for it. */
        if (prog->regmust != NULL) {
                s = string;
                while ((s = cstrchr(s, prog->regmust[0])) != NULL) {
                        if (cstrncmp(s, prog->regmust, prog->regmlen) == 0)
                                break;  /* Found it. */
                        s++;
                }
                if (s == NULL)  /* Not present. */
                        return(0);
        }

        /* Mark beginning of line for ^ . */
        if (at_bol)
                regbol = string;        /* is possible to match bol */
        else
                regbol = NULL;          /* we aren't there, so don't match it */

        /* Simplest case:  anchored match need be tried only once. */
        if (prog->reganch)
                return(regtry(prog, string));

        /* Messy cases:  unanchored match. */
        s = string;
        if (prog->regstart != '\0')
                /* We know what char it must start with. */
                while ((s = cstrchr(s, prog->regstart)) != NULL) {
                        if (regtry(prog, s))
                                return(1);
                        s++;
                }
        else
                /* We don't -- general case. */
                do {
                        if (regtry(prog, s))
                                return(1);
                } while (*s++ != '\0');

        /* Failure. */
        return(0);
}

/*
 - regtry - try match at specific point
 */
static int                      /* 0 failure, 1 success */
regtry(prog, string)
regexp *prog;
char *string;
{
        register int i;
        register char **sp;
        register char **ep;

        reginput = string;
        regstartp = prog->startp;
        regendp = prog->endp;

        sp = prog->startp;
        ep = prog->endp;
        for (i = NSUBEXP; i > 0; i--) {
                *sp++ = NULL;
                *ep++ = NULL;
        }
        if (regmatch(prog->program + 1)) {
                prog->startp[0] = string;
                prog->endp[0] = reginput;
                return(1);
        } else
                return(0);
}

/*
 - regmatch - main matching routine
 *
 * Conceptually the strategy is simple:  check to see whether the current
 * node matches, call self recursively to see whether the rest matches,
 * and then act accordingly.  In practice we make some effort to avoid
 * recursion, in particular by going through "ordinary" nodes (that don't
 * need to know whether the rest of the match failed) by a loop instead of
 * by recursion.
 */
static int                      /* 0 failure, 1 success */
regmatch(prog)
char *prog;
{
        register char *scan;    /* Current node. */
        char *next;             /* Next node. */

        scan = prog;
#ifdef DEBUG
        if (scan != NULL && regnarrate)
                fprintf(stderr, "%s(\n", regprop(scan));
#endif
        while (scan != NULL) {
#ifdef DEBUG
                if (regnarrate)
                        fprintf(stderr, "%s...\n", regprop(scan));
#endif
                next = regnext(scan);

                switch (OP(scan)) {
                case BOL:
                        if (reginput != regbol)
                                return(0);
                        break;
                case EOL:
                        if (*reginput != '\0')
                                return(0);
                        break;
                case ANY:
                        if (*reginput == '\0')
                                return(0);
                        reginput++;
                        break;
                case EXACTLY: {
                                register int len;
                                register char *opnd;

                                opnd = OPERAND(scan);
                                /* Inline the first character, for speed. */
                                if (mkup(*opnd) != mkup(*reginput))
                                        return(0);
                                len = strlen(opnd);
                                if (len > 1 && cstrncmp(opnd,reginput,len) != 0)
                                        return(0);
                                reginput += len;
                        }
                        break;
                case ANYOF:
                        if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) == NULL)
                                return(0);
                        reginput++;
                        break;
                case ANYBUT:
                        if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) != NULL)
                                return(0);
                        reginput++;
                        break;
                case NOTHING:
                        break;
                case BACK:
                        break;
                case OPEN+1:
                case OPEN+2:
                case OPEN+3:
                case OPEN+4:
                case OPEN+5:
                case OPEN+6:
                case OPEN+7:
                case OPEN+8:
                case OPEN+9: {
                                register int no;
                                register char *save;

                                no = OP(scan) - OPEN;
                                save = reginput;

                                if (regmatch(next)) {
                                        /*
                                         * Don't set startp if some later
                                         * invocation of the same parentheses
                                         * already has.
                                         */
                                        if (regstartp[no] == NULL)
                                                regstartp[no] = save;
                                        return(1);
                                } else
                                        return(0);
                        }
                        break;
                case CLOSE+1:
                case CLOSE+2:
                case CLOSE+3:
                case CLOSE+4:
                case CLOSE+5:
                case CLOSE+6:
                case CLOSE+7:
                case CLOSE+8:
                case CLOSE+9: {
                                register int no;
                                register char *save;

                                no = OP(scan) - CLOSE;
                                save = reginput;

                                if (regmatch(next)) {
                                        /*
                                         * Don't set endp if some later
                                         * invocation of the same parentheses
                                         * already has.
                                         */
                                        if (regendp[no] == NULL)
                                                regendp[no] = save;
                                        return(1);
                                } else
                                        return(0);
                        }
                        break;
                case BRANCH: {
                                register char *save;

                                if (OP(next) != BRANCH)         /* No choice. */
                                        next = OPERAND(scan);   /* Avoid recursion. */
                                else {
                                        do {
                                                save = reginput;
                                                if (regmatch(OPERAND(scan)))
                                                        return(1);
                                                reginput = save;
                                                scan = regnext(scan);
                                        } while (scan != NULL && OP(scan) == BRANCH);
                                        return(0);
                                        /* NOTREACHED */
                                }
                        }
                        break;
                case STAR:
                case PLUS: {
                                register char nextch;
                                register int no;
                                register char *save;
                                register int min;

                                /*
                                 * Lookahead to avoid useless match attempts
                                 * when we know what character comes next.
                                 */
                                nextch = '\0';
                                if (OP(next) == EXACTLY)
                                        nextch = *OPERAND(next);
                                min = (OP(scan) == STAR) ? 0 : 1;
                                save = reginput;
                                no = regrepeat(OPERAND(scan));
                                while (no >= min) {
                                        /* If it could work, try it. */
                                        if (nextch == '\0' || *reginput == nextch)
                                                if (regmatch(next))
                                                        return(1);
                                        /* Couldn't or didn't -- back up. */
                                        no--;
                                        reginput = save + no;
                                }
                                return(0);
                        }
                        break;
                case END:
                        return(1);      /* Success! */
                        break;
                default:
                        regerror("memory corruption");
                        return(0);
                        break;
                }

                scan = next;
        }

        /*
         * We get here only if there's trouble -- normally "case END" is
         * the terminating point.
         */
        regerror("corrupted pointers");
        return(0);
}

/*
 - regrepeat - repeatedly match something simple, report how many
 */
static int
regrepeat(p)
char *p;
{
        register int count = 0;
        register char *scan;
        register char *opnd;

        scan = reginput;
        opnd = OPERAND(p);
        switch (OP(p)) {
        case ANY:
                count = strlen(scan);
                scan += count;
                break;
        case EXACTLY:
                while (mkup(*opnd) == mkup(*scan)) {
                        count++;
                        scan++;
                }
                break;
        case ANYOF:
                while (*scan != '\0' && strchr(opnd, *scan) != NULL) {
                        count++;
                        scan++;
                }
                break;
        case ANYBUT:
                while (*scan != '\0' && strchr(opnd, *scan) == NULL) {
                        count++;
                        scan++;
                }
                break;
        default:                /* Oh dear.  Called inappropriately. */
                regerror("internal foulup");
                count = 0;      /* Best compromise. */
                break;
        }
        reginput = scan;

        return(count);
}

/*
 - regnext - dig the "next" pointer out of a node
 */
static char *
regnext(p)
register char *p;
{
        register int offset;

        if (p == &regdummy)
                return(NULL);

        offset = NEXT(p);
        if (offset == 0)
                return(NULL);

        if (OP(p) == BACK)
                return(p-offset);
        else
                return(p+offset);
}

#ifdef DEBUG

STATIC char *regprop();

/*
 - regdump - dump a regexp onto stdout in vaguely comprehensible form
 */
void
regdump(r)
regexp *r;
{
        register char *s;
        register char op = EXACTLY;     /* Arbitrary non-END op. */
        register char *next;

        s = r->program + 1;
        while (op != END) {     /* While that wasn't END last time... */
                op = OP(s);
                printf("%2d%s", s-r->program, regprop(s));      /* Where, what. */
                next = regnext(s);
                if (next == NULL)               /* Next ptr. */
                        printf("(0)");
                else
                        printf("(%d)", (s-r->program)+(next-s));
                s += 3;
                if (op == ANYOF || op == ANYBUT || op == EXACTLY) {
                        /* Literal string, where present. */
                        while (*s != '\0') {
                                putchar(*s);
                                s++;
                        }
                        s++;
                }
                putchar('\n');
        }

        /* Header fields of interest. */
        if (r->regstart != '\0')
                printf("start `%c' ", r->regstart);
        if (r->reganch)
                printf("anchored ");
        if (r->regmust != NULL)
                printf("must have \"%s\"", r->regmust);
        printf("\n");
}

/*
 - regprop - printable representation of opcode
 */
static char *
regprop(op)
char *op;
{
        register char *p;
        static char buf[50];

        (void) strcpy(buf, ":");

        switch (OP(op)) {
        case BOL:
                p = "BOL";
                break;
        case EOL:
                p = "EOL";
                break;
        case ANY:
                p = "ANY";
                break;
        case ANYOF:
                p = "ANYOF";
                break;
        case ANYBUT:
                p = "ANYBUT";
                break;
        case BRANCH:
                p = "BRANCH";
                break;
        case EXACTLY:
                p = "EXACTLY";
                break;
        case NOTHING:
                p = "NOTHING";
                break;
        case BACK:
                p = "BACK";
                break;
        case END:
                p = "END";
                break;
        case OPEN+1:
        case OPEN+2:
        case OPEN+3:
        case OPEN+4:
        case OPEN+5:
        case OPEN+6:
        case OPEN+7:
        case OPEN+8:
        case OPEN+9:
                sprintf(buf+strlen(buf), "OPEN%d", OP(op)-OPEN);
                p = NULL;
                break;
        case CLOSE+1:
        case CLOSE+2:
        case CLOSE+3:
        case CLOSE+4:
        case CLOSE+5:
        case CLOSE+6:
        case CLOSE+7:
        case CLOSE+8:
        case CLOSE+9:
                sprintf(buf+strlen(buf), "CLOSE%d", OP(op)-CLOSE);
                p = NULL;
                break;
        case STAR:
                p = "STAR";
                break;
        case PLUS:
                p = "PLUS";
                break;
        default:
                regerror("corrupted opcode");
                break;
        }
        if (p != NULL)
                (void) strcat(buf, p);
        return(buf);
}
#endif

/*
 * The following is provided for those people who do not have strcspn() in
 * their C libraries.  They should get off their butts and do something
 * about it; at least one public-domain implementation of those (highly
 * useful) string routines has been published on Usenet.
 */
#ifdef STRCSPN
/*
 * strcspn - find length of initial segment of s1 consisting entirely
 * of characters not from s2
 */

static int
strcspn(s1, s2)
char *s1;
char *s2;
{
        register char *scan1;
        register char *scan2;
        register int count;

        count = 0;
        for (scan1 = s1; *scan1 != '\0'; scan1++) {
                for (scan2 = s2; *scan2 != '\0';)       /* ++ moved down. */
                        if (*scan1 == *scan2++)
                                return(count);
                count++;
        }
        return(count);
}
#endif

int
cstrncmp(s1, s2, n)
char    *s1, *s2;
int     n;
{
        char    *p, *S1, *S2, *strsave();
        int     rval;

        if (!reg_ic)
                return (strncmp(s1, s2, n));

        S1 = strsave(s1);
        S2 = strsave(s2);

        for (p = S1; *p ;p++)
                if (islower(*p))
                        *p = (char)toupper(*p);

        for (p = S2; *p ;p++)
                if (islower(*p))
                        *p = (char)toupper(*p);

        rval = strncmp(S1, S2, n);

        free(S1);
        free(S2);

        return rval;
}

char *
cstrchr(
char	*s,
char	c)
{
        char    *p;

        for (p = s; *p ;p++) {
                if (mkup(*p) == mkup(c))
                        return p;
        }
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\regmagic.h ===
/*
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by
 * Henry Spencer. This code has been modified specifically for use
 * with the STEVIE editor, and should not be used apart from compiling
 * STEVIE. If you want a good regular expression library, get the
 * original code. The copyright notice that follows is from the
 * original.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * The first byte of the regexp internal "program" is actually this magic
 * number; the start node begins in the second byte.
 */
#define     MAGIC   0234
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\stevie.h ===
/*
 * $Header: /nw/tony/src/stevie/src/RCS/stevie.h,v 1.19 89/07/12 21:33:32 tony Exp $
 *
 * Main header file included by all source files.
 */

#include "env.h"        /* defines to establish the compile-time environment */

#include <excpt.h>
#include <ntdef.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "ascii.h"
#include "keymap.h"
#include "param.h"

#define NORMAL 0
#define CMDLINE 1
#define INSERT 2
#define REPLACE 3
#define FORWARD 4
#define BACKWARD 5

/*
 * Boolean type definition and constants
 */
typedef unsigned  bool_t;

#ifndef TRUE
#define FALSE   (0)
#define TRUE    (1)
#endif

/*
 * SLOP is the amount of extra space we get for text on a line during
 * editing operations that need more space. This keeps us from calling
 * malloc every time we get a character during insert mode. No extra
 * space is allocated when the file is initially read.
 */
#define SLOP            10
#define INSERTSLOP      1024    // for insert buffer
#define REDOBUFFMIN     100     // minimum size of redo buffer

/*
 * LINEINC is the gap we leave between the artificial line numbers. This
 * helps to avoid renumbering all the lines every time a new line is
 * inserted.
 */
#define LINEINC 10

#define CHANGED         Changed=TRUE
#define UNCHANGED       Changed=FALSE

struct  line {
        struct  line    *prev, *next;   /* previous and next lines */
        char    *s;                     /* text for this line */
        int     size;                   /* actual size of space at 's' */
        unsigned long   num;            /* line "number" */
};

#define LINEOF(x)       ((x)->linep->num)

struct  LNPTR {
        struct  line    *linep;         /* line we're referencing */
        int     index;                  /* position within that line */
};

typedef struct line     LINE;
typedef struct LNPTR     LNPTR;

struct charinfo {
        char ch_size;
        char *ch_str;
};

extern struct charinfo chars[];

extern  int     State;
extern  int     Rows;
extern  int     Columns;
extern  char    *Realscreen;
extern  char    *Nextscreen;
extern  char    *Filename;
extern  char    *Appname;
extern  LNPTR    *Filemem;
extern  LNPTR    *Filetop;
extern  LNPTR    *Fileend;
extern  LNPTR    *Topchar;
extern  LNPTR    *Botchar;
extern  LNPTR    *Curschar;
extern  LNPTR    *Insstart;
extern  int     Cursrow, Curscol, Cursvcol, Curswant;
extern  bool_t  set_want_col;
extern  int     Prenum,namedbuff;
extern  bool_t  Changed;
extern  char    *Redobuff, *Insbuff;
extern  int     InsbuffSize;
extern  char    *Insptr;
extern  int     Ninsert;
extern  bool_t  got_int;

/*
 * alloc.c
 */
char    *alloc(), *strsave(), *mkstr();
char    *ralloc(char *,unsigned);
void    screenalloc(), filealloc(), freeall();
LINE    *newline();
bool_t  bufempty(), buf1line(), lineempty(), endofline(), canincrease();

/*
 * cmdline.c
 */
void    doxit(),docmdln(), dotag(), msg(), emsg();
void    smsg(), gotocmd(), wait_return();
int     wait_return0();
void    dosource(char *,bool_t);
char    *getcmdln();

/*
 * edit.c
 */
void    edit(), insertchar(), getout(), scrollup(), scrolldown(), beginline();
bool_t  oneright(), oneleft(), oneup(), onedown();

/*
 * fileio.c
 */
void    filemess(), renum();
bool_t  readfile(), writeit();

/*
 * help.c
 */
bool_t  help();

/*
 * linefunc.c
 */
LNPTR    *nextline(), *prevline(), *coladvance();

/*
 * main.c
 */
void    stuffin(), stuffnum();
void    do_mlines();
int     vgetc();
bool_t  anyinput();

/*
 * mark.c
 */
void    setpcmark(), clrall(), clrmark();
bool_t  setmark();
LNPTR    *getmark();

/*
 * misccmds.c
 */
void    opencmd(), fileinfo(), inschar(), delline();
bool_t  delchar();
int     cntllines(), plines();
LNPTR    *gotoline();

/*
 * normal.c
 */
void    normal();

/*
 * ops.c
 */

void inityank();

/*
 * param.c
 */
void    doset();

/*
 * ptrfunc.c
 */
int     inc(), dec();
int     gchar();
void    pchar(), pswap();
bool_t  lt(), equal(), ltoreq();
#if 0
/* not currently used */
bool_t  gtoreq(), gt();
#endif

/*
 * screen.c
 */
void    updatescreen(), updateline();
void    screenclear(), cursupdate();
void    s_ins(), s_del();
void    prt_line();

/*
 * search.c
 */
void    dosub(), doglob();
bool_t  searchc(), crepsearch(), findfunc(), dosearch(), repsearch();
LNPTR    *showmatch();
LNPTR    *fwd_word(), *bck_word(), *end_word();

/*
 * undo.c
 */
void    u_save(), u_saveline(), u_clear();
void    u_lcheck(), u_lundo();
void    u_undo();

/*
 * Machine-dependent routines.
 */
int     inchar();
void    flushbuf();
void    outchar(), outstr(), beep();
char    *fixname();
void    windinit(), windexit(), windgoto();
void    delay();
void    doshell();
void    sleep(int);
void    setviconsoletitle();
void    dochdir();

void Scroll(int t,int l,int b,int r,int Row,int Col);
void EraseLine(void);
void EraseNLinesAtRow(int n,int row);
void InsertLine(void);
void SaveCursor(void);
void RestoreCursor(void);
void ClearDisplay(void);
void InvisibleCursor(void);
void VisibleCursor(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\regexp.h ===
/*
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by
 * Henry Spencer. This code has been modified specifically for use
 * with the STEVIE editor, and should not be used apart from compiling
 * STEVIE. If you want a good regular expression library, get the
 * original code. The copyright notice that follows is from the
 * original.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * Definitions etc. for regexp(3) routines.
 *
 * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
 * not the System V one.
 */
#define NSUBEXP  10
typedef struct regexp {
        char *startp[NSUBEXP];
        char *endp[NSUBEXP];
        char regstart;          /* Internal use only. */
        char reganch;           /* Internal use only. */
        char *regmust;          /* Internal use only. */
        int regmlen;            /* Internal use only. */
        char program[1];        /* Unwarranted chumminess with compiler. */
} regexp;

extern regexp *regcomp();
extern int regexec();
extern void regsub();
extern void regerror();

#ifndef ORIGINAL
extern int reg_ic;              /* set non-zero to ignore case in searches */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\regsub.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/regsub.c,v 1.4 89/03/11 22:43:30 tony Exp $
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by
 * Henry Spencer. This code has been modified specifically for use
 * with the STEVIE editor, and should not be used apart from compiling
 * STEVIE. If you want a good regular expression library, get the
 * original code. The copyright notice that follows is from the
 * original.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * regsub
 *
 *      Copyright (c) 1986 by University of Toronto.
 *      Written by Henry Spencer.  Not derived from licensed software.
 *
 *      Permission is granted to anyone to use this software for any
 *      purpose on any computer system, and to redistribute it freely,
 *      subject to the following restrictions:
 *
 *      1. The author is not responsible for the consequences of use of
 *              this software, no matter how awful, even if they arise
 *              from defects in it.
 *
 *      2. The origin of this software must not be misrepresented, either
 *              by explicit claim or by omission.
 *
 *      3. Altered versions must be plainly marked as such, and must not
 *              be misrepresented as being the original software.
 *
 */

#include <stdio.h>
#include <string.h>
#include "regexp.h"
#include "regmagic.h"

#ifndef CHARBITS
#define UCHARAT(p)      ((int)*(unsigned char *)(p))
#else
#define UCHARAT(p)      ((int)*(p)&CHARBITS)
#endif

/*
 - regsub - perform substitutions after a regexp match
 */
void
regsub(prog, source, dest)
regexp *prog;
char *source;
char *dest;
{
        register char *src;
        register char *dst;
        register char c;
        register int no;
        register size_t len;

        if (prog == NULL || source == NULL || dest == NULL) {
                regerror("NULL parm to regsub");
                return;
        }
        if (UCHARAT(prog->program) != MAGIC) {
                regerror("damaged regexp fed to regsub");
                return;
        }

        src = source;
        dst = dest;
        while ((c = *src++) != '\0') {
                if (c == '&')
                        no = 0;
                else if (c == '\\' && '0' <= *src && *src <= '9')
                        no = *src++ - '0';
                else
                        no = -1;
                if (no < 0) {   /* Ordinary character. */
                        if (c == '\\' && (*src == '\\' || *src == '&'))
                                c = *src++;
                        *dst++ = c;
                } else if (prog->startp[no] != NULL && prog->endp[no] != NULL) {
                        len = (size_t)(prog->endp[no] - prog->startp[no]);
                        strncpy(dst, prog->startp[no], len);
                        dst += len;
                        if (len != 0 && *(dst-1) == '\0') {     /* strncpy hit NUL. */
                                regerror("damaged match string");
                                return;
                        }
                }
        }
        *dst++ = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\screen.c ===
/*
 *
 * Routines to manipulate the screen representations.
 */

#include "stevie.h"

/*
 * This gets set if we ignored an update request while input was pending.
 * We check this when the input is drained to see if the screen should be
 * updated.
 */
bool_t  need_redraw = FALSE;

/*
 * The following variable is set (in filetonext) to the number of physical
 * lines taken by the line the cursor is on. We use this to avoid extra
 * calls to plines(). The optimized routines lfiletonext() and lnexttoscreen()
 * make sure that the size of the cursor line hasn't changed. If so, lines
 * below the cursor will move up or down and we need to call the routines
 * filetonext() and nexttoscreen() to examine the entire screen.
 */
static  int     Cline_size;     /* size (in rows) of the cursor line */
static  int     Cline_row;      /* starting row of the cursor line */

static  char    *mkline();      /* calculate line string for "number" mode */

/*
 * filetonext()
 *
 * Based on the current value of Topchar, transfer a screenfull of
 * stuff from Filemem to Nextscreen, and update Botchar.
 */

static void
filetonext()
{
        register int    row, col;
        register char   *screenp = Nextscreen;
        LNPTR    memp;
        LNPTR    save;                   /* save pos. in case line won't fit */
        register char   *endscreen;
        register char   *nextrow;
        char    extra[16];
        int     nextra = 0;
        register int    c;
        int     n;
        bool_t  done;           /* if TRUE, we hit the end of the file */
        bool_t  didline;        /* if TRUE, we finished the last line */
        int     srow;           /* starting row of the current line */
        int     lno;            /* number of the line we're doing */
        int     coff;           /* column offset */

        coff = P(P_NU) ? 8 : 0;

        save = memp = *Topchar;

        if (P(P_NU))
                lno = cntllines(Filemem, Topchar);

        /*
         * The number of rows shown is Rows-1.
         * The last line is the status/command line.
         */
        endscreen = &screenp[(Rows-1)*Columns];

        done = didline = FALSE;
        srow = row = col = 0;
        /*
         * We go one past the end of the screen so we can find out if the
         * last line fit on the screen or not.
         */
        while ( screenp <= endscreen && !done) {


                if (P(P_NU) && col == 0 && memp.index == 0) {
                        strcpy(extra, mkline(lno++));
                        nextra = 8;
                }

                /* Get the next character to put on the screen. */

                /* The 'extra' array contains the extra stuff that is */
                /* inserted to represent special characters (tabs, and */
                /* other non-printable stuff.  The order in the 'extra' */
                /* array is reversed. */

                if ( nextra > 0 )
                        c = extra[--nextra];
                else {
                        c = (unsigned)(0xff & gchar(&memp));
                        if (inc(&memp) == -1)
                                done = 1;
                        /* when getting a character from the file, we */
                        /* may have to turn it into something else on */
                        /* the way to putting it into 'Nextscreen'. */
                        if ( c == TAB && !P(P_LS) ) {
                                strcpy(extra,"        ");
                                /* tab amount depends on current column */
                                nextra = ((P(P_TS)-1) - (col - coff)%P(P_TS));
                                c = ' ';
                        }
                        else if ( c == NUL && P(P_LS) ) {
                                extra[0] = NUL;
                                nextra = 1;
                                c = '$';
                        } else if ((n = chars[c].ch_size) > 1 ) {
                                char *p;
                                nextra = 0;
                                p = chars[c].ch_str;
                                /* copy 'ch-str'ing into 'extra' in reverse */
                                while ( n > 1 )
                                        extra[nextra++] = p[--n];
                                c = p[0];
                        }
                }

                if (screenp == endscreen) {
                        /*
                         * We're one past the end of the screen. If the
                         * current character is null, then we really did
                         * finish, so set didline = TRUE. In either case,
                         * break out because we're done.
                         */
                        dec(&memp);
                        if (memp.index != 0 && c == NUL) {
                                didline = TRUE;
                                inc(&memp);
                        }
                        break;
                }

                if ( c == NUL ) {
                        srow = ++row;
                        /*
                         * Save this position in case the next line won't
                         * fit on the screen completely.
                         */
                        save = memp;
                        /* get pointer to start of next row */
                        nextrow = &Nextscreen[row*Columns];
                        /* blank out the rest of this row */
                        while ( screenp != nextrow )
                                *screenp++ = ' ';
                        col = 0;
                        continue;
                }
                if ( col >= Columns ) {
                        row++;
                        col = 0;
                }
                /* store the character in Nextscreen */
                *screenp++ = (char)c;
                col++;
        }
        /*
         * If we didn't hit the end of the file, and we didn't finish
         * the last line we were working on, then the line didn't fit.
         */
        if (!done && !didline) {
                /*
                 * Clear the rest of the screen and mark the unused lines.
                 */
                screenp = &Nextscreen[srow * Columns];
                while (screenp < endscreen)
                        *screenp++ = ' ';
                for (; srow < (Rows-1) ;srow++)
                        Nextscreen[srow * Columns] = '@';
                *Botchar = save;
                return;
        }
        /* make sure the rest of the screen is blank */
        while ( screenp < endscreen )
                *screenp++ = ' ';
        /* put '~'s on rows that aren't part of the file. */
        if ( col != 0 )
                row++;
        while ( row < Rows ) {
                Nextscreen[row*Columns] = '~';
                row++;
        }
        if (done)       /* we hit the end of the file */
                *Botchar = *Fileend;
        else
                *Botchar = memp;        /* FIX - prev? */
}

/*
 * nexttoscreen
 *
 * Transfer the contents of Nextscreen to the screen, using Realscreen
 * to avoid unnecessary output.
 */
static void
nexttoscreen()
{
        register char   *np = Nextscreen;
        register char   *rp = Realscreen;
        register char   *endscreen;
        register int    row = 0, col = 0;
        int     gorow = -1, gocol = -1;

        if (anyinput()) {
                need_redraw = TRUE;
                return;
        }

        endscreen = &np[(Rows-1)*Columns];

        InvisibleCursor();

        for ( ; np < endscreen ; np++,rp++ ) {
                /* If desired screen (contents of Nextscreen) does not */
                /* match what's really there, put it there. */
                if ( *np != *rp ) {
                        /* if we are positioned at the right place, */
                        /* we don't have to use windgoto(). */
                        if (gocol != col || gorow != row) {
                                /*
                                 * If we're just off by one, don't send
                                 * an entire esc. seq. (this happens a lot!)
                                 */
                                if (gorow == row && gocol+1 == col) {
                                        outchar(*(np-1));
                                        gocol++;
                                } else
                                        windgoto(gorow=row,gocol=col);
                        }
                        outchar(*rp = *np);
                        gocol++;
                }
                if ( ++col >= Columns ) {
                        col = 0;
                        row++;
                }
        }
        VisibleCursor();
}

/*
 * lfiletonext() - like filetonext() but only for cursor line
 *
 * Returns true if the size of the cursor line (in rows) hasn't changed.
 * This determines whether or not we need to call filetonext() to examine
 * the entire screen for changes.
 */
static bool_t
lfiletonext()
{
        register int    row, col;
        register char   *screenp;
        LNPTR    memp;
        register char   *nextrow;
        char    extra[16];
        int     nextra = 0;
        register int    c;
        int     n;
        bool_t  eof;
        int     lno;            /* number of the line we're doing */
        int     coff;           /* column offset */

        coff = P(P_NU) ? 8 : 0;

        /*
         * This should be done more efficiently.
         */
        if (P(P_NU))
                lno = cntllines(Filemem, Curschar);

        screenp = Nextscreen + (Cline_row * Columns);

        memp = *Curschar;
        memp.index = 0;

        eof = FALSE;
        col = 0;
        row = Cline_row;

        while (!eof) {

                if (P(P_NU) && col == 0 && memp.index == 0) {
                        strcpy(extra, mkline(lno));
                        nextra = 8;
                }

                /* Get the next character to put on the screen. */

                /* The 'extra' array contains the extra stuff that is */
                /* inserted to represent special characters (tabs, and */
                /* other non-printable stuff.  The order in the 'extra' */
                /* array is reversed. */

                if ( nextra > 0 )
                        c = extra[--nextra];
                else {
                        c = (unsigned)(0xff & gchar(&memp));
                        if (inc(&memp) == -1)
                                eof = TRUE;
                        /* when getting a character from the file, we */
                        /* may have to turn it into something else on */
                        /* the way to putting it into 'Nextscreen'. */
                        if ( c == TAB && !P(P_LS) ) {
                                strcpy(extra,"        ");
                                /* tab amount depends on current column */
                                nextra = ((P(P_TS)-1) - (col - coff)%P(P_TS));
                                c = ' ';
                        } else if ( c == NUL && P(P_LS) ) {
                                extra[0] = NUL;
                                nextra = 1;
                                c = '$';
                        } else if (c != NUL && (n=chars[c].ch_size) > 1 )
                        {
                                char *p;
                                nextra = 0;
                                p = chars[c].ch_str;
                                /* copy 'ch-str'ing into 'extra' in reverse */
                                while ( n > 1 )
                                        extra[nextra++] = p[--n];
                                c = p[0];
                        }
                }

                if ( c == NUL ) {
                        row++;
                        /* get pointer to start of next row */
                        nextrow = &Nextscreen[row*Columns];
                        /* blank out the rest of this row */
                        while ( screenp != nextrow )
                                *screenp++ = ' ';
                        col = 0;
                        break;
                }

                if ( col >= Columns ) {
                        row++;
                        col = 0;
                }
                /* store the character in Nextscreen */
                *screenp++ = (char)c;
                col++;
        }
        return ((row - Cline_row) == Cline_size);
}

/*
 * lnexttoscreen
 *
 * Like nexttoscreen() but only for the cursor line.
 */
static void
lnexttoscreen()
{
        register char   *np = Nextscreen + (Cline_row * Columns);
        register char   *rp = Realscreen + (Cline_row * Columns);
        register char   *endline;
        register int    row, col;
        int     gorow = -1, gocol = -1;

        if (anyinput()) {
                need_redraw = TRUE;
                return;
        }

        endline = np + (Cline_size * Columns);

        row = Cline_row;
        col = 0;

        InvisibleCursor();

        for ( ; np < endline ; np++,rp++ ) {
                /* If desired screen (contents of Nextscreen) does not */
                /* match what's really there, put it there. */
                if ( *np != *rp ) {
                        /* if we are positioned at the right place, */
                        /* we don't have to use windgoto(). */
                        if (gocol != col || gorow != row) {
                                /*
                                 * If we're just off by one, don't send
                                 * an entire esc. seq. (this happens a lot!)
                                 */
                                if (gorow == row && gocol+1 == col) {
                                        outchar(*(np-1));
                                        gocol++;
                                } else
                                        windgoto(gorow=row,gocol=col);
                        }
                        outchar(*rp = *np);
                        gocol++;
                }
                if ( ++col >= Columns ) {
                        col = 0;
                        row++;
                }
        }
        VisibleCursor();
}

static char *
mkline(n)
register int    n;
{
        static  char    lbuf[9];
        register int    i = 2;

        strcpy(lbuf, "        ");

        lbuf[i++] = (char)((n % 10) + '0');
        n /= 10;
        if (n != 0) {
                lbuf[i++] = (char)((n % 10) + '0');
                n /= 10;
        }
        if (n != 0) {
                lbuf[i++] = (char)((n % 10) + '0');
                n /= 10;
        }
        if (n != 0) {
                lbuf[i++] = (char)((n % 10) + '0');
                n /= 10;
        }
        if (n != 0) {
                lbuf[i++] = (char)((n % 10) + '0');
                n /= 10;
        }
        return lbuf;
}

/*
 * updateline() - update the line the cursor is on
 *
 * Updateline() is called after changes that only affect the line that
 * the cursor is on. This improves performance tremendously for normal
 * insert mode operation. The only thing we have to watch for is when
 * the cursor line grows or shrinks around a row boundary. This means
 * we have to repaint other parts of the screen appropriately. If
 * lfiletonext() returns FALSE, the size of the cursor line (in rows)
 * has changed and we have to call updatescreen() to do a complete job.
 */
void
updateline()
{
        if (!lfiletonext())
                updatescreen(); /* bag it, do the whole screen */
        else
                lnexttoscreen();
}

void
updatescreen()
{
        extern  bool_t  interactive;

        if (interactive) {
                filetonext();
                nexttoscreen();
        }
}

/*
 * prt_line() - print the given line
 */
void
prt_line(s)
char    *s;
{
        register int    si = 0;
        register int    c;
        register int    col = 0;

        char    extra[16];
        int     nextra = 0;
        int     n;

        for (;;) {

                if ( nextra > 0 )
                        c = extra[--nextra];
                else {
                        c = s[si++];
                        if ( c == TAB && !P(P_LS) ) {
                                strcpy(extra, "        ");
                                /* tab amount depends on current column */
                                nextra = (P(P_TS) - 1) - col%P(P_TS);
                                c = ' ';
                        } else if ( c == NUL && P(P_LS) ) {
                                extra[0] = NUL;
                                nextra = 1;
                                c = '$';
                        } else if ( c != NUL && (n=chars[c].ch_size) > 1 ) {
                                char    *p;

                                nextra = 0;
                                p = chars[c].ch_str;
                                /* copy 'ch-str'ing into 'extra' in reverse */
                                while ( n > 1 )
                                        extra[nextra++] = p[--n];
                                c = p[0];
                        }
                }

                if ( c == NUL )
                        break;

                outchar(c);
                col++;
        }
}

void
screenclear()
{
        register char   *rp, *np;
        register char   *end;

        ClearDisplay();

        rp  = Realscreen;
        end = Realscreen + Rows * Columns;
        np  = Nextscreen;

        /* blank out the stored screens */
        while (rp != end)
                *rp++ = *np++ = ' ';
}

void
cursupdate()
{
        register LNPTR   *p;
        register int    icnt, c, nlines;
        register int    i;
        int     didinc;

        if (bufempty()) {               /* special case - file is empty */
                *Topchar  = *Filemem;
                *Curschar = *Filemem;
        } else if ( LINEOF(Curschar) < LINEOF(Topchar) ) {
                nlines = cntllines(Curschar,Topchar);
                /* if the cursor is above the top of */
                /* the screen, put it at the top of the screen.. */
                *Topchar = *Curschar;
                Topchar->index = 0;
                /* ... and, if we weren't very close to begin with, */
                /* we scroll so that the line is close to the middle. */
                if ( nlines > Rows/3 ) {
                        for (i=0, p = Topchar; i < Rows/3 ;i++, *Topchar = *p)
                                if ((p = prevline(p)) == NULL)
                                        break;
                } else
                        s_ins(0, nlines-1);
                updatescreen();
        }
        else if (LINEOF(Curschar) >= LINEOF(Botchar)) {
                nlines = cntllines(Botchar,Curschar);
                /* If the cursor is off the bottom of the screen, */
                /* put it at the top of the screen.. */
                /* ... and back up */
                if ( nlines > Rows/3 ) {
                        p = Curschar;
                        for (i=0; i < (2*Rows)/3 ;i++)
                                if ((p = prevline(p)) == NULL)
                                        break;
                        *Topchar = *p;
                } else {
                        scrollup(nlines+1);
                }
                updatescreen();
        }

        Cursrow = Curscol = Cursvcol = 0;
        for ( p=Topchar; p->linep != Curschar->linep ;p = nextline(p) )
                Cursrow += plines(p);

        Cline_row = Cursrow;
        Cline_size = plines(p);

        if (P(P_NU))
                Curscol = 8;

        for (i=0; i <= Curschar->index ;i++) {
                c = Curschar->linep->s[i];
                /* A tab gets expanded, depending on the current column */
                if ( c == TAB && !P(P_LS) )
                        icnt = P(P_TS) - (Cursvcol % P(P_TS));
                else
                        icnt = chars[(unsigned)(c & 0xff)].ch_size;
                Curscol += icnt;
                Cursvcol += icnt;
                if ( Curscol >= Columns ) {
                        Curscol -= Columns;
                        Cursrow++;
                        didinc = TRUE;
                }
                else
                        didinc = FALSE;
        }
        if (didinc)
                Cursrow--;

        if (c == TAB && State == NORMAL && !P(P_LS)) {
                Curscol--;
                Cursvcol--;
        } else {
                Curscol -= icnt;
                Cursvcol -= icnt;
        }
        if (Curscol < 0)
                Curscol += Columns;

        if (set_want_col) {
                Curswant = Cursvcol;
                set_want_col = FALSE;
        }
}

/*
 * The rest of the routines in this file perform screen manipulations.
 * The given operation is performed physically on the screen. The
 * corresponding change is also made to the internal screen image.
 * In this way, the editor anticipates the effect of editing changes
 * on the appearance of the screen. That way, when we call screenupdate
 * a complete redraw isn't usually necessary. Another advantage is that
 * we can keep adding code to anticipate screen changes, and in the
 * meantime, everything still works.
 */

/*
 * s_ins(row, nlines) - insert 'nlines' lines at 'row'
 */
void
s_ins(row, nlines)
int     row;
int     nlines;
{
        register char   *s, *d;         /* src & dest for block copy */
        register char   *e;             /* end point for copy */

        SaveCursor();

        // clip to screen

        if(row <= Rows-2-nlines) {
            Scroll(row,0,Rows-2-nlines,Columns-1,row+nlines,0);
            EraseNLinesAtRow(nlines,row);
        } else {
            // just erase to end of screen
            EraseNLinesAtRow(Rows-2-row+1,row);
        }

        windgoto(Rows-1, 0);    /* delete any garbage that may have */
        EraseLine();
        RestoreCursor();

        /*
         * Now do a block move to update the internal screen image
         */
        d = Realscreen + (Columns * (Rows - 1)) - 1;
        s = d - (Columns * nlines);
        e = Realscreen + (Columns * row);

        while (s >= e)
                *d-- = *s--;

        /*
         * Clear the inserted lines
         */
        s = Realscreen + (row * Columns);
        e = s + (nlines * Columns);
        while (s < e)
                *s++ = ' ';
}

/*
 * s_del(row, nlines) - delete 'nlines' lines at 'row'
 */
void
s_del(row, nlines)
int     row;
int     nlines;
{
        register char   *s, *d, *e;

        SaveCursor();
        windgoto(Rows-1,0);
        EraseLine();                        // erase status line
        windgoto(row,0);

        if(row + nlines >= Rows - 1) {      // more than a screenfull?
            EraseNLinesAtRow(Rows-row-1,row);
        } else {
            Scroll(row+nlines,0,Rows-2,Columns-1,row,0);
            EraseNLinesAtRow(nlines,Rows-nlines-1);
        }
        RestoreCursor();

        /*
         * do a block move to update the internal image
         */
        d = Realscreen + (row * Columns);
        s = d + (nlines * Columns);
        e = Realscreen + ((Rows - 1) * Columns);

        while (s < e)
                *d++ = *s++;

        while (d < e)           /* clear the lines at the bottom */
                *d++ = ' ';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\undo.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/undo.c,v 1.7 89/08/06 09:51:06 tony Exp $
 *
 * Undo facility
 *
 * The routines in this file comprise a general undo facility for use
 * throughout the rest of the editor. The routine u_save() is called
 * before each edit operation to save the current contents of the lines
 * to be editted. Later, u_undo() can be called to return those lines
 * to their original state. The routine u_clear() should be called
 * whenever a new file is going to be editted to clear the undo buffer.
 */

#include "stevie.h"

/*
 * The next two variables mark the boundaries of the changed section
 * of the file. Lines BETWEEN the lower and upper bounds are changed
 * and originally contained the lines pointed to by u_lines. To undo
 * the last change, insert the lines in u_lines between the lower and
 * upper bounds.
 */
static  LINE    *u_lbound = NULL; /* line just prior to first changed line */
static  LINE    *u_ubound = NULL; /* line just after the last changed line */

static  LINE    *u_lline  = NULL; /* bounds of the saved lines */
static  LINE    *u_uline  = NULL;

static  int     u_col;
static  bool_t  u_valid = FALSE;  /* is the undo buffer valid */

/*
 * Local forward declarations
 */
static  LINE    *copyline();
static  void    u_lsave();
static  void    u_lfree();

/*
 * u_save(l, u) - save the current contents of part of the file
 *
 * The lines between 'l' and 'u' are about to be changed. This routine
 * saves their current contents into the undo buffer. The range l to u
 * is not inclusive because when we do an open, for example, there aren't
 * any lines in between. If no lines are to be saved, then l->next == u.
 */
void
u_save(l, u)
LINE    *l, *u;
{
        LINE    *nl;                    /* copy of the current line */

        /*
         * If l or u is null, there's an error. We don't return an
         * indication to the caller. They should find the problem
         * while trying to perform whatever edit is being requested
         * (e.g. a join on the last line).
         */
        if (l == NULL || u == NULL)
                return;

        u_clear();                      /* clear the buffer, first */

        u_lsave(l, u);          /* save to the "line undo" buffer, if needed */

        u_lbound = l;
        u_ubound = u;

        if (l->next != u) {             /* there are lines in the middle */
                l = l->next;
                u = u->prev;

                u_lline = nl = copyline(l);     /* copy the first line */
                while (l != u) {
                        nl->next = copyline(l->next);
                        nl->next->prev = nl;
                        l = l->next;
                        nl = nl->next;
                }
                u_uline = nl;
        } else
                u_lline = u_uline = NULL;

        u_valid = TRUE;
        u_col = Cursvcol;
}

/*
 * u_saveline() - save the current line in the undo buffer
 */
void
u_saveline()
{
        u_save(Curschar->linep->prev, Curschar->linep->next);
}

/*
 * u_undo() - effect an 'undo' operation
 *
 * The last edit is undone by restoring the modified section of the file
 * to its original state. The lines we're going to trash are copied to
 * the undo buffer so that even an 'undo' can be undone. Rings the bell
 * if the undo buffer is empty.
 */
void
u_undo()
{
        LINE    *tl, *tu;

        if (!u_valid) {
                beep();
                return;
        }

        /*
         * Get the first line of the thing we're undoing on the screen.
         */
        Curschar->linep = u_lbound->next;
        Curschar->index = 0;                    /* for now */
        if (Curschar->linep == Fileend->linep)
                Curschar->linep = Curschar->linep->prev;
        cursupdate();

        /*
         * Save pointers to what's in the file now.
         */
        if (u_lbound->next != u_ubound) {       /* there are lines to get */
                tl = u_lbound->next;
                tu = u_ubound->prev;
                tl->prev = NULL;
                tu->next = NULL;
        } else
                tl = tu = NULL;                 /* no lines between bounds */

        /*
         * Link the undo buffer into the right place in the file.
         */
        if (u_lline != NULL) {          /* there are lines in the undo buf */

                /*
                 * If the top line of the screen is being undone, we need to
                 * fix up Topchar to point to the new line that will be there.
                 */
                if (u_lbound->next == Topchar->linep)
                        Topchar->linep = u_lline;

                u_lbound->next = u_lline;
                u_lline->prev  = u_lbound;
                u_ubound->prev = u_uline;
                u_uline->next  = u_ubound;
        } else {                        /* no lines... link the bounds */
                if (u_lbound->next == Topchar->linep)
                        Topchar->linep = u_ubound;
                if (u_lbound == Filetop->linep)
                        Topchar->linep = u_ubound;

                u_lbound->next = u_ubound;
                u_ubound->prev = u_lbound;
        }

        /*
         * If we swapped the top line, patch up Filemem appropriately.
         */
        if (u_lbound == Filetop->linep)
                Filemem->linep = Filetop->linep->next;

        /*
         * Now save the old stuff in the undo buffer.
         */
        u_lline = tl;
        u_uline = tu;

        renum();                /* have to renumber everything */

        /*
         * Put the cursor on the first line of the 'undo' region.
         */
        Curschar->linep = u_lbound->next;
        Curschar->index = 0;
        if (Curschar->linep == Fileend->linep)
                Curschar->linep = Curschar->linep->prev;
        *Curschar = *coladvance(Curschar, u_col);
        cursupdate();
        updatescreen();         /* now show the change */

        u_lfree();              /* clear the "line undo" buffer */
}

/*
 * u_clear() - clear the undo buffer
 *
 * This routine is called to clear the undo buffer at times when the
 * pointers are about to become invalid, such as when a new file is
 * about to be editted.
 */
void
u_clear()
{
        LINE    *l, *nextl;

        if (!u_valid)           /* nothing to do */
                return;

        for (l = u_lline; l != NULL ;l = nextl) {
                nextl = l->next;
                free(l->s);
                free((char *)l);
        }

        u_lbound = u_ubound = u_lline = u_uline = NULL;
        u_valid = FALSE;
}

/*
 * The following functions and data implement the "line undo" feature
 * performed by the 'U' command.
 */

static  LINE    *u_line;                /* pointer to the line we last saved */
static  LINE    *u_lcopy = NULL;        /* local copy of the original line */

/*
 * u_lfree() - free the line save buffer
 */
static  void
u_lfree()
{
        if (u_lcopy != NULL) {
                free(u_lcopy->s);
                free((char *)u_lcopy);
                u_lcopy = NULL;
        }
        u_line = NULL;
}

/*
 * u_lsave() - save the current line if necessary
 */
static  void
u_lsave(l, u)
LINE    *l, *u;
{

        if (l->next != u->prev) {       /* not changing exactly one line */
                u_lfree();
                return;
        }

        if (l->next == u_line)          /* more edits on the same line */
                return;

        u_lfree();
        u_line = l->next;
        u_lcopy = copyline(l->next);
}

/*
 * u_lundo() - undo the current line (the 'U' command)
 */
void
u_lundo()
{
        if (u_lcopy != NULL) {
                free(Curschar->linep->s);
                Curschar->linep->s = u_lcopy->s;
                Curschar->linep->size = u_lcopy->size;
                free((char *)u_lcopy);
        } else
                beep();
        Curschar->index = 0;

        cursupdate();
        updatescreen();         /* now show the change */

        u_lcopy = NULL; /* can't undo this kind of undo */
        u_line = NULL;
}

/*
 * u_lcheck() - clear the "line undo" buffer if we've moved to a new line
 */
void
u_lcheck()
{
        if (Curschar->linep != u_line)
                u_lfree();
}

/*
 * copyline(l) - copy the given line, and return a pointer to the copy
 */
static LINE *
copyline(l)
LINE    *l;
{
        LINE    *nl;            /* the new line */

        nl = newline(strlen(l->s));
        strcpy(nl->s, l->s);

        return nl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\search.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/search.c,v 1.16 89/08/06 09:50:51 tony Exp $
 *
 * This file contains various searching-related routines. These fall into
 * three groups: string searches (for /, ?, n, and N), character searches
 * within a single line (for f, F, t, T, etc), and "other" kinds of searches
 * like the '%' command, and 'word' searches.
 */

#include "stevie.h"
#include "regexp.h"     /* Henry Spencer's (modified) reg. exp. routines */

/*
 * String searches
 *
 * The actual searches are done using Henry Spencer's regular expression
 * library.
 */

#define BEGWORD "([^a-zA-Z0-9_]|^)"     /* replaces "\<" in search strings */
#define ENDWORD "([^a-zA-Z0-9_]|$)"     /* likewise replaces "\>" */

#define BEGCHAR(c)      (islower(c) || isupper(c) || isdigit(c) || ((c) == '_'))

bool_t  begword;        /* does the search include a 'begin word' match */

static  LNPTR    *bcksearch(), *fwdsearch();

void HighlightLine();

/*
 * mapstring(s) - map special backslash sequences
 */
static char *
mapstring(s)
register char   *s;
{
        static  char    ns[80];
        register char   *p;

        begword = FALSE;

        for (p = ns; *s ;s++) {
                if (*s != '\\') {       /* not an escape */
                        *p++ = *s;
                        continue;
                }
                switch (*++s) {
                case '/':
                        *p++ = '/';
                        break;

                case '<':
                        strcpy(p, BEGWORD);
                        p += strlen(BEGWORD);
                        begword = TRUE;
                        break;

                case '>':
                        strcpy(p, ENDWORD);
                        p += strlen(ENDWORD);
                        break;

                default:
                        *p++ = '\\';
                        *p++ = *s;
                        break;
                }
        }
        *p++ = NUL;

        return ns;
}

static char *laststr = NULL;
static int lastsdir;

static LNPTR *
ssearch(dir,str)
int     dir;    /* FORWARD or BACKWARD */
char    *str;
{
    LNPTR    *pos;
        char    *old_ls = laststr;

        reg_ic = P(P_IC);       /* tell the regexp routines how to search */

        laststr = strsave(str);
        lastsdir = dir;

        if (old_ls != NULL)
                free(old_ls);

        if (dir == BACKWARD) {
                smsg("?%s", laststr);
                pos = bcksearch(mapstring(laststr));
        } else {
                smsg("/%s", laststr);
                pos = fwdsearch(mapstring(laststr));
        }

        /*
         * This is kind of a kludge, but its needed to make
         * 'beginning of word' searches land on the right place.
         */
        if (pos != NULL && begword) {
                if (pos->index != 0 || !BEGCHAR(pos->linep->s[0]))
                        pos->index += 1;
        }
        return pos;
}

bool_t
dosearch(dir,str)
int     dir;
char    *str;
{
    LNPTR    *p;

        if (str == NULL) {
                if (laststr == NULL) {
                    msg("No previous regular expression");
                    got_int = FALSE;
                    return FALSE;
                }
                str = laststr;
        }

        got_int = FALSE;

        if ((p = ssearch(dir,str)) == NULL) {
                if (got_int)
                        msg("Interrupt");
                else
                        msg("Pattern not found");

                got_int = FALSE;
                return FALSE;
        } else {
                LNPTR savep;
                char  string[256];
                unsigned long lno;
                unsigned long toplno;

                cursupdate();
                /*
                 * if we're backing up, we make sure the line we're on
                 * is on the screen.
                 */
                setpcmark();
                *Curschar = savep = *p;
                set_want_col = TRUE;
                cursupdate();

                HighlightLine(0,
                              Cursrow,
                              p->linep->s);
                return TRUE;
        }
}

#define OTHERDIR(x)     (((x) == FORWARD) ? BACKWARD : FORWARD)

bool_t
repsearch(flag)
int     flag;
{
        int     dir = lastsdir;
        bool_t  found;

        if ( laststr == NULL ) {
                beep();
                return FALSE;
        }

        found = dosearch(flag ? OTHERDIR(lastsdir) : lastsdir, laststr);

        /*
         * We have to save and restore 'lastsdir' because it gets munged
         * by ssearch() and winds up saving the wrong direction from here
         * if 'flag' is true.
         */
        lastsdir = dir;

        return found;
}

/*
 * regerror - called by regexp routines when errors are detected.
 */
void
regerror(s)
char    *s;
{
        emsg(s);
}

static LNPTR *
fwdsearch(str)
register char   *str;
{
    static LNPTR infile;
    register LNPTR   *p;
        regexp  *prog;

        register char   *s;
        register int    i;

        if ((prog = regcomp(str)) == NULL) {
                emsg("Invalid search string");
                return NULL;
        }

        p = Curschar;
        i = Curschar->index + 1;
        do {
                s = p->linep->s + i;

                if (regexec(prog, s, i == 0)) {         /* got a match */
                        infile.linep = p->linep;
                        infile.index = (int) (prog->startp[0] - p->linep->s);
                        free((char *)prog);
                        return (&infile);
                }
                i = 0;

                if (got_int)
                        goto fwdfail;

        } while ((p = nextline(p)) != NULL);

        /*
         * If wrapscan isn't set, then don't scan from the beginning
         * of the file. Just return failure here.
         */
        if (!P(P_WS))
                goto fwdfail;

        /* search from the beginning of the file to Curschar */
        for (p = Filemem; p != NULL ;p = nextline(p)) {
                s = p->linep->s;

                if (regexec(prog, s, TRUE)) {           /* got a match */
                        infile.linep = p->linep;
                        infile.index = (int) (prog->startp[0] - s);
                        free((char *)prog);
                        return (&infile);
                }

                if (p->linep == Curschar->linep)
                        break;

                if (got_int)
                        goto fwdfail;
        }

fwdfail:
        free((char *)prog);
        return NULL;
}

static LNPTR *
bcksearch(str)
char    *str;
{
    static LNPTR infile;
    register LNPTR   *p = &infile;
        register char   *s;
        register int    i;
        register char   *match;
        regexp  *prog;

        /* make sure str isn't empty */
        if (str == NULL || *str == NUL)
                return NULL;

        if ((prog = regcomp(str)) == NULL) {
                emsg("Invalid search string");
                return NULL;
        }

        *p = *Curschar;
        if (dec(p) == -1) {     /* already at start of file? */
                *p = *Fileend;
                p->index = strlen(p->linep->s) - 1;
        }

        if (begword)            /* so we don't get stuck on one match */
                dec(p);

        i = p->index;

        do {
                s = p->linep->s;

                if (regexec(prog, s, TRUE)) {   /* match somewhere on line */

                        /*
                         * Now, if there are multiple matches on this line,
                         * we have to get the last one. Or the last one
                         * before the cursor, if we're on that line.
                         */
                        match = prog->startp[0];

                        while (regexec(prog, prog->endp[0], FALSE)) {
                                if ((i >= 0) && ((prog->startp[0] - s) > i))
                                        break;
                                match = prog->startp[0];
                        }

                        if ((i >= 0) && ((match - s) > i)) {
                                i = -1;
                                continue;
                        }

                        infile.linep = p->linep;
                        infile.index = (int) (match - s);
                        free((char *)prog);
                        return (&infile);
                }
                i = -1;

                if (got_int)
                        goto bckfail;

        } while ((p = prevline(p)) != NULL);

        /*
         * If wrapscan isn't set, bag the search now
         */
        if (!P(P_WS))
                goto bckfail;

        /* search backward from the end of the file */
        p = prevline(Fileend);
        do {
                s = p->linep->s;

                if (regexec(prog, s, TRUE)) {   /* match somewhere on line */

                        /*
                         * Now, if there are multiple matches on this line,
                         * we have to get the last one.
                         */
                        match = prog->startp[0];

                        while (regexec(prog, prog->endp[0], FALSE))
                                match = prog->startp[0];

                        infile.linep = p->linep;
                        infile.index = (int) (match - s);
                        free((char *)prog);
                        return (&infile);
                }

                if (p->linep == Curschar->linep)
                        break;

                if (got_int)
                        goto bckfail;

        } while ((p = prevline(p)) != NULL);

bckfail:
        free((char *)prog);
        return NULL;
}

/*
 * dosub(lp, up, cmd)
 *
 * Perform a substitution from line 'lp' to line 'up' using the
 * command pointed to by 'cmd' which should be of the form:
 *
 * /pattern/substitution/g
 *
 * The trailing 'g' is optional and, if present, indicates that multiple
 * substitutions should be performed on each line, if applicable.
 * The usual escapes are supported as described in the regexp docs.
 */
void
dosub(lp, up, cmd)
LNPTR    *lp, *up;
char    *cmd;
{
        LINE    *cp;
        char    *pat, *sub;
        regexp  *prog;
        int     nsubs;
        bool_t  do_all;         /* do multiple substitutions per line */

        /*
         * If no range was given, do the current line. If only one line
         * was given, just do that one.
         */
        if (lp->linep == NULL)
                *up = *lp = *Curschar;
        else {
                if (up->linep == NULL)
                        *up = *lp;
        }

        pat = ++cmd;            /* skip the initial '/' */

        while (*cmd) {
                if (*cmd == '\\')       /* next char is quoted */
                        cmd += 2;
                else if (*cmd == '/') { /* delimiter */
                        *cmd++ = NUL;
                        break;
                } else
                        cmd++;          /* regular character */
        }

        if (*pat == NUL) {
                if (laststr == NULL) {
                        emsg("NULL pattern specified");
                        return;
                }
                pat = laststr;
        } else {
                if (laststr != NULL) {
                        free(laststr);
                }
                laststr = strsave(pat);
        }

        sub = cmd;

        do_all = FALSE;

        while (*cmd) {
                if (*cmd == '\\')       /* next char is quoted */
                        cmd += 2;
                else if (*cmd == '/') { /* delimiter */
                        do_all = (cmd[1] == 'g');
                        *cmd++ = NUL;
                        break;
                } else
                        cmd++;          /* regular character */
        }

        reg_ic = P(P_IC);       /* set "ignore case" flag appropriately */

        if ((prog = regcomp(pat)) == NULL) {
                emsg("Invalid search string");
                return;
        }

        nsubs = 0;

        for (cp = lp->linep; cp != NULL ;cp = cp->next) {
                if (regexec(prog, cp->s, TRUE)) { /* a match on this line */
                        char    *ns, *sns, *p;

                        /*
                         * Get some space for a temporary buffer
                         * to do the substitution into.
                         */
                        sns = ns = alloc(2048);
                        *sns = NUL;

                        p = cp->s;

                        do {
                                for (ns = sns; *ns ;ns++)
                                        ;
                                /*
                                 * copy up to the part that matched
                                 */
                                while (p < prog->startp[0])
                                        *ns++ = *p++;

                                regsub(prog, sub, ns);

                                /*
                                 * continue searching after the match
                                 */
                                p = prog->endp[0];

                        } while (regexec(prog, p, FALSE) && do_all);

                        for (ns = sns; *ns ;ns++)
                                ;

                        /*
                         * copy the rest of the line, that didn't match
                         */
                        while (*p)
                                *ns++ = *p++;

                        *ns = NUL;

                        free(cp->s);            /* free the original line */
                        cp->s = strsave(sns);   /* and save the modified str */
                        cp->size = strlen(cp->s) + 1;
                        free(sns);              /* free the temp buffer */
                        nsubs++;
                        CHANGED;
                }
                if (cp == up->linep)
                        break;
        }

        if (nsubs) {
                updatescreen();
                if (nsubs >= P(P_RP))
                        smsg("%d substitution%c", nsubs, (nsubs>1) ? 's' : ' ');
        } else
                msg("No match");

        free((char *)prog);
}

/*
 * doglob(cmd)
 *
 * Execute a global command of the form:
 *
 * g/pattern/X
 *
 * where 'x' is a command character, currently one of the following:
 *
 * d    Delete all matching lines
 * p    Print all matching lines
 *
 * The command character (as well as the trailing slash) is optional, and
 * is assumed to be 'p' if missing.
 */
void
doglob(lp, up, cmd)
LNPTR    *lp, *up;
char    *cmd;
{
        LINE    *cp;
        char    *pat;
        regexp  *prog;
        int     ndone;
        char    cmdchar = NUL;  /* what to do with matching lines */

        /*
         * If no range was given, do every line. If only one line
         * was given, just do that one.
         */
        if (lp->linep == NULL) {
                *lp = *Filemem;
                *up = *Fileend;
        } else {
                if (up->linep == NULL)
                        *up = *lp;
        }

        pat = ++cmd;            /* skip the initial '/' */

        while (*cmd) {
                if (*cmd == '\\')       /* next char is quoted */
                        cmd += 2;
                else if (*cmd == '/') { /* delimiter */
                        cmdchar = cmd[1];
                        *cmd++ = NUL;
                        break;
                } else
                        cmd++;          /* regular character */
        }
        if (cmdchar == NUL)
                cmdchar = 'p';

        reg_ic = P(P_IC);       /* set "ignore case" flag appropriately */

        if (cmdchar != 'd' && cmdchar != 'p') {
                emsg("Invalid command character");
                return;
        }

        if (*pat == NUL) {
                //
                // Check and use previous expressions.
                //
                if (laststr != NULL) {
                        pat = laststr;
                }
        } else {
                if (laststr != NULL) {
                        free(laststr);
                }
                laststr = strsave(pat);
        }

        if ((prog = regcomp(pat)) == NULL) {
                emsg("Invalid search string");
                return;
        }

        msg("");
        ndone = 0;
        got_int = FALSE;

        for (cp = lp->linep; cp != NULL && !got_int ;cp = cp->next) {
                if (regexec(prog, cp->s, TRUE)) { /* a match on this line */
                        switch (cmdchar) {

                        case 'd':               /* delete the line */
                                if (Curschar->linep != cp) {
                    LNPTR    savep;

                                        savep = *Curschar;
                                        Curschar->linep = cp;
                                        Curschar->index = 0;
                                        delline(1, FALSE);
                                        *Curschar = savep;
                                } else
                                        delline(1, FALSE);
                                break;

                        case 'p':               /* print the line */
                                prt_line(cp->s);
                                outstr("\r\n");
                                break;
                        }
                        ndone++;
                }
                if (cp == up->linep)
                        break;
        }

        if (ndone) {
                switch (cmdchar) {

                case 'd':
                        updatescreen();
                        if (ndone >= P(P_RP) || got_int)
                                smsg("%s%d fewer line%c",
                                        got_int ? "Interrupt: " : "",
                                        ndone,
                                        (ndone > 1) ? 's' : ' ');
                        break;

                case 'p':
                        wait_return();
                        break;
                }
        } else {
                if (got_int)
                        msg("Interrupt");
                else
                        msg("No match");
        }

        got_int = FALSE;
        free((char *)prog);
}

/*
 * Character Searches
 */

static char lastc = NUL;        /* last character searched for */
static int  lastcdir;           /* last direction of character search */
static int  lastctype;          /* last type of search ("find" or "to") */

/*
 * searchc(c, dir, type)
 *
 * Search for character 'c', in direction 'dir'. If type is 0, move to
 * the position of the character, otherwise move to just before the char.
 */
bool_t
searchc(c, dir, type)
char    c;
int     dir;
int     type;
{
    LNPTR    save;

        save = *Curschar;       /* save position in case we fail */
        lastc = c;
        lastcdir = dir;
        lastctype = type;

        /*
         * On 'to' searches, skip one to start with so we can repeat
         * searches in the same direction and have it work right.
         */
        if (type)
                (dir == FORWARD) ? oneright() : oneleft();

        while ( (dir == FORWARD) ? oneright() : oneleft() ) {
                if (gchar(Curschar) == c) {
                        if (type)
                                (dir == FORWARD) ? oneleft() : oneright();
                        return TRUE;
                }
        }
        *Curschar = save;
        return FALSE;
}

bool_t
crepsearch(flag)
int     flag;
{
        int     dir = lastcdir;
        int     rval;

        if (lastc == NUL)
                return FALSE;

        rval = searchc(lastc, flag ? OTHERDIR(lastcdir) : lastcdir, lastctype);

        lastcdir = dir;         /* restore dir., since it may have changed */

        return rval;
}

/*
 * "Other" Searches
 */

/*
 * showmatch - move the cursor to the matching paren or brace
 */
LNPTR *
showmatch()
{
    static  LNPTR    pos;
        int     (*move)(), inc(), dec();
        char    initc = (char)gchar(Curschar);  /* initial char */
        char    findc;                          /* terminating char */
        char    c;
        int     count = 0;

        pos = *Curschar;                /* set starting point */

        switch (initc) {

        case '(':
                findc = ')';
                move = inc;
                break;
        case ')':
                findc = '(';
                move = dec;
                break;
        case '{':
                findc = '}';
                move = inc;
                break;
        case '}':
                findc = '{';
                move = dec;
                break;
        case '[':
                findc = ']';
                move = inc;
                break;
        case ']':
                findc = '[';
                move = dec;
                break;
        default:
        return (LNPTR *) NULL;
        }

        while ((*move)(&pos) != -1) {           /* until end of file */
                c = (char)gchar(&pos);
                if (c == initc)
                        count++;
                else if (c == findc) {
                        if (count == 0)
                                return &pos;
                        count--;
                }
        }
    return (LNPTR *) NULL;           /* never found it */
}

/*
 * findfunc(dir) - Find the next function in direction 'dir'
 *
 * Return TRUE if a function was found.
 */
bool_t
findfunc(dir)
int     dir;
{
    LNPTR    *curr;

        curr = Curschar;

        do {
                curr = (dir == FORWARD) ? nextline(curr) : prevline(curr);

                if (curr != NULL && curr->linep->s[0] == '{') {
                        setpcmark();
                        *Curschar = *curr;
                        return TRUE;
                }
        } while (curr != NULL);

        return FALSE;
}

/*
 * The following routines do the word searches performed by the
 * 'w', 'W', 'b', 'B', 'e', and 'E' commands.
 */

/*
 * To perform these searches, characters are placed into one of three
 * classes, and transitions between classes determine word boundaries.
 *
 * The classes are:
 *
 * 0 - white space
 * 1 - letters, digits, and underscore
 * 2 - everything else
 */

static  int     stype;          /* type of the word motion being performed */

#define C0(c)   (((c) == ' ') || ((c) == '\t') || ((c) == NUL))
#define C1(c)   (isalpha(c) || isdigit(c) || ((c) == '_'))

/*
 * cls(c) - returns the class of character 'c'
 *
 * The 'type' of the current search modifies the classes of characters
 * if a 'W', 'B', or 'E' motion is being done. In this case, chars. from
 * class 2 are reported as class 1 since only white space boundaries are
 * of interest.
 */
static  int
cls(c)
char    c;
{
        if (C0(c))
                return 0;

        if (C1(c))
                return 1;

        /*
         * If stype is non-zero, report these as class 1.
         */
        return (stype == 0) ? 2 : 1;
}


/*
 * fwd_word(pos, type) - move forward one word
 *
 * Returns the resulting position, or NULL if EOF was reached.
 */
LNPTR *
fwd_word(p, type)
LNPTR    *p;
int     type;
{
    static  LNPTR    pos;
        int     sclass = cls(gchar(p));         /* starting class */

        pos = *p;

        stype = type;

        /*
         * We always move at least one character.
         */
        if (inc(&pos) == -1)
                return NULL;

        if (sclass != 0) {
                while (cls(gchar(&pos)) == sclass) {
                        if (inc(&pos) == -1)
                                return NULL;
                }
                /*
                 * If we went from 1 -> 2 or 2 -> 1, return here.
                 */
                if (cls(gchar(&pos)) != 0)
                        return &pos;
        }

        /* We're in white space; go to next non-white */

        while (cls(gchar(&pos)) == 0) {
                /*
                 * We'll stop if we land on a blank line
                 */
                if (pos.index == 0 && pos.linep->s[0] == NUL)
                        break;

                if (inc(&pos) == -1)
                        return NULL;
        }

        return &pos;
}

/*
 * bck_word(pos, type) - move backward one word
 *
 * Returns the resulting position, or NULL if EOF was reached.
 */
LNPTR *
bck_word(p, type)
LNPTR    *p;
int     type;
{
    static  LNPTR    pos;
        int     sclass = cls(gchar(p));         /* starting class */

        pos = *p;

        stype = type;

        if (dec(&pos) == -1)
                return NULL;

        /*
         * If we're in the middle of a word, we just have to
         * back up to the start of it.
         */
        if (cls(gchar(&pos)) == sclass && sclass != 0) {
                /*
                 * Move backward to start of the current word
                 */
                while (cls(gchar(&pos)) == sclass) {
                        if (dec(&pos) == -1)
                                return NULL;
                }
                inc(&pos);                      /* overshot - forward one */
                return &pos;
        }

        /*
         * We were at the start of a word. Go back to the start
         * of the prior word.
         */

        while (cls(gchar(&pos)) == 0) {         /* skip any white space */
                /*
                 * We'll stop if we land on a blank line
                 */
                if (pos.index == 0 && pos.linep->s[0] == NUL)
                        return &pos;

                if (dec(&pos) == -1)
                        return NULL;
        }

        sclass = cls(gchar(&pos));

        /*
         * Move backward to start of this word.
         */
        while (cls(gchar(&pos)) == sclass) {
                if (dec(&pos) == -1)
                        return NULL;
        }
        inc(&pos);                      /* overshot - forward one */

        return &pos;
}

/*
 * end_word(pos, type, in_change) - move to the end of the word
 *
 * There is an apparent bug in the 'e' motion of the real vi. At least
 * on the System V Release 3 version for the 80386. Unlike 'b' and 'w',
 * the 'e' motion crosses blank lines. When the real vi crosses a blank
 * line in an 'e' motion, the cursor is placed on the FIRST character
 * of the next non-blank line. The 'E' command, however, works correctly.
 * Since this appears to be a bug, I have not duplicated it here.
 *
 * There's a strange special case here that the 'in_change' parameter
 * helps us deal with. Vi effectively turns 'cw' into 'ce'. If we're on
 * a word with only one character, we need to stick at the current
 * position so we don't change two words.
 *
 * Returns the resulting position, or NULL if EOF was reached.
 */
LNPTR *
end_word(p, type, in_change)
LNPTR    *p;
int     type;
bool_t  in_change;
{
    static  LNPTR    pos;
        int     sclass = cls(gchar(p));         /* starting class */

        pos = *p;

        stype = type;

        if (inc(&pos) == -1)
                return NULL;

        /*
         * If we're in the middle of a word, we just have to
         * move to the end of it.
         */
        if (cls(gchar(&pos)) == sclass && sclass != 0) {
                /*
                 * Move forward to end of the current word
                 */
                while (cls(gchar(&pos)) == sclass) {
                        if (inc(&pos) == -1)
                                return NULL;
                }
                dec(&pos);                      /* overshot - forward one */
                return &pos;
        }

        /*
         * We were at the end of a word. Go to the end of the next
         * word, unless we're doing a change. In that case we stick
         * at the end of the current word.
         */
        if (in_change)
                return p;

        while (cls(gchar(&pos)) == 0) {         /* skip any white space */
                if (inc(&pos) == -1)
                        return NULL;
        }

        sclass = cls(gchar(&pos));

        /*
         * Move forward to end of this word.
         */
        while (cls(gchar(&pos)) == sclass) {
                if (inc(&pos) == -1)
                        return NULL;
        }
        dec(&pos);                      /* overshot - forward one */

        return &pos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\version.c ===
static  char    RCSid[] =
"$Header: /nw/tony/src/stevie/src/RCS/version.c,v 3.69 89/08/13 11:41:58 tony Exp $";

/*
 * Contains the declaration of the global version number variable.
 *
 *  revision 0.23 JohnRo    1/20/92
 *  Make tag search obey ignorecase flag.
 *
 *  revision 0.22 JohnRo    11/6/91
 *  Made Tags file more like that of other versions of VI.
 *
 *  revision 0.21 tedm      6/9/91
 *  add named buffers (numbered buffers still absent)
 *
 *  revision 0.16 tedm      6/8/91
 *  add v and V visual operators for lowercasing and uppercasing.
 *
 *  revision 0.15 tedm
 *  add :list
 *
 *  revision 0.14 tedm
 *  add source command and automatic 'source $init:ntvi.exe' at startup
 *
 *  Revision 0.13 tedm
 *  add undo for line-oriented delete.  Still no undo for global or substitute.
 *
 *  Revision 0.12 tedm
 *  add line-oriented delete command.
 *
 *  Revision 0.11 tedm
 *  Changes various buffers to be dynamically allocated.  Insert mode is no
 *  longer limited to 1024 characters at a time.
 *
 *  NT version 0.1 tedm
 *  ported
 *
 * $Log:        version.c,v $
 * Revision 3.69  89/08/13  11:41:58  tony
 * Fixed a bug that caused messages from fileinfo() (in misccmds.c) to get
 * messed up. The routine smsg() which uses the kludge approach to varargs
 * didn't have enough parameters for some of the calls made to it.
 *
 * Revision 3.68  89/08/06  09:51:20  tony
 * Misc. minor changes to make lint happier before posting to USENET.
 *
 * Revision 3.67  89/08/03  13:08:52  tony
 * There was some code in ops.c that was duplicating the function of the
 * getcmdln() routine in cmdline.c. I modified getcmdln() to be slightly
 * more general, and changed dofilter() in ops.c to use it.
 *
 * Revision 3.66  89/08/02  20:00:12  tony
 * Fixed some problems with mode lines. There were still extra screen
 * redraws that needed to be avoided. There was also a problem involving
 * nested calls to docmdln() that can occur when mode lines are used.
 *
 * Revision 3.65  89/08/02  15:50:03  tony
 * Finally got around to providing full support for the "change" operator.
 * Multi-line changes (like "cL" or "3cc") now work correctly. Also fixed
 * a small problem with multi-line character-oriented deletes leaving the
 * cursor in the wrong location (off by one character). This is mainly
 * useful for multi-line changes (such as "c%") so the insert starts in
 * the right place.
 *
 * Revision 3.64  89/08/02  12:47:04  tony
 * This message intentionally left blank.
 *
 * Revision 3.63  89/08/02  12:43:44  tony
 * I just noticed that I had used the RCS cookie for log messages in one
 * of my prior version messages. This caused these version update messages
 * to be duplicated in this file. I just removed that string, and the
 * extra message copies that had been generated.
 *
 * Revision 3.62  89/08/02  12:26:20  tony
 * The ^G command now shows where you are in the file list, if more than one
 * file is being edited. Also, the commands ":e#" and ":e!#" (note the lack
 * of a space between the command and file name) will now work.
 *
 * Revision 3.61  89/08/02  11:03:16  tony
 * Misc. cleanups regarding tags. Also added support for the "terse" option.
 * This is ignored, but improves compatibility with vi, since we no longer
 * complain about an unknown option if "terse" is used.
 *
 * Revision 3.60  89/08/02  09:26:39  tony
 * Added code to avoid screen redraws when input is being read from the
 * "stuffin" buffer. This avoids extra redraws when switching to the
 * alternate file, or when invoking the editor with one of the "+" options,
 * or when using tags.
 *
 * Revision 3.59  89/08/01  16:28:31  tony
 * Added better support for counts on several cursor motion commands. These
 * include ^F, ^B, f, F, t, T, as well as the repeated character search
 * commands (command and semi-colon).
 *
 * Revision 3.58  89/07/19  08:08:23  tony
 * Added the ability for '~' to be an operator. If enabled (by defined TILDEOP
 * in env.h), the parameter "tildeop" (or "to") may be set to turn tilde into
 * an operator.
 *
 * Revision 3.57  89/07/13  22:47:05  tony
 * Made some generic speed improvements in screen.c and some TOS-specific
 * improvements in tos.c. The TOS version is now much faster at screen
 * updates than before.
 *
 * Revision 3.56  89/07/13  14:52:03  tony
 * Minor cleanups in normal.c
 *
 * Revision 3.55  89/07/13  14:19:12  tony
 * Cleaned up the logic in getcmdln() A LOT. The routine docmdln() needs a
 * similar overhaul.
 *
 * Revision 3.54  89/07/12  21:40:01  tony
 * Lots of misc. cleanup in normal.c and cmdline.c, but nothing much in the
 * way of functional improvements. One change is that things like d/foo<CR>
 * will now work since searches are less of a special case now.
 *
 * Revision 3.53  89/07/11  16:16:08  tony
 * Added general support for interrupt-handling for those environments that
 * can actually generate them. Basically, long-running operations are now
 * able to terminate early if an error occurs. These operations are: string
 * searches, the global command (":g/.../"), and file reads. File writes
 * should probably be done as well, but this is more dangerous. In all cases,
 * the user is given an indication on the status line that the operation
 * terminated due to an interrupt.
 *
 * Revision 3.52  89/07/11  12:35:09  tony
 * Improved the code in dosub() and doglob() that detects quoted characters
 * and delimiters in search strings and replacement patterns. The current
 * code didn't allow certain valid strings to be used. The delimiter is still
 * required to be '/', but it can be quoted reliably now with backslash.
 *
 * Revision 3.51  89/07/10  14:01:58  tony
 * Removed the function addtobuff() since it was rarely used and could be
 * replaced by calls to other library functions. Also removed some other
 * obsolete code that was already ifdef'd out anyway.
 *
 * Revision 3.50  89/07/10  13:10:32  tony
 * Added a workaround in normal.c to avoid problems with broken versions of
 * strncpy() that don't properly deal with a count of zero.
 *
 * Revision 3.49  89/07/07  16:28:37  tony
 * Fixed a long-standing bug with 'cw' when the cursor is positioned on a
 * word with only one character. Also fixed a problems with zero-length files
 * and reverse searches.
 *
 * Revision 3.48  89/03/22  10:26:58  tony
 * Fixed some outdated uses of the ":p" command (which has been changed to
 * ":N" in os2.c and dos.c. Also added macros (F7 and F8) for dos and os/2
 * to use the "cdecl" program to convert lines to and from a pseudo-english
 * form. Use F7 to "explain" the declaration on the current line, and F8 to
 * convert an english-style declaration to the C form. In both cases, the
 * new form is placed on the next line, leaving the original line intact.
 *
 * Revision 3.47  89/03/11  22:44:14  tony
 * General cleanup. Removed the static "rcsid" variables and the log
 * strings (except in version.c). Fixed some coding style inconsistencies
 * and added a few register declarations.
 *
 * Revision 3.46  89/02/14  09:52:07  tony
 * Made a first pass at adding Robert Regn's changes, starting with the
 * more portable ones. Added better support for '#' and '%' in colon
 * commands, support for a configurable temp directory, and made the
 * termcap code less picky about capabilities.
 *
 * Revision 3.45  88/11/10  09:00:06  tony
 * Added support for mode lines. Strings like "vi:stuff:" or "ex:stuff:"
 * occurring in the first or last 5 lines of a file cause the editor to
 * pretend that "stuff" was types as a colon command. This examination
 * is done only if the parameter "modelines" (or "ml") is set. This is
 * not enabled, by default, because of the security implications involved.
 *
 * Revision 3.44  88/11/01  21:34:11  tony
 * Fixed a couple of minor points for Minix, and improved the speed of
 * the 'put' command dramatically.
 *
 * Revision 3.43  88/10/31  13:11:33  tony
 * Added optional support for termcap. Initialization is done in term.c
 * and also affects the system-dependent files. To enable termcap in those
 * environments that support it, define the symbol "TERMCAP" in env.h
 *
 * Revision 3.42  88/10/27  18:30:19  tony
 * Removed support for Megamax. Added '%' as an alias for '1,$'. Made the
 * 'r' command more robust. Now prints the string on repeated searches.
 * The ':=" command now works. Some pointer operations are now safer.
 * The ":!" and ":sh" now work correctly. Re-organized the help screens
 * a little.
 *
 * Revision 3.41  88/10/06  10:15:00  tony
 * Fixed a bug involving ^Y that occurs when the cursor is on the last
 * line, and the line above the screen is long. Also hacked up fileio.c
 * to pass pathnames off to fixname() for system-dependent processing.
 * Used under DOS & OS/2 to trim parts of the name appropriately.
 *
 * Revision 3.40  88/09/16  08:37:36  tony
 * No longer beeps when repeated searches fail.
 *
 * Revision 3.39  88/09/06  06:51:07  tony
 * Fixed a bug with shifts that was introduced when replace mode was added.
 *
 * Revision 3.38  88/08/31  20:48:28  tony
 * Made another fix in search.c related to repeated searches.
 *
 * Revision 3.37  88/08/30  20:37:16  tony
 * After much prodding from Mark, I finally added support for replace mode.
 *
 * Revision 3.36  88/08/26  13:46:34  tony
 * Added support for the '!' (filter) operator.
 *
 * Revision 3.35  88/08/26  08:46:01  tony
 * Misc. changes to make lint happy.
 *
 * Revision 3.34  88/08/25  15:13:36  tony
 * Fixed a bug where the cursor didn't land on the right place after
 * "beginning-of-word" searches if the word was preceded by the start
 * of the line and a single character.
 *
 * Revision 3.33  88/08/23  12:53:08  tony
 * Fixed a bug in ssearch() where repeated searches ('n' or 'N') resulted
 * in dynamic memory being referenced after it was freed.
 *
 * Revision 3.32  88/08/17  07:37:07  tony
 * Fixed a general problem in u_save() by checking both parameters for
 * null values. The specific symptom was that a join on the last line of
 * the file would crash the editor.
 *
 * Revision 3.31  88/07/09  20:39:38  tony
 * Implemented the "line undo" command (i.e. 'U').
 *
 * Revision 3.30  88/06/28  07:54:22  tony
 * Fixed a bug involving redo's of the '~' command. The redo would just
 * repeat the replacement last performed instead of switching the case of
 * the current character.
 *
 * Revision 3.29  88/06/26  14:53:19  tony
 * Added support for a simple form of the "global" command. It supports
 * commands of the form "g/pat/d" or "g/pat/p", to delete or print lines
 * that match the given pattern. A range spec may be used to limit the
 * lines to be searched.
 *
 * Revision 3.28  88/06/25  21:44:22  tony
 * Fixed a problem in the processing of colon commands that caused
 * substitutions of patterns containing white space to fail.
 *
 * Revision 3.27  88/06/20  14:52:21  tony
 * Merged in changes for BSD Unix sent in by Michael Lichter.
 *
 * Revision 3.26  88/06/10  13:44:06  tony
 * Fixed a bug involving writing out files with long pathnames. A small
 * fixed size buffer was being used. The space for the backup file name
 * is now allocated dynamically.
 *
 * Revision 3.25  88/05/04  08:29:02  tony
 * Fixed a minor incompatibility with vi involving the 'G' command. Also
 * changed the RCS version number of version.c to match the actual version
 * of the editor.
 *
 * Revision 1.12  88/05/03  14:39:52  tony
 * Changed the screen representation of the ascii character DELETE to be
 * compatible with vi. Also merged in support for DOS.
 *
 * Revision 1.11  88/05/02  21:38:21  tony
 * The code that reads files now handles boundary/error conditions much
 * better, and generates status/error messages that are compatible with
 * the real vi. Also fixed a bug in repeated reverse searches that got
 * inserted in the recent changes to search.c.
 *
 * Revision 1.10  88/05/02  07:35:41  tony
 * Fixed a bug in the routine plines() that was introduced during changes
 * made for the last version.
 *
 * Revision 1.9  88/05/01  20:10:19  tony
 * Fixed some problems with auto-indent, and added support for the "number"
 * parameter.
 *
 * Revision 1.8  88/04/30  20:00:49  tony
 * Added support for the auto-indent feature.
 *
 * Revision 1.7  88/04/29  14:50:11  tony
 * Fixed a class of bugs involving commands like "ct)" where the cursor
 * motion part of the operator can fail. If the motion failed, the operator
 * was continued, with the cursor position unchanged. Cases like this were
 * modified to abort the operation if the motion fails.
 *
 * Revision 1.6  88/04/28  08:19:35  tony
 * Modified Henry Spencer's regular expression library to support new
 * features that couldn't be done easily with the existing interface.
 * This code is now a direct part of the editor source code. The editor
 * now supports the "ignorecase" parameter, and multiple substitutions
 * per line, as in "1,$s/foo/bar/g".
 *
 * Revision 1.5  88/04/24  21:38:00  tony
 * Added preliminary support for the substitute command. Full range specs.
 * are supported, but only a single substitution is allowed on each line.
 *
 * Revision 1.4  88/04/23  20:41:01  tony
 * Worked around a problem with adding lines to the end of the buffer when
 * the cursor is at the bottom of the screen (in misccmds.c). Also fixed a
 * bug that caused reverse searches from the start of the file to bomb.
 *
 * Revision 1.3  88/03/24  08:57:00  tony
 * Fixed a bug in cmdline() that had to do with backspacing out of colon
 * commands or searches. Searches were okay, but colon commands backed out
 * one backspace too early.
 *
 * Revision 1.2  88/03/21  16:47:55  tony
 * Fixed a bug in renum() causing problems with large files (>6400 lines).
 * Also moved system-specific defines out of stevie.h and into a new file
 * named env.h. This keeps volatile information outside the scope of RCS.
 *
 * Revision 1.1  88/03/20  21:00:39  tony
 * Initial revision
 *
 */

char    *Version = "NT VI - Version 0.23";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\makefile.inc ===
$(O)\vmmreg32.res: vmmreg32.rc vmmreg32.rcv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\dllentry.c ===
//
//  DLLENTRY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

#ifdef USEHEAP
#define RGHEAP_SIZE                 9256*1024
HANDLE g_RgHeap = NULL;
#endif

BOOL
WINAPI
VMMRegDllEntry(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    switch (dwReason) {

        case DLL_PROCESS_ATTACH:
#ifdef USEHEAP
            if ((g_RgHeap = HeapCreate(0, RGHEAP_SIZE, RGHEAP_SIZE)) == NULL)
                return FALSE;
#endif

            if (VMMRegLibAttach(0) != ERROR_SUCCESS)
                return FALSE;

            break;

        case DLL_PROCESS_DETACH:
            VMMRegLibDetach();

#ifdef USEHEAP
            if (g_RgHeap != NULL)
                HeapDestroy(g_RgHeap);
#endif

            break;

    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vi\vi.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/main.c,v 1.12 89/08/02 19:53:27 tony Exp $
 *
 * The main routine and routines to deal with the input buffer.
 */

#include "stevie.h"

int Rows;               /* Number of Rows and Columns */
int Columns;            /* in the current window. */

char INITFILENAME[] = "ntvi.ini";   /* file that's source'd at startup */

char *Realscreen = NULL;        /* What's currently on the screen, a single */
                                /* array of size Rows*Columns. */
char *Nextscreen = NULL;        /* What's to be put on the screen. */

char *Filename = NULL;  /* Current file name */

char *Appname = NULL;   /* Name of program (vi, for instance) */

LNPTR *Filemem;      /* Pointer to the first line of the file */

LNPTR *Filetop;      /* Line 'above' the start of the file */

LNPTR *Fileend;      /* Pointer to the end of the file in Filemem. */
                     /* (It points to the byte AFTER the last byte.) */

LNPTR *Topchar;      /* Pointer to the byte in Filemem which is */
                        /* in the upper left corner of the screen. */

LNPTR *Botchar;      /* Pointer to the byte in Filemem which is */
                        /* just off the bottom of the screen. */

LNPTR *Curschar;     /* Pointer to byte in Filemem at which the */
                        /* cursor is currently placed. */

int Cursrow, Curscol;   /* Current position of cursor */

int Cursvcol;           /* Current virtual column, the column number of */
                        /* the file's actual line, as opposed to the */
                        /* column number we're at on the screen.  This */
                        /* makes a difference on lines that span more */
                        /* than one screen line. */

int Curswant = 0;       /* The column we'd like to be at. This is used */
                        /* try to stay in the same column through up/down */
                        /* cursor motions. */

bool_t set_want_col;    /* If set, then update Curswant the next time */
                        /* through cursupdate() to the current virtual */
                        /* column. */

int State = NORMAL;     /* This is the current state of the command */
                        /* interpreter. */

int Prenum = 0;         /* The (optional) number before a command. */
int namedbuff = -1;     /* the (optional) named buffer before a command */

LNPTR *Insstart;     /* This is where the latest insert/append */
                        /* mode started. */

bool_t Changed = 0;     /* Set to 1 if something in the file has been */
                        /* changed and not written out. */

char *Redobuff;         /* Each command should stuff characters into this */
                        /* buffer that will re-execute itself. */

char *Insbuff;          /* Each insertion gets stuffed into this buffer. */
int   InsbuffSize;

int Ninsert = 0;        /* Number of characters in the current insertion. */
char *Insptr = NULL;

bool_t  got_int=FALSE;  /* set to TRUE when an interrupt occurs (if possible) */

bool_t  interactive = FALSE;    /* set TRUE when main() is ready to roll */

char **files;           /* list of input files */
int  numfiles;          /* number of input files */
int  curfile;           /* number of the current file */

static char *getcbuff;
static char *getcnext = NULL;

static void chk_mline();

static void
usage()
{
        fprintf(stderr, "usage: stevie [file ...]\n");
        fprintf(stderr, "       stevie -t tag\n");
        fprintf(stderr, "       stevie +[num] file\n");
        fprintf(stderr, "       stevie +/pat  file\n");
        exit(1);
}

__cdecl main(argc,argv)
int     argc;
char    *argv[];
{
        char    *initstr;               /* init string from the environment */
        char    *tag = NULL;            /* tag from command line */
        char    *pat = NULL;            /* pattern from command line */
        int     line = -1;              /* line number from command line */
        char    *p1, *p2;

        p1 = strrchr(argv[0], '\\');
        if (!p1)
            p1 = strrchr(argv[0], ':');
        if (p1)
            p1++;
        else
            p1 = argv[0];
        p2 = strrchr(p1, '.');
        if (!p2)
            Appname = strsave(p1);
        else {
            Appname = malloc((size_t)(p2-p1+1));
            strncpy(Appname, p1, (size_t)(p2-p1));
            Appname[p2-p1] = '\0';
        }

        /*
         * Process the command line arguments.
         */
        if (argc > 1) {
                switch (argv[1][0]) {

                case '-':                       /* -t tag */
                        if (argv[1][1] != 't')
                                usage();

                        if (argv[2] == NULL)
                                usage();

                        Filename = NULL;
                        tag = argv[2];
                        numfiles = 1;
                        break;

                case '+':                       /* +n or +/pat */
                        if (argv[1][1] == '/') {
                                if (argv[2] == NULL)
                                        usage();
                                Filename = strsave(argv[2]);
                                pat = &(argv[1][1]);
                                numfiles = 1;

                        } else if (isdigit(argv[1][1]) || argv[1][1] == NUL) {
                                if (argv[2] == NULL)
                                        usage();
                                Filename = strsave(argv[2]);
                                numfiles = 1;

                                line = (isdigit(argv[1][1])) ?
                                        atoi(&(argv[1][1])) : 0;
                        } else
                                usage();

                        break;

                default:                        /* must be a file name */
                        Filename = strsave(argv[1]);
                        files = &(argv[1]);
                        numfiles = argc - 1;
                        break;
                }
        } else {
                Filename = NULL;
                numfiles = 1;
        }
        curfile = 0;

        if (numfiles > 1)
                fprintf(stderr, "%d files to edit\n", numfiles);

        windinit();

        /*
         * Allocate LNPTR structures for all the various position pointers
         */
    if ((Filemem = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ||
        (Filetop = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ||
        (Fileend = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ||
        (Topchar = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ||
        (Botchar = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ||
        (Curschar = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ||
        (Insstart = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ) {
                fprintf(stderr, "Can't allocate data structures\n");
                windexit(0);
        }

        screenalloc();
        filealloc();            /* Initialize Filemem, Filetop, and Fileend */
        inityank();

        getcbuff = malloc(1);
        if(((getcbuff = malloc(1          )) == NULL)
        || ((Redobuff = malloc(REDOBUFFMIN)) == NULL)
        || ((Insbuff  = malloc(INSERTSLOP )) == NULL))
        {
            fprintf(stderr,"Can't allocate buffers\n");
            windexit(1);
        }
        *getcbuff = 0;
        InsbuffSize = INSERTSLOP;

        screenclear();


        {
            char     *srcinitname,*initvar;
            bool_t   unmalloc;
            unsigned x;

            if((initvar = getenv("INIT")) == NULL) {
                srcinitname = INITFILENAME;
                unmalloc = FALSE;
            } else {
                srcinitname = malloc((x = strlen(initvar))+strlen(INITFILENAME)+2);
                if(srcinitname == NULL) {
                    fprintf(stderr,"Can't allocate initial source buffer\n");
                    windexit(1);
                }
                unmalloc = TRUE;
                strcpy(srcinitname,initvar);
                if(srcinitname[x-1] != '\\') {      // not NLS-aware!!
                    srcinitname[x] = '\\';
                    srcinitname[x+1]   = '\0';
                }
                strcat(srcinitname,INITFILENAME);
            }
            dosource(srcinitname,FALSE);
            if(unmalloc) {
                free(srcinitname);
            }
        }


        if ((initstr = getenv("EXINIT")) != NULL) {
                char *lp, buf[128];

                if ((lp = getenv("LINES")) != NULL) {
                        sprintf(buf, "%s lines=%s", initstr, lp);
                        docmdln(buf);
                } else
                        docmdln(initstr);
        }

        if (Filename != NULL) {
                if (readfile(Filename, Filemem, FALSE))
                        filemess("[New File]");
        } else if (tag == NULL)
                msg("Empty Buffer");

        setpcmark();

        if (tag) {
                stuffin(":ta ");
                stuffin(tag);
                stuffin("\n");

        } else if (pat) {
                stuffin(pat);
                stuffin("\n");

        } else if (line >= 0) {
                if (line > 0)
                        stuffnum(line);
                stuffin("G");
        }

        interactive = TRUE;

        edit();

        windexit(0);

        return 1;               /* shouldn't be reached */
}

void
stuffin(s)
char    *s;
{
        char *p;

        if (s == NULL) {                /* clear the stuff buffer */
                getcnext = NULL;
                return;
        }

        if (getcnext == NULL) {
                p = ralloc(getcbuff,strlen(s)+1);
                if(p) {
                    getcbuff = p;
                    strcpy(getcbuff,s);
                    getcnext = getcbuff;
                } else {
                    getcnext = NULL;
                }
        } else {
                p = ralloc(getcbuff,strlen(getcbuff)+strlen(s)+1);
                if(p) {
                    getcnext += p - getcbuff;
                    getcbuff = p;
                    strcat(getcbuff,s);
                } else {
                    getcnext = NULL;
                }
        }
}

void
stuffnum(n)
int     n;
{
        char    buf[32];

        sprintf(buf, "%d", n);
        stuffin(buf);
}

int
vgetc()
{
        register int    c;

        /*
         * inchar() may map special keys by using stuffin(). If it does
         * so, it returns -1 so we know to loop here to get a real char.
         */
        do {
                if ( getcnext != NULL ) {
                        int nextc = *getcnext++;
                        if ( *getcnext == NUL ) {
                                *getcbuff = NUL;
                                getcnext = NULL;
                        }
                        return(nextc);
                }
                c = inchar();
        } while (c == -1);

        return c;
}

/*
 * anyinput
 *
 * Return non-zero if input is pending.
 */

bool_t
anyinput()
{
        return (getcnext != NULL);
}

/*
 * do_mlines() - process mode lines for the current file
 *
 * Returns immediately if the "ml" parameter isn't set.
 */
#define NMLINES 5       /* no. of lines at start/end to check for modelines */

void
do_mlines()
{
        int     i;
    register LNPTR   *p;

        if (!P(P_ML))
                return;

        p = Filemem;
        for (i=0; i < NMLINES ;i++) {
                chk_mline(p->linep->s);
                if ((p = nextline(p)) == NULL)
                        break;
        }

        if ((p = prevline(Fileend)) == NULL)
                return;

        for (i=0; i < NMLINES ;i++) {
                chk_mline(p->linep->s);
                if ((p = prevline(p)) == NULL)
                        break;
        }
}

/*
 * chk_mline() - check a single line for a mode string
 */
static void
chk_mline(s)
register char   *s;
{
        register char   *cs;            /* local copy of any modeline found */
        register char   *e;

        for (; *s != NUL ;s++) {
                if (strncmp(s, "vi:", 3) == 0 || strncmp(s, "ex:", 3) == 0) {
                        cs = strsave(s+3);
                        if ((e = strchr(cs, ':')) != NULL) {
                                *e = NUL;
                                stuffin(mkstr(CTRL('o')));
                                docmdln(cs);
                        }
                        free(cs);
                }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\pch.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regdblk.h ===
//
//  REGDBLK.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGDBLK_
#define _REGDBLK_

int
INTERNAL
RgInitDatablockInfo(
    LPFILE_INFO lpFileInfo,
    HFILE hFile
    );

int
INTERNAL
RgLockDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex
    );

VOID
INTERNAL
RgUnlockDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    BOOL fMarkDirty
    );

int
INTERNAL
RgLockKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    BYTE KeyRecordIndex,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgWriteDatablocks(
    LPFILE_INFO lpFileInfo,
    HFILE hSourceFile,
    HFILE hDestinationFile
    );

VOID
INTERNAL
RgWriteDatablocksComplete(
    LPFILE_INFO lpFileInfo
    );

VOID
INTERNAL
RgSweepDatablocks(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgAllocKeyRecordFromDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgAllocKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgExtendKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length,
    LPKEY_RECORD lpKeyRecord
    );

VOID
INTERNAL
RgFreeDatablockInfoBuffers(
    LPDATABLOCK_INFO lpDatablockInfo
    );

VOID
INTERNAL
RgFreeKeyRecord(
    LPDATABLOCK_INFO lpDatablockInfo,
    LPKEY_RECORD lpKeyRecord
    );

VOID
INTERNAL
RgFreeKeyRecordIndex(
    LPDATABLOCK_INFO lpDatablockInfo,
    UINT KeyRecordIndex
    );

#endif // _REGDBLK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regdebug.c ===
//
//  REGDEBUG.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

//  VXD_NODEBUGGER:  Uses debug services available when a debugger is not
//  installed, but at the cost of an intermediate debug buffer.
//#define VXD_NODEBUGGER

#ifdef DEBUG

#include <stdarg.h>

#ifdef STDIO_DEBUG
#include <stdio.h>
#else
static char g_RgDebugBuffer[256];
#endif

#ifdef VXD_NODEBUGGER
extern	ULONG	(SERVICE*_Vsprintf)(PCHAR,PCHAR,va_list);
#endif

VOID
INTERNALV
RgDebugPrintf(
    LPCSTR lpFormatString,
    ...
    )
{

    va_list arglist;

    va_start(arglist, lpFormatString);

#ifdef STDIO_DEBUG
    vprintf(lpFormatString, arglist);
#else
#ifdef VXD
#ifdef VXD_NODEBUGGER
    _Vsprintf(g_RgDebugBuffer, (PCHAR) lpFormatString, arglist);
    _Debug_Out_Service(g_RgDebugBuffer);
#else
    _Debug_Printf_Service((PCHAR) lpFormatString, arglist);
#endif
#else
    wvsprintf(g_RgDebugBuffer, lpFormatString, arglist);
    OutputDebugString(g_RgDebugBuffer);
#endif
#endif

}

VOID
INTERNAL
RgDebugAssert(
    LPCSTR lpFile,
    UINT LineNumber
    )
{

    RgDebugPrintf("assert failed %s@%d\n", lpFile, LineNumber);

    TRAP();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regdblk.c ===
//
//  REGDBLK.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

DECLARE_DEBUG_COUNT(g_RgDatablockLockCount);

//  Don't let a FREE_RECORD shrink less than this value.
#define MINIMUM_FREE_RECORD_LENGTH  (sizeof(KEY_RECORD) + sizeof(VALUE_RECORD))

//
//  RgAllocDatablockInfoBuffers
//
//  Allocates the buffers associated with a DATABLOCK_INFO structure.  The
//  size of the datablock buffer is determined by the BlockSize member.
//

int
INTERNAL
RgAllocDatablockInfoBuffers(
                           LPDATABLOCK_INFO lpDatablockInfo
                           )
{

    lpDatablockInfo-> lpDatablockHeader = (LPDATABLOCK_HEADER)
                                          RgAllocMemory(lpDatablockInfo-> BlockSize);

    if (!IsNullPtr(lpDatablockInfo-> lpDatablockHeader)) {

        lpDatablockInfo-> lpKeyRecordTable = (LPKEY_RECORD_TABLE_ENTRY)
                                             RgSmAllocMemory(sizeof(KEY_RECORD_TABLE_ENTRY) *
                                                             KEY_RECORDS_PER_DATABLOCK);

        if (!IsNullPtr(lpDatablockInfo-> lpKeyRecordTable))
            return ERROR_SUCCESS;

        RgFreeDatablockInfoBuffers(lpDatablockInfo);

    }

    return ERROR_OUTOFMEMORY;

}

//
//  RgFreeDatablockInfoBuffers
//
//  Frees the buffers associated with a DATABLOCK_INFO structure.
//

VOID
INTERNAL
RgFreeDatablockInfoBuffers(
                          LPDATABLOCK_INFO lpDatablockInfo
                          )
{

    if (!IsNullPtr(lpDatablockInfo-> lpDatablockHeader)) {
        RgFreeMemory(lpDatablockInfo-> lpDatablockHeader);
        lpDatablockInfo-> lpDatablockHeader = NULL;
    }

    if (!IsNullPtr(lpDatablockInfo-> lpKeyRecordTable)) {
        RgSmFreeMemory(lpDatablockInfo-> lpKeyRecordTable);
        lpDatablockInfo-> lpKeyRecordTable = NULL;
    }

}

//
//  RgBuildKeyRecordTable
//
//  Builds a KEY_RECORD index table for the given datablock.
//
//  A datablock consists of a header followed by a series of variable-sized
//  KEY_RECORDs, each with a unique id.  To make lookups fast, an index table is
//  used to map from the unique id to that KEY_RECORD's location.
//
//  As we walk over each KEY_RECORD, we do checks to validate the structure of
//  the datablock, so the error code should be checked for corruption.
//

int
INTERNAL
RgBuildKeyRecordTable(
                     LPDATABLOCK_INFO lpDatablockInfo
                     )
{

    LPDATABLOCK_HEADER lpDatablockHeader;
    UINT Offset;
    UINT BytesRemaining;
    LPKEY_RECORD lpKeyRecord;
    DWORD DatablockAddress;

    ZeroMemory(lpDatablockInfo-> lpKeyRecordTable,
               sizeof(KEY_RECORD_TABLE_ENTRY) * KEY_RECORDS_PER_DATABLOCK);

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;
    Offset = sizeof(DATABLOCK_HEADER);
    BytesRemaining = lpDatablockInfo-> BlockSize - sizeof(DATABLOCK_HEADER);

    while (BytesRemaining) {

        lpKeyRecord = (LPKEY_RECORD) ((LPBYTE) lpDatablockHeader + Offset);
        DatablockAddress = lpKeyRecord-> DatablockAddress;

        if ((lpKeyRecord-> AllocatedSize == 0) || (lpKeyRecord-> AllocatedSize >
                                                   BytesRemaining) || ((DatablockAddress != REG_NULL) &&
                                                                       (LOWORD(DatablockAddress) >= KEY_RECORDS_PER_DATABLOCK))) {

            TRACE(("RgBuildKeyRecordTable: invalid key record detected\n"));

            TRACE(("lpdh=%x\n", lpDatablockHeader));
            TRACE(("lpkr=%x\n", lpKeyRecord));
            TRACE(("as=%x\n", lpKeyRecord-> AllocatedSize));
            TRACE(("br=%x\n", BytesRemaining));
            TRACE(("dba=%x\n", DatablockAddress));
            TRAP();

            return ERROR_BADDB;

        }

        if (DatablockAddress != REG_NULL) {
            lpDatablockInfo-> lpKeyRecordTable[LOWORD(DatablockAddress)] =
            (KEY_RECORD_TABLE_ENTRY) Offset;
        }

        Offset += SmallDword(lpKeyRecord-> AllocatedSize);
        BytesRemaining -= SmallDword(lpKeyRecord-> AllocatedSize);

    }

    return ERROR_SUCCESS;

}

//
//  RgLockDatablock
//
//  Locks the specified datablock in memory, indicating that it is about to be
//  used.  If the datablock is not currently in memory, then it is brought in.
//  Unlocked datablocks are freed as necessary to make room for this new
//  datablock.
//
//  IMPORTANT:  Locking a datablock only means that it's guaranteed to be kept
//  in memory.  It does not mean that pointers contained in a DATABLOCK_INFO
//  structure will remain the same: routines that could change the
//  DATABLOCK_INFO pointers are labeled "IMPORTANT" as well.
//
//  lpFileInfo, registry file containing the datablock.
//  BlockIndex, index of the datablock.
//

int
INTERNAL
RgLockDatablock(
               LPFILE_INFO lpFileInfo,
               UINT BlockIndex
               )
{

    int ErrorCode;
    LPDATABLOCK_INFO lpDatablockInfo;
    HFILE hFile = HFILE_ERROR;

    if (BlockIndex >= lpFileInfo-> FileHeader.BlockCount) {
        TRACE(("RgLockDatablock: invalid datablock number\n"));
        return ERROR_BADDB;
    }

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

    //
    //  Is the datablock currently in memory?
    //

    if (!(lpDatablockInfo-> Flags & DIF_PRESENT)) {

        NOISE(("RgLockDatablock: "));
        NOISE((lpFileInfo-> FileName));
        NOISE((", block %d\n", BlockIndex));

        ASSERT(lpDatablockInfo-> FileOffset != -1);

        if ((ErrorCode = RgAllocDatablockInfoBuffers(lpDatablockInfo)) !=
            ERROR_SUCCESS)
            goto CleanupAfterError;

        NOISE(("    lpDatablockHeader=%x\n", lpDatablockInfo-> lpDatablockHeader));
        NOISE(("    lpKeyRecordTable=%x\n", lpDatablockInfo-> lpKeyRecordTable));

        if ((hFile = RgOpenFile(lpFileInfo-> FileName, OF_READ)) == HFILE_ERROR)
            goto CleanupAfterFileError;

        if (!RgSeekFile(hFile, lpDatablockInfo-> FileOffset))
            goto CleanupAfterFileError;

        if (!RgReadFile(hFile, lpDatablockInfo-> lpDatablockHeader,
                        (UINT) lpDatablockInfo-> BlockSize))
            goto CleanupAfterFileError;

        if (!RgIsValidDatablockHeader(lpDatablockInfo-> lpDatablockHeader)) {
            ErrorCode = ERROR_BADDB;
            goto CleanupAfterError;
        }

        if ((ErrorCode = RgBuildKeyRecordTable(lpDatablockInfo)) !=
            ERROR_SUCCESS)
            goto CleanupAfterError;

        RgCloseFile(hFile);

    }

    lpDatablockInfo-> Flags |= (DIF_ACCESSED | DIF_PRESENT);
    lpDatablockInfo-> LockCount++;

    INCREMENT_DEBUG_COUNT(g_RgDatablockLockCount);
    return ERROR_SUCCESS;

    CleanupAfterFileError:
    ErrorCode = ERROR_REGISTRY_IO_FAILED;

    CleanupAfterError:
    if (hFile != HFILE_ERROR)
        RgCloseFile(hFile);

    RgFreeDatablockInfoBuffers(lpDatablockInfo);

    DEBUG_OUT(("RgLockDatablock() returning error %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgUnlockDatablock
//
//  Unlocks the datablock, indicating that the datablock is no longer in active
//  use.  After a datablock has been unlocked, the datablock may be freed after
//  flushing to disk if dirty.
//

VOID
INTERNAL
RgUnlockDatablock(
                 LPFILE_INFO lpFileInfo,
                 UINT BlockIndex,
                 BOOL fMarkDirty
                 )
{

    LPDATABLOCK_INFO lpDatablockInfo;

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

    ASSERT(lpDatablockInfo-> LockCount > 0);
    lpDatablockInfo-> LockCount--;

    if (fMarkDirty) {
        lpDatablockInfo-> Flags |= DIF_DIRTY;
        lpFileInfo-> Flags |= FI_DIRTY;
        RgDelayFlush();
    }

    DECREMENT_DEBUG_COUNT(g_RgDatablockLockCount);

}

//
//  RgLockKeyRecord
//
//  Wraps RgLockDatablock, returning the address of the specified KEY_RECORD
//  structure.
//

int
INTERNAL
RgLockKeyRecord(
               LPFILE_INFO lpFileInfo,
               UINT BlockIndex,
               BYTE KeyRecordIndex,
               LPKEY_RECORD FAR* lplpKeyRecord
               )
{

    int ErrorCode;
    LPDATABLOCK_INFO lpDatablockInfo;

    if ((ErrorCode = RgLockDatablock(lpFileInfo, BlockIndex)) ==
        ERROR_SUCCESS) {

        lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

        if (IsNullKeyRecordTableEntry(lpDatablockInfo->
                                      lpKeyRecordTable[KeyRecordIndex])) {
            RgUnlockDatablock(lpFileInfo, BlockIndex, FALSE);
            TRACE(("RgLockKeyRecord: invalid datablock address %x:%x\n",
                   BlockIndex, KeyRecordIndex));
            ErrorCode = ERROR_BADDB;
        }

        else {
            *lplpKeyRecord = RgIndexKeyRecordPtr(lpDatablockInfo,
                                                 KeyRecordIndex);
        }

    }

    return ErrorCode;

}

//
//  RgCompactDatablock
//
//  Compacts the datablock by pushing all KEY_RECORDS together and leaving a
//  single FREEKEY_RECORD at the end.
//
//  The datablock must be marked dirty by the caller, if desired.
//
//  Returns TRUE if any action was taken.
//

BOOL
INTERNAL
RgCompactDatablock(
                  LPDATABLOCK_INFO lpDatablockInfo
                  )
{

    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;
    LPBYTE lpSource;
    LPBYTE lpDestination;
    UINT Offset;
    UINT BlockSize;
    UINT BytesToPushDown;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    //  Only need to compact if there's a free record in this datablock.
    if (lpDatablockHeader-> FirstFreeOffset == REG_NULL)
        return FALSE;

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                                          SmallDword(lpDatablockHeader-> FirstFreeOffset));

    //  Only need to compact if the all the free bytes aren't already at the end
    //  of the datablock (datablocks can't be greater than 64K-1, so no overflow
    //  is possible).
    if ((SmallDword(lpDatablockHeader-> FirstFreeOffset) +
         SmallDword(lpFreeKeyRecord-> AllocatedSize) >= lpDatablockInfo->
         BlockSize) && (lpFreeKeyRecord-> NextFreeOffset == REG_NULL))
        return FALSE;

    NOISE(("RgCompactDatablock: block %d\n", lpDatablockHeader-> BlockIndex));

    lpSource = NULL;
    lpDestination = NULL;
    Offset = sizeof(DATABLOCK_HEADER);
    BlockSize = lpDatablockInfo-> BlockSize;

    while (Offset < BlockSize) {

        //  Advance to the next free record or the end of the block.
        for (;;) {

            lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                                                  Offset);

            if (Offset >= BlockSize || IsKeyRecordFree(lpFreeKeyRecord)) {

                //
                //  If lpSource is valid, then we can push down the bytes from
                //  lpSource through lpFreeKeyRecord to lpDestination.
                //

                if (!IsNullPtr(lpSource)) {
                    BytesToPushDown = (LPBYTE) lpFreeKeyRecord -
                                      (LPBYTE) lpSource;
                    MoveMemory(lpDestination, lpSource, BytesToPushDown);
                    lpDestination += BytesToPushDown;
                }

                if (IsNullPtr(lpDestination))
                    lpDestination = (LPBYTE) lpFreeKeyRecord;

                break;

            }

            Offset += SmallDword(lpFreeKeyRecord-> AllocatedSize);

        }

        //  Advance to the next key record.
        while (Offset < BlockSize) {

            lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                                                  Offset);

            if (!IsKeyRecordFree(lpFreeKeyRecord)) {
                lpSource = (LPBYTE) lpFreeKeyRecord;
                break;
            }

            Offset += SmallDword(lpFreeKeyRecord-> AllocatedSize);

        }

    }

    //  lpDestination now points at the end of the datablock where the giant
    //  free record is to be placed.  Initialize this record and patch up the
    //  datablock header.
    lpDatablockHeader-> FirstFreeOffset = (LPBYTE) lpDestination -
                                          (LPBYTE) lpDatablockHeader;
    ((LPFREEKEY_RECORD) lpDestination)-> AllocatedSize = lpDatablockInfo->
                                                         FreeBytes;
    ((LPFREEKEY_RECORD) lpDestination)-> DatablockAddress = REG_NULL;
    ((LPFREEKEY_RECORD) lpDestination)-> NextFreeOffset = REG_NULL;

    //  The key record table is now invalid, so we must refresh its contents.
    RgBuildKeyRecordTable(lpDatablockInfo);

    return TRUE;

}

//
//  RgCreateDatablock
//
//  Creates a new datablock at the end of the file of the specified length (plus
//  padding to align the block).
//
//  The datablock is locked, so RgUnlockDatablock must be called on the last
//  datablock in the file.
//

int
INTERNAL
RgCreateDatablock(
                 LPFILE_INFO lpFileInfo,
                 UINT Length
                 )
{

    UINT BlockCount;
    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;

    BlockCount = lpFileInfo-> FileHeader.BlockCount;

    if (BlockCount >= DATABLOCKS_PER_FILE)
        return ERROR_OUTOFMEMORY;

    if (BlockCount >= lpFileInfo-> DatablockInfoAllocCount) {

        //  lpDatablockInfo is too small to hold the info for a new datablock,
        //  so we must grow it a bit.
        if (IsNullPtr((lpDatablockInfo = (LPDATABLOCK_INFO)
                       RgSmReAllocMemory(lpFileInfo-> lpDatablockInfo, (BlockCount +
                                                                        DATABLOCK_INFO_SLACK_ALLOC) * sizeof(DATABLOCK_INFO)))))
            return ERROR_OUTOFMEMORY;

        lpFileInfo-> lpDatablockInfo = lpDatablockInfo;
        lpFileInfo-> DatablockInfoAllocCount += DATABLOCK_INFO_SLACK_ALLOC;

    }

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockCount);

    Length = RgAlignBlockSize(Length + sizeof(DATABLOCK_HEADER));
    lpDatablockInfo-> BlockSize = Length;

    if (RgAllocDatablockInfoBuffers(lpDatablockInfo) != ERROR_SUCCESS)
        return ERROR_OUTOFMEMORY;

    lpDatablockInfo-> FreeBytes = Length - sizeof(DATABLOCK_HEADER);
    lpDatablockInfo-> FirstFreeIndex = 0;
    lpDatablockInfo-> FileOffset = -1;          //  Set during file flush
    lpDatablockInfo-> Flags = DIF_PRESENT | DIF_ACCESSED | DIF_DIRTY;
    lpDatablockInfo-> LockCount = 1;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;
    lpDatablockHeader-> Signature = DH_SIGNATURE;
    lpDatablockHeader-> BlockSize = Length;
    lpDatablockHeader-> FreeBytes = lpDatablockInfo-> FreeBytes;
    lpDatablockHeader-> Flags = DHF_HASBLOCKNUMBERS;
    lpDatablockHeader-> BlockIndex = (WORD) BlockCount;
    lpDatablockHeader-> FirstFreeOffset = sizeof(DATABLOCK_HEADER);
    lpDatablockHeader-> MaxAllocatedIndex = 0;
    //  lpDatablockHeader-> FirstFreeIndex is copied back on the flush.
    //  lpDatablockHeader-> Reserved is worthless because it was randomly set
    //      to a pointer in the old code.

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                                          sizeof(DATABLOCK_HEADER));
    lpFreeKeyRecord-> AllocatedSize = lpDatablockInfo-> FreeBytes;
    lpFreeKeyRecord-> DatablockAddress = REG_NULL;
    lpFreeKeyRecord-> NextFreeOffset = REG_NULL;

    lpFileInfo-> FileHeader.BlockCount++;
    lpFileInfo-> FileHeader.Flags |= FHF_DIRTY;

    lpFileInfo-> Flags |= FI_DIRTY | FI_EXTENDED;
    RgDelayFlush();

    INCREMENT_DEBUG_COUNT(g_RgDatablockLockCount);

    //  We must initialize the key record table, so we might as well let
    //  RgBuildKeyRecordTable check the validity of what we just created...
    return RgBuildKeyRecordTable(lpDatablockInfo);

}

//
//  RgExtendDatablock
//
//  Extends the given datablock to the specified size.  If successful, then the
//  resulting datablock will be compacted with a single FREEKEY_RECORD at the
//  end of the datablock which will include the added space.
//

int
INTERNAL
RgExtendDatablock(
                 LPFILE_INFO lpFileInfo,
                 UINT BlockIndex,
                 UINT Length
                 )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    DWORD NewBlockSize;
    LPDATABLOCK_HEADER lpNewDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);
    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
    ASSERT(lpDatablockInfo-> Flags & DIF_PRESENT);

    //  Check if enough free bytes already exist: if so, no need to extend.
    if (lpDatablockInfo-> FreeBytes >= Length) {
        DEBUG_OUT(("RgExtendDatablock: unexpectedly called\n"));
        return ERROR_SUCCESS;
    }

    NewBlockSize = RgAlignBlockSize(lpDatablockInfo-> BlockSize + Length -
                                    lpDatablockInfo-> FreeBytes);

    if (NewBlockSize > MAXIMUM_DATABLOCK_SIZE) {
        TRACE(("RgExtendDatablock: datablock too big\n"));
        return ERROR_OUTOFMEMORY;
    }

    NOISE(("RgExtendDatablock: block %d\n", BlockIndex));
    NOISE(("block size=%x, new block size=%x\n", lpDatablockInfo-> BlockSize,
           NewBlockSize));

    if (IsNullPtr((lpNewDatablockHeader = (LPDATABLOCK_HEADER)
                   RgReAllocMemory(lpDatablockInfo-> lpDatablockHeader, (UINT)
                                   NewBlockSize))))
        return ERROR_OUTOFMEMORY;

    lpDatablockInfo-> lpDatablockHeader = lpNewDatablockHeader;

    RgCompactDatablock(lpDatablockInfo);

    if (lpNewDatablockHeader-> FirstFreeOffset == REG_NULL) {
        lpNewDatablockHeader-> FirstFreeOffset = lpDatablockInfo-> BlockSize;
        lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpNewDatablockHeader +
                                              SmallDword(lpNewDatablockHeader-> FirstFreeOffset));
        lpFreeKeyRecord-> DatablockAddress = REG_NULL;
        lpFreeKeyRecord-> NextFreeOffset = REG_NULL;
    }

    else {
        lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpNewDatablockHeader +
                                              SmallDword(lpNewDatablockHeader-> FirstFreeOffset));
    }

    lpDatablockInfo-> FreeBytes += (UINT) NewBlockSize - lpDatablockInfo->
                                   BlockSize;
    lpFreeKeyRecord-> AllocatedSize = lpDatablockInfo-> FreeBytes;
    lpDatablockInfo-> BlockSize = (UINT) NewBlockSize;

    lpDatablockInfo-> Flags |= (DIF_DIRTY | DIF_EXTENDED);

    lpFileInfo-> Flags |= FI_DIRTY | FI_EXTENDED;
    RgDelayFlush();

    return ERROR_SUCCESS;

}

//
//  RgAllocKeyRecordFromDatablock
//
//  Creates an uninitialized KEY_RECORD of the desired size from the provided
//  datablock.  On exit, only AllocatedSize is valid.
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//
//  IMPORTANT:  Any datablock may be relocated as a result of calling this
//  routine.  All pointers to datablocks should be refetched.
//

int
INTERNAL
RgAllocKeyRecordFromDatablock(
                             LPFILE_INFO lpFileInfo,
                             UINT BlockIndex,
                             UINT Length,
                             LPKEY_RECORD FAR* lplpKeyRecord
                             )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;
    UINT AllocatedSize;
    LPFREEKEY_RECORD lpNewFreeKeyRecord;
    UINT ExtraBytes;

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);
    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
    ASSERT(lpDatablockInfo-> Flags & DIF_PRESENT);

    if (Length > lpDatablockInfo-> FreeBytes)
        return ERROR_OUTOFMEMORY;

    RgCompactDatablock(lpDatablockInfo);

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                                          SmallDword(lpDatablockHeader-> FirstFreeOffset));

    AllocatedSize = SmallDword(lpFreeKeyRecord-> AllocatedSize);

    if (Length > AllocatedSize) {
        TRACE(("RgAllocKeyRecordFromDatablock() detected corruption?\n"));
        return ERROR_OUTOFMEMORY;
    }

    ExtraBytes = AllocatedSize - Length;

    //
    //  If we were to break this FREEKEY_RECORD into two records, would the
    //  second chunk be too small?  If so, then don't do it.  Just give back
    //  the full allocated size to the caller.
    //

    if (ExtraBytes >= MINIMUM_FREE_RECORD_LENGTH) {

        lpNewFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpFreeKeyRecord +
                                                 Length);

        lpDatablockHeader-> FirstFreeOffset += Length;

        lpFreeKeyRecord-> AllocatedSize = Length;

        //  IMPORTANT:	Note that lpNewFreeKeyRecord and lpFreeKeyRecord may
        //  overlap so we have to be careful when changing these fields!
        lpNewFreeKeyRecord-> NextFreeOffset = lpFreeKeyRecord-> NextFreeOffset;
        lpNewFreeKeyRecord-> DatablockAddress = REG_NULL;
        lpNewFreeKeyRecord-> AllocatedSize = ExtraBytes;

    }

    else {

        Length = AllocatedSize;

        lpDatablockHeader-> FirstFreeOffset = lpFreeKeyRecord-> NextFreeOffset;

    }

    //  Adjust the number of free bytes in this datablock.  At this point,
    //  Length is equal to the size of the newly formed record.
    lpDatablockInfo-> FreeBytes -= Length;

    *lplpKeyRecord = (LPKEY_RECORD) lpFreeKeyRecord;
    return ERROR_SUCCESS;

}

//
//  RgAllocKeyRecordIndex
//
//  Allocates a key record index from the provided datablock.  If no indexs
//  are available in the datablock, then KEY_RECORDS_PER_DATABLOCK is returned.
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//

UINT
INTERNAL
RgAllocKeyRecordIndex(
                     LPDATABLOCK_INFO lpDatablockInfo
                     )
{

    LPDATABLOCK_HEADER lpDatablockHeader;
    UINT KeyRecordIndex;
    UINT NextFreeIndex;
    LPKEY_RECORD_TABLE_ENTRY lpKeyRecordTableEntry;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;
    KeyRecordIndex = lpDatablockInfo-> FirstFreeIndex;
    NextFreeIndex = KeyRecordIndex + 1;

    ASSERT(KeyRecordIndex < KEY_RECORDS_PER_DATABLOCK);
    ASSERT(IsNullKeyRecordTableEntry(lpDatablockInfo->
                                     lpKeyRecordTable[KeyRecordIndex]));

    if (KeyRecordIndex > lpDatablockHeader-> MaxAllocatedIndex)
        lpDatablockHeader-> MaxAllocatedIndex = (WORD) KeyRecordIndex;

    else {

        //  Find the next free hole in the key record table or leave ourselves
        //  at the end of the table.
        for (lpKeyRecordTableEntry =
             &lpDatablockInfo-> lpKeyRecordTable[NextFreeIndex]; NextFreeIndex <=
            lpDatablockHeader-> MaxAllocatedIndex; NextFreeIndex++,
            lpKeyRecordTableEntry++) {
            if (IsNullKeyRecordTableEntry(*lpKeyRecordTableEntry))
                break;
        }

    }

    lpDatablockInfo-> FirstFreeIndex = NextFreeIndex;

    return KeyRecordIndex;

}

//
//  RgAllocKeyRecord
//
//
//  IMPORTANT:  Any datablock may be relocated as a result of calling this
//  routine.  All pointers to datablocks should be refetched.
//

int
INTERNAL
RgAllocKeyRecord(
                LPFILE_INFO lpFileInfo,
                UINT Length,
                LPKEY_RECORD FAR* lplpKeyRecord
                )
{

    BOOL fExtendDatablock;
    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    UINT KeyRecordIndex;

    if (lpFileInfo-> FileHeader.BlockCount == 0)
        goto MakeNewDatablock;

    //
    //  Find a datablock that can satisfy the allocation request.  Two passes
    //  may be made over this routine-- during the second pass, datablocks may
    //  be extended.
    //

    fExtendDatablock = FALSE;

    DoSecondPass:
    BlockIndex = lpFileInfo-> FileHeader.BlockCount;
    //  We overindex by one, but this gets decremented at the start of the loop.
    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

    while (BlockIndex--) {

        lpDatablockInfo--;

        //  Are there any more ids available in this datablock?
        if (lpDatablockInfo-> FirstFreeIndex >= KEY_RECORDS_PER_DATABLOCK)
            continue;

        if (fExtendDatablock) {
            //  Can we grow this datablock without exceeding the maximum size?
            if ((DWORD) (lpDatablockInfo-> BlockSize - lpDatablockInfo->
                         FreeBytes) + Length > MAXIMUM_DATABLOCK_SIZE)
                continue;
        } else {
            //  Is there enough free space in this datablock for this record?
            if (Length > lpDatablockInfo-> FreeBytes)
                continue;
        }

        if (RgLockDatablock(lpFileInfo, BlockIndex) == ERROR_SUCCESS) {

            if (!fExtendDatablock || RgExtendDatablock(lpFileInfo, BlockIndex,
                                                       Length) == ERROR_SUCCESS) {

                if (RgAllocKeyRecordFromDatablock(lpFileInfo, BlockIndex,
                                                  Length, lplpKeyRecord) == ERROR_SUCCESS)
                    goto AllocatedKeyRecord;

            }

            RgUnlockDatablock(lpFileInfo, BlockIndex, FALSE);

        }

    }

    //  If we haven't already tried to extend some datablock, make another
    //  pass over the blocks to do so.
    if (!fExtendDatablock) {
        fExtendDatablock = TRUE;
        goto DoSecondPass;
    }

    //
    //  No datablock has enough space to satisfy the request, so attempt to
    //  create a new one at the end of the file.
    //

    MakeNewDatablock:
    if (RgCreateDatablock(lpFileInfo, Length) == ERROR_SUCCESS) {

        BlockIndex = lpFileInfo-> FileHeader.BlockCount - 1;
        lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

        if (RgAllocKeyRecordFromDatablock(lpFileInfo, BlockIndex, Length,
                                          lplpKeyRecord) == ERROR_SUCCESS) {

            AllocatedKeyRecord:
            KeyRecordIndex = RgAllocKeyRecordIndex(lpDatablockInfo);
            (*lplpKeyRecord)-> DatablockAddress = MAKELONG(KeyRecordIndex,
                                                           BlockIndex);
            lpDatablockInfo-> lpKeyRecordTable[KeyRecordIndex] =
            (KEY_RECORD_TABLE_ENTRY) ((LPBYTE) (*lplpKeyRecord) -
                                      (LPBYTE) lpDatablockInfo-> lpDatablockHeader);
            return ERROR_SUCCESS;

        }

        RgUnlockDatablock(lpFileInfo, BlockIndex, FALSE);

    }

    return ERROR_OUTOFMEMORY;

}

//
//  RgExtendKeyRecord
//
//  Attempts to extend the given KEY_RECORD by combining it with an adjacent
//  FREE_RECORD.
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//
//  Returns ERROR_SUCCESS if the KEY_RECORD could be extended, else
//  ERROR_OUTOFMEMORY.
//

int
INTERNAL
RgExtendKeyRecord(
                 LPFILE_INFO lpFileInfo,
                 UINT BlockIndex,
                 UINT Length,
                 LPKEY_RECORD lpKeyRecord
                 )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;
    UINT AllocatedSize;
    UINT FreeSizeAllocation;
    UINT ExtraBytes;
    LPFREEKEY_RECORD lpTempFreeKeyRecord;
    DWORD NewFreeOffset;                    //  May be REG_NULL
    UINT FreeOffset;
    DWORD Offset;                           //  May be REG_NULL

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    AllocatedSize = SmallDword(lpKeyRecord-> AllocatedSize);

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpKeyRecord +
                                          AllocatedSize);
    FreeOffset = (LPBYTE) lpFreeKeyRecord - (LPBYTE) lpDatablockHeader;

    //  Check if this key record is at the very end of the datablock and that
    //  lpFreeKeyRecord is really a free key record.
    if (FreeOffset >= lpDatablockInfo-> BlockSize ||
        !IsKeyRecordFree(lpFreeKeyRecord))
        return ERROR_OUTOFMEMORY;

    ASSERT(Length >= AllocatedSize);
    FreeSizeAllocation = Length - AllocatedSize;

    AllocatedSize = SmallDword(lpFreeKeyRecord-> AllocatedSize);

    if (FreeSizeAllocation > AllocatedSize)
        return ERROR_OUTOFMEMORY;

    ExtraBytes = AllocatedSize - FreeSizeAllocation;

    //
    //  If we were to break this FREEKEY_RECORD into two records, would the
    //  second chunk be too small?  If so, then don't do it.  Just give back
    //  the full allocated size to the caller.
    //

    if (ExtraBytes >= MINIMUM_FREE_RECORD_LENGTH) {

        NewFreeOffset = FreeOffset + FreeSizeAllocation;
        lpTempFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpFreeKeyRecord +
                                                  FreeSizeAllocation);

        //  IMPORTANT:	Note that lpNewFreeKeyRecord and lpFreeKeyRecord may
        //  overlap so we have to be careful when changing these fields!
        lpTempFreeKeyRecord-> NextFreeOffset = lpFreeKeyRecord-> NextFreeOffset;
        lpTempFreeKeyRecord-> DatablockAddress = REG_NULL;
        lpTempFreeKeyRecord-> AllocatedSize = ExtraBytes;

    }

    else {

        NewFreeOffset = lpFreeKeyRecord-> NextFreeOffset;

        //  The key record's allocated length will also include all of the extra
        //  bytes.
        FreeSizeAllocation += ExtraBytes;

    }

    lpKeyRecord-> AllocatedSize += FreeSizeAllocation;
    lpDatablockInfo-> FreeBytes -= FreeSizeAllocation;

    //
    //  Unlink the free record that we just extended into and possibly link in
    //  the new FREEKEY_RECORD if a split occurred.
    //

    Offset = lpDatablockHeader-> FirstFreeOffset;

    if (Offset == FreeOffset) {
        lpDatablockHeader-> FirstFreeOffset = NewFreeOffset;
    }

    else {

        while (Offset != REG_NULL) {

            lpTempFreeKeyRecord =
            (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                                SmallDword(Offset));

            Offset = lpTempFreeKeyRecord-> NextFreeOffset;

            if (Offset == FreeOffset) {
                lpTempFreeKeyRecord-> NextFreeOffset = NewFreeOffset;
                break;
            }

        }

    }

    return ERROR_SUCCESS;

}

//
//  RgFreeKeyRecord
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//

VOID
INTERNAL
RgFreeKeyRecord(
               LPDATABLOCK_INFO lpDatablockInfo,
               LPKEY_RECORD lpKeyRecord
               )
{

    LPDATABLOCK_HEADER lpDatablockHeader;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    ((LPFREEKEY_RECORD) lpKeyRecord)-> DatablockAddress = REG_NULL;
    ((LPFREEKEY_RECORD) lpKeyRecord)-> NextFreeOffset = lpDatablockHeader->
                                                        FirstFreeOffset;
    lpDatablockHeader-> FirstFreeOffset = (LPBYTE) lpKeyRecord - (LPBYTE)
                                          lpDatablockHeader;
    lpDatablockInfo-> FreeBytes += SmallDword(((LPFREEKEY_RECORD) lpKeyRecord)->
                                              AllocatedSize);

}

//
//  RgFreeKeyRecordIndex
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//
//  We don't bother updated MaxAllocatedIndex because it's only really useful
//  if we're always freeing from the maximum index to zero.  This is very
//  rarely the case, so no point in keeping that test around or touching the
//  datablock header page just to do it.
//

VOID
INTERNAL
RgFreeKeyRecordIndex(
                    LPDATABLOCK_INFO lpDatablockInfo,
                    UINT KeyRecordIndex
                    )
{

    ASSERT(lpDatablockInfo-> lpDatablockHeader-> MaxAllocatedIndex >=
           KeyRecordIndex);

    if (lpDatablockInfo-> FirstFreeIndex > KeyRecordIndex)
        lpDatablockInfo-> FirstFreeIndex = KeyRecordIndex;

    lpDatablockInfo-> lpKeyRecordTable[KeyRecordIndex] =
    NULL_KEY_RECORD_TABLE_ENTRY;

}

//
//  RgWriteDatablocks
//
//  Writes all dirty datablocks to the file specified by the file handle.
//

int
INTERNAL
RgWriteDatablocks(
                 LPFILE_INFO lpFileInfo,
                 HFILE hSourceFile,
                 HFILE hDestinationFile
                 )
{

    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LONG FileOffset;

    lpDatablockInfo = lpFileInfo-> lpDatablockInfo;
    FileOffset = lpFileInfo-> FileHeader.Size;

    for (BlockIndex = 0; BlockIndex < lpFileInfo-> FileHeader.BlockCount;
        BlockIndex++, lpDatablockInfo++) {

        if (lpDatablockInfo-> Flags & DIF_PRESENT) {

            //  The block is currently in memory.  If we're either extending
            //  the file or the block is dirty, then write out our in-memory
            //  copy to disk.
            if (hSourceFile != HFILE_ERROR || lpDatablockInfo-> Flags &
                DIF_DIRTY) {

                NOISE(("writing datablock #%d of ", BlockIndex));
                NOISE((lpFileInfo-> FileName));
                NOISE(("\n"));

                lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

                //  Copy back the fields that we've been maintaining in the
                //  DATABLOCK_INFO structure.
                lpDatablockHeader-> BlockSize = lpDatablockInfo-> BlockSize;
                lpDatablockHeader-> FreeBytes = lpDatablockInfo-> FreeBytes;
                lpDatablockHeader-> FirstFreeIndex = (WORD) lpDatablockInfo->
                                                     FirstFreeIndex;

                //  The checksum is not currently calculated, so we must clear
                //  the flag so we don't confuse Win95.
                lpDatablockHeader-> Flags &= ~DHF_HASCHECKSUM;

                if (!RgSeekFile(hDestinationFile, FileOffset))
                    return ERROR_REGISTRY_IO_FAILED;

                if (!RgWriteFile(hDestinationFile, lpDatablockHeader,
                                 lpDatablockInfo-> BlockSize))
                    return ERROR_REGISTRY_IO_FAILED;

            }

        }

        else {

            //  The block is not currently in memory.  If we're extending the
            //  file, then we must write out this datablock.  The overhead is
            //  too great to lock the datablock down, so just copy it from the
            //  original file to the extended file.
            if (hSourceFile != HFILE_ERROR) {

                if (RgCopyFileBytes(hSourceFile, lpDatablockInfo-> FileOffset,
                                    hDestinationFile, FileOffset, lpDatablockInfo->
                                    BlockSize) != ERROR_SUCCESS)
                    return ERROR_REGISTRY_IO_FAILED;

            }

        }

        FileOffset += lpDatablockInfo-> BlockSize;

    }

    return ERROR_SUCCESS;

}

//
//  RgWriteDatablocksComplete
//
//  Called after a file has been successfully written.  We can now safely clear
//  all dirty flags and update our state information with the knowledge that
//  the file is in a consistent state.
//

VOID
INTERNAL
RgWriteDatablocksComplete(
                         LPFILE_INFO lpFileInfo
                         )
{

    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    LONG FileOffset;

    lpDatablockInfo = lpFileInfo-> lpDatablockInfo;
    FileOffset = lpFileInfo-> FileHeader.Size;

    for (BlockIndex = 0; BlockIndex < lpFileInfo-> FileHeader.BlockCount;
        BlockIndex++, lpDatablockInfo++) {

        lpDatablockInfo-> Flags &= ~DIF_DIRTY;
        lpDatablockInfo-> FileOffset = FileOffset;

        FileOffset += lpDatablockInfo-> BlockSize;

    }

}

//
//  RgSweepDatablocks
//
//  Makes a pass through all the present datablocks of the given FILE_INFO
//  structure and discards datablocks that have not been accessed since the last
//  sweep.
//

VOID
INTERNAL
RgSweepDatablocks(
                 LPFILE_INFO lpFileInfo
                 )
{

    UINT BlocksLeft;
    LPDATABLOCK_INFO lpDatablockInfo;

    for (BlocksLeft = lpFileInfo-> FileHeader.BlockCount, lpDatablockInfo =
         lpFileInfo-> lpDatablockInfo; BlocksLeft > 0; BlocksLeft--,
        lpDatablockInfo++) {

        if (((lpDatablockInfo-> Flags & (DIF_PRESENT | DIF_ACCESSED |
                                         DIF_DIRTY)) == DIF_PRESENT) && (lpDatablockInfo-> LockCount == 0)) {

            NOISE(("discarding datablock #%d of ",
                   lpFileInfo-> FileHeader.BlockCount - BlocksLeft));
            NOISE((lpFileInfo-> FileName));
            NOISE(("\n"));

            RgFreeDatablockInfoBuffers(lpDatablockInfo);

            lpDatablockInfo-> Flags = 0;

        }

        //  Reset the accessed bit for the next sweep.
        lpDatablockInfo-> Flags &= ~DIF_ACCESSED;

    }

}

//
//  RgIsValidDatablockHeader
//
//  Returns TRUE if lpDatablockHeader is a valid DATABLOCK_HEADER structure.
//

BOOL
INTERNAL
RgIsValidDatablockHeader(
                        LPDATABLOCK_HEADER lpDatablockHeader
                        )
{

    if (lpDatablockHeader-> Signature != DH_SIGNATURE ||
        HIWORD(lpDatablockHeader-> BlockSize) != 0)
        return FALSE;

    return TRUE;

}

#ifdef VXD
    #pragma VxD_RARE_CODE_SEG
#endif

//
//  RgInitDatablockInfo
//
//  Initializes fields in the provided FILE_INFO related to the datablocks.
//

int
INTERNAL
RgInitDatablockInfo(
                   LPFILE_INFO lpFileInfo,
                   HFILE hFile
                   )
{

    UINT BlockCount;
    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    LONG FileOffset;
    DATABLOCK_HEADER DatablockHeader;

    BlockCount = lpFileInfo-> FileHeader.BlockCount;

    if (IsNullPtr((lpDatablockInfo = (LPDATABLOCK_INFO)
                   RgSmAllocMemory((BlockCount + DATABLOCK_INFO_SLACK_ALLOC) *
                                   sizeof(DATABLOCK_INFO)))))
        return ERROR_OUTOFMEMORY;

    ZeroMemory(lpDatablockInfo, BlockCount * sizeof(DATABLOCK_INFO));
    lpFileInfo-> lpDatablockInfo = lpDatablockInfo;
    lpFileInfo-> DatablockInfoAllocCount = BlockCount +
                                           DATABLOCK_INFO_SLACK_ALLOC;

    FileOffset = lpFileInfo-> FileHeader.Size;

    for (BlockIndex = 0; BlockIndex < BlockCount; BlockIndex++,
        lpDatablockInfo++) {

        if (!RgSeekFile(hFile, FileOffset))
            return ERROR_REGISTRY_IO_FAILED;

        if (!RgReadFile(hFile, &DatablockHeader, sizeof(DATABLOCK_HEADER)))
            return ERROR_REGISTRY_IO_FAILED;

        if (!RgIsValidDatablockHeader(&DatablockHeader))
            return ERROR_BADDB;

        //  Following fields already zeroed by above ZeroMemory.
        //  lpDatablockInfo-> lpDatablockHeader = NULL;
        //  lpDatablockInfo-> lpKeyRecordTable = NULL;
        //  lpDatablockInfo-> Flags = 0;
        //  lpDatablockInfo-> LockCount = 0;

        lpDatablockInfo-> FileOffset = FileOffset;

        //  Cache these fields from the datablock header.  These fields should
        //  not be considered valid when the datablock is physically in memory.
        lpDatablockInfo-> BlockSize = SmallDword(DatablockHeader.BlockSize);
        lpDatablockInfo-> FreeBytes = SmallDword(DatablockHeader.FreeBytes);
        lpDatablockInfo-> FirstFreeIndex = DatablockHeader.FirstFreeIndex;

        NOISE(("DB#%d fileoff=%lx, size=%x free=%x 1stindex=%d\n", BlockIndex,
               FileOffset, lpDatablockInfo-> BlockSize, lpDatablockInfo->
               FreeBytes, lpDatablockInfo-> FirstFreeIndex));

        FileOffset += lpDatablockInfo-> BlockSize;

    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\pch.h ===
//
//  PCH.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGPRIV_
#define _REGPRIV_

//  Conditional enable registry "features" based on the target model.
//
//  WANT_STATIC_KEYS:  Allocates key handles from a memory pool allocated
//  during library initialization.  Especially useful for real-mode to reduce
//  the memory fragmentation caused by allocating several small fixed objects.
//
//  WANT_FULL_MEMORY_CLEANUP:  When detaching, free every memory block.  Not
//  necessary for the ring zero version where "detach" means system shutdown.
//
//  WANT_HIVE_SUPPORT:  RegLoadKey, RegUnLoadKey, RegSaveKey, RegReplaceKey
//  APIs plus support code.
//
//  WANT_DYNKEY_SUPPORT:  RegCreateDynKey plus HKEY_DYN_DATA support.
//
//  WANT_NOTIFY_CHANGE_SUPPORT:  RegNotifyChangeKeyValue plus support code.
#ifndef IS_32
#define WANT_STATIC_KEYS
#endif
#ifndef VXD
#define WANT_FULL_MEMORY_CLEANUP
#endif
#ifndef REALMODE
#define WANT_HIVE_SUPPORT
#endif
#ifdef VXD
#define WANT_REGREPLACEKEY
#define WANT_DYNKEY_SUPPORT
#define WANT_NOTIFY_CHANGE_SUPPORT
#endif

//  Map any other header's definitions of these to unused types.
#define HKEY __UNUSED_HKEY
#define LPHKEY __UNUSED_LPHKEY

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#define NORESOURCE                  //  prevent RT_* definitions from vmmsys.h
#include <windows.h>
#include <string.h>
#ifdef VXD
#include <vmmsys.h>
#include <thrdsys.h>
#endif

#ifndef UNALIGNED
#define UNALIGNED                   //  defined in standard headers for RISC
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY               1
#endif

#ifdef VXD
//  By default, all registry code and data is pageable.
#pragma VMM_PAGEABLE_CODE_SEG
#pragma VMM_PAGEABLE_DATA_SEG
#endif

#define UNREFERENCED_PARAMETER(P)   (P)

#define INTERNAL                    PASCAL NEAR
#define INTERNALV                   CDECL NEAR

//  Undefine any constants that we're about to define ourselves.
#undef HKEY
#undef LPHKEY
#undef HKEY_CLASSES_ROOT
#undef HKEY_CURRENT_USER
#undef HKEY_LOCAL_MACHINE
#undef HKEY_USERS
#undef HKEY_PERFORMANCE_DATA
#undef HKEY_CURRENT_CONFIG
#undef HKEY_DYN_DATA

typedef struct _KEY FAR*            HKEY;               //  Forward reference

#include "regdebug.h"
#include "regffmt.h"
#include "regfinfo.h"

//  Many file structures in the registry are declared as DWORDs, the HIWORD is
//  always zero.  Use SmallDword to access such DWORDs for optimal access in
//  16-bit or 32-bit code.
#if defined(IS_32)
#define SmallDword(dw)              ((UINT) (dw))
#else
#define SmallDword(dw)              ((UINT) LOWORD((dw)))
#endif

#if defined(WIN16)
#define IsNullPtr(ptr)              (SELECTOROF((ptr)) == NULL)
#else
#define IsNullPtr(ptr)              ((ptr) == NULL)
#endif

//  In either mode, the resulting code uses an instrinsic version of the memcmp
//  function.
#if defined(IS_32)
#define CompareMemory               memcmp
#else
#define CompareMemory               _fmemcmp
#endif

#if defined(WIN16) || defined(WIN32)
#define StrCpy(lpd, lps)            (lstrcpy((lpd), (lps)))
#define StrCpyN(lpd, lps, cb)       (lstrcpyn((lpd), (lps), (cb)))
#define StrLen(lpstr)               (lstrlen((lpstr)))
#define ToUpper(ch)                 ((int) (DWORD) AnsiUpper((LPSTR)((BYTE)(ch))))
#define RgCreateFile(lpfn)          ((HFILE) _lcreat((lpfn), 0))
#define RgOpenFile(lpfn, mode)      ((HFILE) _lopen((lpfn), (mode)))
#define RgCloseFile(h)              ((VOID) _lclose(h))
#if defined(WIN32)
#define RgDeleteFile(lpv)           (DeleteFile((lpv)))
#define RgRenameFile(lpv1, lpv2)    (MoveFile((lpv1), (lpv2)))
#define RgGetFileAttributes(lpv)    (GetFileAttributes((lpv)))
#define RgSetFileAttributes(lpv, a) (SetFileAttributes((lpv), (a)))
#ifdef USEHEAP
extern HANDLE g_RgHeap;             //  Low memory heap for testing
#define AllocBytes(cb)              ((LPVOID) HeapAlloc(g_RgHeap, 0, (cb)))
#define FreeBytes(lpv)              ((VOID) HeapFree(g_RgHeap, 0, (lpv)))
#define ReAllocBytes(lpv, cb)       ((LPVOID) HeapReAlloc(g_RgHeap, 0, (lpv), (cb)))
#define MemorySize(lpv)             ((UINT) HeapSize(g_RgHeap, 0, (lpv)))
#else
#define AllocBytes(cb)              ((LPVOID) LocalAlloc(LMEM_FIXED, (cb)))
#define FreeBytes(lpv)              ((VOID) LocalFree((HLOCAL) (lpv)))
#define ReAllocBytes(lpv, cb)       ((LPVOID) LocalReAlloc((HLOCAL) (lpv), (cb), LMEM_MOVEABLE))
#define MemorySize(lpv)             ((UINT) LocalSize((lpv)))
#endif // USEHEAP
#else
#define AllocBytes(cb)              ((LPVOID) MAKELP(GlobalAlloc(GMEM_FIXED, (cb)), 0))
#define FreeBytes(lpv)              ((VOID) GlobalFree((HGLOBAL) SELECTOROF((lpv))))
#define ReAllocBytes(lpv, cb)       ((LPVOID) MAKELP(GlobalReAlloc((HGLOBAL) SELECTOROF((lpv)), (cb), GMEM_MOVEABLE), 0))
#define MemorySize(lpv)             ((UINT) GlobalSize((HGLOBAL) SELECTOROF((lpv))))
//  WIN16's ZeroMemory/MoveMemory:  SETUPX is the only target WIN16 environment
//  and they already use _fmemset and _fmemmove, so just use their versions.
#define ZeroMemory(lpv, cb)         (_fmemset((lpv), 0, (cb)))
#define MoveMemory(lpd, lps, cb)    (_fmemmove((lpd), (lps), (cb)))
#endif // WIN16 || WIN32
#elif defined(REALMODE)
#define IsBadStringPtr(lpv, cb)     (FALSE)
#define IsBadHugeWritePtr(lpv, cb)  (FALSE)
#define IsBadHugeReadPtr(lpv, cb)   (FALSE)
#define StrCpy(lpd, lps)            (_fstrcpy((lpd), (lps)))
#define StrCpyN(lpd, lps, cb)       (_fstrcpyn((lpd), (lps), (cb)))
#define StrLen(lpstr)               (_fstrlen((lpstr)))
#define ToUpper(ch)                 ((int)(((ch>='a')&&(ch<='z'))?(ch-'a'+'A'):ch))
LPVOID INTERNAL AllocBytes(UINT);
VOID   INTERNAL FreeBytes(LPVOID);
LPVOID INTERNAL ReAllocBytes(LPVOID, UINT);
UINT   INTERNAL MemorySize(LPVOID);
VOID   INTERNAL ZeroMemory(LPVOID, UINT);
VOID   INTERNAL MoveMemory(LPVOID, const VOID FAR*, UINT);
#elif defined(VXD)
#undef IsBadStringPtr               //  Conflicts with windows.h
#undef ZeroMemory                   //  Conflicts with windows.h
#undef MoveMemory                   //  Conflicts with windows.h
BOOL    INTERNAL RgIsBadStringPtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadOptionalStringPtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadHugeWritePtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadHugeOptionalWritePtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadHugeReadPtr(const VOID FAR*, UINT);
#define IsBadStringPtr(lpv, cb)     (RgIsBadStringPtr((lpv), (cb)))
#define IsBadOptionalStringPtr(lpv, cb)     (RgIsBadOptionalStringPtr((lpv), (cb)))
#define IsBadHugeWritePtr(lpv, cb)  (RgIsBadHugeWritePtr((lpv), (cb)))
#define IsBadHugeOptionalWritePtr(lpv, cb)  (RgIsBadHugeOptionalWritePtr((lpv), (cb)))
#define IsBadHugeReadPtr(lpv, cb)   (RgIsBadHugeReadPtr((lpv), (cb)))
#define StrCpy(lpd, lps)            (_lstrcpyn((PCHAR)(lpd), (PCHAR)(lps), (ULONG)(-1)))
#define StrCpyN(lpd, lps, cb)       (_lstrcpyn((PCHAR)(lpd), (PCHAR)(lps), (ULONG)(cb)))
#define StrLen(lpstr)               (_lstrlen((PCHAR)(lpstr)))
extern  UCHAR UpperCaseTable[256];
#define ToUpper(ch)                 ((int)(UpperCaseTable[(UCHAR)(ch)]))
VOID	INTERNAL RgSetAndReleaseEvent(HANDLE hEvent);
#define RgGetCurrentThreadId()      ((DWORD)pthcbCur)
#define AllocBytes(cb)              ((LPVOID) _HeapAllocate((cb), HEAPSWAP))
#define FreeBytes(lpv)              ((VOID) _HeapFree((lpv), 0))
#define ReAllocBytes(lpv, cb)       ((LPVOID) _HeapReAllocate((lpv), (cb), HEAPSWAP))
#define MemorySize(lpv)             ((UINT) _HeapGetSize((lpv), 0))
#define AllocPages(cp)              ((LPVOID) _PageAllocate((cp), PG_SYS, 0, 0, 0, 0, NULL, 0))
#define FreePages(lpv)              ((VOID) _PageFree((ULONG) (lpv), 0))
#define ReAllocPages(lpv, cp)       ((LPVOID) _PageReAllocate((ULONG) (lpv), (cp), 0))
VOID   INTERNAL RgZeroMemory(LPVOID, UINT);
VOID   INTERNAL RgMoveMemory(LPVOID, const VOID FAR*, UINT);
#define ZeroMemory                  RgZeroMemory
#define MoveMemory                  RgMoveMemory
#else
#error Must define REALMODE, VXD, WIN16, or WIN32.
#endif

//  The IsBadHugeOptional*Ptr macros are used to validate pointers that may be
//  NULL.  By wrapping this "predicate", we can generate smaller code in some
//  environments, specifically VMM...
#if !defined(VXD)
#define IsBadOptionalStringPtr(lpv, cb) \
    (!IsNullPtr((lpv)) && IsBadStringPtr((lpv), (cb)))
#define IsBadHugeOptionalWritePtr(lpv, cb) \
    (!IsNullPtr((lpv)) && IsBadHugeWritePtr((lpv), (cb)))
#endif

//  The IsEnumIndexTooBig macro is used to check if a DWORD sized index can fit
//  into a UINT sized variable.  Only useful for validation of RegEnumKey or
//  RegEnumValue to make small code in both 16 and 32 bit environments.
#if defined(IS_32)
#define IsEnumIndexTooBig(index)    (FALSE)
#else
#define IsEnumIndexTooBig(index)    (HIWORD(index) > 0)
#endif

#if defined(VXD)
BOOL INTERNAL RgLockRegistry(VOID);
VOID INTERNAL RgUnlockRegistry(VOID);
VOID INTERNAL RgDelayFlush(VOID);
VOID INTERNAL RgYield(VOID);
#else
#define RgLockRegistry()            (TRUE)
#define RgUnlockRegistry()          (TRUE)
#define RgDelayFlush()              (TRUE)
#define RgYield()                   (TRUE)
#endif

//  Eliminate the need for #ifdef DBCS by using macros and letting the compiler
//  optimize out the DBCS code on SBCS systems.
#ifdef DBCS
#if !defined(WIN16) && !defined(WIN32)
BOOL INTERNAL RgIsDBCSLeadByte(BYTE TestChar);
#define IsDBCSLeadByte(ch)              RgIsDBCSLeadByte(ch)
#endif
#else
#define IsDBCSLeadByte(ch)              ((ch), FALSE)
#endif // DBCS

#ifdef WANT_DYNKEY_SUPPORT
//  Internally used for maintaining dynamic key information; only keeps the
//  fields that we actually need from the REG_PROVIDER structure given to
//  VMMRegCreateDynKey.
typedef struct _INTERNAL_PROVIDER {
    PQUERYHANDLER ipi_R0_1val;
    PQUERYHANDLER ipi_R0_allvals;
    LPVOID ipi_key_context;
}   INTERNAL_PROVIDER, FAR* PINTERNAL_PROVIDER;
#endif

typedef struct _KEY {
    WORD Signature;                             //  KEY_SIGNATURE
    WORD Flags; 				//  KEYF_* bits
    UINT ReferenceCount;
    LPFILE_INFO lpFileInfo;
    DWORD KeynodeIndex;
    DWORD ChildKeynodeIndex;
    WORD BlockIndex;
    BYTE KeyRecordIndex;
    BYTE PredefinedKeyIndex;
    struct _KEY FAR* lpNext;
    struct _KEY FAR* lpPrev;
    UINT LastEnumKeyIndex;
    DWORD LastEnumKeyKeynodeIndex;
#ifdef WANT_DYNKEY_SUPPORT
    PINTERNAL_PROVIDER pProvider;
#endif
}   KEY;

#define KEY_SIGNATURE               0x4B48      //  "HK"

#define KEYF_PREDEFINED             0x01        //  Represents one of HKEY_*
#define KEYF_DELETED                0x02        //
#define KEYF_INVALID                0x04        //
#define KEYF_STATIC                 0x08        //  Allocated from static pool
#define KEYF_ENUMKEYCACHED          0x10        //  LastEnumKey* values valid
#define KEYF_HIVESALLOWED           0x20        //
#define KEYF_PROVIDERHASVALUELENGTH 0x40        //  PROVIDER_KEEPS_VALUE_LENGTH
#define KEYF_NEVERDELETE            0x80        //  Reference count overflow

#define INDEX_CLASSES_ROOT          0
#define INDEX_CURRENT_USER          1
#define INDEX_LOCAL_MACHINE         2
#define INDEX_USERS                 3
#define INDEX_PERFORMANCE_DATA      4
#define INDEX_CURRENT_CONFIG        5
#define INDEX_DYN_DATA              6

//  Returns TRUE if the KEY references the root of a hive, such as
//  HKEY_LOCAL_MACHINE, HKEY_USERS, or any hive loaded by RegLoadKey.
#define IsKeyRootOfHive(hkey)       \
    ((hkey)-> KeynodeIndex == (hkey)-> lpFileInfo-> KeynodeHeader.RootIndex)

#include <regapix.h>
#include "regkylst.h"
#include "regdblk.h"
#include "regknode.h"
#include "regnckey.h"
#include "regfsio.h"
#include "regmem.h"

#ifdef VXD
extern BYTE g_RgPostCriticalInit;
extern BYTE g_RgFileAccessDisabled;
#define IsPostCriticalInit()        (g_RgPostCriticalInit)
#define IsFileAccessDisabled()      (g_RgFileAccessDisabled)
#else
#define IsPostCriticalInit()        (TRUE)
#define IsFileAccessDisabled()      (FALSE)
#endif

//  g_RgWorkBuffer: one buffer is always available of size SIZEOF_WORK_BUFFER.
//  These macros wrap access to this buffer for to verify only one routine is
//  attempting to use it at any time.
extern LPVOID g_RgWorkBuffer;
#ifdef DEBUG
extern BOOL g_RgWorkBufferBusy;
#define RgLockWorkBuffer()          \
    (ASSERT(!g_RgWorkBufferBusy), g_RgWorkBufferBusy = TRUE, (LPVOID) g_RgWorkBuffer)
#define RgUnlockWorkBuffer(lpv)     \
    (VOID) (ASSERT((lpv) == g_RgWorkBuffer), g_RgWorkBufferBusy = FALSE)
#else
#define RgLockWorkBuffer()          ((LPVOID) g_RgWorkBuffer)
#define RgUnlockWorkBuffer(lpv)
#endif
#define SIZEOF_WORK_BUFFER          (sizeof(W95KEYNODE_BLOCK))

#define IsKeyRecordFree(lpkr) \
    (((lpkr)-> DatablockAddress) == REG_NULL)

BOOL
INTERNAL
RgIsBadSubKey(
    LPCSTR lpSubKey
    );

UINT
INTERNAL
RgGetNextSubSubKey(
    LPCSTR lpSubKey,
    LPCSTR FAR* lplpSubSubKey,
    UINT FAR* lpSubSubKeyLength
    );

#define LK_OPEN                     0x0000      //  Open key only
#define LK_CREATE                   0x0001      //  Create or open key
#define LK_CREATEDYNDATA            0x0002      //  HKEY_DYN_DATA may create

int
INTERNAL
RgLookupKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphSubKey,
    UINT Flags
    );

int
INTERNAL
RgCreateOrOpenKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey,
    UINT Flags
    );

int
INTERNAL
RgLookupKeyByIndex(
    HKEY hKey,
    UINT Index,
    LPSTR lpKeyName,
    LPDWORD lpcbKeyName
    );

int
INTERNAL
RgLookupValueByName(
    HKEY hKey,
    LPCSTR lpValueName,
    LPKEY_RECORD FAR* lplpKeyRecord,
    LPVALUE_RECORD FAR* lplpValueRecord
    );

int
INTERNAL
RgLookupValueByIndex(
    HKEY hKey,
    UINT Index,
    LPVALUE_RECORD FAR* lplpValueRecord
    );

int
INTERNAL
RgCopyFromValueRecord(
    HKEY hKey,
    LPVALUE_RECORD lpValueRecord,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

int
INTERNAL
RgReAllocKeyRecord(
    HKEY hKey,
    DWORD Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgSetValue(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Type,
    LPBYTE lpData,
    UINT cbData
    );

int
INTERNAL
RgDeleteKey(
    HKEY hKey
    );

DWORD
INTERNAL
RgChecksum(
    LPVOID lpBuffer,
    UINT ByteCount
    );

DWORD
INTERNAL
RgHashString(
    LPCSTR lpString,
    UINT Length
    );

int
INTERNAL
RgStrCmpNI(
    LPCSTR lpString1,
    LPCSTR lpString2,
    UINT Length
    );

int
INTERNAL
RgCopyFileBytes(
    HFILE hSourceFile,
    LONG SourceOffset,
    HFILE hDestinationFile,
    LONG DestinationOffset,
    DWORD cbSize
    );

BOOL
INTERNAL
RgGenerateAltFileName(
    LPCSTR lpFileName,
    LPSTR lpAltFileName,
    char ExtensionChar
    );

int
INTERNAL
RgCopyFile(
    LPCSTR lpSourceFile,
    LPCSTR lpDestinationFile
    );

int
INTERNAL
RgReplaceFileInfo(
    LPFILE_INFO lpFileInfo
    );

#endif // _REGPRIV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regdebug.h ===
//
//  DEBUG.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _DEBUG_
#define _DEBUG_

#ifdef DEBUG

//  Disable the "in-line assembler precludes global optimizations" warning
//  because of debug breaks.
#pragma warning(disable:4704)

#if !defined(WIN32) || defined(_X86_)
#define TRAP()                      _asm {int 3}
#else
#define TRAP()                      DebugBreak()
#endif

VOID
INTERNALV
RgDebugPrintf(
    LPCSTR lpFormatString,
    ...
    );

VOID
INTERNAL
RgDebugAssert(
    LPCSTR lpFile,
    UINT LineNumber
    );

#define TRACE(x)    RgDebugPrintf ##x

#ifdef REGDEBUG
#define NOISE(x)    RgDebugPrintf ##x
#else
#define NOISE(x)
#endif

#define ASSERT(x)   ((x) ? (VOID) 0 : RgDebugAssert(__FILE__, __LINE__))

#define DECLARE_DEBUG_COUNT(var)    int var = 0;
#define INCREMENT_DEBUG_COUNT(var)  ((var)++)
#define DECREMENT_DEBUG_COUNT(var)  ASSERT(((var)--))

#if !defined(WIN32) || defined(_X86_)
#define DEBUG_OUT(x)                { TRACE(x); _asm {int 1}; }
#else
#define DEBUG_OUT(x)                { TRACE(x); TRAP(); }
#endif

#else
#define TRAP()
#define TRACE(x)
#define NOISE(x)
#define ASSERT(x)
#define DECLARE_DEBUG_COUNT(var)
#define INCREMENT_DEBUG_COUNT(var)
#define DECREMENT_DEBUG_COUNT(var)
#define DEBUG_OUT(x)
#endif

#endif // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regdkey.c ===
//
//  REGDKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegDeleteKey and supporting functions.
//

#include "pch.h"

//
//  RgFreeDatablockStructures
//
//  Helper routine for RgDeleteKey.  Deletes the specified datablock structures.
//  The datablock is not assumed to be locked.  We don't care about the success
//  of this routine-- in the worst case, some stuff will be orphaned in the
//  file.
//

VOID
INTERNAL
RgFreeDatablockStructures(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT KeyRecordIndex
    )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    LPKEY_RECORD lpKeyRecord;

    if (RgLockKeyRecord(lpFileInfo, BlockIndex, (BYTE) KeyRecordIndex,
        &lpKeyRecord) == ERROR_SUCCESS) {
        lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
        RgFreeKeyRecord(lpDatablockInfo, lpKeyRecord);
        RgFreeKeyRecordIndex(lpDatablockInfo, KeyRecordIndex);
        RgUnlockDatablock(lpFileInfo, BlockIndex, TRUE);
    }

}

//
//  RgDeleteKey
//
//  Worker routine for VMMRegDeleteKey.  The given key handle references a key
//  that has already been validated as "deleteable".
//

int
INTERNAL
RgDeleteKey(
    HKEY hKey
    )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    DWORD KeynodeIndex;
    LPKEYNODE lpKeynode;
    DWORD NextKeynodeIndex;
    LPKEYNODE lpNextKeynode;
    DWORD ReplacementKeynodeIndex;
    HKEY hTempKey;

    lpFileInfo = hKey-> lpFileInfo;

    //
    //  Stage one: unlink the keynode of the specified key from the keynode
    //  tree and free all associate file structures with the key.
    //

    if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, hKey-> KeynodeIndex,
        &lpKeynode)) != ERROR_SUCCESS)
        return ErrorCode;

    KeynodeIndex = lpKeynode-> ParentIndex;
    ReplacementKeynodeIndex = lpKeynode-> NextIndex;
    RgUnlockKeynode(lpFileInfo, hKey-> KeynodeIndex, FALSE);

    //  Signal any waiting notifies on the parent that this key is about to be
    //  deleted.
    //
    //  Note that we may fail below, but NT does _exactly_ the same thing in
    //  this case: doesn't care.  If we get an error and don't actually delete
    //  this key, then we'll have sent a spurious notify.
    //
    //  Note also that we don't send any notification that the key itself has
    //  been deleted.  REG_NOTIFY_CHANGE_NAME is supposed to be for subkey
    //  changes only, not changes to the key itself.  But because of the
    //  incompatible way we must deal with subkeys of the key we're about to
    //  delete, we may well end up notifying the key if it has subkeys.
    RgSignalWaitingNotifies(lpFileInfo, KeynodeIndex, REG_NOTIFY_CHANGE_NAME);

    if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
        &lpKeynode)) != ERROR_SUCCESS)
        return ErrorCode;

    //  The per-key cache that we use for RegEnumKey may be invalid, so it must
    //  be zapped.
    if (!IsNullPtr(hTempKey = RgFindOpenKeyHandle(lpFileInfo, KeynodeIndex)))
        hTempKey-> Flags &= ~KEYF_ENUMKEYCACHED;

    NextKeynodeIndex = lpKeynode-> ChildIndex;

    if (NextKeynodeIndex == hKey-> KeynodeIndex) {

        //  Update the cached child keynode index in the open handle on the
        //  parent.
        if (!IsNullPtr(hTempKey))
            hTempKey-> ChildKeynodeIndex = ReplacementKeynodeIndex;

        //  This is the parent of the keynode that we need to delete.  Replace
        //  it's "child" link.
        lpKeynode-> ChildIndex = ReplacementKeynodeIndex;

    }

    else {

        //  Loop through the siblings of the keynode we're trying to delete.
        do {

            RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
            KeynodeIndex = NextKeynodeIndex;

            if (IsNullKeynodeIndex(KeynodeIndex)) {
                DEBUG_OUT(("RgDeleteKey: couldn't find the keynode to delete\n"));
                return ERROR_BADDB;
            }

            if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
                &lpKeynode)) != ERROR_SUCCESS)
                return ErrorCode;

            NextKeynodeIndex = lpKeynode-> NextIndex;

        }   while (NextKeynodeIndex != hKey-> KeynodeIndex);

        //  This is the previous sibling of the keynode that we need to delete.
        //  Replace it's "next" link.
        lpKeynode-> NextIndex = ReplacementKeynodeIndex;

    }

    //  Unlock the updated "parent" or "next" of this keynode.
    RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

    //  Free the structures associated with the datablock.
    RgFreeDatablockStructures(lpFileInfo, hKey-> BlockIndex, hKey->
        KeyRecordIndex);

    //  Free the structures associated with the keynode tables.
    RgFreeKeynode(lpFileInfo, hKey-> KeynodeIndex);

    //  The key is definitely toast now.
    hKey-> Flags |= KEYF_DELETED;

    //
    //  Stage two: the specified key is unlinked, but any of its subkeys now
    //  have to be freed.  Errors are ignored at this point: we won't try to
    //  undo the stuff we did in stage one.  The worst thing that can happen is
    //  that some file structures are orphaned.
    //

    NextKeynodeIndex = hKey-> ChildKeynodeIndex;

    if (IsNullKeynodeIndex(NextKeynodeIndex) || RgLockInUseKeynode(lpFileInfo,
        NextKeynodeIndex, &lpNextKeynode) != ERROR_SUCCESS)
        return ERROR_SUCCESS;

    while (!IsNullKeynodeIndex(NextKeynodeIndex)) {

        KeynodeIndex = NextKeynodeIndex;
        lpKeynode = lpNextKeynode;

        //  Check if the keynode has any children.  If it does and we can lock
        //  it down, then move to it.
        NextKeynodeIndex = lpKeynode-> ChildIndex;

        if (!IsNullKeynodeIndex(NextKeynodeIndex) &&
            RgLockInUseKeynode(lpFileInfo, NextKeynodeIndex, &lpNextKeynode) ==
            ERROR_SUCCESS) {

            ASSERT(KeynodeIndex == lpNextKeynode-> ParentIndex);

            RgYield();

            //  "Burn" the link to our child, so that on the way back out of
            //  the tree, we don't end up recursing.  Plus, if we hit any errors
            //  deep in the tree deletion, the child of the current keynode
            //  could have already been toasted, so we have to zap our link to
            //  it.
            lpKeynode-> ChildIndex = REG_NULL;
            RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

            //  We've now caused a change in the subkeys of the current key.
            //  Note that we don't bother signaling notifies that are doing a
            //  subtree watch because any such notifies should have already been
            //  signaled by the above call or they've already been signaled
            //  during our recursion.  In the off chance that we have a lot of
            //  notifications registered, this will avoid a lot of unnecessary
            //  checking.
            RgSignalWaitingNotifies(lpFileInfo, KeynodeIndex,
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_NO_WATCH_SUBTREE);

            continue;

        }

        //  The keynode doesn't have any children.  Check for sibling keynodes.
        NextKeynodeIndex = lpKeynode-> NextIndex;

        if (IsNullKeynodeIndex(NextKeynodeIndex) ||
            RgLockInUseKeynode(lpFileInfo, NextKeynodeIndex, &lpNextKeynode) !=
            ERROR_SUCCESS) {

            //  The keynode doesn't have any siblings or we were unable to get
            //  at them.  Move back to the parent.
            NextKeynodeIndex = lpKeynode-> ParentIndex;

            //  If we wrapped back up to the top of the deleted branch or if we
            //  just can't access the parent keynode, then set next to REG_NULL
            //  and bail out on the next iteration.
            if ((NextKeynodeIndex == hKey-> KeynodeIndex) ||
                RgLockInUseKeynode(lpFileInfo, NextKeynodeIndex,
                &lpNextKeynode) != ERROR_SUCCESS)
                NextKeynodeIndex = REG_NULL;

        }

        //  If an open key refers to this file and keynode index, mark it as
        //  deleted.
        if (!IsNullPtr(hTempKey = RgFindOpenKeyHandle(lpFileInfo,
            KeynodeIndex)))
            hTempKey-> Flags |= KEYF_DELETED;

        //  Free the structures associated with the datablock.
        RgFreeDatablockStructures(lpFileInfo, lpKeynode-> BlockIndex,
            (BYTE) lpKeynode-> KeyRecordIndex);

        //  Free the structures associated with the keynode tables.
        RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);
        RgFreeKeynode(lpFileInfo, KeynodeIndex);

    }

    return ERROR_SUCCESS;

}

//
//  VMMRegDeleteKey
//
//  See Win32 documentation for a description of the behavior.
//
//  Although the Win32 documentation states that lpSubKey must be NULL, NT
//  actually allows this to pass through.  Win95 rejected the call, but the only
//  reason we didn't change it then was because we realized too late in the
//  product that it was different.
//

LONG
REGAPI
VMMRegDeleteKey(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{

    LONG ErrorCode;
    HKEY hSubKey = 0;

    if ((ErrorCode = VMMRegOpenKey(hKey, lpSubKey, &hSubKey)) != ERROR_SUCCESS)
        return ErrorCode;

    if (!RgLockRegistry())
        ErrorCode = ERROR_LOCK_FAILED;

    else {

        if (IsKeyRootOfHive(hSubKey) || (hSubKey-> lpFileInfo-> Flags &
            FI_READONLY))
            ErrorCode = ERROR_ACCESS_DENIED;
        else
            ErrorCode = RgDeleteKey(hSubKey);

        RgUnlockRegistry();

    }

    VMMRegCloseKey(hSubKey);

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regdval.c ===
//
//  REGDVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegDeleteValue and supporting functions.
//

#include "pch.h"

//
//  RgDeleteValueRecord
//
//  Deletes the specified VALUE_RECORD from the provided KEY_RECORD.
//

VOID
INTERNAL
RgDeleteValueRecord(
    LPKEY_RECORD lpKeyRecord,
    LPVALUE_RECORD lpValueRecord
    )
{

    UINT ValueRecordLength;
    LPBYTE lpSource;
    UINT BytesToPushDown;

    ASSERT(lpKeyRecord-> ValueCount > 0);

    ValueRecordLength = sizeof(VALUE_RECORD) + lpValueRecord-> NameLength +
        lpValueRecord-> DataLength - 1;

    ASSERT(lpKeyRecord-> RecordSize >= ValueRecordLength);

    //
    //  If this isn't the last value of this KEY_RECORD, then push down any
    //  VALUE_RECORDs after the VALUE_RECORD to delete.
    //

    if (--lpKeyRecord-> ValueCount) {

        lpSource = (LPBYTE) lpValueRecord + ValueRecordLength;

        BytesToPushDown = (UINT) ((LPBYTE) lpKeyRecord + lpKeyRecord->
            RecordSize - lpSource);

        MoveMemory((LPBYTE) lpValueRecord, lpSource, BytesToPushDown);

    }

    lpKeyRecord-> RecordSize -= ValueRecordLength;

}

//
//  VMMRegDeleteValue
//
//  See Win32 documentation of RegDeleteValue.
//

LONG
REGAPI
VMMRegDeleteValue(
    HKEY hKey,
    LPCSTR lpValueName
    )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;

    if (IsBadOptionalStringPtr(lpValueName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {

        if ((ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
            &lpValueRecord)) == ERROR_SUCCESS) {

            if ((hKey-> PredefinedKeyIndex == INDEX_DYN_DATA) || (hKey->
                lpFileInfo-> Flags & FI_READONLY))
                ErrorCode = ERROR_ACCESS_DENIED;
            else {
                RgDeleteValueRecord(lpKeyRecord, lpValueRecord);
                RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                    REG_NOTIFY_CHANGE_LAST_SET);
            }

            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, TRUE);

        }

    }

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regdykey.c ===
//
//  REGDYKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegCreateDynKey and supporting functions.
//

#include "pch.h"

#ifdef WANT_DYNKEY_SUPPORT

    #ifdef VXD
        #pragma VxD_RARE_CODE_SEG
    #endif

//
//  VMMRegCreateDynKey
//
//  See VMM DDK of _RegCreateDynKey.
//

LONG
REGAPI
VMMRegCreateDynKey(
                  LPCSTR lpKeyName,
                  LPVOID KeyContext,
                  PPROVIDER pProvider,
                  PPVALUE pValueList,
                  DWORD ValueCount,
                  LPHKEY lphKey
                  )
{

    LONG ErrorCode;
    HKEY hKey;
    PINTERNAL_PROVIDER pProviderCopy;
    PPVALUE pCurrentValue;

    if (IsBadHugeReadPtr(pProvider, sizeof(REG_PROVIDER)) ||
        (IsNullPtr(pProvider-> pi_R0_1val) &&
         IsNullPtr(pProvider-> pi_R0_allvals)) ||
        IsBadHugeReadPtr(pValueList, sizeof(PVALUE) * ValueCount))
        return ERROR_INVALID_PARAMETER;

    if ((ErrorCode = RgCreateOrOpenKey(HKEY_DYN_DATA, lpKeyName, &hKey,
                                       LK_CREATE | LK_CREATEDYNDATA)) != ERROR_SUCCESS)
        return ErrorCode;

    if (!RgLockRegistry())
        ErrorCode = ERROR_LOCK_FAILED;

    else {

        pProviderCopy = RgSmAllocMemory(sizeof(INTERNAL_PROVIDER));

        if (IsNullPtr(pProviderCopy))
            ErrorCode = ERROR_OUTOFMEMORY;

        else {

            //  ErrorCode = ERROR_SUCCESS;  //  Must be true if we're here...

            hKey-> pProvider = pProviderCopy;

            //  If no "get single" callback was provided, we can just use the
            //  "get atomic" callback.
            if (IsNullPtr(pProvider-> pi_R0_1val))
                pProviderCopy-> ipi_R0_1val = pProvider-> pi_R0_allvals;
            else
                pProviderCopy-> ipi_R0_1val = pProvider-> pi_R0_1val;

            pProviderCopy-> ipi_R0_allvals = pProvider-> pi_R0_allvals;
            pProviderCopy-> ipi_key_context = KeyContext;

            //  No point in keeping a whole DWORD for one bit when we can fit
            //  it inside the main key structure.
            if (pProvider-> pi_flags & PROVIDER_KEEPS_VALUE_LENGTH)
                hKey-> Flags |= KEYF_PROVIDERHASVALUELENGTH;

            //  Loop over all the values and store each name in the registry
            //  with a partial PVALUE record as the value's data.
            for (pCurrentValue = pValueList; ValueCount > 0; ValueCount--,
                pCurrentValue++) {

                if (IsBadStringPtr(pCurrentValue-> pv_valuename, (UINT) -1)) {
                    ErrorCode = ERROR_INVALID_PARAMETER;
                    break;
                }

                //  Skip storing the pv_valuename field.
                if ((ErrorCode = RgSetValue(hKey, pCurrentValue-> pv_valuename,
                                            REG_BINARY, (LPBYTE) &(pCurrentValue-> pv_valuelen),
                                            sizeof(PVALUE) - FIELD_OFFSET(PVALUE, pv_valuename))) !=
                    ERROR_SUCCESS) {
                    TRAP();
                    break;
                }

            }

        }

        RgUnlockRegistry();

    }

    //  Win95 difference: on an error, don't modify lphKey and close the key
    //  created above.
    if (ErrorCode == ERROR_SUCCESS)
        *lphKey = hKey;
    else
        VMMRegCloseKey(hKey);

    return ErrorCode;

}

#endif // WANT_DYNKEY_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regeval.c ===
//
//  REGEVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegEnumValue and supporting functions.
//

#include "pch.h"

//
//  RgLookupValueByIndex
//
//  Searches for the value with the specified index and returns a pointer to its
//  VALUE_RECORD.
//

int
INTERNAL
RgLookupValueByIndex(
                    HKEY hKey,
                    UINT Index,
                    LPVALUE_RECORD FAR* lplpValueRecord
                    )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;

    //  Handle Win95 registries that don't have a key record for the root key.
    if (IsNullBlockIndex(hKey-> BlockIndex))
        return ERROR_NO_MORE_ITEMS;

    if ((ErrorCode = RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex,
                                     hKey-> KeyRecordIndex, &lpKeyRecord)) == ERROR_SUCCESS) {

        if (Index >= lpKeyRecord-> ValueCount) {
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);
            ErrorCode = ERROR_NO_MORE_ITEMS;
        }

        else {

            lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpKeyRecord-> Name +
                                              lpKeyRecord-> NameLength + lpKeyRecord-> ClassLength);

            while (Index--) {
                lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpValueRecord->
                                                  Name + lpValueRecord-> NameLength + lpValueRecord->
                                                  DataLength);
            }

            *lplpValueRecord = lpValueRecord;
            ErrorCode = ERROR_SUCCESS;

        }

    }

    return ErrorCode;

}

//
//  VMMRegEnumValue
//
//  See Win32 documentation for a description of the behavior.
//

LONG
REGAPI
VMMRegEnumValue(
               HKEY hKey,
               DWORD Index,
               LPSTR lpValueName,
               LPDWORD lpcbValueName,
               LPDWORD lpReserved,
               LPDWORD lpType,
               LPBYTE lpData,
               LPDWORD lpcbData
               )
{

    int ErrorCode;
    LPVALUE_RECORD lpValueRecord;

    if (IsBadHugeWritePtr(lpcbValueName, sizeof(DWORD)) ||
        IsBadHugeWritePtr(lpValueName, *lpcbValueName) ||
        (IsBadHugeOptionalWritePtr(lpType, sizeof(DWORD))))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeOptionalWritePtr(lpType, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (IsNullPtr(lpcbData)) {
        if (!IsNullPtr(lpData))
            return ERROR_INVALID_PARAMETER;
    }

    else {
        //  Win95 compatibility: don't validate lpData is of size *lpcbData.
        //  Instead of validating the entire buffer, we'll validate just the
        //  required buffer length in RgCopyFromValueRecord.
        if (IsBadHugeWritePtr(lpcbData, sizeof(DWORD)))
            return ERROR_INVALID_PARAMETER;
    }

    if (IsEnumIndexTooBig(Index))
        return ERROR_NO_MORE_ITEMS;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {

        if ((ErrorCode = RgLookupValueByIndex(hKey, (UINT) Index,
                                              &lpValueRecord)) == ERROR_SUCCESS) {
            ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, lpValueName,
                                              lpcbValueName, lpType, lpData, lpcbData);
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);
        }

    }

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(lpReserved);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regffmt.h ===
//
//  REGFFMT.H
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Defines the physical format of a Windows VMM registry file.
//

#ifndef _REGFFMT_
#define _REGFFMT_

#ifdef WIN32
#include <pshpack1.h>
#else
#pragma pack(1)
#endif

#define REG_NULL                    0xFFFFFFFF

typedef struct _FILE_HEADER {
    DWORD Signature;                            //  FH_SIGNATURE
    DWORD Version;                              //  FH_VERSION_*
    DWORD Size;                                 //  of file header, all keynodes
    DWORD Checksum;                             //  of file header
    WORD BlockCount;
    DWORD Flags;                                //  FHF_* bits
    WORD Type;                                  //  FHT_* constant
    BYTE Reserved[8];
}   FILE_HEADER, UNALIGNED FAR* LPFILE_HEADER;

#define FH_SIGNATURE                0x47455243  //  "CREG"
#define FH_VERSION10                0x00010000  //  Win95 compatible
#define FH_VERSION20                0x00020000  //  Supports compact keynodes

#define FHF_DIRTY                   0x00000001  //  Must rewrite to disk
#define FHF_RESERVED1               0x00000002  //  Dead bit from VERY old files
#define FHF_HASCHECKSUM             0x00000004  //  Checksum member is valid

#define FHT_PRIMARY                 0x0001      //  System hives
#define FHT_SECONDARY               0x0080      //  User/application hives

typedef struct _KEYNODE_HEADER {
    DWORD Signature;                            //  KH_SIGNATURE
    DWORD FileKnSize;				//  of entire keynode table inc header
    DWORD RootIndex;
    DWORD FirstFreeIndex;
    DWORD Flags;                                //  KHF_* bits
    DWORD Checksum;                             //  of entire keynode table
    BYTE Reserved[8];
}   KEYNODE_HEADER, UNALIGNED FAR* LPKEYNODE_HEADER;

#define KH_SIGNATURE                0x4E4B4752  //  "RGKN"

#define KHF_DIRTY                   0x00000001  //  Win95: Must rewrite to disk
#define KHF_EXTENDED                0x00000002  //  Win95: Table has grown
#define KHF_HASCHECKSUM             0x00000004  //  Win95: Checksum is valid
#define KHF_NEWHASH                 0x00000008  //  Alway expect

typedef struct _VERSION20_HEADER_PAGE {
    union {
        struct {
            FILE_HEADER FileHeader;
            KEYNODE_HEADER KeynodeHeader;
        };
        struct {
            BYTE Page[4096];
        };
    };
}   VERSION20_HEADER_PAGE, UNALIGNED FAR* LPVERSION20_HEADER_PAGE;

typedef struct _W95KEYNODE {
    DWORD W95State;				//  KNS_* constant
    union {
        //  State == KNS_USED
        struct {
	    DWORD W95Hash;
            DWORD W95Reserved1;
	    DWORD W95ParentOffset;
	    DWORD W95ChildOffset;
	    DWORD W95NextOffset;
	    DWORD W95DatablockAddress;
        };
        //  State == KNS_FREE or KNS_ALLFREE
        struct {
	    DWORD W95FreeRecordSize;
	    DWORD W95NextFreeOffset;
	    DWORD W95Reserved2[4];
        };
    };
}   W95KEYNODE, UNALIGNED FAR* LPW95KEYNODE;

#define KNS_USED                    0x00000000  //  Keynode
#define KNS_FREE                    0x80000000
#define KNS_ALLFREE                 0xFFFFFFFF

typedef struct _KEYNODE {
    DWORD NextIndex:24,
          Flags:8;
    union {
        //  Flags & KNF_INUSE
	struct {
	    DWORD ChildIndex:24,
		  BinNumber:8;
	    DWORD ParentIndex:24,
                  KeyRecordIndex:8;
            WORD  BlockIndex;
	    WORD  Hash;
        };
        //  !(Flags & KNF_INUSE)
	struct {
            DWORD Reserved;
            DWORD FreeRecordSize;
        };
    };
}   KEYNODE, FAR* LPKEYNODE;

#define KNF_INUSE	0x01		    // Block is in use

#define IsNullKeynodeIndex(kni)     ((kni) >= 0x00FFFFFF)

typedef struct _DATABLOCK_HEADER {
    DWORD Signature;                            //  DH_SIGNATURE
    DWORD BlockSize;
    DWORD FreeBytes;
    WORD Flags;                                 //  DHF_* bits
    WORD BlockIndex;
    DWORD FirstFreeOffset;
    WORD MaxAllocatedIndex;
    WORD FirstFreeIndex;
    DWORD Reserved;
    DWORD Checksum;                             //  of entire datablock
}   DATABLOCK_HEADER, UNALIGNED FAR* LPDATABLOCK_HEADER;

#define DH_SIGNATURE                0x42444752  //  "RGDB"

#define DHF_DIRTY                   0x0001      //  Must rewrite to disk
#define DHF_EXTENDED                0x0002      //  Datablock size has grown
#define DHF_HASCHECKSUM             0x0004      //  Checksum member is valid
#define DHF_HASBLOCKNUMBERS         0x0008      //  Keys contain block numbers

#define DATABLOCKS_PER_FILE         0xFFFE      //  0xFFFF is 'null' block index

//  Arbitrary size pulled from the old registry code.  Oh well, makes it
//  convenient when we do 16-bit math to extend a datablock by 4K.
#define MAXIMUM_DATABLOCK_SIZE      ((DWORD)(60L*1024L))

//  Win95 registry files may not always have a key record for the root key of
//  a file.
#define NULL_BLOCK_INDEX            0xFFFF
#define IsNullBlockIndex(bi)        ((bi) == NULL_BLOCK_INDEX)

typedef struct _KEY_RECORD {
    DWORD AllocatedSize;
    union {
        DWORD DatablockAddress;
        struct {
            WORD KeyRecordIndex;
            WORD BlockIndex;
        };
    };
    DWORD RecordSize;
    WORD NameLength;
    WORD ValueCount;
    WORD ClassLength;
    WORD Reserved;
    char Name[ANYSIZE_ARRAY];
}   KEY_RECORD, UNALIGNED FAR* LPKEY_RECORD;

typedef struct _FREEKEY_RECORD {
    DWORD AllocatedSize;
    DWORD DatablockAddress;                     //  REG_NULL for free records
    DWORD NextFreeOffset;
}   FREEKEY_RECORD, UNALIGNED FAR* LPFREEKEY_RECORD;

typedef struct _VALUE_RECORD {
    DWORD DataType;
    DWORD Reserved;
    WORD NameLength;
    WORD DataLength;
    char Name[ANYSIZE_ARRAY];
}   VALUE_RECORD, UNALIGNED FAR* LPVALUE_RECORD;

#define KEY_RECORDS_PER_DATABLOCK   255

//  Arbitrary size pulled from the old registry code.  Oh well, makes it
//  convenient when we do 16-bit math to extend a datablock by 4K.
#define MAXIMUM_KEY_RECORD_SIZE     \
    ((DWORD)(MAXIMUM_DATABLOCK_SIZE-sizeof(DATABLOCK_HEADER)))

#ifdef WIN32
#include <poppack.h>
#else
#pragma pack()
#endif

#endif // _REGFFMT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regfkey.c ===
//
//  REGFKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegFlushKey and supporting functions.
//

#include "pch.h"

//  Magic HKEY used by Setup to disable disk I/O for the duration of this
//  Windows session (you must restart to re-enable disk I/O).  This is done
//  just before the new SYSTEM.DAT and USER.DAT are copied to their final
//  destination.
#define HKEY_DISABLE_REG            (HKEY) 0x484A574D

//  Magic HKEY used by CONFIGMG to force a flush of the registry before we've
//  received our normal post-critical init call.
#define HKEY_CRITICAL_FLUSH         (HKEY) 0x5350574D

//
//  VMMRegFlushKey
//

LONG
REGAPI
VMMRegFlushKey(
    HKEY hKey
    )
{

    int ErrorCode;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

#ifdef VXD
    //  Set the g_RgFileAccessDisabled flag so that all create or open file
    //  calls will be failed.  The backing stores for our files are about to
    //  be changed, so there's no file for us to go to.
    if (hKey == HKEY_DISABLE_REG) {
        g_RgFileAccessDisabled = TRUE;
        ErrorCode = ERROR_SUCCESS;
        goto ReturnErrorCode;
    }

    //  Set the g_RgPostCriticalInit flag so that all I/O calls will go to disk
    //  instead of the XMS cache.  The XMS cache will be freed when/if the
    //  normal post critical init routine is called, but we should only be
    //  getting this call when we're about to die, so it doesn't really matter.
    if (hKey == HKEY_CRITICAL_FLUSH) {
        g_RgPostCriticalInit = TRUE;
        hKey = HKEY_LOCAL_MACHINE;
    }
#endif

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgFlushFileInfo(hKey-> lpFileInfo);

#ifdef VXD
ReturnErrorCode:
#endif
    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regekey.c ===
//
//  REGEKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegEnumKey and supporting functions.
//

#include "pch.h"

//
//  RgLookupKeyByIndex
//
//  lpKeyName, points to a buffer that receives the name of the subkey,
//      including the null terminator.  May be NULL.
//  lpcbKeyName, on entry, specifies the size in characters of the buffer
//      pointed to be lpKeyName, and on return, specifies the size of the
//      indexed subkey.  May not be NULL.
//

int
INTERNAL
RgLookupKeyByIndex(
    HKEY hKey,
    UINT Index,
    LPSTR lpKeyName,
    LPDWORD lpcbKeyName
    )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    UINT KeysToSkip;
    DWORD KeynodeIndex;
    DWORD TempOffset;
    LPKEYNODE lpKeynode;
    LPKEY_RECORD lpKeyRecord;
#ifdef WANT_HIVE_SUPPORT
    LPHIVE_INFO lpHiveInfo;
#endif

    lpFileInfo = hKey-> lpFileInfo;
    KeysToSkip = Index;

    //
    //  Check if we've cached the keynode index of the last key index
    //  (confusing?) from a previous call to this function.  If so, then we can
    //  skip ahead a bit and avoid touching a bunch of keynode pages.
    //

    if ((hKey-> Flags & KEYF_ENUMKEYCACHED) && (Index >=
        hKey-> LastEnumKeyIndex)) {
        KeysToSkip -= hKey-> LastEnumKeyIndex;
        KeynodeIndex = hKey-> LastEnumKeyKeynodeIndex;
    }

    else
        KeynodeIndex = hKey-> ChildKeynodeIndex;

    //
    //  Loop over the child keys of this key until we find our index or run out
    //  of children.
    //

    while (!IsNullKeynodeIndex(KeynodeIndex)) {

        if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
            &lpKeynode)) != ERROR_SUCCESS)
            return ErrorCode;

        ASSERT(hKey-> KeynodeIndex == lpKeynode-> ParentIndex);

        if (KeysToSkip == 0) {

            if ((ErrorCode = RgLockKeyRecord(lpFileInfo, lpKeynode-> BlockIndex,
                (BYTE) lpKeynode-> KeyRecordIndex, &lpKeyRecord)) ==
                ERROR_SUCCESS) {

                if (!IsNullPtr(lpKeyName)) {

                    if (*lpcbKeyName <= lpKeyRecord-> NameLength)
                        ErrorCode = ERROR_MORE_DATA;

                    else {
                        MoveMemory(lpKeyName, lpKeyRecord-> Name, lpKeyRecord->
                            NameLength);
                        lpKeyName[lpKeyRecord-> NameLength] = '\0';
                    }

                }

                //  Does not include terminating null.
                *lpcbKeyName = lpKeyRecord-> NameLength;

                RgUnlockDatablock(lpFileInfo, lpKeynode-> BlockIndex, FALSE);

            }

            RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);

            //  Cache our current position because the caller is likely to turn
            //  around and ask for the next index.
            hKey-> LastEnumKeyIndex = Index;
            hKey-> LastEnumKeyKeynodeIndex = KeynodeIndex;
            hKey-> Flags |= KEYF_ENUMKEYCACHED;

            return ErrorCode;

        }

        TempOffset = lpKeynode-> NextIndex;
        RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
        KeynodeIndex = TempOffset;

        KeysToSkip--;

    }

#ifdef WANT_HIVE_SUPPORT
    //
    //  Loop over the hives of this key until we find our index or run out of
    //  hives.
    //

    if (hKey-> Flags & KEYF_HIVESALLOWED) {

        lpHiveInfo = hKey-> lpFileInfo-> lpHiveInfoList;

        while (!IsNullPtr(lpHiveInfo)) {

            if (KeysToSkip == 0) {

                ErrorCode = ERROR_SUCCESS;

                if (!IsNullPtr(lpKeyName)) {

                    if (*lpcbKeyName <= lpHiveInfo-> NameLength)
                        ErrorCode = ERROR_MORE_DATA;

                    else {
                        MoveMemory(lpKeyName, lpHiveInfo-> Name, lpHiveInfo->
                            NameLength);
                        lpKeyName[lpHiveInfo-> NameLength] = '\0';
                    }

                }

                //  Does not include terminating null.
                *lpcbKeyName = lpHiveInfo-> NameLength;

                //  We don't worry about the enum key cache if we find a
                //  hit in this code.  This is a rare case and already the cache
                //  that we do have is much better then Win95.

                return ErrorCode;

            }

            lpHiveInfo = lpHiveInfo-> lpNextHiveInfo;
            KeysToSkip--;

        }

    }
#endif

    return ERROR_NO_MORE_ITEMS;

}

//
//  VMMRegEnumKey
//
//  See Win32 documentation for a description of the behavior.
//

LONG
REGAPI
VMMRegEnumKey(
    HKEY hKey,
    DWORD Index,
    LPSTR lpKeyName,
    DWORD cbKeyName
    )
{

    int ErrorCode;

    if (IsBadHugeWritePtr(lpKeyName, cbKeyName))
        return ERROR_INVALID_PARAMETER;

    if (IsEnumIndexTooBig(Index))
        return ERROR_NO_MORE_ITEMS;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgLookupKeyByIndex(hKey, (UINT) Index, lpKeyName,
            &cbKeyName);

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regfinfo.c ===
//
//  REGFINFO.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

LPFILE_INFO g_RgFileInfoList = NULL;

const char g_RgDotBackslashPath[] = ".\\";

#ifdef VXD
    #pragma VxD_RARE_CODE_SEG
#endif

//
//  RgCreateFileInfoNew
//
//  If CFIN_VOLATILE is specified, then we skip trying to create the backing
//  store for the FILE_INFO.  lpFileName should point at a null byte so we can
//  initialize the FILE_INFO properly.
//
//  CFIN_PRIMARY and CFIN_SECONDARY are used to determine the FHT_* constant
//  to put in the file header.
//

int
INTERNAL
RgCreateFileInfoNew(
                   LPFILE_INFO FAR* lplpFileInfo,
                   LPCSTR lpFileName,
                   UINT Flags
                   )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    HFILE hFile;
    LPKEYNODE lpKeynode;
    DWORD KeynodeIndex;

    if (IsNullPtr((lpFileInfo = (LPFILE_INFO)
                   RgSmAllocMemory(sizeof(FILE_INFO) + StrLen(lpFileName))))) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ErrorReturn;
    }

    ZeroMemory(lpFileInfo, sizeof(FILE_INFO));
    StrCpy(lpFileInfo-> FileName, lpFileName);

    //  For volatile FILE_INFOs, we obviously don't need to create the backing
    //  store.
    if (!(Flags & CFIN_VOLATILE)) {

        //  Attempt to the create the given filename.
        if ((hFile = RgCreateFile(lpFileName)) == HFILE_ERROR) {
            ErrorCode = ERROR_REGISTRY_IO_FAILED;
            goto ErrorDestroyFileInfo;
        }

        RgCloseFile(hFile);

    }

    lpFileInfo-> Flags = FI_DIRTY | FI_KEYNODEDIRTY;
    //  lpFileInfo-> lpHiveInfoList = NULL;
    //  lpFileInfo-> lpParentFileInfo = NULL;
    //  lpFileInfo-> lpNotifyChangeList = NULL;
    //  lpFileInfo-> lpKeynodeBlockInfo = NULL;
    //  lpFileInfo-> NumKeynodeBlocks = 0;
    //  lpFileInfo-> NumAllocKNBlocks = 0;
    //  lpFileInfo-> CurTotalKnSize = 0;
    //  lpFileInfo-> lpDatablockInfo = NULL;
    //  lpFileInfo-> DatablockInfoAllocCount = 0;

    if (Flags & CFIN_VOLATILE)
        lpFileInfo-> Flags |= FI_VOLATILE;

    //  Initialize the file header.
    lpFileInfo-> FileHeader.Signature = FH_SIGNATURE;
    //  If we're using compact keynodes, up the version number to make sure
    //  Win95 doesn't try to load this hive.
    if (Flags & CFIN_VERSION20) {
        lpFileInfo-> FileHeader.Version = FH_VERSION20;
        lpFileInfo-> Flags |= FI_VERSION20;
    } else {
        lpFileInfo-> FileHeader.Version = FH_VERSION10;
    }
    //  lpFileInfo-> FileHeader.Size = 0;
    //  lpFileInfo-> FileHeader.Checksum = 0;
    //  lpFileInfo-> FileHeader.BlockCount = 0;
    lpFileInfo-> FileHeader.Flags = FHF_DIRTY;
    lpFileInfo-> FileHeader.Type = ((Flags & CFIN_SECONDARY) ? FHT_SECONDARY :
                                    FHT_PRIMARY);

    //  Initialize the keynode header.
    lpFileInfo-> KeynodeHeader.Signature = KH_SIGNATURE;
    //  lpFileInfo-> KeynodeHeader.FileKnSize = 0;
    lpFileInfo-> KeynodeHeader.RootIndex = REG_NULL;
    lpFileInfo-> KeynodeHeader.FirstFreeIndex = REG_NULL;
    lpFileInfo-> KeynodeHeader.Flags = KHF_DIRTY | KHF_NEWHASH;
    //  lpFileInfo-> KeynodeHeader.Checksum = 0;

    //  Init the keynode data structures.
    if ((ErrorCode = RgInitKeynodeInfo(lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorDeleteFile;

    //  For uncompacted keynode tables, the keynode table now includes at least
    //  the header itself.
    if (!(lpFileInfo-> Flags & FI_VERSION20))
        lpFileInfo-> CurTotalKnSize = sizeof(KEYNODE_HEADER);

    //  Init the datablock data structures.
    if ((ErrorCode = RgInitDatablockInfo(lpFileInfo, HFILE_ERROR)) !=
        ERROR_SUCCESS)
        goto ErrorDeleteFile;

    //  Allocate the keynode for the root of the file.
    if ((ErrorCode = RgAllocKeynode(lpFileInfo, &KeynodeIndex, &lpKeynode)) !=
        ERROR_SUCCESS)
        goto ErrorDeleteFile;

    lpFileInfo-> KeynodeHeader.RootIndex = KeynodeIndex;

    lpKeynode-> ParentIndex = REG_NULL;
    lpKeynode-> NextIndex = REG_NULL;
    lpKeynode-> ChildIndex = REG_NULL;
    lpKeynode-> Hash = 0;
    //  Note that we don't allocate a key record for this root keynode.  Win95
    //  didn't do this either, so we already must handle this case in code that
    //  needs a key record.  Our code is smaller if we just don't allocate this
    //  key record which is rarely ever used anyway...
    lpKeynode-> BlockIndex = NULL_BLOCK_INDEX;

    RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

    if ((ErrorCode = RgFlushFileInfo(lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorDeleteFile;

    //  Link this FILE_INFO into the global file info list.
    lpFileInfo-> lpNextFileInfo = g_RgFileInfoList;
    g_RgFileInfoList = lpFileInfo;

    *lplpFileInfo = lpFileInfo;
    return ERROR_SUCCESS;

    ErrorDeleteFile:
    if (!(Flags & CFIN_VOLATILE))
        RgDeleteFile(lpFileName);

    ErrorDestroyFileInfo:
    RgDestroyFileInfo(lpFileInfo);

    ErrorReturn:
    TRACE(("RgCreateFileInfoNew: returning %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgCreateFileInfoExisting
//

int
INTERNAL
RgCreateFileInfoExisting(
                        LPFILE_INFO FAR* lplpFileInfo,
                        LPCSTR lpFileName
                        )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    HFILE hFile;
    DWORD FileAttributes;

    if (IsNullPtr((lpFileInfo = (LPFILE_INFO)
                   RgSmAllocMemory(sizeof(FILE_INFO) + StrLen(lpFileName))))) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ErrorReturn;
    }

    ZeroMemory(lpFileInfo, sizeof(FILE_INFO));
    StrCpy(lpFileInfo-> FileName, lpFileName);

    //  lpFileInfo-> Flags = 0;
    //  lpFileInfo-> lpHiveInfoList = NULL;
    //  lpFileInfo-> lpParentFileInfo = NULL;
    //  lpFileInfo-> lpNotifyChangeList = NULL;
    //  lpFileInfo-> lpKeynodeBlockInfo = NULL;
    //  lpFileInfo-> NumKeynodeBlocks = 0;
    //  lpFileInfo-> NumAllocKNBlocks = 0;
    //  lpFileInfo-> CurTotalKnSize = 0;
    //  lpFileInfo-> lpDatablockInfo = NULL;
    //  lpFileInfo-> DatablockInfoAllocCount = 0;

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    //  Attempt to the open the given filename.
    if ((hFile = RgOpenFile(lpFileName, OF_READ)) == HFILE_ERROR)
        goto ErrorDestroyFileInfo;

    //  Read and validate the file header.
    if (!RgReadFile(hFile, &lpFileInfo-> FileHeader, sizeof(FILE_HEADER)))
        goto ErrorCloseFile;

    if (!RgIsValidFileHeader(&lpFileInfo-> FileHeader)) {
        ErrorCode = ERROR_BADDB;
        goto ErrorCloseFile;
    }

    lpFileInfo-> FileHeader.Flags &= ~(FHF_DIRTY | FHF_HASCHECKSUM);

    if (lpFileInfo-> FileHeader.Version == FH_VERSION20)
        lpFileInfo-> Flags |= FI_VERSION20;

    //  Read and validate the keynode header.
    if (!RgReadFile(hFile, &lpFileInfo-> KeynodeHeader,
                    sizeof(KEYNODE_HEADER)))
        goto ErrorCloseFile;

    if (lpFileInfo-> KeynodeHeader.Signature != KH_SIGNATURE) {
        ErrorCode = ERROR_BADDB;
        goto ErrorCloseFile;
    }

    //  Init the keynode data structures.
    if ((ErrorCode = RgInitKeynodeInfo(lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorCloseFile;

    //  Init the datablock data structures.
    if ((ErrorCode = RgInitDatablockInfo(lpFileInfo, hFile)) != ERROR_SUCCESS)
        goto ErrorCloseFile;

    RgCloseFile(hFile);

    //  Check if the file can be written to.  We did this in Win95 by getting
    //  the current file attributes and then slamming them back on the file.  If
    //  this failed, then we treated the file as read-only (such as hive from
    //  a read-only network share).  This seems to work, so why change?
    if ((FileAttributes = RgGetFileAttributes(lpFileName)) != (DWORD) -1) {
        if (!RgSetFileAttributes(lpFileName, (UINT) FileAttributes))
            lpFileInfo-> Flags |= FI_READONLY;
    }

    //  Link this FILE_INFO into the global file info list.
    lpFileInfo-> lpNextFileInfo = g_RgFileInfoList;
    g_RgFileInfoList = lpFileInfo;

    *lplpFileInfo = lpFileInfo;
    return ERROR_SUCCESS;

    ErrorCloseFile:
    RgCloseFile(hFile);

    ErrorDestroyFileInfo:
    RgDestroyFileInfo(lpFileInfo);

    ErrorReturn:
    TRACE(("RgCreateFileInfoExisting: returning %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgIsValidFileHeader
//
//  Returns TRUE if lpFileHeader is a valid FILE_HEADER structure.
//

BOOL
INTERNAL
RgIsValidFileHeader(
                   LPFILE_HEADER lpFileHeader
                   )
{

    if (lpFileHeader-> Signature != FH_SIGNATURE ||
        (lpFileHeader-> Version != FH_VERSION10 &&
         lpFileHeader-> Version != FH_VERSION20))
        return FALSE;

    if (lpFileHeader-> Flags & FHF_HASCHECKSUM &&
        RgChecksum(lpFileHeader, sizeof(FILE_HEADER)) != 0)
        return FALSE;

    return TRUE;

}

//
//  RgDestroyFileInfo
//
//  Unlinks the FILE_INFO from the global list, if appropriate, and frees all
//  memory associated with the structure including the structure itself.
//
//  If the FILE_INFO is dirty, then all changes will be lost.  Call
//  RgFlushFileInfo first if the file should be flushed.
//

int
INTERNAL
RgDestroyFileInfo(
                 LPFILE_INFO lpFileInfo
                 )
{

    LPFILE_INFO lpPrevFileInfo;
    LPFILE_INFO lpCurrFileInfo;
#ifdef WANT_HIVE_SUPPORT
    LPHIVE_INFO lpHiveInfo;
    LPHIVE_INFO lpTempHiveInfo;
#endif
#ifdef WANT_NOTIFY_CHANGE_SUPPORT
    LPNOTIFY_CHANGE lpNotifyChange;
    LPNOTIFY_CHANGE lpTempNotifyChange;
#endif
    UINT Counter;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    LPDATABLOCK_INFO lpDatablockInfo;

    ASSERT(!IsNullPtr(lpFileInfo));

    RgInvalidateKeyHandles(lpFileInfo, (UINT) -1);

    //
    //  Unlink this FILE_INFO from the the file info list.  Note that the
    //  structure may not have actually been linked in if we're called as a
    //  result of an error in one of the create file info functions.
    //

    lpPrevFileInfo = NULL;
    lpCurrFileInfo = g_RgFileInfoList;

    while (!IsNullPtr(lpCurrFileInfo)) {

        if (lpCurrFileInfo == lpFileInfo) {
            if (IsNullPtr(lpPrevFileInfo))
                g_RgFileInfoList = lpCurrFileInfo-> lpNextFileInfo;
            else
                lpPrevFileInfo-> lpNextFileInfo = lpCurrFileInfo->
                                                  lpNextFileInfo;
            break;
        }

        lpPrevFileInfo = lpCurrFileInfo;
        lpCurrFileInfo = lpCurrFileInfo-> lpNextFileInfo;

    }

#ifdef WANT_HIVE_SUPPORT
    //
    //  Delete all of the hives connected to this FILE_INFO.
    //

    lpHiveInfo = lpFileInfo-> lpHiveInfoList;

    while (!IsNullPtr(lpHiveInfo)) {
        RgDestroyFileInfo(lpHiveInfo-> lpFileInfo);
        lpTempHiveInfo = lpHiveInfo;
        lpHiveInfo = lpHiveInfo-> lpNextHiveInfo;
        RgSmFreeMemory(lpTempHiveInfo);
    }
#endif

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
    //
    //  Signal and free all of the change notifications.  On NT, a hive cannot
    //  be unloaded if there are any open handles referencing it.  Change
    //  notifications are cleaned up when a key handle is closed.  So this
    //  cleanup is unique to our registry code.
    //

    lpNotifyChange = lpFileInfo-> lpNotifyChangeList;

    while (!IsNullPtr(lpNotifyChange)) {
        RgSetAndReleaseEvent(lpNotifyChange-> hEvent);
        lpTempNotifyChange = lpNotifyChange;
        lpNotifyChange = lpNotifyChange-> lpNextNotifyChange;
        RgSmFreeMemory(lpTempNotifyChange);
    }
#endif

    //
    //  Free all memory associated with the keynode table.
    //

    if (!IsNullPtr(lpFileInfo-> lpKeynodeBlockInfo)) {

        for (Counter = 0, lpKeynodeBlockInfo = lpFileInfo-> lpKeynodeBlockInfo;
            Counter < lpFileInfo-> KeynodeBlockCount; Counter++,
            lpKeynodeBlockInfo++) {
            if (!IsNullPtr(lpKeynodeBlockInfo-> lpKeynodeBlock))
                RgFreeMemory(lpKeynodeBlockInfo-> lpKeynodeBlock);
        }

        RgSmFreeMemory(lpFileInfo-> lpKeynodeBlockInfo);

    }

    //
    //  Free all memory associated with the datablocks.
    //

    if (!IsNullPtr(lpFileInfo-> lpDatablockInfo)) {

        for (Counter = 0, lpDatablockInfo = lpFileInfo-> lpDatablockInfo;
            Counter < lpFileInfo-> FileHeader.BlockCount; Counter++,
            lpDatablockInfo++)
            RgFreeDatablockInfoBuffers(lpDatablockInfo);

        RgSmFreeMemory(lpFileInfo-> lpDatablockInfo);

    }

    //
    //  Free the FILE_INFO itself.
    //

    RgSmFreeMemory(lpFileInfo);

    return ERROR_SUCCESS;

}

#ifdef VXD
    #pragma VxD_PAGEABLE_CODE_SEG
#endif

//
//  RgFlushFileInfo
//

int
INTERNAL
RgFlushFileInfo(
               LPFILE_INFO lpFileInfo
               )
{

    int ErrorCode;
    HFILE hSourceFile;
    HFILE hDestinationFile;
    char TempFileName[MAX_PATH];
    UINT Index;

    ASSERT(!IsNullPtr(lpFileInfo));

    if (!IsPostCriticalInit() || IsFileAccessDisabled())
        return ERROR_SUCCESS;               //  Win95 compatibility.

    if (!(lpFileInfo-> Flags & FI_DIRTY))
        return ERROR_SUCCESS;

    //  If we're currently flushing this FILE_INFO and are called again because
    //  of low memory conditions, ignore this request.  Or if this is a memory
    //  only registry file, there's nothing to flush to.
    if (lpFileInfo-> Flags & (FI_FLUSHING | FI_VOLATILE))
        return ERROR_SUCCESS;

    lpFileInfo-> Flags |= FI_FLUSHING;

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    hSourceFile = HFILE_ERROR;
    hDestinationFile = HFILE_ERROR;

    if (!RgSetFileAttributes(lpFileInfo-> FileName, FILE_ATTRIBUTE_NONE))
        goto CleanupAfterError;

    if (lpFileInfo-> Flags & FI_EXTENDED) {

        if ((Index = StrLen(lpFileInfo-> FileName)) >= MAX_PATH)
            goto CleanupAfterError;

        StrCpy(TempFileName, lpFileInfo-> FileName);

        //  Back up to the last backslash (or the start of the string) and
        //  null-terminate.
        do {
            Index--;
        }   while (Index > 0 && TempFileName[Index] != '\\');

        //  If we found a backslash, then null terminate the string after the
        //  backslash.  Otherwise, we don't have a full qualified pathname, so
        //  make the temporary file in the current directory and pray that's
        //  where the registry file is.
        if (Index != 0)
            TempFileName[Index + 1] = '\0';
        else
            StrCpy(TempFileName, g_RgDotBackslashPath);

        if ((hDestinationFile = RgCreateTempFile(TempFileName)) ==
            HFILE_ERROR)
            goto CleanupAfterError;

        if ((hSourceFile = RgOpenFile(lpFileInfo-> FileName, OF_READ)) ==
            HFILE_ERROR)
            goto CleanupAfterError;

        TRACE(("rewriting to TempFileName = \""));
        TRACE((TempFileName));
        TRACE(("\"\n"));

    }

    else {
        if ((hDestinationFile = RgOpenFile(lpFileInfo-> FileName, OF_WRITE)) ==
            HFILE_ERROR)
            goto CleanupAfterError;
    }

    //  Write out the file header.
    if (hSourceFile != HFILE_ERROR || lpFileInfo-> FileHeader.Flags &
        FHF_DIRTY) {

        //  Note that RgWriteDatablocks and RgWriteDatablocksComplete uses this
        //  value, too.
        if (lpFileInfo-> Flags & FI_VERSION20)
            lpFileInfo-> FileHeader.Size = sizeof(VERSION20_HEADER_PAGE) +
                                           lpFileInfo-> CurTotalKnSize;
        else
            lpFileInfo-> FileHeader.Size = sizeof(FILE_HEADER) +
                                           lpFileInfo-> CurTotalKnSize;

        if (!RgWriteFile(hDestinationFile, &lpFileInfo-> FileHeader,
                         sizeof(FILE_HEADER)))
            goto CleanupAfterError;

    }

    //  Write out the keynode header and table.
    if ((ErrorCode = RgWriteKeynodes(lpFileInfo, hSourceFile,
                                     hDestinationFile)) != ERROR_SUCCESS) {
        TRACE(("RgWriteKeynodes returned error %d\n", ErrorCode));
        goto CleanupAfterError;
    }

    //  Write out the datablocks.
    if ((ErrorCode = RgWriteDatablocks(lpFileInfo, hSourceFile,
                                       hDestinationFile)) != ERROR_SUCCESS) {
        TRACE(("RgWriteDatablocks returned error %d\n", ErrorCode));
        goto CleanupAfterError;
    }

    RgCloseFile(hDestinationFile);

    //  If we're extending the file, we now go back and delete the current file
    //  and replace it with our temporary file.
    if (hSourceFile != HFILE_ERROR) {

        RgCloseFile(hSourceFile);

        ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

        if (!RgDeleteFile(lpFileInfo-> FileName))
            goto CleanupAfterFilesClosed;

        if (!RgRenameFile(TempFileName, lpFileInfo-> FileName)) {
            DEBUG_OUT(("RgFlushFileInfo failed to replace backing file\n"));
            goto CleanupAfterFilesClosed;
        }

    }

    //  Go back and tell everyone that the write is complete-- the file has
    //  been successfully written to disk.
    RgWriteDatablocksComplete(lpFileInfo);
    RgWriteKeynodesComplete(lpFileInfo);
    lpFileInfo-> FileHeader.Flags &= ~FHF_DIRTY;
    lpFileInfo-> Flags &= ~(FI_DIRTY | FI_EXTENDED);

    ErrorCode = ERROR_SUCCESS;

    CleanupAfterFilesClosed:
    RgSetFileAttributes(lpFileInfo-> FileName, FILE_ATTRIBUTE_READONLY |
                        FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

    lpFileInfo-> Flags &= ~FI_FLUSHING;

    if (ErrorCode != ERROR_SUCCESS)
        DEBUG_OUT(("RgFlushFileInfo() returning error %d\n", ErrorCode));

    return ErrorCode;

    CleanupAfterError:
    if (hSourceFile != HFILE_ERROR)
        RgCloseFile(hSourceFile);

    if (hDestinationFile != HFILE_ERROR) {

        //  If both hSourceFile and hDestinationFile were valid, then we must
        //  have created a temporary file.  Delete it now that we've failed.
        if (hSourceFile != HFILE_ERROR)
            RgDeleteFile(TempFileName);

        RgSetFileAttributes(lpFileInfo-> FileName, FILE_ATTRIBUTE_READONLY |
                            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

    }

    goto CleanupAfterFilesClosed;

}

//
//  RgSweepFileInfo
//

int
INTERNAL
RgSweepFileInfo(
               LPFILE_INFO lpFileInfo
               )
{

    ASSERT(!IsNullPtr(lpFileInfo));

    //  If we're currently sweeping this FILE_INFO and are called again because
    //  of low memory conditions, ignore this request.  Or if this is a memory
    //  only registry file, we can't sweep anything out.
    if (lpFileInfo-> Flags & (FI_FLUSHING | FI_VOLATILE))
        return ERROR_SUCCESS;

    lpFileInfo-> Flags |= FI_SWEEPING;

    RgSweepKeynodes(lpFileInfo);
    RgSweepDatablocks(lpFileInfo);

    lpFileInfo-> Flags &= ~FI_SWEEPING;

    return ERROR_SUCCESS;

}

//
//  RgEnumFileInfos
//
//  Enumerates over all FILE_INFO structures, passing each to the provided
//  callback.  Currently, all errors from callbacks are ignored.
//

VOID
INTERNAL
RgEnumFileInfos(
               LPENUMFILEINFOPROC lpEnumFileInfoProc
               )
{

    LPFILE_INFO lpFileInfo;
    LPFILE_INFO lpTempFileInfo;

    lpFileInfo = g_RgFileInfoList;

    while (!IsNullPtr(lpFileInfo)) {
        lpTempFileInfo = lpFileInfo;
        lpFileInfo = lpFileInfo-> lpNextFileInfo;
        (*lpEnumFileInfoProc)(lpTempFileInfo);
    }

}

#ifdef VXD
    #pragma VxD_RARE_CODE_SEG
#endif

//
//  RgInitRootKeyFromFileInfo
//
//  Using the FILE_INFO contained in the key, initialize the rest of the members
//  of the key.  If any errors occur, then the FILE_INFO is destroyed.
//

int
INTERNAL
RgInitRootKeyFromFileInfo(
                         HKEY hKey
                         )
{

    int ErrorCode;
    LPKEYNODE lpKeynode;

    hKey-> KeynodeIndex = hKey-> lpFileInfo-> KeynodeHeader.RootIndex;

    if ((ErrorCode = RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                                        &lpKeynode)) == ERROR_SUCCESS) {

        hKey-> Signature = KEY_SIGNATURE;
        hKey-> Flags &= ~(KEYF_INVALID | KEYF_DELETED | KEYF_ENUMKEYCACHED);
        hKey-> ChildKeynodeIndex = lpKeynode-> ChildIndex;
        hKey-> BlockIndex = (WORD) lpKeynode-> BlockIndex;
        hKey-> KeyRecordIndex = (BYTE) lpKeynode-> KeyRecordIndex;

        RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, FALSE);

    }

    else
        RgDestroyFileInfo(hKey-> lpFileInfo);

    return ErrorCode;

}

#ifdef VXD
    #pragma VxD_INIT_CODE_SEG
#endif


//
//  VMMRegMapPredefKeyToFile2 -- Alternate version of VMMRegMapPredefKeyToFile that
//  allows remapping of HKCU.  (Called by VMMRegMapPredefKeyToFile.)
//

LONG
REGAPI
VMMRegMapPredefKeyToFile2(
                         HKEY hKey,
                         LPCSTR lpFileName,
                         UINT Flags,
                         BOOL fAllowMapToHKCU
                         )
{
    int ErrorCode;
#ifdef WIN32
    char FullPathName[MAX_PATH];
#endif
    UINT CreateNewFlags;

    if (!( hKey == HKEY_LOCAL_MACHINE ||
           hKey == HKEY_USERS ||
           (hKey == HKEY_CURRENT_USER && fAllowMapToHKCU))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadOptionalStringPtr(lpFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    RgValidateAndConvertKeyHandle(&hKey);

    if (!(hKey-> Flags & KEYF_INVALID))
        RgDestroyFileInfo(hKey-> lpFileInfo);

    //  Specifying NULL "unmaps" the key and leaves it invalidated.
    if (IsNullPtr(lpFileName))
        return ERROR_SUCCESS;

#ifdef WIN32
    //  For users of the Win32 DLL, resolve the path name so they don't have to.
    if ((GetFullPathName(lpFileName, sizeof(FullPathName), FullPathName,
                         NULL)) != 0)
        lpFileName = FullPathName;
#endif

    if (Flags & MPKF_CREATENEW) {
        CreateNewFlags = CFIN_PRIMARY | ((Flags & MPKF_VERSION20) ?
                                         CFIN_VERSION20 : 0);
        ErrorCode = RgCreateFileInfoNew(&hKey-> lpFileInfo, lpFileName,
                                        CreateNewFlags);
    }

    else {
        ErrorCode = RgCreateFileInfoExisting(&hKey-> lpFileInfo, lpFileName);
    }

    if (ErrorCode == ERROR_SUCCESS)
        ErrorCode = RgInitRootKeyFromFileInfo(hKey);

    RgUnlockRegistry();

    return ErrorCode;

}


//
//  VMMRegMapPredefKeyToFile
//

LONG
REGAPI
VMMRegMapPredefKeyToFile(
                        HKEY hKey,
                        LPCSTR lpFileName,
                        UINT Flags
                        )
{
    return VMMRegMapPredefKeyToFile2(hKey, lpFileName, Flags, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regfinfo.h ===
//
//  REGFINFO.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGFINFO_
#define _REGFINFO_

#define PAGESHIFT                   12
#define PAGESIZE                    (1 << PAGESHIFT)
#define PAGEMASK                    (PAGESIZE - 1)

#define KEYNODE_BLOCK_SHIFT	    10
#define KEYNODES_PER_BLOCK	    (1 << KEYNODE_BLOCK_SHIFT)
#define KEYNODE_BLOCK_MASK	    (KEYNODES_PER_BLOCK-1)
#define KEYNODES_PER_PAGE	    (PAGESIZE / sizeof(KEYNODE))

#define KN_INDEX_IN_BLOCK(i)        ((i) & KEYNODE_BLOCK_MASK)
#define KN_BLOCK_NUMBER(i)          ((UINT) ((i) >> KEYNODE_BLOCK_SHIFT))

typedef struct _KEYNODE_BLOCK {
    KEYNODE	aKN[KEYNODES_PER_BLOCK];
} KEYNODE_BLOCK, FAR* LPKEYNODE_BLOCK;

#define KEYNODES_PER_PAGE	    (PAGESIZE / sizeof(KEYNODE))

typedef struct _W95KEYNODE_BLOCK {
    W95KEYNODE	aW95KN[KEYNODES_PER_BLOCK];
} W95KEYNODE_BLOCK, FAR* LPW95KEYNODE_BLOCK;

typedef struct _KEYNODE_BLOCK_INFO {
    LPKEYNODE_BLOCK lpKeynodeBlock;
    BYTE Flags;                                 // KBDF_* bits
    BYTE LockCount;
}   KEYNODE_BLOCK_INFO, FAR* LPKEYNODE_BLOCK_INFO;

#define KBIF_ACCESSED               0x01        //  Recently accessed
#define KBIF_DIRTY                  0x02        //  Must rewrite to disk

//  Number of extra KEYNODE_BLOCK_INFO structures to alloc on top of the block
//  count already in the file.  Reduces heap fragmentation in real-mode.
#define KEYNODE_BLOCK_INFO_SLACK_ALLOC 4

#ifdef WIN32
typedef UINT KEY_RECORD_TABLE_ENTRY;
#else
typedef WORD KEY_RECORD_TABLE_ENTRY;
#endif
typedef KEY_RECORD_TABLE_ENTRY FAR* LPKEY_RECORD_TABLE_ENTRY;

#define NULL_KEY_RECORD_TABLE_ENTRY     ((KEY_RECORD_TABLE_ENTRY) 0)
#define IsNullKeyRecordTableEntry(kri)  ((kri) == NULL_KEY_RECORD_TABLE_ENTRY)

typedef struct _DATABLOCK_INFO {
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPKEY_RECORD_TABLE_ENTRY lpKeyRecordTable;
    UINT BlockSize;                             //  cached from datablock header
    UINT FreeBytes;                             //  cached from datablock header
    UINT FirstFreeIndex;                        //  cached from datablock header
    LONG FileOffset;
    BYTE Flags;                                 //  DIF_* bits
    BYTE LockCount;
}   DATABLOCK_INFO, FAR* LPDATABLOCK_INFO;

#define DIF_PRESENT                 0x01        //  In memory
#define DIF_ACCESSED                0x02        //  Recently accessed
#define DIF_DIRTY                   0x04        //  Must rewrite to disk
#define DIF_EXTENDED                0x08        //  Has grown in size

//  Number of extra DATABLOCK_INFO structures to alloc on top of the block count
//  already in the file.  Reduces heap fragmentation in real-mode.
#define DATABLOCK_INFO_SLACK_ALLOC  4

//  When we create or extend a datablock, try to keep it on page boundaries.
#define DATABLOCK_GRANULARITY       4096
#define RgAlignBlockSize(size) \
    (((size) + (DATABLOCK_GRANULARITY - 1)) & ~(DATABLOCK_GRANULARITY - 1))

typedef struct _FILE_INFO {
    struct _FILE_INFO FAR* lpNextFileInfo;
#ifdef WANT_HIVE_SUPPORT
    struct _HIVE_INFO FAR* lpHiveInfoList;
#endif
#ifdef WANT_NOTIFY_CHANGE_SUPPORT
#ifdef WANT_HIVE_SUPPORT
    struct _FILE_INFO FAR* lpParentFileInfo;
#endif
    struct _NOTIFY_CHANGE FAR* lpNotifyChangeList;
#endif
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    UINT KeynodeBlockCount;
    UINT KeynodeBlockInfoAllocCount;
    DWORD CurTotalKnSize;           // Normally = to FileKnSize unless grown
    LPDATABLOCK_INFO lpDatablockInfo;
    UINT DatablockInfoAllocCount;
    FILE_HEADER FileHeader;
    KEYNODE_HEADER KeynodeHeader;
    WORD Flags;                                 //  FI_* bits
    char FileName[ANYSIZE_ARRAY];
}   FILE_INFO, FAR* LPFILE_INFO;

#define FI_DIRTY                    0x0001      //  Must rewrite to disk
#define FI_KEYNODEDIRTY             0x0002      //
#define FI_EXTENDED                 0x0004      //
#define FI_VERSION20                0x0008      //
#define FI_FLUSHING                 0x0010      //  Currently flushing file
#define FI_SWEEPING                 0x0020      //  Currently sweeping file
#define FI_VOLATILE                 0x0040      //  File has no backing store
#define FI_READONLY                 0x0080      //  File cannot be modified
#define FI_REPLACEMENTEXISTS        0x0100      //  RegReplaceKey called on file

typedef struct _HIVE_INFO {
    struct _HIVE_INFO FAR* lpNextHiveInfo;
    LPFILE_INFO lpFileInfo;
    UINT NameLength;
    BYTE Hash;
    char Name[ANYSIZE_ARRAY];
}   HIVE_INFO, FAR* LPHIVE_INFO;

#define CFIN_PRIMARY                0x0000      //  FHT_PRIMARY header type
#define CFIN_SECONDARY              0x0001      //  FHT_SECONDARY header type
#define CFIN_VOLATILE               0x0002      //  File has no backing store
#define CFIN_VERSION20              0x0004      //  Use compact keynode form

int
INTERNAL
RgCreateFileInfoNew(
    LPFILE_INFO FAR* lplpFileInfo,
    LPCSTR lpFileName,
    UINT Flags
    );

int
INTERNAL
RgCreateFileInfoExisting(
    LPFILE_INFO FAR* lplpFileInfo,
    LPCSTR lpFileName
    );

int
INTERNAL
RgInitRootKeyFromFileInfo(
    HKEY hKey
    );

int
INTERNAL
RgDestroyFileInfo(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgFlushFileInfo(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgSweepFileInfo(
    LPFILE_INFO lpFileInfo
    );

typedef int (INTERNAL* LPENUMFILEINFOPROC)(LPFILE_INFO);

VOID
INTERNAL
RgEnumFileInfos(
    LPENUMFILEINFOPROC lpEnumFileInfoProc
    );

#define RgIndexKeynodeBlockInfoPtr(lpfi, index) \
    ((LPKEYNODE_BLOCK_INFO) (&(lpfi)-> lpKeynodeBlockInfo[index]))

#define RgIndexDatablockInfoPtr(lpfi, index) \
    ((LPDATABLOCK_INFO) (&(lpfi)-> lpDatablockInfo[index]))

#define RgIndexKeyRecordPtr(lpdi, index) \
    ((LPKEY_RECORD) ((LPBYTE)(lpdi)-> lpDatablockHeader + (lpdi)-> lpKeyRecordTable[(index)]))

BOOL
INTERNAL
RgIsValidFileHeader(
    LPFILE_HEADER lpFileHeader
    );

BOOL
INTERNAL
RgIsValidKeynodeHeader(
    LPKEYNODE_HEADER lpKeynodeHeader
    );

BOOL
INTERNAL
RgIsValidDatablockHeader(
    LPDATABLOCK_HEADER lpDatablockHeader
    );

extern LPFILE_INFO g_RgFileInfoList;

#endif // _REGFINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regfsio.h ===
//
//  REGFSIO.H
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Prototypes for file system I/O.  Many of these prototypes may not be used
//  if a direct mapping is available in the target environment.
//

#ifndef _REGFSIO_
#define _REGFSIO_

//  Consistent with both 16-bit and 32-bit windows.h.
#ifndef HFILE_ERROR
typedef int HFILE;
#define HFILE_ERROR     ((HFILE)-1)
#endif

//  Special value used for the VMM version when we haven't fully initialized yet
//  but are reading SYSTEM.DAT from the XMS cache.
#define HFILE_MEMORY    ((HFILE)-2)

#ifndef RgCreateFile
HFILE
INTERNAL
RgCreateFile(
    LPCSTR lpFileName
    );
#endif

#ifndef RgOpenFile
HFILE
INTERNAL
RgOpenFile(
    LPCSTR lpFileName,
    int Mode
    );
#endif

#ifndef RgCreateTempFile
HFILE
INTERNAL
RgCreateTempFile(
    LPSTR lpFileName
    );
#endif

#ifndef RgReadFile
BOOL
INTERNAL
RgReadFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    );
#endif

#ifndef RgWriteFile
BOOL
INTERNAL
RgWriteFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    );
#endif

#ifndef RgSeekFile
BOOL
INTERNAL
RgSeekFile(
    HFILE hFile,
    LONG FileOffset
    );
#endif

#ifndef RgCloseFile
VOID
INTERNAL
RgCloseFile(
    HFILE hFile
    );
#endif

#ifndef RgDeleteFile
BOOL
INTERNAL
RgDeleteFile(
    LPCSTR lpFileName
    );
#endif

#ifndef RgRenameFile
BOOL
INTERNAL
RgRenameFile(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    );
#endif

#define FILE_ATTRIBUTE_NONE             0

#ifndef RgGetFileAttributes
DWORD
INTERNAL
RgGetFileAttributes(
    LPCSTR lpFileName
    );
#endif

#ifndef RgSetFileAttributes
BOOL
INTERNAL
RgSetFileAttributes(
    LPCSTR lpFileName,
    UINT FileAttributes
    );
#endif

#ifndef RgGetFileSize
DWORD
INTERNAL
RgGetFileSize(
    HFILE hFile
    );
#endif

#endif // _REGFSIO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regknode.h ===
//
//  REGKNODE.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGKNODE_
#define _REGKNODE_

int
INTERNAL
RgInitKeynodeInfo(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgLockKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    );

int
INTERNAL
RgLockInUseKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    );

VOID
INTERNAL
RgUnlockKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    BOOL fMarkDirty
    );

int
INTERNAL
RgWriteKeynodes(
    LPFILE_INFO lpFileInfo,
    HFILE hSrcFile,
    HFILE hDestFile
    );

VOID
INTERNAL
RgWriteKeynodesComplete(
    LPFILE_INFO lpFileInfo
    );

VOID
INTERNAL
RgSweepKeynodes(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgAllocKeynode(
    LPFILE_INFO lpFileInfo,
    LPDWORD lpKeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    );

int
INTERNAL
RgFreeKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    );

#endif // _REGKNODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regkey.c ===
//
//  REGKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegCreateKey, RegOpenKey, RegCloseKey, and supporting
//  functions.
//

#include "pch.h"

//
//  RgIsBadSubKey
//
//  Returns TRUE if lpSubKey is a invalid subkey string.  An invalid subkey
//  string may be an invalid pointer or contain double-backslashes or elements
//  greater than MAXIMUM_SUB_KEY_LENGTH.
//

BOOL
INTERNAL
RgIsBadSubKey(
    LPCSTR lpSubKey
    )
{

    LPCSTR lpString;
    UINT SubSubKeyLength;
    BYTE Char;

    if (IsNullPtr(lpSubKey))
        return FALSE;

    if (!IsBadStringPtr(lpSubKey, (UINT) -1)) {

        lpString = lpSubKey;
        SubSubKeyLength = 0;

        while (TRUE) {

            Char = *((LPBYTE) lpString);

            if (Char == '\0')
                return FALSE;

            else if (Char == '\\') {
                //  Catch double-backslashes and leading backslashes.  One
                //  leading backslash is acceptable...
                if (SubSubKeyLength == 0 && lpString != lpSubKey)
                    break;
                SubSubKeyLength = 0;
            }

            else {

                if (IsDBCSLeadByte(Char)) {
                    SubSubKeyLength++;
                    //  Catch an unpaired DBCS pair...
                    if (*lpString++ == '\0')
                        break;
                }

                //  Win95 compatibility: don't accept strings with control
                //  characters.
                else if (Char < ' ')
                    break;

                if (++SubSubKeyLength >= MAXIMUM_SUB_KEY_LENGTH)
                    break;

            }

            lpString++;

        }

    }

    return TRUE;

}

//
//  RgGetNextSubSubKey
//
//  Extracts the next subkey component tokenized by backslashes.  Works like
//  strtok where on the first call, lpSubKey points to the start of the subkey.
//  On subsequent calls, lpSubKey is NULL and the last offset is used to find
//  the next component.
//
//  Returns the length of the SubSubKey string.
//

UINT
INTERNAL
RgGetNextSubSubKey(
    LPCSTR lpSubKey,
    LPCSTR FAR* lplpSubSubKey,
    UINT FAR* lpSubSubKeyLength
    )
{

    static LPCSTR lpLastSubSubKey = NULL;
    LPCSTR lpString;
    UINT SubSubKeyLength;

    if (!IsNullPtr(lpSubKey))
        lpLastSubSubKey = lpSubKey;

    lpString = lpLastSubSubKey;

    if (*lpString == '\0') {
        *lplpSubSubKey = NULL;
        *lpSubSubKeyLength = 0;
        return 0;
    }

    if (*lpString == '\\')
        lpString++;

    *lplpSubSubKey = lpString;

    while (*lpString != '\0') {

        if (*lpString == '\\')
            break;

        //  The subkey has already been validated, so we know there's a matching
        //  trail byte.
        if (IsDBCSLeadByte(*lpString))
            lpString++;                 //  Trail byte skipped immediately below

        lpString++;

    }

    lpLastSubSubKey = lpString;

    SubSubKeyLength = lpString - *lplpSubSubKey;
    *lpSubSubKeyLength = SubSubKeyLength;

    return SubSubKeyLength;

}

//
//  RgLookupKey
//

int
INTERNAL
RgLookupKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphSubKey,
    UINT Flags
    )
{

    int ErrorCode;
    LPCSTR lpSubSubKey;
    UINT SubSubKeyLength;
    BOOL fCreatedKeynode;
    LPFILE_INFO lpFileInfo;
    DWORD KeynodeIndex;
#ifdef WANT_HIVE_SUPPORT
    LPHIVE_INFO lpHiveInfo;
#endif
    BOOL fPrevIsNextIndex;
    DWORD SubSubKeyHash;
    LPKEYNODE lpKeynode;
    LPKEY_RECORD lpKeyRecord;
    BOOL fFound;
    DWORD PrevKeynodeIndex;
#ifdef WANT_NOTIFY_CHANGE_SUPPORT
    DWORD NotifyKeynodeIndex;
#endif
    LPKEYNODE lpNewKeynode;
    HKEY hSubKey;

    fCreatedKeynode = FALSE;

    //
    //  Check if the caller is trying to open a key with a NULL or zero-length
    //  sub key string.  If so, simply return hKey.
    //

    if (IsNullPtr(lpSubKey) || RgGetNextSubSubKey(lpSubKey, &lpSubSubKey,
        &SubSubKeyLength) == 0) {
        hSubKey = hKey;
        goto HaveSubKeyHandle;
    }

    lpFileInfo = hKey-> lpFileInfo;
    KeynodeIndex = hKey-> ChildKeynodeIndex;
    PrevKeynodeIndex = hKey-> KeynodeIndex;

#ifdef WANT_HIVE_SUPPORT
    //
    //  If this key can have hives attached to it, check there for the first
    //  part of the subkey.  If we have a match, then switch into that
    //  FILE_INFO.
    //

    if (hKey-> Flags & KEYF_HIVESALLOWED) {

        lpHiveInfo = lpFileInfo-> lpHiveInfoList;

        while (!IsNullPtr(lpHiveInfo)) {

            if (SubSubKeyLength == lpHiveInfo-> NameLength &&
                RgStrCmpNI(lpSubSubKey, lpHiveInfo-> Name,
                SubSubKeyLength) == 0) {

                lpFileInfo = lpHiveInfo-> lpFileInfo;
                KeynodeIndex = lpFileInfo-> KeynodeHeader.RootIndex;

                if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
                    &lpKeynode)) != ERROR_SUCCESS)
                    return ErrorCode;

                if (!RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength))
                    goto LookupComplete;

                PrevKeynodeIndex = KeynodeIndex;
                KeynodeIndex = lpKeynode-> ChildIndex;
                RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, FALSE);

                break;

            }

            lpHiveInfo = lpHiveInfo-> lpNextHiveInfo;

        }

    }
#endif

    //
    //  Walk as deep as we can into the registry tree using existing key
    //  records.  For each subkey component, move to the child of the current
    //  tree position and walk each sibling looking for a match.  Repeat until
    //  we're out of subkey components or we hit the end of a branch.
    //

    fPrevIsNextIndex = FALSE;

    for (;;) {

        SubSubKeyHash = RgHashString(lpSubSubKey, SubSubKeyLength);

        while (!IsNullKeynodeIndex(KeynodeIndex)) {

            if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
                &lpKeynode)) != ERROR_SUCCESS)
                return ErrorCode;

            if (lpKeynode-> Hash == SubSubKeyHash) {

                if ((ErrorCode = RgLockKeyRecord(lpFileInfo, lpKeynode->
                    BlockIndex, (BYTE) lpKeynode-> KeyRecordIndex,
                    &lpKeyRecord)) != ERROR_SUCCESS) {
                    RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
                    return ErrorCode;
                }

                fFound = (SubSubKeyLength == lpKeyRecord-> NameLength &&
                    RgStrCmpNI(lpSubSubKey, lpKeyRecord-> Name,
                    SubSubKeyLength) == 0);

                RgUnlockDatablock(lpFileInfo, lpKeynode-> BlockIndex, FALSE);

                if (fFound)
                    break;

            }

            //  Unlock the current keynode and advance to its sibling.  Set
            //  fPrevIsNextIndex so that if we have to create, we know that
            //  we'll be inserting the new keynode as a sibling.
            fPrevIsNextIndex = TRUE;
            PrevKeynodeIndex = KeynodeIndex;
            KeynodeIndex = lpKeynode-> NextIndex;
            RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, FALSE);

        }

        //  Break out if we looped over all the siblings of the previous keynode
        //  or if the previous keynode didn't have any children.  If we're in
        //  create mode, then fPrevIsNextIndex and PrevKeynodeIndex will
        //  represent where we need to start inserting.
        if (IsNullKeynodeIndex(KeynodeIndex))
            break;

        //  Break out there are no more subkey components to lookup.
        //  KeynodeIndex represents the index of the matching key.  It's
        //  corresponding keynode is locked.
        if (!RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength))
            break;

        //  Unlock the current keynode and advance to its child.  Clear
        //  fPrevIsNextIndex so that if we have to create, we know that we'll
        //  be inserting the new keynode as a child.
        fPrevIsNextIndex = FALSE;
        PrevKeynodeIndex = KeynodeIndex;
        KeynodeIndex = lpKeynode-> ChildIndex;
        RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, FALSE);

    }

    if (IsNullKeynodeIndex(KeynodeIndex)) {

        if (!(Flags & LK_CREATE))
            return ERROR_CANTOPEN16_FILENOTFOUND32;

        if (((hKey-> PredefinedKeyIndex == INDEX_DYN_DATA) && !(Flags &
            LK_CREATEDYNDATA)) || (lpFileInfo-> Flags & FI_READONLY))
            return ERROR_ACCESS_DENIED;

        if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, PrevKeynodeIndex,
            &lpKeynode)) != ERROR_SUCCESS) {
            TRACE(("RgLookupKey: failed to lock keynode we just had?\n"));
            return ErrorCode;
        }

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
        //  Which keynode index we'll notify of the subkeys we're creating
        //  depends on the state of fPrevIsNextIndex.
        NotifyKeynodeIndex = fPrevIsNextIndex ? lpKeynode-> ParentIndex :
            PrevKeynodeIndex;
#endif

        //  See if there's an open handle on the parent so that we can patch up
        //  its child keynode index member.  We only need this on the first
        //  pass.
        hSubKey = RgFindOpenKeyHandle(lpFileInfo, PrevKeynodeIndex);

        do {

            if ((ErrorCode = RgAllocKeynode(lpFileInfo, &KeynodeIndex,
                &lpNewKeynode)) != ERROR_SUCCESS)
                goto CreateAllocFailed1;

            if ((ErrorCode = RgAllocKeyRecord(lpFileInfo, sizeof(KEY_RECORD) +
                SubSubKeyLength - 1, &lpKeyRecord)) != ERROR_SUCCESS) {

                RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
                RgFreeKeynode(lpFileInfo, KeynodeIndex);

CreateAllocFailed1:
                RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, fCreatedKeynode);

                DEBUG_OUT(("RgLookupKey: allocation failed\n"));
                goto SignalAndReturnErrorCode;

            }

            //  Fixup the previous keynode's next offset.
            if (fPrevIsNextIndex) {

                fPrevIsNextIndex = FALSE;
                hSubKey = NULL;
                lpNewKeynode-> ParentIndex = lpKeynode-> ParentIndex;
                lpKeynode-> NextIndex = KeynodeIndex;

            }

            //  Fixup the previous keynode's child offset.
            else {

                lpNewKeynode-> ParentIndex = PrevKeynodeIndex;
                lpKeynode-> ChildIndex = KeynodeIndex;

                //  If hSubKey is not NULL, then we may have to patch up the
                //  child offset cache to point to the newly created keynode.
                if (!IsNullPtr(hSubKey)) {
                    if (IsNullKeynodeIndex(hSubKey-> ChildKeynodeIndex))
                        hSubKey-> ChildKeynodeIndex = KeynodeIndex;
                    hSubKey = NULL;
                }

            }

            //  Fill in the keynode.
            lpNewKeynode-> NextIndex = REG_NULL;
            lpNewKeynode-> ChildIndex = REG_NULL;
            lpNewKeynode-> BlockIndex = lpKeyRecord-> BlockIndex;
            lpNewKeynode-> KeyRecordIndex = lpKeyRecord-> KeyRecordIndex;
            lpNewKeynode-> Hash = (WORD) RgHashString(lpSubSubKey,
                SubSubKeyLength);

            //  Fill in the key record.
            lpKeyRecord-> RecordSize = sizeof(KEY_RECORD) + SubSubKeyLength - 1;
            lpKeyRecord-> NameLength = (WORD) SubSubKeyLength;
            MoveMemory(lpKeyRecord-> Name, lpSubSubKey, SubSubKeyLength);
            lpKeyRecord-> ValueCount = 0;
            lpKeyRecord-> ClassLength = 0;
            lpKeyRecord-> Reserved = 0;

            //  Unlock the keynode that points to the new keynode and advance
            //  to the next keynode.
            RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, TRUE);
            PrevKeynodeIndex = KeynodeIndex;
            lpKeynode = lpNewKeynode;

            RgUnlockDatablock(lpFileInfo, lpKeyRecord-> BlockIndex, TRUE);

            fCreatedKeynode = TRUE;

            //  Following should already be zeroed for subsequent iterations.
            ASSERT(!fPrevIsNextIndex);
            ASSERT(IsNullPtr(hSubKey));

        }   while (RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength));

    }

    ASSERT(!IsNullKeynodeIndex(KeynodeIndex));

    //
    //  Now we've got the keynode for the request subkey.  Check if it has been
    //  previously opened.  If not, then allocate a new key handle for it and
    //  initialize it.
    //

LookupComplete:
    if (IsNullPtr(hSubKey = RgFindOpenKeyHandle(lpFileInfo, KeynodeIndex))) {

        if (IsNullPtr(hSubKey = RgCreateKeyHandle()))
            ErrorCode = ERROR_OUTOFMEMORY;

        else {

            hSubKey-> lpFileInfo = lpFileInfo;
	    hSubKey-> KeynodeIndex = KeynodeIndex;
	    hSubKey-> ChildKeynodeIndex = lpKeynode-> ChildIndex;
            hSubKey-> BlockIndex = (WORD) lpKeynode-> BlockIndex;
            hSubKey-> KeyRecordIndex = (BYTE) lpKeynode-> KeyRecordIndex;
            hSubKey-> PredefinedKeyIndex = hKey-> PredefinedKeyIndex;

        }

    }

    RgUnlockKeynode(lpFileInfo, KeynodeIndex, fCreatedKeynode);

    //
    //  Now we've got a key handle that references the requested subkey.
    //  Increment the reference count on the handle and return it to the caller.
    //  Note that this differs from NT semantic where they return a unique
    //  handle for every open.
    //

    if (!IsNullPtr(hSubKey)) {
HaveSubKeyHandle:
        RgIncrementKeyReferenceCount(hSubKey);
        *lphSubKey = hSubKey;
        ErrorCode = ERROR_SUCCESS;
    }

SignalAndReturnErrorCode:
    //  If we managed to create any keynodes, regardless of what ErrorCode is
    //  set to now, then we must signal any waiting events.
    if (fCreatedKeynode) {
        RgSignalWaitingNotifies(lpFileInfo, NotifyKeynodeIndex,
            REG_NOTIFY_CHANGE_NAME);
    }

    return ErrorCode;

}

//
//  RgCreateOrOpenKey
//
//  Common routine for VMMRegCreateKey and VMMRegOpenKey.  Valids parameters,
//  locks the registry, and calls the real worker routine.
//

int
INTERNAL
RgCreateOrOpenKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey,
    UINT Flags
    )
{

    int ErrorCode;

    if (RgIsBadSubKey(lpSubKey))
        return ERROR_BADKEY;

    if (IsBadHugeWritePtr(lphKey, sizeof(HKEY)))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgLookupKey(hKey, lpSubKey, lphKey, Flags);

    RgUnlockRegistry();

    return ErrorCode;

}


//
//  VMMRegCreateKey
//
//  See Win32 documentation of RegCreateKey.
//

LONG
REGAPI
VMMRegCreateKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey
    )
{

    return RgCreateOrOpenKey(hKey, lpSubKey, lphKey, LK_CREATE);

}

//
//  VMMRegOpenKey
//
//  See Win32 documentation of RegOpenKey.
//

LONG
REGAPI
VMMRegOpenKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey
    )
{

    return RgCreateOrOpenKey(hKey, lpSubKey, lphKey, LK_OPEN);

}

//
//  VMMRegCloseKey
//
//  See Win32 documentation of RegCloseKey.
//

LONG
REGAPI
VMMRegCloseKey(
    HKEY hKey
    )
{

    int ErrorCode;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    ErrorCode = RgValidateAndConvertKeyHandle(&hKey);

    if (ErrorCode == ERROR_SUCCESS || ErrorCode == ERROR_KEY_DELETED) {
        RgDestroyKeyHandle(hKey);
        ErrorCode = ERROR_SUCCESS;
    }

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\reginit.c ===
//
//  REGINIT.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

#ifdef DEBUG
extern int g_RgDatablockLockCount;
extern int g_RgKeynodeLockCount;
extern int g_RgMemoryBlockCount;
#endif

#ifdef WANT_DYNKEY_SUPPORT
#ifdef VXD
#pragma VMM_IDATA_SEG
#endif
const char g_RgNull[] = "";
#ifdef VXD
#pragma VMM_PAGEABLE_DATA_SEG
#endif
#endif

#ifdef VXD
//  Set when our post critical init routine is called indicating that it's safe
//  to make disk I/O calls.  May also be set early when RegFlushKey gets the
//  magic HKEY_CRITICAL_FLUSH.
BYTE g_RgPostCriticalInit = FALSE;
//  Set when RegFlushKey gets the magic HKEY_DISABLE_REG.  No disk I/O will be
//  allowed after this flag is set.
BYTE g_RgFileAccessDisabled = FALSE;
#endif

LPVOID g_RgWorkBuffer = NULL;
#ifdef DEBUG
BOOL g_RgWorkBufferBusy = FALSE;
#endif

#ifdef VXD
#pragma VxD_INIT_CODE_SEG
#endif

//
//  VMMRegLibAttach
//
//  Prepares the registry library for use by allocating any global resources.
//  If ERROR_SUCCESS is returned, then VMMRegLibDetach should be called to 
//  release these resources.
//

LONG
REGAPI
VMMRegLibAttach(
    UINT Flags
    )
{

    if (IsNullPtr((g_RgWorkBuffer = RgAllocMemory(SIZEOF_WORK_BUFFER))))
        goto MemoryError;

#ifdef WANT_STATIC_KEYS
    if (!RgAllocKeyHandleStructures())
        goto MemoryError;
#endif

#ifdef WANT_DYNKEY_SUPPORT
    //  Initialize HKEY_DYN_DATA.  If anything fails here, we won't stop the
    //  initialize of the entire registry.
    if (RgCreateFileInfoNew(&g_RgDynDataKey.lpFileInfo, g_RgNull,
        CFIN_VERSION20 | CFIN_VOLATILE) == ERROR_SUCCESS)
        RgInitRootKeyFromFileInfo(&g_RgDynDataKey);

    ASSERT(!(g_RgDynDataKey.Flags & KEYF_INVALID));
#endif

    return ERROR_SUCCESS;

MemoryError:
    //  Release anything that we may have allocated up to this point.
    VMMRegLibDetach();

    TRACE(("VMMRegLibAttach returning ERROR_OUTOFMEMORY\n"));
    return ERROR_OUTOFMEMORY;

}

#ifdef VXD
#pragma VxD_SYSEXIT_CODE_SEG
#endif

#ifdef WANT_FULL_MEMORY_CLEANUP
//
//  RgDetachPredefKey
//
//  Destroys the memory associated with a predefined key and marks the key
//  invalid.
//

VOID
INTERNAL
RgDetachPredefKey(
    HKEY hKey
    )
{

    if (!(hKey-> Flags & KEYF_INVALID)) {
        RgDestroyFileInfo(hKey-> lpFileInfo);
        hKey-> Flags |= KEYF_INVALID;
    }

}
#endif

//
//  VMMRegLibDetach
//
//  Releases resources allocated by VMMRegLibAttach.  This function may be
//  called after VMMRegLibDetach returns an error, so this function and all
//  functions it calls must be aware that their corresponding 'alloc' function
//  was not called.
//

VOID
REGAPI
VMMRegLibDetach(
    VOID
    )
{

    RgEnumFileInfos(RgFlushFileInfo);

#ifdef VXD
    //  Reduce the chance that we'll go and try to touch the file again!
    g_RgFileAccessDisabled = TRUE;
#endif

#ifdef WANT_REGREPLACEKEY
    //  Win95 difference: file replacement used to take place on system startup,
    //  not system exit.  It's much easier to deal with file replacement now
    //  since we know somebody called RegReplaceKey and we only have to do the
    //  work in one component, instead of multiple copies in io.sys, VMM loader,
    //  and VMM.
    RgEnumFileInfos(RgReplaceFileInfo);
#endif

#ifdef WANT_FULL_MEMORY_CLEANUP
    //
    //  Delete the FILE_INFO of each of these top-level keys will cause all
    //  of their hives to be deleted.
    //

    RgDetachPredefKey(&g_RgLocalMachineKey);
    RgDetachPredefKey(&g_RgUsersKey);

#ifdef WANT_DYNKEY_SUPPORT
    RgDetachPredefKey(&g_RgDynDataKey);
#endif

    RgFreeKeyHandleStructures();

    if (!IsNullPtr(g_RgWorkBuffer))
        RgFreeMemory(g_RgWorkBuffer);
#endif

    ASSERT(g_RgDatablockLockCount == 0);
    ASSERT(g_RgKeynodeLockCount == 0);
#ifdef WANT_FULL_MEMORY_CLEANUP
    ASSERT(g_RgMemoryBlockCount == 0);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\reghive.c ===
//
//  REGHIVE.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegLoadKey, RegUnLoadKey, RegSaveKey, RegReplaceKey and
//  supporting functions.
//

#include "pch.h"

#ifdef WANT_HIVE_SUPPORT

//  Maximum number of times we'll allow RgCopyBranch to be reentered.
#define MAXIMUM_COPY_RECURSION          32

LPSTR g_RgNameBufferPtr;                //  Temporary buffer for RgCopyBranch
LPBYTE g_RgDataBufferPtr;               //  Temporary buffer for RgCopyBranch
UINT g_RgRecursionCount;                //  Tracks depth of RgCopyBranch

#if MAXIMUM_VALUE_NAME_LENGTH > MAXIMUM_SUB_KEY_LENGTH
#error Code assumes a value name can fit in a subkey buffer.
#endif

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  RgValidateHiveSubKey
//
//  Note that unlike most parameter validation routines, this routine must be
//  called with the registry lock taken because we call RgGetNextSubSubKey.
//
//  Pass back the length of the subkey to deal with the trailing backslash
//  problem.
//
//  Returns TRUE if lpSubKey is a valid subkey string for hive functions.
//

BOOL
INTERNAL
RgValidateHiveSubKey(
    LPCSTR lpSubKey,
    UINT FAR* lpHiveKeyLength
    )
{

    LPCSTR lpSubSubKey;
    UINT SubSubKeyLength;

    //  Verify that we have a valid subkey that has one and only one sub-subkey.
    //  Win95 messed this up and it was possible to load a hive with a keyname
    //  containing a backslash!
    return !IsNullPtr(lpSubKey) && !RgIsBadSubKey(lpSubKey) &&
        (RgGetNextSubSubKey(lpSubKey, &lpSubSubKey, lpHiveKeyLength) > 0) &&
        (RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength) == 0);

}

//
//  VMMRegLoadKey
//
//  See Win32 documentation of RegLoadKey.
//

LONG
REGAPI
VMMRegLoadKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    HKEY hSubKey;
    UINT SubKeyLength;
    LPHIVE_INFO lpHiveInfo;

    if (IsBadStringPtr(lpFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if ((hKey != HKEY_LOCAL_MACHINE) && (hKey != HKEY_USERS))
        return ERROR_BADKEY;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

    if (!RgValidateHiveSubKey(lpSubKey, &SubKeyLength)) {
        ErrorCode = ERROR_BADKEY;
        goto ReturnErrorCode;
    }

    //  Check if a subkey with the specified name already exists.
    if (RgLookupKey(hKey, lpSubKey, &hSubKey, LK_OPEN) == ERROR_SUCCESS) {
        RgDestroyKeyHandle(hSubKey);
        ErrorCode = ERROR_BADKEY;       //  Win95 compatibility
        goto ReturnErrorCode;
    }

    if (IsNullPtr((lpHiveInfo = (LPHIVE_INFO)
        RgSmAllocMemory(sizeof(HIVE_INFO) + SubKeyLength)))) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ReturnErrorCode;
    }

    //  Fill in the HIVE_INFO.
    StrCpy(lpHiveInfo-> Name, lpSubKey);
    lpHiveInfo-> NameLength = SubKeyLength;
    lpHiveInfo-> Hash = (BYTE) RgHashString(lpSubKey, SubKeyLength);

    //  Attempt to create a FILE_INFO for the specified file.  If successful,
    //  link this HIVE_INFO into the parent FILE_INFO's hive list.
    if ((ErrorCode = RgCreateFileInfoExisting(&lpHiveInfo-> lpFileInfo,
        lpFileName)) == ERROR_SUCCESS) {

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
        lpHiveInfo-> lpFileInfo-> lpParentFileInfo = hKey-> lpFileInfo;
#endif
        lpHiveInfo-> lpNextHiveInfo = hKey-> lpFileInfo-> lpHiveInfoList;
        hKey-> lpFileInfo-> lpHiveInfoList = lpHiveInfo;

        //  Signal any notifications waiting on this top-level key.
        RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
            REG_NOTIFY_CHANGE_NAME);

    }

    else
        RgFreeMemory(lpHiveInfo);

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

}

//
//  VMMRegUnLoadKey
//
//  See Win32 documentation of RegUnLoadKey.
//

LONG
REGAPI
VMMRegUnLoadKey(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{

    int ErrorCode;
    UINT SubKeyLength;
    LPFILE_INFO lpFileInfo;
    LPHIVE_INFO lpPrevHiveInfo;
    LPHIVE_INFO lpCurrHiveInfo;

    if ((hKey != HKEY_LOCAL_MACHINE) && (hKey != HKEY_USERS))
        return ERROR_BADKEY;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

    ErrorCode = ERROR_BADKEY;               //  Assume this error code

    if (!RgValidateHiveSubKey(lpSubKey, &SubKeyLength))
        goto ReturnErrorCode;

    lpPrevHiveInfo = NULL;
    lpCurrHiveInfo = hKey-> lpFileInfo-> lpHiveInfoList;

    while (!IsNullPtr(lpCurrHiveInfo)) {

        if (SubKeyLength == lpCurrHiveInfo-> NameLength && RgStrCmpNI(lpSubKey,
            lpCurrHiveInfo-> Name, SubKeyLength) == 0) {

            //  Unlink this HIVE_INFO structure.
            if (IsNullPtr(lpPrevHiveInfo))
                hKey-> lpFileInfo-> lpHiveInfoList = lpCurrHiveInfo->
                    lpNextHiveInfo;
            else
                lpPrevHiveInfo-> lpNextHiveInfo = lpCurrHiveInfo->
                    lpNextHiveInfo;

            //  Flush and destroy it's associated FILE_INFO structure.  When we
            //  destroy the FILE_INFO, all open keys in this hive will be
            //  invalidated.
            lpFileInfo = lpCurrHiveInfo-> lpFileInfo;
            RgFlushFileInfo(lpFileInfo);
            RgDestroyFileInfo(lpFileInfo);

            //  Free the HIVE_INFO itself.
            RgSmFreeMemory(lpCurrHiveInfo);

            //  Signal any notifications waiting on this top-level key.
            RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                REG_NOTIFY_CHANGE_NAME);

            ErrorCode = ERROR_SUCCESS;
            break;

        }

        lpPrevHiveInfo = lpCurrHiveInfo;
        lpCurrHiveInfo = lpCurrHiveInfo-> lpNextHiveInfo;

    }

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

}

//
//  RgCopyBranchHelper
//
//  Copies all of the values and subkeys starting at the specified source key to
//  the specified destination key.
//
//  For Win95 compatibility, we don't stop the copy process if we encounter an
//  error.  (But unlike Win95, we do actually check more error codes)
//
//  SHOULD ONLY BE CALLED BY RgCopyBranch.
//

VOID
INTERNAL
RgCopyBranchHelper(
    HKEY hSourceKey,
    HKEY hDestinationKey
    )
{

    UINT Index;
    DWORD cbNameBuffer;
    LPVALUE_RECORD lpValueRecord;

    //
    //  Copy all of the values from the source key to the destination key.
    //

    Index = 0;

    while (RgLookupValueByIndex(hSourceKey, Index++, &lpValueRecord) ==
        ERROR_SUCCESS) {

        DWORD cbDataBuffer;
        DWORD Type;

        cbNameBuffer = MAXIMUM_VALUE_NAME_LENGTH;
        cbDataBuffer = MAXIMUM_DATA_LENGTH + 1;         //  Terminating null

        if (RgCopyFromValueRecord(hSourceKey, lpValueRecord, g_RgNameBufferPtr,
            &cbNameBuffer, &Type, g_RgDataBufferPtr, &cbDataBuffer) ==
            ERROR_SUCCESS) {
            //  Subtract the terminating null that RgCopyFromValueRecord added
            //  to cbDataBuffer.  We don't save that in the file.
            if (Type == REG_SZ) {
                ASSERT(cbDataBuffer > 0);               //  Must have the null!
                cbDataBuffer--;
            }
            RgSetValue(hDestinationKey, g_RgNameBufferPtr, Type,
                g_RgDataBufferPtr, cbDataBuffer);
        }

        RgUnlockDatablock(hSourceKey-> lpFileInfo, hSourceKey-> BlockIndex,
            FALSE);

    }

    //  We can't recurse forever, so enforce a maximum depth like Win95.
    if (g_RgRecursionCount > MAXIMUM_COPY_RECURSION)
        return;

    g_RgRecursionCount++;

    //
    //  Copy all of the subkeys from the source key to the destination key.
    //

    Index = 0;

    while (TRUE) {

        HKEY hSubSourceKey;
        HKEY hSubDestinationKey;

        cbNameBuffer = MAXIMUM_SUB_KEY_LENGTH;

        if (RgLookupKeyByIndex(hSourceKey, Index++, g_RgNameBufferPtr,
            &cbNameBuffer) != ERROR_SUCCESS)
            break;

        if (RgLookupKey(hSourceKey, g_RgNameBufferPtr, &hSubSourceKey,
            LK_OPEN) == ERROR_SUCCESS) {

            if (RgLookupKey(hDestinationKey, g_RgNameBufferPtr,
                &hSubDestinationKey, LK_CREATE) == ERROR_SUCCESS) {
                RgYield();
                RgCopyBranchHelper(hSubSourceKey, hSubDestinationKey);
                RgDestroyKeyHandle(hSubDestinationKey);
            }

            else
                TRAP();

            RgDestroyKeyHandle(hSubSourceKey);

        }

        else
            TRAP();

    }

    g_RgRecursionCount--;

}

//
//  RgCopyBranch
//
//  Copies all of the values and subkeys starting at the specified source key to
//  the specified destination key.
//
//  This function sets and cleans up for RgCopyBranchHelper who does all
//  the real copying.
//
//  The backing store of the destination file is flushed if successful.
//

int
INTERNAL
RgCopyBranch(
    HKEY hSourceKey,
    HKEY hDestinationKey
    )
{

    int ErrorCode;

    if (IsNullPtr(g_RgNameBufferPtr = RgSmAllocMemory(MAXIMUM_SUB_KEY_LENGTH)))
        ErrorCode = ERROR_OUTOFMEMORY;

    else {

        if (IsNullPtr(g_RgDataBufferPtr = RgSmAllocMemory(MAXIMUM_DATA_LENGTH +
            1)))                                        //  + terminating null
            ErrorCode = ERROR_OUTOFMEMORY;

        else {

            g_RgRecursionCount = 0;
            RgCopyBranchHelper(hSourceKey, hDestinationKey);

            //  Everything should be copied over, so flush the file now since
            //  all callers will be immediately destroying this FILE_INFO
            //  anyways.
            ErrorCode = RgFlushFileInfo(hDestinationKey-> lpFileInfo);

        }

        RgSmFreeMemory(g_RgNameBufferPtr);

    }

    RgSmFreeMemory(g_RgDataBufferPtr);

    return ErrorCode;

}

//
//  RgSaveKey
//
//  Worker routine for VMMRegSaveKey and VMMRegReplaceKey.  Saves all the keys
//  and values starting at hKey, which must point at a valid KEY structure, to
//  the location specified by lpFileName.  The file must not currently exist.
//

int
INTERNAL
RgSaveKey(
    HKEY hKey,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    HKEY hHiveKey;

    if (IsNullPtr(hHiveKey = RgCreateKeyHandle()))
        ErrorCode = ERROR_OUTOFMEMORY;

    else {

        //  Artificially increment the count, so the below destroy will work.
        RgIncrementKeyReferenceCount(hHiveKey);

        if ((ErrorCode = RgCreateFileInfoNew(&hHiveKey-> lpFileInfo, lpFileName,
            CFIN_SECONDARY)) == ERROR_SUCCESS) {

            if (((ErrorCode = RgInitRootKeyFromFileInfo(hHiveKey)) != ERROR_SUCCESS) ||
                ((ErrorCode = RgCopyBranch(hKey, hHiveKey)) != ERROR_SUCCESS)) {
                RgSetFileAttributes(hHiveKey-> lpFileInfo-> FileName,
                    FILE_ATTRIBUTE_NONE);
                RgDeleteFile(hHiveKey-> lpFileInfo-> FileName);
            }

            //  If successful, then RgCopyBranch has already flushed the file.
            RgDestroyFileInfo(hHiveKey-> lpFileInfo);

        }

        RgDestroyKeyHandle(hHiveKey);

    }

    return ErrorCode;

}

//
//  VMMRegSaveKey
//
//  See Win32 documentation of RegSaveKey.
//

LONG
REGAPI
VMMRegSaveKey(
    HKEY hKey,
    LPCSTR lpFileName,
    LPVOID lpSecurityAttributes
    )
{

    int ErrorCode;

    if (IsBadStringPtr(lpFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgSaveKey(hKey, lpFileName);

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(lpSecurityAttributes);

}

#ifdef WANT_REGREPLACEKEY

//
//  RgGetKeyName
//

LPSTR
INTERNAL
RgGetKeyName(
    HKEY hKey
    )
{

    LPSTR lpKeyName;
    LPKEY_RECORD lpKeyRecord;

    if (RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex, hKey->
        KeyRecordIndex, &lpKeyRecord) != ERROR_SUCCESS)
        lpKeyName = NULL;

    else {

        //  A registry is corrupt if we ever hit this.  We'll continue to
        //  allocate a buffer and let downstream code fail when we try to use
        //  the string.
        ASSERT(lpKeyRecord-> NameLength < MAXIMUM_SUB_KEY_LENGTH);

        if (!IsNullPtr(lpKeyName = (LPSTR) RgSmAllocMemory(lpKeyRecord->
            NameLength + 1))) {                         //  + terminating null
            MoveMemory(lpKeyName, lpKeyRecord-> Name, lpKeyRecord->
                NameLength);
            lpKeyName[lpKeyRecord-> NameLength] = '\0';
        }

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

    }

    return lpKeyName;

}

//
//  RgCreateRootKeyForFile
//
//  Creates a KEY and a FILE_INFO to access the specified file.
//

int
INTERNAL
RgCreateRootKeyForFile(
    LPHKEY lphKey,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    HKEY hKey;

    if (IsNullPtr(hKey = RgCreateKeyHandle()))
        ErrorCode = ERROR_OUTOFMEMORY;

    else {

        //  Artificially increment the count, so RgDestroyKeyHandle will work.
        RgIncrementKeyReferenceCount(hKey);

        if ((ErrorCode = RgCreateFileInfoExisting(&hKey-> lpFileInfo,
            lpFileName)) == ERROR_SUCCESS) {

            if ((ErrorCode = RgInitRootKeyFromFileInfo(hKey)) ==
                ERROR_SUCCESS) {
                *lphKey = hKey;
                return ERROR_SUCCESS;
            }

            RgDestroyFileInfo(hKey-> lpFileInfo);

        }

        RgDestroyKeyHandle(hKey);

    }

    return ErrorCode;

}

//
//  RgDestroyRootKeyForFile
//
//  Destroys the resources allocated by RgCreateRootKeyForFile.
//

VOID
INTERNAL
RgDestroyRootKeyForFile(
    HKEY hKey
    )
{

    RgDestroyFileInfo(hKey-> lpFileInfo);
    RgDestroyKeyHandle(hKey);

}

//
//  RgDeleteHiveFile
//
//  Deletes the specified hive file after clearing its file attributes.
//

BOOL
INTERNAL
RgDeleteHiveFile(
    LPCSTR lpFileName
    )
{

    RgSetFileAttributes(lpFileName, FILE_ATTRIBUTE_NONE);
    //  RgSetFileAttributes may fail, but try to delete the file anyway.
    return RgDeleteFile(lpFileName);

}

//
//  VMMRegReplaceKey
//
//  See Win32 documentation of RegReplaceKey.
//

LONG
REGAPI
VMMRegReplaceKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpNewFileName,
    LPCSTR lpOldFileName
    )
{

    int ErrorCode;
    HKEY hSubKey;
    LPKEYNODE lpKeynode;
    DWORD KeynodeIndex;
    HKEY hParentKey;
    char ReplaceFileName[MAX_PATH];
    BOOL fCreatedReplaceFile;
    HKEY hReplaceKey;
    HKEY hNewKey;
    HKEY hReplaceSubKey;
    LPSTR lpReplaceSubKey;

    if (IsBadOptionalStringPtr(lpSubKey, (UINT) -1) ||
        IsBadStringPtr(lpNewFileName, (UINT) -1) ||
        IsBadStringPtr(lpOldFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ErrorReturn;

    if ((ErrorCode = RgLookupKey(hKey, lpSubKey, &hSubKey, LK_OPEN)) !=
        ERROR_SUCCESS)
        goto ErrorReturn;

    //
    //  The provided key handle must an immediate child from the same backing
    //  store (not a hive) as either HKEY_LOCAL_MACHINE or HKEY_USERS.
    //

    if (RgLockInUseKeynode(hSubKey-> lpFileInfo, hSubKey-> KeynodeIndex,
        &lpKeynode) != ERROR_SUCCESS) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ErrorDestroySubKey;
    }

    KeynodeIndex = lpKeynode-> ParentIndex;
    RgUnlockKeynode(hSubKey-> lpFileInfo, hSubKey-> KeynodeIndex, FALSE);

    //  Find an open key on the parent check if it's HKEY_LOCAL_MACHINE or
    //  HKEY_USERS.  If not, bail out.  KeynodeIndex may be REG_NULL, but
    //  RgFindOpenKeyHandle handles that case.
    if (IsNullPtr(hParentKey = RgFindOpenKeyHandle(hSubKey-> lpFileInfo,
        KeynodeIndex)) || ((hParentKey != &g_RgLocalMachineKey) &&
        (hParentKey != &g_RgUsersKey))) {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto ErrorDestroySubKey;
    }

    //
    //  All parameters have been validated, so begin the real work of the API.
    //

    //  Because we'll be doing a file copy below, all changes must be flushed
    //  now.
    if ((ErrorCode = RgFlushFileInfo(hSubKey-> lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorDestroySubKey;

    //  Make a backup of the current contents of the subkey.
    if ((ErrorCode = RgSaveKey(hSubKey, lpOldFileName)) != ERROR_SUCCESS)
        goto ErrorDestroySubKey;

    RgGenerateAltFileName(hSubKey-> lpFileInfo-> FileName, ReplaceFileName, 'R');

    //  Check if the magic replacement file already exists and if not, create
    //  it.
    if (RgGetFileAttributes(ReplaceFileName) == (DWORD) -1) {
        if ((ErrorCode = RgCopyFile(hSubKey-> lpFileInfo-> FileName,
            ReplaceFileName)) != ERROR_SUCCESS)
            goto ErrorDeleteOldFile;
        fCreatedReplaceFile = TRUE;
    }

    else
        fCreatedReplaceFile = FALSE;

    if ((ErrorCode = RgCreateRootKeyForFile(&hNewKey, lpNewFileName)) !=
        ERROR_SUCCESS)
        goto ErrorDeleteReplaceFile;

    if ((ErrorCode = RgCreateRootKeyForFile(&hReplaceKey, ReplaceFileName)) !=
        ERROR_SUCCESS)
        goto ErrorDestroyNewRootKey;

    //  The original key that we were given may reference the subkey, so
    //  lpSubKey would be a NULL or empty string.  But we need the name that
    //  this subkey refers to, so we have to go back to the file to pull out
    //  the name.
    if (hKey != hSubKey)
        lpReplaceSubKey = (LPSTR) lpSubKey;

    else {
        //  We allocate this from the heap to reduce the requirements of an
        //  already strained stack.  If this fails, we're likely out of memory.
        //  Even if that's not why we failed, this is such an infrequent path
        //  that it's a good enough error code.
        if (IsNullPtr(lpReplaceSubKey = RgGetKeyName(hSubKey))) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto ErrorDestroyReplaceRootKey;
        }
    }

    //  Check if the specified subkey already exists and if it does, delete it.
    if (RgLookupKey(hReplaceKey, lpReplaceSubKey, &hReplaceSubKey, LK_OPEN) ==
        ERROR_SUCCESS) {
        RgDeleteKey(hReplaceSubKey);
        RgDestroyKeyHandle(hReplaceSubKey);
    }

    //  Create the specified subkey in the replacement registry and copy the
    //  new hive to that key.
    if ((ErrorCode = RgLookupKey(hReplaceKey, lpReplaceSubKey, &hReplaceSubKey,
        LK_CREATE)) == ERROR_SUCCESS) {

        //  If successful, tag the FILE_INFO so that on system exit, we'll go
        //  and rename the replacement file to actual filename.
        if ((ErrorCode = RgCopyBranch(hNewKey, hReplaceSubKey)) ==
            ERROR_SUCCESS)
            hKey-> lpFileInfo-> Flags |= FI_REPLACEMENTEXISTS;

        RgDestroyKeyHandle(hReplaceSubKey);

    }

    if (lpSubKey != lpReplaceSubKey)
        RgSmFreeMemory(lpReplaceSubKey);

ErrorDestroyReplaceRootKey:
    RgDestroyRootKeyForFile(hReplaceKey);

ErrorDestroyNewRootKey:
    RgDestroyRootKeyForFile(hNewKey);

ErrorDeleteReplaceFile:
    if (ErrorCode != ERROR_SUCCESS && fCreatedReplaceFile)
        RgDeleteHiveFile(ReplaceFileName);

ErrorDeleteOldFile:
    if (ErrorCode != ERROR_SUCCESS)
        RgDeleteHiveFile(lpOldFileName);

ErrorDestroySubKey:
    RgDestroyKeyHandle(hSubKey);

ErrorReturn:
    RgUnlockRegistry();

    return ErrorCode;

}

#ifdef VXD
#pragma VxD_SYSEXIT_CODE_SEG
#endif

//
//  RgReplaceFileOnSysExit
//
//  Essentially the same algorithm as rlReplaceFile from the Win95 registry
//  code with modifications for how file I/O is handled in this library.
//

int
INTERNAL
RgReplaceFileOnSysExit(
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    char ReplaceFileName[MAX_PATH];
    char SaveFileName[MAX_PATH];

    ErrorCode = ERROR_SUCCESS;

    if (RgGenerateAltFileName(lpFileName, ReplaceFileName, 'R') &&
        RgGetFileAttributes(ReplaceFileName) == (FILE_ATTRIBUTE_READONLY |
        FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) {

        //  If we were able to generate the replace file name, then we must be
        //  able to generate the save file name, so ignore the result.
        RgGenerateAltFileName(lpFileName, SaveFileName, 'S');
        RgDeleteHiveFile(SaveFileName);

        //  Preserve the current hive in case something fails below.
        if (!RgSetFileAttributes(lpFileName, FILE_ATTRIBUTE_NONE) ||
            !RgRenameFile(lpFileName, SaveFileName))
            ErrorCode = ERROR_REGISTRY_IO_FAILED;

        else {
            //  Now try to move the replacement in.
            if (!RgSetFileAttributes(ReplaceFileName, FILE_ATTRIBUTE_NONE) ||
                !RgRenameFile(ReplaceFileName, lpFileName)) {
                ErrorCode = ERROR_REGISTRY_IO_FAILED;
                RgRenameFile(SaveFileName, lpFileName);
            }
            else
                RgDeleteFile(SaveFileName);
        }

        RgSetFileAttributes(lpFileName, FILE_ATTRIBUTE_READONLY |
            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

    }

    return ErrorCode;

}

//
//  RgReplaceFileInfo
//
//  Called during registry detach to do any necessary file replacements as a
//  result of calling RegReplaceKey.
//

int
INTERNAL
RgReplaceFileInfo(
    LPFILE_INFO lpFileInfo
    )
{

    if (lpFileInfo-> Flags & FI_REPLACEMENTEXISTS)
        RgReplaceFileOnSysExit(lpFileInfo-> FileName);

    return ERROR_SUCCESS;

}

#endif // WANT_REGREPLACEKEY

#endif // WANT_HIVE_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regknode.c ===
//
//  REGKNODE.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

DECLARE_DEBUG_COUNT(g_RgKeynodeLockCount);

#define HAS_COMPACT_KEYNODES(lpfi)      ((lpfi)-> Flags & FI_VERSION20)

#define SIZEOF_KEYNODE_BLOCK(lpfi)      \
    ((HAS_COMPACT_KEYNODES(lpfi)) ? sizeof(KEYNODE_BLOCK) : sizeof(W95KEYNODE_BLOCK))

#define SIZEOF_FILE_KEYNODE(lpfi)       \
    ((HAS_COMPACT_KEYNODES(lpfi)) ? sizeof(KEYNODE) : sizeof(W95KEYNODE))

#define ROUND_UP(i, basesize) (((((i) + (basesize) - 1) / (basesize))) * (basesize))

#define BLOCK_DESC_GROW_SIZE 0x400

#define W95KEYNODES_PER_PAGE            (PAGESIZE / sizeof(W95KEYNODE))

typedef BOOL (INTERNAL *LPPROCESSKEYNODEPROC)(LPKEYNODE, LPW95KEYNODE);

//
//  RgOffsetToIndex
//

DWORD
INTERNAL
RgOffsetToIndex(
               DWORD W95KeynodeOffset
               )
{

    return (W95KeynodeOffset == REG_NULL) ? W95KeynodeOffset :
    (W95KeynodeOffset / sizeof(W95KEYNODE));

}

//
//  RgIndexToOffset
//

DWORD
INTERNAL
RgIndexToOffset(
               DWORD KeynodeIndex
               )
{

    if (IsNullKeynodeIndex(KeynodeIndex))
        return REG_NULL;

    else {
        if (KeynodeIndex >= 2 * W95KEYNODES_PER_PAGE) {
            DWORD dwUnroundedOff = (KeynodeIndex * sizeof(W95KEYNODE))
                                   + sizeof(W95KEYNODE)-1;
            DWORD dwRoundPage = ((dwUnroundedOff & PAGEMASK) / sizeof(W95KEYNODE))
                                * sizeof(W95KEYNODE);
            return ((dwUnroundedOff & ~PAGEMASK) + dwRoundPage);
        } else {
            return (((KeynodeIndex-1)*sizeof(W95KEYNODE))+sizeof(KEYNODE_HEADER));
        }
    }

}

//
//  RgPackKeynode
//
//  Packs the data from the provided W95KEYNODE to the KEYNODE structure.
//

BOOL
INTERNAL
RgPackKeynode(
             LPKEYNODE lpKeynode,
             LPW95KEYNODE lpW95Keynode
             )
{
    lpKeynode->Flags = 0;

    //  Don't use a switch statement here.  Apparently the compiler will treat
    //  lpW95Keynode->W95State as an integer, so the 16-bit compiler ends up truncating
    //  the value.

    if (lpW95Keynode->W95State == KNS_USED) {
        lpKeynode->Flags = KNF_INUSE;
        lpKeynode->ParentIndex = RgOffsetToIndex(lpW95Keynode->W95ParentOffset);
        lpKeynode->NextIndex = RgOffsetToIndex(lpW95Keynode->W95NextOffset);
        lpKeynode->ChildIndex = RgOffsetToIndex(lpW95Keynode->W95ChildOffset);
        lpKeynode->KeyRecordIndex = LOWORD(lpW95Keynode->W95DatablockAddress);
        lpKeynode->BlockIndex = HIWORD(lpW95Keynode->W95DatablockAddress);
        lpKeynode->Hash = (WORD)lpW95Keynode->W95Hash;
    }

    else if (lpW95Keynode->W95State == KNS_FREE || lpW95Keynode->W95State ==
             KNS_ALLFREE) {
        lpKeynode->FreeRecordSize = lpW95Keynode->W95FreeRecordSize;
        lpKeynode->NextIndex = RgOffsetToIndex(lpW95Keynode->W95NextFreeOffset);
        //  Review this later.  Previous versions of this code checked
        //  if the next index was REG_NULL and bailed out of the processing
        //  loop.  It's possible to have a registry with a free keynode sitting
        //  in the middle of some keynode block and that keynode is the last
        //  in the chain.  We don't want to bail out in those cases.
        //
        //  For now, just bail out if the free record size is greater than a
        //  couple keynodes indicating that this is probably the last free
        //  record and the last record of the keynode.
        if (lpKeynode-> FreeRecordSize > (sizeof(W95KEYNODE)*2))
            return TRUE;
    }

    else {
        DEBUG_OUT(("RgPackKeynode: Unrecognized state (%lx)\n", lpW95Keynode->
                   W95State));
    }

    return FALSE;
}

//
//  RgUnpackKeynode
//
//  Unpacks the data from the provided KEYNODE to the W95KEYNODE structure.
//

BOOL
INTERNAL
RgUnpackKeynode(
               LPKEYNODE lpKeynode,
               LPW95KEYNODE lpW95Keynode
               )
{

    if (lpKeynode->Flags & KNF_INUSE) {

        lpW95Keynode->W95State = KNS_USED;
        lpW95Keynode->W95ParentOffset = RgIndexToOffset(lpKeynode->ParentIndex);
        lpW95Keynode->W95NextOffset = RgIndexToOffset(lpKeynode->NextIndex);
        lpW95Keynode->W95ChildOffset = RgIndexToOffset(lpKeynode->ChildIndex);
        lpW95Keynode->W95Hash = lpKeynode->Hash;

        //  Handle Win95 registries that don't have a key record for the root
        //  key.  The datablock address must be REG_NULL for Win95 to work.
        lpW95Keynode->W95DatablockAddress = IsNullBlockIndex(lpKeynode->
                                                             BlockIndex) ? REG_NULL : MAKELONG(lpKeynode-> KeyRecordIndex,
                                                                                               lpKeynode-> BlockIndex);

    }

    else {

        lpW95Keynode->W95State = KNS_FREE;
        lpW95Keynode->W95FreeRecordSize = lpKeynode->FreeRecordSize;
        lpW95Keynode->W95NextFreeOffset = RgIndexToOffset(lpKeynode->NextIndex);

    }

    return FALSE;

}

//
//  RgProcessKeynodeBlock
//
//  The provided callback function is called for each pair of KEYNODE and
//  W95KEYNODE structures from the given keynode blocks.
//

VOID
INTERNAL
RgProcessKeynodeBlock(
                     DWORD dwStartOffset,
                     DWORD dwBlockSize,
                     LPKEYNODE_BLOCK lpKeynodeBlock,
                     LPW95KEYNODE_BLOCK lpW95KeynodeBlock,
                     LPPROCESSKEYNODEPROC lpfnProcessKeynode
                     )
{

    DWORD dwCurOffset;
    LPKEYNODE lpKeynode;
    LPW95KEYNODE lpW95Keynode;
    UINT SkipSize;

    dwCurOffset = dwStartOffset;
    lpW95Keynode = &lpW95KeynodeBlock->aW95KN[0];
    SkipSize = (dwStartOffset == 0) ? sizeof(KEYNODE_HEADER) : 0;

    for (;;) {

        lpW95Keynode = (LPW95KEYNODE)(((LPBYTE)lpW95Keynode)+SkipSize);
        dwCurOffset += SkipSize;

        if (dwCurOffset >= dwStartOffset+dwBlockSize) {
            goto Done;
        }
        lpKeynode = &lpKeynodeBlock->aKN[KN_INDEX_IN_BLOCK(RgOffsetToIndex(dwCurOffset))];
        while ((dwCurOffset < dwStartOffset+dwBlockSize) &&
               ((dwCurOffset >> PAGESHIFT) == 0) ||
               ((dwCurOffset >> PAGESHIFT) ==
                ((dwCurOffset + sizeof(W95KEYNODE)) >> PAGESHIFT))) {
            if (lpfnProcessKeynode(lpKeynode, lpW95Keynode)) {
                goto Done;
            }
            dwCurOffset += sizeof(W95KEYNODE);
            lpW95Keynode++;
            lpKeynode++;
        }
        //
        //  Compute the number of bytes to skip to get to the next page
        //
        SkipSize = PAGESIZE - (UINT) (dwCurOffset & PAGEMASK);
    }
    Done: {};

}

//
//  RgLockKeynode
//

int
INTERNAL
RgLockKeynode(
             LPFILE_INFO lpFileInfo,
             DWORD KeynodeIndex,
             LPKEYNODE FAR* lplpKeynode
             )
{

    int ErrorCode;
    UINT KeynodeBlockIndex;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    UINT KeynodeBlockSize;
    HFILE hFile;
    LPKEYNODE_BLOCK lpKeynodeBlock;
    LPW95KEYNODE_BLOCK lpW95KeynodeBlock;
    DWORD BlockOffset;
    UINT ReadBlockSize;

    KeynodeBlockIndex = KN_BLOCK_NUMBER(KeynodeIndex);

    if (KeynodeBlockIndex > lpFileInfo-> KeynodeBlockCount) {
        DEBUG_OUT(("RgLockKeynode: invalid keynode offset\n"));
        return ERROR_BADDB;
    }

    //
    //  Is the keynode block currently in memory?
    //

    lpKeynodeBlockInfo = RgIndexKeynodeBlockInfoPtr(lpFileInfo,
                                                    KeynodeBlockIndex);
    lpKeynodeBlock = lpKeynodeBlockInfo-> lpKeynodeBlock;

    if (IsNullPtr(lpKeynodeBlock)) {

        NOISE(("RgLockKeynode: "));
        NOISE((lpFileInfo-> FileName));
        NOISE((", block %d\n", KeynodeBlockIndex));

        if (IsNullPtr((lpKeynodeBlock = (LPKEYNODE_BLOCK)
                       RgAllocMemory(sizeof(KEYNODE_BLOCK)))))
            return ERROR_OUTOFMEMORY;

        KeynodeBlockSize = SIZEOF_KEYNODE_BLOCK(lpFileInfo);
        BlockOffset = (DWORD) KeynodeBlockIndex * KeynodeBlockSize;

        if (BlockOffset < lpFileInfo-> KeynodeHeader.FileKnSize) {

            ASSERT(!(lpFileInfo-> Flags & FI_VOLATILE));

            ReadBlockSize = (UINT) min(KeynodeBlockSize, (lpFileInfo->
                                                          KeynodeHeader.FileKnSize - BlockOffset));

            if ((hFile = RgOpenFile(lpFileInfo-> FileName, OF_READ)) ==
                HFILE_ERROR)
                goto CleanupAfterFileError;

            if (HAS_COMPACT_KEYNODES(lpFileInfo)) {

                if (!RgSeekFile(hFile, sizeof(VERSION20_HEADER_PAGE) +
                                BlockOffset))
                    goto CleanupAfterFileError;

                if (!RgReadFile(hFile, lpKeynodeBlock, ReadBlockSize))
                    goto CleanupAfterFileError;

            }

            else {

                if (!RgSeekFile(hFile, sizeof(FILE_HEADER) + BlockOffset))
                    goto CleanupAfterFileError;

                lpW95KeynodeBlock = (LPW95KEYNODE_BLOCK) RgLockWorkBuffer();

                if (!RgReadFile(hFile, lpW95KeynodeBlock, ReadBlockSize)) {
                    RgUnlockWorkBuffer(lpW95KeynodeBlock);
                    goto CleanupAfterFileError;
                }

                RgProcessKeynodeBlock(BlockOffset, ReadBlockSize,
                                      lpKeynodeBlock, lpW95KeynodeBlock, RgPackKeynode);

                RgUnlockWorkBuffer(lpW95KeynodeBlock);

            }

            RgCloseFile(hFile);

        }

        lpKeynodeBlockInfo-> lpKeynodeBlock = lpKeynodeBlock;
        lpKeynodeBlockInfo-> Flags = 0;
        lpKeynodeBlockInfo-> LockCount = 0;

    }

    *lplpKeynode = &lpKeynodeBlock-> aKN[KN_INDEX_IN_BLOCK(KeynodeIndex)];
    lpKeynodeBlockInfo-> Flags |= KBIF_ACCESSED;
    lpKeynodeBlockInfo-> LockCount++;

    INCREMENT_DEBUG_COUNT(g_RgKeynodeLockCount);
    return ERROR_SUCCESS;

    CleanupAfterFileError:
    ErrorCode = ERROR_REGISTRY_IO_FAILED;

    RgFreeMemory(lpKeynodeBlock);

    if (hFile != HFILE_ERROR)
        RgCloseFile(hFile);

    DEBUG_OUT(("RgLockKeynode() returning error %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgLockInUseKeynode
//
//  Wrapper for RgLockKeynode that guarantees that the returned keynode is
//  marked as being in-use.  If not, ERROR_BADDB is returned.
//

int
INTERNAL
RgLockInUseKeynode(
                  LPFILE_INFO lpFileInfo,
                  DWORD KeynodeIndex,
                  LPKEYNODE FAR* lplpKeynode
                  )
{

    int ErrorCode;

    if ((ErrorCode = RgLockKeynode(lpFileInfo, KeynodeIndex, lplpKeynode)) ==
        ERROR_SUCCESS) {
        if (!((*lplpKeynode)-> Flags & KNF_INUSE)) {
            DEBUG_OUT(("RgLockInUseKeynode: keynode unexpectedly not marked used\n"));
            RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
            ErrorCode = ERROR_BADDB;
        }
    }

    return ErrorCode;

}

//
//  RgUnlockKeynode
//

VOID
INTERNAL
RgUnlockKeynode(
               LPFILE_INFO lpFileInfo,
               DWORD KeynodeIndex,
               BOOL fMarkDirty
               )
{

    UINT KeynodeBlockIndex;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    KeynodeBlockIndex = KN_BLOCK_NUMBER(KeynodeIndex);
    ASSERT(KeynodeBlockIndex < lpFileInfo-> KeynodeBlockCount);

    lpKeynodeBlockInfo = RgIndexKeynodeBlockInfoPtr(lpFileInfo,
                                                    KeynodeBlockIndex);

    ASSERT(lpKeynodeBlockInfo-> LockCount > 0);
    lpKeynodeBlockInfo-> LockCount--;

    if (fMarkDirty) {
        lpKeynodeBlockInfo-> Flags |= KBIF_DIRTY;
        lpFileInfo-> Flags |= FI_DIRTY | FI_KEYNODEDIRTY;
        RgDelayFlush();
    }

    DECREMENT_DEBUG_COUNT(g_RgKeynodeLockCount);

}

//
//  RgAllocKeynode
//

int
INTERNAL
RgAllocKeynode(
              LPFILE_INFO lpFileInfo,
              LPDWORD lpKeynodeIndex,
              LPKEYNODE FAR* lplpKeynode
              )
{

    int ErrorCode;
    DWORD FreeKeynodeOffset;
    DWORD FreeKeynodeIndex;
    UINT FreeRecordSize;
    UINT ExtraPadding;
    UINT KeynodeBlockIndex;
    UINT AllocCount;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    LPKEYNODE lpKeynode;
    DWORD NextFreeKeynodeIndex;
    LPKEYNODE lpNextFreeKeynode;
    UINT KeynodeSize;

    FreeKeynodeIndex = lpFileInfo-> KeynodeHeader.FirstFreeIndex;

    //  If no more free keynodes exist, then we try to extend the keynode table
    //  to provide more entries.
    if (IsNullKeynodeIndex(FreeKeynodeIndex)) {

        if (HAS_COMPACT_KEYNODES(lpFileInfo)) {
            FreeKeynodeIndex = ROUND_UP(lpFileInfo-> CurTotalKnSize, PAGESIZE) /
                               sizeof(KEYNODE);
            FreeRecordSize = PAGESIZE;
            ExtraPadding = 0;
        }

        else {

            //  Handle the special case of a new file being created: for
            //  uncompacted keynode tables, the first offset is immediately
            //  after the keynode header and the size of the free record must
            //  account for  the size of this header.
            if (lpFileInfo-> CurTotalKnSize == sizeof(KEYNODE_HEADER)) {
                FreeKeynodeOffset = sizeof(KEYNODE_HEADER);
                //  Win95 compatiblity:  Same initial table size, plus
                //  causes us to stress the below special grow case.
                FreeRecordSize = PAGESIZE - sizeof(KEYNODE_HEADER) * 2;
                ExtraPadding = 0;
            }

            else {

                FreeKeynodeOffset = ROUND_UP(lpFileInfo-> CurTotalKnSize,
                                             PAGESIZE);
                FreeRecordSize = PAGESIZE;
                ExtraPadding = (UINT) (FreeKeynodeOffset - lpFileInfo->
                                       CurTotalKnSize);

                //  Handle the case of a keynode table with a non-integral
                //  number of pages.  We'll place the new free keynode at the
                //  top of the existing keynode table with a size including
                //  the remaining bytes on the page plus a new page (effectively
                //  the same as Win95).
                if (ExtraPadding > sizeof(W95KEYNODE) || FreeKeynodeOffset ==
                    PAGESIZE) {
                    //	Although this code will work for any non-integral
                    //	number of pages, it should ONLY occur for <4K tables.
                    ASSERT(FreeKeynodeOffset == PAGESIZE);
                    FreeRecordSize += ExtraPadding;
                    FreeKeynodeOffset = lpFileInfo-> CurTotalKnSize;
                    ExtraPadding = 0;
                }

            }

            FreeKeynodeIndex = RgOffsetToIndex(FreeKeynodeOffset);

        }

        KeynodeBlockIndex = KN_BLOCK_NUMBER(FreeKeynodeIndex);

        //  Check if lpKeynodeBlockInfo is too small to hold the info for a new
        //  keynode block.  If so, then we must grow it a bit.
        if (KeynodeBlockIndex >= lpFileInfo-> KeynodeBlockInfoAllocCount) {

            AllocCount = KeynodeBlockIndex + KEYNODE_BLOCK_INFO_SLACK_ALLOC;

            if (IsNullPtr((lpKeynodeBlockInfo = (LPKEYNODE_BLOCK_INFO)
                           RgSmReAllocMemory(lpFileInfo-> lpKeynodeBlockInfo, AllocCount *
                                             sizeof(KEYNODE_BLOCK_INFO)))))
                return ERROR_OUTOFMEMORY;

            ZeroMemory(lpKeynodeBlockInfo + lpFileInfo->
                       KeynodeBlockInfoAllocCount, (AllocCount - lpFileInfo->
                                                    KeynodeBlockInfoAllocCount) * sizeof(KEYNODE_BLOCK_INFO));

            lpFileInfo-> lpKeynodeBlockInfo = lpKeynodeBlockInfo;
            lpFileInfo-> KeynodeBlockInfoAllocCount = AllocCount;

        }

        if (KeynodeBlockIndex >= lpFileInfo-> KeynodeBlockCount)
            lpFileInfo-> KeynodeBlockCount = KeynodeBlockIndex + 1;

        lpFileInfo-> CurTotalKnSize += (FreeRecordSize + ExtraPadding);
        lpFileInfo-> Flags |= FI_EXTENDED;
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = FreeKeynodeIndex;

        if ((ErrorCode = RgLockKeynode(lpFileInfo, FreeKeynodeIndex,
                                       &lpKeynode)) != ERROR_SUCCESS)
            return ErrorCode;

        lpKeynode-> NextIndex = REG_NULL;
        lpKeynode-> Flags = 0;
        lpKeynode-> FreeRecordSize = FreeRecordSize;

    }

    else {
        if ((ErrorCode = RgLockKeynode(lpFileInfo, FreeKeynodeIndex,
                                       &lpKeynode)) != ERROR_SUCCESS)
            return ErrorCode;
    }

    NextFreeKeynodeIndex = lpKeynode-> NextIndex;
    KeynodeSize = SIZEOF_FILE_KEYNODE(lpFileInfo);

    //  If the free keynode record can be broken up into smaller chunks, then
    //  create another free record immediately after the one we're about to
    //  snag.
    if ((lpKeynode-> FreeRecordSize >= KeynodeSize * 2) &&
        (RgLockKeynode(lpFileInfo, FreeKeynodeIndex + 1, &lpNextFreeKeynode) ==
         ERROR_SUCCESS)) {

        //  Copy the next link from the current free keynode (likely REG_NULL).
        lpNextFreeKeynode-> NextIndex = NextFreeKeynodeIndex;
        lpNextFreeKeynode-> Flags = 0;
        lpNextFreeKeynode-> FreeRecordSize = lpKeynode-> FreeRecordSize -
                                             KeynodeSize;

        NextFreeKeynodeIndex = FreeKeynodeIndex + 1;
        RgUnlockKeynode(lpFileInfo, NextFreeKeynodeIndex, TRUE);

    }

    lpFileInfo-> KeynodeHeader.FirstFreeIndex = NextFreeKeynodeIndex;

    lpKeynode-> Flags |= KNF_INUSE;

    //  Mark the keynode block that holds this keynode dirty.
    lpKeynodeBlockInfo = RgIndexKeynodeBlockInfoPtr(lpFileInfo,
                                                    KN_BLOCK_NUMBER(FreeKeynodeIndex));
    lpKeynodeBlockInfo-> Flags |= KBIF_DIRTY;
    lpFileInfo-> Flags |= FI_DIRTY | FI_KEYNODEDIRTY;
    RgDelayFlush();

    //  WARNING:  The following two statements used to be above the block that
    //  dirtied the keynode.  The 16-bit compiler messed up and
    //  lpKeynodeBlockInfo ended up with a bogus offset thus corrupting random
    //  memory.  Be sure to trace through this function if you change it!
    *lpKeynodeIndex = FreeKeynodeIndex;
    *lplpKeynode = lpKeynode;

    return ERROR_SUCCESS;

}

//
//  RgFreeKeynode
//
//  Marks the specified keynode index free and adds it to the hive's free
//  keynode list.
//

int
INTERNAL
RgFreeKeynode(
             LPFILE_INFO lpFileInfo,
             DWORD KeynodeIndex
             )
{

    int ErrorCode;
    LPKEYNODE lpKeynode;

    if ((ErrorCode = RgLockKeynode(lpFileInfo, KeynodeIndex, &lpKeynode)) ==
        ERROR_SUCCESS) {

        lpKeynode-> Flags &= ~KNF_INUSE;
        lpKeynode-> NextIndex = lpFileInfo-> KeynodeHeader.FirstFreeIndex;
        lpKeynode-> FreeRecordSize = SIZEOF_FILE_KEYNODE(lpFileInfo);
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = KeynodeIndex;

        RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

    }

    return ErrorCode;

}

//
//  RgGetKnBlockIOInfo
//

VOID
INTERNAL
RgGetKnBlockIOInfo(
                  LPFILE_INFO lpFileInfo,
                  DWORD       BaseKeynodeIndex,
                  UINT FAR*   lpFileBlockSize,
                  LONG FAR*   lpFileOffset
                  )
{

    UINT FileBlockSize;
    DWORD FileOffset;
    DWORD BaseKeynodeOffset;

    if (HAS_COMPACT_KEYNODES(lpFileInfo)) {

        FileBlockSize = sizeof(KEYNODE_BLOCK);

        BaseKeynodeOffset = BaseKeynodeIndex * sizeof(KEYNODE);

        if (BaseKeynodeOffset + FileBlockSize > lpFileInfo-> CurTotalKnSize)
            FileBlockSize = (UINT) (lpFileInfo-> CurTotalKnSize -
                                    BaseKeynodeOffset);

        FileOffset = sizeof(VERSION20_HEADER_PAGE) + BaseKeynodeIndex *
                     sizeof(KEYNODE);

    }

    else {

        FileBlockSize = sizeof(W95KEYNODE_BLOCK);

        //  The first keynode block of an uncompacted keynode table should
        //  start writing AFTER the keynode header.
        if (BaseKeynodeIndex == 0) {
            BaseKeynodeIndex = RgOffsetToIndex(sizeof(KEYNODE_HEADER));
            FileBlockSize -= sizeof(KEYNODE_HEADER);
        }

        BaseKeynodeOffset = RgIndexToOffset(BaseKeynodeIndex);

        if (BaseKeynodeOffset + FileBlockSize > lpFileInfo-> CurTotalKnSize)
            FileBlockSize = (UINT) (lpFileInfo-> CurTotalKnSize -
                                    BaseKeynodeOffset);

        FileOffset = sizeof(FILE_HEADER) + BaseKeynodeOffset;

    }

    *lpFileBlockSize = FileBlockSize;
    *lpFileOffset = FileOffset;

}



int
_inline
RgCopyKeynodeBlock(
                  LPFILE_INFO lpFileInfo,
                  DWORD BaseIndex,
                  HFILE hSrcFile,
                  HFILE hDestFile
                  )
{
    UINT FileBlockSize;
    LONG FileOffset;
    RgGetKnBlockIOInfo(lpFileInfo, BaseIndex, &FileBlockSize, &FileOffset);
    return RgCopyFileBytes(hSrcFile,
                           FileOffset,
                           hDestFile,
                           FileOffset,
                           FileBlockSize);
}

//
//  RgWriteKeynodeBlock
//

int
INTERNAL
RgWriteKeynodeBlock(
                   LPFILE_INFO lpFileInfo,
                   DWORD BaseIndex,
                   HFILE hDestFile,
                   LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo
                   )
{
    int ErrorCode;
    UINT FileBlockSize;
    LONG FileOffset;
    LPW95KEYNODE_BLOCK lpW95KeynodeBlock;

    RgGetKnBlockIOInfo(lpFileInfo, BaseIndex, &FileBlockSize, &FileOffset);

    ErrorCode = ERROR_REGISTRY_IO_FAILED;       // Assume I/O fails
    if (!RgSeekFile(hDestFile, FileOffset)) {
        goto Exit;
    }
    if (HAS_COMPACT_KEYNODES(lpFileInfo)) {
        if (RgWriteFile(hDestFile, lpKeynodeBlockInfo->lpKeynodeBlock, FileBlockSize)) {
            ErrorCode = ERROR_SUCCESS;
        }
    } else {
        LPBYTE lpWriteBlock;
        lpW95KeynodeBlock = (LPW95KEYNODE_BLOCK) RgLockWorkBuffer();
        RgProcessKeynodeBlock(
                             BaseIndex * sizeof(W95KEYNODE),
                             FileBlockSize,
                             lpKeynodeBlockInfo->lpKeynodeBlock,
                             lpW95KeynodeBlock,
                             RgUnpackKeynode);
        lpWriteBlock = (LPBYTE)lpW95KeynodeBlock;
        if (BaseIndex == 0) {
            lpWriteBlock += sizeof(KEYNODE_HEADER);
        }
        if (RgWriteFile(hDestFile, lpWriteBlock, FileBlockSize)) {
            ErrorCode = ERROR_SUCCESS;
        }
        RgUnlockWorkBuffer(lpW95KeynodeBlock);
    }
    Exit:   ;
    return (ErrorCode);
}

//
//  RgWriteKeynodes
//

int
INTERNAL
RgWriteKeynodes(
               LPFILE_INFO lpFileInfo,
               HFILE hSrcFile,
               HFILE hDestFile
               )
{

    DWORD SavedRootIndex;
    DWORD SavedFreeIndex;
    DWORD SavedFileKnSize;
    BOOL fResult;
    UINT KeynodeBlockIndex;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    if ((hSrcFile == HFILE_ERROR) && !(lpFileInfo->Flags & FI_KEYNODEDIRTY))
        return ERROR_SUCCESS;

    NOISE(("writing keynodes of "));
    NOISE((lpFileInfo-> FileName));
    NOISE(("\n"));

    //
    //	Write out the keynode header.  If the keynodes are not compact then
    //	convert to offsets before writing.
    //

    if (!RgSeekFile(hDestFile, sizeof(FILE_HEADER)))
        return ERROR_REGISTRY_IO_FAILED;

    SavedFileKnSize = lpFileInfo-> KeynodeHeader.FileKnSize;
    SavedRootIndex = lpFileInfo-> KeynodeHeader.RootIndex;
    SavedFreeIndex = lpFileInfo-> KeynodeHeader.FirstFreeIndex;

    //  Write the real size of the keynode table to disk.
    lpFileInfo-> KeynodeHeader.FileKnSize = lpFileInfo-> CurTotalKnSize;

    //  Convert keynode indexes back to offsets temporarily for uncompacted
    //  keynode tables.
    if (!HAS_COMPACT_KEYNODES(lpFileInfo)) {
        lpFileInfo-> KeynodeHeader.RootIndex = RgIndexToOffset(lpFileInfo->
                                                               KeynodeHeader.RootIndex);
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = RgIndexToOffset(lpFileInfo->
                                                                    KeynodeHeader.FirstFreeIndex);
    }

    fResult = RgWriteFile(hDestFile, &lpFileInfo-> KeynodeHeader,
                          sizeof(KEYNODE_HEADER));

    lpFileInfo-> KeynodeHeader.FileKnSize = SavedFileKnSize;
    lpFileInfo-> KeynodeHeader.RootIndex = SavedRootIndex;
    lpFileInfo-> KeynodeHeader.FirstFreeIndex = SavedFreeIndex;

    if (!fResult)
        return ERROR_REGISTRY_IO_FAILED;

    //
    //	Now loop through each block.
    //

    lpKeynodeBlockInfo = lpFileInfo-> lpKeynodeBlockInfo;

    for (KeynodeBlockIndex = 0; KeynodeBlockIndex < lpFileInfo->
        KeynodeBlockCount; KeynodeBlockIndex++, lpKeynodeBlockInfo++) {

        DWORD BaseKeynodeIndex = KeynodeBlockIndex * KEYNODES_PER_BLOCK;

        if (!IsNullPtr(lpKeynodeBlockInfo-> lpKeynodeBlock)) {
            if (hSrcFile != HFILE_ERROR || lpKeynodeBlockInfo-> Flags &
                KBIF_DIRTY) {
                if (RgWriteKeynodeBlock(lpFileInfo, BaseKeynodeIndex, hDestFile,
                                        lpKeynodeBlockInfo) != ERROR_SUCCESS)
                    return ERROR_REGISTRY_IO_FAILED;
            }
        }

        else {
            if (hSrcFile != HFILE_ERROR) {
                if (RgCopyKeynodeBlock(lpFileInfo, BaseKeynodeIndex, hSrcFile,
                                       hDestFile) != ERROR_SUCCESS)
                    return ERROR_REGISTRY_IO_FAILED;
            }
        }

    }

    return ERROR_SUCCESS;

}

//
//  RgWriteKeynodesComplete
//
//  Called after a file has been successfully written.  We can now safely clear
//  all dirty flags and update our state information with the knowledge that
//  the file is in a consistent state.
//

VOID
INTERNAL
RgWriteKeynodesComplete(
                       LPFILE_INFO lpFileInfo
                       )
{

    UINT BlocksLeft;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    lpFileInfo-> Flags &= ~FI_KEYNODEDIRTY;
    lpFileInfo-> KeynodeHeader.FileKnSize = lpFileInfo-> CurTotalKnSize;

    for (BlocksLeft = lpFileInfo-> KeynodeBlockCount, lpKeynodeBlockInfo =
         lpFileInfo-> lpKeynodeBlockInfo; BlocksLeft > 0; BlocksLeft--,
        lpKeynodeBlockInfo++)
        lpKeynodeBlockInfo-> Flags &= ~KBIF_DIRTY;

}

//
//  RgSweepKeynodes
//
//  Makes a pass through all the present keynode blocks of the given FILE_INFO
//  structure and discards keynode blocks that have not been accessed since the
//  last sweep.
//

VOID
INTERNAL
RgSweepKeynodes(
               LPFILE_INFO lpFileInfo
               )
{

    UINT BlocksLeft;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    for (BlocksLeft = lpFileInfo-> KeynodeBlockCount, lpKeynodeBlockInfo =
         lpFileInfo-> lpKeynodeBlockInfo; BlocksLeft > 0; BlocksLeft--,
        lpKeynodeBlockInfo++) {

        if (!IsNullPtr(lpKeynodeBlockInfo-> lpKeynodeBlock)) {

            if (((lpKeynodeBlockInfo-> Flags & (KBIF_ACCESSED | KBIF_DIRTY)) ==
                 0) && (lpKeynodeBlockInfo-> LockCount == 0)) {
                RgFreeMemory(lpKeynodeBlockInfo-> lpKeynodeBlock);
                lpKeynodeBlockInfo-> lpKeynodeBlock = NULL;
            }

            lpKeynodeBlockInfo-> Flags &= ~KBIF_ACCESSED;

        }

    }

}

#ifdef VXD
    #pragma VxD_RARE_CODE_SEG
#endif

//
//  RgInitKeynodeInfo
//
//  Initializes fields in the provided FILE_INFO related to the keynode table.
//

int
INTERNAL
RgInitKeynodeInfo(
                 LPFILE_INFO lpFileInfo
                 )
{

    UINT KeynodeBlockSize;
    UINT BlockCount;
    UINT AllocCount;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    KeynodeBlockSize = SIZEOF_KEYNODE_BLOCK(lpFileInfo);
    BlockCount = (UINT) ((DWORD) (lpFileInfo-> KeynodeHeader.FileKnSize +
                                  KeynodeBlockSize - 1) / (DWORD) KeynodeBlockSize);
    AllocCount = BlockCount + KEYNODE_BLOCK_INFO_SLACK_ALLOC;

    if (IsNullPtr((lpKeynodeBlockInfo = (LPKEYNODE_BLOCK_INFO)
                   RgSmAllocMemory(AllocCount * sizeof(KEYNODE_BLOCK_INFO)))))
        return ERROR_OUTOFMEMORY;

    ZeroMemory(lpKeynodeBlockInfo, AllocCount * sizeof(KEYNODE_BLOCK_INFO));
    lpFileInfo-> lpKeynodeBlockInfo = lpKeynodeBlockInfo;
    lpFileInfo-> KeynodeBlockCount = BlockCount;
    lpFileInfo-> KeynodeBlockInfoAllocCount = AllocCount;

    lpFileInfo-> KeynodeHeader.Flags &= ~(KHF_DIRTY | KHF_EXTENDED |
                                          KHF_HASCHECKSUM);

    //  Convert file offsets to index values for uncompressed files
    if (!HAS_COMPACT_KEYNODES(lpFileInfo)) {
        lpFileInfo-> KeynodeHeader.RootIndex = RgOffsetToIndex(lpFileInfo->
                                                               KeynodeHeader.RootIndex);
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = RgOffsetToIndex(lpFileInfo->
                                                                    KeynodeHeader.FirstFreeIndex);
    }

    lpFileInfo-> CurTotalKnSize = lpFileInfo-> KeynodeHeader.FileKnSize;

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regkylst.h ===
//
//  REGKYLST.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGKYLST_
#define _REGKYLST_

BOOL
INTERNAL
RgAllocKeyHandleStructures(
    VOID
    );

VOID
INTERNAL
RgFreeKeyHandleStructures(
    VOID
    );

HKEY
INTERNAL
RgCreateKeyHandle(
    VOID
    );

VOID
INTERNAL
RgDestroyKeyHandle(
    HKEY hKey
    );

int
INTERNAL
RgValidateAndConvertKeyHandle(
    LPHKEY lphKey
    );

VOID
INTERNAL
RgIncrementKeyReferenceCount(
    HKEY hKey
    );

HKEY
INTERNAL
RgFindOpenKeyHandle(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    );

VOID
INTERNAL
RgInvalidateKeyHandles(
    LPFILE_INFO lpFileInfo,
    UINT PredefinedKeyIndex
    );

extern KEY g_RgLocalMachineKey;
extern KEY g_RgUsersKey;
#ifdef WANT_DYNKEY_SUPPORT
extern KEY g_RgDynDataKey;
#endif

#endif // _REGKYLST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regkylst.c ===
//
//  REGKYLST.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Declares the predefined key structures and manages dynamic HKEY structures.
//

#include "pch.h"
#include <limits.h>

//  We would rather just have one definition a
#ifdef WANT_DYNKEY_SUPPORT
#define INITED_PREDEFINED_KEY(index, flags)             \
    {                                                   \
        KEY_SIGNATURE,                                  \
        KEYF_PREDEFINED | KEYF_INVALID | (flags),       \
        0,                                              \
        NULL,                                           \
        REG_NULL,                                       \
        REG_NULL,                                       \
        0,                                              \
        0,                                              \
        (index),                                        \
        NULL,                                           \
        NULL,                                           \
        (UINT) -1,                                      \
        REG_NULL,                                       \
        NULL                                            \
    }
#else
#define INITED_PREDEFINED_KEY(index, flags)             \
    {                                                   \
        KEY_SIGNATURE,                                  \
        KEYF_PREDEFINED | KEYF_INVALID | (flags),       \
        0,                                              \
        NULL,                                           \
        REG_NULL,                                       \
        REG_NULL,                                       \
        0,                                              \
        0,                                              \
        (index),                                        \
        NULL,                                           \
        NULL,                                           \
        (UINT) -1,                                      \
        REG_NULL                                        \
    }
#endif

KEY g_RgLocalMachineKey =
    INITED_PREDEFINED_KEY(INDEX_LOCAL_MACHINE, KEYF_HIVESALLOWED);
KEY g_RgUsersKey = INITED_PREDEFINED_KEY(INDEX_USERS, KEYF_HIVESALLOWED);
#ifdef WANT_DYNKEY_SUPPORT
KEY g_RgDynDataKey = INITED_PREDEFINED_KEY(INDEX_DYN_DATA, 0);
#endif

HKEY g_RgPredefinedKeys[] = {
    NULL,                                       //  HKEY_CLASSES_ROOT
    NULL,                                       //  HKEY_CURRENT_USER
    &g_RgLocalMachineKey,                       //  HKEY_LOCAL_MACHINE
    &g_RgUsersKey,                              //  HKEY_USERS
    NULL,                                       //  HKEY_PERFORMANCE_DATA
    NULL,                                       //  HKEY_CURRENT_CONFIG
#ifdef WANT_DYNKEY_SUPPORT
    &g_RgDynDataKey,                            //  HKEY_DYN_DATA
#endif
};

#define NUMBER_PREDEF_KEYS      (sizeof(g_RgPredefinedKeys) / sizeof(HKEY))

#ifdef WANT_STATIC_KEYS
#define NUMBER_STATIC_KEYS              32
HKEY g_RgStaticKeyArray = NULL;
#endif

//  List of all dynamically allocated keys.
HKEY g_RgDynamicKeyList = NULL;

const char g_RgClassesRootSubKey[] = "SOFTWARE\\CLASSES";
const char g_RgCurrentUserSubKey[] = ".DEFAULT";

#ifdef WANT_STATIC_KEYS
//
//  RgAllocKeyHandleStructures
//

BOOL
INTERNAL
RgAllocKeyHandleStructures(
    VOID
    )
{

    UINT Index;
    HKEY hKey;

    ASSERT(IsNullPtr(g_RgStaticKeyArray));
    ASSERT(IsNullPtr(g_RgDynamicKeyList));

    //
    //  Allocate and initialize the static key table.
    //

    g_RgStaticKeyArray = RgSmAllocMemory(NUMBER_STATIC_KEYS * sizeof(KEY));

    if (IsNullPtr(g_RgStaticKeyArray))
        return FALSE;

    for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
        Index--, hKey++) {
        hKey-> Signature = KEY_SIGNATURE;
        hKey-> Flags = KEYF_STATIC | KEYF_INVALID;
        hKey-> ReferenceCount = 0;
    }

    return TRUE;

}
#endif

#ifdef WANT_FULL_MEMORY_CLEANUP
//
//  RgFreeKeyHandleStructures
//
//  Releases resources allocated by RgAllocKeyHandleStructures.
//

VOID
INTERNAL
RgFreeKeyHandleStructures(
    VOID
    )
{

    HKEY hTempKey;
    HKEY hKey;

    //
    //  Delete all of the dynamically allocated keys.
    //

    hKey = g_RgDynamicKeyList;

    if (!IsNullPtr(hKey)) {
        do {
            hTempKey = hKey;
            hKey = hKey-> lpNext;
#ifdef WANT_DYNKEY_SUPPORT
            if (!IsNullPtr(hTempKey-> pProvider))
                RgSmFreeMemory(hTempKey-> pProvider);
#endif
            RgSmFreeMemory(hTempKey);
        }   while (hKey != g_RgDynamicKeyList);
    }

    g_RgDynamicKeyList = NULL;

#ifdef WANT_STATIC_KEYS
    //
    //  Delete the static key table.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {
        RgSmFreeMemory(g_RgStaticKeyArray);
        g_RgStaticKeyArray = NULL;
    }
#endif

}
#endif

//
//  RgCreateKeyHandle
//
//  Allocates one KEY structure, initializes some of its members, and links it
//  to the list of open key handles.
//

HKEY
INTERNAL
RgCreateKeyHandle(
    VOID
    )
{

#ifdef WANT_STATIC_KEYS
    UINT Index;
#endif
    HKEY hKey;

#ifdef WANT_STATIC_KEYS
    //
    //  Check if any keys are available in the static pool.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {

        for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
            Index--, hKey++) {
            if (hKey-> Flags & KEYF_INVALID) {
                ASSERT(hKey-> ReferenceCount == 0);
                hKey-> Flags &= ~(KEYF_INVALID | KEYF_DELETED |
                    KEYF_ENUMKEYCACHED);
                return hKey;
            }
        }

    }
#endif

    //
    //  Must allocate a dynamic key.  Initialize it and add it to our list.
    //

    hKey = (HKEY) RgSmAllocMemory(sizeof(KEY));

    if (!IsNullPtr(hKey)) {

        hKey-> Signature = KEY_SIGNATURE;
        hKey-> Flags = 0;
        hKey-> ReferenceCount = 0;
#ifdef WANT_DYNKEY_SUPPORT
        hKey-> pProvider = NULL;
#endif

        if (IsNullPtr(g_RgDynamicKeyList)) {
            hKey-> lpPrev = hKey;
            hKey-> lpNext = hKey;
        }

        else if (hKey != g_RgDynamicKeyList) {
            hKey-> lpNext = g_RgDynamicKeyList;
            hKey-> lpPrev = g_RgDynamicKeyList-> lpPrev;
            hKey-> lpPrev-> lpNext = hKey;
            g_RgDynamicKeyList-> lpPrev = hKey;
        }

        g_RgDynamicKeyList = hKey;

    }

    return hKey;

}

//
//  RgDeleteKeyHandle
//
//  Decrements the reference count on the given key handle.  If the count
//  reaches zero and the key was dynamically allocated, then the key is unlinked
//  from the key list and the key is freed.
//

VOID
INTERNAL
RgDestroyKeyHandle(
    HKEY hKey
    )
{

    ASSERT(!IsNullPtr(hKey));

    //	Don't allow the reference count to underflow for predefined keys or
    //	keys marked "never delete".
    if (hKey-> ReferenceCount > 0)
        hKey-> ReferenceCount--;

    if (hKey-> ReferenceCount == 0) {

        if (!(hKey-> Flags & (KEYF_PREDEFINED | KEYF_NEVERDELETE))) {

#ifdef WANT_STATIC_KEYS
            if (hKey-> Flags & KEYF_STATIC) {
                hKey-> Flags |= KEYF_INVALID;
                return;
            }
#endif

            if (hKey == hKey-> lpNext)
                g_RgDynamicKeyList = NULL;

            else {

                hKey-> lpPrev-> lpNext = hKey-> lpNext;
                hKey-> lpNext-> lpPrev = hKey-> lpPrev;

                if (hKey == g_RgDynamicKeyList)
                    g_RgDynamicKeyList = hKey-> lpNext;

            }

#ifdef WANT_DYNKEY_SUPPORT
            if (!IsNullPtr(hKey-> pProvider))
                RgSmFreeMemory(hKey-> pProvider);
#endif

            hKey-> Signature = 0;
            RgSmFreeMemory(hKey);

        }

    }

}

//
//  RgValidateAndConvertKeyHandle
//
//  Verifies the the given key handle is valid.  If the handle is one of the
//  special predefined constants, then it is converted to the handle of the
//  real KEY structure.
//

int
INTERNAL
RgValidateAndConvertKeyHandle(
    LPHKEY lphKey
    )
{

    HKEY hKey;
    UINT Index;
    HKEY hRootKey;
    LPCSTR lpSubKey;

    hKey = *lphKey;

    //
    //  Check if this is one of the predefined key handles.
    //

    if ((DWORD) HKEY_CLASSES_ROOT <= (DWORD) hKey &&
        (DWORD) hKey < (DWORD) HKEY_CLASSES_ROOT + NUMBER_PREDEF_KEYS) {

        Index = (UINT) ((DWORD) hKey - (DWORD) HKEY_CLASSES_ROOT);
        hKey = g_RgPredefinedKeys[Index];

        //  If the predefined handle is not valid, we'll try to (re)open it for
        //  use.  This isn't pretty, but in the typical case, this code path is
        //  only executed once per handle.
        if (IsNullPtr(hKey) || (hKey-> Flags & KEYF_DELETED)) {

            if (Index == INDEX_CLASSES_ROOT) {
                hRootKey = &g_RgLocalMachineKey;
                lpSubKey = g_RgClassesRootSubKey;
            }

            else if (Index == INDEX_CURRENT_USER) {
                hRootKey = &g_RgUsersKey;
                lpSubKey = g_RgCurrentUserSubKey;
            }

			else if (Index == INDEX_USERS) {
				goto ReturnKeyAndSuccess;
			}

            else
                return ERROR_BADKEY;

            //  Extremely rare case: somebody has deleted one of the predefined
            //  key paths.  We'll clear the predefined bit on this key and throw
            //  it away.
            if (!IsNullPtr(hKey)) {
                g_RgPredefinedKeys[Index] = NULL;
                hKey-> Flags &= ~KEYF_PREDEFINED;
                RgDestroyKeyHandle(hKey);
            }

            //  If the base root key for this predefined key is valid, attempt
            //  to open the key.  Mark the key as predefined so that bad apps
            //  can't close a key more times then it has opened it.
            if (!(hRootKey-> Flags & KEYF_INVALID) && RgLookupKey(hRootKey,
                lpSubKey, &hKey, LK_CREATE) == ERROR_SUCCESS) {
                g_RgPredefinedKeys[Index] = hKey;
                hKey-> Flags |= KEYF_PREDEFINED;
                hKey-> PredefinedKeyIndex = (BYTE) Index;
                goto ReturnKeyAndSuccess;
            }

            return ERROR_BADKEY;

        }

ReturnKeyAndSuccess:
        *lphKey = hKey;
        return (hKey-> Flags & KEYF_INVALID) ? ERROR_BADKEY : ERROR_SUCCESS;

    }

    else {

        if (IsBadHugeReadPtr(hKey, sizeof(KEY)) || hKey-> Signature !=
            KEY_SIGNATURE || (hKey-> Flags & KEYF_INVALID))
            return ERROR_BADKEY;

        return (hKey-> Flags & KEYF_DELETED) ? ERROR_KEY_DELETED :
            ERROR_SUCCESS;

    }

}

//
//  RgIncrementKeyReferenceCount
//
//  Safely increments the reference count of the specified KEY.  If the count
//  overflows, then the key is marked as "never delete" since the usage count
//  is now unknown.
//

VOID
INTERNAL
RgIncrementKeyReferenceCount(
    HKEY hKey
    )
{

    if (hKey-> ReferenceCount != UINT_MAX)
        hKey-> ReferenceCount++;
    else {
        if (!(hKey-> Flags & KEYF_NEVERDELETE)) {
            TRACE(("RgIncrementKeyReferenceCount: handle %lx has overflowed\n",
                hKey));
        }
        hKey-> Flags |= KEYF_NEVERDELETE;
    }

}

//
//  RgFindOpenKeyHandle
//
//  Searches the list of currently opened keys for a key that refers to the same
//  FILE_INFO structure and keynode offset.  If found, the HKEY is returned, or
//  if not, NULL.
//

HKEY
INTERNAL
RgFindOpenKeyHandle(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    )
{

    UINT Index;
    LPHKEY lphKey;
    HKEY hKey;

    ASSERT(!IsNullKeynodeIndex(KeynodeIndex));

    //
    //  Check if this is one of the predefined key handles.
    //

    for (Index = NUMBER_PREDEF_KEYS, lphKey = g_RgPredefinedKeys; Index > 0;
        Index--, lphKey++) {

        hKey = *lphKey;

        if (!IsNullPtr(hKey) && hKey-> lpFileInfo == lpFileInfo && hKey->
            KeynodeIndex == KeynodeIndex && !(hKey-> Flags & (KEYF_DELETED |
            KEYF_INVALID)))
            return hKey;

    }

#ifdef WANT_STATIC_KEYS
    //
    //  Check if this is one of the static key handles.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {

        for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
            Index--, hKey++) {
            if (hKey-> lpFileInfo == lpFileInfo && hKey-> KeynodeIndex ==
                KeynodeIndex && !(hKey-> Flags & (KEYF_DELETED | KEYF_INVALID)))
                return hKey;
        }

    }
#endif

    //
    //  Check if this is one of the dynamic key handles.
    //

    if (!IsNullPtr((hKey = g_RgDynamicKeyList))) {

        do {

            if (hKey-> KeynodeIndex == KeynodeIndex && hKey-> lpFileInfo ==
                lpFileInfo && !(hKey-> Flags & KEYF_DELETED))
                return hKey;

            hKey = hKey-> lpNext;

        }   while (hKey != g_RgDynamicKeyList);

    }

    return NULL;

}

//
//  RgInvalidateKeyHandles
//
//  Generic routine to invalidate key handles based on a set of criteria.
//  If any key handle meets any of the given criteria, then it's marked invalid.
//

VOID
INTERNAL
RgInvalidateKeyHandles(
    LPFILE_INFO lpFileInfo,
    UINT PredefinedKeyIndex
    )
{

    UINT Index;
    LPHKEY lphKey;
    HKEY hKey;

    //
    //  Invalidate predefined key handles.
    //

    for (Index = NUMBER_PREDEF_KEYS, lphKey = g_RgPredefinedKeys; Index > 0;
        Index--, lphKey++) {

        hKey = *lphKey;

        if (!IsNullPtr(hKey)) {
            if (hKey-> lpFileInfo == lpFileInfo || hKey-> PredefinedKeyIndex ==
                (BYTE) PredefinedKeyIndex)
                hKey-> Flags |= (KEYF_DELETED | KEYF_INVALID);
        }

    }

#ifdef WANT_STATIC_KEYS
    //
    //  Invalidate static key handles.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {

        for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
            Index--, hKey++) {
            if (hKey-> lpFileInfo == lpFileInfo || hKey-> PredefinedKeyIndex ==
                PredefinedKeyIndex)
                hKey-> Flags |= (KEYF_DELETED | KEYF_INVALID);
        }

    }
#endif

    //
    //  Invalidate dynamic key handles.
    //

    if (!IsNullPtr((hKey = g_RgDynamicKeyList))) {

        do {

            if (hKey-> lpFileInfo == lpFileInfo || hKey-> PredefinedKeyIndex ==
                (BYTE) PredefinedKeyIndex)
                hKey-> Flags |= (KEYF_DELETED | KEYF_INVALID);

            hKey = hKey-> lpNext;

        }   while (hKey != g_RgDynamicKeyList);

    }

}

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  VMMRegMapPredefKeyToKey
//

LONG
REGAPI
VMMRegMapPredefKeyToKey(
    HKEY hTargetKey,
    HKEY hPredefKey
    )
{

    int ErrorCode;
    UINT PredefinedKeyIndex;
    HKEY hOldKey;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hTargetKey)) ==
        ERROR_SUCCESS) {

        if ((hPredefKey == HKEY_CURRENT_USER && hTargetKey->
            PredefinedKeyIndex == INDEX_USERS) || (hPredefKey ==
            HKEY_CURRENT_CONFIG && hTargetKey-> PredefinedKeyIndex ==
            INDEX_LOCAL_MACHINE)) {

            PredefinedKeyIndex = (UINT) ((DWORD) hPredefKey - (DWORD)
                HKEY_CLASSES_ROOT);

            hOldKey = g_RgPredefinedKeys[PredefinedKeyIndex];

            if (!IsNullPtr(hOldKey)) {

                //  Invalidate open handles based off the existing predefined
                //  key handle.  Win95 behavior.
                RgInvalidateKeyHandles((LPFILE_INFO) -1L, (BYTE)
                    PredefinedKeyIndex);

                hOldKey-> Flags &= ~KEYF_PREDEFINED;
                RgDestroyKeyHandle(hOldKey);

            }

            hTargetKey-> Flags |= KEYF_PREDEFINED;
            RgIncrementKeyReferenceCount(hTargetKey);
            g_RgPredefinedKeys[PredefinedKeyIndex] = hTargetKey;

        }

        else {
            DEBUG_OUT(("VMMRegMapPredefKeyToKey: invalid hTargetKey\n"));
            ErrorCode = ERROR_BADKEY;
        }

    }

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regnckey.h ===
//
//  REGNCKEY.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGNCKEY_
#define _REGNCKEY_

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
typedef struct _NOTIFY_CHANGE {
    struct _NOTIFY_CHANGE FAR* lpNextNotifyChange;
    DWORD ThreadId;
    HANDLE hEvent;
    DWORD KeynodeIndex;
    DWORD NotifyFilter;
}   NOTIFY_CHANGE, FAR* LPNOTIFY_CHANGE;

//  Map the bWatchSubtree flag to this bit tucked into the NotifyFilter field.
#define REG_NOTIFY_WATCH_SUBTREE        0x40
//  Only signal events that are watching the specified keynode index, not
//  parents of the keynode index.
#define REG_NOTIFY_NO_WATCH_SUBTREE     0x80

VOID
INTERNAL
RgSignalWaitingNotifies(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    UINT NotifyEvent
    );
#else
#define RgSignalWaitingNotifies(lpfi, ki, nevt)
#endif

#endif // _REGNCKEY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regqkey.c ===
//
//  REGQKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegQueryInfoKey.
//

#include "pch.h"

//
//  VMMRegQueryInfoKey
//
//  See Win32 documentation of RegQueryInfoKey.  When VXD is defined, this
//  function does not take all of the parameters that we end up ignoring anyway
//  (class, security, timestamp parameters).
//

#ifdef VXD
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueName,
    LPDWORD lpcbMaxValueData
    )
#else
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueName,
    LPDWORD lpcbMaxValueData,
    LPVOID lpcbSecurityDescriptor,
    LPVOID lpftLastWriteTime
    )
#endif
{

    int ErrorCode;
    LPVALUE_RECORD lpValueRecord;
    UINT cItems;
    DWORD cbValueData;
    DWORD cbMaxValueData;
    DWORD cbStringLen;
    DWORD cbMaxStringLen;

    if (IsBadHugeOptionalWritePtr(lpcSubKeys, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcbMaxSubKeyLen, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcValues, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcbMaxValueName, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcbMaxValueData, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

    //
    //  Compute cValues, cbMaxValueName, and cbMaxValueData.
    //

    if (!IsNullPtr(lpcValues) || !IsNullPtr(lpcbMaxValueName) ||
        !IsNullPtr(lpcbMaxValueData)) {

        cItems = 0;
        cbMaxStringLen = 0;
        cbMaxValueData = 0;

        while ((ErrorCode = RgLookupValueByIndex(hKey, cItems,
            &lpValueRecord)) == ERROR_SUCCESS) {

            cItems++;

            if (lpValueRecord-> NameLength > cbMaxStringLen)
                cbMaxStringLen = lpValueRecord-> NameLength;

            //  RgCopyFromValueRecord will handle static and dynamic keys...
            ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL,
                NULL, NULL, &cbValueData);

            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

            if (ErrorCode != ERROR_SUCCESS)
                goto ReturnErrorCode;

            if (cbValueData > cbMaxValueData)
                cbMaxValueData = cbValueData;

        }

        if (ErrorCode == ERROR_NO_MORE_ITEMS) {

            if (!IsNullPtr(lpcValues))
                *lpcValues = cItems;

            if (!IsNullPtr(lpcbMaxValueName))
                *lpcbMaxValueName = cbMaxStringLen;

            if (!IsNullPtr(lpcbMaxValueData))
                *lpcbMaxValueData = cbMaxValueData;

            ErrorCode = ERROR_SUCCESS;

        }

    }

    //
    //  Compute cSubKeys and cbMaxSubKeyLen.  Somewhat painful because we must
    //  touch each child keynode and datablock.
    //

    if (!IsNullPtr(lpcSubKeys) || !IsNullPtr(lpcbMaxSubKeyLen)) {

        cItems = 0;
        cbMaxStringLen = 0;

        while ((ErrorCode = RgLookupKeyByIndex(hKey, cItems, NULL,
            &cbStringLen)) == ERROR_SUCCESS) {

            cItems++;

            if (cbStringLen > cbMaxStringLen)
                cbMaxStringLen = cbStringLen;

        }

        if (ErrorCode == ERROR_NO_MORE_ITEMS) {

            if (!IsNullPtr(lpcSubKeys))
                *lpcSubKeys = cItems;

            if (!IsNullPtr(lpcbMaxSubKeyLen))
                *lpcbMaxSubKeyLen = cbMaxStringLen;

            ErrorCode = ERROR_SUCCESS;

        }

    }

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

#ifndef VXD
    UNREFERENCED_PARAMETER(lpClass);
    UNREFERENCED_PARAMETER(lpcbClass);
    UNREFERENCED_PARAMETER(lpReserved);
    UNREFERENCED_PARAMETER(lpcbMaxClassLen);
    UNREFERENCED_PARAMETER(lpcbSecurityDescriptor);
    UNREFERENCED_PARAMETER(lpftLastWriteTime);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regmem.h ===
//
//  REGMEM.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGMEM_
#define _REGMEM_

LPVOID
INTERNAL
RgAllocMemory(
    UINT cbBytes
    );

LPVOID
INTERNAL
RgReAllocMemory(
    LPVOID lpMemory,
    UINT cbBytes
    );

#ifdef DEBUG
VOID
INTERNAL
RgFreeMemory(
    LPVOID
    );
#else
#ifdef VXD
#define RgFreeMemory(lpv)           (FreePages(lpv))
#else
#define RgFreeMemory(lpv)           (FreeBytes(lpv))
#endif
#endif

//  Use the RgSm*Memory macros to allocate small chunks of memory off the heap.
//  For the VMM mode registry, the Rg*Memory functions will allocate pages,
//  while the RgSm*Memory functions will allocate from the heap.  For all other
//  modes, the two sets are equivalent.
#if defined(VXD)
#define RgSmAllocMemory             AllocBytes
#define RgSmFreeMemory              FreeBytes
#define RgSmReAllocMemory           ReAllocBytes
#else
#define RgSmAllocMemory             RgAllocMemory
#define RgSmFreeMemory              RgFreeMemory
#define RgSmReAllocMemory           RgReAllocMemory
#endif

#endif // _REGMEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regqmval.c ===
//
//  REGQMVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegQueryMultipleValues and supporting functions.
//

#include "pch.h"

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

#ifdef IS_32

//
//  VMMRegQueryMultipleValues
//
//  See Win32 documentation of RegQueryMultipleValues.  However, the Win95
//  implementation breaks many of the rules that are described in the
//  documentation:
//      *  num_vals is a count of VALENT structures, not a size in bytes.
//      *  data is not DWORD aligned in lpValueBuffer.
//      *  if lpValueBuffer is too small, lpValueBuffer is not filled to the
//         size specified by lpdwTotalSize.
//
//  All of this plus dynamic keys makes this an extremely ugly routine, but
//  every attempt was made to be compatible with the Win95 semantics.
//

LONG
REGAPI
VMMRegQueryMultipleValues(
    HKEY hKey,
    PVALENT val_list,
    DWORD num_vals,
    LPSTR lpValueBuffer,
    LPDWORD lpdwTotalSize
    )
{

    int ErrorCode;
    PVALENT pCurrentValent;
    DWORD Counter;
    DWORD BufferSize;
    DWORD RequiredSize;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;
    LPSTR lpCurrentBuffer;
#ifdef WANT_DYNKEY_SUPPORT
    PVALCONTEXT pValueContext;
    PINTERNAL_PROVIDER pProvider;
    PPVALUE pProviderValue;
#endif

    if (IsBadHugeReadPtr(val_list, sizeof(VALENT) * num_vals))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeWritePtr(lpdwTotalSize, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeWritePtr(lpValueBuffer, *lpdwTotalSize))
        return ERROR_INVALID_PARAMETER;

    for (Counter = num_vals, pCurrentValent = val_list; Counter > 0; Counter--,
        pCurrentValent++) {
        if (IsBadStringPtr(pCurrentValent-> ve_valuename, (UINT) -1))
            return ERROR_INVALID_PARAMETER;
    }

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

#ifdef WANT_DYNKEY_SUPPORT
    //  Check if this a dynamic key that has a "get all" atomic callback.  If
    //  the dynamic key just has "get one" callback, then we'll fall into the
    //  non-dynamic case.
    if ((hKey-> PredefinedKeyIndex == INDEX_DYN_DATA) && !IsNullPtr(hKey->
        pProvider-> ipi_R0_allvals)) {

        pProvider = hKey-> pProvider;

        pValueContext = RgSmAllocMemory(sizeof(struct val_context) * num_vals);

        if (IsNullPtr(pValueContext)) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto ReturnErrorCode;
        }

        //
        //  Compute the required buffer size to hold all the value data and
        //  check it against the provided buffer size.
        //

        RequiredSize = 0;

        for (Counter = 0, pCurrentValent = val_list; Counter < num_vals;
            Counter++, pCurrentValent++) {

            if ((ErrorCode = RgLookupValueByName(hKey, pCurrentValent->
                ve_valuename, &lpKeyRecord, &lpValueRecord)) != ERROR_SUCCESS)
                goto ReturnErrorCode;

            //  The value data contains only part of a PROVIDER structure.
            pProviderValue = CONTAINING_RECORD(&lpValueRecord-> Name +
                lpValueRecord-> NameLength, PVALUE, pv_valuelen);

            pValueContext[Counter].value_context = pProviderValue->
                pv_value_context;
            pCurrentValent-> ve_type = pProviderValue-> pv_type;

            if (hKey-> Flags & KEYF_PROVIDERHASVALUELENGTH) {

                //  Must zero it so that some providers don't try to stomp on
                //  lpData.
                pCurrentValent-> ve_valuelen = 0;

                ErrorCode = pProvider-> ipi_R0_1val(pProvider-> ipi_key_context,
                    &pValueContext[Counter], 1, NULL, &(pCurrentValent->
                    ve_valuelen), 0);

                //  Providers should really be returning either of these errors
                //  to us.
                ASSERT((ErrorCode == ERROR_SUCCESS) || (ErrorCode ==
                    ERROR_MORE_DATA));

            }

            else {
                pCurrentValent-> ve_valuelen = pProviderValue-> pv_valuelen;
            }

            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

            pCurrentValent-> ve_valueptr = (DWORD) NULL;
            RequiredSize += pCurrentValent-> ve_valuelen;

        }

        BufferSize = *lpdwTotalSize;
        *lpdwTotalSize = RequiredSize;

        if (BufferSize < RequiredSize)
            ErrorCode = ERROR_MORE_DATA;

        else if (pProvider-> ipi_R0_allvals(pProvider-> ipi_key_context,
            pValueContext, num_vals, lpValueBuffer, lpdwTotalSize, 0) !=
            ERROR_SUCCESS)
            ErrorCode = ERROR_CANTREAD;

        else {

            ErrorCode = ERROR_SUCCESS;

            //  Copy the pointers to the value data back to the user's buffer.
            //  Don't ask me why, but the Win95 code copies the value length
            //  back again if the provider is maintaining it.
            for (Counter = 0, pCurrentValent = val_list; Counter < num_vals;
                Counter++, pCurrentValent++) {
                pCurrentValent-> ve_valueptr = (DWORD)
                    pValueContext[Counter].val_buff_ptr;
                if (hKey-> Flags & KEYF_PROVIDERHASVALUELENGTH)
                    pCurrentValent-> ve_valuelen = pValueContext[Counter].valuelen;
            }

        }

        RgSmFreeMemory(pValueContext);

        goto ReturnErrorCode;

    }
#endif

    //
    //  First pass over the value names checks for the existence of the value
    //  and its size.  We check the total size against the provided buffer size
    //  and bail out if necessary.
    //

    RequiredSize = 0;

    for (Counter = num_vals, pCurrentValent = val_list; Counter > 0; Counter--,
        pCurrentValent++) {

        if ((ErrorCode = RgLookupValueByName(hKey, pCurrentValent->
            ve_valuename, &lpKeyRecord, &lpValueRecord)) != ERROR_SUCCESS)
            goto ReturnErrorCode;

        ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL,
            &(pCurrentValent-> ve_type), NULL, &(pCurrentValent-> ve_valuelen));

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

        if (ErrorCode != ERROR_SUCCESS)
            goto ReturnErrorCode;

        pCurrentValent-> ve_valueptr = (DWORD) NULL;
        RequiredSize += pCurrentValent-> ve_valuelen;

    }

    BufferSize = *lpdwTotalSize;
    *lpdwTotalSize = RequiredSize;

    if (BufferSize < RequiredSize) {
        ErrorCode = ERROR_MORE_DATA;
        goto ReturnErrorCode;
    }

    //
    //  Second pass copies the value data back to the user's buffer now that we
    //  know the buffer is large enough to contain the data.
    //

    lpCurrentBuffer = lpValueBuffer;

    for (Counter = num_vals, pCurrentValent = val_list; Counter > 0; Counter--,
        pCurrentValent++) {

        if ((ErrorCode = RgLookupValueByName(hKey, pCurrentValent->
            ve_valuename, &lpKeyRecord, &lpValueRecord)) != ERROR_SUCCESS)
            goto ReturnErrorReading;

        ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL, NULL,
            lpCurrentBuffer, &(pCurrentValent-> ve_valuelen));

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

        if (ErrorCode != ERROR_SUCCESS) {
ReturnErrorReading:
            TRAP();                     //  Registry is internally inconsistent?
            ErrorCode = ERROR_CANTREAD;
            goto ReturnErrorCode;
        }

        pCurrentValent-> ve_valueptr = (DWORD) lpCurrentBuffer;
        lpCurrentBuffer += pCurrentValent-> ve_valuelen;

    }

    ErrorCode = ERROR_SUCCESS;

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regmem.c ===
//
//  REGMEM.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Upper-level memory management functions that discards unlocked memory blocks
//  as required to fulfill allocation requests.
//
//  For the ring zero version of this code, only large requests will call these
//  functions.  For most registry files, these requests will already be an
//  integral number of pages, so it's best just to do page allocations.  Small
//  allocations, such as key handles,  will use the heap services and not go
//  through this code.
//
//  For all other models of this code, all memory requests will go through this
//  code and memory is allocated from the heap.
//

#include "pch.h"

DECLARE_DEBUG_COUNT(g_RgMemoryBlockCount);

//  For the ring zero version, only large allocations that should be page
//  aligned will pass through these functions.
#ifdef VXD

//  Converts number of bytes to number of whole pages.
#define ConvertToMemoryUnits(cb)        \
    ((((cb) + (PAGESIZE - 1)) & ~(PAGESIZE - 1)) >> PAGESHIFT)

//  Generates smaller code if we don't just make this a macro...
LPVOID
INTERNAL
RgAllocMemoryUnits(
    UINT nPages
    )
{

    return AllocPages(nPages);

}

//  Generates smaller code if we don't just make this a macro...
LPVOID
INTERNAL
RgReAllocMemoryUnits(
    LPVOID lpMemory,
    UINT nPages
    )
{

    return ReAllocPages(lpMemory, nPages);

}

#define RgFreeMemoryUnits           FreePages

//  For non-ring zero version of the registry code, all allocations will funnel
//  through these functions.  All allocations are off the heap.
#else
#define ConvertToMemoryUnits(cb)    (cb)
#define RgAllocMemoryUnits          AllocBytes
#define RgReAllocMemoryUnits        ReAllocBytes
#define RgFreeMemoryUnits           FreeBytes
#endif

//
//  RgAllocMemory
//

LPVOID
INTERNAL
RgAllocMemory(
    UINT cbBytes
    )
{

    UINT MemoryUnits;
    LPVOID lpMemory;

    ASSERT(cbBytes > 0);

    MemoryUnits = ConvertToMemoryUnits(cbBytes);

    //  Can we allocate from available memory?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all old memory blocks?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    //  The first sweep will have cleared all the access bits of every memory
    //  block.  This sweep will effectively discard all unlocked blocks.
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked and clean memory blocks?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    //  Flush out every dirty memory block and sweep again.
    RgEnumFileInfos(RgFlushFileInfo);
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked memory blocks?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    DEBUG_OUT(("RgAllocMemory failure\n"));
    //  Return lpMemory, which must be NULL if we're here, generates smaller
    //  code.
    return lpMemory;                    //  Must be NULL if we're here

}

//
//  RgReAllocMemory
//

LPVOID
INTERNAL
RgReAllocMemory(
    LPVOID lpOldMemory,
    UINT cbBytes
    )
{

    UINT MemoryUnits;
    LPVOID lpMemory;

    ASSERT(!IsNullPtr(lpOldMemory));
    ASSERT(cbBytes > 0);

    MemoryUnits = ConvertToMemoryUnits(cbBytes);

    //  Can we allocate from available memory?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all old memory blocks?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    //  The first sweep will have cleared all the access bits of every memory
    //  block.  This sweep will effectively discard all unlocked blocks.
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked and clean memory blocks?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    //  Flush out every dirty memory block and sweep again.
    RgEnumFileInfos(RgFlushFileInfo);
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked memory blocks?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    DEBUG_OUT(("RgReAllocMemory failure\n"));
    //  Return lpMemory, which must be NULL if we're here, generates smaller
    //  code.
    return lpMemory;

}

#ifdef DEBUG
//
//  RgFreeMemory
//

VOID
INTERNAL
RgFreeMemory(
    LPVOID lpMemory
    )
{

    ASSERT(!IsNullPtr(lpMemory));

    DECREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);

#ifdef ZEROONFREE
    ZeroMemory(lpMemory, MemorySize(lpMemory));
#endif

    RgFreeMemoryUnits(lpMemory);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regqval.c ===
//
//  REGQVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegQueryValue, RegQueryValueEx and supporting functions.
//

#include "pch.h"

//
//  RgLookupValueByName
//
//  Searches for the value with the specified name and returns a pointer to its
//  KEY_RECORD and VALUE_RECORD.
//

int
INTERNAL
RgLookupValueByName(
                   HKEY hKey,
                   LPCSTR lpValueName,
                   LPKEY_RECORD FAR* lplpKeyRecord,
                   LPVALUE_RECORD FAR* lplpValueRecord
                   )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    UINT ValueNameLength;
    LPVALUE_RECORD lpValueRecord;
    UINT ValuesRemaining;

    //  Handle Win95 registries that don't have a key record for the root key.
    if (IsNullBlockIndex(hKey-> BlockIndex))
        return ERROR_CANTREAD16_FILENOTFOUND32;

    if ((ErrorCode = RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex,
                                     hKey-> KeyRecordIndex, &lpKeyRecord)) == ERROR_SUCCESS) {

        ValueNameLength = (IsNullPtr(lpValueName) ? 0 : (UINT)
                           StrLen(lpValueName));

        lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpKeyRecord-> Name +
                                          lpKeyRecord-> NameLength + lpKeyRecord-> ClassLength);

        ValuesRemaining = lpKeyRecord-> ValueCount;

        while (ValuesRemaining) {

            if (lpValueRecord-> NameLength == ValueNameLength &&
                (ValueNameLength == 0 || RgStrCmpNI(lpValueName, lpValueRecord->
                                                    Name, ValueNameLength) == 0)) {
                *lplpKeyRecord = lpKeyRecord;
                *lplpValueRecord = lpValueRecord;
                return ERROR_SUCCESS;
            }

            lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpValueRecord->
                                              Name + lpValueRecord-> NameLength + lpValueRecord->
                                              DataLength);

            ValuesRemaining--;

        }

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

        ErrorCode = ERROR_CANTREAD16_FILENOTFOUND32;

    }

    return ErrorCode;

}

//
//  RgCopyFromValueRecord
//
//  Shared routine for RegQueryValue and RegEnumValue.  Copies the information
//  from the VALUE_RECORD to the user-provided buffers.  All parameters should
//  have already been validated.
//
//  Because all parameters have been validated, if lpData is valid, then
//  lpcbData MUST be valid.
//

int
INTERNAL
RgCopyFromValueRecord(
                     HKEY hKey,
                     LPVALUE_RECORD lpValueRecord,
                     LPSTR lpValueName,
                     LPDWORD lpcbValueName,
                     LPDWORD lpType,
                     LPBYTE lpData,
                     LPDWORD lpcbData
                     )
{

    int ErrorCode;
    UINT BytesToTransfer;
#ifdef WANT_DYNKEY_SUPPORT
    PINTERNAL_PROVIDER pProvider;
    PPVALUE pProviderValue;
    struct val_context ValueContext;
#endif

#ifdef WANT_DYNKEY_SUPPORT
    if (hKey-> PredefinedKeyIndex == INDEX_DYN_DATA) {

        pProvider = hKey-> pProvider;

        if (IsNullPtr(pProvider))
            return ERROR_CANTOPEN;

        //  The value data contains only part of a PROVIDER structure.
        pProviderValue = CONTAINING_RECORD(&lpValueRecord-> Name +
                                           lpValueRecord-> NameLength, PVALUE, pv_valuelen);

        if (!IsNullPtr(lpType))
            *lpType = pProviderValue-> pv_type;

        if (!(hKey-> Flags & KEYF_PROVIDERHASVALUELENGTH)) {

            BytesToTransfer = pProviderValue-> pv_valuelen;

            if (IsNullPtr(lpData))
                goto ValueDataNotNeeded;

            if (BytesToTransfer > *lpcbData) {
                *lpcbData = BytesToTransfer;
                return ERROR_MORE_DATA;
            }

            //	Win95 compatibility: now that we know the required number of
            //	bytes, validate the data buffer.
            if (IsBadHugeWritePtr(lpData, BytesToTransfer))
                return ERROR_INVALID_PARAMETER;

        }

        ValueContext.value_context = pProviderValue-> pv_value_context;

        if (!IsNullPtr(lpcbData)) {

            //  Zero *lpcbData, if we aren't actually copying any data back to
            //  the user's buffer.  This keeps some providers from stomping on
            //  lpData.
            if (IsNullPtr(lpData))
                *lpcbData = 0;

            if ((ErrorCode = (int) pProvider-> ipi_R0_1val(pProvider->
                                                           ipi_key_context, &ValueContext, 1, lpData, lpcbData, 0)) !=
                ERROR_SUCCESS) {

                //  Win95 compatibility: the old code ignored any errors if
                //  lpData is NULL.  The below ASSERT will verify that we aren't
                //  dropping errors.
                if (!IsNullPtr(lpData))
                    return ErrorCode;

                ASSERT((ErrorCode == ERROR_SUCCESS) || (ErrorCode ==
                                                        ERROR_MORE_DATA));

            }

        }

        goto CopyValueName;

    }
#endif

    if (!IsNullPtr(lpType))
        *lpType = lpValueRecord-> DataType;

    BytesToTransfer = lpValueRecord-> DataLength;

    //  The terminating null is not stored in the value record.
    if (lpValueRecord-> DataType == REG_SZ)
        BytesToTransfer++;

    //
    //  Win32 compatibilty: lpData must be filled in before lpValueName.  Word
    //  NT and Excel NT broke when we validated lpValueName and failed the call
    //  before filling in lpData which was valid.  Don't rearrange this code!
    //

    if (!IsNullPtr(lpData)) {

        ErrorCode = ERROR_SUCCESS;

        if (BytesToTransfer > *lpcbData) {
            *lpcbData = BytesToTransfer;
            return ERROR_MORE_DATA;
        }

        //  Win95 compatibility: now that we know the required number of bytes,
        //  validate the data buffer.
        else if (IsBadHugeWritePtr(lpData, BytesToTransfer))
            return ERROR_INVALID_PARAMETER;

        else {

            MoveMemory(lpData, &lpValueRecord-> Name + lpValueRecord->
                       NameLength, lpValueRecord-> DataLength);

            if (lpValueRecord-> DataType == REG_SZ)
                lpData[lpValueRecord-> DataLength] = '\0';

        }

    }

#ifdef WANT_DYNKEY_SUPPORT
    ValueDataNotNeeded:
#endif
    if (!IsNullPtr(lpcbData))
        *lpcbData = BytesToTransfer;

#ifdef WANT_DYNKEY_SUPPORT
    CopyValueName:
#endif
    if (!IsNullPtr(lpValueName)) {

        ErrorCode = ERROR_SUCCESS;

        if (*lpcbValueName <= lpValueRecord-> NameLength) {

            //  Although we will not touch the lpData buffer if it's too small
            //  to hold the value data, we will partially fill lpValueName if
            //  it's too small.
            ErrorCode = ERROR_MORE_DATA;

            if (*lpcbValueName == 0)
                return ErrorCode;

            BytesToTransfer = (UINT) *lpcbValueName - 1;

        }

        else
            BytesToTransfer = lpValueRecord-> NameLength;

        MoveMemory(lpValueName, &lpValueRecord-> Name, BytesToTransfer);
        lpValueName[BytesToTransfer] = '\0';

        //  Does not include terminating null.
        *lpcbValueName = BytesToTransfer;

        return ErrorCode;

    }

    return ERROR_SUCCESS;

}

//
//  VMMRegQueryValueEx
//
//  See Win32 documentation of RegQueryValueEx.
//

LONG
REGAPI
VMMRegQueryValueEx(
                  HKEY hKey,
                  LPCSTR lpValueName,
                  LPDWORD lpReserved,
                  LPDWORD lpType,
                  LPBYTE lpData,
                  LPDWORD lpcbData
                  )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;

    if (IsBadOptionalStringPtr(lpValueName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeOptionalWritePtr(lpType, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (IsNullPtr(lpcbData)) {
        if (!IsNullPtr(lpData))
            return ERROR_INVALID_PARAMETER;
    }

    else {
        //  Win95 compatibility: don't validate lpData is of size *lpcbData.
        //  Instead of validating the entire buffer, we'll validate just the
        //  required buffer length in RgCopyFromValueRecord.
        if (IsBadHugeWritePtr(lpcbData, sizeof(DWORD)))
            return ERROR_INVALID_PARAMETER;
    }

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {

        if ((ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
                                             &lpValueRecord)) == ERROR_SUCCESS) {

            ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL,
                                              lpType, lpData, lpcbData);
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

        }

        else if (ErrorCode == ERROR_CANTREAD16_FILENOTFOUND32) {

            //
            //  Windows 95 compatibility problem.  If the "value
            //  record" didn't exist in Windows 3.1, then it acted like it was
            //  really a null byte REG_SZ string.  This should have only been
            //  done in RegQueryValue, but we're stuck with it now...
            //

            if (IsNullPtr(lpValueName) || *lpValueName == '\0') {

                if (!IsNullPtr(lpType))
                    *lpType = REG_SZ;

                if (!IsNullPtr(lpData) && *lpcbData > 0)
                    *lpData = 0;

                if (!IsNullPtr(lpcbData))
                    *lpcbData = sizeof(char);

                ErrorCode = ERROR_SUCCESS;

            }

        }

    }

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(lpReserved);

}

//
//  VMMRegQueryValue
//
//  See Win32 documentation of RegQueryValue.
//

LONG
REGAPI
VMMRegQueryValue(
                HKEY hKey,
                LPCSTR lpSubKey,
                LPBYTE lpData,
                LPDWORD lpcbData
                )
{

    LONG ErrorCode;
    HKEY hSubKey;

    if ((ErrorCode = RgCreateOrOpenKey(hKey, lpSubKey, &hSubKey, LK_OPEN)) ==
        ERROR_SUCCESS) {
        ErrorCode = VMMRegQueryValueEx(hSubKey, NULL, NULL, NULL, lpData,
                                       lpcbData);
        VMMRegCloseKey(hSubKey);
    }

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regmisc.c ===
//
//  REGMISC.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

//
//  RgChecksum
//

DWORD
INTERNAL
RgChecksum(
    LPVOID lpBuffer,
    UINT ByteCount
    )
{

    LPDWORD lpdwBuffer;
    DWORD Checksum;

    lpdwBuffer = (LPDWORD) lpBuffer;
    ByteCount >>= 2;
    Checksum = 0;

    while (ByteCount) {
        Checksum += *lpdwBuffer++;
        ByteCount--;
    }

    return Checksum;

}

//
//  RgHashString
//
//  Simple hash computation of a counted string.  All characters less than 0x80
//  0x80 and all DBCS characters are added up.
//

DWORD
INTERNAL
RgHashString(
    LPCSTR lpString,
    UINT Length
    )
{

    DWORD Hash;
    UINT Byte;

    Hash = 0;

    while (Length) {

        Byte = *((LPBYTE) lpString)++;

        if (IsDBCSLeadByte((BYTE) Byte)) {

            Hash += Byte;
            Length--;
            Hash += (*((LPBYTE) lpString)++);

        }

        else if (Byte < 0x80)
            Hash += ToUpper(Byte);

        Length--;

    }

    return Hash;

}

//
//  RgStrCmpNI
//

int
INTERNAL
RgStrCmpNI(
    LPCSTR lpString1,
    LPCSTR lpString2,
    UINT Length
    )
{

    int Difference;

    while (Length) {

        if (IsDBCSLeadByte(*lpString1)) {

            if ((Difference = *lpString1 - *lpString2) != 0)
                return Difference;

            lpString1++;
            lpString2++;
            Length--;

            if (Length == 0)
                break;

            if ((Difference = *lpString1 - *lpString2) != 0)
                return Difference;

        }

        else if ((Difference = (int) ToUpper(*lpString1) -
            (int) ToUpper(*lpString2)) != 0)
            return Difference;

        lpString1++;
        lpString2++;
        Length--;

    }

    return 0;
}

//
//  RgCopyFileBytes
//
//  Copies the specified number of bytes from the source to the destination
//  starting at the specified offsets in each file.
//

int
INTERNAL
RgCopyFileBytes(
    HFILE hSourceFile,
    LONG SourceOffset,
    HFILE hDestinationFile,
    LONG DestinationOffset,
    DWORD cbSize
    )
{

    int ErrorCode;
    LPVOID lpWorkBuffer;
    UINT cbBytesThisPass;

    ASSERT(hSourceFile != HFILE_ERROR);
    ASSERT(hDestinationFile != HFILE_ERROR);

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    lpWorkBuffer = RgLockWorkBuffer();

    if (!RgSeekFile(hSourceFile, SourceOffset))
        goto ErrorUnlockWorkBuffer;

    if (!RgSeekFile(hDestinationFile, DestinationOffset))
        goto ErrorUnlockWorkBuffer;

    while (cbSize) {

        cbBytesThisPass = (UINT) ((DWORD) min(cbSize, SIZEOF_WORK_BUFFER));

        if (!RgReadFile(hSourceFile, lpWorkBuffer, cbBytesThisPass)) {
            TRAP();
            goto ErrorUnlockWorkBuffer;
        }

        RgYield();

        if (!RgWriteFile(hDestinationFile, lpWorkBuffer, cbBytesThisPass)) {
            TRAP();
            goto ErrorUnlockWorkBuffer;
        }

        RgYield();

        cbSize -= cbBytesThisPass;

    }

    ErrorCode = ERROR_SUCCESS;

ErrorUnlockWorkBuffer:
    RgUnlockWorkBuffer(lpWorkBuffer);
    return ErrorCode;

}

//
//  RgGenerateAltFileName
//

BOOL
INTERNAL
RgGenerateAltFileName(
    LPCSTR lpFileName,
    LPSTR lpAltFileName,
    char ExtensionChar
    )
{

    LPSTR lpString;

    StrCpy(lpAltFileName, lpFileName);
    lpString = lpAltFileName + StrLen(lpAltFileName) - 3;

    *lpString++ = '~';
    *lpString++ = '~';
    *lpString = ExtensionChar;

    return TRUE;

}

#ifdef VXD

#pragma VxD_RARE_CODE_SEG

//
//  RgCopyFile
//

int
INTERNAL
RgCopyFile(
    LPCSTR lpSourceFile,
    LPCSTR lpDestinationFile
    )
{

    int ErrorCode;
    HFILE hSourceFile;
    HFILE hDestinationFile;
    DWORD FileSize;

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    if ((hSourceFile = RgOpenFile(lpSourceFile, OF_READ)) != HFILE_ERROR) {

        if ((FileSize = RgGetFileSize(hSourceFile)) != (DWORD) -1) {

            if ((hDestinationFile = RgCreateFile(lpDestinationFile)) !=
                HFILE_ERROR) {

                ErrorCode = RgCopyFileBytes(hSourceFile, 0, hDestinationFile, 0,
                    FileSize);

                RgCloseFile(hDestinationFile);

                if (ErrorCode != ERROR_SUCCESS)
                    RgDeleteFile(lpDestinationFile);

            }

        }

        RgCloseFile(hSourceFile);

    }

    return ErrorCode;

}

#endif // VXD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\regsval.c ===
//
//  REGSVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegSetValue, RegSetValueEx and supporting functions.
//

#include "pch.h"

//
//  RgReAllocKeyRecord
//

int
INTERNAL
RgReAllocKeyRecord(
    HKEY hKey,
    DWORD Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    )
{

    int ErrorCode;
    LPKEY_RECORD lpOldKeyRecord;
    UINT BlockIndex;
    UINT KeyRecordIndex;
    LPDATABLOCK_INFO lpOldDatablockInfo;
    LPKEYNODE lpKeynode;

    if (Length > MAXIMUM_KEY_RECORD_SIZE) {
        TRACE(("key record too big\n"));
        return ERROR_OUTOFMEMORY;
    }

    lpOldKeyRecord = *lplpKeyRecord;

    BlockIndex = HIWORD(lpOldKeyRecord-> DatablockAddress);
    KeyRecordIndex = LOWORD(lpOldKeyRecord-> DatablockAddress);

    //
    //  Check if we can simply extend this key record by taking space from an
    //  adjacent free record.
    //

    if (RgExtendKeyRecord(hKey-> lpFileInfo, BlockIndex, (UINT) Length,
        lpOldKeyRecord) == ERROR_SUCCESS)
        return ERROR_SUCCESS;

    //
    //  Check if there's enough space in the datablock lpCurrKeyRecord is in to
    //  contain a key record of the specified size.  If so, then we don't have
    //  to dirty the keynode.
    //

    if (RgAllocKeyRecordFromDatablock(hKey-> lpFileInfo, BlockIndex,
        (UINT) Length, lplpKeyRecord) == ERROR_SUCCESS) {

        //  After an alloc, we must refetch these pointers because they may be
        //  invalid.
        lpOldDatablockInfo = RgIndexDatablockInfoPtr(hKey-> lpFileInfo,
            BlockIndex);
        lpOldKeyRecord = RgIndexKeyRecordPtr(lpOldDatablockInfo,
            KeyRecordIndex);

        //  Transfer all the data to the new record, except for the allocated
        //  size which is already correctly set.
        MoveMemory(&(*lplpKeyRecord)-> DatablockAddress, &lpOldKeyRecord->
            DatablockAddress, SmallDword(lpOldKeyRecord-> RecordSize) -
            sizeof(DWORD));

        RgFreeKeyRecord(lpOldDatablockInfo, lpOldKeyRecord);

        //  Update the key record table to point to the new key record.
        lpOldDatablockInfo-> lpKeyRecordTable[KeyRecordIndex] =
            (KEY_RECORD_TABLE_ENTRY) ((LPBYTE) (*lplpKeyRecord) -
            (LPBYTE) lpOldDatablockInfo-> lpDatablockHeader);

        return ERROR_SUCCESS;

    }

    //
    //  Check if we can allocate a key record from another datablock.  If so,
    //  then copy the key to the other datablock and update the keynode.
    //

    if (RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
        &lpKeynode) == ERROR_SUCCESS) {

        if ((ErrorCode = RgAllocKeyRecord(hKey-> lpFileInfo, (UINT) Length,
            lplpKeyRecord)) == ERROR_SUCCESS) {

            //  After an alloc, we must refetch these pointers because they may
            //  be invalid.
            lpOldDatablockInfo = RgIndexDatablockInfoPtr(hKey-> lpFileInfo,
                BlockIndex);
            lpOldKeyRecord = RgIndexKeyRecordPtr(lpOldDatablockInfo,
                KeyRecordIndex);

            //  Transfer all the data to the new record, except for the
            //  allocated size which is already correctly set.
            MoveMemory(&(*lplpKeyRecord)-> RecordSize, &lpOldKeyRecord->
                RecordSize, SmallDword(lpOldKeyRecord-> RecordSize) -
                (sizeof(DWORD) * 2));

            RgFreeKeyRecord(lpOldDatablockInfo, lpOldKeyRecord);
            RgFreeKeyRecordIndex(lpOldDatablockInfo, KeyRecordIndex);

            //  Unlock the old datablock.
            RgUnlockDatablock(hKey-> lpFileInfo, BlockIndex, TRUE);

            //  Update the open key and keynode to point to the key record in
            //  the new datablock.
            hKey-> BlockIndex = (*lplpKeyRecord)-> BlockIndex;
            lpKeynode-> BlockIndex = hKey-> BlockIndex;
            hKey-> KeyRecordIndex = (BYTE) (*lplpKeyRecord)-> KeyRecordIndex;
            lpKeynode-> KeyRecordIndex = hKey-> KeyRecordIndex;

        }

        RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, TRUE);

        return ErrorCode;

    }

    return ERROR_OUTOFMEMORY;

}

//
//  RgSetValue
//

int
INTERNAL
RgSetValue(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Type,
    LPBYTE lpData,
    UINT cbData
    )
{

    int ErrorCode;
    UINT ValueNameLength;
    UINT NewValueRecordLength;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;
    UINT CurrentValueRecordLength;
    LPBYTE lpDestination;
    UINT BytesToExtend;
    UINT TempCount;
    LPKEYNODE lpKeynode;

    ValueNameLength = (IsNullPtr(lpValueName) ? 0 : (UINT) StrLen(lpValueName));

    if (ValueNameLength > MAXIMUM_VALUE_NAME_LENGTH - 1)
        return ERROR_INVALID_PARAMETER;

    NewValueRecordLength = sizeof(VALUE_RECORD) + ValueNameLength + cbData - 1;

    ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
        &lpValueRecord);

    //
    //  A value with this name already exists, so update the existing
    //  VALUE_RECORD with the new information.
    //

    if (ErrorCode == ERROR_SUCCESS) {

        CurrentValueRecordLength = sizeof(VALUE_RECORD) + lpValueRecord->
            NameLength + lpValueRecord-> DataLength - 1;

        if (NewValueRecordLength == CurrentValueRecordLength) {
            if (lpValueRecord-> DataLength == cbData && lpValueRecord->
                DataType == Type && CompareMemory((LPBYTE) lpValueRecord->
                Name + ValueNameLength, lpData, cbData) == 0) {
                RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);
                return ERROR_SUCCESS;
            }
        }

        if (NewValueRecordLength < CurrentValueRecordLength) {
            lpKeyRecord-> RecordSize -= (CurrentValueRecordLength -
                NewValueRecordLength);
        }

        else if (NewValueRecordLength > CurrentValueRecordLength) {

            BytesToExtend = NewValueRecordLength - CurrentValueRecordLength;

            if (BytesToExtend > SmallDword(lpKeyRecord-> AllocatedSize) -
                SmallDword(lpKeyRecord-> RecordSize)) {

                TempCount = (LPBYTE) lpValueRecord - (LPBYTE) lpKeyRecord;

                if ((ErrorCode = RgReAllocKeyRecord(hKey, lpKeyRecord->
                    RecordSize + BytesToExtend, &lpKeyRecord)) !=
                    ERROR_SUCCESS) {
                    RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex,
                        FALSE);
                    return ErrorCode;
                }

                lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) lpKeyRecord +
                    TempCount);

            }

            lpKeyRecord-> RecordSize += BytesToExtend;

        }

        lpDestination = (LPBYTE) lpValueRecord + NewValueRecordLength;
        TempCount = (UINT) ((LPBYTE) lpKeyRecord + SmallDword(lpKeyRecord->
            RecordSize) - lpDestination);

        if (TempCount > 0) {
            MoveMemory(lpDestination, (LPBYTE) lpValueRecord +
                CurrentValueRecordLength, TempCount);
        }

    }

    //
    //  No value exists with this name.  Place a new VALUE_RECORD at the end of
    //  the KEY_RECORD.
    //

    else if (ErrorCode == ERROR_CANTREAD16_FILENOTFOUND32) {

        //  Handle Win95 registries that don't have a key record for the root
        //  key.  We don't check if this is really the root key, but it doesn't
        //  matter much.
        if (IsNullBlockIndex(hKey-> BlockIndex)) {

            if (RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                &lpKeynode) != ERROR_SUCCESS)
                goto LockKeynodeFailed;

            if (RgAllocKeyRecord(hKey-> lpFileInfo, sizeof(KEY_RECORD) +
                NewValueRecordLength, &lpKeyRecord) != ERROR_SUCCESS) {
                RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, FALSE);
LockKeynodeFailed:
                TRAP();
                return ERROR_CANTOPEN;          //  Win95 compatibility
            }

            lpKeyRecord-> RecordSize = sizeof(KEY_RECORD);
            lpKeyRecord-> NameLength = 1;       //  Win95 compatibility
            lpKeyRecord-> Name[0] = '\0';       //  Win95 compatibility
            lpKeyRecord-> ValueCount = 0;
            lpKeyRecord-> ClassLength = 0;
            lpKeyRecord-> Reserved = 0;

            lpKeynode-> BlockIndex = lpKeyRecord-> BlockIndex;
            lpKeynode-> KeyRecordIndex = lpKeyRecord-> KeyRecordIndex;

            hKey-> BlockIndex = (WORD) lpKeynode-> BlockIndex;
            hKey-> KeyRecordIndex = (BYTE) lpKeynode-> KeyRecordIndex;

            RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, TRUE);

            ErrorCode = ERROR_SUCCESS;
            goto AddValueRecord;

        }

        if ((ErrorCode = RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex,
            hKey-> KeyRecordIndex, &lpKeyRecord)) == ERROR_SUCCESS) {

            if (NewValueRecordLength > SmallDword(lpKeyRecord-> AllocatedSize) -
                SmallDword(lpKeyRecord-> RecordSize)) {

                if ((ErrorCode = RgReAllocKeyRecord(hKey, lpKeyRecord->
                    RecordSize + NewValueRecordLength, &lpKeyRecord)) !=
                    ERROR_SUCCESS) {
                    RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex,
                        FALSE);
                    return ErrorCode;
                }

            }

AddValueRecord:
            lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) lpKeyRecord +
                SmallDword(lpKeyRecord-> RecordSize));
            lpKeyRecord-> RecordSize += NewValueRecordLength;
            lpKeyRecord-> ValueCount++;

        }

    }

    //
    //  If we're successful at this point, then lpValueRecord is valid and we
    //  should copy the data into this record.
    //

    if (ErrorCode == ERROR_SUCCESS) {

        lpValueRecord-> DataType = Type;

        lpValueRecord-> NameLength = (WORD) ValueNameLength;
        MoveMemory(lpValueRecord-> Name, lpValueName, ValueNameLength);

        lpValueRecord-> DataLength = (WORD) cbData;
        MoveMemory((LPBYTE) lpValueRecord-> Name + ValueNameLength, lpData,
            cbData);

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, TRUE);

    }

    return ErrorCode;

}

//
//  VMMRegSetValueEx
//
//  See Win32 documentation of RegSetValueEx.
//

LONG
REGAPI
VMMRegSetValueEx(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD Type,
    LPBYTE lpData,
    DWORD cbData
    )
{

    int ErrorCode;

    if (IsBadOptionalStringPtr(lpValueName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    //
    //  Windows 95 compatibility problem.  If the type is REG_SZ,
    //  then override cbData with the length of the string pointed to by lpData.
    //  This should have only been done in RegSetValue, but we're stuck with it
    //  now...
    //

    if (Type == REG_SZ) {
        if (IsBadStringPtr(lpData, (UINT) -1))
            return ERROR_INVALID_PARAMETER;
        cbData = StrLen(lpData);
    }
    else {
        if (cbData > 0 && IsBadHugeReadPtr(lpData, cbData))
            return ERROR_INVALID_PARAMETER;
    }

    if (cbData > MAXIMUM_DATA_LENGTH)
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {
        if ((hKey-> PredefinedKeyIndex == INDEX_DYN_DATA) || (hKey->
            lpFileInfo-> Flags & FI_READONLY))
            ErrorCode = ERROR_ACCESS_DENIED;
        else {
            if ((ErrorCode = RgSetValue(hKey, lpValueName, Type, lpData,
                (UINT) cbData)) == ERROR_SUCCESS) {
                RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                    REG_NOTIFY_CHANGE_LAST_SET);
            }
        }
    }

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(Reserved);

}

//
//  VMMRegSetValue
//
//  See Win32 documentation of RegSetValue.
//

LONG
REGAPI
VMMRegSetValue(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Type,
    LPBYTE lpData,
    DWORD cbData
    )
{

    LONG ErrorCode;
    HKEY hSubKey;

    if ((ErrorCode = RgCreateOrOpenKey(hKey, lpSubKey, &hSubKey, LK_CREATE)) ==
        ERROR_SUCCESS) {
        ErrorCode = VMMRegSetValueEx(hSubKey, NULL, 0, REG_SZ, lpData, 0);
        VMMRegCloseKey(hSubKey);
    }

    return ErrorCode;

    UNREFERENCED_PARAMETER(Type);
    UNREFERENCED_PARAMETER(cbData);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\utilwinc.c ===
//
//  UTILWINC.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Operating system interfaces for Windows environments.
//

#include "pch.h"

BOOL
INTERNAL
RgReadFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    )
{

    UINT BytesRead;

    BytesRead = _lread(hFile, lpBuffer, ByteCount);

    return ByteCount == BytesRead;

}

BOOL
INTERNAL
RgWriteFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    )
{

    UINT BytesWritten;

    BytesWritten = _lwrite(hFile, lpBuffer, ByteCount);

    return ByteCount == BytesWritten;

}

#ifndef FILE_BEGIN
#define FILE_BEGIN SEEK_SET
#endif

BOOL
INTERNAL
RgSeekFile(
    HFILE hFile,
    LONG FileOffset
    )
{

    LONG NewFileOffset;

    NewFileOffset = _llseek(hFile, FileOffset, FILE_BEGIN);

    return FileOffset == NewFileOffset;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmmreg32\utilw32c.c ===
//
//  UTILW32C.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Operating system interfaces for Win32 environments.
//

#include "pch.h"

//
//  RgCreateTempFile
//
//  Returns the path through lpFileName and a file handle of a temporary file
//  located in the same directory as lpFileName.  lpFileName must specify the
//

HFILE
INTERNAL
RgCreateTempFile(
    LPSTR lpFileName
    )
{

    HFILE hFile;

    if (GetTempFileName(lpFileName, "reg", 0, lpFileName) > 0) {
        if ((hFile = RgOpenFile(lpFileName, OF_WRITE)) != HFILE_ERROR)
            return hFile;
        DeleteFile(lpFileName);
    }

    DEBUG_OUT(("RgCreateTempFile failed\n"));
    return HFILE_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmtests\poolkill.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define DbgPrint printf
#define NtTerminateProcess(a,b) ExitProcess((ULONG)(b))

__cdecl
main(
    )

{

    LONG i, j;
    PULONG p4, p3, p2, p1, oldp1;
    SIZE_T Size1;
    NTSTATUS status;
    HANDLE CurrentProcessHandle;
    HANDLE GiantSection;
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG OldProtect;
    STRING Name3;
    HANDLE Section1;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG ViewSize;
    ULONG NumberOfAllocs = 0;
    TIME DelayTime = {-15 * 1000 * 1000 * 10, -1};
    OBJECT_ATTRIBUTES Object1Attributes;
    LARGE_INTEGER SectionSize;
    BOOL PrintedOnce = FALSE;

    CurrentProcessHandle = NtCurrentProcess();

    for(i = 0; i < 3; i += 1){
        DbgPrint("Hello World...\n\n");
    }

    DbgPrint("allocating virtual memory\n");

    for (;;) {
        p1 = NULL;
        Size1 = 800;

        status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                         (PVOID *)&p1,
                                         0,
                                         &Size1,
                                         MEM_RESERVE,
                                         PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            break;
        }

        if ((PrintedOnce == FALSE) &&
            ((ULONG_PTR)p1 >= 0x80000000)) {
            printf("allocate high %p\n", p1);
            PrintedOnce = TRUE;
        }

        NumberOfAllocs += 1;
    }

    DbgPrint("allocVM failed after %ld allocs of 800 bytes\n", NumberOfAllocs);
    DbgPrint("created vm status %X start %p size %d\n",
             status,
             p1,
             Size1);

    for (i = 0; i < 4; i += 1) {
        p1 = NULL;
        Size1 = 800;

        status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                         (PVOID *)&p1,
                                         0,
                                         &Size1,
                                         MEM_RESERVE,
                                         PAGE_READWRITE);

        DbgPrint("created vm status %X start %p size %d\n",
                 status,
                 p1,
                 Size1);
    }

    DbgPrint("delaying for 15 seconds\n");
    NtDelayExecution(FALSE, &DelayTime);
    DbgPrint ("end of delay\n");
    DbgPrint ("paged pool allocations\n");
    NumberOfAllocs = 0;
    for (;;) {

        //
        // Create a giant section (100mb)
        //

        InitializeObjectAttributes(&Object1Attributes,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL);

        SectionSize.QuadPart = (100 * 1024 * 1024);
        status = NtCreateSection(&GiantSection,
                                 SECTION_MAP_READ | SECTION_MAP_WRITE,
                                 &Object1Attributes,
                                 &SectionSize,
                                 PAGE_READWRITE,
                                 SEC_RESERVE,
                                 NULL);

        if (!NT_SUCCESS(status)) {
            break;
        }

        NumberOfAllocs += 1;
    }

    DbgPrint("Create section failed after %ld creates of 2GB\n", NumberOfAllocs);
    DbgPrint("create section status %X\n", status);
    DbgPrint("delaying for 15 seconds\n");
    NtDelayExecution(FALSE, &DelayTime);
    DbgPrint("end of delay\n");
    DbgPrint("that's all\n");
    NtTerminateProcess(NtCurrentProcess(), STATUS_SUCCESS);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmtests\color.c ===
/* memtest.c, Robert Nix, December, 1993
 *            nix@vliw.enet.dec.com
 * based on:
 *      cbash.c
 *      kirk johnson @ MIT
 *      february 1993
 *
 *      RCS $Id: cbash.c,v 1.2 1993/08/12 15:30:17 tuna Exp $
 *
 * Usage: memtest <machname> <iterations> <max-mem>
 *    machname   - a short indentifier for the machine being tested.
 *    iterations - target number of iterations to run for stable timing.
 *    max-mem    - maximum working set size to test.
 *
 *    Iterations and max-mem can be specified with a "k" or "m" suffix
 *    for kilo or mega iterations/mem.
 *
 * Example: Test of a Gateway 60 Mhz Pentium system
 * Command Line: memtest gp560 8m 4m
 * Output:
 *
--------------------------------------------------------------------------------
 *                      4k   8k  16k  32k  64k 128k 256k 512k   1m   2m   4m
 * L gp560          4   68   68   86   86   86   93  104  111  111  111  122
 * L gp560          8   68   68  107  107  107  114  139  165  154  154  154
 * L gp560         16   89   68  143  143  143  161  204  232  240  243  243
 * L gp560         32   68   68  172  168  168  207  290  347  365  365  365
 * L gp560         64   68   72  168  168  168  207  290  350  368  368  368
 * L gp560        128   72   75  168  168  168  211  293  358  379  418  379
 * L gp560        256   75   79  168  168  168  207  293  379  397  401  401
 * L gp560        512   86   86  172  168  168  215  297  418  440  443  494
 * L gp560         1k  100  104  175  172  168  218  304  501  522  529  529
 * L gp560         2k  136  139  179  172  172  222  322  665  687  755  701
 * L gp560         4k  132  243  232  225  222  286  401  991 1016 1094 1048
 * L gp560         8k  132  136  243  232  225  290  350  923  973 1034 1109
 * L gp560        16k  132  136  132  243  232  225  333  937  908  994 1041
 * L gp560        32k  136  132  136  136  243  232  304  833  919  930 1012
 *
--------------------------------------------------------------------------------
 * Explanation of output.
 *
 * There are three kinds of tests.
 *
 * L - Load latency test.
 *     Measures the average repetition rate, in ns, of a latency-oriented load
 *     loop.  The two main variables are:
 *
 *        (1) working set, or the amount of memory touched by the loop.  This
 *            varies across the columns in the output above, from a low of 4k
 *            bytes to a high of max-mem, or 16m bytes.
 *
 *        (2) stride, or the the number of bytes separating successive loads.
 *            This is the number in the 3rd column of each of the "L" rows
 *            in the output above, and varies from 4 bytes to 32k bytes.
 *
 * Interpreting the results. This is easiest on a 3d chart in Excel.
 * Two strides are always particularly interesting:
 *
 *      - The cache line or block size stride (32 bytes above).
 *        Big changes in latencies across the columns show the sizes
 *        and basic performance of the load side of the cache hierarchy.
 *
 *        If you don't know the cache line size: look across the first row
 *        for the first column that takes a big jump up in latency (the jump
 *        from 68ns to 86ns between the 8k column and 16k columnabove), then (b)
 *        scan down the rows of that column for the first relativelystable value
 *        (172ns in the 32 byte stride row above).  The row containing
 *        that stable value is probably the cache line size.
 *
 *        Look across the cache line size row.  Access time jumps at 16K --
 *        so the L1 cache is 8K -- and then jumps again at 512K -- so the L2
 *        cache is 256K.  The slope between 64K and 512K could be caused
 *        by a thrash in the L2 cache; page coloring could remove this thrash.
 *
 *      - The page size stride (4k above).
 *        Big changes in latencies across the columns expose the tbsize and the cost
 *        of a tb refill.
 *
 *        Scan the 4k line. It takes a big jump in latency at the 512K working
 *        set (and actually starts to thrash at the 256K working set). This test says the TB
 *        can map somewhere in the neighborhood of 64 4K pages.  The TB fill time
 *        looks to be somewhere around 650-700 ns (subtract large working set entries
 *        in the 32-byte stride line from corresponding entries in the 4k stride line).
 *
 * The output always contains a little noise:
 *
 *      - Boost the "iterations" command line parameter to remove timing jitter.
 *
 *      - All entries contain some loop overhead.  Its fair to normalize results by subtracting
 *        out the difference between the reported times and the known latency to the fastest level
 *        of the memory hierarchy.
 *
 *      - The entries in the lower-left hand corner of the table (large
 *        strides in small memory) are dominated by loop overhead; ignore them.
 *
 *      - Implement a good page coloring algorithm to remove jitter caused by cache
 *        thrashing.  Look at the cache-line sized stride to see the frequency of thrashing.
 *
 */

#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#define DEF_MAXMEM 16777216
#define MINMEM 4096
#define ITYPE signed int
signed long     max_mem;
char           *mach_name;

#if defined(_WIN64)
typedef unsigned __int64 ULONG_PTR;
#else
typedef unsigned long ULONG_PTR;
#endif

#define MAXSTRIDE 32768
#define MINSTRIDE 4

char           *version_string = "1.0 (20 Dec 1993)";
extern ITYPE  arg_to_int(char *);
extern double bash(char *, long, long, long);
extern int bash_loop(char *, long, long, long);
extern void allocate_memory(char *, long);
extern void usage(char *);

int __cdecl main(
     int argc,
     char *argv[]
)
{
ITYPE           nbytes;
ITYPE           stride;
ITYPE           iters;
char           *region;

    if ((argc > 1) && (strcmp(argv[1], "-v") == 0)) {
       fprintf(stderr, "This is memtest version %s.\n", version_string);
        exit(1);
    }
    if (argc < 3)
    usage(argv[0]);
    mach_name = argv[1];
    iters = arg_to_int(argv[2]);
    if (argc < 4) {
        max_mem = DEF_MAXMEM;
    } else {
        max_mem = arg_to_int(argv[3]);
    }
    region = (char *) malloc(max_mem+(128*1024));
    region = (char *) ((((ULONG_PTR) region) + (128*1024-1)) & ~((128*1024)-1));
    if (region == NULL) {
        perror("malloc failed");
        exit(1);
    }
    printf("  %8s", "");
    printf("%8s", "");
    for (nbytes = MINMEM; nbytes <= max_mem; nbytes += nbytes) {
        if (nbytes >= (1024 * 1024))
            printf("%4dm", nbytes / (1024 * 1024));
        else if (nbytes >= 1024)
            printf("%4dk", nbytes / 1024);
        else
            printf("%5d", nbytes);
    }
    printf("\n");
    for (stride = MINSTRIDE; stride <= MAXSTRIDE; stride += stride) {
        printf("L %-8s", mach_name);
        if (stride >= (1024 * 1024))
            printf("%7dm", stride / (1024 * 1024));
        else if (stride >= 1024)
            printf("%7dk", stride / 1024);
        else
            printf("%8d", stride);
        for (nbytes = MINMEM; nbytes <= max_mem; nbytes += nbytes) {
            double ns_ref = bash(region, nbytes, stride, iters);
            printf("%5.0f", ns_ref);
            fflush(stdout);
        }
        printf("\n");
    }
    exit(0);
    return 0;
}

ITYPE
arg_to_int(char *arg)
{
ITYPE           rslt = 0;
ITYPE           mult = 1;

    switch (arg[strlen(arg) - 1]) {
    case 'k':
    case 'K':
        mult = 1024;
        break;

    case 'm':
    case 'M':
        mult = 1024 * 1024;
        break;

    default:
        mult = 1;
        break;
    }
    if (!((arg[0] >= '0') && arg[0] <= '9')) {
        fprintf(stderr, "Argument %s not a number\n", arg);
        usage("memtest");
        exit(1);
    }
    if (sscanf(arg, "%ld", &rslt) != 1) {
        fprintf(stderr, "Argument %s not a number\n", arg);
        usage("memtest");
        exit(1);
    }
    rslt *= mult;
    return rslt;
}


double
bash(
     char *region,
     long nbytes,       /* size of region to bash (bytes) */
     long stride,       /* stride through region (bytes)  */
     long iters         /* target # of loop iterations    */
)
{
signed long     count;
signed long     reps;
clock_t         start, stop;
double          utime, stime;

    count = ((nbytes - sizeof(int)) / stride) + 1;
    if (! (((count - 1) * stride + (long)sizeof(int)) <= nbytes)) {
        fprintf(stderr, "trip count problem\n");
        exit(1);
    }
    reps = (iters + count - 1) / count;
    if (reps <= 0)
        reps = 1;
    iters = reps * count;

    /* make sure the memory is allocated */
    memset(region, 0, nbytes);
    memset(region, 1, nbytes);
    allocate_memory(region, nbytes);
    memset(region, 0, nbytes);
    /* warm up the cache */
    (void) bash_loop(region, count, stride, 1L);

    /* run the bash loop */
    start = clock();
    (void) bash_loop(region, count, stride, reps);
    stop = clock();
    utime = (double) (stop - start) / CLOCKS_PER_SEC;
    stime = 0.0;

    return 1e9 * ((utime + stime) / iters);
}

/* Your virtual memory pagesize must be at least this big */
#define MIN_PAGESIZE    256

void
allocate_memory(
                char *region,   /* memory region to be bashed       */
                long nbytes)
{                       /* size of region (bytes)           */
long            i;

    for (i = 0; i < nbytes; i += MIN_PAGESIZE)
        *((int *) (region + i)) = 0;
}


int
bash_loop(
          char *region, /* memory region to be bashed       */
          long count,   /* number of locations to bash      */
          long stride,  /* stride between locations (bytes) */
          long reps     /* number of passes through region  */
)
{
long            i;
int             rslt;
char           *tmp;

    rslt = 0;
    for (; reps > 0; reps--) {
        tmp = region;
        for (i = count; i > 0; i--) {
            rslt ^= *((int *) tmp);
            tmp += stride;
        }
    }

    return rslt;
}


void
usage(char *progname)
{
    fprintf(stderr, "usage: %s <machname> <iters> [<maxmem>]\n", progname);
    fprintf(stderr, "  <machname>   machine name\n");
    fprintf(stderr, "  <iters>      target # of accesses\n");
    fprintf(stderr, "  <maxmem>     maximum amount of mem to touch (def 16 Mb)\n");
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmtests\mem64.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define DbgPrint printf
#define NtTerminateProcess(a,b) ExitProcess(b)

typedef unsigned long *POINTER_64 PULONG64;

__cdecl main()
{
    LONG i, j;
    PVOID64 p1;
    PVOID64 p2;
    PVOID64 p3;
    PULONG64 long64;
    ULONG Size2, Size3;
    ULONGLONG Size1;
    NTSTATUS status, alstatus;
    HANDLE CurrentProcessHandle;
    HANDLE GiantSection;
    HANDLE Section2, Section4;
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG OldProtect;
    STRING Name3;
    HANDLE Section1;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_ATTRIBUTES Object1Attributes;
    ULONG ViewSize;
    LARGE_INTEGER Offset;
    LARGE_INTEGER SectionSize;
    UNICODE_STRING Unicode;

    CurrentProcessHandle = NtCurrentProcess();

    DbgPrint(" 64-bit Memory Management Tests - AllocVm, FreeVm, ProtectVm, QueryVm\n");

    Size1 = 1*1024*1024;
    p1 = NULL;

    alstatus = NtAllocateVirtualMemory64 (CurrentProcessHandle,
                                         (PVOID *)&p1,
                                         0,
                                         &Size1,
                                         MEM_RESERVE | MEM_COMMIT,
                                         PAGE_READWRITE);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("failed first created vm status %X start %lx size %lx\n",
            alstatus, (ULONG)p1, Size1);
        DbgPrint("******** FAILED TEST 1 **************\n");
        return 1;
    }

    printf("starting va %lx %08lx\n", (ULONG)((ULONGLONG)p1 >> 32),(ULONG)((ULONGLONG)p1));

    printf("touching va %lx %08lx\n", (ULONG)((ULONGLONG)p1 >> 32),(ULONG)(ULONGLONG)p1);

   long64 = p1;

   *long64 = 77;

    p2 = NULL;
    alstatus = NtAllocateVirtualMemory64 (CurrentProcessHandle,
                                         (PVOID *)&p2,
                                         0,
                                         &Size1,
                                         MEM_RESERVE | MEM_COMMIT,
                                         PAGE_READWRITE);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("failed first created vm status %X start %lx size %lx\n",
            alstatus, (ULONG)p2, Size1);
        DbgPrint("******** FAILED TEST 1 **************\n");
        return 1;
    }

    printf("starting va %lx %08lx\n", (ULONG)((ULONGLONG)p2 >> 32),(ULONG)((ULONGLONG)p2));

    p3 = NULL;
    alstatus = NtAllocateVirtualMemory64 (CurrentProcessHandle,
                                         (PVOID *)&p3,
                                         0,
                                         &Size1,
                                         MEM_RESERVE | MEM_COMMIT,
                                         PAGE_READWRITE);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("failed first created vm status %X start %lx size %lx\n",
            alstatus, (ULONG)p3, Size1);
        DbgPrint("******** FAILED TEST 1 **************\n");
        return 1;
    }

    printf("starting va %lx %08lx\n", (ULONG)((ULONGLONG)p3 >> 32),(ULONG)((ULONGLONG)p3));

    printf("freeing va at %lx %08lx\n", (ULONG)((ULONGLONG)p2 >> 32),(ULONG)(ULONGLONG)p2);

    Size1 = 0;
    alstatus = NtFreeVirtualMemory64 (CurrentProcessHandle,
                                      (PVOID *)&p2,
                                      &Size1,
                                      MEM_RELEASE);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("failed first free vm status %X start %lx size %lx\n",
            alstatus, (ULONG)p2, Size1);
        DbgPrint("******** FAILED TEST 1 **************\n");
        return 1;
    }

    printf("decommit va at %lx %08lx\n", (ULONG)((ULONGLONG)p3 >> 32),(ULONG)(ULONGLONG)p3);

    Size1 = 4096;
    alstatus = NtFreeVirtualMemory64 (CurrentProcessHandle,
                                      (PVOID *)&p3,
                                      &Size1,
                                      MEM_DECOMMIT);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("failed first delete vm status %X start %lx size %lx\n",
            alstatus, (ULONG)p3, Size1);
        DbgPrint("******** FAILED TEST 1 **************\n");
        return 1;
    }
 //   return 0;


#if 0
    status = NtQueryVirtualMemory (CurrentProcessHandle, p1,
                                    MemoryBasicInformation,
                                    &MemInfo, sizeof (MEMORY_BASIC_INFORMATION),
                                    NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("******** FAILED TEST 2 **************\n");
        DbgPrint("FAILURE query vm status %X address %lx Base %lx size %lx\n",
             status,
             p1,
             MemInfo.BaseAddress,
             MemInfo.RegionSize);
        DbgPrint("     state %lx protect %lx type %lx\n",
             MemInfo.State,
             MemInfo.Protect,
             MemInfo.Type);
    }
    if ((MemInfo.RegionSize != Size1) || (MemInfo.BaseAddress != p1) ||
        (MemInfo.Protect != PAGE_READWRITE) || (MemInfo.Type != MEM_PRIVATE) ||
        (MemInfo.State != MEM_COMMIT)) {

        DbgPrint("******** FAILED TEST 3 **************\n");
        DbgPrint("FAILURE query vm status %X address %lx Base %lx size %lx\n",
             status,
             p1,
             MemInfo.BaseAddress,
             MemInfo.RegionSize);
    }
    return 0;
#endif //0
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmtests\pageit.c ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#define ONE_MB              (1024*1024)
#define TWO_MB              (2*ONE_MB)
#define PAGE_SIZE           (4096)
#define PAGESPERTWO_MB      (TWO_MB/PAGE_SIZE)
#define TWO_MBREGIONS       (8)

#define NEW_CELL(id,i)    ( (id)<<20 | ((i)&0x000fffff) )

CRITICAL_SECTION ErrorCrit;
PUCHAR RegionBase;


DWORD
SelectPage(
    void
    )
{
    DWORD PageNum;

    PageNum = GetTickCount();
    PageNum = PageNum >> 3;
    PageNum = PageNum & (PAGESPERTWO_MB-1);

    return PageNum;
}

void
CellError(
    DWORD TwoMegRegion,
    DWORD *Address,
    DWORD ThreadId,
    DWORD OriginalCell,
    DWORD CurrentCell,
    DWORD Iteration
    )
{
    EnterCriticalSection(&ErrorCrit);
    printf("PAGEIT: Cell Error at %x %p %02lx %08x vs %08x (iter %d)\n",
        TwoMegRegion,
        Address,
        ThreadId,
        OriginalCell,
        CurrentCell,
        Iteration
        );
    DebugBreak();
    LeaveCriticalSection(&ErrorCrit);
}

void
PrintHeartBeat(
    DWORD Id,
    DWORD Counter
    )
{
    EnterCriticalSection(&ErrorCrit);
    printf("PAGEIT: HeartBeat Id %3d iter %8d\n",
        Id,
        Counter
        );
    LeaveCriticalSection(&ErrorCrit);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
ThreadRoutine(
    PVOID Unused
    )

{
    DWORD Id;
    DWORD Counter;
    DWORD PageNumber;
    DWORD CellOffset;
    DWORD *CellAddress;
    DWORD OriginalCell;
    DWORD NewCell;
    DWORD i;

    SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_LOWEST);
    Id = GetCurrentThreadId();
    Counter = 0;

    for(;;) {
        PageNumber = SelectPage();
        CellOffset = PageNumber*PAGE_SIZE + Id*sizeof(DWORD);
        CellAddress = (DWORD *)(RegionBase + CellOffset);
        OriginalCell = *CellAddress;
        NewCell = NEW_CELL(Id,Counter);
        for(i=0;i<TWO_MBREGIONS;i++) {
            CellAddress = (DWORD *)(RegionBase + i*TWO_MB + CellOffset);
            if ( OriginalCell != *CellAddress ) {
                CellError(i,CellAddress,Id,OriginalCell,*CellAddress,Counter);
            }

            *CellAddress = NewCell;
        }

        Counter++;
        if ( (Counter/50) * 50 == Counter ) {
            Sleep(500);
        }

        if ( (Counter/1024) * 1024 == Counter ) {
            PrintHeartBeat(Id,Counter);
        }
    }

    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    DWORD i;
    DWORD Id;
    HANDLE Thread;

    InitializeCriticalSection(&ErrorCrit);

    RegionBase = VirtualAlloc(NULL,TWO_MBREGIONS*TWO_MB,MEM_COMMIT,PAGE_READWRITE);

    if ( !RegionBase ) {
        printf("PAGEIT: VirtualAlloc Failed %d\n",GetLastError());
        ExitProcess(1);
        }
    for (i=0;i<(TWO_MBREGIONS-1);i++){
        Thread = CreateThread(NULL,0,ThreadRoutine,NULL,0,&Id);
        if ( Thread ) {
            CloseHandle(Thread);
            }
        }
    ThreadRoutine(NULL);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmtests\tfork.c ===
#include <nt.h>
#include <ntrtl.h>
#include <stdio.h>

ULONG ProcessNumber = 1;
#define DbgPrint printf

ULONG
fork ();

__cdecl
main(
    )

{

    LONG i, j;
    PULONG p4, p3, p2, p1, Ro3, Noaccess;
    SIZE_T Size1, Size2, Size3, SizeRo3, SizeNoaccess;
    NTSTATUS status;
    HANDLE CurrentProcessHandle;
    ULONG id = 0;
    ULONG OldProtect;

    CurrentProcessHandle = NtCurrentProcess();

    for(i=0;i<3;i++){
        DbgPrint("Hello World...\n\n");
    }

    DbgPrint("allocating virtual memory\n");

    p1 = (PULONG)NULL;
    Size1 = 30 * 4096;

    status = NtAllocateVirtualMemory (CurrentProcessHandle, (PVOID *)&p1,
                        0, &Size1, MEM_COMMIT, PAGE_READWRITE);

    DbgPrint("created vm1 status %X start %p size %lx\n",
            status, p1, Size1);

    p2 = (PULONG)NULL;
    Size2 = 16 * 4096;

    status = NtAllocateVirtualMemory (CurrentProcessHandle, (PVOID *)&p2,
                        0, &Size2, MEM_COMMIT, PAGE_READWRITE);

    DbgPrint("created vm2 status %X start %p size %lx\n",
            status, p2, Size2);


    id = fork () + id;

    DbgPrint("fork complete id %lx\n",id);

    p3 = p1 + 8 * 1024;
    Size3 = 16 * 4096;

    DbgPrint("deleting va from %p for %lx bytes\n",p3, Size3);

    status = NtFreeVirtualMemory (CurrentProcessHandle,(PVOID *)&p3, &Size3,
                                  MEM_RELEASE);

    DbgPrint("free vm status %X start %p size %lx\n",
            status, p3, Size3);

    p3 = (PULONG)NULL;
    Size3 = 50 * 4096;

    DbgPrint("allocating 50 pages of vm\n");

    status = NtAllocateVirtualMemory (CurrentProcessHandle, (PVOID *)&p3,
                        0, &Size3, MEM_COMMIT, PAGE_READWRITE);

    DbgPrint("created vm3 status %X start %p size %lx\n",
            status, p3, Size3);

    Ro3 = (PULONG)NULL;
    SizeRo3 = 393933;

    status = NtAllocateVirtualMemory (CurrentProcessHandle, (PVOID *)&Ro3,
                        0, &SizeRo3, MEM_COMMIT, PAGE_READONLY);


    DbgPrint("created vm4 status %X start %p size %lx\n",
            status, Ro3, SizeRo3);

    *p3 = *Ro3;

    p1 = p3;

    p2 = ((PULONG)((PUCHAR)p3 + Size3));
    p4 = p1;
    j = 0;

    while (p3 < p2) {
        j += 1;

        if (j % 8 == 0) {
            if (*p4 != (ULONG)((ULONG_PTR)p4)) {
                DbgPrint("bad value in cell %p value is %lx\n",p4, *p4);

            }
            p4 += 1;
            *p4 = (ULONG)((ULONG_PTR)p4);
            p4 = p4 + 1026;
        }

        *p3 = (ULONG)((ULONG_PTR)p3);
        p3 += 1027;

    }

    p3 = p1;

    //
    // Protect page as no access.
    //

    Noaccess = NULL;
    SizeNoaccess = 200*4096;

    status = NtAllocateVirtualMemory (CurrentProcessHandle, (PVOID *)&Noaccess,
                        0, &SizeNoaccess, MEM_COMMIT, PAGE_READWRITE);


    DbgPrint("created vm5 status %X start %p size %lx\n",
            status, Ro3, SizeRo3);

    //
    // Touch all the pages.
    //

    RtlZeroMemory(Noaccess, SizeNoaccess);

    *Noaccess = 91;
    Size1 = 30 * 4097;

    status = NtProtectVirtualMemory (CurrentProcessHandle, (PVOID *)&Noaccess,
                        &Size1, PAGE_NOACCESS,
                        &OldProtect);

    DbgPrint("protected VM1 status %X, base %p, size %lx, old protect %lx\n",
                    status, p1, Size1, OldProtect);


    DbgPrint("forking a second time\n");

    id = fork () + id;
    DbgPrint("fork2 complete id %lx\n",id);

    DbgPrint("changing page protection\n");

    Size1 = 9000;

    OldProtect = *p3;

    status = NtProtectVirtualMemory (CurrentProcessHandle, (PVOID *)&p3,
                        &Size1, PAGE_EXECUTE_READWRITE | PAGE_NOCACHE,
                        &OldProtect);

    DbgPrint("protected VM2 status %X, base %p, size %lx, old protect %lx\n",
                    status, p1, Size1, OldProtect);


    status = NtProtectVirtualMemory (CurrentProcessHandle, (PVOID *)&Ro3,
                        &Size1, PAGE_READONLY | PAGE_NOCACHE, &OldProtect);

    DbgPrint("protected VM3 status %X, base %p, size %lx, old protect %lx\n",
                    status, Ro3, Size1, OldProtect);
    p1 += 1;

    while (p3 < p2) {

        *p1 = (ULONG)((ULONG_PTR)p1);

        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("bad value in cell %p value is %lx\n",p3, *p3);
        }
        p3 += 1027;
        p1 += 1027;

    }

    DbgPrint("trying noaccess test\n");

    try {
        if (*Noaccess != 91) {
            DbgPrint("*************** FAILED NOACCESS TEST 1 *************\n");

        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (GetExceptionCode() != STATUS_ACCESS_VIOLATION) {
            DbgPrint("*************** FAILED NOACCESS TEST 2 *************\n");
        }
    }

    //
    // Make no access page accessable.
    //

    status = NtProtectVirtualMemory (CurrentProcessHandle, (PVOID *)&Noaccess,
                        &Size1, PAGE_READWRITE,
                        &OldProtect);

    if (*Noaccess != 91) {
        DbgPrint("*************** FAILED NOACCESS TEST 3 *************\n");
    }

    DbgPrint("that's all process %lx\n", id);
    NtTerminateProcess(NtCurrentProcess(),STATUS_SUCCESS);
    return 0;
}

ULONG
fork ()

{
    LONG i;
    PULONG Foo;
    NTSTATUS status;
    HANDLE CurrentProcessHandle;
    HANDLE ProcessHandle;
    CONTEXT ThreadContext;
    CLIENT_ID Cid1;
    HANDLE Thread1;
    LARGE_INTEGER DelayTime;
    PINITIAL_TEB Teb;
    
    CurrentProcessHandle = NtCurrentProcess();
    DbgPrint("creating new process\n");

    status = NtCreateProcess(
             &ProcessHandle,
             PROCESS_ALL_ACCESS, //DesiredAccess,
             NULL, //ObjectAttributes,
             CurrentProcessHandle, //ParentProcess
             TRUE, //InheritObjectTable,
             NULL, //SectionHandle
             NULL, //DebugPort OPTIONAL,
             NULL  //ExceptionPort OPTIONAL
             );

    DbgPrint("status from create process %lx\n",status);

    if (!NT_SUCCESS(status)) {
        return 0;
    }
    ThreadContext.ContextFlags = CONTEXT_FULL;

    status = NtGetContextThread (NtCurrentThread(), &ThreadContext);

    DbgPrint("status from get context %lx\n",status);

    if (status == 0) {

#ifdef i386
        ThreadContext.Eax = 0x7777;
        ThreadContext.Esp -= 0x18;
        Foo = (PULONG)ThreadContext.Esp;
        DbgPrint("stack value is %lx\n",*Foo);
#endif

        Teb= (PINITIAL_TEB) NtCurrentTeb ();

        status = NtCreateThread(
                &Thread1,
                THREAD_ALL_ACCESS,
                NULL,
                ProcessHandle,
                &Cid1,
                &ThreadContext,
                Teb,
                FALSE
                );

//        DelayTime.HighPart = -1;
//        DelayTime.LowPart = 0;
//        NtDelayExecution (FALSE, &DelayTime);

        return 0;
    } else {

        ProcessNumber += ProcessNumber;
        return ProcessNumber;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmtests\vmperf.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define DbgPrint printf

#define SEG_1_SIZE 1024 * 1024
#define SEG_X_SIZE 1024 * 1024 * 64

#define VM_MEMMAN_ITERATIONS       150
#define VM_MEMMAN_ITERATIONS2     2000
#define MemManSubtest5Count         200

int TotalBenchMarks = 0;
#define MAX_BENCHMARKS 32
char *BenchMarkNames[ MAX_BENCHMARKS ];
ULONG BenchMarkRates[ MAX_BENCHMARKS ];
ULONG BenchMarkFracs[ MAX_BENCHMARKS ];

typedef struct _PERFINFO {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER StopTime;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

int
StartBenchMark(
    PCHAR Title,
    ULONG Iterations,
    PPERFINFO PerfInfo
    );

VOID
FinishBenchMark(
    PPERFINFO PerfInfo
    );

__cdecl main()
{
    PCHAR   p1, p2, p3, p4;         // pointers into new segment
    PCHAR   pa[MemManSubtest5Count]; // array for section pointers
    PULONG  u1;
    ULONG   actual;         // actual xfer count for read
    ULONG   ssize;          // section allocation size var
    ULONG   ii, ix;         // loop index variables
    PERFINFO PerfInfo;
    ULONG Seg1Size;
    ULONG SegxSize;
    ULONG CommitSize;
    NTSTATUS status;
    HANDLE CurrentProcessHandle, Section1;
    LARGE_INTEGER SectionSize;
    ULONG Size;
    ULONG ViewSize;

    DbgPrint("NT Memory Management test\n");

    CurrentProcessHandle = NtCurrentProcess();

    Size = 1024L * 1024L;
    p1 = NULL;

    status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p1,
                                       0,
                                       &Size,
                                       MEM_RESERVE | MEM_COMMIT,
                                       PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("service failed allocvm - status %X\n", status);
    }

    for (p2=p1; p2 < (p1 + Size); p2 += 4) {
            u1 = (PULONG)p2;
            *u1 = (ULONG)p2;
    }  // for

    SectionSize.LowPart = 1024*1024;
    SectionSize.HighPart = 0;
    status = NtCreateSection (&Section1,
                              SECTION_MAP_READ | SECTION_MAP_WRITE,
                              NULL,
                              &SectionSize,
                              PAGE_READWRITE,
                              SEC_COMMIT,
                              NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("service failed create sect - status %X\n", status);
    }

    p3 = NULL;
    ViewSize = 0;
    status = NtMapViewOfSection (Section1,
                                 CurrentProcessHandle,
                                 (PVOID *)&p3,
                                 0L,
                                 0,
                                 NULL,
                                 &ViewSize,
                                 ViewUnmap,
                                 0,
                                 PAGE_READWRITE );

    if (!NT_SUCCESS(status)) {
        DbgPrint("service failed mapview - status %X\n", status);
    }

    RtlMoveMemory ((PVOID)p3, (PVOID)p1, Size);

    StartBenchMark( "NT MemMan00 -- 1 Meg Copy",
                    150,
                    &PerfInfo
                  );
//
//  Memory Management sub-test 1 --
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    for (ii=0; ii<150; ii++) {

        RtlMoveMemory ((PVOID)p3, (PVOID)p1, Size);
    }


    FinishBenchMark( &PerfInfo );

    status = NtClose (Section1);

    if (!NT_SUCCESS(status)) {
        DbgPrint("service failed close sect - status %X\n", status);
    }

    status = NtUnmapViewOfSection (CurrentProcessHandle,
                                   p3);

    if (!NT_SUCCESS(status)) {
        DbgPrint("service failed - status %X\n", status);
    }

//
//  Memory Management sub-test 1 --
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//
    StartBenchMark( "NT MemMan01 -- create 1mb section, copy 1mb, delete",
                    150,
                    &PerfInfo
                  );

    for (ii=0; ii<150; ii++) {

        status = NtCreateSection (&Section1,
                                  SECTION_MAP_READ | SECTION_MAP_WRITE,
                                  NULL,
                                  &SectionSize,
                                  PAGE_READWRITE,
                                  SEC_COMMIT,
                                  NULL);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed create sect - status %X\n", status);
        }

        p3 = NULL;
        ViewSize = 0;
        status = NtMapViewOfSection (Section1,
                                     CurrentProcessHandle,
                                     (PVOID *)&p3,
                                     0L,
                                     0,
                                     NULL,
                                     &ViewSize,
                                     ViewUnmap,
                                     0,
                                     PAGE_READWRITE );

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed mapview - status %X\n", status);
        }

        RtlMoveMemory ((PVOID)p3, (PVOID)p1, Size);

        p4 = NULL;
        ViewSize = 0;
        status = NtMapViewOfSection (Section1,
                                     CurrentProcessHandle,
                                     (PVOID *)&p4,
                                     0L,
                                     0,
                                     NULL,
                                     &ViewSize,
                                     ViewUnmap,
                                     0,
                                     PAGE_READWRITE );

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed mapview - status %X\n", status);
        }

        status = NtClose (Section1);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed close sect - status %X\n", status);
        }

        status = NtUnmapViewOfSection (CurrentProcessHandle,
                                       p3);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %X\n", status);
        }

        status = NtUnmapViewOfSection (CurrentProcessHandle,
                                       p4);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %X\n", status);
        }
    }

    FinishBenchMark( &PerfInfo );

//
//  Memory Management sub-test 1 --
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//
    StartBenchMark( "NT MemMan02 -- alloc 1mb vm, copy 1mb, delete",
                    150,
                    &PerfInfo
                  );

    for (ii=0; ii<150; ii++) {

        Size = 1024*1024;
        p3 = NULL;
        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&p3,
                                           0,
                                           &Size,
                                           MEM_RESERVE | MEM_COMMIT,
                                           PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed allocvm - status %X\n", status);
        }

        RtlMoveMemory ((PVOID)p3, (PVOID)p1, Size);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed close sect - status %X\n", status);
        }

        status = NtFreeVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p3,
                                      &Size,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed freevm - status %X\n", status);
        }

    }

    FinishBenchMark( &PerfInfo );

    status = NtFreeVirtualMemory (CurrentProcessHandle,
                                  (PVOID *)&p1,
                                  &Size,
                                  MEM_RELEASE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("service failed freevm - status %X\n", status);
    }

    //
    // start regular benchmarks.
    //

    StartBenchMark( "NT MemMan1 -- 1 Meg Seg, Create, Commit & Touch",
                    VM_MEMMAN_ITERATIONS,
                    &PerfInfo
                  );
//
//  Memory Management sub-test 1 --
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    for (ii=0; ii<VM_MEMMAN_ITERATIONS; ii++) {

        p1 = NULL;
        Seg1Size = SEG_1_SIZE;
        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&p1,
                                          0,
                                          &Seg1Size,
                                          MEM_RESERVE | MEM_COMMIT,
                                          PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

        for (p2=p1; p2 < (p1 + Seg1Size); p2 += 4096) {
            u1 = (PULONG)p2;
            *u1=99;
//            for (ix=0; ix<1023; ix++) {
//                u1++;
//                if (*u1 != 0) DbgPrint("%lx = %lx\n",u1,*u1);
//            }
        }  // for

        status = NtFreeVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p1,
                                      &Seg1Size,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }
    }

    FinishBenchMark( &PerfInfo );

    StartBenchMark( "NT MemMan1.5 -- 1 Meg Seg, Create, reserve Commit & Touch",
                    VM_MEMMAN_ITERATIONS,
                    &PerfInfo
                  );
//
//  Memory Management sub-test 1 --
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    for (ii=0; ii<VM_MEMMAN_ITERATIONS; ii++) {

        p1 = NULL;
        Seg1Size = SEG_1_SIZE;
        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&p1,
                                          0,
                                          &Seg1Size,
                                          MEM_RESERVE | MEM_COMMIT,
                                          PAGE_READONLY);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

        status = NtProtectVirtualMemory (CurrentProcessHandle,
                                         (PVOID *)&p1,
                                         &Seg1Size,
                                         PAGE_READWRITE,
                                         &CommitSize);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed (ntprotect)- status %lx\n", status);
            return 0;
        }

        for (p2=p1; p2 < (p1 + Seg1Size); p2 += 4096) {
            u1 = (PULONG)p2;
            *u1=99;
//            for (ix=0; ix<1023; ix++) {
//                u1++;
//                if (*u1 != 0) DbgPrint("%lx = %lx\n",u1,*u1);
//            }
        }  // for

        status = NtFreeVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p1,
                                      &Seg1Size,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }
    }

    FinishBenchMark( &PerfInfo );

    StartBenchMark( "NT MemMan2 -- 1 Meg Seg, Create & Commit Only",
                    VM_MEMMAN_ITERATIONS2,
                    &PerfInfo
                  );
//
//  Memory Management sub-test 2 --
//
//      Create a 1 MB segment with commitment of the pages,
//      but never use the segment.
//

    for (ii=0; ii<VM_MEMMAN_ITERATIONS2; ii++) {

        p1 = NULL;
        Seg1Size = SEG_1_SIZE;
        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&p1,
                                          0,
                                          &Seg1Size,
                                          MEM_RESERVE | MEM_COMMIT,
                                          PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

        status = NtFreeVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p1,
                                      &Seg1Size,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

    }

    FinishBenchMark( &PerfInfo );

    StartBenchMark( "NT MemMan3 -- 1 Meg Seg Create Only",
                    VM_MEMMAN_ITERATIONS2,
                    &PerfInfo
                  );

//
//  Memory Management sub-test 3 --
//
//      Create a 1 MB segment without commitment of the pages,
//      but never use or commit the segment.
//

    for (ii=0; ii<VM_MEMMAN_ITERATIONS2; ii++) {

        p1 = NULL;
        Seg1Size = SEG_1_SIZE;
        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&p1,
                                          0,
                                          &Seg1Size,
                                          MEM_RESERVE,
                                          PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

        status = NtFreeVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p1,
                                      &Seg1Size,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }
    }

    FinishBenchMark( &PerfInfo );

//
//  Reduce the number of iterations on this subtest for now.
//      When NT can perform it faster, up the interations again
//
#define VM_MMST04_ITERATIONS 4     //temporarily reduce the iterations


    StartBenchMark( "NT MemMan4 -- 64 Meg Seg, Commit Sparse",
                    VM_MMST04_ITERATIONS,
                    &PerfInfo
                  );

//
//  Memory Management sub-test 4 --
//
//      Create a 64 MB segment without committing the pages,
//      then commit and touch at 128 KB intervals.
//
//
    for (ii=0; ii<VM_MMST04_ITERATIONS; ii++) {

        p1 = NULL;
        SegxSize = SEG_X_SIZE;
        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&p1,
                                          0,
                                          &SegxSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

        CommitSize = 4;

        for (p2=p1; p2 < (p1 + SegxSize); p2 += 256 * 1024) {

            status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                              (PVOID *)&p2,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE);

            if (!NT_SUCCESS(status)) {
                DbgPrint("service failed - status %lx\n", status);
            }
            if (*p2 != 0) DbgPrint("%lx = %lx\n",p2,*p2);
            }  // for
        status = NtFreeVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p1,
                                      &SegxSize,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

    }
    FinishBenchMark( &PerfInfo );

//


    StartBenchMark( "NT MemMan5 -- Sparse Section Create/Delete Benchmark",
                    VM_MEMMAN_ITERATIONS,
                    &PerfInfo
                  );

//
//  Memory Management sub-test 5 --
//
//      Create a alternatively 232k and 112 k memory sections.
//      For every 2 created, delete 1.  Do this for MemManSubtest5Count times.
//
//
    for (ii=0; ii<VM_MEMMAN_ITERATIONS; ii++) {
        for (ix=0; ix<MemManSubtest5Count; ix++) {
//
// determine if even or odd allocation, if even and not 0, delete a section
//
            ssize = (112 * 1024);       //assume ODD allocation
            if ((ix & 1) == 0) {        //if it is an even one
                ssize = (232 * 1024);   //allocate 232 K on even passes
                if (ix){                //except on pass 0
                    SegxSize = 0;
                    status = NtFreeVirtualMemory (CurrentProcessHandle,
                                                  (PVOID *)&pa[ix/2],
                                                  &SegxSize,
                                                  MEM_RELEASE);

                    if (!NT_SUCCESS(status)) {
                        DbgPrint("service failed - status %lx\n", status);
                    }
                    pa[ix / 2] = 0;     //remember this one is gone
                }
            }  // end if even allocation


            pa[ix] = NULL;

            status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                              (PVOID *)&pa[ix],
                                              0,
                                              &ssize,
                                              MEM_RESERVE,
                                              PAGE_READWRITE);

            if (!NT_SUCCESS(status)) {
                DbgPrint("service failed - status %lx\n", status);
            }
        }  // for ix
//
// Now free up the memory used in this test
//
        for (ix=0; ix<MemManSubtest5Count; ix++) {
            if (pa[ix] != 0) {
                SegxSize = 0;
                status = NtFreeVirtualMemory (CurrentProcessHandle,
                                              (PVOID *)&pa[ix],
                                              &SegxSize,
                                              MEM_RELEASE);

                if (!NT_SUCCESS(status)) {
                    DbgPrint("service failed - status %lx\n", status);
                }
            }  // if
        }  // for
    }  // for ii

    FinishBenchMark( &PerfInfo );

    DbgPrint("that's all\n");
    return (TRUE);

}
int
StartBenchMark(
    PCHAR Title,
    ULONG Iterations,
    PPERFINFO PerfInfo
    )
{
    DbgPrint( "*** Start %s (%d iterations)\n",
            PerfInfo->Title = Title,
            PerfInfo->Iterations = Iterations
          );

    NtQuerySystemTime( (PLARGE_INTEGER)&PerfInfo->StartTime );
    return( TRUE );
}

VOID
FinishBenchMark(
    PPERFINFO PerfInfo
    )
{
    ULONG TotalMilliSeconds;
    ULONG IterationsPerSecond;
    ULONG IterationFractions;
    LARGE_INTEGER Delta;

    NtQuerySystemTime( (PLARGE_INTEGER)&PerfInfo->StopTime );

    Delta.QuadPart = PerfInfo->StopTime.QuadPart -
                                     PerfInfo->StartTime.QuadPart;

    TotalMilliSeconds = Delta.LowPart / 10000;

    IterationsPerSecond = (1000 * PerfInfo->Iterations) / TotalMilliSeconds;
    IterationFractions  = (1000 * PerfInfo->Iterations) % TotalMilliSeconds;
    IterationFractions  = (1000 * IterationFractions) / TotalMilliSeconds;
    if (1) {
        DbgPrint( "        iterations     - %9d\n", PerfInfo->Iterations );
        DbgPrint( "        milliseconds   - %9d\n", TotalMilliSeconds );
        DbgPrint( "        iterations/sec - %5d.%3d\n\n",
                IterationsPerSecond,
                IterationFractions
              );
        }
    BenchMarkNames[ TotalBenchMarks ] = PerfInfo->Title;
    BenchMarkRates[ TotalBenchMarks ] = IterationsPerSecond;
    BenchMarkFracs[ TotalBenchMarks ] = IterationFractions;
    TotalBenchMarks++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmtests\vmperf32.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <windows.h>

#define SEG_1_SIZE 1024 * 1024
#define SEG_X_SIZE 1024 * 1024 * 64

#define W32_MEMMAN_ITERATIONS       150
#define W32_MEMMAN_ITERATIONS2    20000
#define W32_MMST04_ITERATIONS       100
#define MemManSubtest5Count         200

int TotalBenchMarks = 0;
#define MAX_BENCHMARKS 32
char *BenchMarkNames[ MAX_BENCHMARKS ];
ULONG BenchMarkRates[ MAX_BENCHMARKS ];
ULONG BenchMarkFracs[ MAX_BENCHMARKS ];

typedef struct _PERFINFO {
    DWORD StartTime;
    DWORD StopTime;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

int
StartBenchMark(
    PCHAR Title,
    ULONG Iterations,
    PPERFINFO PerfInfo
    );

VOID
FinishBenchMark(
    PPERFINFO PerfInfo
    );

__cdecl
main(
    )

{

    PULONG_PTR p1, p2, p3, p4; // pointers into new segment
    PCHAR pa[MemManSubtest5Count]; // array for section pointers
    PULONG_PTR u1;
    ULONG actual;         // actual xfer count for read
    ULONG ssize;          // section allocation size var
    ULONG ii, ix;         // loop index variables
    PERFINFO PerfInfo;
    ULONG Seg1Size;
    ULONG SegxSize;
    ULONG CommitSize;
    HANDLE CurrentProcessHandle, Section1;
    LARGE_INTEGER SectionSize;
    ULONG Size;
    ULONG ViewSize;

    printf("Win32 Memory Management test\n");
    Size = 1024 * 1024;
    p1 = NULL;
    p1 = VirtualAlloc(NULL, Size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (p1 == NULL) {
        printf("failed first created vm status %X start %p size %lx\n",
               GetLastError(),
               p1,
               Size);
    }

    for (p2 = p1; p2 < (p1 + (Size / sizeof(ULONG_PTR))); p2 += 1) {
        *p2 = (ULONG_PTR)p2;
    }

    SectionSize.QuadPart = 1024 * 1024;
    Section1 = CreateFileMapping(INVALID_HANDLE_VALUE,
                                 NULL,
                                 PAGE_READWRITE | SEC_COMMIT,
                                 SectionSize.HighPart,
                                 SectionSize.LowPart,
                                 NULL);

    if (!Section1) {
        printf("failed create big section status %ld\n", GetLastError());
    }

    p3 = NULL;
    ViewSize = 0;
    p3 = MapViewOfFile(Section1, FILE_MAP_WRITE, 0, 0, 0);
    if (p3 == NULL) {
        printf("service failed mapview - status %X\n", GetLastError());
    }

//
//  Memory Management sub-test 1
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    StartBenchMark("Win32 MemMan0 - 1 Meg Copy", 150, &PerfInfo);
    for (ii = 0; ii < 150; ii += 1) {
        MoveMemory (p3, p1, Size);
    }

    FinishBenchMark(&PerfInfo);
    CloseHandle(Section1);
    if (!UnmapViewOfFile(p3)) {
        printf("unmap view service failed - status %X\n", GetLastError());
    }

//
//  Memory Management sub-test 1
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    StartBenchMark("Win32 MemMan01 - create 1mb section, copy 1mb, delete",
                   150,
                   &PerfInfo);

    for (ii = 0; ii < 150; ii += 1) {
        Section1 = CreateFileMapping(INVALID_HANDLE_VALUE,
                                     NULL,
                                     PAGE_READWRITE | SEC_COMMIT,
                                     SectionSize.HighPart,
                                     SectionSize.LowPart,
                                     NULL);

        if (!Section1) {
            printf("failed create big section status %X\n", GetLastError());
        }

        p3 = MapViewOfFile(Section1, FILE_MAP_WRITE, 0, 0, 0);
        if (p3 == NULL) {
            printf("service failed mapview - status %X\n", GetLastError());
        }

        MoveMemory(p3, p1, Size);
        p4 = MapViewOfFile(Section1, FILE_MAP_WRITE, 0, 0, 0);
        if (p4 == NULL) {
            printf("service failed mapview - status %X\n", GetLastError());
        }

        CloseHandle(Section1);
        if (!UnmapViewOfFile(p3)) {
            printf("unmap view service failed - status %X\n", GetLastError());
        }

        if (!UnmapViewOfFile(p4)) {
            printf("unmap view service failed - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

//
//  Memory Management sub-test 1
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    StartBenchMark("Win32 MemMan02 - alloc 1mb vm, copy 1mb, delete",
                   150,
                   &PerfInfo);

    for (ii = 0; ii < 150; ii++) {
        Size = 1024 * 1024;
        p3 = VirtualAlloc(NULL, Size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        if (p3 == NULL) {
            printf("service failed allocvm - status %ld\n", GetLastError());
        }

        MoveMemory (p3, p1, Size);
        if (!VirtualFree(p3, 0, MEM_RELEASE)) {
            printf("service failed freevm1 - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

    if (!VirtualFree (p1, 0, MEM_RELEASE)) {
        printf("service failed freevm2 - status %X\n", GetLastError());
    }

//
//  Memory Management sub-test 1
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    StartBenchMark("Win32 MemMan1 - 1 Meg Seg, Create, Commit & Touch",
                   W32_MEMMAN_ITERATIONS,
                   &PerfInfo);

    for (ii = 0; ii < W32_MEMMAN_ITERATIONS; ii += 1) {
        Seg1Size = SEG_1_SIZE;
        p1 = VirtualAlloc(NULL, Seg1Size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        if (p1 == NULL) {
            printf("service failed - status %X\n", GetLastError());
        }

        for (p2 = p1; p2 < (p1 + (Seg1Size / sizeof(ULONG_PTR))); p2 += 4096 /sizeof(ULONG_PTR)) {
            *p2 = 99;
        }

        if (!VirtualFree(p1, 0, MEM_RELEASE)) {
            printf("service failed freevm3 - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

//
//  Memory Management sub-test 1
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    StartBenchMark("Win32 MemMan1.5 - 1 Meg Seg, Create, reserve Commit & Touch",
                   W32_MEMMAN_ITERATIONS,
                   &PerfInfo);

    for (ii = 0; ii < W32_MEMMAN_ITERATIONS; ii += 1) {
        Seg1Size = SEG_1_SIZE;
        p1 = VirtualAlloc(NULL, Seg1Size, MEM_RESERVE | MEM_COMMIT, PAGE_READONLY);
        if (p1 == NULL) {
            printf("service failed - status %X\n", GetLastError());
        }

        if (!VirtualProtect(p1, Seg1Size, PAGE_READWRITE, &CommitSize)) {
            printf("service failed (ntprotect)- status %X\n", GetLastError());
        }

        for (p2 = p1; p2 < (p1 + (Seg1Size / sizeof(ULONG_PTR))); p2 += (4096 / sizeof(ULONG_PTR))) {
            *p2 = 99;
        }

        if (!VirtualFree(p1, 0, MEM_RELEASE)) {
            printf("service failed freevm4 - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

//
//  Memory Management sub-test 2
//
//      Create a 1 MB segment with commitment of the pages,
//      but never use the segment.
//

    StartBenchMark("Win32 MemMan2 - 1 Meg Seg, Create & Commit Only",
                   W32_MEMMAN_ITERATIONS2,
                   &PerfInfo);

    for (ii = 0; ii < W32_MEMMAN_ITERATIONS2; ii += 1) {
        p1 = NULL;
        Seg1Size = SEG_1_SIZE;
        p1 = VirtualAlloc(NULL, Seg1Size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        if (p1 == NULL) {
            printf("service failed - status %X\n", GetLastError());
        }

        if (!VirtualFree(p1, 0, MEM_RELEASE)) {
            printf("service failed freevm5 - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

//
//  Memory Management sub-test 3
//
//      Create a 1 MB segment without commitment of the pages,
//      but never use or commit the segment.
//

    StartBenchMark("Win32 MemMan3 - 1 Meg Seg Create Only",
                   W32_MEMMAN_ITERATIONS2,
                   &PerfInfo);

    for (ii = 0; ii < W32_MEMMAN_ITERATIONS2; ii += 1) {
        p1 = NULL;
        Seg1Size = SEG_1_SIZE;
        p1 = VirtualAlloc(NULL, Seg1Size, MEM_RESERVE, PAGE_READWRITE);
        if (p1 == NULL) {
            printf("service failed - status %X\n", GetLastError());
        }

        if (!VirtualFree(p1, 0, MEM_RELEASE)) {
            printf("service failed freevm6 - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

//
//  Memory Management sub-test 4
//
//      Create a 64 MB segment without committing the pages,
//      then commit and touch at 128 KB intervals.
//
//

    StartBenchMark("Win32 MemMan4 - 64 Meg Seg, Commit Sparse",
                   W32_MMST04_ITERATIONS,
                   &PerfInfo);

    for (ii = 0; ii < W32_MMST04_ITERATIONS; ii += 1) {
        p1 = NULL;
        SegxSize = SEG_X_SIZE;
        p1 = VirtualAlloc(NULL, SegxSize, MEM_RESERVE, PAGE_READWRITE);
        if (p1 == NULL) {
            printf("service failed - status %X\n", GetLastError());
        }

        CommitSize = 4;
        for (p2 = p1; p2 < (p1 + (SegxSize / sizeof(ULONG_PTR))); p2 += (256 * 1024 / sizeof(ULONG_PTR))) {
            p2 = VirtualAlloc(p2, CommitSize, MEM_COMMIT, PAGE_READWRITE);
            if (p2 == NULL) {
                printf("service failed - status %X\n", GetLastError());
            }

            if (*p2 != 0) {
                printf("%p = %lx\n", p2, *p2);
            }
        }

        if (!VirtualFree(p1, 0, MEM_RELEASE)) {
            printf("service failed freevm7 - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

//
//  Memory Management sub-test 5
//
//      Create a alternatively 232k and 112 k memory sections.
//      For every 2 created, delete 1.  Do this for MemManSubtest5Count times.
//
//

    StartBenchMark("Win32 MemMan5 - Sparse Section Create/Delete Benchmark",
                   W32_MEMMAN_ITERATIONS,
                   &PerfInfo);

    for (ii = 0; ii < W32_MEMMAN_ITERATIONS; ii += 1) {
        for (ix = 0; ix < MemManSubtest5Count; ix += 1) {

            //
            // determine if even or odd allocation, if even and not 0,
            // delete a section
            //

            ssize = (112 * 1024);       //assume ODD allocation
            if ((ix & 1) == 0) {        //if it is an even one
                ssize = (232 * 1024);   //allocate 232 K on even passes
                if (ix) {                //except on pass 0
                    if (!VirtualFree(pa[ix/2], 0, MEM_RELEASE)) {
                        printf("service failed freevm8 - status %X\n", GetLastError());
                    }

                    pa[ix / 2] = 0;     //remember this one is gone
                }
            }

            pa[ix] = VirtualAlloc(NULL, ssize, MEM_RESERVE, PAGE_READWRITE);
            if (pa[ix] == NULL) {
                printf("service failed - status %X\n", GetLastError());
            }
        }

        //
        // Now free up the memory used in this test
        //

        for (ix = 0; ix < MemManSubtest5Count; ix += 1) {
            if (pa[ix] != 0) {
                if (!VirtualFree(pa[ix], 0, MEM_RELEASE)) {
                    printf("service failed freevm9 - status %X\n", GetLastError());
                }
            }
        }
    }

    FinishBenchMark(&PerfInfo);
    printf("that's all\n");
    return (TRUE);
}
int
StartBenchMark(
    PCHAR Title,
    ULONG Iterations,
    PPERFINFO PerfInfo
    )

{

    printf("*** Start %s : %d\n",
           PerfInfo->Title = Title,
           PerfInfo->Iterations = Iterations);

    PerfInfo->StartTime = GetCurrentTime();
    return TRUE;
}

VOID
FinishBenchMark(
    PPERFINFO PerfInfo
    )

{

    ULONG TotalMilliSeconds;
    ULONG IterationsPerSecond;
    ULONG IterationFractions;
    DWORD Delta;

    PerfInfo->StopTime = GetCurrentTime();
    TotalMilliSeconds = PerfInfo->StopTime - PerfInfo->StartTime;
    IterationsPerSecond = (1000 * PerfInfo->Iterations) / TotalMilliSeconds;
    IterationFractions  = (1000 * PerfInfo->Iterations) % TotalMilliSeconds;
    IterationFractions  = (1000 * IterationFractions) / TotalMilliSeconds;
    if (1) {
        printf("        iterations     - %9d\n", PerfInfo->Iterations );
        printf("        milliseconds   - %9d\n", TotalMilliSeconds );
        printf("        iterations/sec - %5d.%3d\n\n",
               IterationsPerSecond,
               IterationFractions);
    }

    BenchMarkNames[TotalBenchMarks] = PerfInfo->Title;
    BenchMarkRates[TotalBenchMarks] = IterationsPerSecond;
    BenchMarkFracs[TotalBenchMarks] = IterationFractions;
    TotalBenchMarks++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmtests\vmquery.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    taststrs.c

Abstract:

    Tasking stress test.

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>

HANDLE Semaphore, Event;

VOID
TestThread(
    LPVOID ThreadParameter
    )
{
    DWORD st;

    (ReleaseSemaphore(Semaphore,1,NULL));

    st = WaitForSingleObject(Event,500);

    ExitThread(0);
}

VOID
NewProcess()
{
    PUCHAR buffer;

    buffer = VirtualAlloc (NULL, 600*1024, MEM_COMMIT, PAGE_READWRITE);

    Sleep(50000);

    TerminateProcess(GetCurrentProcess(),0);
}


DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    BOOL Success;
    DWORD st;
    DWORD ProcessCount;
    SMALL_RECT Window;
    MEMORY_BASIC_INFORMATION info;
    PUCHAR address;
    PUCHAR buffer;
    PUCHAR SystemRangeStart;

    ProcessCount = 0;
    if ( strchr(GetCommandLine(),'+') ) {
        NewProcess();
        }

    if (!NT_SUCCESS(NtQuerySystemInformation(SystemRangeStartInformation,
                                             &SystemRangeStart,
                                             sizeof(SystemRangeStart),
                                             NULL))) {
        // assume usermode is the low half of the address space
        SystemRangeStart = (PUCHAR)MAXLONG_PTR;
    }

    GetStartupInfo(&StartupInfo);

    Success = CreateProcess(
                    NULL,
                    "vmread +",
                    NULL,
                    NULL,
                    FALSE,
                    CREATE_NEW_CONSOLE,
                    NULL,
                    NULL,
                    &StartupInfo,
                    &ProcessInfo
                    );

    if (Success) {
        printf("Process Created\n");

        Sleep (1000);


        buffer = VirtualAlloc (NULL, 10*1000*1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

        if (!buffer) {
            printf("virtual alloc failed at %ld.\n",GetLastError());
            return 1;
        }

        address = NULL;
        do {

            Success = VirtualQueryEx (ProcessInfo.hProcess,
                                      (PVOID)address,
                                      &info,
                                      sizeof(info));

            if (!Success) {
                printf ("virtual query failed at %lx - %ld.\n",address,GetLastError());
                break;
            } else {
                printf("address: %lx size %lx state %lx protect %lx type %lx\n",
                    address,
                    info.RegionSize,
                    info.State,
                    info.Protect,
                    info.Type);
            }

            address += info.RegionSize;
        } while (address < SystemRangeStart);

        address = 0x40000000;
        do {

            Success = VirtualQueryEx (ProcessInfo.hProcess,
                                      (PVOID)address,
                                      &info,
                                      sizeof(info));

            if (!Success) {
                printf ("virtual query failed at %lx %ld.\n",address,GetLastError());
                return 1;
            } else {
                if (info.AllocationBase == address) {
                    printf("address: %lx size %lx state %lx protect %lx type %lx\n",
                        address,
                        info.RegionSize,
                        info.State,
                        info.Protect,
                        info.Type);
                }
            }
            address += 4096;
        } while (address < SystemRangeStart);

        CloseHandle(ProcessInfo.hProcess);
        CloseHandle(ProcessInfo.hThread);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmtests\vmread.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    taststrs.c

Abstract:

    Tasking stress test.

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>

HANDLE Semaphore, Event;

VOID
TestThread(
    LPVOID ThreadParameter
    )
{
    DWORD st;

    (ReleaseSemaphore(Semaphore,1,NULL));

    st = WaitForSingleObject(Event,500);

    ExitThread(0);
}

VOID
NewProcess()
{
    PUCHAR buffer;

    buffer = VirtualAlloc (NULL, 600*1024, MEM_COMMIT, PAGE_READWRITE);

    Sleep(10000);

    TerminateProcess(GetCurrentProcess(),0);
}

TCHAR szCmdLine[] = "vmread.exe +";
const TCHAR szAppName[] = "vmread.exe";

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    SIZE_T st;
    DWORD ProcessCount;
    SMALL_RECT Window;
    MEMORY_BASIC_INFORMATION info;
    PUCHAR address;
    PUCHAR buffer;
    PUCHAR SystemRangeStart;

    ProcessCount = 0;
    if ( strchr(GetCommandLine(),'+') ) {
        NewProcess();
        }

    if (!NT_SUCCESS(NtQuerySystemInformation(SystemRangeStartInformation,
                                             &SystemRangeStart,
                                             sizeof(SystemRangeStart),
                                             NULL))) {
        // assume usermode is the low half of the address space
        SystemRangeStart = (PUCHAR)MAXLONG_PTR;
    }

    GetStartupInfo(&StartupInfo);

    if (CreateProcess(
                    szAppName,
                    szCmdLine,
                    NULL,
                    NULL,
                    FALSE,
                    CREATE_NEW_CONSOLE,
                    NULL,
                    NULL,
                    &StartupInfo,
                    &ProcessInfo
                    ))
    {
        printf("Process Created\n");

        Sleep (1000);


        buffer = VirtualAlloc (NULL, 10*1000*1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

        if (!buffer) {
            printf("virtual alloc failed %ld.\n",GetLastError());
            return 1;
        }

        address = NULL;
        do {

            if (!VirtualQueryEx (ProcessInfo.hProcess,
                                      (PVOID)address,
                                      &info,
                                      sizeof(info)))
            {
                printf ("virtual query failed %ld.\n",GetLastError());
                break;
            } else {
                printf("address: %p size %lx state %lx protect %lx type %lx\n",
                    address,
                    info.RegionSize,
                    info.State,
                    info.Protect,
                    info.Type);
            }
            if ((info.Protect != PAGE_NOACCESS) &&
                (info.Protect != 0) &&
                (!(info.Protect & PAGE_GUARD))) {
                if (!ReadProcessMemory (ProcessInfo.hProcess,
                                             address,
                                             buffer,
                                             4,
                                             &st))
                {
                    printf("read vm4 failed at %p error %ld. \n",
                        address,
                        GetLastError());
                    return 1;
                }

                if (!ReadProcessMemory (ProcessInfo.hProcess,
                                             address,
                                             buffer,
                                             info.RegionSize,
                                             &st))
                {
                    printf("read vm failed at %p error %ld. \n",
                        address,
                        GetLastError());
                    return 1;
                }

            }

            address += info.RegionSize;
        } while (address < SystemRangeStart);

        address = NULL;
        do {

            if (!VirtualQueryEx (ProcessInfo.hProcess,
                                      (PVOID)address,
                                      &info,
                                      sizeof(info)))
            {
                printf ("virtual query failed %ld.\n",GetLastError());
                return 1;
            } else {
                printf("address: %p size %lx state %lx protect %lx type %lx\n",
                    address,
                    info.RegionSize,
                    info.State,
                    info.Protect,
                    info.Type);
            }
            if ((info.Protect != PAGE_NOACCESS) &&
                (info.Protect != 0) &&
                (!(info.Protect & PAGE_GUARD)) &&
                (info.Protect & PAGE_READWRITE) &&
                (info.State != MEM_IMAGE)) {
                if (!ReadProcessMemory (ProcessInfo.hProcess,
                                              address,
                                              buffer,
                                              4,
                                              &st) )
                {
                    printf("read vm5 failed at %p error %ld. \n",
                        address,
                        GetLastError());
                    return 1;
                }
                if (!WriteProcessMemory (ProcessInfo.hProcess,
                                              address,
                                              buffer,
                                              4,
                                              &st))
                {
                    printf("write vm4 failed at %p error %ld. \n",
                        address,
                        GetLastError());
                    return 1;
                }

                if (!ReadProcessMemory (ProcessInfo.hProcess,
                                              address,
                                              buffer,
                                              info.RegionSize,
                                              &st))
                {
                    printf("read 5 vm failed at %p error %ld. \n",
                        address,
                        GetLastError());
                    return 1;
                }

                if (!WriteProcessMemory (ProcessInfo.hProcess,
                                              address,
                                              buffer,
                                              info.RegionSize,
                                              &st))
                {
                    printf("write vm failed at %p error %ld. \n",
                        address,
                        GetLastError());
                    return 1;
                }

            }

            address += info.RegionSize;
        } while (address < SystemRangeStart);

        CloseHandle(ProcessInfo.hProcess);
        CloseHandle(ProcessInfo.hThread);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\walk\walk.c ===
/*      WALK - Walk a directory hierarchy
 *
 *      Mark Z.         ??/??/83
 *
 *      WALK walks a directory heirarchy and for each
 *      file or directory or both,
 *      prints the pathname, runs a program, or both.
 *
 *      walk [-f] [-d] [-h] [-print] topdir [command]
 *
 *      -f      deal with files
 *      -d      deal with directorys
 *              if neither is specified, deal with both
 *
 *      -h      Also find hidden directories and files
 *      -p[rint] print the pathnames on stdout
 *
 *      command optional command and arguments.  Pathname is
 *              substituted for every "%s" in the arguments
 *      Modification History
 *
 *      11/07/83        JGL
 *              - added -print switch
 *              - no longer an error to omit [command]
 *      15-May-87   bw  Add /h switch
 *      18-May-87   bw  Add code to recognize root directories
 *      23-Dec-1987 mz  Fix poor ./.. processing;  use system
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *
 */

#define INCL_DOSMISC

#include <direct.h>
#include <errno.h>

#include <malloc.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <windows.h>
#include <tools.h>

// Forward Function Declarations...
void walk( char *, struct findType *, void* );
void usage( void );


char **vec;
flagType fD = FALSE;            /* apply function to directories only */
flagType fF = FALSE;            /* apply function to files only       */
flagType fPrint = FALSE;        /* print pathnames                    */
unsigned srch_attr = FILE_ATTRIBUTE_DIRECTORY; /* Find non-hidden files and dirs          */
char cmdline[MAXLINELEN];       /* command line to be executed        */
char dir[MAX_PATH];
char cdir[MAX_PATH];

void walk (p, b, dummy)
char *p;
struct findType *b;
void * dummy;
{
    static flagType fFirst = TRUE;
    int i;
    char *ppat, *pdst;

    if (fFirst || strcmp (b->fbuf.cFileName, ".") && strcmp (b->fbuf.cFileName, "..")) {
        fFirst = FALSE;
        if ((!fD && !fF) ||                     /* no special processing */
            (fD && HASATTR(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)) ||       /* only dir and dir */
            (fF && !HASATTR(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY))) {      /* only file and file */
            if (fPrint)
                printf ("%s\n", p);
            if (vec[0]) {
                cmdline[0] = 0;
                for (i = 0; vec[i] != NULL; i++) {
                    strcat (cmdline, " ");
                    pdst = strend (cmdline);
                    ppat = vec[i];
                    while (*ppat != '\0')
                        if (ppat[0] == '%') {
                            if (ppat[1] == 'l') {
                                strcpy (pdst, p);
                                _strlwr (pdst);
                                pdst = strend (pdst);
                                ppat += 2;
                                }
                            else
                            if (ppat[1] == 'u') {
                                strcpy (pdst, p);
                                _strupr (pdst);
                                pdst = strend (pdst);
                                ppat += 2;
                                }
                            else
                            if (ppat[1] == 's') {
                                strcpy (pdst, p);
                                pdst = strend (pdst);
                                ppat += 2;
                                }
                            else
                                *pdst++ = *ppat++;
                        } else
                            *pdst++ = *ppat++;
                    *pdst = 0;
                    }
                i = system (cmdline);
                if (HIGH(i) != 0)
                    exit (1);
                }
            }

        if (HASATTR(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)) {
            switch (p[strlen(p)-1]) {
            case '/':
            case '\\':
                strcat (p, "*.*");
                break;
            default:
                strcat (p, "\\*.*");
                }
            forfile (p, srch_attr, walk, NULL);
            }
        }
    dummy;
}

int
__cdecl main (c, v)
int c;
char *v[];
{
    struct findType buf;

    ConvertAppToOem( c, v );
    SHIFT (c, v);
    while (c && fSwitChr (**v)) {
        switch (*(*v+1)) {
            case 'd':
                fD = TRUE;
                break;
            case 'f':
                fF = TRUE;
                break;
            case 'p':
                fPrint = TRUE;
                break;
            case 'h':
                srch_attr |= (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM); /* Find hidden/system files       */
                break;
            default:
                usage ();
            }
        SHIFT(c,v);
    }

    if (c == 0)
        usage ();

    strcpy (dir, *v);
    buf.fbuf.dwFileAttributes = GetFileAttributes( *v );
    SHIFT (c, v);

    if (c == 0 && !fPrint)
        usage ();

    if ( !HASATTR(buf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) )/* DOS doesn't think it's a directory, but */
        switch (dir[strlen(dir)-1]) {
            case '/':              /* ... the user does.                    */
            case '\\':
                SETFLAG (buf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY);
                break;
            default:                /* ... it could be a root directory     */
                _getcwd (cdir, MAX_PATH);
                if ( _chdir(dir) == 0 ) {
                    SETFLAG (buf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY);
                    _chdir (cdir);
                    }
            }

    vec = v;

    walk (dir, &buf, NULL);
    return( 0 );
}

void usage ()
{
    printf ("walk [/d] [/f] [/p] [/h] dir [cmd]\n\n");

    printf ("WALK walks a directory heirarchy and for each file, directory or both,\n");
    printf ("prints the pathname, runs a program, or both.\n\n");

    printf ("    -f       deal with files\n");
    printf ("    -d       deal with directorys\n");
    printf ("             if neither is specified, deal with both\n");
    printf ("    -h       Also find hidden directories and files\n");
    printf ("    -p[rint] print the pathnames on stdout\n");
    printf ("    [cmd]    optional command and arguments. \n");

    exit (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wc\wc.c ===
/*
 *      wc.c - counts lines, words and chars.  A word is defined as a
 *      maximal string of non-blank characters separated by blanks.
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <windows.h>
#include <tools.h>
/*
 *      options flags
 */
int     lflg, wflg, cflg, tflg;
unsigned long sumlines, sumwords, sumchars;

void
usage()
{
        fprintf(stderr, "usage: wc [-lwc] [files]\n" );
        exit(EXIT_FAILURE);
}

void
wc( fh )
FILE *fh;
{
        unsigned long lines, words, chars;
        int ch, inword = 0;

        lines = words = chars = 0L;

        while (1)
        {
                if ((ch = getc(fh)) == EOF ) break;
                ++chars;

                if ( isspace(ch) )
                {
                        if ( inword )
                                inword = 0;
                        if ( ch == '\n' )
                                ++lines;
                        continue;
                }

                if ( isalnum(ch) && !inword )
                {
                        inword = 1;
                        ++words;
                }
        }

        if ( lflg ) printf(" %10lu", lines );
        if ( wflg ) printf(" %10lu", words );
        if ( cflg ) printf(" %10lu", chars );

        sumlines += lines;
        sumwords += words;
        sumchars += chars;

        return;
}

__cdecl
main(
    int argc,
    char **argv
    )
{
        FILE    *fh;
        char    *p;

        SHIFT( argc, argv );

        while ( argc > 0 && ( **argv == '-' || **argv == '/' ) )
        {
                p = *argv;
                while (*++p)
                {
                        switch(*p)
                        {
                        case 'l':
                                lflg++;
                                break;
                        case 'w':
                                wflg++;
                                break;
                        case 'c':
                                cflg++;
                                break;
                        case '?':
                        default:
                                usage();
                        }
                }
                SHIFT( argc, argv );
        }
        if (!(lflg||wflg||cflg)) lflg = wflg = cflg = 1;
        if ( argc > 1 ) tflg++;                 /* print totals */

        if ( argc == 0 )
        {
                wc( stdin );
                printf("\n");
        }
        else
        {
                while ( argc )
                {
                        if (( fh = fopen( *argv, "rb" )) == NULL )
                        {
                                perror( *argv );
                                SHIFT( argc, argv );
                                continue;
                        }

                        wc( fh );
                        fclose( fh );
                        printf ("\t%s\n", *argv );
                        SHIFT( argc, argv );
                }
                if ( tflg )
                {
                        if ( lflg ) printf(" %10lu", sumlines );
                        if ( wflg ) printf(" %10lu", sumwords );
                        if ( cflg ) printf(" %10lu", sumchars );
                        printf("\tTotals\n");
                }
        }
        return (EXIT_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmtests\vmstress.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vmstress.c

Abstract:

    Test stress program for virtual memory.

Author:

    Lou Perazzoli (LouP) 26-Jul-91

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

typedef struct _INIT_ARG {
    PULONG_PTR Va;
    SIZE_T Size;
} INIT_ARG, *PINITARG;

VOID
VmRandom1 (
    LPVOID ThreadParameter
    );

VOID
VmRandom2 (
    LPVOID ThreadParameter
    );


VOID
VmRandom1 (
    LPVOID ThreadParameter
    )
{

    PINITARG InitialArg;
    ULONG Seed = 8373833;
    SIZE_T size;
    PULONG_PTR startva0;
    PULONG_PTR Va;
    ULONG i,j;

    InitialArg = (PINITARG)ThreadParameter;

    startva0 = InitialArg->Va;
    size = InitialArg->Size;

//    printf("starting random references in thread1\n");
    for (j = 1; j < 10; j++) {
        for (i = 1 ; i < 2500; i++) {

             RtlRandom (&Seed);
             Va = startva0 + (Seed % (size / sizeof(ULONG_PTR)));


             if (*Va == (((ULONG_PTR)Va + 1))) {
                 *Va = (ULONG_PTR)Va;

             } else {
                 if (*Va != (ULONG_PTR)Va) {
                     printf("bad random value in cell %p was %p\n", Va, (void *)*Va);
                 }
             }

        }
        Sleep (150);
    }
//    printf("terminating thread1\n");
    ExitThread(0);
}

VOID
VmRandom2 (
    LPVOID ThreadParameter
    )
{

    PINITARG InitialArg;
    ULONG Seed = 8373839;
    SIZE_T size;
    PULONG_PTR startva0;
    PULONG_PTR Va;
    ULONG i,j;

    InitialArg = (PINITARG)ThreadParameter;

    startva0 = InitialArg->Va;
    size = InitialArg->Size;

//    printf("starting random references in thread2\n");

    for (j = 1; j < 10; j++) {
        for (i = 1 ; i < 2500; i++) {

             RtlRandom (&Seed);
             Va = startva0 + (Seed % (size / sizeof(ULONG_PTR)));


             if (*Va == (((ULONG_PTR)Va + 1))) {
                 *Va = (ULONG_PTR)Va;

             } else {
                 if (*Va != (ULONG_PTR)Va) {
                     printf("bad random value in cell %p was %lx\n", Va, *Va);
                 }
             }
        }

        Sleep (150);
    }
//    printf("terminating thread2\n");
    ExitThread(0);
}


DWORD
__cdecl main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE Objects[2];
    MEMORYSTATUS MemStatus;
    INIT_ARG InitialArg;
    PULONG_PTR Va;
    PULONG_PTR EndVa;
    SIZE_T size;
    PULONG_PTR startva0;
    NTSTATUS status;
    DWORD ThreadId1, ThreadId2;
    ULONG count = 0;

    printf("Starting virtual memory stress test\n");

    for (;;) {

        //
        // Create a region of private memory based on the number of
        // available pages on this system.
        //

        GlobalMemoryStatus(&MemStatus);

        size = MemStatus.dwAvailPhys;
        if (size == 0) {
            size = 4096;
        }
        else {
            size -= 4*4096;
        }

        while (size != 0) {
            startva0 = NULL;
            status = NtAllocateVirtualMemory (NtCurrentProcess(),
                                              (PVOID *)&startva0,
                                              0,
                                              &size,
                                              MEM_COMMIT | MEM_RESERVE,
                                              PAGE_READWRITE);
            if (NT_SUCCESS(status)) {
                break;
            }
            else {

                //
                // Try for less memory.
                //

                size -= 4096;
            }
        }

        printf("created vm status, startva, size, %lX %p %p\n",
                status, startva0, (void *)size);

        if (!NT_SUCCESS(status)) {
            ExitProcess (0);
        }

        InitialArg.Va = startva0;
        InitialArg.Size = size;

        //
        // Set all memory to know values (not zeroes).
        //

        printf("initializing memory\n");

        EndVa = (PULONG_PTR)startva0 + (size/sizeof(ULONG_PTR));

        Va = startva0;

        while (Va < EndVa) {
            *Va = (ULONG_PTR)Va + 1;
            Va += 1;
        }

        do {
            Objects[0] = CreateThread(NULL,
                                  0L,
                                  (LPTHREAD_START_ROUTINE)VmRandom1,
                                  (LPVOID)&InitialArg,
                                  0,
                                  &ThreadId1);
            //
            // Must have run out of memory, wait a while and then try again.
            //

            if (Objects[0] == (HANDLE)0) {
                Sleep (3000);
            }

        } while (Objects[0] == (HANDLE)0);

        do {
            Objects[1] = CreateThread(NULL,
                                  0L,
                                  (LPTHREAD_START_ROUTINE)VmRandom2,
                                  (LPVOID)&InitialArg,
                                  0,
                                  &ThreadId2);
            //
            // Must have run out of memory, wait a while and then try again.
            //

            if (Objects[1] == (HANDLE)0) {
                Sleep (3000);
            }
        } while (Objects[1] == (HANDLE)0);

        WaitForMultipleObjects (2,
                                Objects,
                                TRUE,
                                -1);

        count += 1;
        printf("stress test pass number %ld complete\n",count);

        CloseHandle (Objects[0]);
        CloseHandle (Objects[1]);

        printf("freeing vm startva, size, %p %p\n",
                startva0, (void *)size);

        status = NtFreeVirtualMemory (NtCurrentProcess(),
                                      (PVOID *)&startva0,
                                      &size,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            ExitProcess (0);
        }

        Sleep (1000);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\vmtests\vmtest.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define DbgPrint printf
#define NtTerminateProcess(a,b) ExitProcess(b)

__cdecl
main(
    )

{

    SIZE_T size, Size;
    PVOID BaseAddress;
    LONG i, j;
    PULONG p4, p3, p2, p1, oldp1, vp1;
    SIZE_T Size1, Size2, Size3;
    NTSTATUS status, alstatus;
    HANDLE CurrentProcessHandle;
    HANDLE GiantSection;
    HANDLE Section2, Section4;
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG OldProtect;
    STRING Name3;
    HANDLE Section1;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_ATTRIBUTES Object1Attributes;
    SIZE_T ViewSize;
    LARGE_INTEGER Offset;
    LARGE_INTEGER SectionSize;
    UNICODE_STRING Unicode;
    LOGICAL Os64Bit;
    SYSTEM_PROCESSOR_INFORMATION SysInfo;

    Os64Bit = FALSE;

    //
    // If we're running on a 64-bit OS, make large memory calls.
    //

    status = NtQuerySystemInformation (SystemProcessorInformation,
                                       &SysInfo,
                                       sizeof(SYSTEM_PROCESSOR_INFORMATION),
                                       NULL);

    if (NT_SUCCESS(status)) {
        if (SysInfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 ||
            SysInfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) {
            Os64Bit = TRUE;
        }
    }

    DbgPrint("****Memory Management Tests (%d-bit) - AllocVm, FreeVm, ProtectVm, QueryVm\n", Os64Bit == TRUE ? 64 : 32);

    CurrentProcessHandle = NtCurrentProcess();

    p1 = (PULONG)0x20020000;
    Size1 = 0xbc0000;
    DbgPrint("    Test 1 - ");
    alstatus = NtAllocateVirtualMemory(CurrentProcessHandle,
                                       (PVOID *)&p1,
                                       0,
                                       &Size1,
                                       MEM_RESERVE | MEM_COMMIT,
                                       PAGE_READWRITE);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("Failed allocate with status %lx start %p size %p\n",
                 alstatus,
                 p1,
                 (void *)Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 2 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p1,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status) ||
        (MemInfo.RegionSize != Size1) ||
        (MemInfo.BaseAddress != p1) ||
        (MemInfo.Protect != PAGE_READWRITE) ||
        (MemInfo.Type != MEM_PRIVATE) ||
        (MemInfo.State != MEM_COMMIT)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 p1,
                 MemInfo.BaseAddress,
                 (void *)MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }


    DbgPrint("    Test 3 - ");
    p2 = NULL;
    Size2 = 0x100000;
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p2,
                                     3,
                                     &Size2,
                                     MEM_TOP_DOWN | MEM_RESERVE | MEM_COMMIT,
                                     PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed allocate with status %lx start %p size %p\n",
                 status,
                 p2,
                 (void *)Size2);

    } else {
        DbgPrint("Succeeded\n");
    }

    //
    // Touch every other page.
    //

    DbgPrint("    Test 4 - ");
    try {
        vp1 = p2 + 3000;
        while (vp1 < (p2 + (Size2 / sizeof(ULONG)))) {
            *vp1 = 938;
            vp1 += 3000;
        }

        DbgPrint("Succeeded\n");

    } except(EXCEPTION_EXECUTE_HANDLER) {
        DbgPrint("Failed with an exception\n");
    }

    //
    // Decommit pages.
    //

    DbgPrint("    Test 5 - ");
    Size3 = Size2 - 5044;
    vp1 = p2 + 3000;
    status = NtFreeVirtualMemory(CurrentProcessHandle,
                                 (PVOID *)&p2,
                                 &Size3,
                                 MEM_DECOMMIT);

    if (!(NT_SUCCESS(status))) {
        DbgPrint("Failed free with status %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

    //
    // Split the memory block using MEM_RELEASE.
    //

    DbgPrint("    Test 6 - ");
    vp1 = p2 + 5000;
    Size3 = Size2 - 50000;
    status = NtFreeVirtualMemory(CurrentProcessHandle,
                                 (PVOID *)&vp1,
                                 &Size3,
                                 MEM_RELEASE);

    if (!(NT_SUCCESS(status))) {
        DbgPrint("Failed free with status %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 7 - ");
    vp1 = p2 + 3000;
    Size3 = 41;
    status = NtFreeVirtualMemory(CurrentProcessHandle,
                                 (PVOID *)&vp1,
                                 &Size3,
                                 MEM_RELEASE);

    if (!(NT_SUCCESS(status))) {
        DbgPrint("Failed free with status %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

    //
    // free every page, ignore the status.
    //

    vp1 = p2;
    Size3 = 30;
    while (vp1 < (p2 + (Size2 / sizeof(ULONG)))) {
        status = NtFreeVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&vp1,
                                     &Size3,
                                     MEM_RELEASE);
        vp1 += 128;
    }

    DbgPrint("    Test 8 - ");
    p2 = NULL;
    Size2 = 0x10000;
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p2,
                                     3,
                                     &Size2,
                                     MEM_TOP_DOWN | MEM_RESERVE | MEM_COMMIT,
                                     PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed allocate with status %lx start %p size %p\n",
                 status,
                 p2,
                 (void *)Size1);

    } else {
        if (p2 < (PULONG)0x1fff0000) {
            DbgPrint("Failed allocate at top of memory at %p\n", p2);
        }

        status = NtFreeVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p2,
                                     &Size2,
                                     MEM_RELEASE);

        if (!(NT_SUCCESS(status))) {
            DbgPrint("Failed free with status %lx\n", status);

        } else {
            DbgPrint("Succeeded with allocation at %p\n", p2);
        }
    }

    DbgPrint("    Test 9 - ");
    if (NT_SUCCESS(alstatus)) {
        status = NtFreeVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p1,
                                     &Size1,
                                     MEM_RELEASE);

        if (!(NT_SUCCESS(status))) {
            DbgPrint("Failed free with status %lx\n", status);

        } else {
            DbgPrint("Succeeded\n");
        }

    } else {
        DbgPrint("Failed allocate with status %lx\n", alstatus);
    }


    DbgPrint("    Test 10 - ");
    p1 = NULL;
    Size1 = 16 * 4096;
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p1,
                                     0,
                                     &Size1,
                                     MEM_RESERVE, PAGE_READWRITE | PAGE_GUARD);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed created with status %lx start %p size %p\n",
                 status,
                 p1,
                 (void *)Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 11 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p1,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status) ||
        (MemInfo.RegionSize != Size1) ||
        (MemInfo.BaseAddress != p1) ||
        (MemInfo.AllocationProtect != (PAGE_READWRITE | PAGE_GUARD)) ||
        (MemInfo.Protect != 0) ||
        (MemInfo.Type != MEM_PRIVATE) ||
        (MemInfo.State != MEM_RESERVE)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 p1,
                 MemInfo.BaseAddress,
                 (void *)MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx alloc_protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.AllocationProtect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }


    DbgPrint("    Test 12 - ");
    Size2 = 8192;
    oldp1 = p1;
    p1 = p1 + 14336;  // 64k -8k /4
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p1,
                                     0,
                                     &Size2,
                                     MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed creat with status %lx start %p size %p\n",
                 status,
                 p1,
                 (void *)Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 13 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  oldp1,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status) ||
        (MemInfo.RegionSize != 56*1024) ||
        (MemInfo.BaseAddress != oldp1) ||
        (MemInfo.AllocationProtect != (PAGE_READWRITE | PAGE_GUARD)) ||
        (MemInfo.Protect != 0) ||
        (MemInfo.Type != MEM_PRIVATE) ||
        (MemInfo.State != MEM_RESERVE)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 oldp1,
                 MemInfo.BaseAddress,
                 (void *)MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx alloc_protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.AllocationProtect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 14 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p1,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status) ||
        (MemInfo.RegionSize != Size2) || (MemInfo.BaseAddress != p1) ||
        (MemInfo.Protect != PAGE_EXECUTE_READWRITE) || (MemInfo.Type != MEM_PRIVATE) ||
        (MemInfo.State != MEM_COMMIT)
        || (MemInfo.AllocationBase != oldp1)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 oldp1,
                 MemInfo.BaseAddress,
                 (void *)MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 15 - ");
    Size1 = Size2;
    status = NtProtectVirtualMemory(CurrentProcessHandle,
                                    (PVOID *)&p1,
                                    &Size1,
                                    PAGE_READONLY | PAGE_NOCACHE, &OldProtect);

    if ((!NT_SUCCESS(status)) ||
        (OldProtect != PAGE_EXECUTE_READWRITE)) {
        DbgPrint("Failed protect with status %lx base %p size %p old protect %lx\n",
                 status,
                 p1,
                 (void *)Size1,
                 OldProtect);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 16 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p1,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if ((!NT_SUCCESS(status)) ||
        (MemInfo.Protect != (PAGE_NOCACHE | PAGE_READONLY))) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 p1,
                 MemInfo.BaseAddress,
                 (void *)MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 17 - ");
    i = *p1;
    status = NtProtectVirtualMemory(CurrentProcessHandle,
                                    (PVOID *)&p1,
                                    &Size1,
                                    PAGE_NOACCESS | PAGE_NOCACHE, &OldProtect);

    if (status != STATUS_INVALID_PAGE_PROTECTION) {
        DbgPrint("Failed protect with status %lx, base %p, size %p, old protect %lx\n",
                 status,
                 p1,
                 (void *)Size1,
                 OldProtect);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 18 - ");
    status = NtProtectVirtualMemory(CurrentProcessHandle,
                                    (PVOID *)&p1,
                                    &Size1,
                                    PAGE_READONLY,
                                    &OldProtect);

    if ((!NT_SUCCESS(status)) ||
        (OldProtect != (PAGE_NOCACHE | PAGE_READONLY))) {
        DbgPrint("Failed protect with status %lx base %p size %p old protect %lx\n",
                 status,
                 p1,
                 (void *)Size1,
                 OldProtect);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 19 - ");
    status = NtProtectVirtualMemory(CurrentProcessHandle,
                                    (PVOID *)&p1,
                                    &Size1,
                                    PAGE_READWRITE,
                                    &OldProtect);

    if ((!NT_SUCCESS(status)) ||
        (OldProtect != (PAGE_READONLY))) {
        DbgPrint("Failed protect with status %lx base %p size %p old protect %lx\n",
                 status,
                 p1,
                 (void *)Size1,
                 OldProtect);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 20 - ");
    for (i = 1; i < 12; i++) {
        p2 = NULL;
        Size2 = i * 4096;
        status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                         (PVOID *)&p2,
                                         0,
                                         &Size2,
                                         MEM_COMMIT,
                                         PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("Failed creat with status %lx start %p size %p\n",
                     status,
                     p2,
                     (void *)Size2);

            break;

        }

        if (i == 4) {
            p3 = p2;
        }

        if (i == 8) {
            Size3 = 12000;
            status = NtFreeVirtualMemory(CurrentProcessHandle,
                                         (PVOID *)&p3,
                                         &Size3,
                                         MEM_RELEASE);

            if (!NT_SUCCESS(status)) {
                DbgPrint("Failed free with status %lx start %p size %p\n",
                         status,
                         p3,
                         (void *)Size3);

                break;
            }
        }
    }

    if (i == 12) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 21 - ");
    p3 = p1 + 8 * 1024;
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p3,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 p3,
                 MemInfo.BaseAddress,
                 (void *)MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 22 - ");
    p3 = p1 - 8 * 1024;
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p3,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 p3,
                 MemInfo.BaseAddress,
                 (void *)MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 23 - ");
    Size3 = 16 * 4096;
    status = NtFreeVirtualMemory(CurrentProcessHandle,
                                 (PVOID *)&p3,
                                 &Size3,
                                 MEM_RELEASE);

    if (status != STATUS_UNABLE_TO_FREE_VM) {
        DbgPrint("Failed free with status %lx start %p size %p\n",
                 status,
                 p3,
                 (void *)Size3);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 24 - ");
    Size3 = 1 * 4096;
    status = NtFreeVirtualMemory(CurrentProcessHandle,
                                 (PVOID *)&p3,
                                 &Size3,
                                 MEM_RELEASE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed free with status %lx start %p size %p\n",
                 status,
                 p3,
                 (void *)Size3);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 25 - ");
    p3 = NULL;
    Size3 = 300 * 4096;
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p3,
                                     0,
                                     &Size3,
                                     MEM_COMMIT, PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed creat with status %lx start %p size %p\n",
                 status,
                 p3,
                 (void *)Size3);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 26 - ");
    p1 = p3;
    p2 = ((PULONG)((PUCHAR)p3 + Size3));
    p4 = p1;
    j = 0;
    while (p3 < p2) {
        j += 1;
        if (j % 8 == 0) {
            if (*p4 != (ULONG)((ULONG_PTR)p4)) {
                DbgPrint("Failed bad value in xcell %p value is %lx\n", p4, *p4);
                break;
            }

            p4 += 1;
            *p4 = (ULONG)((ULONG_PTR)p4);
            p4 = p4 + 1026;
        }

        *p3 = (ULONG)((ULONG_PTR)p3);
        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 27 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p3,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 p3,
                 MemInfo.BaseAddress,
                 (void *)MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 28 - ");
    p3 = p1;
    while (p3 < p2) {
        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("Failed bad value in 1cell %p value is %lx\n", p3, *p3);
            break;
        }

        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 29 - ");
    p3 = p1;
    while (p3 < p2) {
        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("Failed bad value in 2cell %p value is %lx\n", p3, *p3);
            break;
        }

        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 30 - ");
    p3 = p1;
    while (p3 < p2) {
        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("Failed bad value in 3cell %p value is %lx\n", p3, *p3);
            break;
        }

        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 31 - ");
    p3 = p1;
    while (p3 < p2) {
        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("Failed bad value in 4cell %p value is %lx\n", p3, *p3);
            break;
        }

        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 32 - ");
    p3 = p1;
    while (p3 < p2) {
        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("Failed bad value in 5cell %p value is %lx\n", p3, *p3);
            break;
        }

        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 33 - ");
    p3 = p1;
    while (p3 < p2) {
        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("Failed bad value in cell %p value is %lx\n", p3, *p3);
            break;
        }

        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    //
    // Check physical frame mapping.
    //

    DbgPrint("    Test 34 - ");
    RtlInitAnsiString(&Name3, "\\Device\\PhysicalMemory");
    RtlAnsiStringToUnicodeString(&Unicode, &Name3, TRUE);
    InitializeObjectAttributes(&ObjectAttributes,
                               &Unicode,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenSection(&Section1,
                           SECTION_MAP_READ | SECTION_MAP_WRITE,
                           &ObjectAttributes);

    RtlFreeUnicodeString(&Unicode);
    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed open physical section with status %lx\n", status);
        DbgPrint("              skipping test 35\n");
        goto Test36;

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 35 - ");
    p1 = NULL;
    Offset.QuadPart = 0x810ff033;
    ViewSize = 300 * 4096;
    status = NtMapViewOfSection(Section1,
                                NtCurrentProcess(),
                                (PVOID *)&p1,
                                0,
                                ViewSize,
                                &Offset,
                                &ViewSize,
                                ViewUnmap,
                                0,
                                PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed map physical section %lx offset %p base %p\n",
                 status,
                 Offset.QuadPart,
                 p1);

    } else {
        DbgPrint("Succeeded\n");
    }

Test36:
    DbgPrint("    Test 36 - ");
    p1 = NULL;
    Size1 = 8 * 1024 * 1024;
    alstatus = NtAllocateVirtualMemory(CurrentProcessHandle,
                                       (PVOID *)&p1,
                                       0,
                                       &Size1,
                                       MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("Failed created with status %lx start %p size %p\n",
                 alstatus,
                 p1,
                 Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

    try {
        RtlZeroMemory(p1, Size1);

    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    DbgPrint("    Test 37 - ");
    Size1 -= 20000;
    (PUCHAR)p1 += 5000;
    status = NtFreeVirtualMemory(CurrentProcessHandle,
                                 (PVOID *)&p1,
                                 &Size1 ,
                                 MEM_DECOMMIT);

    if (!(NT_SUCCESS(status))) {
        DbgPrint("Failed free with status %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 38 - ");
    Size1 -= 20000;
    (PUCHAR)p1 += 5000;
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                       (PVOID *)&p1,
                                       0,
                                       &Size1,
                                       MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed create with status %lx start %p size %p\n",
                 status,
                 p1,
                 Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

    try {
        RtlZeroMemory(p1, Size1);

    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    DbgPrint("    Test 39 - ");
    Size1 = 28 * 4096;
    p1 = NULL;
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p1,
                                     0,
                                     &Size1,
                                     MEM_COMMIT, PAGE_READWRITE | PAGE_GUARD);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed create with status %lx start %p size %p\n",
                 status,
                 p1,
                 Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 40 - ");
    try {

        //
        // attempt to write the guard page.
        //

        *p1 = 973;
        DbgPrint("Failed guard page exception did not occur\n");

    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != STATUS_GUARD_PAGE_VIOLATION) {
            DbgPrint("Failed incorrect guard exception code %lx\n", status);

        } else {
            DbgPrint("Succeeded\n");
        }
    }

    DbgPrint("    Test 41 - ");
    p2 = NULL;
    Size2 = 200 * 1024 * 1024;  //200MB
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p2,
                                     0,
                                     &Size2,
                                     MEM_COMMIT, PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed allocate with status %lx\n", status);

    } else {
        status = NtFreeVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p2,
                                     &Size2,
                                     MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("Failed free with status %lx\n", status);

        } else {
            DbgPrint("Succeeded\n");
        }
    }

    //
    // Create a giant section 2gb on 32-bit system, 4gb on 64_bit system.
    //

    DbgPrint("    Test 42 - ");
    InitializeObjectAttributes(&Object1Attributes,
                               NULL,
                               0,
                               NULL,
                               NULL);

#if defined(_WIN64)

    SectionSize.QuadPart = 0xffffffff;

#else

    SectionSize.QuadPart = 0x7f000000;

#endif

    status = NtCreateSection(&GiantSection,
                             SECTION_MAP_READ | SECTION_MAP_WRITE,
                             &Object1Attributes,
                             &SectionSize,
                             PAGE_READWRITE,
                             SEC_RESERVE,
                             NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed create big section with status %lx\n", status);
        DbgPrint("              skipping test 43\n");
        goto Test44;

    } else {
        DbgPrint("Succeeded\n");
    }

    //
    // Attempt to map the section (this should fail).
    //

    DbgPrint("    Test 43 - ");
    p1 = NULL;
    ViewSize = 0;
    status = NtMapViewOfSection(GiantSection,
                                CurrentProcessHandle,
                                (PVOID *)&p1,
                                0L,
                                0,
                                0,
                                &ViewSize,
                                ViewUnmap,
                                0,
                                PAGE_READWRITE );

    if (status != STATUS_NO_MEMORY) {
        DbgPrint("Failed map big section status %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

Test44:
    DbgPrint("    Test 44 - ");
    i = 0;

#if defined(_WIN64)
    if (Os64Bit == TRUE) {
        Size2 = (SIZE_T)(32i64 * 1024 * 1024 * 1024 + 9938);
    }
    else {
        Size2 = 8 * 1024 * 1024 + 9938;
    }
#else
    Size2 = 8 * 1024 * 1024 + 9938;
#endif

    do {
        p2 = NULL;
        i += 1;
        status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                         (PVOID *)&p2,
                                         0,
                                         &Size2,
                                         MEM_RESERVE, PAGE_READWRITE);

    } while (NT_SUCCESS(status));

    if (status != STATUS_NO_MEMORY) {
        DbgPrint("Failed with status %lx after %d allocations\n", status, i);

    } else {
        DbgPrint("Succeeded with %d allocations\n", i);
    }

    //
    // we pass an address of 1, so mm will round it down to 0.  if we
    // passed 0, it looks like a not present argument
    //
    // N.B.  We have to make two separate calls to allocatevm, because
    //       we want a specific virtual address.  If we don't first reserve
    //       the address, the mm fails the commit call.
    //

    DbgPrint("    Test 45 - ");
    Size = 50 * 1024;
    size = Size - 1;
    BaseAddress = (PVOID)1;
    status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &BaseAddress,
                                     0L,
                                     &size,
                                     MEM_RESERVE,
                                     PAGE_READWRITE );

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed reserve with status = %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 46 - ");
    size = Size - 1;
    BaseAddress = (PVOID)1;
    status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &BaseAddress,
                                     0L,
                                     &size,
                                     MEM_COMMIT,
                                     PAGE_READWRITE );

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed commit with status = %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

    //
    // Test MEM_DOS_LIM support.
    //

#ifdef i386

    DbgPrint("    Test 47 - ");
    InitializeObjectAttributes(&Object1Attributes,
                               NULL,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    SectionSize.QuadPart = 1575757,
    status = NtCreateSection(&Section4,
                             SECTION_MAP_READ | SECTION_MAP_WRITE,
                             &Object1Attributes,
                             &SectionSize,
                             PAGE_READWRITE,
                             SEC_COMMIT,
                             NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed create section with status %lx section handle %lx\n",
                 status,
                 (ULONG)Section4);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 48 - ");
    p3 = (PVOID)0x9001000;
    ViewSize = 8000;
    status = NtMapViewOfSection(Section4,
                                CurrentProcessHandle,
                                (PVOID *)&p3,
                                0L,
                                0,
                                0,
                                &ViewSize,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_READWRITE );

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed map section with status %lx base %lx size %lx\n",
                 status,
                 (ULONG)p3,
                 ViewSize);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 49 - ");
    p2 = (PVOID)0x9003000;
    ViewSize = 8000;
    status = NtMapViewOfSection(Section4,
                                CurrentProcessHandle,
                                (PVOID *)&p2,
                                0L,
                                0,
                                0,
                                &ViewSize,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_READWRITE );

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed map section with status %lx base %lx size %lx\n",
                 status,
                 (ULONG)p3,
                 ViewSize);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 50 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p3,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed query with status %lx address %lx Base %lx size %lx\n",
                 status,
                 p1,
                 MemInfo.BaseAddress,
                 MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 51 - ");
    *p3 = 98;
    if (*p3 != *p2) {
        DbgPrint("Failed compare with %lx %lx\n", *p3, *p2);

    } else {
        DbgPrint("Succeeded\n");
    }


    DbgPrint("    Test 52 - ");
    Size2 = 8;
    p1 = (PVOID)((ULONG)p2 - 0x3000);
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p1,
                                     0,
                                     &Size2,
                                     MEM_COMMIT,
                                     PAGE_EXECUTE_READWRITE);

    if (NT_SUCCESS(status)) {
        DbgPrint("Failed create with status %lx start %lx size %lx\n",
                 status,
                 p1,
                 Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

#endif
    DbgPrint("****End of Memory Management Tests\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wcache\scsi.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    scsi.h

Abstract:

    These are the structures and defines that are used in the
    SCSI port and class drivers.

Authors:

    John Freeman (johnfr) 28-Mar-90
    Andre Vachon (andrev) 06-Jun-90
    Mike Glass (mglass)
    Jeff Havens (jhavens)

Revision History:

--*/
#ifndef _NTSCSI_
#define _NTSCSI_

//
// Define SCSI maximum configuration parameters.
//

#define SCSI_MAXIMUM_TARGETS 8
#define SCSI_MAXIMUM_LOGICAL_UNITS 8
#define SCSI_MAXIMUM_TARGETS_PER_BUS 32

#define MAXIMUM_CDB_SIZE 12

//
// Command Descriptor Block. Passed by SCSI controller chip over the SCSI bus
//

typedef union _CDB {

    //
    // Generic 6-Byte CDB
    //

    struct _CDB6GENERIC {
       UCHAR  OperationCode;
       UCHAR  Immediate : 1;
       UCHAR  CommandUniqueBits : 4;
       UCHAR  LogicalUnitNumber : 3;
       UCHAR  CommandUniqueBytes[3];
       UCHAR  Link : 1;
       UCHAR  Flag : 1;
       UCHAR  Reserved : 4;
       UCHAR  VendorUnique : 2;
    } CDB6GENERIC, *PCDB6GENERIC;

    //
    // Standard 6-byte CDB
    //

    struct _CDB6READWRITE {
        UCHAR OperationCode;
        UCHAR LogicalBlockMsb1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockMsb0;
        UCHAR LogicalBlockLsb;
        UCHAR TransferBlocks;
        UCHAR Control;
    } CDB6READWRITE, *PCDB6READWRITE;


    //
    // SCSI Inquiry CDB
    //

    struct _CDB6INQUIRY {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode;
        UCHAR IReserved;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY, *PCDB6INQUIRY;

    //
    // SCSI Format CDB
    //

    struct _CDB6FORMAT {
        UCHAR OperationCode;
        UCHAR FormatControl : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR FReserved1;
        UCHAR InterleaveMsb;
        UCHAR InterleaveLsb;
        UCHAR FReserved2;
    } CDB6FORMAT, *PCDB6FORMAT;

    //
    // Standard 10-byte CDB

    struct _CDB10 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved2;
        UCHAR TransferBlocksMsb;
        UCHAR TransferBlocksLsb;
        UCHAR Control;
    } CDB10, *PCDB10;

    //
    // CD Rom Audio CDBs
    //

    struct _PAUSE_RESUME {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[6];
        UCHAR Action;
        UCHAR Control;
    } PAUSE_RESUME, *PPAUSE_RESUME;

    //
    // Read Table of Contents
    //

    struct _READ_TOC {
        UCHAR OperationCode;
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[4];
        UCHAR StartingTrack;
        UCHAR AllocationLength[2];
        UCHAR Control : 6;
        UCHAR Format : 2;
    } READ_TOC, *PREAD_TOC;

    struct _PLAY_AUDIO_MSF {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Control;
    } PLAY_AUDIO_MSF, *PPLAY_AUDIO_MSF;

    //
    // Read SubChannel Data
    //

    struct _SUBCHANNEL {
        UCHAR OperationCode;
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2 : 6;
        UCHAR SubQ : 1;
        UCHAR Reserved3 : 1;
        UCHAR Format;
        UCHAR Reserved4[2];
        UCHAR TrackNumber;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } SUBCHANNEL, *PSUBCHANNEL;

    //
    // Mode sense
    //

    struct _MODE_SENSE {
        UCHAR OperationCode;
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3;
        UCHAR AllocationLength;
        UCHAR Control;
    } MODE_SENSE, *PMODE_SENSE;

    //
    // Mode select
    //

    struct _MODE_SELECT {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR ParameterListLength;
        UCHAR Control;
    } MODE_SELECT, *PMODE_SELECT;

    struct _LOCATE {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR CPBit : 1;
        UCHAR BTBit : 1;
        UCHAR Reserved1 : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved4;
        UCHAR Partition;
        UCHAR Control;
    } LOCATE, *PLOCATE;

    struct _LOGSENSE {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR PPCBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2;
        UCHAR Reserved3;
        UCHAR ParameterPointer[2];  // [0]=MSB, [1]=LSB
        UCHAR AllocationLength[2];  // [0]=MSB, [1]=LSB
        UCHAR Control;
    } LOGSENSE, *PLOGSENSE;

    struct _PRINT {
        UCHAR OperationCode;
        UCHAR Reserved : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } PRINT, *PPRINT;

    struct _SEEK {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved2[3];
        UCHAR Control;
    } SEEK, *PSEEK;

    struct _ERASE {
        UCHAR OperationCode;
        UCHAR Long : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[3];
        UCHAR Control;
    } ERASE, *PERASE;

    struct _START_STOP {
        UCHAR OperationCode;
        UCHAR Immediate: 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } START_STOP, *PSTART_STOP;

    struct _MEDIA_REMOVAL {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR Prevent;
        UCHAR Control;
    } MEDIA_REMOVAL, *PMEDIA_REMOVAL;

    //
    // Tape CDBs
    //

    struct _SEEK_BLOCK {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR BlockAddress[3];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } SEEK_BLOCK, *PSEEK_BLOCK;

    struct _REQUEST_BLOCK_ADDRESS {
        UCHAR OperationCode;
        UCHAR Reserved1[3];
        UCHAR AllocationLength;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } REQUEST_BLOCK_ADDRESS, *PREQUEST_BLOCK_ADDRESS;

    struct _PARTITION {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Sel: 1;
        UCHAR PartitionSelect : 6;
        UCHAR Reserved1[3];
        UCHAR Control;
    } PARTITION, *PPARTITION;

    struct _WRITE_TAPE_MARKS {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR WriteSetMarks: 1;
        UCHAR Reserved : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } WRITE_TAPE_MARKS, *PWRITE_TAPE_MARKS;

    struct _SPACE_TAPE_MARKS {
        UCHAR OperationCode;
        UCHAR Code : 3;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR NumMarksMSB ;
        UCHAR NumMarks;
        UCHAR NumMarksLSB;
        union {
            UCHAR value;
            struct {
                UCHAR Link : 1;
                UCHAR Flag : 1;
                UCHAR Reserved : 4;
                UCHAR VendorUnique : 2;
            } Fields;
        } Byte6;
    } SPACE_TAPE_MARKS, *PSPACE_TAPE_MARKS;

    //
    // Read tape position
    //

    struct _READ_POSITION {
        UCHAR Operation;
        UCHAR BlockType:1;
        UCHAR Reserved1:4;
        UCHAR Lun:3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } READ_POSITION, *PREAD_POSITION;

    //
    // ReadWrite for Tape
    //

    struct _CDB6READWRITETAPE {
        UCHAR OperationCode;
        UCHAR VendorSpecific : 5;
        UCHAR Reserved : 3;
        UCHAR TransferLenMSB;
        UCHAR TransferLen;
        UCHAR TransferLenLSB;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved1 : 4;
        UCHAR VendorUnique : 2;
     } CDB6READWRITETAPE, *PCDB6READWRITETAPE;

} CDB, *PCDB;

//
// Command Descriptor Block constants.
//

#define CDB6GENERIC_LENGTH                   6
#define CDB10GENERIC_LENGTH                  10

#define SETBITON                             1
#define SETBITOFF                            0
//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_ERROR_RECOVERY        0x01
#define MODE_PAGE_DISCONNECT            0x02
#define MODE_PAGE_FORMAT_DEVICE         0x03
#define MODE_PAGE_RIGID_GEOMETRY        0x04
#define MODE_PAGE_FLEXIBILE             0x05
#define MODE_PAGE_VERIFY_ERROR          0x07
#define MODE_PAGE_CACHING               0x08
#define MODE_PAGE_PERIPHERAL            0x09
#define MODE_PAGE_CONTROL               0x0A
#define MODE_PAGE_MEDIUM_TYPES          0x0B
#define MODE_PAGE_NOTCH_PARTITION       0x0C
#define MODE_SENSE_RETURN_ALL           0x3f
#define MODE_SENSE_CURRENT_VALUES       0x00
#define MODE_SENSE_CHANGEABLE_VALUES    0x40
#define MODE_SENSE_DEFAULT_VAULES       0x80
#define MODE_SENSE_SAVED_VALUES         0xc0
#define MODE_PAGE_DEVICE_CONFIG         0x10
#define MODE_PAGE_MEDIUM_PARTITION      0x11
#define MODE_PAGE_DATA_COMPRESS         0x0f

//
// SCSI CDB operation codes
//

#define SCSIOP_TEST_UNIT_READY     0x00
#define SCSIOP_REZERO_UNIT         0x01
#define SCSIOP_REWIND              0x01
#define SCSIOP_REQUEST_BLOCK_ADDR  0x02
#define SCSIOP_REQUEST_SENSE       0x03
#define SCSIOP_FORMAT_UNIT         0x04
#define SCSIOP_READ_BLOCK_LIMITS   0x05
#define SCSIOP_REASSIGN_BLOCKS     0x07
#define SCSIOP_READ6               0x08
#define SCSIOP_RECEIVE             0x08
#define SCSIOP_WRITE6              0x0A
#define SCSIOP_PRINT               0x0A
#define SCSIOP_SEND                0x0A
#define SCSIOP_SEEK6               0x0B
#define SCSIOP_TRACK_SELECT        0x0B
#define SCSIOP_SLEW_PRINT          0x0B
#define SCSIOP_SEEK_BLOCK          0x0C
#define SCSIOP_PARTITION           0x0D
#define SCSIOP_READ_REVERSE        0x0F
#define SCSIOP_WRITE_FILEMARKS     0x10
#define SCSIOP_FLUSH_BUFFER        0x10
#define SCSIOP_SPACE               0x11
#define SCSIOP_INQUIRY             0x12
#define SCSIOP_VERIFY6             0x13
#define SCSIOP_RECOVER_BUF_DATA    0x14
#define SCSIOP_MODE_SELECT         0x15
#define SCSIOP_RESERVE_UNIT        0x16
#define SCSIOP_RELEASE_UNIT        0x17
#define SCSIOP_COPY                0x18
#define SCSIOP_ERASE               0x19
#define SCSIOP_MODE_SENSE          0x1A
#define SCSIOP_START_STOP_UNIT     0x1B
#define SCSIOP_STOP_PRINT          0x1B
#define SCSIOP_LOAD_UNLOAD         0x1B
#define SCSIOP_RECEIVE_DIAGNOSTIC  0x1C
#define SCSIOP_SEND_DIAGNOSTIC     0x1D
#define SCSIOP_MEDIUM_REMOVAL      0x1E
#define SCSIOP_READ_CAPACITY       0x25
#define SCSIOP_READ                0x28
#define SCSIOP_WRITE               0x2A
#define SCSIOP_SEEK                0x2B
#define SCSIOP_LOCATE              0x2B
#define SCSIOP_WRITE_VERIFY        0x2E
#define SCSIOP_VERIFY              0x2F
#define SCSIOP_SEARCH_DATA_HIGH    0x30
#define SCSIOP_SEARCH_DATA_EQUAL   0x31
#define SCSIOP_SEARCH_DATA_LOW     0x32
#define SCSIOP_SET_LIMITS          0x33
#define SCSIOP_READ_POSITION       0x34
#define SCSIOP_SYNCHRONIZE_CACHE   0x35
#define SCSIOP_COMPARE             0x39
#define SCSIOP_COPY_COMPARE        0x3A
#define SCSIOP_WRITE_DATA_BUFF     0x3B
#define SCSIOP_READ_DATA_BUFF      0x3C
#define SCSIOP_CHANGE_DEFINITION   0x40
#define SCSIOP_READ_SUB_CHANNEL    0x42
#define SCSIOP_READ_TOC            0x43
#define SCSIOP_READ_HEADER         0x44
#define SCSIOP_PLAY_AUDIO          0x45
#define SCSIOP_PLAY_AUDIO_MSF      0x47
#define SCSIOP_PLAY_TRACK_INDEX    0x48
#define SCSIOP_PLAY_TRACK_RELATIVE 0x49
#define SCSIOP_PAUSE_RESUME        0x4B
#define SCSIOP_LOG_SELECT          0x4C
#define SCSIOP_LOG_SENSE           0x4D

//
// If the IMMED bit is 1, status is returned as soon
// as the operation is initiated. If the IMMED bit
// is 0, status is not returned until the operation
// is completed.
//

#define CDB_RETURN_ON_COMPLETION   0
#define CDB_RETURN_IMMEDIATE       1

//
// CDB Force media access used in extended read and write commands.
//

#define CDB_FORCE_MEDIA_ACCESS 0x08

//
// Denon CD ROM operation codes
//

#define SCSIOP_DENON_EJECT_DISC    0xE6
#define SCSIOP_DENON_STOP_AUDIO    0xE7
#define SCSIOP_DENON_PLAY_AUDIO    0xE8
#define SCSIOP_DENON_READ_TOC      0xE9
#define SCSIOP_DENON_READ_SUBCODE  0xEB

//
// SCSI Bus Messages
//

#define SCSIMESS_ABORT                0x06
#define SCSIMESS_ABORT_WITH_TAG       0x0D
#define SCSIMESS_BUS_DEVICE_RESET     0X0C
#define SCSIMESS_CLEAR_QUEUE          0X0E
#define SCSIMESS_COMMAND_COMPLETE     0X00
#define SCSIMESS_DISCONNECT           0X04
#define SCSIMESS_EXTENDED_MESSAGE     0X01
#define SCSIMESS_IDENTIFY             0X80
#define SCSIMESS_IDENTIFY_WITH_DISCON 0XC0
#define SCSIMESS_IGNORE_WIDE_RESIDUE  0X23
#define SCSIMESS_INITIATE_RECOVERY    0X0F
#define SCSIMESS_INIT_DETECTED_ERROR  0X05
#define SCSIMESS_LINK_CMD_COMP        0X0A
#define SCSIMESS_LINK_CMD_COMP_W_FLAG 0X0B
#define SCSIMESS_MESS_PARITY_ERROR    0X09
#define SCSIMESS_MESSAGE_REJECT       0X07
#define SCSIMESS_NO_OPERATION         0X08
#define SCSIMESS_HEAD_OF_QUEUE_TAG    0X21
#define SCSIMESS_ORDERED_QUEUE_TAG    0X22
#define SCSIMESS_SIMPLE_QUEUE_TAG     0X20
#define SCSIMESS_RELEASE_RECOVERY     0X10
#define SCSIMESS_RESTORE_POINTERS     0X03
#define SCSIMESS_SAVE_DATA_POINTER    0X02
#define SCSIMESS_TERMINATE_IO_PROCESS 0X11

//
// SCSI Extended Message operation codes
//

#define SCSIMESS_MODIFY_DATA_POINTER  0X00
#define SCSIMESS_SYNCHRONOUS_DATA_REQ 0X01
#define SCSIMESS_WIDE_DATA_REQUEST    0X03

//
// SCSI Extended Message Lengths
//

#define SCSIMESS_MODIFY_DATA_LENGTH   5
#define SCSIMESS_SYNCH_DATA_LENGTH    3
#define SCSIMESS_WIDE_DATA_LENGTH     2

//
// SCSI extended message structure
//

#pragma pack (1)
typedef struct _SCSI_EXTENDED_MESSAGE {
    UCHAR InitialMessageCode;
    UCHAR MessageLength;
    UCHAR MessageType;
    union _EXTENDED_ARGUMENTS {

        struct {
            UCHAR Modifier[4];
        } Modify;

        struct {
            UCHAR TransferPeriod;
            UCHAR ReqAckOffset;
        } Synchronous;

        struct{
            UCHAR Width;
        } Wide;
    }ExtendedArguments;
}SCSI_EXTENDED_MESSAGE, *PSCSI_EXTENDED_MESSAGE;
#pragma pack ()

//
// SCSI bus status codes.
//

#define SCSISTAT_GOOD                  0x00
#define SCSISTAT_CHECK_CONDITION       0x02
#define SCSISTAT_CONDITION_MET         0x04
#define SCSISTAT_BUSY                  0x08
#define SCSISTAT_INTERMEDIATE          0x10
#define SCSISTAT_INTERMEDIATE_COND_MET 0x14
#define SCSISTAT_RESERVATION_CONFLICT  0x18
#define SCSISTAT_COMMAND_TERMINATED    0x22
#define SCSISTAT_QUEUE_FULL            0x28

//
// Enable Vital Product Data Flag (EVPD)
// used with INQUIRY command.
//

#define CDB_INQUIRY_EVPD           0x01

//
// Defines for format CDB
//

#define LUN0_FORMAT_SAVING_DEFECT_LIST 0
#define USE_DEFAULTMSB  0
#define USE_DEFAULTLSB  0

#define START_UNIT_CODE 0x01
#define STOP_UNIT_CODE  0x00

//
// Inquiry buffer structure. This is the data returned from the target
// after it receives an inquiry.
//
// This structure may be extended by the number of bytes specified
// in the field AdditionalLength. The defined size constant only
// includes fields through ProductRevisionLevel.
//
// The NT SCSI drivers are only interested in the first 36 bytes of data.
//

#define INQUIRYDATABUFFERSIZE 36

typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    UCHAR Versions;
    UCHAR ResponseDataFormat;
    UCHAR AdditionalLength;
    UCHAR Reserved[2];
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR Reserved2 : 1;
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;
    UCHAR Wide16Bit : 1;
    UCHAR Wide32Bit : 1;
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network
#define LOGICAL_UNIT_NOT_PRESENT_DEVICE 0x7F

//
// DeviceTypeQualifier field
//

#define DEVICE_CONNECTED 0x00

//
// Sense Data Format
//

typedef struct _SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FieldReplaceableUnitCode;
    UCHAR SenseKeySpecific[3];
} SENSE_DATA, *PSENSE_DATA;

//
// Default request sense buffer size
//

#define SENSE_BUFFER_SIZE 18

//
// Sense codes
//

#define SCSI_SENSE_NO_SENSE         0x00
#define SCSI_SENSE_RECOVERED_ERROR  0x01
#define SCSI_SENSE_NOT_READY        0x02
#define SCSI_SENSE_MEDIUM_ERROR     0x03
#define SCSI_SENSE_HARDWARE_ERROR   0x04
#define SCSI_SENSE_ILLEGAL_REQUEST  0x05
#define SCSI_SENSE_UNIT_ATTENTION   0x06
#define SCSI_SENSE_DATA_PROTECT     0x07
#define SCSI_SENSE_BLANK_CHECK      0x08
#define SCSI_SENSE_UNIQUE           0x09
#define SCSI_SENSE_COPY_ABORTED     0x0A
#define SCSI_SENSE_ABORTED_COMMAND  0x0B
#define SCSI_SENSE_EQUAL            0x0C
#define SCSI_SENSE_VOL_OVERFLOW     0x0D
#define SCSI_SENSE_MISCOMPARE       0x0E
#define SCSI_SENSE_RESERVED         0x0F

//
// Additional tape bit
//

#define SCSI_ILLEGAL_LENGTH         0x20
#define SCSI_EOM                    0x40
#define SCSI_FILE_MARK              0x80

//
// Additional Sense codes
//

#define SCSI_ADSENSE_NO_SENSE       0x00
#define SCSI_ADSENSE_LUN_NOT_READY  0x04
#define SCSI_ADSENSE_ILLEGAL_COMMAND 0x20
#define SCSI_ADSENSE_ILLEGAL_BLOCK  0x21
#define SCSI_ADSENSE_INVALID_LUN    0x25
#define SCSI_ADSENSE_MUSIC_AREA     0xA0
#define SCSI_ADSENSE_DATA_AREA      0xA1
#define SCSI_ADSENSE_VOLUME_OVERFLOW 0xA7

#define SCSI_ADSENSE_NO_MEDIA_IN_DEVICE 0x3a
#define SCSI_ADWRITE_PROTECT        0x27
#define SCSI_ADSENSE_MEDIUM_CHANGED 0x28
#define SCSI_ADSENSE_BUS_RESET      0x29
#define SCSI_ADSENSE_TRACK_ERROR    0x14
#define SCSI_ADSENSE_SEEK_ERROR     0x15
#define SCSI_ADSENSE_REC_DATA_NOECC 0x17
#define SCSI_ADSENSE_REC_DATA_ECC   0x18

//
// Additional sense code qualifier
//

#define SCSI_SENSEQ_FORMAT_IN_PROGRESS 0x04
#define SCSI_SENSEQ_INIT_COMMAND_REQUIRED 0x02
#define SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED 0x03
#define SCSI_SENSEQ_BECOMING_READY 0x01
#define SCSI_SENSEQ_FILEMARK_DETECTED 0x01
#define SCSI_SENSEQ_SETMARK_DETECTED 0x03
#define SCSI_SENSEQ_END_OF_MEDIA_DETECTED 0x02
#define SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED 0x04

//
// SCSI IO Device Control Codes
//

#define FILE_DEVICE_SCSI 0x0000001b

#define IOCTL_SCSI_EXECUTE_IN   ((FILE_DEVICE_SCSI << 16) + 0x0011)
#define IOCTL_SCSI_EXECUTE_OUT  ((FILE_DEVICE_SCSI << 16) + 0x0012)
#define IOCTL_SCSI_EXECUTE_NONE ((FILE_DEVICE_SCSI << 16) + 0x0013)

//
// Read Capacity Data - returned in Big Endian format
//

typedef struct _READ_CAPACITY_DATA {
    ULONG LogicalBlockAddress;
    ULONG BytesPerBlock;
} READ_CAPACITY_DATA, *PREAD_CAPACITY_DATA;


//
// Read Block Limits Data - returned in Big Endian format
// This structure returns the maximum and minimum block
// size for a TAPE device.
//

typedef struct _READ_BLOCK_LIMITS {
    UCHAR Reserved;
    UCHAR BlockMaximumSize[3];
    UCHAR BlockMinimumSize[2];
} READ_BLOCK_LIMITS_DATA, *PREAD_BLOCK_LIMITS_DATA;

//
// Mode data structures.
//

//
// Define Mode parameter header.
//

typedef struct _MODE_PARAMETER_HEADER {
    UCHAR ModeDataLength;
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR BlockDescriptorLength;
}MODE_PARAMETER_HEADER, *PMODE_PARAMETER_HEADER;

#define MODE_FD_SINGLE_SIDE     0x01
#define MODE_FD_DOUBLE_SIDE     0x02
#define MODE_FD_MAXIMUM_TYPE    0x1E
#define MODE_DSP_FUA_SUPPORTED  0x10
#define MODE_DSP_WRITE_PROTECT  0x80

//
// Define the mode parameter block.
//

typedef struct _MODE_PARAMETER_BLOCK {
    UCHAR DensityCode;
    UCHAR NumberOfBlocks[3];
    UCHAR Reserved;
    UCHAR BlockLength[3];
}MODE_PARAMETER_BLOCK, *PMODE_PARAMETER_BLOCK;

//
// Define Disconnect-Reconnect page.
//

typedef struct _MODE_DISCONNECT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR BufferFullRatio;
    UCHAR BufferEmptyRatio;
    UCHAR BusInactivityLimit[2];
    UCHAR BusDisconnectTime[2];
    UCHAR BusConnectTime[2];
    UCHAR MaximumBurstSize[2];
    UCHAR DataTransferDisconnect : 2;
    UCHAR Reserved2[3];
}MODE_DISCONNECT_PAGE, *PMODE_DISCONNECT_PAGE;

//
// Define mode caching page.
//

typedef struct _MODE_CACHING_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR ReadDisableCache : 1;
    UCHAR MultiplicationFactor : 1;
    UCHAR WriteCacheEnable : 1;
    UCHAR Reserved2 : 5;
    UCHAR WriteRetensionPriority : 4;
    UCHAR ReadRetensionPriority : 4;
    UCHAR DisablePrefetchTransfer[2];
    UCHAR MinimumPrefectch[2];
    UCHAR MaximumPrefectch[2];
    UCHAR MaximumPrefectchCeil[2];
}MODE_CACHING_PAGE, *PMODE_CACHING_PAGE;

//
// Define mode flexible disk page.
//

typedef struct _MODE_FLEXIBLE_DISK_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TransferRate[2];
    UCHAR NumberOfHeads;
    UCHAR SectorsPerTrack;
    UCHAR BytesPerSector[2];
    UCHAR NumberOfCylinders[2];
    UCHAR StartWritePrecom[2];
    UCHAR StartReducedCurrent[2];
    UCHAR StepRate[2];
    UCHAR StepPluseWidth;
    UCHAR HeadSettleDelay[2];
    UCHAR MotorOnDelay;
    UCHAR MotorOffDelay;
    UCHAR Reserved2 : 5;
    UCHAR MotorOnAsserted : 1;
    UCHAR StartSectorNumber : 1;
    UCHAR TrueReadySignal : 1;
    UCHAR StepPlusePerCyclynder : 4;
    UCHAR Reserved3 : 4;
    UCHAR WriteCompenstation;
    UCHAR HeadLoadDelay;
    UCHAR HeadUnloadDelay;
    UCHAR Pin2Usage : 4;
    UCHAR Pin34Usage : 4;
    UCHAR Pin1Usage : 4;
    UCHAR Pin4Usage : 4;
    UCHAR MediumRotationRate[2];
    UCHAR Reserved4[2];
}MODE_FLEXIBLE_DISK_PAGE, *PMODE_FLEXIBLE_DISK_PAGE;

//
// Define mode format page.
//

typedef struct _MODE_FORMAT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TracksPerZone[2];
    UCHAR AlternetSectorsPerZone[2];
    UCHAR AlternetTracksPerZone[2];
    UCHAR SectorsPerTrack[2];
    UCHAR BytesPerPhysicalSector[2];
    UCHAR Interleave[2];
    UCHAR TrackSkewFactor[2];
    UCHAR CylinderSkewFactor[2];
    UCHAR Reserved2 : 4;
    UCHAR SurfaceFirst : 1;
    UCHAR RemovableMedia : 1;
    UCHAR HardSectorFormating : 1;
    UCHAR SoftSectorFormating : 1;
    UCHAR Reserved3[2];
}MODE_FORMAT_PAGE, *PMODE_FORMAT_PAGE;

//
// Define rigid disk driver geometry page.
//

typedef struct _MODE_RIGID_GEOMETRY_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR NumberOfCylinders[2];
    UCHAR NumberOfHeads;
    UCHAR StartWritePrecom[2];
    UCHAR StartReducedCurrent[2];
    UCHAR DriveStepRate[2];
    UCHAR LandZoneCyclinder[2];
    UCHAR RotationalPositionLock : 2;
    UCHAR Reserved2 : 6;
    UCHAR RotationOffset;
    UCHAR Reserved3;
    UCHAR RoataionRate[2];
    UCHAR Reserved4[2];
}MODE_RIGID_GEOMETRY_PAGE, *PMODE_RIGID_GEOMETRY_PAGE;

//
// Define read write recovery page
//

typedef struct _MODE_READ_WRITE_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR EERBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR TBBit : 1;
    UCHAR Reserved3 : 2;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];
    UCHAR WriteRetryCount;
    UCHAR Reserved5[3];

} MODE_READ_WRITE_RECOVERY_PAGE, *PMODE_READ_WRITE_RECOVERY_PAGE;

//
// Mode parameter list block descriptor -
// set the block length for reading/writing
//
//

#define MODE_BLOCK_DESC_LENGTH               8

typedef struct _MODE_PARM_READ_WRITE {

   MODE_PARAMETER_HEADER  ParameterListHeader;  // List Header Format
   MODE_PARAMETER_BLOCK   ParameterListBlock;   // List Block Descriptor

} MODE_PARM_READ_WRITE_DATA, *PMODE_PARM_READ_WRITE_DATA;

//
// CDROM audio control (0x0E)
//

#define CDB_AUDIO_PAUSE 0
#define CDB_AUDIO_RESUME 1

#define CDB_DEVICE_START 0x11
#define CDB_DEVICE_STOP 0x10

#define CDB_EJECT_MEDIA 0x10
#define CDB_LOAD_MEDIA 0x01

#define CDB_SUBCHANNEL_HEADER      0x00
#define CDB_SUBCHANNEL_BLOCK       0x01

#define CDROM_AUDIO_CONTROL_PAGE   0x0E
#define MODE_SELECT_IMMEDIATE      0x04
#define MODE_SELECT_PFBIT          0x10

#define CDB_USE_MSF                0x01

typedef struct _PORT_OUTPUT {
    UCHAR ChannelSelection;
    UCHAR Volume;
} PORT_OUTPUT, *PPORT_OUTPUT;

typedef struct _AUDIO_OUTPUT {
    UCHAR CodePage;
    UCHAR ParameterLength;
    UCHAR Immediate;
    UCHAR Reserved[2];
    UCHAR LbaFormat;
    UCHAR LogicalBlocksPerSecond[2];
    PORT_OUTPUT PortOutput[4];
} AUDIO_OUTPUT, *PAUDIO_OUTPUT;

//
// Multisession CDROM
//

#define GET_LAST_SESSION 0x01
#define GET_SESSION_DATA 0x02;

//
// Tape definitions
//

typedef struct _TAPE_POSITION_DATA {
    UCHAR Reserved1:2;
    UCHAR BlockPositionUnsupported:1;
    UCHAR Reserved2:3;
    UCHAR EndOfPartition:1;
    UCHAR BeginningOfPartition:1;
    UCHAR PartitionNumber;
    USHORT Reserved3;
    UCHAR FirstBlock[4];
    UCHAR LastBlock[4];
    UCHAR Reserved4;
    UCHAR NumberOfBlocks[3];
    UCHAR NumberOfBytes[4];
} TAPE_POSITION_DATA, *PTAPE_POSITION_DATA;

//
// Byte reversing macro for converting
// between big- and little-endian formats
//

#define REVERSE_BYTES(Destination, Source) {                \
    (Destination)->Byte3 = (Source)->Byte0;                 \
    (Destination)->Byte2 = (Source)->Byte1;                 \
    (Destination)->Byte1 = (Source)->Byte2;                 \
    (Destination)->Byte0 = (Source)->Byte3;                 \
}

//
// This structure is used to convert little endian
// ULONGs to SCSI CDB 4 byte big endians values.
//

typedef struct _FOUR_BYTE {
    UCHAR Byte0;
    UCHAR Byte1;
    UCHAR Byte2;
    UCHAR Byte3;
} FOUR_BYTE, *PFOUR_BYTE;

//
// This macro has the effect of Bit = log2(Data)
//

#define WHICH_BIT(Data, Bit) {                      \
    for (Bit = 0; Bit < 32; Bit++) {                \
        if ((Data >> Bit) == 1) {                   \
            break;                                  \
        }                                           \
    }                                               \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wcache\wcache.c ===
#include <nt.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <scsi.h>

typedef struct _MODE_SENSE_PASS_THROUGH {
    SCSI_PASS_THROUGH Srb;
    ULONG             Reserved;
    UCHAR             SenseData[32];
    UCHAR             DataBuffer[256];

} MODE_SENSE_PASS_THROUGH, *PMODE_SENSE_PASS_THROUGH;


VOID
Usage(
   VOID
   );


int __cdecl
main( int argc, char **argv )
{
    ULONG              portNumber = 0;
    ULONG              physicalDrive = 0,
                       selectedDrive = 0xFFFFFFFF;

    HANDLE             volumeHandle,driveHandle;
    UNICODE_STRING     unicodeString;
    OBJECT_ATTRIBUTES  objectAttributes;
    NTSTATUS           ntStatus;
    PSCSI_ADAPTER_BUS_INFO  adapterInfo;
    PSCSI_BUS_DATA     busData;
    PSCSI_INQUIRY_DATA inquiryData;
    PINQUIRYDATA       deviceInquiryData;
    ULONG bytesTransferred;
    ULONG i, j;
    PCHAR              pageData,pch;
    UCHAR              modeOperation,
                       cacheSettings;
    INT                args;
    BOOLEAN            disableCache = FALSE,
                       enableCache = FALSE;
    BOOLEAN            displayAll = TRUE;
    UCHAR              buffer[32];
    UCHAR              driveBuffer[20];
    CHAR               driver[9];
    MODE_SENSE_PASS_THROUGH modeSenseData;



    if ( argc > 3 ) {
        Usage();
        exit(1);
    } else if (argc > 1 ) {

        displayAll = FALSE;

        args = 1;

        while ( args < argc ) {

            pch = argv[args];

            if ( *pch == '-' ) {
                BOOL exitSwitch = FALSE;
                pch++;
                switch( *pch ) {
                case 'd':
                    disableCache = TRUE;
                    break;
                case 'e':
                    enableCache = TRUE;
                    break;

                case '?':
                    Usage();
                    exit(1);
                    break;
                default:
                    Usage();
                    exit(1);
                }
                pch++;
            } else {
                if (!isdigit(*pch)) {
                    Usage();
                    exit(1);
                }
                selectedDrive = atol(pch);

            }
            args++;
        }
    }

    printf("\nDrive Port Bus TID LUN Vendor                   ReadCache WriteCache\n");
    printf(  "--------------------------------------------------------------------");
    while (TRUE) {

        memset( buffer, 0, sizeof( buffer ) );
        sprintf( buffer,"\\\\.\\Scsi%d:",portNumber);

        //
        // Open the volume with the DOS name.
        //

        volumeHandle = CreateFile(buffer,
                                  GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  0);

        if( volumeHandle == INVALID_HANDLE_VALUE ) {
            break;
        }

        //
        // Allocate memory to store the inquiry data.
        //

        adapterInfo = (PSCSI_ADAPTER_BUS_INFO)malloc( 0x400 );

        if (adapterInfo == NULL) {
            printf( "Can't allocate memory for bus data\n" );
            CloseHandle( volumeHandle );
            return 1;
        }

        //
        // Issue device control to get configuration information.
        //

        if (!DeviceIoControl( volumeHandle,
                              IOCTL_SCSI_GET_INQUIRY_DATA,
                              NULL,
                              0,
                              adapterInfo,
                              0x400,
                              &bytesTransferred,
                              NULL)) {

            fprintf(stderr, "IOCTL_SCSI_GET_INQUIRY_DATA failed [Error %d].\n", GetLastError() );
            free(adapterInfo);
            CloseHandle( volumeHandle );
            return 2;
        }

        //
        // Display devices on buses.
        //

        for (i=0; i < adapterInfo->NumberOfBuses; i++) {

            busData = &adapterInfo->BusData[i];

            inquiryData = (PSCSI_INQUIRY_DATA)((PUCHAR)adapterInfo + busData->InquiryDataOffset);

            for (j=0; j<busData->NumberOfLogicalUnits; j++) {

                //
                // Make sure VendorId string is null terminated.
                //

                deviceInquiryData = (PINQUIRYDATA)&inquiryData->InquiryData[0];

                //
                // Determine the perpherial type.
                //

                if (deviceInquiryData->DeviceType == DIRECT_ACCESS_DEVICE) {

                    deviceInquiryData->ProductRevisionLevel[0] = '\0';
                    if (displayAll || (selectedDrive == physicalDrive)) {

                        printf("\n%2d    %2d   %2d  %2d  %2d ",
                                physicalDrive,
                                portNumber,
                                inquiryData->PathId,
                                inquiryData->TargetId,
                                inquiryData->Lun);

                        //
                        // Display product information.
                        //

                        printf(" %s", deviceInquiryData->VendorId);

                        //
                        // Open handle to the PhysicalDrive
                        //

                        sprintf(driveBuffer,"\\\\.\\PhysicalDrive%d",physicalDrive);

                        driveHandle = CreateFile(driveBuffer,
                                                 GENERIC_READ | GENERIC_WRITE,
                                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                 NULL,
                                                 OPEN_EXISTING,
                                                 0,
                                                 NULL);

                        if (driveHandle == INVALID_HANDLE_VALUE) {
                            printf("CreateFile for %s failed. Error = %x\n",
                                    driveBuffer,
                                    GetLastError() );
                            return 3;
                        }


                        //
                        // Issue mode sense to see if caches are enabled.
                        //

                        ZeroMemory(&modeSenseData, sizeof(MODE_SENSE_PASS_THROUGH));

                        modeSenseData.Srb.Length = sizeof(SCSI_PASS_THROUGH);
                        modeSenseData.Srb.CdbLength = 6;
                        modeSenseData.Srb.DataIn = SCSI_IOCTL_DATA_IN;
                        modeSenseData.Srb.DataBufferOffset = offsetof(MODE_SENSE_PASS_THROUGH, DataBuffer);
                        modeSenseData.Srb.SenseInfoOffset = offsetof(MODE_SENSE_PASS_THROUGH, SenseData);
                        modeSenseData.Srb.DataTransferLength = 0xFF;
                        modeSenseData.Srb.TimeOutValue = 10;

                        ZeroMemory(&modeSenseData.Srb.Cdb, 16);

                        modeSenseData.Srb.Cdb[0] = 0x1A;
                        modeSenseData.Srb.Cdb[2] = 8;
                        modeSenseData.Srb.Cdb[4] = 0xFF;

                        if (!DeviceIoControl(driveHandle,
                                             IOCTL_SCSI_PASS_THROUGH_DIRECT,
                                             &modeSenseData,
                                             sizeof(modeSenseData),
                                             &modeSenseData,
                                             sizeof(modeSenseData),
                                             &bytesTransferred,
                                             FALSE)) {

                            fprintf(stderr,"Mode sense failed. Error = %x\n",
                                    GetLastError() );
                            return 4;
                        }

                        //
                        // Display current values
                        //

                        pageData = modeSenseData.DataBuffer;
                        (ULONG_PTR)pageData += 6 + pageData[3];
                        cacheSettings = *pageData;


                        if (displayAll || (physicalDrive == selectedDrive)) {
                            printf(" %s  ", (cacheSettings & 1) ? "Disabled" : "Enabled");
                            printf(" %s", (cacheSettings & 4) ? "Enabled" : "Disabled");
                        }

                        if ((enableCache || disableCache) && (physicalDrive == selectedDrive)) {

                            //
                            // Build mode select - caching page.
                            //
                            // Clean out reserved areas of data buffer and update others
                            //

                            modeSenseData.Srb.SenseInfoLength = 32;
                            pageData = modeSenseData.DataBuffer;
                            modeSenseData.Srb.Cdb[4] = *pageData + 1;
                            modeSenseData.Srb.Cdb[2] = 0x00;
                            modeSenseData.Srb.Cdb[1] = 0x11;
                            *pageData = 0;
                            (ULONG_PTR)pageData += 4 + pageData[3];
                            *pageData &= 0x3F;
                            pageData++;
                            pageData++;
                            *pageData &= 0x07;

                            modeSenseData.DataBuffer[5] = 0x00;
                            modeSenseData.DataBuffer[6] = 0x00;
                            modeSenseData.DataBuffer[7] = 0x00;



                            modeSenseData.Srb.DataIn = SCSI_IOCTL_DATA_OUT;
                            modeSenseData.Srb.DataTransferLength = modeSenseData.Srb.Cdb[4];

                            if (disableCache) {

                                //
                                // Disable write cache
                                //

                                *pageData &= 0x03;
                            } else {

                                //
                                // Enable the cache.
                                //

                                *pageData |= 0x04;
                            }

                            modeSenseData.Srb.Cdb[0] = 0x15;

                            if (!DeviceIoControl(driveHandle,
                                                 IOCTL_SCSI_PASS_THROUGH_DIRECT,
                                                 &modeSenseData,
                                                 sizeof(modeSenseData),
                                                 &modeSenseData,
                                                 sizeof(modeSenseData),
                                                 &bytesTransferred,
                                                 FALSE)) {

                                fprintf(stderr,"Mode select failed. Error = %x\n",
                                        GetLastError() );
                            } else {

                                printf("\nWrite cache successfully %s\n", (enableCache ? "Enabled" : "Disabled"));
                            }
                        }

                        CloseHandle(driveHandle );
                    }


                    physicalDrive++;
                }

                //
                // Get next device data.
                //

                inquiryData =
                    (PSCSI_INQUIRY_DATA)((PUCHAR)adapterInfo + inquiryData->NextInquiryDataOffset);

            }
        }

        free (adapterInfo);
        CloseHandle(volumeHandle );

        portNumber++;
    }

    printf("\n");
    return 0;
}


VOID Usage(
    VOID
) {
    fprintf(stderr,"WCACHE: Usage  wcache [-options] <PhysicalDrive Number>\n");
    fprintf(stderr,"\n");
    fprintf(stderr,"  where options are:   e - Enable Write Cache for the <PhysicalDrive>\n");
    fprintf(stderr,"                       d - Disable Write Cache for the  <PhysicalDrive>\n");
    fprintf(stderr,"  dumps current values for all drives when invoked with no options\n");
    fprintf(stderr,"\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\where\where.c ===
/* find where the various command arguments are from
 *
 * HISTORY:
 *	25-Jan-2000	a-anurag in the 'found' function changed the printf format of the year in the date from
 *				%d to %02d and did ptm->tm_year%100 to display the right year in 2 digits.
 *  06-Aug-1990    davegi  Added check for no arguments
 *  03-Mar-1987    danl    Update usage
 *  17-Feb-1987 BW  Move strExeType to TOOLS.LIB
 *  18-Jul-1986 DL  Add /t
 *  18-Jun-1986 DL  handle *. properly
 *                  Search current directory if no env specified
 *  17-Jun-1986 DL  Do look4match on Recurse and wildcards
 *  16-Jun-1986 DL  Add wild cards to $FOO:BAR, added /q
 *   1-Jun-1986 DL  Add /r, fix Match to handle pat ending with '*'
 *  27-May-1986 MZ  Add *NIX searching.
 *  30-Jan-1998 ravisp Add /Q
 *
 */

#define INCL_DOSMISC


#include <sys/types.h>
#include <sys\stat.h>
#include <ctype.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <stdarg.h>


// Function Forward Declarations...
void     __cdecl Usage( char *, ... );
int      found( char * );
int      Match( char *, char * );
void     look4match( char *, struct findType *, void * );
flagType chkdir( char *, va_list );

char const rgstrUsage[] = {
    "Usage: WHERE [/r dir] [/qte] pattern ...\n"
    "    /r - recurse starting with directory dir\n"
    "    /q - quiet, use exit code\n"
    "    /t - times, display size and time\n"
    "    /e - .EXE, display .EXE type\n"
    "    /Q - double quote the output\n"
    "    WHERE bar                 Find ALL bar along path\n"
    "    WHERE $foo:bar            Find ALL bar along foo\n"
    "    WHERE /r \\ bar            Find ALL bar on current drive\n"
    "    WHERE /r . bar            Find ALL bar recursing on current directory\n"
    "    WHERE /r d:\\foo\\foo bar   Find ALL bar recursing on d:\\foo\\foo\n"
    "        Wildcards, * ?, allowed in bar in all of above.\n"
};


flagType fQuiet   = FALSE;  /* TRUE, use exit code, no print out */
flagType fQuote   = FALSE;  /* TRUE, double quote the output */
flagType fAnyFound = FALSE;
flagType fRecurse = FALSE;
flagType fTimes = FALSE;
flagType fExe = FALSE;
flagType fFound;
flagType fWildCards;
flagType fHasDot;
struct _stat sbuf;
char *pPattern;                 /* arg to look4match, contains * or ?   */
char strDirFileExtBuf[MAX_PATH]; /* fully qualified file name            */
char *strDirFileExt = strDirFileExtBuf;
char strBuf[MAX_PATH];        /* hold curdir or env var expansion     */

/*  Usage takes a variable number of strings, terminated by zero,
    e.g. Usage ("first ", "second ", 0);
*/
void
__cdecl
Usage(
     char *p,
     ...
     )
{
    if (p) {
        va_list args;
        char *rgstr;
        va_start(args, p);
        rgstr = p;
        fputs("WHERE: ", stdout);
        while (rgstr) {
            fputs (rgstr, stdout);
            rgstr = va_arg(args, char *);
        }
        fputs ("\n", stdout);
        va_end(args);
    }
    puts(rgstrUsage);

    exit (1);
}

int
found (
      char *p
      )
{
    struct _stat sbuf;
    struct tm *ptm;

    fAnyFound = fFound = TRUE;
    if (!fQuiet) {
        if (fTimes) {
            if ( ( _stat(p, &sbuf) == 0 ) &&
                 ( ptm = localtime (&sbuf.st_mtime) ) ) {
                printf ("% 9ld  %2d-%02d-%02d  %2d:%02d%c  ", sbuf.st_size,
                        ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year%100,
                        ( ptm->tm_hour > 12 ? ptm->tm_hour-12 : ptm->tm_hour ),
                        ptm->tm_min,
                        ( ptm->tm_hour >= 12 ? 'p' : 'a' ));
            } else {
                printf("        ?         ?       ?  " );
            }
        }
        if (fExe) {
            printf ("%-10s", strExeType(exeType(p)) );
        }
        if (fQuote) {
            printf ("\"%s\"\n",  p);
        } else {
            printf ("%s\n",  p );
        }
    }
    return( 0 );
}

int
Match (
      char *pat,
      char *text
      )
{
    switch (*pat) {
        case '\0':
            return *text == '\0';
        case '?':
            return *text != '\0' && Match (pat + 1, text + 1);
        case '*':
            do {
                if (Match (pat + 1, text))
                    return TRUE;
            } while (*text++);
            return FALSE;
        default:
            return toupper (*text) == toupper (*pat) && Match (pat + 1, text + 1);
    }
}


void
look4match (
           char *pFile,
           struct findType *b,
           void *dummy
           )
{
    char *p = b->fbuf.cFileName;

    if (!strcmp (p, ".") || !strcmp (p, "..") || !_strcmpi (p, "deleted"))
        return;

    /* if pattern has dot and filename does NOT ..., this handles case of
       where *. to look for files with no extensions */
    if (fHasDot && !*strbscan (p, ".")) {
        strcpy (strBuf, p);
        strcat (strBuf, ".");
        p = strBuf;
    }
    if (Match (pPattern, p))
        found (pFile);

    p = b->fbuf.cFileName;
    if (fRecurse && TESTFLAG (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        p = strend (pFile);
        strcat (p, "\\*.*");
        forfile (pFile, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, look4match, NULL);
        *p = '\0';
    }
}

flagType
chkdir (
       char *pDir,
       va_list pa
       )
/*
    pDir == dir name
    pa   == fileext
*/
{
    char *pFileExt = va_arg( pa, char* );

    if ( strDirFileExt == strDirFileExtBuf &&
         strlen(pDir) > sizeof(strDirFileExtBuf) ) {
        strDirFileExt = (char *)malloc(strlen(pDir)+1);
        if (!strDirFileExt) {
            strDirFileExt = strDirFileExtBuf;
            return FALSE;
        }
    }
    strcpy (strDirFileExt, pDir);
    /* if prefix does not have trailing path char */
    if (!fPathChr (strend(strDirFileExt)[-1]))
        strcat (strDirFileExt, PSEPSTR);
    if (fRecurse || fWildCards) {
        pPattern = pFileExt;    /* implicit arg to look4match */
        strcat (strDirFileExt, "*.*");
        forfile(strDirFileExt, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, look4match, NULL);
    } else {
        /* if file name has leading path char */
        if (fPathChr (*pFileExt))
            strcat (strDirFileExt, pFileExt+1);
        else
            strcat (strDirFileExt, pFileExt);
        if (_stat (strDirFileExt, &sbuf) != -1)
            found (strDirFileExt);
    }
    return FALSE;
}

int
__cdecl
main (
     int c,
     char *v[]
     )
{
    char *p, *p1, *p2;
    char *strDir;

    strDir = (char *)malloc(MAX_PATH);
    if (!strDir) {
        printf("Out of memory\n");
        exit(1);
    }

    ConvertAppToOem( c, v );
    SHIFT (c, v);

    while (c != 0 && fSwitChr (*(p = *v))) {
        while (*++p) {
            switch (*p) {
                case 'r':
                    fRecurse = TRUE;
                    SHIFT (c, v);
                    if (c) {
                        if ( rootpath (*v, strDir) ||
                             GetFileAttributes( strDir ) == -1 ) {
                            Usage ("Could not find directory ", *v, 0);
                        }
                    } else {
                        Usage ("No directory specified.", 0);
                    }
                    break;
                case 'q':
                    fQuiet = TRUE;
                    break;
                case 'Q':
                    fQuote = TRUE;
                    break;
                case 't':
                    fTimes = TRUE;
                    break;
                case 'e':
                    fExe = TRUE;
                    break;
                case '?':
                    Usage (0);
                    break;
                default:
                    Usage ("Bad switch: ", p, 0);
            }
        }
        SHIFT (c, v);
    }

    if (!c)
        Usage ("No pattern(s).", 0);

    while (c) {
        fFound = FALSE;
        p = _strlwr (*v);
        if (*p == '$') {
            if (fRecurse)
                Usage ("$FOO not allowed with /r", 0);
            if (*(p1=strbscan (*v, ":")) == '\0')
                Usage ("Missing \":\" in ", *v, 0);
            *p1 = 0;
            if ((p2 = getenvOem (_strupr (p+1))) == NULL) {
                rootpath (".", strDir);
                printf ("WHERE: Warning env variable \"%s\" is NULL, using current dir %s\n",
                        p+1, strDir);
            } else
                strcpy (strDir, p2);
            *p1++ = ':';
            p = p1;
        } else if (!fRecurse) {
            if ((p2 = getenvOem ("PATH")) == NULL)
                rootpath (".", strDir);
            else {

                //
                // if the path is longer than the allocated space for it, make more space
                // this is safe, it does not collide with the recurse case where strDir
                // is already set to something else
                //

                unsigned int length = strlen(p2) + 3;   // including .; and null
                if (length > MAX_PATH) {
                    strDir = (char *)realloc(strDir, length);
                }
                strcpy (strDir, ".;");
                strcat (strDir, p2);
            }
        }
        /* N.B. if fRecurse, then strDir was set in case 'r' above */

        if (!*p)
            Usage ("No pattern in ", *v, 0);

        /* strDir == cur dir or a FOO expansion */
        /* p    == filename, may have wild cards */
        /* does p contain wild cards */
        fWildCards = *strbscan (p, "*?");
        fHasDot    = *strbscan (p, ".");
        if (*(p2 = (strend (strDir) - 1)) == ';')
            /* prevents forsemi from doing enum with null str as last enum */
            *p2 = '\0';
        if (*strDir)
            forsemi (strDir, chkdir, p);

        if (!fFound && !fQuiet)
            printf ("Could not find %s\n", *v);
        SHIFT (c, v);
    }

    return( fAnyFound ? 0 : 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wcshdr\wcshdr.c ===
/* WCSHDR
 * generate UNICODE, ANSI & NEUTRAL typedefs and prototypes from a master file
 *
 * string% = string{W,A,}
 * LPTSTR% = {LPWSTR,LPSTR,LPTSTR}
 * TCHAR%  = {WCHAR,CHAR,TCHAR}
 * LPTCH%  = {LPWCH,LPCH,LPTCH}
 * If whitespace follows the symbol, a space is appended as required to
 * prevent shortening, and thus screwwing layout.
 *
 * History:
 *   04-Mar-1991 IanJa Wrote it.
 *   19-Mar-1991 IanJa Not all fgets() implementations append '\0' upon EOF.
 *   29-Mar-1991 IanJa Workaround NT fgets bug ("\r\n" not collapsed to "\n"),
 *                     & Command line, Usage and Version numbers added.
 *   13-May-1991 IanJa All neutrality achieved by #define - no neutral structs
 *   14-May-1991 IanJa Minor improvements to version display, help
 *   21-May-1991 IanJa Realloc() pbs->pStart when required
 *   27-May-1991 GregoryW bug fix, add LPTSTRID, LPTSTRNULL
 *   13-Jun-1991 IanJa Convert #define's too. Eg: #define Fn%(a) FnEx%(0, a)
 *   19-Jun-1991 IanJa improve #define treatment & simplify main loop
 *   12-Aug-1991 IanJa fix multi-line #defines, NEAR & FAR typedefs
 *   12-Aug-1991 IanJa fix braceless typedefs with %s; add LPTSTR2
 *   13-Aug-1991 IanJa add braceless typedefs #defines
 *   21-Aug-1991 IanJa fix string% substitutions for #defines
 *   21-Aug-1991 IanJa add BCHAR% -> BYTE or WCHAR as per BodinD request
 *   26-Aug-1991 IanJa init pbs->iType (NT-mode bug fix)
 *   26-Aug-1991 IanJa workaround NT fgets bug (CR LF not collapsed to NL)
 *   17-Nov-1992 v-griffk map #defines to typedef's on structs
 *               for debugger support
 *   08-Sep-1993 IanJa add pLastParen for complex function typedefs such as
 *               typedef BOOL ( CALLBACK * FOO% ) (BLAH% blah) ;
 *   24-Feb-1994 IanJa add CONV_FLUSH for blocks starting #if, #endif etc.
 *               #if (WINVER > 0x400)
 *               foo%(void);
 *               #endif
 *   11-Nov-1994 RaymondC propagate ;internal-ness to trailers
 */
char *Version = "WCSHDR v1.20 1994-11-11:";

#include <excpt.h>
#include <ntdef.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

#define INITIAL_STORE_SIZE 2048
#define EXTRA_STORE_SIZE   1024
#define FN_NAME_SIZE       100

#define CONV_NONE       0
#define CONV_FN_PROTO   1
#define CONV_TYPEDEF    2
#define CONV_DEFINE     3
#define CONV_FLUSH      4

#define ASSERT(pbs, exp) if (!(exp)) AssertFail(__FILE__, __LINE__, pbs, #exp);

typedef int BOOL;
typedef char *PSZ;

typedef struct {
    char   *pStart;     // 1st char in store
    char   *pLastLine;  // 1st char of last line in store
    int    line;        // number of lines read

    char   *pEnd;       /* '\0' at end of store */
    size_t cbSize;
    size_t cbFree;

    int    iType;       // FnPrototype, Typedef, #define or none
    int    nParen;      // nesting index: ( & { increment; ) & } decrement
    char   *p1stParen;  // Pointer to first '(' or '{' in current block.
    char   *pLastParen; // Pointer to last '(' or '{' in current block.
    char  *pSymNam;     // copy of function name, null-terminated
    int    cbSymNam;    // bytes available for fn name
    char  *pszInternal; // "" if external or "\t// ;internal" if internal
} BLOCKSTORE, *PBLOCKSTORE;

void ArgProcess(int argc, PSZ argv[]);
void Usage(void);
void InitBS(PBLOCKSTORE);
void SetInternalnessBS(PBLOCKSTORE);
BOOL ReadLineBS(PBLOCKSTORE);
void WriteBS(PBLOCKSTORE);
void WriteAllTypesBS(PBLOCKSTORE, int);
int  ConversionRequiredBS(PBLOCKSTORE);
void GetSymNameBS(PBLOCKSTORE, int);
BOOL WriteRedefinedTypeNamesBS(PBLOCKSTORE);
void WriteConvertBS(PBLOCKSTORE, int, BOOL);
void EmptyBS(PBLOCKSTORE);
DECLSPEC_NORETURN void error_exit(PBLOCKSTORE pbs, int exitval);
void PrintSubstitute(PBLOCKSTORE, PSZ, PSZ, int, BOOL);

void AssertFail(PSZ pszfnam, int lineno, PBLOCKSTORE pbs, PSZ pszExp);

#define NEUT 0
#define ANSI 1
#define UNIC 2

/*
 * Command line flags
 */
int fDebug = FALSE;

void
__cdecl main(
    int argc,
    PSZ argv[])
{
    /*
     * block store.
     * lines from input are saved in here until we know
     * enough about how to process them.
     */
    BLOCKSTORE bs;
    int BlockType;

    ArgProcess(argc, argv);

    /*
     * buffer is empty
     */
    InitBS(&bs);
    if (fDebug) {
        fprintf(stderr, "About to start main loop\n");
    }

    while (ReadLineBS(&bs)) {
        /*
         * if line is blank then we have a complete block not requiring
         * any conversion.
         */
        if (bs.pLastLine[strspn(bs.pLastLine, " \t\r")] == '\n') {
            WriteBS(&bs);
            EmptyBS(&bs);

            continue;
        }

        if ((BlockType = ConversionRequiredBS(&bs)) != 0) {
            WriteAllTypesBS(&bs, BlockType);
        }
    }

    /*
     * Flush last BlockStore
     */
    WriteBS(&bs);
}

void
WriteAllTypesBS(PBLOCKSTORE pbs, int BlockType)
{
    if (fDebug) {
        fprintf(stderr, "WriteAllTypes(%p, %d)\n", pbs, BlockType);
    }

    switch (BlockType) {
    case CONV_NONE:
        /*
         * No conversion required, keep accumulating block.
         */
        return;

    case CONV_DEFINE:
    case CONV_FN_PROTO:
        SetInternalnessBS(pbs);
        GetSymNameBS(pbs, BlockType);

        WriteConvertBS(pbs, ANSI, TRUE);
        WriteConvertBS(pbs, UNIC, TRUE);

        ASSERT(pbs, pbs->pszInternal);
        /*
         * UNICODE defn.
         */
        fprintf(stdout, "#ifdef UNICODE%s\n#define %s  %sW%s\n",
                pbs->pszInternal, pbs->pSymNam, pbs->pSymNam, pbs->pszInternal);

        /*
         * ANSI defn.
         */
        fprintf(stdout, "#else%s\n#define %s  %sA%s\n",
                pbs->pszInternal, pbs->pSymNam, pbs->pSymNam, pbs->pszInternal);
        fprintf(stdout, "#endif // !UNICODE%s\n", pbs->pszInternal);

        /*
         * Neutral defn.
         */
        break;

    case CONV_TYPEDEF:
        SetInternalnessBS(pbs);
        WriteConvertBS(pbs, ANSI, FALSE);
        WriteConvertBS(pbs, UNIC, FALSE);
        WriteRedefinedTypeNamesBS(pbs);
        break;

    case CONV_FLUSH:
        WriteBS(pbs);
        EmptyBS(pbs);
        break;

    default:
        fprintf(stderr, "Don't understand block");
        error_exit(pbs, 2);
    }

    EmptyBS(pbs);
}

BOOL
ReadLineBS(PBLOCKSTORE pbs)
{
    int cbLine;
    if (fDebug) {
        fprintf(stderr, "ReadLineBS(%p)\n", pbs);
    }

    /*
     * Not all implementations of fgets() put a '\0' in the buffer upon EOF.
     * This will cause ReadLineBS() to leave the BlockStore untouched when
     * it returns FALSE.
     * We must ensure that BlockStore contents are valid whenever this routine
     * is called.  InitBS() and EmptyBS() must set contents to '\0' !!
     */
    if (fgets(pbs->pEnd, pbs->cbFree, stdin) == NULL) {
        return FALSE;
    }
    cbLine = strlen(pbs->pEnd);
    if (fDebug) {
        fprintf(stderr, "read %d characters: \"%s\"\n", cbLine, pbs->pEnd);
    }
    pbs->pLastLine = pbs->pEnd;
    pbs->pEnd += cbLine;
    pbs->cbFree -= cbLine;
    pbs->line++;
    if (pbs->cbFree <= 1) {
        PSZ p;
        p = realloc(pbs->pStart, pbs->cbSize + EXTRA_STORE_SIZE);

        /*
         * Fatal Errror if allocation failed
         */
        ASSERT(pbs, p != NULL);
        if (p == NULL) {
            fprintf(stderr, "Reallocate BlockStore to %d bytes failed",
                    pbs->cbSize + EXTRA_STORE_SIZE);
            error_exit(pbs, 2);
        }

        /*
         * adjust the pointers and counts
         */
        pbs->pLastLine = p + (pbs->pLastLine - pbs->pStart);
        pbs->pEnd      = p + (pbs->pEnd      - pbs->pStart);
        pbs->cbSize   += EXTRA_STORE_SIZE;
        pbs->cbFree   += EXTRA_STORE_SIZE;

        pbs->pStart = p;
    }
    return TRUE;
}

void
WriteBS(PBLOCKSTORE pbs)
{
    if (fDebug) {
        fprintf(stderr, "WriteBS(%p)\n", pbs);
    }
    fputs(pbs->pStart, stdout);
}

/*
 * Each time a new line is read in, this function is called to determine
 * whether a complete block has been accumulated for conversion and output.
 */
int
ConversionRequiredBS(PBLOCKSTORE pbs)
{
    PSZ p;

    if (fDebug) {
        fprintf(stderr, "ConversionRequiredBS(%p)\n", pbs);
    }

    if (pbs->iType == CONV_NONE) {
        if (strncmp(pbs->pStart, "#define", 7) == 0) {
            /*
             * The block starts with #define
             */
            pbs->iType = CONV_DEFINE;
        } else if (pbs->pStart[0] == '#') {
            /*
             * The block starts with #if, #else, #endif etc.
             */
            return CONV_FLUSH;
        }
    }

    if (pbs->iType != CONV_DEFINE) {
        /*
         * Scan this line for parentheses and braces to identify
         * a complete Function Prototype or Structure definition.
         * NOTE: comments containing unbalanced parentheses or braces
         *       will mess this up!
         */
        for (p = pbs->pLastLine; p <= pbs->pEnd; p++) {
            if ((*p == '(') || (*p == '{')) {
                pbs->pLastParen = p;
                if (pbs->p1stParen == NULL) {
                    pbs->p1stParen = p;
                }
                pbs->nParen++;
            } else if ((*p == ')') || (*p == '}')) {
                pbs->nParen--;
            }

            if ((*p == ';') && (pbs->nParen == 0)) {
                /*
                 * We have a function prototype or a typedef
                 * (Balanced brackets and a semi-colon)
                 */
                if (pbs->p1stParen && *(pbs->p1stParen) == '(') {
                    pbs->iType = CONV_FN_PROTO;
                } else {
                    pbs->iType = CONV_TYPEDEF;
                }
                goto CheckPercents;
            }
        }
        /*
         * Not a #define, nor a complete Typedef or Function prototype.
         */
        if (fDebug) {
            fprintf(stderr, "  CONV_NONE (incomplete fn.proto/typedef)\n");
        }
        return CONV_NONE;

    } else if (pbs->iType == CONV_DEFINE) {
        /*
         * We know the block is a #define - we must detect the end
         * (it can extend for more than one line using backslashes)
         */
        if ((p = strrchr(pbs->pStart, '\\')) != NULL) {
            /*
             * There is a backslash on the line: if is it the last
             * non-whitespace character on the line, then this #define
             * is continuing on to the next line.
             */
            p++;
            p += strspn(p, " \t\r\n");
            if (*p == '\0') {
                /*
                 * No conversion required *yet*. Continue accumulating
                 * the multi-line #define statement.
                 */
                if (fDebug) {
                    fprintf(stderr, "  CONV_NONE (incomplete #define)\n");
                }
                return CONV_NONE;  // ...yet
            }
        }
    }

CheckPercents:
    /*
     * We have a complete block of known type pbs->iType.  We will need
     * to convert this block if it contains any %'s, so search for '%'
     */
    p = pbs->pStart;
    while ((p = strchr(p, '%')) != NULL) {
        if (!isalnum(p[1])) {
            if (fDebug) {
                fprintf(stderr, "  return %d (%% found)\n", pbs->iType);
            }
            return pbs->iType;
        }

        /*
         * We found a %, but it followed by an alphanumeric character,
         * so can't require wcshdr.exe substitution.  Look for more '%'s
         */
        p++;
    }

    if (fDebug) {
        fprintf(stderr, "  CONV_FLUSH (no %%'s)\n");
    }
    return CONV_FLUSH;
}

BOOL
GetDefinedNameBS(PBLOCKSTORE pbs) {
    PSZ pPercent = pbs->p1stParen - 1;
    PSZ pStartNam;

    if (fDebug) {
        fprintf(stderr, "GetDefinedNameBS(%p)\n", pbs);
    }
    /*
     * Scan forwards for name (starting from beyond the "#define")
     */
    pStartNam = pbs->pStart + 7;
    while (isspace(*pStartNam)) {
        pStartNam++;
    }

    /*
     * Scan forwards for '%', starting at beginning of literal name
     */
    for (pPercent = pStartNam; *pPercent; pPercent++) {
        if (*pPercent == '%') {
            /*
             * Make sure we have enough space to store the literal name
             */
            if ((pPercent - pStartNam) > pbs->cbSymNam) {
                fprintf(stderr, "REALLOCATE DEFINED NAME BUFFER!");
                error_exit(pbs, 2);
            }
            /*
             * store the literal name
             */
            *pPercent = '\0';
            strcpy(pbs->pSymNam, pStartNam);
            *pPercent = '%';
            return TRUE;
        }
    }

    /*
     * didn't find percent!
     */
    fprintf(stderr, "DEFINED NAME ???");
    error_exit(pbs, 2);
}

BOOL
GetFnNameBS(PBLOCKSTORE pbs)
{
    PSZ pPercent = pbs->pLastParen - 1;
    PSZ pStartNam;

    if (fDebug) {
        fprintf(stderr, "GetFnNameBS(%p)\n", pbs);
    }
    /*
     * Scan backwards for '%'
     */
    while (*pPercent != '%') {
        if (--pPercent <= pbs->pStart) {
            fprintf(stderr, "FUNCTION NAME ???");
            error_exit(pbs, 2);
        }
    }

    /*
     * Scan back for start of function name
     */
    for (pStartNam = pPercent - 1; pStartNam >= pbs->pStart; pStartNam--) {
        if (!isalnum(*pStartNam) && *pStartNam != '_')
            break;
    }
    pStartNam++;

    /*
     * Make sure we have enough space to store the function name
     */
    if ((pPercent - pStartNam) > pbs->cbSymNam) {
        fprintf(stderr, "REALLOCATE FN NAME BUFFER!");
        error_exit(pbs, 2);
    }

    /*
     * store the function name
     */
    *pPercent = '\0';
    strcpy(pbs->pSymNam, pStartNam);
    *pPercent = '%';
    return TRUE;
}

void
GetSymNameBS(PBLOCKSTORE pbs, int iType)
{
   if (iType == CONV_DEFINE) {
       GetDefinedNameBS(pbs);
   } else {
       GetFnNameBS(pbs);
   }
}

BOOL
WriteRedefinedTypeNamesBS(PBLOCKSTORE pbs)
{
    PSZ pFirstName = NULL;
    PSZ pToken;
    PSZ pPercent;
    BOOL fSkipFirst;

    if (fDebug) {
        fprintf(stderr, "WriteRedefinedTypeNamesBS(%p)\n", pbs);
    }

    ASSERT(pbs, pbs->pszInternal);

    if (pbs->p1stParen && (*(pbs->p1stParen) == '{')) {
        /*
         * Scan backwards for the closing brace
         */
        for (pToken = pbs->pEnd; *pToken != '}'; pToken--) {
            if (pToken <= pbs->pStart) {
                /*
                 * No closing brace found!?
                 */
                fprintf(stderr, "CLOSING BRACE ???");
                error_exit(pbs, 2);
            }
        }
        pToken++;
        fSkipFirst = FALSE;
    } else {
        /*
         * skip past "typedef"
         */
        pToken = pbs->pStart + 7;

        /*
         * Skip the first name
         */
        fSkipFirst = TRUE;
    }

    /*
     * UNICODE pass
     */
    fprintf(stdout, "#ifdef UNICODE%s\n", pbs->pszInternal);
    while (pToken = strtok(pToken, ",; \t*\n\r")) {
        if (fDebug) {
            fprintf(stderr, "token: \"%s\"\n", pToken);
        }
        /*
         * Write out the #define for UNICODE, excluding "NEAR" & "FAR"
         */
        if (   (_stricmp(pToken, "NEAR") == 0)
            || (_stricmp(pToken, "FAR")  == 0)) {
            goto NextUnicodeToken;
        }

        if (fSkipFirst) {
            fSkipFirst = FALSE;
            goto NextUnicodeToken;
        } else if (pFirstName == NULL) {
            pFirstName = pToken;
        }

        pPercent = pToken + strlen(pToken) - 1;
        if (*pPercent == '%') {
            fprintf(stdout, "typedef ");
            PrintSubstitute(pbs, pToken, pPercent, UNIC, FALSE);
            fputs(" ", stdout);
            PrintSubstitute(pbs, pToken, pPercent, NEUT, FALSE);
            fprintf(stdout, ";%s\n", pbs->pszInternal);
        }

NextUnicodeToken:
        pToken = NULL;
    }

    if (pFirstName == NULL) {
        fprintf(stderr, "TYPE NAME ???");
        error_exit(pbs, 2);
    }

    fprintf(stdout, "#else%s\n", pbs->pszInternal);
    if (fDebug) {
        fprintf(stderr, "FirstName = %s\n", pFirstName);
    }

    /*
     * ANSI pass
     */
    pToken = pFirstName;
    while ((pToken += strspn(pToken, "%,; \t*\n\r")) < pbs->pEnd) {
        /*
         * Write out the #define for ANSI, excluding "NEAR" and "FAR"
         */
        if (   (_stricmp(pToken, "NEAR") == 0)
            || (_stricmp(pToken, "FAR")  == 0)) {
            goto NextAnsiToken;
        }

        pPercent = pToken + strlen(pToken) - 1;
        if (*pPercent == '%') {
            fprintf(stdout, "typedef ");
            PrintSubstitute(pbs, pToken, pPercent, ANSI, FALSE);
            fputs(" ", stdout);
            PrintSubstitute(pbs, pToken, pPercent, NEUT, FALSE);
            fprintf(stdout, ";%s\n", pbs->pszInternal);
        }

NextAnsiToken:
        while (*pToken++) {
            ;
        }
    }

    fprintf(stdout, "#endif // UNICODE%s\n", pbs->pszInternal);

    return TRUE;
}

void
WriteConvertBS(PBLOCKSTORE pbs, int Type, int fVertAlign)
{
    PSZ p = pbs->pStart;
    PSZ pPercent;

    if (fDebug) {
        fprintf(stderr, "WriteConvertBS(%p, %d, %d)\n", pbs, Type, fVertAlign);
    }
    while ((pPercent = strchr(p, '%')) != NULL) {
        if (isalnum(pPercent[1])) {
            goto ContinueSearch;
        }

        /*
         * print the substitution
         */
        PrintSubstitute(pbs, p, pPercent, Type, fVertAlign);

        /*
         * Advance beyond the %
         */
ContinueSearch:
        p = pPercent+1;
    }

    /*
     * Print remainder of store
     */
    fputs(p, stdout);
}

void
EmptyBS(PBLOCKSTORE pbs)
{
    if (fDebug) {
        fprintf(stderr, "EmptyBS(%p)\n", pbs);
    }
    pbs->pEnd = pbs->pStart;
    pbs->pLastLine = pbs->pStart;
    pbs->cbFree = pbs->cbSize;
    if (pbs->pStart) {
        *(pbs->pStart) = '\0';
    }

    pbs->iType = CONV_NONE;
    pbs->p1stParen = NULL;
    pbs->pLastParen = NULL;
    pbs->nParen = 0;
    if (pbs->pSymNam) {
        *(pbs->pSymNam) = '\0';
    }
}

void
InitBS(PBLOCKSTORE pbs) {
    pbs->line = 0;
    pbs->pStart = malloc(INITIAL_STORE_SIZE);
    ASSERT(pbs, pbs->pStart != NULL);

    pbs->pLastLine = pbs->pStart;
    pbs->pEnd = pbs->pStart;
    *(pbs->pStart) = '\0';

    pbs->iType = CONV_NONE;
    pbs->p1stParen = NULL;
    pbs->pLastParen = NULL;
    pbs->nParen = 0;
    pbs->pszInternal = 0;

    pbs->cbSize = INITIAL_STORE_SIZE;
    pbs->cbFree = INITIAL_STORE_SIZE;

    pbs->pSymNam = malloc(FN_NAME_SIZE);
    ASSERT(pbs, pbs->pSymNam != NULL);
    pbs->cbSymNam = FN_NAME_SIZE;
    *(pbs->pSymNam) = '\0';
}

void
SetInternalnessBS(PBLOCKSTORE pbs) {
    if (strstr(pbs->pStart, ";internal")) {
        pbs->pszInternal = "\t// ;internal";
    } else {
        pbs->pszInternal = "";
    }
}

void
AssertFail(
    PSZ pszfnam,
    int lineno,
    PBLOCKSTORE pbs,
    PSZ pszExp)
{
    fprintf(stderr, "ASSERT failed: file %s, line %d:\n", pszfnam, lineno);
    fprintf(stderr, "input line %d: \"%s\"\n", pbs->line, pszExp);
}

void
ArgProcess(
    int argc,
    PSZ argv[])
{
    int ArgIndex;
    PSZ pszArg;

    for (ArgIndex = 1; ArgIndex < argc; ArgIndex++) {

        pszArg = argv[ArgIndex];
        if ((*pszArg == '-') || (*pszArg == '/')) {
            switch (pszArg[1]) {
            case '?':
                fprintf(stderr, "%s\n", Version);
                Usage();
                exit(0);

            case 'd':
            case 'D':
                fDebug = TRUE;
                break;

            default:
                fprintf(stderr, "%s Invalid switch: %s\n", Version, pszArg);
                Usage();
                exit(1);
            }
        }
    }
}

void Usage(void)
{
    fprintf(stderr, "usage: WCSHDR [-?] display this message\n");
    fprintf(stderr, "              [-d] debug (to stderr)\n");
    fprintf(stderr, "              reads stdin, writes to stdout\n");
}

void
DECLSPEC_NORETURN
error_exit(PBLOCKSTORE pbs, int exitval) {
    fprintf(stderr, " (line %d)\n", pbs->line);
    exit(exitval);
}

/*
 * Substitutions performed on strings ending '%'
 *
 */

typedef struct {
    int  cchTemplate;
    PSZ pszTemplate;
    PSZ apszSub[3];
} SUBSTR, *PSUBSTR;

/*
 * Strings that are replaced:
 *   BCHAR%
 *   TCHAR%
 *   LPTCH%
 *   LPTSTR%
 *   LPTSTR2%
 *   LPTSTRID%
 *   LPTSTRNULL%
 *   %
 *
 * "%" MUST comes last (before the null terminator)
 *
 * The other strings must be ordered from sensibly:
 *    if FRED% came before BIGFRED% in Substrs[], then the Substitute()
 *    procedure would match input BIGFRED% to FRED%, not BIGFRED%.  The
 *    simplest way to avoid this is to arrange strings in descending lengths.
 */
SUBSTR Substrs[] = {
    { 10, "LPTSTRNULL%",  "LPTSTRNULL", "LPSTRNULL", "LPWSTRNULL" },
    {  8, "LPTSTRID%",    "LPTSTRID",   "LPSTRID",   "LPWSTRID"   },
    {  7, "LPTSTR2%",     "LPTSTR2",    "LPSTR2",    "LPWSTR2"    },
    {  7, "LPCTSTR%",     "LPCTSTR",    "LPCSTR",    "LPCWSTR"    },
    {  6, "LPTSTR%",      "LPTSTR",     "LPSTR",     "LPWSTR"     },
    {  5, "TCHAR%",       "TCHAR",      "CHAR",      "WCHAR"      },
    {  5, "BCHAR%",       "BCHAR",      "BYTE",      "WCHAR"      },
    {  5, "LPTCH%",       "LPTCH",      "LPCH",      "LPWCH"      },
    {  0, "%",            "",           "A",         "W"          },
    {  0, NULL,           NULL,          NULL,       NULL         }
};

PSZ special_pad[] = {
    " ",              // Neutral
    "  ",             // ANSI
    " "               // UNICODE
};

PSZ normal_pad[] = {
    " ",              // Neutral
    "",               // ANSI
    ""                // UNICODE
};

void PrintSubstitute(
    PBLOCKSTORE pbs,         // just for error reporting
    PSZ pStart,              // where to start substitution
    PSZ pPercent,            // ptr to '%' at end of input string
    int Type,                // NEUT, ANSI or UNIC
    BOOL fVertAlign)         // attempt  to maintain vertical alignment?
{
    PSUBSTR pSub;
    char  chTmp;
    PSZ pChangedPart = NULL;

    if (fDebug) {
        fprintf(stderr, "PrintSubstitute(%p, %p, %p, %d, %d)\n",
                pbs, pStart, pPercent, Type, fVertAlign);
    }

    for (pSub = Substrs; pSub->pszTemplate; pSub++) {
        int cch = pSub->cchTemplate;
        if ((pPercent - cch) < pStart) {
            continue;
        }
        if (strncmp(pPercent - cch, pSub->pszTemplate, cch+1) == 0) {
            pChangedPart = pPercent-cch;

            /*
             * print out unaltered bit
             */
            chTmp = *pChangedPart;
            *pChangedPart = '\0';
            fputs(pStart, stdout);
            *pChangedPart = chTmp;

            /*
             * print out replacement bit
             */
            fputs(pSub->apszSub[Type], stdout);
            break;
        }
    }
    if (pChangedPart == NULL) {
        /*
         * NO match was found in Substrs[] !!!
         */
        fprintf(stderr, "Can't substitute");
        error_exit(pbs, 2);
    }

    /*
     * preserve alignment if required.
     * (not for function prototypes, and only if whitespace follows
     */
    if (!fVertAlign &&
        ((pPercent[1] == ' ') || (pPercent[1] == '\t'))) {
        if (pChangedPart != pPercent) {
            fputs(special_pad[Type], stdout);
        } else {
            fputs(normal_pad[Type], stdout);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\who\who.cpp ===
/****************************** Module Header ******************************\
* Module Name: who.c
*
* Copyright (c) 1998, Microsoft Corporation
*
* Command line exchange lookup of phone and office numbers.
*
* History:
* 26-Mar-1998 vadimg    created
\***************************************************************************/

#include <stdio.h>
#include <locale.h>
#include <mapix.h>
#include <mapi.h>
#include <mapiwin.h>
#include <mapiutil.h>
#include <mapidefs.h>

#include <initguid.h>
#include <mapiguid.h>

#define DISPLAY_NAME                0
#define ACCOUNT                     1
#define BUSINESS_TELEPHONE_NUMBER   2
#define OFFICE_LOCATION             3

DWORD gdwCodePage;

void FreeRowSet(LPSRowSet psrs)
{
    ULONG i;
    for (i = 0; i < psrs->cRows; i++) {
        LPSPropValue pspv = psrs->aRow[i].lpProps;

        if (pspv != NULL) {
            MAPIFreeBuffer((LPVOID)pspv);
        }
    }
    MAPIFreeBuffer((LPVOID)psrs);
}

void PrintName(ULONG cProps, LPSPropValue rgspv)
{
    if (rgspv[DISPLAY_NAME].Value.err != MAPI_E_NOT_FOUND) {
        WCHAR buffW[30];
        int len;
        len = MultiByteToWideChar(CP_ACP,
                            0,
                            rgspv[DISPLAY_NAME].Value.lpszA,
                            -1,
                            buffW,
                            30);
        WideCharToMultiByte(gdwCodePage,
                            0,
                            buffW,
                            len,
                            rgspv[DISPLAY_NAME].Value.lpszA,
                            30, NULL, NULL);
        printf("%-25.23s", rgspv[DISPLAY_NAME].Value.lpszA);
    }
    if (rgspv[ACCOUNT].Value.err != MAPI_E_NOT_FOUND) {
        printf("%-17.15s", rgspv[ACCOUNT].Value.lpszA);
    }
    if (rgspv[BUSINESS_TELEPHONE_NUMBER].Value.err != MAPI_E_NOT_FOUND) {
        printf("%-22.21s", rgspv[BUSINESS_TELEPHONE_NUMBER].Value.lpszA);
    }
    if (rgspv[OFFICE_LOCATION].Value.err != MAPI_E_NOT_FOUND) {
        printf("%-15.15s", rgspv[OFFICE_LOCATION].Value.lpszA);
    }
    printf("\n");
}

BOOL PrintNames(LPSTR psz, LPSRowSet psrs)
{
    ULONG i;

    if (psrs->cRows == 0)
        return FALSE;

    for (i = 0; i < psrs->cRows; i++) {
        PrintName(psrs->aRow[i].cValues, psrs->aRow[i].lpProps);
    }
    return TRUE;
}

BOOL FindNames(LPMAPITABLE pmtb, char *psz)
{
    SRestriction sres;
    SPropValue spv;
    SizedSPropTagArray(4, rgspt) = {4, {PR_DISPLAY_NAME, PR_ACCOUNT,
            PR_BUSINESS_TELEPHONE_NUMBER, PR_OFFICE_LOCATION}};

    if (FAILED(pmtb->SetColumns((LPSPropTagArray)&rgspt, 0)))
        return FALSE;

    spv.ulPropTag = PR_ANR;
    spv.Value.lpszA = psz;

    sres.rt = RES_PROPERTY;
    sres.res.resProperty.relop = RELOP_EQ;
    sres.res.resProperty.ulPropTag = spv.ulPropTag;
    sres.res.resProperty.lpProp = &spv;

    if (FAILED(pmtb->Restrict(&sres, 0)))
        return FALSE;

    return TRUE;
}

BOOL GetGlobalAdressListTable(LPADRBOOK padb, LPMAPITABLE *ppmtb)
{
    ULONG ulType;
    IABContainer *pabc = NULL;
    LPMAPITABLE pmtb = NULL;
    LPSRowSet psrs = NULL;
    SRestriction sres;
    SPropValue spv;
    SizedSPropTagArray(1, rgspt) = {1, {PR_ENTRYID}};
    BOOL fRet = FALSE;

    if (FAILED(padb->OpenEntry(0, NULL, NULL, MAPI_BEST_ACCESS |
            MAPI_DEFERRED_ERRORS, &ulType, (LPUNKNOWN*)&pabc)))
        goto Cleanup;

    if (FAILED(pabc->GetHierarchyTable(MAPI_DEFERRED_ERRORS, &pmtb)))
        goto Cleanup;

    pabc->Release();
    pabc = NULL;

    spv.ulPropTag = PR_DISPLAY_NAME;
    spv.Value.lpszA = "Global Address List";

    sres.rt = RES_PROPERTY;
    sres.res.resProperty.relop = RELOP_EQ;
    sres.res.resProperty.ulPropTag = spv.ulPropTag;
    sres.res.resProperty.lpProp = &spv;

    if (FAILED(pmtb->FindRow(&sres, BOOKMARK_BEGINNING, 0)))
        goto Cleanup;

    if (FAILED(pmtb->SetColumns((LPSPropTagArray)&rgspt, 0)))
        goto Cleanup;

    if (FAILED(pmtb->QueryRows(1, 0, &psrs)))
        goto Cleanup;

    if (FAILED(padb->OpenEntry(psrs->aRow[0].lpProps[0].Value.bin.cb,
            (LPENTRYID)psrs->aRow[0].lpProps[0].Value.bin.lpb,
            NULL, MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, 
            &ulType, (LPUNKNOWN*)&pabc)))
        goto Cleanup;

    if (FAILED(pabc->GetContentsTable(MAPI_DEFERRED_ERRORS, ppmtb)))
        goto Cleanup;

    fRet = TRUE;

Cleanup:
    if (pmtb != NULL) {
        pmtb->Release();
    }
    if (pabc != NULL) {
        pabc->Release();
    }
    if (psrs != NULL) {
        FreeRowSet(psrs);
    }

    return fRet;
}

void PrintUsage(void)
{
    printf("Sample Usage:\n");
    printf("    who jane\n");
    printf("    who janed\n");
    printf("    who \"jane d\"\n");
}

int __cdecl main(int argc, char **argv)
{
    IMAPISession *pmss = NULL;
    LPADRBOOK padb = NULL;
    LPMAPITABLE pmtb;
    LPSRowSet psrs = NULL;
    ULONG cRows;
    BOOL fContinue;
    LPSTR psz = argv[1];
    char lBuf[6];

    if (argc == 1 || (argc == 2 && argv[1][0] == '-')) {
        PrintUsage();
        return 0;
    }

    gdwCodePage = GetConsoleOutputCP();
#if 0
    SetThreadLocale(MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
                         SORT_DEFAULT));
    sprintf(lBuf, ".%.6d", gdwCodePage);
    setlocale(LC_ALL, lBuf);
#endif

    if (FAILED(MAPIInitialize(NULL)))
        return 0;

    if (FAILED(MAPILogonEx(0, NULL, NULL, MAPI_ALLOW_OTHERS |
            MAPI_USE_DEFAULT, &pmss)))
        goto Cleanup;

    if (FAILED(pmss->OpenAddressBook(NULL, NULL, AB_NO_DIALOG, &padb)))
        goto Cleanup;

    if (!GetGlobalAdressListTable(padb, &pmtb))
        goto Cleanup;

    if (!FindNames(pmtb, psz))
        goto Cleanup;

    if (FAILED(pmtb->GetRowCount(0, &cRows)))
        goto Cleanup;

    do {

        if (FAILED(pmtb->QueryRows(cRows, 0, &psrs)))
            goto Cleanup;

        if (psrs == NULL)
            break;

        fContinue = PrintNames(psz, psrs);

        FreeRowSet(psrs);

    } while (fContinue);

Cleanup:
    if (padb != NULL) {
        padb->Release();
    }

    if (pmss != NULL) {
        pmss->Release();
    }

    MAPIUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\client\sendquit.c ===
/*
 * basic client for sumserve remote checksum server
 *
 *
 * sends the program exit command to the server named on the cmd line
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <sumserve.h>
#include "ssclient.h"

extern int __argc;
extern char ** __argv;

/* program entry point
 *
 */
int PASCAL
WinMain (HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpszCmdParam,
 		int nCmdShow)
{
	HANDLE hpipe;

	/* we expect one arg: the server name */

	if (__argc != 2) {

		printf("usage: sendquit <servername>");
		return(1);
	}

	hpipe = ss_connect(__argv[1]);
	if (hpipe == INVALID_HANDLE_VALUE) {
		printf("cannot connect to %s", __argv[1]);
		return(2);
	}

	ss_sendrequest(hpipe, SSREQ_EXIT, NULL, strlen(__argv[1])+1);

	CloseHandle(hpipe);
	return(0);
}

/* error output functions - called by the ssclient library functions
 *
 * defined here so the library can be called from cmdline and windows
 * programs.
 *
 */
BOOL
Trace_Error(LPSTR str, BOOL fCancel)
{
	printf("%s\n", str);
	return(TRUE);
}

/*
 * status update (eg retrying...)
 */
void
Trace_Status(LPSTR str)
{
	printf("%s\n", str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\client\ssclient.h ===
/*
 * declaration of client library functions for
 * remote checksum server.
 *
 * statically linked to the calling program.
 */

/* -- functions defined in library -------------------------------  */

/* connect to the remote server */
HANDLE ss_connect(PSTR server);

/* send a request */
BOOL ss_sendrequest(HANDLE hpipe, long lCode, PSTR szPath, int lenpath, DWORD dwFlags);

/* receive a standard response block */
int ss_getresponse(HANDLE hpipe, PSSNEWRESP presp);

/* cleanly close a correctly-finished conversation */
void ss_terminate(HANDLE hpipe);

/* send a SSREQ_UNC */
BOOL ss_sendunc(HANDLE hpipe, PSTR password, PSTR server);

// I think this is obsolete - let's see if it still links without error.
// if so, please delete me!
// /* return a checksum for a file */
// ULONG ss_checksum(HANDLE hFile);

/* return a checksum for a block of data */
ULONG ss_checksum_block(PSTR block, int size);

/* checksum a single file using the checksum server */
BOOL ss_checksum_remote( HANDLE hpipe, PSTR path, ULONG * psum, FILETIME * pft, LONG * pSize,
                            DWORD *pAttr );

/* Call this before a sequence of ss_bulkcopy calls.  This should be
   considerably faster than calls to ss_copy_reliable.
   Call ss_endcopy afterwards (the copying is not complete until endcopy
   has completed.
*/
BOOL ss_startcopy(PSTR server,  PSTR uncname, PSTR password);

/* negative retcode = number of bad files,
   else number of files copied (none bad)
*/
int ss_endcopy(void);

/*
 * request to copy a file
 *
 * returns TRUE if it succeeded or FALSE if the connection was lost
 * TRUE only means the REQUEST was sent.
 */
BOOL ss_bulkcopy(PSTR server, PSTR remotepath, PSTR localpath, PSTR uncname,
                PSTR password);

/*
 * reliably copy a file (repeat (upto N times) until checksums match)
 * unc connection is made first if uncname and password are non-null
 */
BOOL ss_copy_reliable(PSTR server, PSTR remotepath, PSTR localpath, PSTR uncname,
                        PSTR password);

/* copy one file using checksum server */
BOOL ss_copy_file(HANDLE hpipe, PSTR remotepath, PSTR localpath);


VOID ss_setretries(int retries);

/* get a block of unspecified type */
int ss_getblock(HANDLE hpipe, PSTR block, int blocksize);

/* --- functions called from library - defined in calling program ------ */

/*
 * print a fatal error; allow 'cancel' button if fCancel TRUE. Returns
 * TRUE for OK.
 */
BOOL APIENTRY Trace_Error(HWND hwnd, LPSTR str, BOOL fCancel);

/*
 * print a status report on non-fatal error (eg 'retrying...').
 * can be no-op if status not desired.
 */
void Trace_Status(LPSTR str);

/*
 * client app must define this (can be set to NULL - used for MessageBox)
 */
extern HWND hwndClient;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\client\ssclient.c ===
#define trace
/*
 *
 * client library for remote checksum server
 *
 * functions for connecting to the server pipe, and reading
 * and writing messages.
 *
 *                !! DEBUG HINT: !!
 *
 * - ENABLE Trace_Stat and Trace_Fil about 30 lines below here
 *          so that they generate file output.
 *          F11 from Windiff will do the trick on a debug build version!
 *
 * expects Trace_Error() to be defined in the client program.
 */

#include <windows.h>
#include <lzexpand.h>
#include <stdio.h>
#include <string.h>
#include <gutils.h>
#include <list.h>
#include "..\server\sumserve.h"
#include "..\windiff\windiff.h"           // for TRACE_ERROR and Windiff_UI which it calls
#include "ssclient.h"

/* need to sort out header files                      !!! */
void SetNames(LPSTR names);           /* from Windiff !!! */
void SetStatus(LPSTR cmd);

ULONG ss_checksum_block(PSTR block, int size);
DWORD WINAPI ReceiveFiles(LPVOID handle);
#ifdef SOCKETS
BOOL GetFile(SOCKET hpipe, PSTR localpath, PSSNEWRESP  presp);
#else
BOOL GetFile(HANDLE hpipe, PSTR localpath, PSSNEWRESP  presp);
#endif
HANDLE ConnectPipe(PSTR pipename);

extern BOOL bTrace;      /* in Windiff.c */

int CountRetries = 5;


/* SOCKETS / NAMED PIPES macros
 */
#ifdef SOCKETS
#define MAYBESOCKETTYPE         SOCKET
#define CLOSEHANDLE( handle )   closesocket( handle )
#else
#define MAYBESOCKETTYPE         HANDLE
#define CLOSEHANDLE( handle )   CloseHandle( handle )
#endif


/*--------------------------- DEBUG FUNCTIONS ----------------------------*/
void Trace_Stat(LPSTR str)
{
        if (bTrace) {
                Trace_File(str);
                Trace_File("\n");
        }
        Trace_Status(str);
}/* Trace_Stat */


void Trace_Fil(LPSTR str)
{
        if (bTrace) {
                Trace_File(str);
        }
} /* Trace_Fil */

/*------------------------------------------------------------------------*/

static char MainPipeName[400];           /* pipe name for requests to server */
extern BOOL bAbort;                     /* abort flag from Windiff */

/* set up pipename for main pipe */
void InitPipeName(PSTR result, PSTR server, PSTR name)
{       sprintf(result, "\\\\%s\\pipe\\%s", server, name);
} /* InitPipeName */


/* ss_connect:
 * make a connection to the server.
 *
 * create the correct pipe name \\server\pipe\NPNAME,
 * connect to the pipe and set the pipe to message mode.
 *
 * return INVALID_HANDLE_VALUE if failure
 */
HANDLE
ss_connect(PSTR server)
{       char pipename[400];
        InitPipeName(pipename, server, NPNAME);
        return ConnectPipe(pipename);

} /* ss_connect */

VOID
ss_setretries(int retries)
{
    CountRetries = retries;
}


/* ss_connect:
 * make a connection to the pipe named.
 *
 * connect to the pipe and set the pipe to message mode.
 *
 * return INVALID_HANDLE_VALUE if failure
 */
HANDLE ConnectPipe(PSTR pipename)
{
        HANDLE hpipe;
        DWORD dwState;
        int i;
        BOOL haderror = FALSE;

        {       char msg[400];
                wsprintf(msg, "ConnectPipe to %s\n", pipename);
                Trace_Fil(msg);
        }

        for (; ; ){  /* repeat if user asks */
                int MsgBoxId;

                /* repeat connect attempt up to 5 times without asking. */
                for (i= 0; i < CountRetries; i++) {

                        if (bAbort) return INVALID_HANDLE_VALUE;

                        /* connect to the named pipe */
                        hpipe = CreateFile(pipename,
                                        GENERIC_READ|GENERIC_WRITE,
                                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        0);

                        if (hpipe != INVALID_HANDLE_VALUE) {
                                /* switch the pipe to message mode */
                                dwState = PIPE_WAIT | PIPE_READMODE_MESSAGE;

                                SetNamedPipeHandleState(hpipe, &dwState, NULL, NULL);

                                if (haderror) {
                                        Trace_Stat("connection ok");
                                }
                                {       char msg[80];
                                        wsprintf(msg, "ConnectedPipe hpipe %x\n", HandleToUlong(hpipe));
                                        Trace_Fil(msg);
                                }
                                return(hpipe);
                        }
                        else {
                                DWORD errorcode = GetLastError();
                                char msg[400];
                                wsprintf(msg, "Error %d on Create Pipe %s", errorcode, pipename);
                                Trace_Stat(msg);
                        }

                        /* connect failed - wait one seconds before retrying */
                        if (CountRetries > 1) {
                            Sleep(1000);
                        }

                        /*
                         * only report success with Trace_Stat if we also
                         * reported an error (don't disturb the user
                         * unnecessarily - he just see nothing unusual if all goes well
                         */
                        haderror = TRUE;
                        Trace_Stat("Retrying pipe connection...");

                } /* retry 5 loop */

                if (CountRetries > 1) {
                    windiff_UI(TRUE);
                    MsgBoxId = MessageBox( hwndClient
                                     , "Pipe connection failed 5 times.  Retry some more?"
                                     , "Windiff: Network connection error"
                                     , MB_RETRYCANCEL
                                     );
                    windiff_UI(FALSE);
                    if (MsgBoxId != IDRETRY)
                            break;
                } else {
                    break;
                }
        } /* ask loop */

        Trace_Fil("ConnectPipe failed");
        return(INVALID_HANDLE_VALUE);
} /* ConnectPipe */

/* build and send a request message to the server. Check for network
 * errors, and retry (unless the pipe is broken) up to 10 times.
 *
 * if write succeeds - return TRUE.
 * if failure - return FALSE to indicate connection is dropped.
 */
BOOL
ss_sendrequest(HANDLE hpipe, long lCode, PSTR szPath, int lenpath, DWORD dwFlags)
{
        SSNEWREQ req;
        int size, count, errorcode;

        Trace_Fil("ss_sendrequest\n");
        req.lCode = -lCode;   /* negative code for versions greater than 0 */
        req.lVersion = SS_VERSION;
        req.lRequest = LREQUEST;
        req.lFlags = dwFlags;
        if (szPath != NULL) {
                /* szPath may be more than one null-term string,
                 * so copy the bytes rather than a strcpy().
                 */
                for (size = 0; size < lenpath; size++) {
                        req.szPath[size] = szPath[size];
                }
        } else {
                req.szPath[0] = '\0';
        }

        /* trace stuff */
        {       char msg[80];
                wsprintf(msg, "Sending request: %d on pipe %x\n", req.lCode, HandleToUlong(hpipe));
                Trace_Fil(msg);
        }

        /* loop retrying the send until it goes ok */
        for (count = 0; count < CountRetries; count++) {

                if (bAbort) {
                        CloseHandle(hpipe);
                        return FALSE;
                }
#ifdef trace
        {       char msg[80];
                wsprintf(msg, "Actually sending on pipe %x... ", HandleToUlong(hpipe));
                Trace_Fil(msg);
        }
#endif
                if (WriteFile(hpipe, &req, sizeof(req), (LPDWORD)(&size), NULL)) {
#ifdef trace
                        {       char msg[80];
                                wsprintf(msg, "Sent req %d OK,  pipe %x\n", req.lCode, HandleToUlong(hpipe));
                                Trace_Fil(msg);
                        }
#endif

                        /* no error reported - was everything written?*/
                        if (size != sizeof(req)) {

                                /* write was NOT ok - report and retry */
                                if (!TRACE_ERROR("pipe write size differs... Retry?", TRUE)) {
                                    return(FALSE);
                                }

                                continue;
                        } else {
                                /* all ok */
                                char msg[80];
                                wsprintf(msg, "Request %d sent on %x\n", req.lCode, HandleToUlong(hpipe));
                                Trace_Fil(msg);
                                return(TRUE);
                        }
                }
#ifdef trace
                {       char msg[80];
                        wsprintf(msg, "!!Bad send pipe %x\n", HandleToUlong(hpipe));
                        Trace_Fil(msg);
                }
#endif

                /* an error occurred */
                switch( (errorcode = (int)GetLastError())) {

                case ERROR_NO_DATA:
                case ERROR_BROKEN_PIPE:
                        /* pipe connection lost - forget it */
                        Trace_Stat("pipe broken on write");
                        return(FALSE);

                default:
                        {       char msg[120];
                                wsprintf(msg, "pipe write error %d on pipe %x.  Retrying..."
                                        , errorcode, HandleToUlong(hpipe));
                                Trace_Stat(msg);
                        }
                        Sleep(count*1000);     /* total sleep possible is 45 sec */
                        break; /* from switch, not loop */
                }
        }

        /* retry count reached - abandon this attempt */
        TRACE_ERROR("retry count reached on pipe write error.", FALSE);
        return(FALSE);
} /* ss_sendrequest */

/* read a message from a pipe, allowing for network errors
 *
 * if error occurs, retry up to 10 times unless error code
 * indicates that pipe is broken - in which case, give up.
 *
 * return size read if all ok, -1 to mean the connection is broken,
 * abort this client, 0 to mean other error.
 */
int
ss_getblock(HANDLE hpipe, PSTR block, int blocksize)
{
        int count;
        int size;
        int errorcode;
        static BOOL PipeError = FALSE;
        char msg[200];

        wsprintf(msg, "ss_getblock.  hpipe=%x\n", HandleToUlong(hpipe));
        Trace_Fil(msg);
        /* retry up to 10 times */
        for (count = 0; count < CountRetries; count++ ) {

                if (bAbort) {
                        CloseHandle(hpipe);
                        return -1;
                }

#ifdef trace
                {  
                        wsprintf(msg, "Actual receive pipe %x...", HandleToUlong(hpipe));
                        Trace_Fil(msg);
                }
#endif
                if (ReadFile(hpipe, block, blocksize, (LPDWORD)(&size), NULL)) {
#ifdef trace
                        {     
                                wsprintf(msg, "Good receive pipe %x\n", HandleToUlong(hpipe));
                                Trace_Fil(msg);
                        }
#endif

                        /* check size of message */
                        if (size == 0) {
                                Trace_Fil("zero length message\r\n");
                                continue;
                        }

                        /* everything ok */
                        {       SSNEWRESP * ssp;
                                ssp = (PSSNEWRESP) block;
                                wsprintf( msg, "ss_getblock got block OK pipe %x: %x %x %x %x %x\n"
                                        , HandleToUlong(hpipe)
                                        , ssp->lVersion, ssp->lResponse, ssp->lCode, ssp->ulSize
                                        , ssp->fileattribs
                                        );
                                Trace_Fil ( msg );
                        }
                        if (PipeError) {
                           PipeError = FALSE;
                           SetStatus("Pipe recovered");
                        }
                        return size;
                }
#ifdef trace
                {       
                        wsprintf(msg, "!!Bad receive pipe %x\n", HandleToUlong(hpipe));
                        Trace_Fil(msg);
                }
#endif

                /* error occurred - check code */
                switch((errorcode = (int)GetLastError())) {

                case ERROR_BROKEN_PIPE:
                        /* connection broken. no point in retrying */
                        {   
                            wsprintf( msg, "pipe %x broken on read.", HandleToUlong(hpipe));
                            TRACE_ERROR(msg, FALSE);
                        }
                        return(-1);

                case ERROR_MORE_DATA:
                        /* the message sent is larger than our buffer.
                         * this is an internal error - report it and carry on
                         */
                        {       
                                SSNEWRESP * ssp;

                                wsprintf( msg, "message too large on pipe %x blocksize=%d data="
                                        , HandleToUlong(hpipe), blocksize
                                        );
                                Trace_Fil(msg);
                                ssp = (PSSNEWRESP) block;
                                wsprintf( msg, "%8x %8x %8x %8x %8x\n"
                                        , ssp->lVersion, ssp->lResponse, ssp->lCode, ssp->ulSize
                                        , ssp->fileattribs
                                        );
                                Trace_Fil(msg);

                        }
                        /* Too low a level for message to user.  Recoverable at higher level
                        ** TRACE_ERROR("internal error- message too large", FALSE);
                        */
                        return -2;

                default:
                        {       
                                wsprintf(msg, "read error %d on pipe %x", errorcode, HandleToUlong(hpipe));
                                Trace_Stat(msg);

                        }
                        Sleep(count*1000);
                        break;
                }
        }
        SetStatus("Pipe error");
        PipeError = TRUE;
        TRACE_ERROR("retry count reached on pipe read error.", FALSE);
        return 0;
} /* ss_getblock */


/*
 * read a standard response from the net, retrying if necessary. return
 * size if ok or <=0 if not.  -1 means pipe broken.
 */
int
ss_getresponse(HANDLE hpipe, PSSNEWRESP presp)
{
        Trace_Fil("ss_getresponse\n");
        return(ss_getblock(hpipe, (PSTR) presp, sizeof(SSNEWRESP)));
} /* ss_getresponse */


/*
 * terminate the connection to the server. send an END message and
 * close the pipe
 */
void
ss_terminate(HANDLE hpipe)
{
        Trace_Fil("ss_terminate\n");
        ss_sendrequest(hpipe, SSREQ_END, NULL, 0,0);
        CloseHandle(hpipe);
} /* ss_terminate */


/* send a unc & password request. the password and the server strings
 * are both held in the buffer as two consecutive null-terminated strings
 */
BOOL
ss_sendunc(HANDLE hpipe, PSTR password, PSTR server)
{
        char buffer[MAX_PATH] = {0};
        char * cp;
        int len;

        Trace_Fil("ss_sendunc\n");
        strncat(buffer, password, sizeof(buffer)-1);

        cp = &buffer[strlen(buffer) + 1];
        strcpy(cp,server);

        len = (int)((cp - buffer) + strlen(cp) + 1);

        return(ss_sendrequest(hpipe, SSREQ_UNC, buffer, len, 0));
}

/*
 * checksum a single file using the checksum server
 */
BOOL
ss_checksum_remote( HANDLE hpipe, PSTR path
                  , ULONG * psum, FILETIME * pft, LONG * pSize, DWORD *pAttr )
{
        SSNEWRESP resp;
        char msg[400];

        *psum = 0;
        if (!ss_sendrequest(hpipe, SSREQ_SCAN, path, strlen(path)+1, 0)) {

                return(FALSE);
        }

        if (0>=ss_getresponse(hpipe, &resp)) {
                return(FALSE);
        }

        if (resp.lResponse != LRESPONSE) {
                return(FALSE);
        }


        switch(resp.lCode) {

        case SSRESP_END:
                TRACE_ERROR("No remote files found", FALSE);
                return(FALSE);

        case SSRESP_ERROR:
                if (resp.ulSize!=0) {
                    wsprintf( msg, "Checksum server could not read %s win32 code %d"
                            , resp.szFile, resp.ulSize
                            );
                }
                else
                    wsprintf(msg, "Checksum server could not read %s", resp.szFile);
                TRACE_ERROR(msg, FALSE);
                return(FALSE);

        case SSRESP_CANTOPEN:
                wsprintf(msg, "Checksum server could not open %s", resp.szFile);
                TRACE_ERROR(msg, FALSE);
                return(FALSE);

        case SSRESP_FILE:
                *psum = resp.ulSum;
                *pSize = resp.ulSize;
                *pft = resp.ft_lastwrite;
                *pAttr = resp.fileattribs;

                /* read and discard any further packets until SSRESP_END */
                while(0<ss_getresponse(hpipe, &resp)) {
                        if (resp.lCode == SSRESP_END) {
                                break;
                        }
                }

                return(TRUE);

        case SSRESP_DIR:
                wsprintf(msg, "Checksum server thinks %s is a directory", resp.szFile);
                TRACE_ERROR(msg, FALSE);
                return(FALSE);
        default:
                wsprintf(msg, "Bad code from checksum server:%d", resp.lCode);
                TRACE_ERROR(msg, FALSE);
                return(FALSE);
        }

} /* ss_checksum_remote */


/*****************************************************************************
  Bulk copying of files:
  Our caller should call ss_startcopy to set things up and then
  call ss_bulkcopy as many times as necessary to transmit the
  file names and then ss_endcopy to wait for the spawned threads
  to finish.  It is also possible to copy a single file by
  ss_copy_reliable.  For multiple files, bulkcopy should be
  much faster.

  Overall organisation, threads etc:
  There are multiple threads in the server.  Read the writeup
  in ..\server\files.c if you want to understand those.  Read
  that writeup ANYWAY to understand the link protocols (i.e.
  which messages are sent in which order between client and server).

  ss_startcopy kicks off a thread to do the actual receiving.
  It exits when it receives a SSRESP_END.

  Within this thread we do most of the processing synchronously.  We
  rely on a file system that does lazy writing to disk to give
  us effectively a pipeline that gets the file written to disk
  in parallel with reading the pipe so that with luck we can always
  be waiting for the data to arrive through the pipe and never have
  the pipe waiting for us.

  The decompression of a file is a lengthy business, so we spawn threads
  to do that.  We need to check the return codes of the decompression,
  so we get that via GetExitCodeThread.  We put the hThreads that we
  create onto a LIST and periodically (after every file) run down this
  list trying to get exit codes.  When we get a code other than STILL_ACTIVE
  we interpret it as good or bad, add to the counts of nGoodFiles or
  nBadFiles and delete it from the list.  ss_endcopy will wait for all
  the decompression to finish by running down the list WAITing for the
  hThreads.  Because we purge the list regularly it should never get
  very long.  We are worried about the prospect of having 1000 dead
  threads lying around if we don't purge it.

  If a copy fails (i.e. the checksum on arrival after unpacking is different
  from that sent in the SSNEWRESP header for the file) then we call
  ss_copy_reliable to have it re-sent.  If we just call that right away, it
  seems to cause confusion.  As far as I can tell the attempt to open up
  a new pipe doesn't seem to work properly (the two processes interfere).
  The symptom is that we promptly get out of step on the data pipe (??!) with
  data packets arriving when we expected response packets.

  So we keep a list of things to be retried and retry them by serially doing
  a ss_copy_reliable for each one after the rest of the copying has finished.
****************************************************************************/

/* The following are remembered across startcopy..bulkcopy..endcopy
   They correspond to the all-lower-case versions given as
   parameters to ss_copy_reliable
   Note that this is per-process storage, so multiple windiffs should be OK.
*/
static  char Server[MAX_PATH];          /* machine running sumserve */
static  char UNCName[MAX_PATH];         /* \\server\share for remote files */
static  char Password[MAX_PATH];        /* for remote share */

static  BOOL BulkCopy = FALSE;          /* to prevent simple copy during bulk*/
static  int  nGoodFiles = 0;            /* number received OK */
static  int  nBadFiles = 0;             /* number received with errors */
static  int  nFiles = 0;                /* number requested */
static  HANDLE hThread = INVALID_HANDLE_VALUE;  /* the receiving thread */

static  HANDLE hpipe = INVALID_HANDLE_VALUE;    /* the main pipe to send names*/
#ifdef SOCKETS
static  SOCKET hpData = (SOCKET)INVALID_HANDLE_VALUE;   /* the data pipe to get files*/
#else
static  HANDLE hpData = INVALID_HANDLE_VALUE;   /* the data pipe to get files*/
#endif

static LIST Decomps = NULL;                     /* hThreads of decompressers */
static LIST Retries = NULL;                     /* DECOMPARGS to retry */

/* Thread arguments for the decompress thread */
typedef struct{
        DWORD fileattribs;
        FILETIME ft_create;
        FILETIME ft_lastaccess;
        FILETIME ft_lastwrite;
        long  lCode;            /* success code from file xfer so far */
        ULONG ulSum;            /* checksum for file */
        BOOL bSumValid;         /* TRUE iff there was a checksum for file */
        char Temp[MAX_PATH];    /* temp path == source */
        char Real[MAX_PATH];    /* real path == target */
        char Remote[MAX_PATH];  /* remote path to allow retry */
} DECOMPARGS;

/* forward declarations */
int  Decompress(DECOMPARGS * da);
void SpawnDecompress(PSTR TempPath, PSTR RealPath, PSSNEWRESP  presp);
void PurgeDecomps(LIST Decs);

/* ss_startcopy
   Set things up for bulkcopy

   Because we expect to send a list of names off and get a list of
   files back, we need to keep track of the local names so that we can
   associate the file with the right name.  This means either sending our
   local name across the link and back or else keeping a list of
   them here.  The list could be long (typically 1000 for an NT build).
   MAX_PATH is 260 or 520 bytes if unicoded.
   and so long as this involves no extra line turnarounds, this might take
   as long as 520 /8K secs *2 (there and back) or about 130mSec.
   (We have seen 8K bytes/sec sustained over a period).  Probably the
   true burst data rate is 32Kbytes/sec giving about 30msec.
   Either way this is only 30 secs to 2 mins per build overhead.
   Of course it's much shorter for normal paths, especially as we pack
   the data end to end (like a superstring but without the 00 at the end).

   So for the above reasons the local (client) name is transmitted with the
   file request and sent back with the file in a SSNEWRESP.
*/
BOOL ss_startcopy(PSTR server,  PSTR uncname, PSTR password)
{       int retry;
        SSNEWRESP resp;         /* buffer for messages received */
        DWORD ThreadId;         /* to keep CreateThread happy */
#ifdef SOCKETS
        static BOOL SocketsInitialized = FALSE;
#endif

        Trace_Fil("ss_startcopy\n");
        nFiles = 0; nGoodFiles = 0; nBadFiles = 0;

        /* don't need a crit sect here because this runs on the main thread */
        if (BulkCopy) return FALSE;     /* already running! */
        BulkCopy = TRUE;

        if (server!=NULL) strcpy(Server, server); else Server[0] = '\0';
        if (uncname!=NULL) strcpy(UNCName, uncname); else UNCName[0] = '\0';
        if (password!=NULL) strcpy(Password, password); else Password[0] = '\0';

        {       char msg[400];
                wsprintf(msg, "Server '%s' UNC '%s' pass '%s'\n", Server, UNCName, Password);
                Trace_Fil(msg);
        }
        /* create the list of decompressor hThreads */
        Decomps = List_Create();
        Retries = List_Create();

        for (retry = 0; retry < 10; retry++) {
                if (hpipe!=INVALID_HANDLE_VALUE) {
                        Trace_Fil("ss_startcopy closing pipe for retry");
                        CloseHandle(hpipe);
                        hpipe = INVALID_HANDLE_VALUE;
                }
                if (bAbort) {
                        CloseHandle(hpipe);
                        hpipe = INVALID_HANDLE_VALUE;
                        return FALSE;
                }

                /* connect to main pipe */
                {       char pipename[400];
                        InitPipeName(pipename, server, NPNAME);
                        hpipe = ConnectPipe(pipename);
                }

                if (hpipe == INVALID_HANDLE_VALUE) {
                        /* next retry in two seconds */
                        Trace_Stat("connect failed - retrying");
                        Sleep(1000);
                        continue;
                }

                {       char msg[80];
                        wsprintf(msg, "ConnectedPipe to pipe number %x\n",HandleToUlong(hpipe));
                        Trace_Fil(msg);
                }

                if ((uncname != NULL) && (password != NULL)) {
                        /* send the password request */
                        if (!ss_sendunc(hpipe, password, uncname)) {
                                Trace_Fil("Server connection lost (1)\n");
                                TRACE_ERROR("Server connection lost", FALSE);
                                CloseHandle(hpipe);
                                hpipe = INVALID_HANDLE_VALUE;
                                continue;
                        }

                        /* wait for password response */
                        if (0>=ss_getresponse(hpipe, &resp)) {
                                Trace_Fil("Server connection lost (2)\n");
                                TRACE_ERROR("Server connection lost", FALSE);
                                continue;
                        }
                        if (resp.lResponse != LRESPONSE) {
                                Trace_Fil("Password - bad response\n");
                                TRACE_ERROR("Password - bad response", FALSE);
                                return(FALSE);
                        }
                        if (resp.lCode != SSRESP_END) {
                                Trace_Fil("Password attempt failed\n");
                                TRACE_ERROR("Password attempt failed", FALSE);
                                return(FALSE);
                        }
                }
                break;

        } /* retry loop */
        if (hpipe == INVALID_HANDLE_VALUE) {
                return FALSE;
        }

#ifdef SOCKETS
        if( !SocketsInitialized )
        {
                WSADATA WSAData;

                if( ( WSAStartup( MAKEWORD( 1, 1 ), &WSAData ) ) == 0 )
                {
                        SocketsInitialized = TRUE;
                }
                else
                {
                        TRACE_ERROR("WSAStartup failed", FALSE);
                }
        }
#endif

        /* Tell server we want to send a file list */
        if(!ss_sendrequest( hpipe, SSREQ_FILES, NULL, 0, 0)){
                return FALSE;
        }

        /* expect a reply which names a data pipe */
        {       
                if ( 0>=ss_getresponse(hpipe, &resp) ){
                        Trace_Fil("Couldn't get data pipe name\n");
                        TRACE_ERROR("Couldn't get data pipe name", FALSE);
                        CloseHandle(hpipe);
                        hpipe = INVALID_HANDLE_VALUE;
                        return FALSE;
                }
                if ( resp.lResponse!=LRESPONSE){
                        Trace_Fil("Bad RESPONSE when expecting data pipe name\n");
                        TRACE_ERROR("Bad RESPONSE when expecting data pipe name", FALSE);
                        CloseHandle(hpipe);
                        hpipe = INVALID_HANDLE_VALUE;
                        return FALSE;
                }
                if ( resp.lCode!=SSRESP_PIPENAME){
                        char msg[80];
                        TRACE_ERROR("Wrong response when expecting data pipe name", FALSE);
                        wsprintf(msg
                                ,"Wrong response (%d) when expecting data pipe name\n"
                                , resp.lCode);
                        Trace_Fil(msg);
                        CloseHandle(hpipe);
                        hpipe = INVALID_HANDLE_VALUE;
                        return FALSE;
                }

                {       char msg[400];
                        wsprintf(msg, "data pipe name = '%s'\n", resp.szFile);
                        Trace_Fil(msg);
                }

#ifdef SOCKETS
        /* We put the TCP port in the high date time slot just for now:
         */
                if( SOCKET_ERROR == SocketConnect( server, (u_short)resp.ft_lastwrite.dwHighDateTime, &hpData ) )
                {
                        Trace_Fil("Couldn't connect to socket\n");
                        TRACE_ERROR("Couldn't connect to socket", FALSE);
                        CLOSEHANDLE(hpData);
                        hpData = (SOCKET)INVALID_HANDLE_VALUE;
                        return FALSE;
                }
#else
                if (resp.szFile[0]=='\\') {
                        /* hack to fix bug.  Replace "." by server name */
                        char buff[70];
                        PSTR temp;
                        temp = strtok(resp.szFile,".");
                        temp = strtok(NULL,".");
                        strcpy(buff, temp);
                        strcat(resp.szFile, server);
                        strcat(resp.szFile, buff);
                        wsprintf(buff, "fixed data pipe name = %s\n", resp.szFile);
                        Trace_Fil(buff);
                }

                hpData = ConnectPipe(resp.szFile);
                if (hpData == INVALID_HANDLE_VALUE) {
                        Trace_Fil("Couldn't connect to data pipe\n");
                        TRACE_ERROR("Couldn't connect to data pipe", FALSE);
                        CloseHandle(hpData);
                        hpData = INVALID_HANDLE_VALUE;
                        return FALSE;
                }
#endif /* SOCKETS */
        }

        /* Start a thread to listen for the SSRESPs that will come through */
        Trace_Fil("Starting ReceiveFiles thread\n");
        hThread = CreateThread( NULL, 0, ReceiveFiles, (LPVOID)hpData, 0, &ThreadId);
        Trace_Fil("End of ss_startCopy\n");
        return TRUE;
} /* ss_startcopy */

/* Collect files from hpData.
   See ..\server\files.c for the protocol.
*/
DWORD WINAPI ReceiveFiles(LPVOID handle)
{
        LPSTR lname;
        BOOL Recovering = FALSE;

        SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST);

#ifdef SOCKETS
        hpData = (SOCKET)handle;
#else
        hpData = (HANDLE)handle;
#endif
        {       char msg[80];
                wsprintf(msg, "Receiving Files on pipe %x\n", PtrToLong(hpData));
                Trace_Fil(msg);
        }

        /* for each file... */
        for (; ; ) {  /* loop getting files until we get END (or error) */
                SSNEWRESP Resp;
                char Guard = '\0';      /* to protect scanning for \0 in Resp */
                int BuffSize;

#ifdef SOCKETS
                BuffSize = recv(hpData, (PSTR) &Resp, sizeof(Resp), 0);
                if (BuffSize==SOCKET_ERROR) {
                        /* We're out of step - almost certainly got a data packet
                        ** when we expected a response block
                        ** Try to recover by reading until we DO get a resp.
                        */
                        if (Resp.lResponse==LRESPONSE) {
                                
                                CLOSEHANDLE(hpData);    /* tough */
                                hpData = (SOCKET)INVALID_HANDLE_VALUE;
                                return (DWORD)(-1);
                        }
                        if (!Recovering){
                                Recovering = TRUE;
                                TRACE_ERROR("Network protocol error.  OK to Resync? (else abort)", TRUE);
                        }
                        continue;
                }
#else
                BuffSize = ss_getblock(hpData, (PSTR) &Resp, sizeof(Resp));
                if (BuffSize==-2) {
                        /* We're out of step - almost certainly got a data packet
                        ** when we expected a response block
                        ** Try to recover by reading until we DO get a resp.
                        */
                        if (Resp.lResponse==LRESPONSE) {
                                
                                CloseHandle(hpData);    /* tough */
                                hpData = INVALID_HANDLE_VALUE;
                                return (DWORD)(-1);
                        }
                        if (!Recovering){
                                Recovering = TRUE;
                                TRACE_ERROR("Network protocol error.  OK to Resync? (else abort)", TRUE);
                        }
                        continue;
                }
#endif /* SOCKETS */
                if (Recovering && Resp.lResponse!=LRESPONSE) continue;

                Recovering = FALSE;

                if (BuffSize<=0) {
                        Trace_Fil("Couldn't read pipe to get file header.\n");
                        CLOSEHANDLE(hpData);    /* tough */
                        hpData = (MAYBESOCKETTYPE)INVALID_HANDLE_VALUE;
                        return BuffSize;
                }

                Trace_Fil("ReceiveFiles got resp\n");
                if (Resp.lResponse!=LRESPONSE) {
                        Trace_Fil("Network protocol error. Not RESP block\n");
                        TRACE_ERROR("Network protocol error. Not RESP block", FALSE);
                        continue;
                }

                if (Resp.lVersion!=SS_VERSION) {
                        Trace_Fil("Network protocol error.  Bad VERSION\n");
                        TRACE_ERROR("Network protocol error.  Bad VERSION", FALSE);
                        continue;       /* maybe it will resync */
                }
                if (Resp.lCode==SSRESP_END)
                        /* normal ending. */
                        break;

                if (  Resp.lCode!=SSRESP_FILE
                   && Resp.lCode!=SSRESP_NOTEMPPATH
                   && Resp.lCode!=SSRESP_COMPRESSEXCEPT
                   && Resp.lCode!=SSRESP_NOREADCOMP
                   && Resp.lCode!=SSRESP_NOCOMPRESS
                   && Resp.lCode!=SSRESP_COMPRESSFAIL
                   ) {
                        /// want a try finally here to protect the filename???!!!
                        char msg[400];
                        wsprintf( msg, "Error code received: %d file:%s"
                                , Resp.lCode
                                , (Resp.szFile ? Resp.szFile : "NULL") );
                        Trace_Fil(msg);
                        ++nBadFiles;
                        if (!TRACE_ERROR(msg, TRUE)) {
                            /* abort operation */
                            bAbort = TRUE;

                            CLOSEHANDLE(hpData);        /* tough */
                            hpData = (MAYBESOCKETTYPE)INVALID_HANDLE_VALUE;
                            return (DWORD)-1;
                        }

                        continue;
                }

                /* Find the local name */
                lname = &(Resp.szFile[0]) + strlen(Resp.szFile) +1;
                /* memmove(Resp.szLocal, lname, strlen(lname)+1); */

                /* Assume Resp.(ulSize, ft, ulSum, bSumValid, szFile, szLocal
                   are all valid */
                if (!GetFile( hpData, lname, &Resp))
                        ++nBadFiles;
                /* If it's good it gets counted when decompressed */

        } /* files loop */
        return 0;
} /* ReceiveFiles */


/* Read the file from hpipe as a series of SSNEWPACKs.
   Write them into a temporary file.  Stop writing when
   a short one comes in.  Spawn a thread to decompress it into localpath.
   check existing decompress threads for status and count
   the number of good/bad files.
*/
BOOL
#ifdef SOCKETS
GetFile(SOCKET hpipe, PSTR localpath, PSSNEWRESP  presp)
#else
GetFile(HANDLE hpipe, PSTR localpath, PSSNEWRESP  presp)
#endif
{
        HANDLE hfile;
        int sequence;
        ULONG size;
        SSNEWPACK packet;
        BOOL bOK = TRUE;
        BOOL bOKFile = TRUE;   /* FALSE means output file nbg, but keep running along
                                  to stay in step with the pipe protocol
                               */
        char szTempname[MAX_PATH];
        DWORD rc;
        {       char msg[50+MAX_PATH];
                wsprintf(msg, "GetFile %s\n", localpath);
                Trace_Fil(msg);
        }

        /* create a temporary name */
        rc = GetTempPath(sizeof(szTempname), szTempname);
        if (rc==0) {
                char Msg[100];
                wsprintf(Msg, "GetTempPath failed, error code=%ld", GetLastError());
                TRACE_ERROR(Msg, FALSE);
                bOKFile = FALSE;
        }

        if (bOKFile){
                rc = GetTempFileName(szTempname, "ssb", 0, szTempname);
                if (rc==0) {
                        char Msg[100];
                        wsprintf(Msg, "GetTempFileName failed, error code=%ld", GetLastError());
                        TRACE_ERROR(Msg, FALSE);
                        return FALSE;
                }
        }

        if (bOKFile){
        /* try to create the temp file */
        hfile = CreateFile(szTempname,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

                if (hfile == INVALID_HANDLE_VALUE) {
                        char Msg[500];
                        wsprintf(Msg, "GetFile: could not create temp file %s", szTempname);
                        TRACE_ERROR(Msg, FALSE);
                        bOKFile = FALSE;
                }
        }
        else hfile = INVALID_HANDLE_VALUE;

        for (sequence = 1; ; sequence++) {

                int SizeGotten;
#ifdef SOCKETS
                SizeGotten = recv(hpipe, (PSTR) &packet, sizeof(packet), 0);
#else
                SizeGotten = ss_getblock(hpipe, (PSTR) &packet, sizeof(packet));
#endif

                if (SizeGotten<=0) {
                        /* error - could be an Abort request */
                        char msg[80];
                        wsprintf( msg, "Network error.  Size received=%d\n", SizeGotten);
                        Trace_Fil(msg);
                        bOK = FALSE;
                        break;
                }

                if (packet.lPacket!=LPACKET) {
                        {       char msg[200];
                                wsprintf( msg
                                        , "Network protocol error. Not PACKET: %x %x %x %x %x"
                                        , packet.lVersion
                                        , packet.lPacket
                                        , packet.lSequence
                                        , packet.ulSize
                                        , packet.ulSum
                                        );
                                /* and maybe someone will recognise what on earth it is */
                                Trace_Fil(msg);
                        }
                        TRACE_ERROR("Network protocol error. Not PACKET.", FALSE);
                        bOK = FALSE;
                        break;
                }

                if (sequence != packet.lSequence) {
                        /* error or out of sequence */
                        char msg[200];
                        wsprintf( msg, "Packet out of sequence. Got %d expected %d\n"
                                , packet.lSequence, sequence);
                        Trace_Fil(msg);
                        TRACE_ERROR("Packet sequence error.", FALSE);
                        bOK = FALSE;
                        break;
                }

                if (packet.ulSize ==0) {
                        /*
                         * this is really the last block (end of file).
                         *
                         * LATER
                         * do SSATTRIBS on the end to support NTFS properly !!!
                         */
                        Trace_Fil("End of file marker (0 length)\n");
                        break;
                }
#if 1
                /* check the block checksums */
                if ( packet.ulSum != 0 ) {
                        TRACE_ERROR("packet checksum error", FALSE);
                        bOK = FALSE;
                        break;
                }
#else           // Debug version.  (Remember to enable server checksums too)
                // Also ensure that Trace_Fil is actually tracing.
                {       ULONG PackSum;
                        /* check the block checksums */
                        if (  (PackSum = ss_checksum_block(packet.Data, packet.ulSize))
                              != packet.ulSum
                           ) {
                                char msg[80];
                                wsprintf( msg, "Packet checksum error was %x should be %x\n"
                                          , PackSum, packet.ulSum );
                                Trace_Fil(msg);
                                // but don't break;
                        }
                }
#endif

                if ( packet.ulSize==(ULONG)(-1) || packet.ulSize==(ULONG)(-2) )  {
                        TRACE_ERROR("Error from server end", FALSE);
                        bOK = FALSE;
                        break;
                }

                if (bOKFile) {
                        bOK = WriteFile(hfile, packet.Data, packet.ulSize, &size, NULL);
                        {       char msg[80];
                                wsprintf( msg,"Writing block to disk - size= %d\n", size);
                                Trace_Fil(msg);
                        }
                        if (!bOK || (size != packet.ulSize)) {
                                TRACE_ERROR("File write error", FALSE);
                                bOK = FALSE;
                                break;
                        }
                }
                else bOK = FALSE;

                if (packet.ulSize < PACKDATALENGTH)
                {
                        /* this is the last block (end of file) */
                        Trace_Fil("End of file marker (short packet)\n");
                        break;
                }

        } /* for each block */

        CloseHandle(hfile);
        if (!bOK) {
                DeleteFile(szTempname);
                return FALSE;
        }


        SpawnDecompress(szTempname, localpath, presp);
        PurgeDecomps(Decomps);

        return bOK;

} /* GetFile */


/* Spawn a thread to decompress TempPath into RealPath on a new thread
   Add the thread handle to the LIST Decomps.
   If presp->lCode is one of SSRESP_NOTEMPPATH
                             SSRESP_COMPRESSEXCEPT
                             SSRESP_NOREADCOMP
                             SSRESP_NOCOMPRESS
   Then the file should just be copied, not decompressed.
*/
void SpawnDecompress(PSTR TempPath, PSTR RealPath, PSSNEWRESP  presp)
{
        DECOMPARGS * DecompArgs;
        HANDLE L_hThread;
        DWORD ThreadId;

        {       char msg[MAX_PATH+60];
                wsprintf(msg, "Spawning decompress of %s", TempPath);
                Trace_Fil(msg);
        }
        DecompArgs = (DECOMPARGS *)GlobalAlloc(GMEM_FIXED, sizeof(DECOMPARGS));
        if (DecompArgs)
        {
            DecompArgs->fileattribs = presp->fileattribs;
            DecompArgs->ft_create = presp->ft_create;
            DecompArgs->ft_lastaccess = presp->ft_lastaccess;
            DecompArgs->ft_lastwrite =  presp->ft_lastwrite;
            DecompArgs->ulSum =  presp->ulSum;
            DecompArgs->lCode =  presp->lCode;
            DecompArgs->bSumValid =  presp->bSumValid;
            strcpy(DecompArgs->Temp, TempPath);
            strcpy(DecompArgs->Real, RealPath);
            strcpy(DecompArgs->Remote, presp->szFile);
            L_hThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)Decompress, DecompArgs, 0, &ThreadId);
            List_AddLast( Decomps, (LPVOID)&L_hThread, sizeof(L_hThread));
        }
        else
        {
            // shut up Prefix.  no idea what is the right thing to do here,
            // without spending a lot of time to understand how this whole
            // add-on to windiff works.  in some other product this would be
            // worth investing time on.  but not this add-on to windiff that
            // most people don't even know exists, much less how to set up
            // the server it needs to talk to.
        }
} /* SpawnDecompress */

/* Decompress da->Temp into da->Real
   Free the storage da->DECOMPARGS
   Return 1 (TRUE) if it worked
   Return 0 (FALSE) if it didn't work
   This return code acts as the exit code for the thread.
*/

int Decompress(DECOMPARGS * da)
{

        OFSTRUCT os;
        int fh1, fh2;
        BOOL bOK = TRUE;

        /* Decompress the file to the original name
           If da->lCode is one of SSRESP_NOTEMPPATH
                                  SSRESP_COMPRESSEXCEPT
                                  SSRESP_NOREADCOMP
                                  SSRESP_NOCOMPRESS
           Then the file is just copied, not decompressed.

        */
        {       char msg[2*MAX_PATH+50];
                wsprintf( msg, "Decompressing %s => %s\n"
                        , da->Temp, da->Real);
                Trace_Fil(msg);
                wsprintf( msg, "%d done. Getting %s\n"
                        , nGoodFiles, da->Real);
                SetNames(msg);
        }

        if (  da->lCode==SSRESP_NOTEMPPATH
           || da->lCode==SSRESP_COMPRESSEXCEPT
           || da->lCode==SSRESP_NOREADCOMP
           || da->lCode==SSRESP_NOCOMPRESS
           ) {     /* Just copy, don't compress */
                bOK = CopyFile(da->Temp, da->Real, FALSE);
                if (bOK) Trace_Fil("Uncompressed file copied.\n");
                else Trace_Fil("Uncompressed file failed final copy.\n");
        } else {

            fh1 = LZOpenFile(da->Temp, &os, OF_READ|OF_SHARE_DENY_WRITE);
            if (fh1 == -1) {
                    char msg[500];
                    wsprintf( msg, "Packed temp file %s did not open for decompression into %s. Error code %d"
                            , da->Temp, da->Real, GetLastError()
                            );
                    TRACE_ERROR(msg, FALSE);
                    bOK = FALSE;
            } else {


                fh2 = LZOpenFile(da->Real, &os, OF_CREATE|OF_READWRITE|OF_SHARE_DENY_NONE);
                if (fh2 == -1) {
                    char msg[MAX_PATH];

                    Trace_Fil("Could not create target file\n");

                    wsprintf(msg, "Could not create target file %s", da->Real);

                    if (!TRACE_ERROR(msg, TRUE)) {

                        /* user hit cancel - abort operation */
                        bAbort = TRUE;

                    }
                    bOK = FALSE;
                    LZClose(fh1);

                } else {
                    long retcode;
                    retcode = LZCopy(fh1, fh2);
                    if (retcode<0){
                        bOK = FALSE;
                    }

                    LZClose(fh1);
                    LZClose(fh2);
                }
            }
        }

        /* May want to keep it for debugging...? */
#ifndef LAURIE
        DeleteFile(da->Temp);
#endif //LAURIE

        if (bOK) {
                HANDLE hfile;
                BOOL bChecked;
                LONG err;
                /*
                * check the file's checksum (end-to-end check) and size and
                * set file attributes and times according to the attribs
                * struct we received. Remember to set file times BEFORE
                * setting attributes in case the attributes include read-only!
                */

                bChecked = ( da->ulSum == checksum_file(da->Real, &err) );
                if (err!=0) bChecked = FALSE;

                if (!bChecked){
                        if (!bAbort){
                                char msg[200];
                                if (err>0) {
                                    /* negative error codes are internal errors,
                                       positive ones are meaningful to outsiders.
                                    */
                                    wsprintf( msg
                                            , "error %ld, Will retry file %s."
                                            , err
                                            , da->Real
                                            );
                                }
                                else {
#if defined(LAURIE)
                                    wsprintf( msg
                                            , "Checksum error %ld on file %s. Sum should be %8x, temp file %s"
                                            , err
                                            , da->Real
                                            , da->ulSum
                                            , da->Temp
                                            );
                                    TRACE_ERROR(msg, FALSE);
#endif
                                    wsprintf( msg
                                            , "Checksum error.  Will retry file %s."
                                            , da->Real
                                            );
                                }
                                SetNames(msg);
                                List_AddLast(Retries, (LPVOID)da, (UINT)sizeof(DECOMPARGS));
                                return(FALSE);   /* Hm - kind of a lie correct later */
                        }
                        else return FALSE;
                }

                hfile = CreateFile(da->Real, GENERIC_WRITE, 0, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


                if (!SetFileTime(hfile, &(da->ft_create),
                                  &(da->ft_lastaccess),
                                  &(da->ft_lastwrite)) ) {
                       TRACE_ERROR("could not set file times", FALSE);
                }

                CloseHandle(hfile);

                if (!SetFileAttributes(da->Real, da->fileattribs)) {
                        TRACE_ERROR("could not set attributes", FALSE);
                }
        }
        GlobalFree((HGLOBAL)da);
        return bOK;
} /* Decompress */



/* safe strcmp of PTR against array, protecting against NULL PTR
   b is an array and had better NOT be null
   a NULL pointer is taken to match an empty arrray.
*/
int safecmp(LPSTR a, LPSTR b)
{       if (a==NULL)
                return (b[0]!='\0'); /* returns 0 if ==, else 1 */
        else return strcmp(a,b);
} /* safecmp */


/*
 * request to copy a file.  Sends the request on (static global) hpipe
 *
 * returns TRUE if it succeeded or FALSE if the connection was lost
 * TRUE only means the REQUEST was sent.
 */
BOOL
ss_bulkcopy(PSTR server, PSTR serverpath, PSTR clientpath, PSTR uncname,
                PSTR password)
{       char buffer[MAX_PATH*2] = {0};
        LPSTR pstr;

        ++nFiles;
        Trace_Fil("ss_bulkcopy\n");
        if (safecmp(server,Server)) {
                char msg[400];
                wsprintf( msg, "Protocol error.  Server change was %s is %s"
                        , Server, (server?server:"NULL")
                        );
                Trace_Fil(msg);
                TRACE_ERROR("Protocol error.  Server change", FALSE);
                return FALSE;
        }
        if (safecmp(uncname,UNCName)) {
                char msg[400];
                wsprintf( msg, "Protocol error.  UNCName change was %s is %s"
                        , UNCName, (uncname?uncname:"NULL")
                        );
                Trace_Fil(msg);
                TRACE_ERROR("Protocol error.  UNCName change", FALSE);
                return FALSE;
        }
        if (safecmp(password,Password)) {
                char msg[400];
                wsprintf( msg, "Protocol error.  Password change was %s is %s"
                        , Password, (password?password:"NULL")
                        );
                Trace_Fil(msg);
                TRACE_ERROR("Protocol error.  Password change", FALSE);
                return FALSE;
        }

        /* pack local and remote paths into buffer */
        _snprintf(buffer, sizeof(buffer)-1, "%s%c%s", serverpath, 0, clientpath);

        return ss_sendrequest( hpipe
                             , SSREQ_NEXTFILE
                             , buffer
                             , strlen(serverpath)+strlen(clientpath)+2
                             , 0
                             );
} /* ss_bulkcopy */

/* Remove from the decompressers list those that have finished.
   Don't hang about waiting.  Leave the rest on the list
   Updating nGoodFiles and/or nBadFiles for those that finished.
*/
void PurgeDecomps(LIST Decs)
{
        HANDLE * phThread, * Temp;
        DWORD ExitCode;

        phThread = List_First(Decs);
        while (phThread!=NULL) {
                if (GetExitCodeThread(*phThread, &ExitCode)) {
                        Temp = phThread;
                        phThread = List_Next((LPVOID)phThread);
                        if (ExitCode==1) {
                                ++nGoodFiles;
                                CloseHandle(*Temp);
                                Trace_Fil("Purged a good decomp\n");
                                List_Delete((LPVOID)Temp);
                        }
                        else if(ExitCode==0) {
                                ++nBadFiles;
                                CloseHandle(*Temp);
                                Trace_Fil("Purged a bad decomp\n");
                                List_Delete((LPVOID)Temp);
                        }
                        else /* still active? */ ;
                }
        } /* traverse */
} /* PurgeDecomps */


/* WAIT for each of the hThreads on Decomps and report its status by
   updating nGoodFiles and/or nBadFiles
   This thread must be run on the receive thread or else after
   the receive thread has terminated (or else we need a critical section).
*/
void WaitForDecomps(LIST Decs)
{
        HANDLE * phThread;
        DWORD ExitCode;

        List_TRAVERSE(Decs, phThread) {
                if (bAbort) return;
                Trace_Fil("Waiting for a decomp...");
                for (; ; ){
                        DWORD rc;
                        rc = WaitForSingleObject(*phThread, 5000);
                        if (rc==0) break;   /* timeout complete */
                        if (bAbort) {
                                // This WILL leave a garbage thread and a temp file lying around!!!???
                                Trace_Fil("Aborting wait for decomp.");
                                return;
                        }
                }
                Trace_Fil(" Done waiting.\n");
                GetExitCodeThread(*phThread, &ExitCode);
                if (ExitCode==1)
                        ++nGoodFiles;
                else
                        ++nBadFiles;
                CloseHandle(*phThread);
        } /* traverse */

        Trace_Fil("All decompression finished.");
        List_Destroy(&Decs);
} /* WaitForDecomps */


static void Retry(LIST Rets)
{
        DECOMPARGS * da;

        if (List_IsEmpty(Rets)) return;

        List_TRAVERSE(Rets, da) {
             if (ss_copy_reliable( Server, da->Remote, da->Real, UNCName, Password))
             {   /* correct the lie we told when Decompress returned FALSE */
                 ++nGoodFiles; --nBadFiles;
             }
        }
        List_Destroy(&Rets);
        SetNames("All errors recovered");
}/* Retry */


/* end of bulk copy.  Tidy everything up */
int ss_endcopy(void)
{
        Trace_Fil("ss_endcopy\n");
        ss_sendrequest( hpipe, SSREQ_ENDFILES, "", 1, 0);
        /* wait for receiving thread to complete (could be long) */
        for (; ; ){
                DWORD rc;
                rc = WaitForSingleObject( hThread, 5000);
                if (rc==0) break;   /* thread complete */
                if (bAbort) {
                        if (hpData != (MAYBESOCKETTYPE)INVALID_HANDLE_VALUE) {
                                CLOSEHANDLE(hpData);
                                hpData = (MAYBESOCKETTYPE)INVALID_HANDLE_VALUE;
                        }
                        break;
                }
        }

        // don't close the connection until we've finished, otherwise
        // someone might think it's ok to reboot the server
        ss_sendrequest( hpipe, SSREQ_END, "", 1, 0);
        CloseHandle(hpipe);
        hpipe = INVALID_HANDLE_VALUE;

        WaitForDecomps(Decomps);
        Decomps = NULL;
        SetNames(NULL);
        Retry(Retries);
        Retries = NULL;

        BulkCopy = FALSE;
        if (nBadFiles+nGoodFiles > nFiles) return -99999; /* !!? */
        if (nBadFiles+nGoodFiles < nFiles) nBadFiles = nFiles-nGoodFiles;

        if (nBadFiles>0)
                return -nBadFiles;
        else    return nGoodFiles;

} /* ss_endcopy */


#if 0
/* A SSREQ_FILES has been sent and possibly one or more files,
   but we have changed our minds.  We try to send an Abort request.
*/
int ss_abortcopy(void)
{
        Trace_Fil("ss_abortcopy\n");
        ss_sendrequest( hpipe, SSREQ_ABORT, "", 1);

        {       DWORD code;
                TerminateThread(hThread, &code);  /* storage leak */
                hThread = INVALID_HANDLE_VALUE;
        }

        Server[0] = '\0';

        CloseHandle(hpipe);
        hpipe = INVALID_HANDLE_VALUE;

        CLOSEHANDLE(hpData);
        hpData = INVALID_HANDLE_VALUE;

        if (Decomps!=NULL){
                HANDLE * phThread;
                List_TRAVERSE(Decomps, phThread){
                        DWORD code;
                        TerminateThread(*phThread, &code);  /* storage leak */
                }
        }
        Decomps = NULL;

        BulkCopy = FALSE;
} /* ss_abortcopy */
#endif // 0


/*
 * reliably copy a file (repeat (upto N times) until checksums match)
 *
 * returns TRUE if it succeeded or FALSE if the connection was lost
 */
BOOL
ss_copy_reliable(PSTR server, PSTR remotepath, PSTR localpath, PSTR uncname,
                PSTR password)
{
        ULONG sum_local, sum_remote;
        int retry;
        SSNEWRESP resp;
        HANDLE hpCopy = INVALID_HANDLE_VALUE;    /* N.B. NOT the static global pipe! */
        LONG err;

        FILETIME ft;
        LONG sz;
        DWORD attr;


        Trace_Fil("ss_copy_reliable\n");
//      if (BulkCopy) {
//              TRACE_ERROR("Cannot do simple copy as bulk copy is in progress", FALSE);
//              return FALSE;
//      }

        for (retry = 0; retry < 10; retry++) {

                if (bAbort) return FALSE;        /* abort requested from WINDIFF */

                if (hpCopy!=INVALID_HANDLE_VALUE) {
                        CloseHandle(hpCopy);
                        hpCopy = INVALID_HANDLE_VALUE;
                }

                {       char pipename[400];
                        InitPipeName(pipename, server, NPNAME);
                        hpCopy = ConnectPipe(pipename);
                }

                if (hpCopy == INVALID_HANDLE_VALUE) {
                        /* next retry in two seconds */
                        Trace_Stat("connect failed - retrying");
                        Sleep(1000);
                        continue;
                }

                if ((uncname != NULL) && (uncname[0]!='\0')
                &&  (password != NULL) && (password[0]!='\0')) {

                        /* send the password request */
                        if (!ss_sendunc(hpCopy, password, uncname)) {
                                TRACE_ERROR("Server connection lost", FALSE);
                                continue;
                        }

                        /* wait for password response */
                        if (0>=ss_getresponse(hpCopy, &resp)) {
                                TRACE_ERROR("Server connection lost", FALSE);
                                continue;
                        }
                        if (resp.lCode != SSRESP_END) {
                                TRACE_ERROR("Password attempt failed", FALSE);
                                return(FALSE);
                        }
                }

                /* try to copy the file */
                ss_copy_file(hpCopy, remotepath, localpath);

                /* whether or not he thinks he failed, we should look
                 * to see if the file is really there.
                 */

                sum_local = checksum_file(localpath, &err);
                if (err!=0) continue;

                sum_remote = 0;
                if (!ss_checksum_remote(hpCopy, remotepath, &sum_remote, &ft, &sz, &attr)) {
                        /* no remote checksum - better retry */
                        if (!TRACE_ERROR("remote checksum failed - retry?", TRUE)) {
                            CloseHandle(hpCopy);
                            return(FALSE);
                        }
                        continue;
                }

                if (sum_local == sum_remote) {
                        /* copy succeeded */
                        ss_terminate(hpCopy);
                        return(TRUE);
                }
                TRACE_ERROR("files different after apparently successful copy!!?", FALSE);

        } /*retry loop */

        /* too many retries */
        CloseHandle(hpCopy);
        return(FALSE);
} /* ss_copy_reliable */


/*
 * copy one file using checksum server
 *
 * send a SSREQ_FILE for the file, and then loop reading
 * blocks until we get an error (sequence count is wrong or -1),
 * or the end of file (0-length block)
 *
 * File sent may be compressed. We write it to a temporary file, and
 * then decompress it using LZCopy. This will work even if the
 * file was sent uncompressed (eg because compress.exe could not be
 * executed on the server).
 */
BOOL
ss_copy_file(HANDLE hpipe, PSTR remotepath, PSTR localpath)
{
        HANDLE hfile;
        int sequence;
        ULONG size;
        SSPACKET packet;
        BOOL bOK;
        char szTempname[MAX_PATH];
        OFSTRUCT os;
        int fh1, fh2;
        PSSATTRIBS attribs;

        Trace_Fil("ss_copy_file\n");
        /* create a temporary name */
        *szTempname = 0;
        GetTempPath(sizeof(szTempname), szTempname);
        GetTempFileName(szTempname, "ssc", 0, szTempname);

        /* try to create the temp file */
        hfile = CreateFile(szTempname,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (hfile == INVALID_HANDLE_VALUE) {
                TRACE_ERROR("ss_copy: could not create temp file", FALSE);
                return(FALSE);
        }

        if (!ss_sendrequest(hpipe, SSREQ_FILE, remotepath, strlen(remotepath)+1, 0)){
                CloseHandle(hfile);
                return(FALSE);
        }

        for (sequence = 0; ; sequence++) {

                bOK = 0 <= ss_getblock(hpipe, (PSTR) &packet, sizeof(packet));

                if (!bOK || (sequence != packet.lSequence)) {
                        /* error or out of sequence */
                        TRACE_ERROR("packet error", FALSE);
                        CloseHandle(hfile);
                        DeleteFile(szTempname);
                        return(FALSE);
                }

                if (packet.ulSize == 0) {
                        /*
                         * this is the last block (end of file).
                         *
                         * the data field for this block contains a
                         * SSATTRIBS struct that we can use to set the
                         * file times and attributes (after decompression).
                         */
                        attribs = (PSSATTRIBS) packet.Data;

                        break;
                }

                /* check the block checksums */
                if (  packet.ulSum!=0 ) {
                        TRACE_ERROR("packet checksum error", FALSE);
                        CloseHandle(hfile);
                        DeleteFile(szTempname);
                        return(FALSE);
                }

                bOK = WriteFile(hfile, packet.Data, packet.ulSize, &size, NULL);
                if (!bOK || (size != packet.ulSize)) {
                        CloseHandle(hfile);
                        DeleteFile(szTempname);
                        return(FALSE);
                }
        }
        CloseHandle(hfile);

        /* decompress the file to the original name */
        fh1 = LZOpenFile(szTempname, &os, OF_READ|OF_SHARE_DENY_WRITE);
        if (fh1 < 0) {
                TRACE_ERROR("Failed to open file for decompression", FALSE);
        } else {


                fh2 = LZOpenFile(localpath, &os, OF_CREATE|OF_READWRITE|OF_SHARE_DENY_NONE);
                if (fh2 < 0) {
                        char msg[MAX_PATH+40];

                        wsprintf(msg, "Could not create target file %s", localpath);

                        if (!TRACE_ERROR(msg, TRUE)) {
                            bAbort = TRUE;
                        }

                        return(FALSE);

                } else {
                        LZCopy(fh1, fh2);
                        LZClose(fh1);
                        LZClose(fh2);
                }
        }

        DeleteFile(szTempname);

        /*
         * now set file attributes and times according to the attribs
         * struct we received. Remember to set file times BEFORE
         * setting attributes in case the attributes include read-only!
         */
        hfile = CreateFile(localpath, GENERIC_WRITE, 0, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (!SetFileTime(hfile, &attribs->ft_create,
                           &attribs->ft_lastaccess,
                           &attribs->ft_lastwrite) ) {
                TRACE_ERROR("could not set file times", FALSE);
        }

        CloseHandle(hfile);

        if (!SetFileAttributes(localpath, attribs->fileattribs)) {
                TRACE_ERROR("could not set attributes", FALSE);
        }


        return(TRUE);

} /* ss_copy_file */


/* produce a checksum of a block of data.
 *
 * This algorithm is compute bound.  It's probably overkill anyway and for
 * version 1 is not used.  It must match the one in server.
 *
 * Generate checksum by the formula
 *      checksum = SUM( rnd(i)*(1+byte[i]) )
 * where byte[i] is the i-th byte in the file, counting from 1
 *       rnd(x) is a pseudo-random number generated from the seed x.
 *
 * Adding 1 to byte ensures that all null bytes contribute, rather than
 * being ignored. Multiplying each such byte by a pseudo-random
 * function of its position ensures that "anagrams" of each other come
 * to different sums. The pseudorandom function chosen is successive
 * powers of 1664525 modulo 2**32. 1664525 is a magic number taken
 * from Donald Knuth's "The Art Of Computer Programming"
 */

ULONG
ss_checksum_block(PSTR block, int size)
{
        unsigned long lCheckSum = 0;            /* grows into the checksum */
        const unsigned long lSeed = 1664525;    /* seed for random Knuth */
        unsigned long lRand = 1;                /* seed**n */
        unsigned long lIndex = 1;               /* byte number in block */
        unsigned Byte;                          /* next byte to process in buffer */
        unsigned length;                        /* unsigned copy of size */

        Trace_Fil("ss_checksum_block\n");
        length = size;
        for (Byte = 0; Byte < length ;++Byte, ++lIndex) {

                lRand = lRand*lSeed;
                lCheckSum += lIndex*(1+block[Byte])*lRand;
        }

        return(lCheckSum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\client\sum.c ===
/*
 * basic client for sumserve remote checksum server
 *
 *
 * sends a request over a named pipe for a list of files and checksums,
 * and printf's the returned list
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "..\server\sumserve.h"
#include "ssclient.h"


extern int __argc;
extern char ** __argv;


/* program entry point
 *
 * creates the named pipe, and loops waiting for client connections and
 * calling ss_handleclient for each connection. only exits when told
 * to by a client.
 *
 * currently permits only one client connection at once.
 */
int PASCAL
WinMain (HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpszCmdParam,
 		int nCmdShow)
{
	HANDLE hpipe;
	SSRESPONSE resp;
	PSTR tag;

	/* we expect two args: the server name, and the pathname */

	if (__argc != 3) {

		printf("usage: client <servername> <pathname>");
		return(1);
	}

 	hpipe = ss_connect(__argv[1]);
	if (hpipe == INVALID_HANDLE_VALUE) {
		printf("cannot connect to server %s\n", __argv[1]);
		return(2);
	}

	/* make a packet to send */
	if (!ss_sendrequest(hpipe, SSREQ_SCAN, __argv[2], strlen(__argv[2])+1)) {
		printf("pipe write error %d\n", GetLastError());
		return(3);
	}


	/* loop reading responses */
	for (; ;) {
		
		if (!ss_getresponse(hpipe, &resp)) {
			printf("pipe read error %d\n", GetLastError());
			return(4);
		}
		

		if (resp.lCode == SSRESP_END) {
			printf("-----------------end of list");
			break;
		}
		
		switch(resp.lCode) {
		case SSRESP_ERROR:
			tag = "ERROR";	
			printf("%s\t\t\t%s\n", tag, resp.szFile);
			break;

		case SSRESP_DIR:
			tag = "dir";	
			printf("%s\t\t\t%s\n", tag, resp.szFile);
			break;

		case SSRESP_FILE:
			tag = "file";
			printf("%s\t%08lx\t%d bytes\t%s\n", tag, resp.ulSum, resp.ulSize, resp.szFile);
			break;
		}
	}
	ss_terminate(hpipe);
	return(0);

}


/* error output functions - called by the ssclient library functions
 *
 * defined here so the library can be called from cmdline and windows
 * programs.
 *
 */
BOOL
Trace_Error(LPSTR str, BOOL fCancel)
{
	printf("%s\n", str);
	return(TRUE);
}


/*
 * status update messages
 */
void
Trace_Status(LPSTR str)
{
	printf("%s\n", str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\gbit.c ===
/*
 * bitmap allocation routines.
 *
 * utility routines to manage a bit-mapped free list, and find
 * free sections
 */

#include <precomp.h>

#ifdef REWRITE
Timings on windiff indicated that not much time was spent here, so it wasn't
worth the rewrite. BUT - could do much better.  To find the first bit in
a dword mask it with FFFF0000 to see which half the bit is in and then
go on by five binary chops.  (You need to wory about the byte order and bit order
of the bitmap - and I haven't - but the code is something like
bitnum = 0
if (dw&0xffff0000) {bitnum +=16; dw >>=16}
if (dw&0x0000ff00) {bitnum +=8;  dw >>=8}
if (dw&0x000000f0) {bitnum +=4;  dw >>=4}
if (dw&0x0000000c) {bitnum +=2;  dw >>=2}
if (dw&0x00000002) {bitnum +=1;  dw >>=1}

Forget the "find the biggest section" stuff - change the spec and just
return(a place if we find enough it or fail.
Special case to search more efficiently for sections of up to 32 bits.
(For mamory heap usage this means that we will have one heap that handles
requests from (say) 16 to 512 bytes (16 bytes per bit) and another heap
for requests (say) 513 to 4096 bytes (128 bits per byte) and so on.

In this case create a mask in a dword with the number of bits set that
we are looking for (keep this we might need it again), shift it the
number of bits to correspond to the start bit that we found (it's two
dwords by now as it will likely shift across a dword boundary) and then
just mask to see if all those bits are on i.e. if ((mask & dw)==mask)

Later.  Maybe.
Laurie

#endif //REWRITE


/* routines to manage bitmapped freelists. Each map is an array
 * of unsigned longs where bit 0 of the first long represents
 * block 1
 */

BOOL gbit_set(DWORD FAR * map, long blknr, long nblks, BOOL op_set);

/* initialise a pre-allocated map of ulongs to represent a free
* area of nblks
*/
void APIENTRY
gbit_init(DWORD FAR * map, long nblks)
{
	long i;
	long leftover = nblks % 32;
	long blks = nblks / 32;
	DWORD last = 0;

	for (i=0; i < blks; i++) {
		map[i] = 0xffffffff;
	}
	for (i = 0; i < leftover; i++) {
		last = (last << 1) | 1;
	}
	if(leftover)
		map[blks] = last;
}

/* mark a region starting at blknr for nblks, as busy (ie 0) */
BOOL APIENTRY
gbit_alloc(DWORD FAR * map, long blknr, long nblks)
{
	return(gbit_set(map, blknr, nblks, FALSE));
}


/* mark region - if op_set, to 1s, otherwise to 0s */
BOOL
gbit_set(DWORD FAR * map, long blknr, long nblks, BOOL op_set)
{
	long first;
	long last;
	long fullwords;
	long startbit, startword;
	long i;
	DWORD dword = 0;

	blknr--;
	first = min(32 - (blknr % 32), nblks);
	nblks -= first;
	last = nblks % 32;
	fullwords = (nblks - last) / 32;
	
	startword = blknr / 32;
	startbit = blknr % 32;
	for (i = 0; i < first; i++) {
		dword = (dword << 1) | 1;
	}
	dword <<= startbit;
	if (op_set) {
		map[startword] |= dword;
		dword = 0xffffffff;
	} else {
		map[startword] &= ~dword;
		dword = 0;
	}
	startword++;
	for (i = 0; i < fullwords; i++) {
		map[startword+i] = dword;
	}
	startword += fullwords;
	for(i = 0, dword = 0; i < last; i++) {
		dword = (dword << 1) | 1;
	}
	if (last) {
		if (op_set) {
			map[startword] |= dword;
		} else {
			map[startword] &= ~dword;
		}
	}

	return(TRUE);
}

/* mark region of nblks starting at blknr to 0s - ie not busy */
BOOL APIENTRY
gbit_free(DWORD FAR * map, long blknr, long nblks)
{
	return(gbit_set(map, blknr, nblks, TRUE));
}


/* find a free segment (ie contiguous sequence of 1s) of nblks in length.
 * If not found, find longest sequence. Store address of segment in *blknr.
 *
 * Return value is nr of blks in sequence found. Region is *not* marked busy.
 */
long APIENTRY
gbit_findfree(DWORD FAR* map, long nblks, long mapsize, long FAR * blknr)
{
	long curblk, startblk, len, i;
	long startbit, nfull, nlast, nbitsleft;
	DWORD mask;
	long mapblks = (mapsize + 31) / 32;
	long aubegin = 0, aulen = 0;
	long curbit = 0;

	/* main loop looking at segments */
	for (curblk = 0; curblk < mapblks; ) {
loop:
		/* loop finding first 1 */
		for (; curblk < mapblks; curblk++, curbit = 0) {
			if (map[curblk] > 0) {
				break;
			}
		}
		if (curblk >= mapblks)
			break;
		
		/* find first 1 in this long */
		startblk = curblk;
		for (mask = 1, i = 0; i < curbit; i++) {
			mask <<= 1;
		}
		for(; curbit < 32; curbit++, mask <<= 1) {
			if (map[curblk] & mask) {
				break;
			}
		}
		if (curbit >= 32) {
			/* abandon this word - start again with next word */
			curblk++;
			curbit = 0;
			goto loop;
		}

		/* we've now found a 1 - calc remaining
		 * bits in this word, complete words etc required.
		 */
		startbit = curbit;
		nbitsleft = min( (32 - curbit), nblks);
		nfull = (nblks - nbitsleft) / 32;
		nlast = (nblks - nbitsleft) % 32;

		/* check for required sequence within this word */

		for (i = 0; i < nbitsleft; i++, curbit++, mask <<= 1) {
			if ((map[curblk] & mask) == 0) {
				/* abandon and start again - start
				 * next pass at curbit in same word
				 */
				/* store free region if longest yet */
				if (i > aulen) {
					aulen = i;
					aubegin = curblk * 32 + startbit +1;
				}
				goto loop;
			}
		}
		
		/* check for nfull full words */
		for (curblk++; curblk <= startblk + nfull; curblk++) {
			if (curblk >= mapblks) {
				/* end of map - abandon here and exit at top
				 * of loop
				 */
				len = nbitsleft +
					((curblk - (startblk + 1)) * 32);
				if (len > aulen) {
					aubegin = startblk * 32 + startbit + 1;
					aulen = len;
				}
				goto loop;
			}
			if (map[curblk] != 0xffffffff) {
				/* not a full word - start again at this bit */
				len = 0;
				curbit = 0;
				for (mask = 1; mask & map[curblk]; mask <<= 1) {
					len++;
					curbit++;
				}
				len += nbitsleft +
					(curblk - (startblk+ 1)) * 32;
				if (len > aulen) {
					aulen = len;
					aubegin = startblk * 32 + startbit + 1;
				}
				/* continue with current blk, bit */
				goto loop;
			}
		}

		/* left-over bits required in last word */
		mask = 1;
		for (curbit = 0; curbit < nlast;  curbit++, mask <<= 1) {
			if ((map[curblk] & mask) == 0) {
				len = nbitsleft + (nfull * 32);
				len += curbit;
				if (len > aulen) {
					aulen = len;
					aubegin = startblk * 32 + startbit + 1;
				}
				goto loop;
			}
		}
		/* ok - found a block big enough! */
		aubegin = startblk * 32 + startbit + 1;
		*blknr = aubegin;
		return(nblks);
	}

	/* end of map - return longest sequence */
	*blknr = aubegin;
	return(aulen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\client\sumcopy.c ===
/*
 * basic client for sumserve remote checksum server
 *
 *
 * sends a request over a named pipe for a list of files and checksums,
 * and printf's the returned list
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "..\server\sumserve.h"
#include "ssclient.h"


extern int __argc;
extern char ** __argv;


/* program entry point
 *
 */
int PASCAL
WinMain (HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpszCmdParam,
 		int nCmdShow)
{

	/* we expect two args: the server name, and the pathname */

	if (__argc != 4) {

		printf("usage: client <servername> <remotefile> <localfile>");
		return(1);
	}

	if (!ss_copy_reliable(__argv[1], __argv[2], __argv[3], NULL, NULL)) {
		printf("copy failed\n");
		return(1);
	} else {

		printf("copy succeeded\n");
		return(0);
	}


}


/* error output functions - called by the ssclient library functions
 *
 * defined here so the library can be called from cmdline and windows
 * programs.
 *
 */
BOOL
Trace_Error(LPSTR str, fCancel)
{
	printf("%s\n", str);

	return(TRUE);
}


/*
 * output status messages
 */
void
Trace_Status(LPSTR str)
{
	printf("%s\n", str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\gutils.c ===
#include <precomp.h>
#include "gutilsrc.h"

/* dll global data */
HANDLE hLibInst;
extern void gtab_init(void);
extern BOOL StatusInit(HANDLE);

#ifdef WIN32
BOOL WINAPI LibMain(HANDLE hInstance, DWORD dwReason, LPVOID reserved)
{
        if (dwReason == DLL_PROCESS_ATTACH) {
                hLibInst = hInstance;
                gtab_init();
                StatusInit(hLibInst);
        }
        return(TRUE);
}

#else

WORD wLibDataSeg;


BOOL FAR PASCAL
LibMain(HANDLE hInstance, WORD   wDataSeg, WORD   cbHeap, LPSTR  lpszCmdLine)
{
	hLibInst = hInstance;
	wLibDataSeg = wDataSeg;

	gtab_init();
	StatusInit(hLibInst);
	return(TRUE);

}
#endif

/* needed for win16 - but does no harm in NT */
int FAR PASCAL
WEP (int bSystemExit)
{
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\gdate.c ===
/*
 * Gutils - 
 *
 * - date conversion functions
 *
 * Geraint, 22 May, 28 Oct 91.
 */

#include <precomp.h>

BOOL gdi_isleap(LONG year);

/*---static data--------------------------------------------*/

int monthdays[] = {
	31,
	28,
	31,
	30,
	31,
	30,
	31,
	31,
	30,
	31,
	30,
	31
};

/*--public functions--------------------------------------*/

void APIENTRY
gdate_daytodmy(LONG days, int FAR* yrp, int FAR* monthp, int FAR* dayp)
{
	int years;
	int nleaps;
	int month;
	int mdays;

	/* get number of completed years and calc leap days */
	years = (int) (days / 365);
	days = days % 365;
	nleaps = (years / 4) - (years / 100) + (years / 400);
	while (nleaps > days) {
		days += 365;
		years--;
		nleaps = (years / 4) - (years / 100) + (years / 400);
	}
	days -= nleaps;

	/* add one year for current (non-complete) year */
	years++;


	/* current month */
	for (month = 0; month < 12; month++) {
		mdays = monthdays[month];
		if (gdi_isleap(years) && (month == 1)) {
			mdays++;
		}
		if (days == mdays) {
			days = 0;
			month++;
			break;
		} else if (days < mdays) {
			break;
		} else {
			days -= mdays;
		}
	}
	/* conv month from 0-11 to 1-12 */
	if (monthp != NULL) {
		*monthp = month+1;
	}
	if (dayp != NULL) {
		*dayp = (int) days + 1;
	}
	if (yrp != NULL) {
		*yrp = years;
	}
}


LONG APIENTRY
gdate_dmytoday(int yr, int month, int day)
{
	int nleaps;
	int i;
	long ndays;

	/* exclude the current year */
	yr--;
	nleaps = (yr / 4) - (yr / 100) + (yr / 400);

	/* in any given year, day 0 is jan1 */
	month--;
	day--;
	ndays = 0;
	for (i = 0; i < month ; i++) {
		ndays += monthdays[i];
		if (gdi_isleap(yr+1) && (i == 1)) {
			ndays++;
		}
	}
	ndays = ndays + day + nleaps + (yr * 365L);
	return(ndays);
}

int APIENTRY
gdate_monthdays(int month, int year)
{
	int ndays;

	ndays = monthdays[month - 1];
	if (gdi_isleap(year) && (month == 2)) {
		ndays++;
	}
	return(ndays);
}

int APIENTRY
gdate_weekday(long daynr)
{
	return((int) ((daynr + 1) % 7));
}

/* internal functions-----------------------------------------*/

BOOL
gdi_isleap(LONG year)
{
	if ( ((year % 4) == 0) &&
		(((year % 100) != 0) ||
		((year % 400) == 0))) {
			return TRUE;
	} else {
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\gfile.c ===
/*
 * File Open/Create dialogs
 *
 */

/*
 * these dialog functions exist because they were written and
 * used before the commmon dialogs existed.
 *
 * they have now been reduced to just calls to the common file dialog
 * functions
 */



/*---includes-----------------------------------------------------------*/
#include <precomp.h>
#include "gutilsrc.h"

/*--functions----------------------------------------------------------*/

/*
 * gfile_open
 *     	dialog asking the user to select an existing file to open.
 *
 * parameters
 *
 *	prompt - message to user indicating purpose of file
 *		 (to be displayed somewhere in dialog box.
 *
 *	ext    - default file extension if user enters file without
 *		 extension.
 *
 *	spec   - default file spec (eg *.*)
 *
 *	pszFull - buffer where full filename (including path) is returned.
 *
 *	cchMax - size of pszFull buffer.
 *
 *	fn     - buffer where filename (just final element) is returned.
 *
 * returns - true if file selected and exists (tested with OF_EXIST).
 *	     FALSE if dialog cancelled. If user selects a file that we cannot
 *	     open, we complain and restart the dialog.
 *
 *	     if TRUE is returned, the file will have been successfully opened,
 *	     for reading and then closed again.
 */

BOOL 
FAR 
PASCAL
gfile_open(
    HWND hwnd, 
    LPSTR prompt, 
    LPSTR ext, 
    LPSTR spec, 
    LPSTR pszFull, 
    int cchMax, 
    LPSTR fn
    )
{
    OPENFILENAME ofn;
    char achFilters[MAX_PATH];
    char szTmp[MAX_PATH * 2] = {0};
    HANDLE fh;

    if (!pszFull)
    {
        pszFull = szTmp;
        cchMax = sizeof(szTmp) / sizeof(szTmp[0]);
    }

    if (cchMax < 1)
        return FALSE;

    /* build filter-pair buffer to contain one pair - the spec filter,
     * twice (one of the pair should be the filter, the second should be
     * the title of the filter - we don't have a title so we use the
     * filter both times.
     */
    _snprintf(achFilters, (sizeof(achFilters)/sizeof(achFilters[0])) - 1, "%s%c%s", spec, 0, spec);

    /*
     * initialise arguments to dialog proc
     */
    memset(&ofn, 0, sizeof(ofn));
    // GetOpenFileName ang GetSaveFileName unfortunately
    // validate the size of the structue.  So we need to lie to
    // the function if we were built for >=Win2000 and
    // running on an earlier OS
#if (_WIN32_WINNT >= 0x0500) 
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
#else
    ofn.lStructSize = sizeof(OPENFILENAME);
#endif
    ofn.hwndOwner = hwnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = achFilters;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;       // first filter pair in list
    pszFull[0] = '\0';
    ofn.lpstrFile = pszFull;        // we need to get the full path to open
    ofn.nMaxFile = cchMax;
    ofn.lpstrFileTitle = fn;        // return final elem of name here
    ofn.nMaxFileTitle = 13;     // assume just big enough for 8.3+null
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = prompt;        // dialog title is good place for prompt text
    ofn.Flags = OFN_FILEMUSTEXIST |
                OFN_HIDEREADONLY |
                OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = ext;

    /*
     * loop until the user cancels, or selects a file that we can open
     */
    do {
        if (!GetOpenFileName(&ofn)) {
            return(FALSE);
        }

        fh = CreateFile(pszFull, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

        if (fh == INVALID_HANDLE_VALUE) {
            if (MessageBox(NULL, "File Could Not Be Opened", "File Open",
                           MB_OKCANCEL|MB_ICONSTOP) == IDCANCEL) {
                return(FALSE);
            }
        }
    } while (fh == INVALID_HANDLE_VALUE);

    CloseHandle(fh);

    return(TRUE);
}





/*
 * gfile_new
 *     	dialog asking the user to name a file for writing to.
 *
 * parameters
 *
 *	prompt - message to user indicating purpose of file
 *		 (to be displayed somewhere in dialog box.
 *
 *	ext    - default file extension if user enters file without
 *		 extension.
 *
 *	spec   - default file spec (eg *.*)
 *
 *	pszFull - buffer where full filename (including path) is returned.
 *
 *	cchMax - size of pszFull buffer.
 *
 *	fn     - buffer where filename (just final element) is returned.
 *
 * returns - true if file selected and exists (tested with OF_EXIST).
 *	     FALSE if dialog cancelled. If user selects a file that we cannot
 *	     open, we complain and restart the dialog.
 *
 *	     if TRUE is returned, the file will have been successfully
 *	     created and opened for writing and then closed again.
 */

BOOL 
FAR 
PASCAL
gfile_new(
    LPSTR prompt, 
    LPSTR ext, 
    LPSTR spec, 
    LPSTR pszFull, 
    int cchMax, 
    LPSTR fn
    )
{
    OPENFILENAME ofn;
    char achFilters[MAX_PATH] = {0};
    char szTmp[MAX_PATH * 2];
    HANDLE fh;

    if (!pszFull)
    {
        pszFull = szTmp;
        cchMax = sizeof(szTmp) / sizeof(szTmp[0]);
    }

    if (cchMax < 1)
        return FALSE;

    /* build filter-pair buffer to contain one pair - the spec filter,
     * twice (one of the pair should be the filter, the second should be
     * the title of the filter - we don't have a title so we use the
     * filter both times. remember double null at end of list of strings.
     */
    _snprintf(achFilters, (sizeof(achFilters)/sizeof(achFilters[0])) - 1, "%s%c%s", spec, 0, spec);

    /*
     * initialise arguments to dialog proc
     */
    memset(&ofn, 0, sizeof(ofn));
    // GetOpenFileName ang GetSaveFileName unfortunately
    // validate the size of the structue.  So we need to lie to
    // the function if we were built for >=Win2000 and
    // running on an earlier OS
#if (_WIN32_WINNT >= 0x0500) 
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
#else
    ofn.lStructSize = sizeof(OPENFILENAME);
#endif
    ofn.hwndOwner = NULL;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = achFilters;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;       // first filter pair in list
    pszFull[0] = '\0';
    ofn.lpstrFile = pszFull;        // we need to get the full path to open
    ofn.nMaxFile = cchMax;
    ofn.lpstrFileTitle = fn;        // return final elem of name here
    ofn.nMaxFileTitle = 13;     // assume just big enough for 8.3+null
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = prompt;        // dialog title is good place for prompt text
    ofn.Flags = OFN_HIDEREADONLY;
    ofn.lpstrDefExt = ext;

    /*
     * loop until the user cancels, or selects a file that we can create/write
     */
    do {
        if (!GetSaveFileName(&ofn)) {
            return(FALSE);
        }

        fh = CreateFile(pszFull, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);

        if (fh == INVALID_HANDLE_VALUE) {
            if (MessageBox(NULL, "File Could Not Be Created", "File Open",
                           MB_OKCANCEL|MB_ICONSTOP) == IDCANCEL) {
                return(FALSE);
            }
        }
    } while (fh == INVALID_HANDLE_VALUE);

    CloseHandle(fh);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\gmem.c ===
/*
 * memory utility functions
 *
 * global heap functions - allocate and free many small
 * pieces of memory by calling global alloc for large pieces
 * and breaking them up.
 *
 * We get memory allocations in units of ALLOCSIZE and hand out blocks
 * in units of BLKSIZE.  Each allocation has a bitmap (segmap) with one
 * bit per block to track the blocks in the allocation that have been
 * handed out.  All the allocations together are referred to as the heap.
 * The bitmap maps the entire allocation, so the first thing done is to
 * set the bits to say that the header (including the bitmap itself) has
 * already gone.  Each allocation contains a count of the number of free
 * blocks left in it.  This allows us to avoid searching allocations that
 * cannot possibly have enough room.
 *
 * Whenever we hand out some blocks we store the HGLOBAL of that allocation
 * immediately before the bit we hand out.  This means that the HGLOBAL
 * gets stored in a lot of places, but we can always find it from the
 * pointer that the caller has.  (Obviously we add a handle size to the
 * bytes asked for to allow for this).  For historical reasons HGLOBALs are
 * often referred to as seg handles.  The caller knows about the handle to
 * the whole heap.  Only we know about these other handles.
 * All allocations are kept locked.
 *
 * Requests for more than MAXGALLOC bytes are passed on to GlobalAlloc and
 * so have none of this.  Likewise when they are freed.
 *
 * The allocations are chained up so that we can look for free space in all
 * of them - BUT to keep speed
 * 1. we keep track of the number of free blocks in an allocation and
 * only look at the bitmap if it might win.
 * 2. When we fail to find free space and so get a new allocation, we chain
 * it on the front, so we will then normally allocate from this new first block.
 * We only * look further down the chain when the first block fails us.
 *
 * Multithread safe.  An allocation contains a critical section, so
 * multiple simultaneous calls to gmem_get and gmem_free will be
 * protected.
 *
 * gmem_freeall should not be called until all other users have finished
 * with the heap.
 */

#include <precomp.h>

#include "gutilsrc.h"                   /* for string id */
extern HANDLE hLibInst;

/*
 * out-of-memory is not something we regard as normal.
 * - if we cannot allocate memory - we put up an abort-retry-ignore
 * error, and only return from the function if the user selects ignore.
 */

int gmem_panic(void);


/* ensure BLKSIZE is multiple of sizeof(DWORD) */
#define BLKSIZE         16                /* block size in bytes to hand out */
#define ALLOCSIZE       32768             /* allocation size in bytes to get */
#define NBLKS           (ALLOCSIZE / BLKSIZE)            /* blocks per alloc */
#define MAPSIZE         (NBLKS / 8)                /* bytes of bitmap needed */
#define MAPLONGS        (MAPSIZE / sizeof(DWORD)) /* DWORDS of bitmap needed */

/* Macro to convert a request in bytes to a (rounded up) number of blocks */
#define TO_BLKS(x)      (((x) + BLKSIZE - 1) / BLKSIZE)


typedef struct seghdr {
    HANDLE hseg;                       /* The HGLOBAL of this allocation */
    CRITICAL_SECTION critsec;          /* Critsec for this allocation */
    struct seghdr FAR * pnext;         /* Next allocation */
    long nblocks;                      /* num free blocks left in this alloc */
    DWORD segmap[MAPLONGS];            /* The bitmap */
    /* The available storage in an allocation follows immediately */
} SEGHDR, FAR * SEGHDRP;


/* Anything above this size, we alloc directly from global
   This must be smaller than ALLOCSIZE - sizeof(SEGHDR) - sizeof(HANDLE)
*/
#define MAXGALLOC       20000


/*
 * init heap - create first segment.
   Return the locked HGLOBAL of the new, initialised heap or NULL if it fails.
 */
HANDLE APIENTRY
gmem_init(void)
{
    HANDLE hNew;
    SEGHDRP hp;

    /* Try to allocate.  If fails, call gmem_panic.
       If user says IGNORE, return NULL, else go round again.
    */
    do {
        hNew = GlobalAlloc(GHND, ALLOCSIZE);/* moveable and Zero-init */
        if (hNew == NULL) {
            if (gmem_panic() == IDIGNORE) {
                return(NULL);
            }
        }
    } while (hNew == NULL);

    /* Lock it - or return NULL (unexpected) if it won't */
    hp = (SEGHDRP) GlobalLock(hNew);
    if (hp == NULL) {
        GlobalFree(hNew);
        return(NULL);
    }

    hp->hseg = hNew;
    InitializeCriticalSection(&hp->critsec);
    hp->pnext = NULL;
    gbit_init(hp->segmap, NBLKS);
    gbit_alloc(hp->segmap, 1, TO_BLKS(sizeof(SEGHDR)));
    hp->nblocks = NBLKS - TO_BLKS(sizeof(SEGHDR));

    return(hNew);
} /* gmem_init */


LONG gmemTime = 0;  /* time used in musec */
LONG gmemTot = 0;   /* number of calls */

LONG APIENTRY gmem_time(void)
{  return MulDiv(gmemTime, 1, gmemTot);
}

#ifdef TIMING
LPSTR APIENTRY gmem_get_internal(HANDLE hHeap, int len);

LPSTR APIENTRY
gmem_get(HANDLE hHeap, int len)
{
    LPSTR Ret;
    LARGE_INTEGER time1, time2, freq;
    LONG t1, t2;

    QueryPerformanceFrequency(&freq);
    if (gmemTot==0) {
        char msg[80];
        LONG temp = freq.LowPart;
        wsprintf(msg, "QPF gave %d", temp);
        Trace_Error(NULL, msg, FALSE);
    }
    ++gmemTot;
    QueryPerformanceCounter(&time1);
    Ret = gmem_get_internal(hHeap, len);
    QueryPerformanceCounter(&time2);

    t1 = time1.LowPart;
    t2 = time2.LowPart;
    gmemTime += t2-t1;

    return Ret;
}

#else
/* cause gmem_get_internal to actually be the real gmem_get */
    #define gmem_get_internal gmem_get
#endif


/* Return an LPSTR pointing to room for len bytes.  Try allocatng
   initially from hHeap, but reserve the right to get it from elsewhere.
   Return NULL if it fails.
*/
LPSTR APIENTRY
gmem_get_internal(HANDLE hHeap, int len)
{
    SEGHDRP chainp;
    HANDLE hNew;
    SEGHDRP hp;
    LPSTR chp;
    long nblks;
    long start;
    long nfound;

    chp = NULL;   /* eliminate spurious compiler warning - generate worse code. */

    //{   char msg[80];
    //    wsprintf(msg, "gmem_get %d bytes", len);
    //    Trace_File(msg);
    //}

    /* Zero bytes?  Address zero is an adequate place! */
    if (len < 1) {
        return(NULL);
    }

    /* The heap is always locked (in gmem_init).
       Lock it again to get the pointer then we can safely unlock it.
     */
    chainp = (SEGHDRP) GlobalLock(hHeap);
    GlobalUnlock(hHeap);

    /*
     * Too big to be worth allocing from heap? - get from globalalloc.
     */
    if (len > MAXGALLOC) {
        /* Try to allocate.  If fails, call gmem_panic.
           If user says IGNORE, return NULL, else go round again.
        */
        do {
            hNew = GlobalAlloc(GHND, len);
            if (hNew == NULL) {
                if (gmem_panic() == IDIGNORE) {
                    return(NULL);
                }
            }
        } while (hNew == NULL);

        chp = GlobalLock(hNew);
        if (chp == NULL) {
            GlobalFree(hNew);
            return(NULL);
        }

        //{   char msg[80];
        //    wsprintf(msg, " gmem_get direct address ==> %8x", chp);
        //    Trace_File(msg);
        //}
        return(chp);
    }


    /*
     * get critical section during all access to the heap itself
     */
    EnterCriticalSection(&chainp->critsec);

    nblks = TO_BLKS(len + sizeof(HANDLE));

    for (hp = chainp; hp !=NULL; hp = hp->pnext) {
        if (hp->nblocks >= nblks) {
            nfound = gbit_findfree(hp->segmap, nblks,NBLKS, &start);
            if (nfound >= nblks) {
                gbit_alloc(hp->segmap, start, nblks);
                hp->nblocks -= nblks;

                /* convert blocknr to pointer
                 * store seg handle in block
                 * Prepare to return pointer to just after handle.
                 */
                chp = (LPSTR) hp;
                chp = &chp[ (start-1) * BLKSIZE];
                * ( (HANDLE FAR *) chp) = hp->hseg;
                chp += sizeof(HANDLE);

                break;
            }
        }
    }
    if (hp == NULL) {

        // Trace_File("<gmen-get new block>");
        /* Try to allocate.  If fails, call gmem_panic.
           If user says IGNORE, return NULL, else go round again.
        */
        do {
            hNew = GlobalAlloc(GHND, ALLOCSIZE);
            if (hNew == NULL) {
                if (gmem_panic() == IDIGNORE) {
                    LeaveCriticalSection(&chainp->critsec);
                    return(NULL);
                }
            }
        } while (hNew == NULL);

        hp = (SEGHDRP) GlobalLock(hNew);
        if (hp == NULL) {
            LeaveCriticalSection(&chainp->critsec);
            GlobalFree(hNew);
            return(NULL);
        }
        hp->pnext = chainp->pnext;
        hp->hseg = hNew;
        chainp->pnext = hp;
        gbit_init(hp->segmap, NBLKS);
        gbit_alloc(hp->segmap, 1, TO_BLKS(sizeof(SEGHDR)));
        hp->nblocks = NBLKS - TO_BLKS(sizeof(SEGHDR));
        nfound = gbit_findfree(hp->segmap, nblks, NBLKS, &start);
        if (nfound >= nblks) {
            gbit_alloc(hp->segmap, start, nblks);
            hp->nblocks -= nblks;

            /* convert block nr to pointer */
            chp = (LPSTR) hp;
            chp = &chp[ (start-1) * BLKSIZE];
            /* add a handle into the block and skip past */
            * ( (HANDLE FAR *) chp) = hp->hseg;
            chp += sizeof(HANDLE);
        }
    }

    /* ASSERT - by now we MUST have found a block.  chp cannot be garbage.
       This requires that MAXGALLOC is not too large.
    */
    //{   char msg[80];
    //    wsprintf(msg, " gmem_get suballoc address ==> %8x\n", chp);
    //    Trace_File(msg);
    //}


    LeaveCriticalSection(&chainp->critsec);
    memset(chp, 0, len);   /* We ask for ZEROINIT memory, but it could have
                              been already affected by gmem_get; use; gmem_free
                           */
    return(chp);
} /* gmem_get */

void APIENTRY
gmem_free(HANDLE hHeap, LPSTR ptr, int len)
{
    SEGHDRP chainp;
    SEGHDRP hp;
    HANDLE hmem;
    long nblks, blknr;
    LPSTR chp;

    //{   char msg[80];
    //    wsprintf(msg, " gmem_free address ==> %8x, len %d \n", ptr, len);
    //    Trace_File(msg);
    //}

    if (len < 1) {
        return;
    }

    /* In Windiff, things are run on different threads and Exit can result
       in a general cleanup.  It is possible that the creation of stuff is
       in an in-between state at this point.  The dogma is that when we
       allocate a new structure and tie it into a List or whatever that
       will need to be freed later:
       EITHER all pointers within the allocated structure are made NULL
              before it is chained in
       OR the caller of Gmem services undertakes not to try to free any
          garbage pointers that are not yet quite built
       For this reason, if ptr is NULL, we go home peacefully.
    */
    if (ptr==NULL) return;

    /*
     * allocs greater than MAXGALLOC were too big to be worth
     * allocing from the heap - they will have been allocated
     * directly from globalalloc
     */
    if (len > MAXGALLOC) {
        hmem = GlobalHandle( (LPSTR) ptr);
        GlobalUnlock(hmem);
        GlobalFree(hmem);
        return;
    }

    chainp = (SEGHDRP) GlobalLock(hHeap);
    EnterCriticalSection(&chainp->critsec);


    /* just before the ptr we gave the user, is the handle to
     * the block.
     */
    chp = (LPSTR) ptr;
    chp -= sizeof(HANDLE);
    hmem = * ((HANDLE FAR *) chp);
    hp = (SEGHDRP) GlobalLock(hmem);

    nblks = TO_BLKS(len + sizeof(HANDLE));

    /* convert ptr to block nr */
    blknr = TO_BLKS( (unsigned) (chp - (LPSTR) hp) ) + 1;

    gbit_free(hp->segmap, blknr, nblks);
    hp->nblocks += nblks;

    GlobalUnlock(hmem);

    LeaveCriticalSection(&chainp->critsec);
    GlobalUnlock(hHeap);
}

void APIENTRY
gmem_freeall(HANDLE hHeap)
{
    SEGHDRP chainp;
    HANDLE hSeg;

    chainp = (SEGHDRP) GlobalLock(hHeap);
    /* this segment is always locked - so we need to unlock
     * it here as well as below
     */
    GlobalUnlock(hHeap);

    /* finished with the critical section  -
     * caller must ensure that at this point there is no
     * longer any contention
     */
    DeleteCriticalSection(&chainp->critsec);

    while (chainp != NULL) {
        hSeg = chainp->hseg;
        chainp = chainp->pnext;
        GlobalUnlock(hSeg);
        GlobalFree(hSeg);
    }
}

/*
 * a memory allocation attempt has failed. return IDIGNORE to ignore the
 * error and return NULL to the caller, and IDRETRY to retry the allocation
 * attempt.
 */
int
gmem_panic(void)
{
    int code;

    TCHAR szBuff1[MAX_PATH];
    TCHAR szBuff2[MAX_PATH];

    LoadString(hLibInst,
               IDS_MEMORY_ALLOC_FAIL,
               szBuff1,
               sizeof(szBuff1)/sizeof(szBuff1[0]));
    LoadString(hLibInst,
               IDS_OUT_OF_MEMORY,
               szBuff2,
               sizeof(szBuff2)/sizeof(szBuff2[0]));
    code = MessageBox(NULL, szBuff1, szBuff2,
                      MB_ICONSTOP|MB_ABORTRETRYIGNORE);
    if (code == IDABORT) {
        /* abort this whole process */
        ExitProcess(1);
    } else {
        return(code);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\gutilsrc.h ===
#define IDC_LPAGENR   102

#define IDC_LFNAME    201
#define IDC_FNAME     202
#define IDC_PROMPT    203
#define IDC_LFILES    204
#define IDC_LSDIR     205
#define IDC_SDIR      206
#define IDC_LDIRS     207
#define IDC_FILES     208
#define IDC_DIRS      209
#define IDC_OPEN      210
#define IDC_CANCEL    211

#define IDD_GUTILS_LABEL     301
#define IDD_GUTILS_FILE      302

#define IDS_MEMORY_ALLOC_FAIL  401
#define IDS_OUT_OF_MEMORY      402
#define IDS_PAGE_STR           403
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\gutils.h ===
/* standard header for gutils.dll library functions
 * include after windows.h
 */

#define DimensionOf(x) (sizeof(x) / sizeof(x[0]))

/*--------win-16 win-32 porting macros etc ----------------------------*/

/* win32 msg crackers */
#define GET_WM_COMMAND_ID(w, l) (LOWORD(w))
#define GET_WM_COMMAND_CMD(w, l) (HIWORD(w))
#define GET_WM_COMMAND_HWND(w, l) (l)
#define GET_SCROLL_OPCODE(w, l)     (LOWORD(w))
#define GET_SCROLL_POS(w, l)        (HIWORD(w))

/* use of WNDPROC and FARPROC don't match up in definitions of
 * Win 3.1 functions vs NT functions. WINPROCTYPE matches WNDPROC
 * in NT and FARPROC in Win 3.1 so there are no warnings in either.
 * Places that use FARPROC in both APIs continue to use FARPROC.
 */
#define WINPROCTYPE     WNDPROC
// #define DLGPROC              WNDPROC  Doesn't wash on MIPS!!

/* ------- memory allocator ------------------------------------------*/

/* global heap functions - allocate and free many small
 * pieces of memory by calling global alloc for large pieces -
 * avoids using too many selectors
 *
 * DOGMA:
 * If you go running things on different threads and then try to EXIT
 * and hence gmem_free everything on one thread while still allocating
 * and hooking things up on another, things can get a little out of hand!
 * In particular, you may traverse a structure and hence try to FREE
 * a sub-structure to which there is a pointer, but which itself is not yet
 * allocated!
 *
 * The dogma is that when you allocate a new structure and tie it into a List
 * or whatever
 * EITHER all pointers within the allocated structure are made NULL
 *        before it is chained in
 * OR the caller of Gmem services undertakes not to try to free any
 *    garbage pointers that are not yet quite built.
 * It is SAFE to attempt to gmem_free a NULL pointer.  It's a no-op.
 * Note that List_NewXxxx(...) zeros the storage before chaining it in.
 * Note that List_AddXxxx(...) obviously doesn't!
 */
HANDLE APIENTRY gmem_init(void);
LPSTR APIENTRY gmem_get(HANDLE hHeap, int len);
void APIENTRY gmem_free(HANDLE hHeap, LPSTR ptr, int len);
void APIENTRY gmem_freeall(HANDLE hHeap);


/* return total time consumed doing gmem_get */
LONG APIENTRY gmem_time(void);

/* ---- file open/save common dialogs ---------------------------*/

/*
 * these functions now rely on to calls to the common dialog libraries.
 *
 * parameters:
 *      prompt - user prompt text (eg for dialog title)
 *      ext    - default extension (eg ".txt")
 *      spec   - default file spec (eg "*.*")
 *      pszFull - full filename will be copied here.
 *      cchMax - size of pszFull buffer.
 *      fn     - last component of file name will be copied here.
 * returns - TRUE if user selected a file that could be opened for
 *           reading (gfile_open) or created and opened for writing (gfile_new)
 *           FALSE if user canceled. if user selects a file that cannot be
 *           opened, a message box is put up and the dialog re-shown.
 */
BOOL APIENTRY gfile_open(HWND hwnd, LPSTR prompt, LPSTR ext, LPSTR spec,
                         LPSTR pszFull, int cchMax, LPSTR fn);
BOOL APIENTRY gfile_new(LPSTR prompt, LPSTR ext, LPSTR spec,
                        LPSTR pszFull, int cchMax, LPSTR fn);


/* --------- date conversion functions    -----------------------*/
/* days (which is actually days measured from a notional Jan 1st 0000)
   is a convenient way to store the date in a single LONG.  Use
   dmytoday to generate the LONG, use daytodmy to convert back
*/
void APIENTRY gdate_daytodmy(LONG days,
                             int FAR* yrp, int FAR* monthp, int FAR* dayp);

LONG APIENTRY gdate_dmytoday(int yr, int month, int day);

/* number of days in given month (Jan===1) in given year (e.g. 1993) */
int APIENTRY gdate_monthdays(int month, int year);

/* daynr is our standard LONG day number.  Returns day of the week.
   Weekdays are numbered from 0 to 6, Sunday==0
*/
int APIENTRY gdate_weekday(long daynr);


/* --- status line window class ---------------------------------- */
/* The status line is a bar across the top or bottom of the window.
 * It can hold a number of fields which can be either static text
 * or buttons.  The so called "static" text can be changed at any time.
 * The fields can be left or right aligned (default is RIGHT).
 * If the text is marked as VAR then the screen real estate allocated
 * for it will be adjusted whenever the text changes.  VAR fields
 * can be given minimum or maximum sizes (but not both).
 *
 * STATIC text fields can be drawn as raised or lowered rectangles (using
 * shades of grey), or (default) without a border. BUTTON fields will
 * always be drawn as raised rectangles, and will lower when pressed.
 *
 * Button fields will send WM_COMMAND messages when clicked including the
 * field id and the WM_LBUTTONUP notification code. Note that that this
 * is not a full implementation of the button class, and no other messages
 * will be sent. In general, none of the fields of a status bar are
 * implemented as separate windows, so GetDlgItem() and similar calls will not
 * work. Buttons only respond to mouse down events, and there is no handling
 * of the focus or of keyboard events.
 *
 * To use:
 *    call StatusAlloc giving the number of items you are going to add to the
 *    status bar. This returns a handle to use in subsequent calls.
 *
 *    Then call StatusAddItem to define each item in turn.
 *    Buttons are placed in order of definition along the bar starting from
 *    the left (SF_LEFT) and from the right (SF_RIGHT) until the two
 *    sides meet.
 *
 *    Call StatusHeight to find the expected height of this status bar, and
 *    set its position within the parent window, then call StatusCreate to
 *    create the window.
 *
 * Having created the window, send SM_SETTEXT messages to set the new
 * text of a field (static or button), or SM_NEW with a handle (obtained from
 * StatusAlloc) to change the contents of the status line.
 */

/* values for type argument to StatusAddItem */
#define SF_BUTTON       1
#define SF_STATIC       2

/* bits in flags argument to StatusAddItem */
#define SF_RAISE        1       /* paint static as raised 3D rectangle */
#define SF_LOWER        2       /* paint static as lowered 3D rectangle */
#define SF_LEFT         4       /* align field on left of status bar */
#define SF_RIGHT        8       /* align field on right (DEFAULT) */
#define SF_VAR          0x10    /* size of field depends on actual text extent*/
#define SF_SZMAX        0x20    /* (with SF_VAR): width argument is maximum */
#define SF_SZMIN        0x40    /* (with SF_VAR) width arg is minimum size */

/* interfaces */
HWND APIENTRY StatusCreate(HANDLE hInst, HWND hParent, INT_PTR id,
                           LPRECT rcp, HANDLE hmem);

/* return the recommended height in device units of the given status bar */
int APIENTRY StatusHeight(HANDLE hmem);

/* alloc the status bar data structures and return handle*/
HANDLE APIENTRY StatusAlloc(int nitems);

/* set the attributes of a field.
 *
 * hmem obtained from StatusAlloc. itemnr must be less than the nitems
 * passed to StatusAlloc.
 *
 * the width argument is the width of the field in characters (average
 * character width).
 */
BOOL APIENTRY StatusAddItem(HANDLE hmem, int itemnr, int type, int flags,
                            int id, int width, LPSTR text);

/* send these window messages to the class */

#define SM_NEW          (WM_USER+1)     /* wParam handle for new status line */
#define SM_SETTEXT      (WM_USER+2)     /* wparam: item id, lparam new label*/

/* --- bit-map freelist management functions -------------------------------*/

/* init a pre-allocated array of longs to map nblks - set all to free
   you should allocate 1 DWORD in map for every 32 blocks of storage
   you wish to control.
*/
void APIENTRY gbit_init(DWORD FAR * map, long nblks);

/* mark a range of nblks starting at blknr to be busy */
BOOL APIENTRY gbit_alloc(DWORD FAR * map, long blknr, long nblks);

/* mark a range of nblks starting at blknr to be free */
BOOL APIENTRY gbit_free(DWORD FAR * map, long blknr, long nblks);

/* find a free section nblks long, or the biggest found in the map if all
 * are less than nblks long. returns size of region found as return value,
 * and sets blknr to the starting blk of region. Region is *not* marked
 * busy
 */
long APIENTRY gbit_findfree(DWORD FAR* map, long nblks,
                            long mapsize, long FAR * blknr);


/* ----- buffered line input ----------------------------------*/

/*
 * functions for reading a file, one line at a time, with some buffering
 * to make the operation reasonably efficient.
 *
 * call readfile_new to initialise the buffer and give it a handle to
 * an open file. Call readfile_next to get a pointer to the next line.
 * This discards the previous line and gives you a pointer to the line
 * IN THE BUFFER. Make your own copy before calling readfile_next again.
 *
 * call readfile_delete once you have finished with this file. That will close
 * the file and free up any memory.
 */

// MAX_LINE_LENGTH is the max number of physical characters we allow in a line
#define MAX_LINE_LENGTH         (4096)
// BUFFER_SIZE is expressed in bytes, and is large enough to read in
// MAX_LINE_LENGTH wide chars, and also hold MAX_LINE_LENGTH 5-byte hex code
// representations of the chars.
#define BUFFER_SIZE             (MAX_LINE_LENGTH * 5)

/* handle to a file buffer */
typedef struct filebuffer FAR * FILEBUFFER;

/* initialise the buffering for an open file */
FILEBUFFER APIENTRY readfile_new(HANDLE fh, BOOL *pfUnicode);

/* return a pointer to the next line in this file. line must be shorter than
 * buffer size (currently 1024 bytes). Line is not null-terminated: *plen
 * is set to the length of the line including the \n. This call will
 * discard any previous line, so ensure that you have made a copy of one line
 * before you call readfile_next again.
 * MUST CALL readfile_setdelims FIRST!
 */
LPSTR APIENTRY readfile_next(FILEBUFFER fb, int FAR * plen, LPWSTR *ppwz, int *pcwch);

/* set the delimiters to use to break lines.  MUST call this to initialise */
void APIENTRY readfile_setdelims(LPBYTE str);

/*
 * close the file and discard any associated memory and buffers.
 */
void APIENTRY readfile_delete(FILEBUFFER fb);


/* ------ hashing and checksums ------------------------------------------- */

/*
 * generate a 32-bit hash code for a null-terminated string of ascii text.
 *
 * if bIgnoreBlanks is TRUE, we ignore spaces and tabs during the
 * hashcode calculation.
 */

/* hash codes are unsigned longs */

DWORD APIENTRY hash_string(LPSTR string, BOOL bIgnoreBlanks);
void Format(char * a, char * b);

/* return TRUE iff the string is blank.  Blank means the same as
 * the characters which are ignored in hash_string when ignore_blanks is set
 */
BOOL APIENTRY utils_isblank(LPSTR string);

/*
 * Compare two pathnames, and if not equal, decide which should come first.
 *
 * returns 0 if the same, -1 if left is first, and +1 if right is first.
 *
 * The comparison is such that all filenames in a directory come before any
 * file in a subdirectory of that directory.
 *
 * To make absolutely certain that you get a canonical sorting, use AnsiLowerBuff
 * to convert BOTH to lower case first.  You may get a funny effect if one one
 * has been converted to lower case and the other not.
 */
int APIENTRY
utils_CompPath(LPSTR left, LPSTR right);
/* given an open file handle open for reading, read the file and
 * generate a 32-bit checksum for the file
 */

/* checksums are unsigned longs */
typedef DWORD CHECKSUM;

/* Open a file, checksum it and close it again. err !=0 iff it failed. */
CHECKSUM APIENTRY checksum_file(LPCSTR fn, LONG FAR * err);


/* --- error message output ----------------------------------------------*/

/*
 * reports error in a dialog, returns TRUE for ok, FALSE for cancel.
 * if fCancel is FALSE, only the OK button is shown, otherwise both ok
 * and cancel. hwnd is the parent window for the dlg. can be null.
 */
BOOL APIENTRY Trace_Error(HWND hwnd, LPSTR msg, BOOL fCancel);

/* Write popups to a file until further notice */
void Trace_Unattended(BOOL bUnattended);

/* --- create/write to trace file ----------------------------------------*/

void APIENTRY Trace_File(LPSTR msg);

/* --- close trace file --------------------------------------------------*/
void APIENTRY Trace_Close(void);

/* --- simple input ------------------------------------------------------*/

/*
 * input of a single text string, using a simple dialog.
 *
 * returns TRUE if ok, or FALSE if error or user canceled. If TRUE,
 * puts the string entered into result (up to resultsize characters).
 *
 *
 * prompt is used as the prompt string, caption as the dialog caption and
 * def_input as the default input. All of these can be null.
 */

int APIENTRY StringInput(LPSTR result, int resultsize, LPSTR prompt,
                         LPSTR caption, LPSTR def_input);



/* --- sockets -----------------------------------------------------------*/

#ifdef SOCKETS

    #include <winsock.h>

BOOL SocketConnect( LPSTR pstrServerName, u_short TCPPort, SOCKET *pSocket );
BOOL SocketListen( u_short TCPPort, SOCKET *pSocket );

#endif

// These are for both WINDIFF.EXE and GUTILS.DLL.
//#define strchr          My_mbschr
//#define strncpy         My_mbsncpy
PUCHAR My_mbspbrk(PUCHAR, PUCHAR);
LPSTR My_mbschr(LPCSTR, unsigned short);
LPSTR My_mbsncpy(LPSTR, LPCSTR, size_t);

// These are for WINDIFF.EXE.
//#define strrchr         My_mbsrchr
//#define strncmp         My_mbsncmp
LPSTR My_mbsrchr(LPCSTR, unsigned short);
int My_mbsncmp(LPCSTR, LPCSTR, size_t);
LPTSTR APIENTRY LoadRcString(UINT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\libentry.asm ===
PAGE	,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       LIBENTRY.ASM
;
;       Windows dynamic link library entry routine
;
;   This module generates a code segment called INIT_TEXT.
;   It initializes the local heap if one exists and then calls
;   the C routine LibMain() which should have the form:
;   BOOL FAR PASCAL LibMain(HANDLE hInstance,
;                           WORD   wDataSeg,
;                           WORD   cbHeap,
;                           LPSTR  lpszCmdLine);
;        
;   The result of the call to LibMain is returned to Windows.
;   The C routine should return TRUE if it completes initialization
;   successfully, FALSE if some error occurs.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        extrn LibMain:far         ; the C routine to be called
	extrn LocalInit:far       ; Windows heap init routine
        extrn __acrtused:abs      ; ensures that Win DLL startup code is linked

        public LibEntry           ; entry point for the DLL

INIT_TEXT segment byte public 'CODE'
        assume cs:INIT_TEXT

LibEntry proc far
        
	push	di		 ; handle of the module instance
        push    ds               ; library data segment
	push	cx		 ; heap size
	push	es		 ; command line segment
	push	si		 ; command line offset

	; if we have some heap then initialize it
	jcxz	callc		 ; jump if no heap specified

	; call the Windows function LocalInit() to set up the heap
	; LocalInit((LPSTR)start, WORD cbHeap);

	push	ds		 ; Heap segment
        xor     ax,ax
	push	ax		 ; Heap start offset in segment
	push	cx		 ; Heap end offset in segment
	call	LocalInit	 ; try to initialize it
	or	ax,ax		 ; did it do it ok ?
	jz	nocall		 ; quit if it failed

	; invoke the C routine to do any special initialization

callc:
	call	LibMain		 ; invoke the 'C' routine (result in AX)
        jmp short exit           ; LibMain is responsible for stack clean up

nocall:                          ; clean up passed params
        pop     si               ; if LocalInit fails. 
        pop     es               
        pop     cx               
        pop     ds
        pop     di
exit:
	ret			 ; return the result

LibEntry endp

INIT_TEXT       ends

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\precomp.h ===
#include <windows.h>
#include <commdlg.h>
#include <string.h>
#include <stdio.h>
#include <memory.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <gutils.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\list.c ===
/* Laurie Griffiths C version 05/12/91 */
/* Storage allocation scheme customised */

#include <precomp.h>
#include "list.h"

// use the standard Trace_Error function, but we have no
// parent window to pass for these errors.
#define TRACE_ERROR(a, b)	Trace_Error(NULL, a, b)


char msg[80];  /* a temp for building up snprintf messages in */

/* Under windows, malloc and GlobalAlloc each seem to give about the
** same number of allocations before they run out of steam, and on my
** laptop it's only about 1600 odd, despite 3M of memory.  Furthermore,
** the number doesn't change much if you allocate in lumps of 30 bytes or
** 1500 bytes.  Alas, it looks as though (one more time, one more operating
** system) we get to do our own allocation scheme.  Sigh.  When will they
** ever learn.
** So we need a List_Init function and a List_Term function.
** In between, we have a current block which is a K or two long and we
** allocate storage from inside it unless there's no room, in which case
** we move onto the next block.  We retain a count of the number of
** allocations within a block.  We make no attempt to reclaim storage
** until the whole block's free (count gone back to 0), then we free it.
** The block holds its handle.  Individual allocations hold a pointer
** to the block start.
**
** Purely for checking purposes, the blocks are all chained together.
** List_Term (which has no function other than checking) checks that
** this chain is empty.  Apart from this we do not keep track of the
** allocations. We just hand them out and let the calling program keep track.
*/
#define BLOCKSIZE 25000
typedef struct blockTag {
    struct blockTag * PrevBlock; /* backward link (NULL terminated doubly linked chain of blocks) */
    struct blockTag * NextBlock; /* forward link (pCurrent points to last in chain) */
    HANDLE hMem;     /* memory handle for this block */
    int iInUse;      /* number of allocations taken out of it.  0 => free it */
    SIZE_T iNext;       /* next byte to use */
    char chData[BLOCKSIZE];
} BLOCK, *PBLOCK;

CRITICAL_SECTION CritSec;  /* to protect pCurrent */

PBLOCK pCurrent = NULL;  /* block currently in use */
/* must always be either NULL or valid */

/* Allocate storage for List elements.  n.b. after a call to this
   you MUST record the value of pCurrent as you need to hand that in
   to Free.  You don't hand in the value of the actual storage.
   See screed above.
   This function Enters the critical section.  The caller must Leave it.
*/
LPVOID
list_Alloc(
          SIZE_T size
          )
{
    HANDLE hMem;
    LPVOID pRet;
    PBLOCK pb;
    EnterCriticalSection(&CritSec);
    if ((pCurrent==NULL)||(pCurrent->iNext+size>BLOCKSIZE+1)) {
        hMem = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE|GMEM_ZEROINIT,(DWORD)(sizeof(BLOCK)));
        if (hMem==NULL) {pCurrent = NULL;
            OutputDebugString("GlobalAlloc failed!!\n");
            return NULL;
        }
        pb = pCurrent;
        pCurrent = (PBLOCK)GlobalLock(hMem);
        if (pCurrent==NULL) {OutputDebugString("GlobalLock failed!!\n");
            return NULL;
        }
        pCurrent->PrevBlock = pb;
        pCurrent->NextBlock = NULL;
        pCurrent->hMem = hMem;
        pCurrent->iInUse = 0;
        pCurrent->iNext = 0;
        if (pb==NULL)
            ;
        else
            pb->NextBlock = pCurrent;
    }
    pRet = &(pCurrent->chData[pCurrent->iNext]);
    ++(pCurrent->iInUse);
    pCurrent->iNext += size;

    /* for MIPS we must also ensure that the data is aligned 4 byte*/
    pCurrent->iNext = ((pCurrent->iNext + (sizeof(void *)-1)) & ~(sizeof(void *) - 1));

    return pRet;
}

void
list_Free(
         PBLOCK pBlock,
         LPVOID p
         )
{
    HANDLE hMem;
    EnterCriticalSection(&CritSec);
    --pBlock->iInUse;
    if (pBlock->iInUse<=0) {if (pBlock->iInUse<0) {_snprintf(msg,sizeof(msg),"Bug in List code. Tell LaurieGr!\nList block allocation negative (%d)", pBlock->iInUse);
            TRACE_ERROR(msg, FALSE);
        }
        if (pCurrent==pBlock) pCurrent = pBlock->PrevBlock; /* defend the invariant */
        /* loop it out of the chain */
        if (pBlock->PrevBlock!=NULL) pBlock->PrevBlock->NextBlock = pBlock->NextBlock;
        if (pBlock->NextBlock!=NULL) pBlock->NextBlock->PrevBlock = pBlock->PrevBlock;
        hMem = pBlock->hMem;
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }
    LeaveCriticalSection(&CritSec);
}



/* The following definition tells the truth about what an ITEM is.  The
|  header file says only that there's a structure with the tag item_tag and
|  that a LIST is a pointer to one.  Here we spell out what that structure
|  is (and a LIST is still a pointer to one).  A PLIST is defined as a
|  pointer to one of those, but is only really used because the C
|  parameter mechanism demands an extra level of indirection for a
|  parameter that can be updated.  (Modula-2 VAR parameter).
*/
typedef struct item_tag {
    struct item_tag *pitNext;    /* to next in circular list */
    struct item_tag *pitPrev;    /* to prev in circular list */
    PBLOCK pBlock;               /* to memory block */
    BOOL bAnchor;                /* TRUE iff an anchor block */
    BOOL bOK;                    /* true unless a list op has failed */
    int iLen;                    /* length of data only */
    char *Data[1];               /* the caller's data.  The '1' is a lie */
} ITEM;

/* For an anchor block, only the fields pitNext thru bAnchor are allocated.
|  For a normal list element, Data may well be longer than 1 byte.
|  The bOK flag is to support a style of programming where several
|  successive operations can be done without having to check the return
|  code at each stage.  At the end, the list can be examined to see if
|  the data in it is valid or if it has been made invalid by the failure
|  of any of the previous operations.  Certain operations may result in
|  having no list at all if they fail (e.g. create) and for these, you'd
|  better check the result at once!
|  ??? Some of this screed belongs in the header!!!
*/

static SIZE_T iAnchorSize;      /* Size of anchor block (no data, no dummy) */
static SIZE_T iHeaderSize;      /* Size of data block not counting Data
                                and offset from cursor back to item.
                             */
static BOOL bInited = FALSE; /* TRUE <=> iAnchorSize and iHeaderSize are OK*/

#define MOVEBACK(Curs)                                               \
   { Curs = ((char *)Curs-iHeaderSize); } /*move from Data to pitNext*/

/*==================================================================
|| Lists are circular, doubly linked with an anchor block which holds
|| pointers to both ends.  Every block has a flag which shows whether
|| it's an anchor or not.
||
|| Empty list:
||
||      -------------
||     |             |
||     |   Anchor    |
||     v   -------   |
||  Ul--->| Next--+--|
||        |-------|  |
||        | Prev--+--
||         -------
||
|| One entry list:
||
||      ------------------------------------
||     |                                    |
||     |   Anchor                           |
||     v   -------                ------    |
||  Ul--->| Next--+------------->| Next-+---|
||        |-------|    |         |------|   |
||        | Prev--+----          | Prev-+---
||         -------               |------|
||                               | Len  |
||                               |------|
||                               | Data |
||                                ------
|| Two entry list:
||
||      -------------------------------------------------
||     | ---------------    ---------------              |
||     ||               |  |               |             |
||     ||  Anchor       |  |               |             |
||     vv  --------     |  v    ------     |    ------   |
||  Ul--->| Next--+-----+----->| Next-+----+-->| Next-+--
||        |-------|     |      |------|  | |   |------|
||        | Prev--+--    ------+-Prev |  |  ---+-Prev |
||         -------   |         |------|  |     |------|
||                   |         | Len  |  |     | Len  |
||                   |         |------|  |     |------|<----Cursor
||                   |         | Data |  |     | Data |
||                   |          ------   |      ------
||                   |                   |
||                    -------------------
||
|| etc.
||
|| Note that an external cursor (i.e one which is seen by the caller)
|| points to the Data field, not to the start of the structure.
|| This allows easy access to the data by the user at the cost of a
|| slightly slower traverse.
|| Within this module, we may sometimes traverse a list with  a cursor
|| that points to the start of an item.  This is called an item cursor.
===================================================================*/

/*------------------------------------------------------------------
| Set iAnchorSize and iHeaderSize.  Implementation independent!
 -------------------------------------------------------------------*/
void
APIENTRY
List_Init(
         void
         )
{
    LIST P;
    P = (LIST)&P;                  /* really any old address will do */
    iAnchorSize = (char *)&(P->iLen) - (char *)&(P->pitNext);
    iHeaderSize = (char *)&(P->Data) - (char *)&(P->pitNext);
    InitializeCriticalSection(&CritSec);
    bInited = TRUE;
    /* assumes layout in storage is linear */
}


void
APIENTRY
List_Term(
         void
         )
{
    if (pCurrent!=NULL)
        TRACE_ERROR("List storage not cleared out properly", FALSE);
}



/* Dump the internals to the debugger. */
void
APIENTRY
List_Dump(
         LPSTR Header,
         LIST lst
         )
{
    LIST pit;
    char X_msg[250] = {0};

    OutputDebugString(Header);  OutputDebugString("\n");
    pit = lst;
    do {
        _snprintf(X_msg,sizeof(X_msg)-1, "%8p %8p %8p %ld %s "
                 , pit, pit->pitNext, pit->pitPrev, pit->iLen
                 , (pit->bAnchor ? "Anchor" : "Data")
                );
        OutputDebugString(X_msg);
        if (pit->pitNext->pitPrev != pit)
            OutputDebugString(" Next Prev error!!");
        if (pit->pitPrev->pitNext != pit)
            OutputDebugString(" Prev Next error!!");
        OutputDebugString("\n");
        pit = pit->pitNext;
    } while (pit!=lst);
    OutputDebugString("End of list dump\n");
}

/* Dump hex representation of handle to debugger */
void
APIENTRY
List_Show(
         LIST lst
         )
{
    char X_msg[50] = {0};
    _snprintf(X_msg, sizeof(X_msg)-1, "%p", lst);
    OutputDebugString(X_msg);
}

/*------------------------------------------------------------------
| Create a list.  It will be initially empty
 -------------------------------------------------------------------*/
LIST
APIENTRY
List_Create(
           void
           )
{
    LIST lst;
    if (!bInited) {
        List_Init();            /* prevent some strange errors */
    }
    lst = list_Alloc(iAnchorSize);

    if (lst==NULL) {
        return NULL;
    }
    lst->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    lst->bOK = TRUE;
    lst->pitNext = lst;
    lst->pitPrev = lst;
    lst->bAnchor = TRUE;
    /* no length field set in an anchor block */
    return lst;
}

/*------------------------------------------------------------------
| Destroy *plst.  It does not need to be empty first
 -------------------------------------------------------------------*/
void
APIENTRY
List_Destroy(
            PLIST plst
            )
{
    LIST pitP;    /* item cursor on * plst */
    LIST pitQ;    /* item cursor runs one step ahead of pitQ */

    if (plst==NULL) {
        TRACE_ERROR("Bug:Attempt to destroy NULL list.  Continuing...", FALSE);
        return;
    }

    /* There is at least an anchor block to destroy */
    pitP = *plst;
    do {
        pitQ = pitP->pitNext;
        list_Free(pitP->pBlock, pitP);
        pitP = pitQ;
    }while (pitP != *plst);
    *plst = NULL;
}

/*------------------------------------------------------------------
| Add an item holding Object to the beginning of * plst
 -------------------------------------------------------------------*/
void
APIENTRY
List_AddFirst(
             LIST lst,
             LPVOID pObject,
             UINT uLen
             )
{
    LIST pit;      /* newly allocated item */

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_AddFirst to bogus list.  Continuing...", FALSE);
        return;
    }
    pit = list_Alloc(iHeaderSize+uLen);
    if (pit==NULL) {
        lst->bOK = FALSE;
        return;
    }
    pit->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    pit->iLen = uLen;
    pit->pitPrev = lst;
    pit->pitNext = lst->pitNext;
    lst->pitNext->pitPrev = pit; /* for empty list that set lst->pitPrev */
    lst->pitNext = pit;
    pit->bAnchor = FALSE;
    memcpy( &(pit->Data), pObject, uLen );
}

/*------------------------------------------------------------------
| Return the address of the place for Len bytes of data in a new
| item at the start of lst
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_NewFirst(
             LIST lst,
             UINT uLen
             )
{
    LIST pit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_NewFirst to bogus list.  Continuing...", FALSE);
        return NULL;
    }
    pit = list_Alloc(iHeaderSize+uLen);
    if (pit==NULL) {
        lst->bOK = FALSE;
        return NULL;
    }
    pit->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    pit->iLen = uLen;
    pit->pitPrev = lst;
    pit->pitNext = lst->pitNext;
    lst->pitNext->pitPrev = pit; /* for empty list that set lst->pitPrev */
    lst->pitNext = pit;
    pit->bAnchor = FALSE;
    return (char *)&(pit->Data);
}

/*------------------------------------------------------------------
| Delete the first item in lst.  Error if lst is empty
 -------------------------------------------------------------------*/
void
APIENTRY
List_DeleteFirst(
                LIST lst
                )
{
    LIST pit;

    if (lst==NULL) {TRACE_ERROR("Bug: List_DeleteFirst from bogus list.  Continuing...", FALSE);
        return;
    }
    /* attempting to delete the anchor block! */
    if (lst->pitNext==lst) {
        lst->bOK = FALSE;
    } else {
        pit = lst->pitNext;
        pit->pitNext->pitPrev = pit->pitPrev;
        pit->pitPrev->pitNext = pit->pitNext;
        list_Free(pit->pBlock, pit);
    }
}

/*------------------------------------------------------------------
| Add an item holding Object to the end of lst
 -------------------------------------------------------------------*/
void
APIENTRY
List_AddLast(
            LIST lst,
            LPVOID pObject,
            UINT uLen
            )
{
    LIST pit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_AddLast to bogus list. Continuing...", FALSE);
        return;
    }
    pit = list_Alloc(iHeaderSize+uLen);
    if (pit==NULL) {
        lst->bOK = FALSE;
        return;
    }
    pit->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    pit->iLen = uLen;
    pit->pitNext = lst;
    pit->pitPrev = lst->pitPrev;
    lst->pitPrev->pitNext = pit; /* for empty list that set lst->pitNext */
    lst->pitPrev = pit;
    pit->bAnchor = FALSE;
    memcpy( &(pit->Data), pObject, uLen );
}

/*------------------------------------------------------------------
| Return the address of the place for uLen bytes of data in a new
|  item at the end of lst
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_NewLast(
            LIST lst,
            UINT uLen
            )
{
    LIST pit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_NewLast in bogus list.  Continuing...", FALSE);
        return NULL;
    }
    pit = list_Alloc(iHeaderSize+uLen);
    if (pit==NULL) {
        lst->bOK = FALSE;
        return NULL;
    }
    pit->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    pit->iLen = uLen;
    pit->pitNext = lst;
    pit->pitPrev = lst->pitPrev;
    lst->pitPrev->pitNext = pit; /* for empty list that set lst->pitNext */
    lst->pitPrev = pit;
    pit->bAnchor = FALSE;
    return (char *)&(pit->Data);
}

/*------------------------------------------------------------------
| Delete the last item in lst.  Error if lst is empty
 -------------------------------------------------------------------*/
void
APIENTRY
List_DeleteLast(
               LIST lst
               )
{
    LIST pit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_DeleteLast from bogus list.  Continuing...", FALSE);
        return;
    }
    /* attempting to delete the anchor block! */
    if (lst->pitNext==lst) {
        lst->bOK = FALSE;
    } else {
        pit = lst->pitPrev;
        pit->pitNext->pitPrev = pit->pitPrev;
        pit->pitPrev->pitNext = pit->pitNext;
        list_Free(pit->pBlock, pit);
    }
}

/*--------------------------------------------------------------------
| Add an item holding * pObject to lst immediately after Curs.
| List_AddAfter(lst,NULL,pObject,Len) adds it to the start of the lst
 ---------------------------------------------------------------------*/
void
APIENTRY
List_AddAfter(
             LIST lst,
             LPVOID Curs,
             LPVOID pObject,
             UINT uLen
             )
{
    LIST pitNew;
    LIST pitAfter;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_AddAfter in bogus list.  Continuing...", FALSE);
        return;
    }
    if (Curs==NULL) {
        List_AddFirst(lst, pObject, uLen);
    } else {
        MOVEBACK(Curs);
        pitAfter = (LIST)Curs;
        pitNew = list_Alloc(iHeaderSize+uLen);
        if (pitNew==NULL) {
            lst->bOK = FALSE;
            return;
        }
        pitNew->pBlock = pCurrent;
        LeaveCriticalSection(&CritSec);
        pitNew->iLen = uLen;
        pitNew->pitPrev = pitAfter;
        pitNew->pitNext = pitAfter->pitNext;
        pitAfter->pitNext->pitPrev = pitNew;
        pitAfter->pitNext = pitNew;
        pitNew->bAnchor = FALSE;
        memcpy( &(pitNew->Data), pObject, uLen );
    }
}

/*--------------------------------------------------------------------
| Return the address of the place for uLen bytes of data in a new
| item immediately after Curs.
| List_NewAfter(Lst,NULL,uLen) returns a pointer
| to space for uLen bytes in a new first element.
 ---------------------------------------------------------------------*/
LPVOID
APIENTRY
List_NewAfter(
              LIST lst,
              LPVOID Curs,
              UINT uLen
              )
{
    LIST pitNew;
    LIST pitAfter;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_NewAfter in bogus list. Continuing...", FALSE);
        return NULL;
    }
    if (Curs==NULL) {
        return List_NewFirst(lst, uLen);
    } else {
        MOVEBACK(Curs);
        pitAfter = (LIST)Curs;
        pitNew = list_Alloc(iHeaderSize+uLen);
        if (pitNew==NULL) {
            lst->bOK = FALSE;
            return NULL;
        }
        pitNew->pBlock = pCurrent;
        LeaveCriticalSection(&CritSec);
        pitNew->iLen = uLen;
        pitNew->pitPrev = pitAfter;
        pitNew->pitNext = pitAfter->pitNext;
        pitAfter->pitNext->pitPrev = pitNew;
        pitAfter->pitNext = pitNew;
        pitNew->bAnchor = FALSE;
        return (char *)&(pitNew->Data);
    }
}

/*--------------------------------------------------------------------
| Add an item holding Object to lst immediately before Curs.
| List_AddBefore(Lst,NULL,Object,uLen) adds it to the end of the list
 ---------------------------------------------------------------------*/
void
APIENTRY
List_AddBefore(
               LIST lst,
               LPVOID Curs,
               LPVOID pObject,
               UINT uLen
                            )
{
    LIST pitNew;
    LIST pitBefore;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_AddBefore in bogus list.  Continuing...", FALSE);
        return;
    }
    if (Curs==NULL) {
        List_AddLast(lst, pObject, uLen);
    } else {
        MOVEBACK(Curs);
        pitBefore = (LIST)Curs;
        pitNew = list_Alloc(iHeaderSize+uLen);
        if (pitNew==NULL) {
            lst->bOK = FALSE;
            return;
        }
        pitNew->pBlock = pCurrent;
        LeaveCriticalSection(&CritSec);
        pitNew->iLen = uLen;
        pitNew->pitNext = pitBefore;
        pitNew->pitPrev = pitBefore->pitPrev;
        pitBefore->pitPrev->pitNext = pitNew;
        pitBefore->pitPrev = pitNew;
        pitNew->bAnchor = FALSE;
        memcpy( &(pitNew->Data), pObject, uLen );
    }
}

/*--------------------------------------------------------------------
| Return the address of the place for uLen bytes of data in a new
| item immediately before Curs.
| List_NewBefore(Lst,NULL,uLen) returns a pointer
| to space for uLen bytes in a new last element.
 ---------------------------------------------------------------------*/
LPVOID
APIENTRY
List_NewBefore(
               LIST lst,
               LPVOID Curs,
               UINT uLen
               )
{
    LIST pitNew;
    LIST pitBefore;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_NewBefore in bogus list.  Continuing...", FALSE);
        return NULL;
    }
    if (Curs==NULL) {
        return List_NewLast(lst, uLen);
    } else {
        MOVEBACK(Curs);
        pitBefore = (LIST)Curs;
        pitNew = list_Alloc(iHeaderSize+uLen);
        if (pitNew==NULL) {
            lst->bOK = FALSE;
            return NULL;
        }
        pitNew->pBlock = pCurrent;
        LeaveCriticalSection(&CritSec);
        pitNew->iLen = uLen;
        pitNew->pitNext = pitBefore;
        pitNew->pitPrev = pitBefore->pitPrev;
        pitBefore->pitPrev->pitNext = pitNew;
        pitBefore->pitPrev = pitNew;
        pitNew->bAnchor = FALSE;
        return (char *) &(pitNew->Data);
    }
}

/*------------------------------------------------------------------
| Delete the item that Curs identifies.
| This will be only a few (maybe as little as 3) machine instructions
| quicker than DeleteForwards or DeleteBackwards but leaves Curs dangling.
| It is therefore NOT usually to be preferred.
| It may be useful when you have a function which returns an LPVOID
| since the argument does not need to be a variable.
|     Trivial example: List_Delete(List_First(L));
 -------------------------------------------------------------------*/
void
APIENTRY
List_Delete(
            LPVOID Curs
            )
{
    LIST pit;
    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_Delete NULL item", FALSE);
        return;
    }
    MOVEBACK(Curs)
    pit = (LIST)Curs;
    pit->pitNext->pitPrev = pit->pitPrev;
    pit->pitPrev->pitNext = pit->pitNext;
    list_Free(pit->pBlock, pit);
}

/*-----------------------------------------------------------------------
| Delete the item that Curs identifies and return a cursor that
| identifies the next item (NULL if already on last)
 ------------------------------------------------------------------------*/
LPVOID
APIENTRY
List_DeleteForwards(
                    LPVOID Curs
                    )
{
    LIST pitDel;  /* the item to delete */
    LIST pitN;    /* the item after (could be anchor) */
    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_DeleteForwards NULL cursor. Continuing...", FALSE);
        return NULL;
    }
    MOVEBACK(Curs)
    pitDel = (LIST)Curs;
    pitN = pitDel->pitNext;

    pitN->pitPrev = pitDel->pitPrev;
    pitDel->pitPrev->pitNext = pitN;
    list_Free(pitDel->pBlock, pitDel);
    if (pitN->bAnchor)
        return NULL;
    else
        return (char *)&(pitN->Data);
}

/*-----------------------------------------------------------------------
| Delete the item that Curs identifies and return a cursor that
| identifies the previous item (NULL if already on first)
 ------------------------------------------------------------------------*/
LPVOID
APIENTRY
List_DeleteBackwards(
                     LPVOID Curs
                     )
{
    LIST pitDel;  /* the one to delete */
    LIST pitB;    /* the one before */

    if (Curs==NULL) {
        TRACE_ERROR("List_DeleteBackwards NULL cursor.  Continuing...", FALSE);
        return NULL;
    }
    MOVEBACK(Curs)
    pitDel = (LIST)Curs;
    pitB = pitDel->pitPrev;
    pitDel->pitNext->pitPrev = pitB;
    pitB->pitNext = pitDel->pitNext;
    list_Free(pitDel->pBlock, pitDel);
    if (pitB->bAnchor)
        return NULL;
    else
        return (char *)&(pitB->Data);
}

/*-------------------------------------------------------------------
| Return the length of the object identified by the cursor Curs
 -------------------------------------------------------------------*/
int
APIENTRY
List_ItemLength(
                LPVOID Curs
                )
{
    LIST pit;
    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_ItemLength NULL cursor.  Continuing...", FALSE);
        return 0;
    }
    MOVEBACK(Curs)
    pit = (LIST)Curs;
    return pit->iLen;
}

/*------------------------------------------------------------------
| Return the address of the first object in lst
|  If lst is empty then Return NULL.
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_First(
           LIST lst
           )
{
    if (lst==NULL) {
        TRACE_ERROR("Bug: List_First of bogus list.  Continuing...", FALSE);
        return NULL;
    }
    if (lst->pitNext==lst) {
        return NULL;
    }
    return &(lst->pitNext->Data);
}

/*------------------------------------------------------------------
| Return the address of the last object in lst
| If lst is empty then return NULL.
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_Last(
          LIST lst
          )
{
    if (lst==NULL) {
        TRACE_ERROR("Bug: List_Last of bogus list.  Continuing...", FALSE);
        return NULL;
    }
    if (lst->pitNext==lst) {
        return NULL;
    }
    return &(lst->pitPrev->Data);
}

/*------------------------------------------------------------------
| Return the address of the object after Curs^.
| List_Next(List_Last(lst)) == NULL;  List_Next(NULL) is an error.
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_Next(
          LPVOID Curs
          )
{
    LIST pit;

    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_Next of NULL cursor.  Continuing...", FALSE);
        return NULL;
    }
    MOVEBACK(Curs)
    pit = (LIST)Curs;
    pit = pit->pitNext;
    if (pit->bAnchor) {
        return NULL;
    } else {
        return &(pit->Data);
    }
}

/*------------------------------------------------------------------
| Return the address of the object after Curs^.
| List_Prev(List_First(L)) == NULL;  List_Prev(NULL) is an error.
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_Prev(
          LPVOID Curs
          )
{
    LIST pit;

    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_Prev of NULL cursor.  Continuing...", FALSE);
        return NULL;
    }
    MOVEBACK(Curs)
    pit = (LIST)Curs;
    pit = pit->pitPrev;
    if (pit->bAnchor) {
        return NULL;
    } else {
        return &(pit->Data);
    }
}

/*-------------------------------------------------------------------
| Arrange that lst is empty after this call
 --------------------------------------------------------------------*/
void
APIENTRY
List_Clear(
           LIST lst
           )
{
    LIST pitP;   /* item cursor on List, points to element starts */
    LIST pitQ;   /* runs one step ahead of pitP                   */

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_Clear of bogus list.  Continuing...", FALSE);
        return;
    }
    pitP = lst->pitNext;   /* first element of list proper */
    while (pitP!=lst) {      /* while not wrapped onto anchor */pitQ = pitP->pitNext;
        list_Free(pitP->pBlock, pitP);
        pitP = pitQ;
    }
    lst->bOK = TRUE;
    lst->pitNext = lst;
    lst->pitPrev = lst;
}

/*---------------------------------------------------------------------
| Return TRUE if and only if lst is empty
 ----------------------------------------------------------------------*/
BOOL
APIENTRY
List_IsEmpty(
             LIST lst
             )
{  if (lst==NULL) {TRACE_ERROR("Bug: List_IsEmpty of bogus list.  Continuing...", FALSE);
        return TRUE;   /* well it's sort of true isn't it? */
    }
    return lst->pitNext ==lst;
} /* List_IsEmpty */

/*------------------------------------------------------------------
| l1 had better be empty.  l1 then acquires all the elements from l2
 -------------------------------------------------------------------*/
void
APIENTRY
SwitchLists(
            LIST l1,
            LIST l2
            )
{
    /* connect l1 to l2's elements, l1 had better be initially empty */
    l1->pitPrev = l2->pitPrev;
    l1->pitNext = l2->pitNext;
    /* connect the elements to l1 anchor block. */
    l1->pitPrev->pitNext = l1;
    l1->pitNext->pitPrev = l1;
    /* make l2 empty */
    l2->pitPrev = l2;
    l2->pitNext = l2;
}

/*-----------------------------------------------------------------------
| l1 := l1||l2; l2 := empty
| The elements themselves are not moved, so pointers to them remain valid.
|
| l1 gets all the elements of l1 in their original order followed by
| all the elements of l2 in the order they were in in l2.
| l2 becomes empty.
 ------------------------------------------------------------------------*/
void
APIENTRY
List_Join(
          LIST l1,
          LIST l2
          )
{
    if ((l1==NULL)||(l2==NULL)) {
        TRACE_ERROR("Bug: List_Join of bogus list.  Continuing...", FALSE);
        return;
    }
    l1->bOK = l1->bOK &&l2->bOK;  /* result OK if both inputs OK */
    l2->bOK = TRUE;               /* as l2 always becomes empty */
    if (l2->pitNext==l2) {
        /* no elements need moving */
    } else if (l2->pitNext==l2) {
        SwitchLists(l1,l2);
        return;
    } else {
        l2->pitNext->pitPrev = l1->pitPrev;
        l1->pitPrev->pitNext = l2->pitNext;
        l1->pitPrev = l2->pitPrev;
        l1->pitPrev->pitNext = l1;
        l2->pitNext = l2;
        l2->pitPrev = l2;
    }
}

/*-----------------------------------------------------------------------
| Let L1 be *pl1 and L2 be *pl2
| L1 := L1[...Curs] || L2 || L1[Curs+1...]; L2 := empty
| Curs=NULL means insert L2 at the start of L1
| The elements themselves are not moved, so pointers to them remain valid.
|
| L1 gets the elements of L1 from the start up to and including the element
| that Curs points at, in their original order,
| followed by all the elements that were in L2, in their original order,
| followed by the rest of L1
 ------------------------------------------------------------------------*/
void
APIENTRY
List_InsertListAfter(
                     LIST l1,
                     LIST l2,
                     LPVOID Curs
                     )
{
    LIST pitA;     /* The element after Curs, could be anchor */
    LIST pit;      /* The start of the element that Curs points at
                   |  or the anchor block if Curs==NULL
                   */

    if ( (l1==NULL) || (l2==NULL)) {
        TRACE_ERROR("Bug: List_InsertListAfter with bogus list.  Continuing...", FALSE);
        return;
    }
    l1->bOK = l1->bOK && l2->bOK;
    l2->bOK = TRUE;
    if (l2->pitNext==l2) {
        /* no elements need moving */
    } else if ( l1->pitNext==l1) {
        /* the easy way to code this would be simply to switch the two
        |  pointers l1 and l2, but they are value parameters and we don't
        |  want to change that.
        */
        SwitchLists(l1,l2);
        return;
    } else {
        if (Curs==NULL) {
            pit = l1;
        } else {
            MOVEBACK(Curs)
            pit = (LIST)Curs;
        }
        /* pit points to a block to insert after, could be anchor */
        pitA = pit->pitNext;           /* Cannot be same as P, already checked */
        l2->pitNext->pitPrev = pit;    /*  P<-- elems-of-l2    A */
        l2->pitPrev->pitNext = pitA;   /*  P<-- elems-of-l2 -->A */
        pit->pitNext = l2->pitNext;    /*  P<-->elems-of-l2 -->A */
        pitA->pitPrev = l2->pitPrev;   /*  P<-->elems-of-l2<-->A */

        l2->pitNext = l2;
        l2->pitPrev = l2;
    }
}


/*-----------------------------------------------------------------------
| l1 := l1[...Curs-1] || l2 || l1[Curs...]; l2 := empty
| Curs=NULL means insert l2 at the end of l1
| The elements themselves are not moved, so pointers to them remain valid.
|
| l1 gets the elements of l1 from the start up to but not including the
| element that Curs points at, in their original order,
| followed by all the elements that were in l2, in their original order,
| followed by the rest of l1.
 ------------------------------------------------------------------------*/
void
APIENTRY
List_InsertListBefore(
                      LIST l1,
                      LIST l2,
                      LPVOID Curs
                      )
{
    LIST pitB;     /* The element before Curs, could be anchor */
    LIST pit;      /* The start of the element that Curs points at
                    |  or the anchor block if Curs==NULL
                    */

    if ((l1==NULL) || (l2==NULL)) {
        TRACE_ERROR("Bug: List_InsertListBefore with bogus list.  Continuing...", FALSE);
        return;
    }
    l1->bOK = l1->bOK && l2->bOK;
    l2 ->bOK = TRUE;
    if (l2->pitNext==l2) {
        /* no action needed */
    } else if (l1->pitNext==l1) {
        /* the easy way to code this would be simply to switch the two
        |  pointers l1 and l2, but they are value parameters and we don't
        |  want to change that.
        */
        SwitchLists(l1,l2);
        return;
    } else {
        if (Curs==NULL) {
            pit = l1;
        } else {
            MOVEBACK(Curs)
            pit = (LIST)Curs;
        }

        /* P points to a block to insert before, could be anchor */
        pitB = pit->pitPrev;       /* Cannot be same as P, already checked */
        l2->pitNext->pitPrev = pitB; /*  B<-- elems-of-L2    P */
        l2->pitPrev->pitNext = pit;  /*  B<-- elems-of-L2 -->P */
        pitB->pitNext = l2->pitNext; /*  B<-->elems-of-L2 -->P */
        pit->pitPrev = l2->pitPrev;  /*  B<-->elems-of-L2<-->P */
        l2->pitNext = l2;
        l2->pitPrev = l2;
    }
}


/*-----------------------------------------------------------------------
| Let l1 be l1 and l2 be l2
| Split l2 off from the front of l1:    final l2,l1 = original l1
|
| Split l1 into l2: objects of l1 up to and including Curs object
|               l1: objects of l1 after Curs
| Any original contents of l2 are freed.
| List_Spilt(l1, l2, NULL) splits l1 before the first object so l1 gets all.
| The elements themselves are not moved.
 ------------------------------------------------------------------------*/
void
APIENTRY
List_SplitAfter(
                LIST l1,
                LIST l2,
                LPVOID Curs
                )
{
    LIST pit;

    if ((l1==NULL) || (l2==NULL)) {
        TRACE_ERROR("Bug: List_SplitAfter bogus list.  Continuing...", FALSE);
        return;
    }
    if (l2->pitNext!=l2) {
        List_Clear(l2);
    };
    if (Curs!=NULL) {
        MOVEBACK(Curs)
        pit = (LIST)Curs;
        /* Curs had better be an item in l1! l2 had better be created! */
        if (pit==l1) {
            l1->bOK = FALSE;
            l2->bOK = FALSE;
            return;
        }
        if (pit->pitNext==l1) {
            /* transfer whole of l2 to l1 */
            SwitchLists(l2,l1);
            return;
        }
        l2->pitPrev = pit;
        l2->pitNext = l1->pitNext;
        l1->pitNext = pit->pitNext;
        pit->pitNext = l2;
        l2->pitNext->pitPrev = l2;
        l1->pitNext->pitPrev = l1;
    }
}

/*----------------------------------------------------------------------
| Split l2 off from the back of l1:  final l1,l2 = original l1
|
| Split l1 into l1: objects of l1 up to but not including Curs object
|               l2: objects of l1 from Curs onwards
| Any original contants of l2 are freed.
| List_Spilt(l1, l2, NULL) splits l1 after the last object so l1 gets all.
| The elements themselves are not moved.
 -----------------------------------------------------------------------*/
void
APIENTRY
List_SplitBefore(
                 LIST l1,
                 LIST l2,
                 LPVOID Curs
                 )
{
    LIST pit;

    if ((l1==NULL) || (l2==NULL)) {
        TRACE_ERROR("Bug: List_SplitBefore bogus list.  Continuing...", FALSE);
        return;
    }
    if (l2->pitNext!=l2) {
        List_Clear(l2);
    }
    if (Curs!=NULL) {
        MOVEBACK(Curs)
        pit = (LIST)Curs;
        /* Curs had better be an item in L1! L2 had better be created! */
        if (pit==l1) {
            l1->bOK = FALSE;
            l2->bOK = FALSE;
            return;
        }
        if (pit->pitPrev==l1) {
            SwitchLists(l2,l1);
            return;
        }
        l2->pitNext = pit;
        l2->pitPrev = l1->pitPrev;
        l1->pitPrev = pit->pitPrev;
        pit->pitPrev = l2;
        l2->pitPrev->pitNext = l2;
        l1->pitPrev->pitNext = l1;
    }
}

/*------------------------------------------------------------------
| Return the number of items in L
 -------------------------------------------------------------------*/
int
APIENTRY
List_Card(
          LIST lst
          )
{
    LIST pit;     /* item cursor on lst */
    int cit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_Card of bogus list.  Continuing...", FALSE);
        return 0;    /* well it is sort of 0 */
    }
    pit = lst->pitNext;
    cit = 0;
    while (pit!=lst) {
        cit++;
        pit = pit->pitNext;
    }
    return cit;
}

/*------------------------------------------------------------------
| Check return code
 -------------------------------------------------------------------*/
BOOL
APIENTRY
List_IsOK(
          LIST lst
          )
{
    if (lst==NULL) {
        TRACE_ERROR("Bug: List_IsOK of bogus list.  Continuing...", FALSE);
        return FALSE;       /* well it is sick ain't it! */
    }
    return lst->bOK;
}

/*------------------------------------------------------------------
| Set return code to good
 -------------------------------------------------------------------*/
void
APIENTRY
List_MakeOK(
            LIST lst
            )
{
    if (lst==NULL) {
        TRACE_ERROR("Bug: List_MakeOK of bogus list.  Continuing...", FALSE);
        return;
    }
    lst->bOK = TRUE;
}

BOOL
APIENTRY
List_Check(
           LIST lst
           )
{
    LIST pel;
    BOOL bOK;
    /*-----------------------------------------------------------------
    | Check the anchor block has the Anchor flag set.
    | Run through the LIST using the Anchor flag (which should be FALSE)
    | to mark where we have been (to test for loops in the chain)
    | and carry on until we see the Anchor flag again.  Check that this
    | is the anchor block that we started from.  Now do another pass
    | turning the Anchor flags off again and checking the Prev pointers.
     -------------------------------------------------------------------*/
    if (lst==NULL)
        return FALSE;  /* Should we trap?  Arguable */
    bOK = lst->bAnchor;
    pel = lst->pitNext;
    while (! pel->bAnchor) {
        pel->bAnchor = TRUE;
        pel = pel->pitNext;
    }
    bOK = bOK && (pel==lst);
    if (bOK) {
        /* Turn all the bAnchor flags off */
        pel = lst;
        do {pel->bAnchor = FALSE;
            bOK = bOK & (pel->pitNext->pitPrev==pel);
            pel = pel->pitNext;
        } while (pel!=lst);
        lst->bAnchor = TRUE;  /* except the real one */
    } else { /* just turn off those that we set on */
        pel = lst->pitNext;
        while (pel->bAnchor) {
            pel->bAnchor = FALSE;
            pel = pel->pitNext;
        }
        lst->bAnchor = TRUE;
    }
    return bOK;
}


void
APIENTRY
List_Recover(
             PLIST plst
             )
{
    LIST Last, P,Q;
    BOOL OK;
    /* For no particular reason we presume that the forward chain
       is good and reconstruct the back chain from it.  A better
       algorithm would do the kind of things that List_Check does
       to figure out where the problems lie.  This just steps along
       until it sees either an address that it has already seen or
       else the anchor block.  (It's an n-squared algorithm).
       It links the last good block found back to the anchor and
       fixes all the Anchor flags.
    */
    if (plst==NULL)
        return;
    if (*plst==NULL) {
        *plst = List_Create();
        return;
    }
    (*plst)->bAnchor = TRUE;
    P = (*plst)->pitNext;
    Last = *plst;
    for (; ; ) {if (P==*plst) break;
        Last = P;
        if (P->pitNext!=*plst) {OK = TRUE;
            Q = *plst;
            for (; ; ) {
                OK &= (P->pitNext!=Q);
                if (Q==P) break;
                Q = Q->pitNext;
            }
            if (!OK) break;
        }
        P = P->pitNext;
    }
    P = *plst;
    while (P!=Last) {P->pitNext->pitPrev = P;
        P->bAnchor = FALSE;
        P = P->pitNext;
    }
    Last->pitNext = *plst;
    (*plst)->pitPrev = Last;
    (*plst)->bAnchor = TRUE;
    (*plst)->bOK = TRUE;   /* Here's hoping! */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\tpriv.h ===
/*
 * tpriv.h
 *
 * data structures used internally by table class.
 *
 * include after table.h
 */


#ifndef abs
#define abs(x)  (((x) > 0)? (x) : -(x))
#endif

/*  one of these per visible line */
typedef struct {
        CellPos linepos;        /* posn and clipping info for line */

        lpCellData pdata;       /* array of CellData structs for all cells */
} LineData, *lpLineData;


/* master info struct pointed to by window extra bytes */

typedef struct {
        /* table info */
        TableHdr        hdr;            /* main hdr info from owner */
        lpColProps      pcolhdr;        /* ptr to array of phdr->ncols hdrs */

        /* window info */
        int     avewidth;       /* font ave width - for default cell sizing */
        int     rowheight;      /* height of one row */
        int     rowwidth;       /* total width of one row in pixels */
        int     winwidth;       /* width of window */
        int     nlines;         /* actual lines currently visible */

        lpCellPos pcellpos;     /* array of cell position structs */

        /* scroll settings */
        long    scrollscale;    /* scaling factor (force 16-bit range) */
        long    toprow;         /* 0-based rownr of top moveable line */
        int     scroll_dx;      /* horz scroll posn in pixels. */

        /* column data */
        lpLineData pdata;       /* ptr to array of nlines of LineData */

        /* selection/dragging */
        UINT    trackmode;      /* current mouse-tracking mode */
        int     tracknr;        /* col or row being resized */
        int     trackline1;     /* currently drawn track lines */
        int     trackline2;
        BOOL    selvisible;     /* used during mouse-down: T if sel drawn */
        TableSelection select;

        // tab expansion
        int     tabchars;

        // show whitespace chars
        BOOL    show_whitespace;

} Table, *lpTable;

/* trackmode constants */
#define TRACK_NONE              0
#define TRACK_COLUMN            1
#define TRACK_CELL              2

/* private flags in CellData struct */
#define CELL_VALID      1

/* window extra bytes are used to hold the owner, heap and Table structs */
#define WW_OWNER        0                               /* HWND of owner */
#define WW_HEAP         (WW_OWNER + sizeof(HWND))       /* gmem heap */
#define WL_TABLE        (WW_HEAP + sizeof(HANDLE))      /* lpTable */
#define WLTOTAL         (WL_TABLE + sizeof(lpTable))    /* total extra bytes */

/* ---------- global data -------------------*/

extern HPEN hpenDotted;         /* in table.c */
extern HANDLE hVertCurs;        /* in table.c */
extern HANDLE hNormCurs;        /* in table.c */

/*------function prototypes ---------------------------------------*/

/* in table.c */

void gtab_init(void);    /* called from DLL startup function */
INT_PTR gtab_sendtq(HWND hwnd, UINT cmd, LPARAM lParam);
void gtab_invallines(HWND hwnd, lpTable ptab, int start, int count);
void gtab_setsize(HWND hwnd, lpTable ptab);
void gtab_calcwidths(HWND hwnd, lpTable ptab);
void gtab_deltable(HWND hwnd, lpTable ptab);
BOOL gtab_alloclinedata(HWND hwnd, HANDLE heap, lpTable ptab);

/* in tpaint.c */
void gtab_paint(HWND hwnd);
void gtab_paintline(HWND hwnd, HDC hdc, lpTable ptab, int line, BOOL show_whitespace, BOOL fPrinting);
void gtab_paintunused(HWND hwnd, HDC hdc, lpTable ptab, int y);
void gtab_vsep(HWND hwnd, lpTable ptab, HDC hdc);
void gtab_hsep(HWND hwnd, lpTable ptab, HDC hdc);
void gtab_invertsel(HWND hwnd, lpTable ptab, HDC hdc_in);
void gtab_drawvertline(HWND hwnd, lpTable ptab);

/* in tscroll.c */
void gtab_dovscroll(HWND hwnd, lpTable ptab, long change);
void gtab_dohscroll(HWND hwnd, lpTable ptab, long change);
long gtab_linetorow(HWND hwnd, lpTable ptab, int line);
int gtab_rowtoline(HWND hwnd, lpTable ptab, long row);
void gtab_msg_vscroll(HWND hwnd, lpTable ptab, int opcode, int pos);
void gtab_msg_hscroll(HWND hwnd, lpTable ptab, int opcode, int pos);
void gtab_select(HWND hwnd, lpTable ptab, long row, long col, long nrows, long ncells, BOOL bNotify);
void gtab_enter(HWND hwnd, lpTable ptab, long row, long col, long nrows, long ncells);
void gtab_press(HWND hwnd, lpTable ptab, int x, int y);
void gtab_rightclick(HWND hwnd, lpTable ptab, int x, int y);
void gtab_release(HWND hwnd, lpTable ptab, int x, int y);
void gtab_move(HWND hwnd, lpTable ptab, int x, int y);
void gtab_dblclick(HWND hwnd, lpTable ptab, int x, int y);
void gtab_showsel(HWND hwnd, lpTable ptab, BOOL bToBottom);
void gtab_showsel_middle(HWND hwnd, lpTable ptab, long dyRowsFromTop);
int gtab_key(HWND hwnd, lpTable ptab, int vkey);
int gtab_mousewheel(HWND hwnd, lpTable ptab, DWORD fwKeys, int zDelta);

/* in tprint.c */
BOOL gtab_print(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext);
void gtab_boxcell(HWND hwnd, HDC hdc, LPRECT rcp, LPRECT pclip, UINT boxmode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\sockets.c ===
/*************************************************************************************************\
 *
 * SOCKETS.C
 *
 * This file contains routines used for establishing Sockets connections.
 *
\*************************************************************************************************/


#include <precomp.h>
#include <winsock.h>


/* ---- Local variables and #defines ----
 */

WSADATA WSAData;


#define MAX_PENDING_CONNECTS 4  /* The backlog allowed for listen() */

static PCHAR DBG_WSAERRORTEXT = "%s failed at line %d in %s: Error %d\n";

#define WSAERROR(func)  \
//      ERROR(( DBG_WSAERRORTEXT, func, __LINE__, __FILE__, WSAGetLastError() ))



/* Error message macro:
 */
#ifdef SOCKETS
#undef SOCKETS
#endif
#define SOCKETS( args ) DBGMSG( DBG_SOCKETS, args )


/* ---- Local function prototypes ----
 */



/* ---- Function definitions ----
 */

/****************************************************************************\
*
*    FUNCTION:  FillAddr(HWND, PSOCKADDR_IN, LPSTR)
*
*    PURPOSE:  Retrieves the IP address and port number.
*
*    COMMENTS:
*        This function is called in two conditions.
*            1.) When a client is preparing to call connect(), or
*            2.) When a server host is going to call bind(), listen() and
*                accept().
*        In both situations, a SOCKADDR_IN structure is filled.
*        However, different fields are filled depending on the condition.
*
*   ASSUMPTION:
*      bConnect determines if the socket address is being set up for a listen()
*      (bConnect == TRUE) or a connect() (bConnect == FALSE)
*
*
*\***************************************************************************/
BOOL
FillAddr(
    HWND hWnd,
    PSOCKADDR_IN psin,
    LPSTR pServerName
    )
{
   DWORD dwSize;
   PHOSTENT phe;
   char szTemp[200];
   CHAR szBuff[80];

   psin->sin_family = AF_INET;

   /*
   **  If we are setting up for a listen() call (pServerName == NULL),
   **  fill servent with our address.
   */
   if (!pServerName)
   {
      /*
      **  Retrieve my ip address.  Assuming the hosts file in
      **  in %systemroot%/system/drivers/etc/hosts contains my computer name.
      */

      dwSize = sizeof(szBuff);
      GetComputerName(szBuff, &dwSize);
      CharLowerBuff( szBuff, dwSize );

   }

   /* gethostbyname() fails if the remote name is in upper-case characters!
    */
   else
   {
       strcpy( szBuff, pServerName );
       CharLowerBuff( szBuff, strlen( szBuff ) );
   }

   phe = gethostbyname(szBuff);
   if (phe == NULL) {

      wsprintf( szTemp, "%d is the error. Make sure '%s' is"
                " listed in the hosts file.", WSAGetLastError(), szBuff );
      MessageBox(hWnd, szTemp, "gethostbyname() failed.", MB_OK);
      return FALSE;
   }

   memcpy((char FAR *)&(psin->sin_addr), phe->h_addr, phe->h_length);

   return TRUE;
}



/* SocketConnect
 *
 * The counterpart to SocketListen.
 * Creates a socket and initializes it with the supplied TCP/IP
 * port address, then connects to a listening server.
 * The returned socket can be used to send() and recv() data.
 *
 * Parameters: TCPPort - The port to use.
 *             pSocket - A pointer to a SOCKET, which will be filled in
 *                 if the call succeeds.
 *
 * Returns:    TRUE if successful.
 *
 *
 * Created 16 November 1993 (andrewbe)
 *
 */
BOOL SocketConnect( LPSTR pstrServerName, u_short TCPPort, SOCKET *pSocket )
{
    SOCKET Socket;
    SOCKADDR_IN dest_sin;  /* DESTination Socket INternet */

    /* Create a socket:
     */
    Socket = socket( AF_INET, SOCK_STREAM, 0);

    if (Socket == INVALID_SOCKET)
    {
        WSAERROR( "socket()");

        return FALSE;
    }

    if (!FillAddr( NULL, &dest_sin, pstrServerName ) )
    {
        return FALSE;
    }

    dest_sin.sin_port = htons( TCPPort );

    /* Someone must be listen()ing for this to succeed:
     */
    if (connect( Socket, (PSOCKADDR)&dest_sin, sizeof( dest_sin)) == SOCKET_ERROR)
    {
        closesocket( Socket );
        WSAERROR("connect()");
        MessageBox(NULL,
                   "ERROR: Could not connect the socket. "
                     "It may be that the hardcoded Sleep() value "
                     "on the caller's side is not long enough.",
                   "Video Conferencing Prototype", MB_OK);
        return FALSE;
    }

    *pSocket = Socket;

    return TRUE;
}



/* SocketListen
 *
 * The counterpart to SocketConnect.
 * Creates a socket and initializes it with the supplied TCP/IP
 * port address, then listens for a connecting client.
 * The returned socket can be used to send() and recv() data.
 *
 * Parameters: TCPPort - The port to use.
 *             pSocket - A pointer to a SOCKET, which will be filled in
 *                 if the call succeeds.
 *
 * Returns:    TRUE if successful.
 *
 *
 * Created 16 November 1993 (andrewbe)
 *
 */
BOOL SocketListen( u_short TCPPort, SOCKET *pSocket )
{
    SOCKET Socket;
    SOCKADDR_IN local_sin;  /* Local socket - internet style */
    SOCKADDR_IN acc_sin;    /* Accept socket address - internet style */
    int acc_sin_len;        /* Accept socket address length */

    /* Create a socket:
     */
    Socket = socket( AF_INET, SOCK_STREAM, 0);

    if (Socket == INVALID_SOCKET)
    {
        WSAERROR( "socket()");

        return FALSE;
    }

    /*
    **  Retrieve the IP address and TCP Port number
    */

    if (!FillAddr(NULL, &local_sin, NULL ))
    {
        return FALSE;
    }

    /*
    **  Associate an address with a socket. (bind)
    */
    local_sin.sin_port = htons( TCPPort );

    if (bind( Socket, (struct sockaddr FAR *)&local_sin, sizeof(local_sin)) == SOCKET_ERROR)
    {
        WSAERROR( "bind()" );

        return FALSE;
    }


    if (listen( Socket, MAX_PENDING_CONNECTS ) == SOCKET_ERROR)
    {
        WSAERROR( "listen()" );

        return FALSE;
    }

    acc_sin_len = sizeof(acc_sin);

    Socket = accept( Socket, (struct sockaddr *)&acc_sin, (int *)&acc_sin_len );

    if (Socket == INVALID_SOCKET)
    {
        WSAERROR( "accept()" );

        return FALSE;
    }

    *pSocket = Socket;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\tree.h ===
/*
 * tree.h
 *
 * data type providing a map from a key to a value, where the value is
 * an arbitrary area of storage.
 *
 * The current implementation of this is a binary search tree with no
 * balancing, so it will be inefficient if the data is presented in
 * strict ascending or descending order.
 *
 * all memory is allocated from a gmem_* heap that is passed on
 * creation of the tree.
 *
 * include gutils.h before this.
 */

/* handle for a tree */
typedef struct tree FAR * TREE;

/* keys in these trees are DWORDs */
typedef DWORD TREEKEY;

/* some sort of place-holder understood only by tree_search and
 * tree_addafter
 */
typedef struct treeitem FAR * TREEITEM;

/* pointer to one of these place holders */
typedef TREEITEM FAR * PTREEITEM;



/*
 * create an empty tree and return a handle to it. Pass the heap to
 * be used for all memory allocations.
 */
TREE APIENTRY tree_create(HANDLE hHeap);


/* delete a tree and discard any associated memory. The tree need not be
 * empty. This will discard the elements of the tree; but if these
 * contained pointers to further data blocks, these will not be discarded-
 * you must free these before deleting the tree.
 */
void APIENTRY tree_delete(TREE tree);


/* add new element to the tree, mapping the key given to the value
 *
 * a block of data of length bytes will be inserted in the tree, mapped
 * to this key, a pointer to this block will be returned. if the
 * value pointer is non-null, the block value[0..length-1] will be copied
 * to the new block.
 *
 * if the key already exists, the value block will be replaced with the
 * new size and (if value is non-null) contents.
 */
LPVOID APIENTRY tree_update(TREE tree, TREEKEY key, LPVOID value, UINT length);


/* return a pointer to the value associated with a given key in this tree.
 * returns NULL if the key is not found.
 */
LPVOID APIENTRY tree_find(TREE tree, TREEKEY key);

/*
 * a common tree operation is to insert a new element into the
 * tree only if that key is not found, and otherwise to update in some
 * way the existing value. Using the standard functions above, that
 * would require one lookup for the tree_find, and then a second lookup
 * to insert the new element.
 *
 * the two functions below provide an optimisation over this. tree_search
 * will return the value if found; if not, it will return NULL, and set
 * pitem to a pointer to a place holder in the tree where the item
 * should be inserted. tree_addafter takes this placeholder as
 * an argument, and will insert the key/value in the tree at that point.
 *
 * as for tree_update, the value pointer can be NULL - in this case
 * the block is allocated on the tree, but not initialised.
 *
 * the return value from tree_addafter is a pointer to the value block in
 * the tree
 */
LPVOID APIENTRY tree_search(TREE tree, TREEKEY key, PTREEITEM place);

LPVOID APIENTRY tree_addafter(TREE tree, PTREEITEM place, TREEKEY key, LPVOID value,
			UINT length);


/* -- ctree ---------------
 *
 * this is a type of tree based on the tree_ data type above, that implements
 * counting for insertions of identical keys.
 *
 * ctree_update, if the key is unique, will insert the object and set the count
 * to 1. if the key is not unique, it will just increment the reference count.
 *
 * ctree_getcount returns the reference count for a tree.
 * ctree_find returns the first value inserted for that key, if any
 */

/*
 * create an empty counting-tree and return handle. pass in the gmem_init()
 * heap to be used for all memory allocations.
 */
TREE APIENTRY ctree_create(HANDLE hHeap);

/*
 * delete a tree and all memory associated directly with it.
 */
void APIENTRY ctree_delete(TREE tree);

/*
 * if the KEY is unique within the tree, insert the value and
 * set the count for that key to 1. If the key is not unique, add one to
 * the reference count for that key but leave the value untouched.
 */
LPVOID APIENTRY ctree_update(TREE tree, TREEKEY key, LPVOID value, UINT length);

/*
 * find the reference count for the given key
 */
long APIENTRY ctree_getcount(TREE tree, TREEKEY key);

/*
 * return the value for the given key (note this will be the value for
 * the first insertion of this key
 */
LPVOID APIENTRY ctree_find(TREE tree, TREEKEY key);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\list.h ===
/*----------------------
                   |         List          |
                    ----------------------*/
/* Laurie Griffiths, C version  5/12/91                                */
/* worth also looking at nt\public\sdk\inc\ntrtl.h which also has some
|  low level list pointer chaining stuff in it
*/
/* Note here that Modula-2 style comments (*like this*) are used
   within examples which are already within C comments to indicate
   where comments should go in the examples
*/

/*------------------------------------------------------------------------
| Abstract data type LIST OF (*untyped*) object.
| Different lists can have different types of object in them
| Different items in a list can have different types of object in them.
| The price of this lack of typing is that you have a slightly more
| awkward syntax and you get no help from the compiler if you try to
| put the wrong type of data into the list.
|
| The list is implemented as a collection of items.  Within the item
| somewhere is the object.
|
| Objects are stored UNALIGNED within items.
|
| Use:
|
|   #include <list.h>
|   . . .
|   LIST MyList; (* or LIST liMyList for Hungarians *)
|   . . .
|   MyList = List_Create();
|   List_AddLast(MyList,&MyObject,sizeof(OBJECT));
|
| In the abstract a LIST is a list of objects.  The representation
| is a linked collection of items.  The manner of the linking is
| implementation dependent (as I write this it's linear but when you
| read it it might be a tree (See Knuth for why a tree)).
|
| A LIST is a "handle" for a list which may be thought of as a POINTER
| (whether it is really a pointer or not is implementation dependent)
| so that it can be copied at the risk of creating an alias. e.g.
|
|   L = List_Create();
|   L1 = L;             (* L and L1 are both healthy and empty *)
|   List_AddFirst(L, &elem, sizeof(elem));
|   (* L1 may also appear to have one object, there again it may be sick *)
|   L1 = L;               (* Now they both surely see the one element *)
|   List_Destroy(&L1);    (* L is almost certainly sick now too *)
|   L1 = List_Create();   (* All bets off as to what L is like now
|                            but L1 is empty and healthy
|                         *)
|
| If two handles compare equal then the lists must be equal, but
| unequal handles could address two similar lists i.e. the same list
| of objects held in two different LISTs of items (like pointers).
|
| A LIST can be transferred from one variable to another like this:
|
|   NewList = OldList;           (* copy the handle *)
|   OldList = List_Create();     (* kill the old alias *)
|
| and the Create statement can be omitted if OldList is never touched again.
|
| Items are identified by Cursors.  A cursor is the address of an object
| within an item in the list. i.e. it is the address of the piece of your
| data that you had inserted.  (It is probably NOT the address of the item).
| It is typed as pointer to void here, but you should declare it as a pointer
| to whatever sort of object you are putting in the LIST.
|
| The operations AddFirst, AddLast, AddAfter and AddBefore
| all copy elements by direct assignment.  If an element is itself
| a complex structure (say a tree) then this will only copy a pointer
| or an anchor block or whatever and give all the usual problems of
| aliases.  Clear will make the list empty, but will only free the
| storage that it can "see" directly.  SplitBefore or Split After may
| also perform a Clear operation.  To deal with fancy data structures
| use New rather than Add calls and copy the data yourself
|   e.g.  P = List_NewLast(MyList, sizeof(MyArray[14])*(23-14+1));
|         CopyArraySlice(P, MyArray, 14, 23);
|
| The operations NewFirst, NewLast, NewAfter, NewBefore, First and Last
| all return pointers to elements and thus allow you to do any copying.
| This is how you might copy a whole list of fancy structures:
|
|    void CopyFancyList(LIST * To, LIST From)
|             (* Assumes that To has been Created and is empty *)
|    { PELEMENT Cursor;
|      PELEMENT P;
|
|      List_TRAVERSE(From, Cursor);
|      { P = List_NewLast(To, sizeof(element) );
|        FancyCopy(P, Cursor);    (* Copy so that *Cursor==*P afterwords *)
|      }
|    }
 --------------------------------------------------------------------*/

  typedef struct item_tag FAR * LIST;
  typedef LIST FAR * PLIST;

  void APIENTRY List_Init(void);
  /* MUST BE CALLED BEFORE ANY OF THE OTHER FUNCTIONS. Don't ask, just do it */

  void APIENTRY List_Term(void);
  /* Call at end of application (does some checking and resource freeing) */

  void APIENTRY List_Dump(LPSTR Header, LIST lst);
  /* Dump the internals to current output stream -- debug only */

  void APIENTRY List_Show(LIST lst);
  /* Dump hex representation of handle to current out stream -- debug only */

  LIST APIENTRY List_Create(void);
  /* Create a list.  It will be initially empty */

  void APIENTRY List_Destroy(PLIST plst);
  /* Destroy *plst.  It does not need to be empty first.
  |  All storage directly in the list wil be freed.
  */

  void APIENTRY List_AddFirst(LIST lst, LPVOID pObject, UINT uLen);
  /* Add an item holding Object to the beginning of * plst */

  LPVOID APIENTRY List_NewFirst(LIST lst, UINT uLen);
  /* Return the address of the place for Len bytes of data in a new
  |  item at the start of *plst.
  |  The storage is zeroed BEFORE chaining it in.
  */

  void APIENTRY List_DeleteFirst(LIST lst);
  /* Delete the first item in lst.  Error if lst is empty */

  void APIENTRY List_AddLast(LIST lst, LPVOID pObject, UINT uLen);
  /* Add an item holding Object to the end of lst */

  LPVOID APIENTRY List_NewLast(LIST lst, UINT uLen);
  /* Return the address of the place for uLen bytes of data in a new
  |  item at the end of lst
  |  The storage is zeroed BEFORE chaining it in.
  */

  void APIENTRY List_DeleteLast(LIST lst);
  /* Delete the last item in lst.  Error if lst is empty */

  void APIENTRY List_AddAfter( LIST lst
                    , LPVOID Curs
                    , LPVOID pObject
                    , UINT uLen
                    );
  /*--------------------------------------------------------------------
  | Add an item holding *pObject to lst immediately after Curs.
  | List_AddAfter(lst, NULL, pObject, Len) adds it to the start of the lst
   ---------------------------------------------------------------------*/

  LPVOID APIENTRY List_NewAfter(LIST lst, LPVOID Curs, UINT uLen);
  /*--------------------------------------------------------------------
  | Return the address of the place for uLen bytes of data in a new
  | item immediately after Curs.
  | List_NewAfter(Lst, NULL, uLen) returns a pointer
  | to space for uLen bytes in a new first element.
  | The storage is zeroed BEFORE chaining it in.
   ---------------------------------------------------------------------*/

  void APIENTRY List_AddBefore( LIST lst
                     , LPVOID Curs
                     , LPVOID pObject
                     , UINT uLen
                     );
  /*--------------------------------------------------------------------
  | Add an item holding Object to lst immediately before Curs.
  | List_AddBefore(Lst, NULL, Object, uLen) adds it to the end of the list
   ---------------------------------------------------------------------*/

  LPVOID APIENTRY List_NewBefore(LIST lst, LPVOID Curs, UINT uLen );
  /*--------------------------------------------------------------------
  | Return the address of the place for uLen bytes of data in a new
  | item immediately before Curs.
  | List_NewBefore(Lst, NULL, uLen) returns a pointer
  | to space for uLen bytes in a new last element.
  | The storage is zeroed BEFORE chaining it in.
   ---------------------------------------------------------------------*/

#if 0
// these functions are not actually defined...

  void APIENTRY List_DeleteAndNext(LPVOID * pCurs);
  /* Delete the item that *pCurs identifies and move *pCurs to the Next item */

  void APIENTRY List_DeleteAndPrev(LPVOID * pCurs);
  /* Delete the item that *pCurs identifies and move *pCurs to the Prev item */
#endif

  void APIENTRY List_Delete(LPVOID Curs);
  /*------------------------------------------------------------------
  | Delete the item that Curs identifies.
  | I'm not too sure about this:
  | This will be only a few (maybe as little as 3) machine instructions
  | quicker than DeleteAndNext or DeleteAndPrev but leaves Curs dangling.
  | It is therefore NOT usually to be preferred.
  | It may be useful when you have a function which returns an LPVOID
  | since the argument does not need to be a variable.
  |     Trivial example: List_Delete(List_First(L));
  | I am not sure which is more damaging, a dangling pointer which points
  | at garbage or one that points at something that is real live data.
   -------------------------------------------------------------------*/

  int APIENTRY List_ItemLength(LPVOID Curs);
  /* Return the length of the object identified by the cursor Curs */

  /*------------------------------------------------------------------
  | TRAVERSING THE ULIST
  |
  | LIST lst;
  | object * Curs;
  | . . .
  | Curs = List_First(lst);
  | while (Curs!=NULL)
  | {  DoSomething(*Curs);   (* Curs points to YOUR data not to chain ptrs *)
  |    Curs = List_Next(Curs);
  | }
  |
  | This is identically equal to
  | List_TRAVERSE(lst, Curs)  // note NO SEMI COLON!
  | {  DoSomething(*Curs); }
   -------------------------------------------------------------------*/

  #define List_TRAVERSE(lst, curs)  for(  curs=List_First(lst)            \
                                       ;  curs!=NULL                      \
                                       ;  curs = List_Next((LPVOID)curs)  \
                                       )
  #define List_REVERSETRAVERSE(lst, curs)  for(  curs=List_Last(lst)             \
                                              ;  curs!=NULL                      \
                                              ;  curs = List_Prev((LPVOID)curs)  \
                                              )

  LPVOID APIENTRY List_First(LIST lst);
  /*------------------------------------------------------------------
  | Return the address of the first object in lst
  |  If lst is empty then Return NULL.
  --------------------------------------------------------------------*/

  LPVOID APIENTRY List_Last(LIST lst);
  /*------------------------------------------------------------------
  | Return the address of the last object in lst
  | If lst is empty then return NULL.
  --------------------------------------------------------------------*/

  LPVOID APIENTRY List_Next(LPVOID Curs);
  /*------------------------------------------------------------------
  | Return the address of the object after Curs^.
  | List_Next(List_Last(lst)) == NULL;  List_Next(NULL) is an error.
  | List_Next(List_Prev(curs)) is illegal if curs identifies first el
  --------------------------------------------------------------------*/

  LPVOID APIENTRY List_Prev(LPVOID Curs);
  /*------------------------------------------------------------------
  | Return the address of the object after Curs^.
  | List_Prev(List_First(L)) == NULL;  List_Prev(NULL) is an error.
  | List_Prev(List_Next(curs)) is illegal if curs identifies last el
  --------------------------------------------------------------------*/

  /*------------------------------------------------------------------
  |  Whole list operations
   -----------------------------------------------------------------*/
  void APIENTRY List_Clear(LIST lst);
  /* arrange that lst is empty after this */

  BOOL APIENTRY List_IsEmpty(LIST lst);
  /* Return TRUE if and only if lst is empty */

  void APIENTRY List_Join(LIST l1, LIST l2);
  /*-----------------------------------------------------------------------
  | l1 := l1||l2; l2 := empty
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets all the elements of l1 in their original order followed by
  | all the elements of l2 in the order they were in in l2.
  | l2 becomes empty.
   ------------------------------------------------------------------------*/

  void APIENTRY List_InsertListAfter(LIST l1, LIST l2, LPVOID Curs);
  /*-----------------------------------------------------------------------
  | l1 := l1[...Curs] || l2 || l1[Curs+1...]; l2 := empty
  | Curs=NULL means insert l2 at the start of l1
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets the elements of l1 from the start up to and including the element
  | that Curs points at, in their original order,
  | followed by all the elements that were in l2, in their original order,
  | followed by the rest of l1
   ------------------------------------------------------------------------*/

  void APIENTRY List_InsertListBefore(LIST l1, LIST l2, LPVOID Curs);
  /*-----------------------------------------------------------------------
  | l1 := l1[...Curs-1] || l2 || l1[Curs...]; l2 := empty
  | Curs=NULL means insert l2 at the end of l1
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets the elements of l1 from the start up to but not including the
  | element that Curs points at, in their original order,
  | followed by all the elements that were in l2, in their original order,
  | followed by the rest of l1.
   ------------------------------------------------------------------------*/

  void APIENTRY List_SplitAfter(LIST l1, LIST l2, LPVOID Curs);
  /*-----------------------------------------------------------------------
  | Let l1 be l1 and l2 be l2
  | Split l2 off from the front of l1:    final l2,l1 = original l1
  |
  | Split l1 into l2: objects of l1 up to and including Curs object
  |               l1: objects of l1 after Curs
  | Any original contents of l2 are freed.
  | List_Spilt(l1, l2, NULL) splits l1 before the first object so l1 gets all.
  | The elements themselves are not moved.
   ------------------------------------------------------------------------*/

  void APIENTRY List_SplitBefore(LIST l1, LIST l2, LPVOID Curs);
  /*----------------------------------------------------------------------
  | Split l2 off from the back of l1:  final l1,l2 = original l1
  |
  | Split l1 into l1: objects of l1 up to but not including Curs object
  |               l2: objects of l1 from Curs onwards
  | Any original contants of l2 are freed.
  | List_Spilt(l1, l2, NULL) splits l1 after the last object so l1 gets all.
  | The elements themselves are not moved.
   -----------------------------------------------------------------------*/

  int APIENTRY List_Card(LIST lst);
  /* Return the number of items in L */

  /*------------------------------------------------------------------
  | Error handling.
  |
  | Each list has within it a flag which indicates whether any illegal
  | operation has been detected (e.g. DeleteFirst when empty).
  | Rather than have a flag on every operation, there is a flag held
  | within the list that can be queried when convenient.  Many operations
  | do not have enough redundancy to allow any meaningful check.  This
  | is a design compromise (for instance to allow P = List_Next(P);
  | rather than P = List_Next(L, P); which is more awkward, especially
  | if L is actually a lengthy phrase).
  |
  | List_IsOK tests this flag (so is a very simple, quick operation).
  | MakeOK sets the flag to TRUE, in other words to accept the current
  | state of the list.
  |
  | It is possible for a list to be damaged (whether or not the flag
  | says OK) for instance by the storage being overwritten.
  |
  | List_Check attempts to verify that the list is sound (for instance where
  | there are both forward and backward pointers they should agree).
  |
  | List_Recover attempts to make a sound list out of whatever debris is left.
  | If the list is damaged, Recover may trap (e.g. address error) but
  | if the list was damaged then ANY operation on it may trap.
  | If Check succeeds without trapping then so will Recover.
   -----------------------------------------------------------------*/

  BOOL APIENTRY List_IsOK(LIST lst);
  /* Check return code */

  void APIENTRY List_MakeOK(LIST lst);
  /* Set return code to good */

  BOOL APIENTRY List_Check(LIST lst);
  /* Attempt to validate the chains */

  void APIENTRY List_Recover(PLIST plst);
  /* Desperate stuff.  Attempt to reconstruct something */

/*------------------------------------------------------------------
|  It is designed to be as easy to USE as possible, consistent
|  only with being an opaque type.
|
|  In particular, the decision to use the address of an object a list cursor
|  means that there is a small amount of extra arithmetic (in the
|  IMPLEMENTATION) in cursor operations (e.g. Next and Prev).
|  and spurious arguments are avoided whenever possible, even though
|  it would allow greater error checking.
|
| Of the "whole list" operations, Clear is given because it seems to be
| a common operation, even though the caller can implement it with almost
| the same efficiency as the List implementation module.
| Join, Split and InsertListXxx cannot be implemented efficiently without
| knowing the representation.
 --------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\table.h ===
/*
 * table.h
 *
 * public interface definition for table window class.
 *
 * include after gutils.h and commdlg.h
 */

/*
 * The table class communicates with its 'owner' window to
 * get the layout info and the data to display. The owner window handle
 * can be sent as the lParam in CreateWindow - if not, the parent window will
 * be used.
 *
 * After creating the window, send it a TM_NEWID message, with a 'data id'
 * as the lParam. This is any non-zero 32-bit value. The table will then call
 * back to its owner window to find out how many rows/columns, then to fetch
 * the name/properties of each column, and finally to get the data to display.
 *
 * Send TM_NEWID of 0 to close (or destroy the window) - wait for TQ_CLOSE
 * (in either case) before discarding data. Send
 * TM_REFRESH if data or row-count changes; send TM_NEWLAYOUT if column
 * properties or nr cols change etc - this is the same as sending TM_NEWID
 * except that no TQ_CLOSE happens on TM_NEWLAYOUT.
 *
 * TQ_SELECT is sent whenever the current selection changes. TQ_ENTER is sent
 * when enter or double-click occurs.
 */

/* -------class and message names --------------------------------------*/

/* create a window of this class */
#define  TableClassName "GTableClass"


/* all messages to the owner window are sent with this message.
 * call RegisterWindowsMessage with this string for the message UINT.
 */
#define TableMessage  "GTableQuery"

/* -------- messages to and from table class  --------------------------*/

/* messages to owner window are:
 *	message:	TableMessage
 *	wParam:		command code (below)
 * 	lParam:		struct pointer according to code
 * below is list of wParam codes & associated lParam struct
 */
#define TQ_GETSIZE	1	/* lParam: lpTableHdr */
#define	TQ_GETCOLPROPS	2	/* lParam: lpColPropList */
#define TQ_GETDATA	3	/* lParam: lpCellDataList */
#define TQ_PUTDATA	4	/* lParam: lpCellDataList */
#define TQ_SELECT	5	/* lParam: lpTableSelection */
#define TQ_ENTER	6	/* lParam: lpTableSelection */
#define TQ_CLOSE	7	/* lParam: the data id to be closed */

/* optional */
#define TQ_SCROLL	8	/* lParam: the new top row nr */
#define TQ_TABS         9       /* lParam: LONG *, write tab here */
#define TQ_SHOWWHITESPACE  10   /* lParam: LONG *, write show_whitespace value here */

/* messages to Table class */

/* data, or nrows has changed  wParam/lParam null*/
#define TM_REFRESH	(WM_USER)

/* nr cols/props/layout has changed  - wparam/lparam null */
#define TM_NEWLAYOUT	(WM_USER+1)

/* close old id, and display new - wParam null, lParam has new id */
#define TM_NEWID	(WM_USER+2)

/* select and show this area - wParam null, lParam is lpTableSelection */
#define TM_SELECT	(WM_USER+3)

/* please print current table - wParam null, lParam either null
 * or lpPrintContext.
 */
#define TM_PRINT	(WM_USER+4)

/* return the top row in the window. If wParam is TRUE, then set
 * lParam to be the new toprow. top row is the number of rows scrolled down
 * from the top. Thus the first visible non-fixed row is toprow+fixedrows
 */
#define TM_TOPROW	(WM_USER+5)


/* return the end row visible. This is the 0-based rownr of the last
 * visible row in the window
 */
#define TM_ENDROW	(WM_USER+6)

/* new rows have been added to the end of the table, but no other
 * rows or cols or properties have been changed.
 * wParam contains the new total nr of rows. lParam contains the id
 * in case this has changed.
 */
#define TM_APPEND	(WM_USER+7)

/*
 * return the current selection - lParam is a lpTableSelection
 */
#define TM_GETSELECTION (WM_USER+8)

/*
 * set the tab width - wParam null, lParam is new tab width
 */
#define TM_SETTABWIDTH (WM_USER+9)

/*-----display properties -------------------------------------------------*/

/*
 * display properties struct. can be set for whole table, for
 * each column, or for each cell. When looking for
 * a property, we search cell->column->table
 */
typedef struct {
	UINT valid;		/* flags (below) for what props we set */

/* remaining fields only valid when corresponding flag set in valid */

	DWORD forecolour;	/* RGB colour value */
	DWORD forecolourws;	/* ditto */
	DWORD backcolour;	/* ditto */
	/* font to use - also set through WM_SETFONT. owner application
	 * is responsible for DeleteObject call when no longer used
	 */
	HFONT hFont;		/* handle to font  - caller should delete*/
	UINT alignment;		/* flags below */
	UINT box;		/* whether cell boxed (see below) */

	/* width/height settings not valid at cell level - only table or col.*/
	int width;		/* pixel width of this cell/column */
	int height;		/* pixel cell height */
} Props, FAR * lpProps;

/* valid flags for fields that are changed in this Props struct */
#define P_FCOLOUR	0x01
#define P_FCOLOURWS	0x02
#define P_BCOLOUR	0x04
#define P_FONT		0x08
#define P_ALIGN		0x10
#define P_BOX		0x20
#define P_WIDTH		0x40
#define P_HEIGHT	0x80

/* box settings  or-ed together */
#define P_BOXTOP	1
#define P_BOXBOTTOM	2
#define P_BOXLEFT	4
#define P_BOXRIGHT	8
#define P_BOXALL	0xF

/* alignment settings (expand later to include various tab-align settings */
#define P_LEFT		0
#define P_RIGHT		1
#define P_CENTRE	2

/* default tab width in chars */
#define TABWIDTH_DEFAULT      8

/* --- main header -------------------------------------------------------*/

/* this struct is the master information about a table. It is
 * passed to the owner window with the id field filled in; fill in
 * all remaining fields and return.
 */
typedef struct {
        DWORD_PTR id;           /* owner's data id */

	/* please fill in rest: */
	long nrows;		/* how many rows ? TM_REFRESH to change */
	int ncols;		/* how many columns ? TM_NEWLAYOUT to chg */

	int fixedrows;		/* for headers - usually 0 or 1 */
	int fixedcols;		/* for hdrs - 0 or 1 normally */
	BOOL fixedselectable;	/* is fixed area selectable ? */
	BOOL hseparator;	/* is there a horz. line after fixed rows */
	BOOL vseparator;	/* is there a vert. line after fixed rows */

	UINT selectmode;	/* multiple/single selection - flags below*/
	BOOL sendscroll;	/* TRUE if TQ_SCROLL to be sent on scrolling*/

	Props props;
} TableHdr, FAR * lpTableHdr;

/*
 * selection mode;
 *
 * choose TM_CELL or TM_ROW, and TM_SINGLE or TM_MANY, and
 * TM_SOLID or TM_FOCUS and or them together.
 *
 */
#define TM_ROW		1	/* selectable items are rows */
#define TM_CELL		0	/* selectable items are cells */

#define TM_MANY		2	/* multiple selects possible */
#define TM_SINGLE	0	/* single item selectable at once only */

#define TM_SOLID	0	/* (default) use a solid black for selection*/
#define TM_FOCUS	4	/* use a dotted focus rect for selection */


/* --------- column header structs --------------------------------------*/

/*
 * this struct is sent to request column width and properties -
 * owner window must fill nchars and props.valid, at minimum.
 */
typedef struct {
	int nchars;	/* expected text width in chars */
	Props props;
} ColProps, FAR * lpColProps;


/* this is a set of column requests - owner should fill each one*/
typedef struct {
        DWORD_PTR id;           /* caller's id for data */
	int startcol;		/* zero-based column nr of first request */
	int ncols;		/* nr of columns in this set */
	lpColProps plist;	/* ptr to _array_ of ColProps */
} ColPropsList, FAR * lpColPropsList;


/* --- cell data structs ---------------------------------------------*/

/* this is the per-cell data struct.
 * When providing data (responding to TQ_GETDATA), fill out ptext[] and
 * props as appropriate. ptext will be pre-allocated with nchars bytes of
 * space. This may be larger than ColProps->nchars if the user has
 * stretched this column's width on screen
 *
 * don't re-alloc ptext, or change flags.
 */
typedef struct {
	int nchars;		/* space in buffer */
	LPSTR ptext;		/* ptr to nchars of text space */
	Props props;		/* per-cell props */
	DWORD flags;		/* private table class flags */
	LPWSTR pwzText;		/* ptr to nchars of WCHAR space */
} CellData, FAR * lpCellData;

/* list of cell data structures - please fill out all of these*/
typedef struct {
        DWORD_PTR id;           /* caller's id for data */
	long row;		/* zero-based row nr to fetch */
	int startcell;		/* zero-based cell nr on this row */
	int ncells;		/* count of cells to fetch */
	lpCellData plist;	/* ptr to array CellData[ncells] */
} CellDataList, FAR * lpCellDataList;


/*----- current selection----------------------------------------------*/

/*
 * describes the current selection - a rectangular selection area
 *
 * Note that if the TM_MANY selection mode is used, startrow and startcell will
 * be the end-point (most recently selected end) of the selection, and
 * nrows, ncells may be positive or negative. +1 and -1 both mean just the
 * 1 row startrow, -2 means startrow and the one before, etc. 0 nrows means
 * no valid selection.
 */
typedef struct {
        DWORD_PTR id;           /* caller's id for data */
	long startrow;		/* zero-based row nr of start of sel. */
	long startcell;		/* zero-based col nr of  start of sel */
	long nrows;		/* vertical depth of selection */
	long ncells;		/* horz width of selection */
	long dyRowsFromTop;		/* -1 means used auto-center logic, otherwise put selection this many rows from top */
} TableSelection, FAR * lpTableSelection;



/*----- print context -----------------------------------------------*/

/* describes the margin settings for the print job - these are in CMs*/
typedef struct {
	int left;		/* edge of paper to start of print area */
	int right;		/* edge of paper to start of print area */
	int top;		/* edge of paper to start of hdr */
	int bottom;		/* end of hdr to end of paper */
	int topinner;		/* start of hdr to start of data */
	int bottominner;	/* end of data to start of hdr */
} Margin, FAR * lpMargin;

/* position and clipping info - only used by table class
 */
typedef struct {
	int start;		/* co-ord of cell start (left or top) */
	int clipstart;		/* start of clipping (vis area) */
	int clipend;		/* end of clipping (vis area) */
	int size;		/* pixel size of cell (width or height) */
} CellPos, FAR * lpCellPos;


/* one of these for each header lines (top and bottom) */
typedef struct {
	CellPos xpos, ypos;	/* private: for table-class use only */
	Props props;
	LPSTR ptext;
} Title, FAR * lpTitle;

/* Print context data structure - any or all 4 pointers may be null */
typedef struct {
        DWORD_PTR id;           /* id of table to print */
	lpTitle head;
	lpTitle foot;
	lpMargin margin;
	PRINTDLG FAR * pd;
} PrintContext, FAR * lpPrintContext;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\tpaint.c ===
/*
 * standard table class.
 *
 * paint functions.
 *
 * see table.h for interface description
 */

#include <precomp.h>

#include "table.h"
#include "tpriv.h"

#ifdef WIN32

int
GetTextExtent(HDC hdc, LPSTR text, INT len)
{
    SIZE sz;

    GetTextExtentPoint(hdc, text, len, &sz);
    return(sz.cx);
}
#endif

void gtab_updatecontig(HWND hwnd, lpTable ptab, int line, int cell1, int count);

/* change all cr/lf chars in input text to nul chars (used to be spaces, not sure why) */
void gtab_delcr(LPSTR ptext)
{
	LPSTR chp;

	if (ptext == NULL) {
		return;
	}
	for(chp = ptext; (chp = My_mbschr(chp, '\r')) != NULL; ) {
		*chp = '\0';
	}
	for(chp = ptext; (chp = My_mbschr(chp, '\n')) != NULL; ) {
		*chp = '\0';
	}
}
void gtab_delcrW(LPWSTR pwzText)
{
	LPWSTR pwch;

	if (pwzText)
		for(pwch = pwzText; *pwch; pwch++)
			if (*pwch == '\r' || *pwch == '\n')
				*pwch = 0;
}

/* ensure that all visible cells in the given line have valid
 * text and property contents. loop through the cells, picking out
 * contiguous blocks of visible, invalid cells and call
 * gtab_updatecontig to update these from the owner window.
 */
void
gtab_updateline(HWND hwnd, lpTable ptab, int line)
{
	lpCellPos ppos;
	int cell1, cellcount;
	lpLineData pline;
	lpCellData cd;
	int i;

	if (line < 0 || line >= ptab->nlines)
		return;

	pline = &ptab->pdata[line];
	cell1 = 0;
	cellcount = 0;
	for (i = 0; i < ptab->hdr.ncols; i++) {
		ppos = &ptab->pcellpos[i];
		cd = &pline->pdata[i];
		if (ppos->clipstart < ppos->clipend) {
			if ((cd->flags & CELL_VALID) == 0) {
				/* add a cell to the list to be updated*/
				if (cellcount++ == 0) {
					cell1 = i;
				}
			} else {
				/* this cell already valid - so end of
				 * a contig block. if the contig
				 * block just ended contained cells to update,
				 * do it now
				 */
				if (cellcount > 0) {
					gtab_updatecontig(hwnd, ptab,
					  line, cell1, cellcount);
				}
				cellcount = 0;
			}
		}
		/* cell not visible - end of a contig block. If it was a
		 * non-empty contig block, then update it now.
		 */
		if (cellcount > 0)  {
			gtab_updatecontig(hwnd, ptab, line, cell1, cellcount);
			cellcount = 0;	
		}
	}
	if (cellcount > 0) {
		gtab_updatecontig(hwnd, ptab, line, cell1, cellcount);
		cellcount = 0;
	}
}

/*
 * update a contiguous block of invalid cells by calling the owner window
 */
void
gtab_updatecontig(HWND hwnd, lpTable ptab, int line, int cell1, int count)
{
	lpLineData pline;
	lpCellData cd;
	CellDataList list;
	lpProps colprops;
	int i;
	COLORREF rgb;

	pline = &ptab->pdata[line];
	cd = &pline->pdata[cell1];

	list.id = ptab->hdr.id;
	list.row = gtab_linetorow(hwnd, ptab, line);
	list.startcell = cell1;
	list.ncells = count;
	list.plist = cd;

	/* clear out prop flags */
	rgb = GetSysColor(COLOR_WINDOW);
	for (i = 0; i < count; i++) {
		cd[i].props.valid = P_BCOLOUR;
		cd[i].props.backcolour = rgb;
		if (cd[i].nchars > 0) {
			cd[i].ptext[0] = '\0';
			if (cd[i].pwzText) {
				cd[i].pwzText[0] = '\0';
			}
		}
	}

	if (list.row < ptab->hdr.nrows) {
		gtab_sendtq(hwnd, TQ_GETDATA, (LPARAM) &list);
	}

	/* for each cell, mark valid and set properties */
	for (i = 0; i < count; i++) {
		cd[i].flags |= CELL_VALID;
		gtab_delcr(cd[i].ptext);
		gtab_delcrW(cd[i].pwzText);
		/* fetch properties from hdr and colhdr */
		colprops = &ptab->pcolhdr[i + cell1].props;
		if (!(cd[i].props.valid & P_FCOLOUR)) {
			if (colprops->valid & P_FCOLOUR) {
				cd[i].props.valid |= P_FCOLOUR;
				cd[i].props.forecolour = colprops->forecolour;
			} else if (ptab->hdr.props.valid & P_FCOLOUR) {
				cd[i].props.valid |= P_FCOLOUR;
				cd[i].props.forecolour =
					ptab->hdr.props.forecolour;
			}
		}

		if (!(cd[i].props.valid & P_FCOLOURWS)) {
			if (colprops->valid & P_FCOLOURWS) {
				cd[i].props.valid |= P_FCOLOURWS;
				cd[i].props.forecolourws = colprops->forecolourws;
			} else if (ptab->hdr.props.valid & P_FCOLOURWS) {
				cd[i].props.valid |= P_FCOLOURWS;
				cd[i].props.forecolourws =
					ptab->hdr.props.forecolourws;
			}
		}

		if (!(cd[i].props.valid & P_BCOLOUR)) {
			if (colprops->valid & P_BCOLOUR) {
				cd[i].props.valid |= P_BCOLOUR;
				cd[i].props.backcolour = colprops->backcolour;
			} else if (ptab->hdr.props.valid & P_BCOLOUR) {
				cd[i].props.valid |= P_BCOLOUR;
				cd[i].props.backcolour =
					ptab->hdr.props.backcolour;
			}
		}

		if (!(cd[i].props.valid & P_FONT)) {
			if (colprops->valid & P_FONT) {
				cd[i].props.valid |= P_FONT;
				cd[i].props.hFont = colprops->hFont;
			} else if (ptab->hdr.props.valid & P_FONT) {
				cd[i].props.valid |= P_FONT;
				cd[i].props.hFont = ptab->hdr.props.hFont;
			}
		}

		if (!(cd[i].props.valid & P_ALIGN)) {
			if (colprops->valid & P_ALIGN) {
				cd[i].props.valid |= P_ALIGN;
				cd[i].props.alignment = colprops->alignment;
			} else if (ptab->hdr.props.valid & P_ALIGN) {
				cd[i].props.valid |= P_ALIGN;
				cd[i].props.alignment =
					ptab->hdr.props.alignment;
			}
		}

		if (!(cd[i].props.valid & P_BOX)) {
			if (colprops->valid & P_BOX) {
				cd[i].props.valid |= P_BOX;
				cd[i].props.box = colprops->box;
			} else if (ptab->hdr.props.valid & P_BOX) {
				cd[i].props.valid |= P_BOX;
				cd[i].props.box = ptab->hdr.props.box;
			}
		}
		/* you can't set width/height per cell - this
		 * is ignored at cell level.
		 */
	}

}

void
gtab_boxcell(HWND hwnd, HDC hdc, LPRECT rcp, LPRECT pclip, UINT boxmode)
{
	if (boxmode & P_BOXTOP) {
		MoveToEx(hdc, max(rcp->left, pclip->left),
			max(rcp->top, pclip->top), NULL);
		LineTo(hdc, min(rcp->right, pclip->right),
			max(rcp->top, pclip->top));
	}
	if (boxmode & P_BOXBOTTOM) {
		MoveToEx(hdc, max(rcp->left, pclip->left),
			min(rcp->bottom, pclip->bottom), NULL);
		LineTo(hdc, min(rcp->right, pclip->right),
			min(rcp->bottom, pclip->bottom));
	}
	if (boxmode & P_BOXLEFT) {
		MoveToEx(hdc, max(rcp->left, pclip->left),
			max(rcp->top, pclip->top), NULL);
		MoveToEx(hdc, max(rcp->left, pclip->left),
			min(rcp->bottom, pclip->bottom), NULL);
	}
	if (boxmode & P_BOXRIGHT) {
		MoveToEx(hdc, min(rcp->right, pclip->right),
			max(rcp->top, pclip->top), NULL);
		LineTo(hdc, min(rcp->right, pclip->right),
			min(rcp->bottom, pclip->bottom));
	}
}

void
gtab_paintcell(HWND hwnd, HDC hdc, lpTable ptab, int line, int cell, BOOL show_whitespace, BOOL fPrinting)
{
	lpLineData pline;
	lpCellData cd;
	lpCellPos ppos;
	RECT rc, rcbox;
	int cx, x, y;
	UINT align;
	LPSTR chp, tabp;
	LPWSTR pwch, pwchBreak;
	DWORD fcol, fcolOld, fcolws;
	DWORD bkcol, bkcolOld;
	HFONT hfont, hfontOld;
	HBRUSH hbr;
	char szCharSet[] = "\t ";
	WCHAR wzCharSet[] = L"\t ";
	char szSpaceReplace[] = { (char) 183, (char) 0 };
	char szTabReplace[] = { (char) 187, (char) 0 };
	int cxSpaceReplace;
	int cxTabReplace;
	SIZE size;
	TEXTMETRIC tm;
	int yOfs;
	DWORD etoFlags = ETO_CLIPPED;

        fcol = 0; bkcol = 0; /* eliminate spurious diagnostic, generate worse code */
        hfont = 0;           /* eliminate spurious diagnostic, generate worse code */
	/* init pointers to cell text and properties */
	pline = &ptab->pdata[line];
	cd = &pline->pdata[cell];
	ppos = &ptab->pcellpos[cell];

	/* draw gutter */
	rc.top = pline->linepos.clipstart;
	rc.bottom = pline->linepos.clipend;
	rc.left = (cell > 0) ? ptab->pcellpos[cell - 1].clipend : 0;
	rc.right = ppos->clipstart;
	if (cell > ptab->hdr.fixedcols && ptab->hdr.fixedcols < ptab->hdr.ncols) {
		rc.left = max(rc.left, ptab->pcellpos[ptab->hdr.fixedcols].clipstart);
	}
	if (ptab->hdr.fixedcols > 0 && cell == ptab->hdr.fixedcols) {
		rc.right--;
	}
	if (!fPrinting && rc.right > rc.left) {
		FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
	}

	/* clip all output to this rectangle */
	rc.top = pline->linepos.clipstart;
	rc.bottom = pline->linepos.clipend;
	rc.left = ppos->clipstart;
	rc.right = ppos->clipend;

	/* check cell properties and colours */
	if (cd->props.valid & P_ALIGN) {
		align = cd->props.alignment;
	} else {
		align = P_LEFT;
	}
	//$ FUTURE: This prevents the user's font from being used when printing.
	// For now, that's better than having the output be really tiny, but this
	// needs to be fixed right eventually.
	if (!fPrinting && cd->props.valid & P_FONT) {
		hfontOld = SelectObject(hdc, cd->props.hFont);
	}

	// get y offset to center text vertically within cell
	GetTextMetrics(hdc, &tm);
	yOfs = (rc.bottom - rc.top - tm.tmHeight) / 2;

	/* set replacement chars and char widths */
	cxSpaceReplace = GetTextExtent(hdc, szSpaceReplace, 1);
	cxTabReplace = cxSpaceReplace * ptab->tabchars;

	/* set colours if not default */
	if (!fPrinting) {
		if (cd->props.valid & P_FCOLOUR) {
			fcol = cd->props.forecolour;
			fcolOld = SetTextColor(hdc, fcol);
		}
		if (cd->props.valid & P_FCOLOURWS) {
			fcolws = cd->props.forecolourws;
		}
		else {
			fcolws = fcol;
		}
		if (cd->props.valid & P_BCOLOUR) {
			/* there is a non-default background colour.
			* create a brush and fill the entire cell with it
			 */
			hbr = CreateSolidBrush(cd->props.backcolour);
			if (hbr)
			{
				FillRect(hdc, &rc, hbr);
				DeleteObject(hbr);
			}

			/* also set colour as background colour for the text */
			bkcolOld = SetBkColor(hdc, cd->props.backcolour);
		}
	}

	/* calc offset of text within cell for right-align or centering */
	if (align == P_LEFT) {
		cx = ptab->avewidth/2;
	} else {
		cx = 0;

		if (cd->pwzText) {
			GetTextExtentPoint32W(hdc, cd->pwzText, wcslen(cd->pwzText), &size);
		} else if (cd->ptext) {
			GetTextExtentPoint32A(hdc, cd->ptext, lstrlen(cd->ptext), &size);
		}
		cx = size.cx;

		if (align == P_CENTRE) {
			cx = (ppos->size - cx) / 2;
		} else {
			cx = ppos->size - cx - (ptab->avewidth/2);
		}
	}
	cx += ppos->start;

	/* expand tabs on output and show whitespace on output */
	x = 0;
	y = pline->linepos.start + yOfs;

	/* set search string for strpbrk fn;
	   don't search for space chars unless we're showing whitespace */
	if (!show_whitespace)
	{
		szCharSet[1] = '\0';
		wzCharSet[1] = '\0';
	}

	// determine the string to display (ansi/unicode).  if we have a string
	// and it's not empty, then loop and display it.
	chp = cd->ptext;
	pwch = cd->pwzText;
	if (pwch ? *pwch : (chp && *chp))
	{
		while (TRUE)
		{
			if (pwch)
			{
				pwchBreak = wcspbrk(pwch, wzCharSet);
				if (!pwchBreak)
					pwchBreak = pwch + wcslen(pwch);
			}
			else
			{
				tabp = My_mbspbrk(chp, szCharSet);
				if (!tabp)
					tabp = chp + lstrlen(chp);
			}

			/* perform output up to tab/space char */
			if (pwch)
				ExtTextOutW(hdc, x+cx, y, etoFlags, &rc, pwch, (UINT)(pwchBreak-pwch), NULL);
			else
				ExtTextOutA(hdc, x+cx, y, etoFlags, &rc, chp, (UINT)(tabp-chp), NULL);

			/* advance past the tab */
			if (pwch)
			{
				GetTextExtentPoint32W(hdc, pwch, (UINT)(pwchBreak - pwch), &size);
				pwch = pwchBreak;
			}
			else
			{
				GetTextExtentPoint32A(hdc, chp, (UINT)(tabp - chp), &size);
				chp = tabp;
			}
			x += size.cx;

			// bail if we hit null terminator
			if (pwch ? !*pwch : !*chp)
				break;

			/* handle tab chars */
			while (pwch ? (*pwch == '\t') : (*chp == '\t'))
			{
				/* print replacement char */
				if (show_whitespace)
				{
					if (!fPrinting)
						SetTextColor(hdc, fcolws);

					ExtTextOut(hdc, x + cx, y, etoFlags, &rc, szTabReplace, 1, NULL);

					if (!fPrinting)
						SetTextColor(hdc, fcol);
				}

				/* advance past the tab */
				if (cxTabReplace > 0)
					x += cxTabReplace - (x % cxTabReplace);
				if (pwch)
					pwch = ++pwchBreak;
				else
					chp = ++tabp;
			}

			/* handle space chars */
			if (show_whitespace)
			{
				while (pwch ? (*pwch == ' ') : (*chp == ' '))
				{
					/* replace space char with visible char */
					if (!fPrinting)
						SetTextColor(hdc, fcolws);

					ExtTextOut(hdc, x + cx, y, etoFlags, &rc, szSpaceReplace, 1, NULL);

					if (!fPrinting)
						SetTextColor(hdc, fcol);

					x += cxSpaceReplace;
					if (pwch)
						pwch = ++pwchBreak;
					else
						chp = ++tabp;
				}
			}
		}
	}

	/* reset colours to original if not default */
	if (!fPrinting) {
		if (cd->props.valid & P_FCOLOUR) {
			SetTextColor(hdc, fcolOld);
		}
		if (cd->props.valid & P_BCOLOUR) {
			SetBkColor(hdc, bkcolOld);
		}
		if (cd->props.valid & P_FONT) {
			SelectObject(hdc, hfontOld);
		}
	}

	/* now box cell if marked */
	if (!fPrinting) {
		if ((cd->props.valid & P_BOX)) {
			if (cd->props.box != 0) {
//				rcbox.top = pline->linepos.start;
				rcbox.top = y;
				rcbox.bottom = rcbox.top + pline->linepos.size;
				rcbox.left = ppos->start;
				rcbox.right = ppos->start + ppos->size;
				gtab_boxcell(hwnd, hdc, &rcbox, &rc, cd->props.box);
			}
		}
	}
}

/* fetch and paint the specified line */
void
gtab_paintline(HWND hwnd, HDC hdc, lpTable ptab, int line, BOOL show_whitespace, BOOL fPrinting)
{
	lpCellPos ppos = NULL;
	int i;
	RECT rc;

	if (line < 0 || line >= ptab->nlines)
		return;

	if (!fPrinting)
		GetClientRect(hwnd, &rc);

	gtab_updateline(hwnd, ptab, line);

	for (i = 0; i < ptab->hdr.ncols; i++) {
		ppos = &ptab->pcellpos[i];
		/* show whitespace iff the flag is set
		   and we're painting the main text column */
		if (ppos->clipstart < ppos->clipend) {
			gtab_paintcell(hwnd, hdc, ptab, line, i,
				       (show_whitespace && (i == 2)), fPrinting);
		}
	}

	if (!fPrinting && ppos) {
		rc.top = ptab->pdata[line].linepos.clipstart;
		rc.bottom = ptab->pdata[line].linepos.clipend;
		rc.left = ppos->clipend;
		FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
	}
}

void
gtab_paint(HWND hwnd)
{
    PAINTSTRUCT ps;
    int y, y2, i;
    HDC hDC = BeginPaint(hwnd, &ps);
    lpTable ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);

    if (!ptab) {
        FillRect(hDC, &ps.rcPaint, (HBRUSH)(COLOR_WINDOW + 1));
    } else {
        /* separator lines between fixed rows/columns
         * (ie headers) and the rest - if enabled
         */
        /* paint here first for good impression,
         * and again after to clean up!!
         */
        if (ptab->hdr.vseparator) {
            gtab_vsep(hwnd, ptab, hDC);
        }
        if (ptab->hdr.hseparator) {
            gtab_hsep(hwnd, ptab, hDC);
        }

        /* paint only the rows that need painting */
        for (i = 0; i < ptab->nlines; i++) {
            y = ptab->pdata[i].linepos.start;
            y2 = y + ptab->pdata[i].linepos.size;
            if ( (y <= ps.rcPaint.bottom) &&
                 (y2 >= ps.rcPaint.top)) {
                gtab_paintline(hwnd, hDC, ptab, i, ptab->show_whitespace, FALSE);
            }
        }
        if (ptab->hdr.vseparator) {
            gtab_vsep(hwnd, ptab, hDC);
        }
        if (ptab->hdr.hseparator) {
            gtab_hsep(hwnd, ptab, hDC);
        }
        if (ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, hDC);
        }
    }

    EndPaint(hwnd, &ps);
}


void
gtab_vsep(HWND hwnd, lpTable ptab, HDC hdc)
{
	int x;
	RECT rc;

	if (ptab->hdr.fixedcols < 1) {
		return;
	}
	x = ptab->pcellpos[ptab->hdr.fixedcols - 1].clipend+1;
	GetClientRect(hwnd, &rc);
	MoveToEx(hdc, x, rc.top, NULL);
	LineTo(hdc, x, rc.bottom);
}

void
gtab_hsep(HWND hwnd, lpTable ptab, HDC hdc)
{
	int y;
	RECT rc;

	if (ptab->hdr.fixedrows < 1) {
		return;
	}
	y = ptab->rowheight * ptab->hdr.fixedrows;
	GetClientRect(hwnd, &rc);
	MoveToEx(hdc, rc.left, y-1, NULL);
	LineTo(hdc, rc.right, y-1);
}

/* draw in (inverting) the dotted selection lines for tracking a col width
 */
void
gtab_drawvertline(HWND hwnd, lpTable ptab)
{
	RECT rc;
	HDC hdc;
	HPEN hpen;

	hdc = GetDC(hwnd);
	if (hdc)
	{
		SetROP2(hdc, R2_XORPEN);
		hpen = SelectObject(hdc, hpenDotted);
		GetClientRect(hwnd, &rc);

		MoveToEx(hdc, ptab->trackline1, rc.top, NULL);
		LineTo(hdc, ptab->trackline1, rc.bottom);
		if (ptab->trackline2 != -1) {
			MoveToEx(hdc, ptab->trackline2, rc.top, NULL);
			LineTo(hdc, ptab->trackline2, rc.bottom);
		}

		SelectObject(hdc, hpen);
		ReleaseDC(hwnd, hdc);
	}
}
	

/*
 * mark the selected line, if visible, in the style chosen by the
 * client app. This can be TM_SOLID, meaning an inversion of
 * the whole selected area or TM_FOCUS, meaning, inversion of the first
 * cell, and then a dotted focus rectangle for the rest.
 *
 * this function inverts either style, and so will turn the selection
 * both on and off.
 */
void
gtab_invertsel(HWND hwnd, lpTable ptab, HDC hdc_in)
{
	HDC hdc;
	int firstline, lastline;
	long startrow, lastrow, toprow, bottomrow;
	RECT rc;
	int lastcell;



	/* get the selection start and end rows ordered vertically */
	if (ptab->select.nrows == 0) {
	    return;
	} else if (ptab->select.nrows < 0) {
	    startrow = ptab->select.startrow + ptab->select.nrows + 1;
	    lastrow = ptab->select.startrow;
	} else {
	    startrow = ptab->select.startrow;
	    lastrow = ptab->select.startrow + ptab->select.nrows -1;
	}

	/* is selected area (or part of it) visible on screen ?  */
	firstline = gtab_rowtoline(hwnd, ptab, startrow);
	lastline = gtab_rowtoline(hwnd, ptab, lastrow);


	if (firstline < 0) {
	    toprow = gtab_linetorow(hwnd, ptab,
	    		ptab->hdr.fixedselectable ? 0: ptab->hdr.fixedrows);
	    if ((toprow >= startrow)  &&
		(toprow <= lastrow)) {
		    firstline = gtab_rowtoline(hwnd, ptab, toprow);
	    } else {
		return;
	    }
	} else {
	    toprow = 0;
	}


	if (lastline < 0) {
	    bottomrow = gtab_linetorow(hwnd, ptab, ptab->nlines-1);
	    if ((bottomrow <= lastrow) &&
		(bottomrow >=startrow)) {
		    lastline = gtab_rowtoline(hwnd, ptab, bottomrow);
	    } else {
		return;
	    }
	}


	rc.top = ptab->pdata[firstline].linepos.clipstart;
	rc.bottom = ptab->pdata[lastline].linepos.clipend;



	/* selection mode includes a flag TM_FOCUS indicating we should
	 * use a focus rect instead of the traditional inversion for
	 * selections in this table. This interferes with multiple backgrnd
	 * colours less.  However we still do inversion for fixedcols.
	 */

	lastcell = (int)(ptab->select.startcell + ptab->select.ncells - 1);


	/*
	 * invert the whole area for TM_SOLID or just the first
	 * cell for TM_FOCUS
	 */
	rc.left = ptab->pcellpos[ptab->select.startcell].clipstart;
	if (ptab->hdr.selectmode & TM_FOCUS) {
		rc.right = ptab->pcellpos[ptab->select.startcell].clipend;
	}else {
		rc.right = ptab->pcellpos[lastcell].clipend;
	}

	if (hdc_in == NULL) {
		hdc = GetDC(hwnd);
		if (!hdc)
			return;
	} else {
		hdc = hdc_in;
	}

	InvertRect(hdc, &rc);

	/*
	 * draw focus rectangle around remaining cells on this line, if there
	 * are any
	 */
	if (ptab->hdr.selectmode & TM_FOCUS) {
		/*
		 * now this is a real fudge. if we are drawing TM_FOCUS
		 * selection, and the real top line is off the top of the
		 * window, then the top of the focus rect will be drawn at
		 * the top of our window. If we then scroll up one line,
		 * a new focus rect will be drawn, but the old top of focus
		 * rect line will still be there as junk on the
		 * screen. To fix this, we have 2 choices: we undo the selection
		 * before every scroll (too slow) or we set the focus rect a little
		 * bigger if the real top line is off-window, so that the top line
		 * is clipped (as it should be). This latter is what we do here
		 */
		if (toprow > startrow) {
		    rc.top--;
		}
		if (ptab->select.ncells > 1) {
			rc.left = ptab->pcellpos[ptab->select.startcell+1].clipstart;
			rc.right = ptab->pcellpos[lastcell].clipend;
			DrawFocusRect(hdc, &rc);
		}
	}

	if (hdc_in == NULL) {
		ReleaseDC(hwnd, hdc);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\tprint.c ===
/*
 * standard table class.
 *
 * print functions.
 *
 * see table.h for interface description
 */

#include <precomp.h>
#include "gutilsrc.h"

#include "table.h"
#include "tpriv.h"

/* in tpaint.c, calls GetTextExtentPoint */
extern int GetTextExtent(HDC, LPSTR, int);

extern HANDLE hLibInst;

/* function prototypes */
lpTable gtab_printsetup(HWND hwnd, lpTable ptab, HANDLE heap,
                        lpPrintContext pcontext);
BOOL gtab_prtwidths(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext
                    pcontext);
void gtab_printjob(HWND hwnd, lpTable ptab, lpPrintContext pcontext);
int APIENTRY AbortProc(HDC hpr, int code);
INT_PTR CALLBACK AbortDlg(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL gtab_printpage(HWND hwnd, lpTable ptab, lpPrintContext pcontext, int page);
void gtab_setrects(lpPrintContext pcontext, LPRECT rcinner, LPRECT rcouter);
void gtab_printhead(HWND hwnd, HDC hdc, lpTable ptab, lpTitle head, int page, BOOL fExpandChars);


/*
 * gtab_print
 */
BOOL
gtab_print(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext)
{
    BOOL fNoContext, fNoMargin, fNoPD;
    BOOL fSuccess = TRUE;
    lpTable ptab_prt;

    fNoContext = FALSE;
    fNoPD = FALSE;
    fNoMargin = FALSE;

    if (pcontext == NULL) {
        fNoContext = TRUE;
        pcontext = (lpPrintContext) gmem_get(heap,
                                             sizeof(PrintContext));
        pcontext->head = pcontext->foot = NULL;
        pcontext->margin = NULL;
        pcontext->pd = NULL;
        pcontext->id = 0;
    }
    if (pcontext->pd == NULL) {
        fNoPD = TRUE;
    }
    if (pcontext->margin == NULL) {
        fNoMargin = TRUE;
    }
    ptab_prt = gtab_printsetup(hwnd, ptab, heap, pcontext);

    if (ptab_prt != NULL) {
        gtab_printjob(hwnd, ptab_prt, pcontext);

        gtab_deltable(hwnd, ptab_prt);
    } else fSuccess = FALSE;
    if (fNoMargin) {
        gmem_free(heap, (LPSTR)pcontext->margin,
                  sizeof(Margin));
        pcontext->margin = NULL;
    }
    if (fNoPD) {
        if (pcontext->pd->hDevMode != NULL) {
            GlobalFree(pcontext->pd->hDevMode);
        }
        if (pcontext->pd->hDevNames != NULL) {
            GlobalFree(pcontext->pd->hDevNames);
        }
        gmem_free(heap, (LPSTR) pcontext->pd, sizeof(PRINTDLG));
        pcontext->pd = NULL;
    }
    if (fNoContext) {
        gmem_free(heap, (LPSTR) pcontext, sizeof(PrintContext));
    }
    return fSuccess;
}



/*
 * gtab_printsetup()
 *
 * sets up printercontext - builds lpTable for printer, incl. sizing
 * and initialises pcontext fields that may be null.
 */
lpTable
gtab_printsetup(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext)
{
    lpTable pprttab;
    PRINTDLG FAR * pd;
    int ncols, i;
    ColPropsList cplist;

    /* set fields for context that user left null */
    if (pcontext->margin == NULL) {
        pcontext->margin = (lpMargin) gmem_get(heap, sizeof(Margin));
        if (pcontext->margin == NULL) {
            return(NULL);
        }
        pcontext->margin->left = 10;
        pcontext->margin->right = 10;
        pcontext->margin->top = 15;
        pcontext->margin->bottom = 15;
        pcontext->margin->topinner = 15;
        pcontext->margin->bottominner = 15;
    }

    if (pcontext->pd == NULL) {
        pd = (PRINTDLG FAR *) gmem_get(heap, sizeof(PRINTDLG));
        if (pd == NULL) {
            return(NULL);
        }
        pcontext->pd = pd;

        pd->lStructSize = sizeof(PRINTDLG);
        pd->hwndOwner = hwnd;
        pd->hDevMode = (HANDLE) NULL;
        pd->hDevNames = (HANDLE) NULL;
        pd->Flags = PD_RETURNDC|PD_RETURNDEFAULT;

        if (PrintDlg(pd) == FALSE) {
            return(NULL);
        }
    }

    /* now create a Table struct by querying the owner */
    pprttab = (lpTable) gmem_get(heap, sizeof(Table));

    if (pprttab == NULL) {
        return(NULL);
    }
    pprttab->hdr = ptab->hdr;
    pprttab->tabchars = ptab->tabchars;
    pprttab->show_whitespace = ptab->show_whitespace;

    /* get the row/column count from owner window */
    if (pcontext->id == 0) {
        pprttab->hdr.id = ptab->hdr.id;
    } else {
        pprttab->hdr.id = pcontext->id;
    }
    pprttab->hdr.props.valid = 0;
    pprttab->hdr.sendscroll = FALSE;
    if (gtab_sendtq(hwnd, TQ_GETSIZE, (LPARAM)&pprttab->hdr) == FALSE) {
        return(NULL);
    }

    /* alloc and init the col data structs */
    ncols = pprttab->hdr.ncols;
    pprttab->pcolhdr = (lpColProps) gmem_get(heap, sizeof(ColProps) * ncols);
    if (pprttab->pcolhdr == NULL) {
        gmem_free(heap, (LPSTR)pprttab, sizeof(Table));
        return(NULL);
    }

    /* init col properties to default */
    for (i=0; i < ncols; i++) {
        pprttab->pcolhdr[i].props.valid = 0;
        pprttab->pcolhdr[i].nchars = 0;
    }
    /* get the column props from owner */
    cplist.plist = pprttab->pcolhdr;
    cplist.id = pprttab->hdr.id;
    cplist.startcol = 0;
    cplist.ncols = ncols;
    gtab_sendtq(hwnd, TQ_GETCOLPROPS, (LPARAM)&cplist);


    pprttab->scrollscale = 1;
    pprttab->pcellpos = (lpCellPos) gmem_get(heap,
                                             sizeof(CellPos) * ptab->hdr.ncols);
    if (pprttab->pcellpos == NULL) {
        gmem_free(heap, (LPSTR) pprttab->pcolhdr, sizeof(ColProps) * ncols);
        gmem_free(heap, (LPSTR)pprttab, sizeof(Table));
        return(NULL);
    }


    pprttab->pdata = NULL;
    pprttab->nlines = 0;

    if (!gtab_prtwidths(hwnd, pprttab, heap, pcontext)) {
        gmem_free(heap, (LPSTR)pprttab->pcellpos,
                  sizeof(CellPos) * ptab->hdr.ncols);
        gmem_free(heap, (LPSTR)pprttab, sizeof(Table));
        return(NULL);
    }
    return(pprttab);
}


/* calc the height/width settings and alloc line data */
BOOL
gtab_prtwidths(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext)
{
    TEXTMETRIC tm;
    int cx, cxtotal, i, curx, cury;
    lpProps hdrprops, cellprops;
    lpCellPos xpos, ypos;
    RECT rcinner, rcouter;

    hdrprops = &ptab->hdr.props;
    GetTextMetrics(pcontext->pd->hDC, &tm);
    ptab->avewidth = tm.tmAveCharWidth;
    ptab->rowheight = tm.tmHeight + tm.tmExternalLeading;
    if (hdrprops->valid & P_HEIGHT) {
        ptab->rowheight = hdrprops->height;
    }

    /* set sizes for headers */
    gtab_setrects(pcontext, &rcinner, &rcouter);

    /* set width/pos for each col. */
    cxtotal = 0;
    curx = rcinner.left;
    for (i = 0; i < ptab->hdr.ncols; i++) {
        cellprops = &ptab->pcolhdr[i].props;
        xpos = &ptab->pcellpos[i];

        if (cellprops->valid & P_WIDTH) {
            cx = cellprops->width;
        } else if (hdrprops->valid & P_WIDTH) {
            cx = hdrprops->width;
        } else {
            cx = ptab->pcolhdr[i].nchars + 1;
            cx *= ptab->avewidth;
        }
        /* add 2 for intercol spacing */
        cx += 2;

        xpos->size = cx;
        xpos->start = curx + 1;
        xpos->clipstart = xpos->start;
        xpos->clipend = xpos->start + xpos->size - 2;
        xpos->clipend = min(xpos->clipend, rcinner.right);

        cxtotal += xpos->size;
        curx += xpos->size;
    }
    ptab->rowwidth = cxtotal;

    if (pcontext->head != NULL) {
        xpos = &pcontext->head->xpos;
        ypos = &pcontext->head->ypos;

        xpos->start = rcouter.left + 1;
        xpos->clipstart = rcouter.left + 1;
        xpos->clipend = rcouter.right - 1;
        xpos->size = rcouter.right - rcouter.left;

        ypos->start = rcouter.top;
        ypos->clipstart = rcouter.top;
        ypos->clipend = rcinner.top;
        ypos->size = ptab->rowheight;
    }

    if (pcontext->foot != NULL) {
        xpos = &pcontext->foot->xpos;
        ypos = &pcontext->foot->ypos;

        xpos->start = rcouter.left + 1;
        xpos->clipstart = rcouter.left + 1;
        xpos->clipend = rcouter.right - 1;
        xpos->size = rcouter.right - rcouter.left;

        ypos->start = rcouter.bottom - ptab->rowheight;
        ypos->clipstart = rcinner.bottom;
        ypos->clipend = rcouter.bottom;
        ypos->size = ptab->rowheight;
    }

    /* set nr of lines per page */
    ptab->nlines = (rcinner.bottom - rcinner.top) / ptab->rowheight;
    if (!gtab_alloclinedata(hwnd, heap, ptab)) {
        return(FALSE);
    }
    /* set line positions */
    cury = rcinner.top;
    for (i = 0; i < ptab->nlines; i++) {
        ypos = &ptab->pdata[i].linepos;
        ypos->start = cury;
        ypos->clipstart = ypos->start;
        ypos->clipend = ypos->start + ypos->size;
        ypos->clipend = min(ypos->clipend, rcinner.bottom);
        cury += ypos->size;
    }
    return(TRUE);
}


/* static information for this module */
BOOL bAbort;
FARPROC lpAbortProc;
//DLGPROC lpAbortDlg;
HWND hAbortWnd;
int npage;
int pages;

void
gtab_printjob(HWND hwnd, lpTable ptab, lpPrintContext pcontext)
{
    int moveables;
    int endpage;
    int startpage = 1;
    HDC hpr;
    int status;
    HANDLE hcurs;
    static char str[256];
    DOCINFO di;
    TCHAR szPage[60];  /* for LoadString */

    hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

    moveables = ptab->nlines - ptab->hdr.fixedrows;
    pages = (int) (ptab->hdr.nrows - ptab->hdr.fixedrows + moveables - 1)
            / moveables;
    endpage = pages;

    if (pcontext->pd->Flags & PD_PAGENUMS) {
        startpage = pcontext->pd->nFromPage;
        endpage = pcontext->pd->nToPage;
    }
    hpr = pcontext->pd->hDC;

    //lpAbortDlg = (DLGPROC) MakeProcInstance((WINPROCTYPE) AbortDlg, hLibInst);
    lpAbortProc = (FARPROC) MakeProcInstance((WINPROCTYPE)AbortProc, hLibInst);

    SetAbortProc(hpr, (ABORTPROC) lpAbortProc);

    di.lpszDocName = "Table";
    di.cbSize = lstrlen(di.lpszDocName);
    di.lpszOutput = NULL;
    di.lpszDatatype = NULL;
    di.fwType = 0;

    StartDoc(hpr, &di);

    bAbort = FALSE;

    /* add abort modeless dialog later!! */
    //hAbortWnd = CreateDialog(hLibInst, "GABRTDLG", hwnd, lpAbortDlg);
    hAbortWnd = CreateDialog(hLibInst, "GABRTDLG", hwnd, AbortDlg);
    if (hAbortWnd != NULL) {
        ShowWindow(hAbortWnd, SW_NORMAL);
        EnableWindow(hwnd, FALSE);
    }
    SetCursor(hcurs);


    status = 0;  /* kills a "used without init" diagnostic */
    for (npage = startpage; npage<=endpage; npage++) {
        LoadString(hLibInst,IDS_PAGE_STR,szPage,sizeof(szPage));
        wsprintf(str, szPage,  npage, pages);
        if (hAbortWnd != NULL)
            SetDlgItemText(hAbortWnd, IDC_LPAGENR, str);
        status = gtab_printpage(hwnd, ptab, pcontext, npage);
        if (status < 0) {
            AbortDoc(hpr);
            break;
        }
    }
    if (status >= 0) {
        EndDoc(hpr);
    }

    if (hAbortWnd != NULL) {
        EnableWindow(hwnd, TRUE);
        DestroyWindow(hAbortWnd);
    }
    //FreeProcInstance((WINPROCTYPE) lpAbortDlg);
    FreeProcInstance(lpAbortProc);

    DeleteDC(hpr);
}

int APIENTRY
AbortProc(HDC hpr, int code)
{

    MSG msg;

    if (!hAbortWnd) {
        return(TRUE);
    }
    while (!bAbort && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        if (!IsDialogMessage(hAbortWnd, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return(!bAbort);
}

INT_PTR CALLBACK
AbortDlg(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {

        case WM_COMMAND:
            bAbort = TRUE;
            EndDialog(hdlg, TRUE);
            return TRUE;

        case WM_INITDIALOG:
            return TRUE;
    }
    return(FALSE);
}

/*
 * print a single page. page number is 1-based
 */
BOOL
gtab_printpage(HWND hwnd, lpTable ptab, lpPrintContext pcontext, int page)
{
    HDC hpr;
    int moveables, i;
    int x1, y1, x2, y2;

    hpr = pcontext->pd->hDC;
    StartPage(hpr);

    moveables = ptab->nlines - ptab->hdr.fixedrows;
    ptab->toprow = moveables * (page-1);
    gtab_invallines(hwnd, ptab, ptab->hdr.fixedrows, moveables);

    for (i =0; i < ptab->nlines; i++) {
        gtab_paintline(hwnd, hpr, ptab, i, ptab->show_whitespace, TRUE);
    }
    if ((ptab->hdr.vseparator) && (ptab->hdr.fixedcols > 0)) {
        x1 = ptab->pcellpos[ptab->hdr.fixedcols -1].clipend+1;
        y1 = ptab->pdata[0].linepos.clipstart;
        y2 = ptab->pdata[ptab->nlines-1].linepos.clipend;
        MoveToEx(hpr, x1, y1, NULL);
        LineTo(hpr, x1, y2);
    }
    if ((ptab->hdr.hseparator) && (ptab->hdr.fixedrows > 0)) {
        y1 = ptab->pdata[ptab->hdr.fixedrows-1].linepos.clipend;
        x1 = ptab->pcellpos[0].clipstart;
        x2 = ptab->pcellpos[ptab->hdr.ncols-1].clipend;
        MoveToEx(hpr, x1, y1, NULL);
        LineTo(hpr, x2, y1);
    }

    if (pcontext->head != NULL) {
        gtab_printhead(hwnd, hpr, ptab, pcontext->head, page, FALSE);
    }
    if (pcontext->foot != NULL) {
        gtab_printhead(hwnd, hpr, ptab, pcontext->foot, page, TRUE);
    }

    return(EndPage(hpr));
}


/*
 * calculate the outline positions in pixels for the headers
 * (outer rect) and for the page itself (inner rect). Based on
 * page size and PrintContext margin info (which is in millimetres).
 */
void
gtab_setrects(lpPrintContext pcontext, LPRECT rcinner, LPRECT rcouter)
{
    HDC hpr;
    int hpixels, hmms;
    int vpixels, vmms;
    int h_pixpermm, v_pixpermm;

    hpr = pcontext->pd->hDC;
    hpixels = GetDeviceCaps(hpr, HORZRES);
    vpixels = GetDeviceCaps(hpr, VERTRES);
    vmms = GetDeviceCaps(hpr, VERTSIZE);
    hmms = GetDeviceCaps(hpr, HORZSIZE);

    h_pixpermm = hpixels / hmms;
    v_pixpermm = vpixels / vmms;

    rcouter->top = (pcontext->margin->top * v_pixpermm);
    rcouter->bottom = vpixels - (pcontext->margin->bottom * v_pixpermm);
    rcouter->left = (pcontext->margin->left * h_pixpermm);
    rcouter->right = hpixels - (pcontext->margin->right * h_pixpermm);

    rcinner->left = rcouter->left;
    rcinner->right = rcouter->right;
    rcinner->top = rcouter->top +
                   (pcontext->margin->topinner * v_pixpermm);
    rcinner->bottom = rcouter->bottom -
                      (pcontext->margin->bottominner * v_pixpermm);
}


void
gtab_printhead(HWND hwnd, HDC hdc, lpTable ptab, lpTitle head, int page, BOOL fExpandChars)
{
    RECT rc, rcbox;
    int i, cx, x, y, tab;
    UINT align;
    LPSTR chp, tabp;
    DWORD fcol, bkcol;
    char str[MAX_PATH * 2];

    fcol = 0; bkcol = 0;  /* eliminate spurious diagnostic - generate worse code */

    rc.top = head->ypos.clipstart;
    rc.bottom = head->ypos.clipend;
    rc.left = head->xpos.clipstart;
    rc.right = head->xpos.clipend;

    /* update page number */
    if (fExpandChars) {
        chp = str;
        for (i = 0; i < lstrlen(head->ptext); i++) {
            switch (head->ptext[i]) {

                case '#':
                    chp += wsprintf(chp, "%d", page);
                    break;

                case '$':
                    chp += wsprintf(chp, "%d", pages);
                    break;

                default:
                    if (IsDBCSLeadByte(head->ptext[i]) &&
                        head->ptext[i+1])
                    {
                        *chp = head->ptext[i];
                        chp++;
                        i++;
                    }
                    *chp++ = head->ptext[i];
                    break;
            }
        }
        *chp = '\0';
    } else {
        lstrcpy(str, head->ptext);
    }
    chp = str;

    if (head->props.valid & P_ALIGN) {
        align = head->props.alignment;
    } else {
        align = P_LEFT;
    }

    /* set colours if not default */
    if (head->props.valid & P_FCOLOUR) {
        fcol = SetTextColor(hdc, head->props.forecolour);
    }
    if (head->props.valid & P_BCOLOUR) {
        bkcol = SetBkColor(hdc, head->props.backcolour);
    }

    /* calc offset of text within cell for right-align or centering */
    if (align == P_LEFT) {
        cx = ptab->avewidth/2;
    } else {
        cx = LOWORD(GetTextExtent(hdc, chp, lstrlen(chp)));
        if (align == P_CENTRE) {
            cx = (head->xpos.size - cx) / 2;
        } else {
            cx = head->xpos.size - cx - (ptab->avewidth/2);
        }
    }
    cx += head->xpos.start;

    /* expand tabs on output */
    tab = ptab->avewidth * ptab->tabchars;
    x = 0;
    y = head->ypos.start;

    for ( ; (tabp = My_mbschr(chp, '\t')) != NULL; ) {
        /* perform output upto tab char */
        ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &rc, chp, (UINT)(tabp-chp), NULL);

        /* advance past the tab */
        x += LOWORD(GetTextExtent(hdc, chp, (INT)(tabp - chp)));
        x = ( (x + tab) / tab) * tab;
        chp = ++tabp;
    }

    /*no more tabs - output rest of string */
    ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &rc, chp, lstrlen(chp), NULL);

    /* reset colours to original if not default */
    if (head->props.valid & P_FCOLOUR) {
        SetTextColor(hdc, fcol);
    }
    if (head->props.valid & P_BCOLOUR) {
        SetBkColor(hdc, bkcol);
    }

    /* now box cell if marked */
    if (head->props.valid & P_BOX) {
        if (head->props.box != 0) {
            rcbox.top = head->ypos.start;
            rcbox.bottom = rcbox.top + head->ypos.size;
            rcbox.left = head->xpos.start;
            rcbox.right = rcbox.left + head->xpos.size;
            gtab_boxcell(hwnd, hdc, &rcbox, &rc, head->props.box);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\status.c ===
/*
 * status line handler
 *
 */

/*---includes-----------------------------------------------------------*/
#include <precomp.h>


/* --- data structures ------------------------------------------------- */

#define SF_MAXLABEL     80   /* no more than 80 in an item within the bar */
/* Is this adequate for long pathnames on a
   hi-res screen?
*/

typedef struct statel {
    int type;                       /* SF_BUTTON or SF_STATIC */
    int flags;                      /* SF_VAR => variable width
                                       SF_LEFT=> left aligned (else right)
                                       SF_RAISE=> paint as 'raised' 3d rect
                                       SF_LOWER=> paint as lowered 3D rect
                                       SF_SZMIN=>together with SF_VAR
                                                 allows minimum size for
                                                 var sized item
                                       SF_SZMAX=>see SZMIN and use nouse
                                    */
    int id;                         /* control id */
    int width;                      /* width of control in chars */
    char text[SF_MAXLABEL+1];       /* null-term string for label */

    RECT rc;                        /* used by status.c */
} STATEL, * PSTATEL;

typedef struct itemlist {
    int nitems;
    PSTATEL statels;

    int selitem;                    /* used by status.c */
    BOOL isselected;                /* used by status.c */
} ILIST, * PILIST;

/* ------------------------------------------------------------------*/


/* prototypes of routines in this module */

void StatusCreateTools(void);
void StatusDeleteTools(void);
INT_PTR APIENTRY StatusWndProc(HWND, UINT, WPARAM, LPARAM);
void StatusResize(HWND hWnd, PILIST pilist);
int StatusCalcHeight(HWND hWnd, PSTATEL ip);
int StatusCalcWidth(HWND hWnd, PSTATEL ip);
PSTATEL StatusGetItem(PILIST plist, int id);
void LowerRect(HDC hDC, LPRECT rcp);
void RaiseRect(HDC hDC, LPRECT rcp);
void StatusPaint(HWND hWnd, PILIST iplistp);
void BottomRight(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners);
void TopLeft(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners);
void StatusButtonDown(HDC hDC, PSTATEL ip);
void StatusButtonUp(HDC hDC, PSTATEL ip);
void InitDC(HDC hdc);


/*--global data---------------------------------------------------------*/

HPEN hpenHilight, hpenLowlight;
HPEN hpenBlack, hpenNeutral;
HBRUSH hbrBackground; /* pieces and board */
HFONT hFont;
int status_charheight, status_charwidth;

/* default pt size for font (tenths of a pt) */
#define         DEF_PTSIZE      80
/*-public functions----------------------------------------------------------*/

/* StatusInit
 *
 * - create window class
 */
BOOL
StatusInit(
           HANDLE hInstance
           )
{
    WNDCLASS    wc;
    BOOL resp;
    TEXTMETRIC tm = {0};
    HDC hDC;


    StatusCreateTools();

    wc.style = CS_HREDRAW|CS_VREDRAW|CS_GLOBALCLASS;
    wc.lpfnWndProc = StatusWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(HANDLE);
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = hbrBackground;
    wc.lpszClassName = (LPSTR) "gdstatusclass";
    wc.lpszMenuName = NULL;

    resp = RegisterClass(&wc);

    hDC = GetDC(NULL);
    if (hDC)
    {
        InitDC(hDC);
        GetTextMetrics(hDC, &tm);
        ReleaseDC(NULL, hDC);
    }
    else
    {
        // arbitrary, whatever...
        tm.tmHeight = 14;
        tm.tmAveCharWidth = 5;
    }
    status_charheight = (int)(tm.tmHeight + tm.tmExternalLeading);
    status_charwidth = (int)tm.tmAveCharWidth;

    return(resp);
}

/*
 * create and show the window
 */
HWND APIENTRY
StatusCreate(
             HANDLE hInst,
             HWND hParent,
             INT_PTR id,
             LPRECT rcp,
             HANDLE hmem
             )
{

    HWND hWnd;

    /* create a child window of status class */


    hWnd = CreateWindow("gdstatusclass",
                        NULL,
                        WS_CHILD | WS_VISIBLE,
                        rcp->left,
                        rcp->top,
                        (rcp->right - rcp->left),
                        (rcp->bottom - rcp->top),
                        hParent,
                        (HANDLE) id,
                        hInst,
                        (LPVOID) hmem);

    return(hWnd);
}

/* return default height of this window */
int APIENTRY
StatusHeight(
             HANDLE hmem
             )
/* The window has a number of items which are arranged horizontally,
   so the window height is the maximum of the individual heights
*/
{
    PILIST plist;
    int i;
    int sz;
    int maxsize = 0;

    plist = (PILIST) GlobalLock(hmem);
    if (plist != NULL) {
        for (i = 0; i<plist->nitems; i++) {
            sz = StatusCalcHeight(NULL, &plist->statels[i]);
            maxsize = max(sz, maxsize);
        }
    }
    GlobalUnlock(hmem);
    if (maxsize > 0) {
        return(maxsize + 4);
    } else {
        return(status_charheight + 4);
    }
}

/* alloc the plist struct and return handle to caller */
HANDLE
StatusAlloc(
            int nitems
            )
{
    HANDLE hmem;
    PILIST pilist;
    LPSTR chp;

    hmem = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
                       sizeof(ILIST) + (sizeof(STATEL) * nitems));
    chp = GlobalLock(hmem);
    if (chp == NULL) {
        return(NULL);
    }

    pilist = (PILIST) chp;
    pilist->nitems = nitems;
    pilist->statels = (PSTATEL) &chp[sizeof(ILIST)];
    GlobalUnlock(hmem);

    return(hmem);
}


/* insert an item into the plist */
BOOL
StatusAddItem(
              HANDLE hmem,
              int itemnr,
              int type,
              int flags,
              int id,
              int width,
              LPSTR text
              )
{
    PILIST pilist;
    PSTATEL pel;

    pilist = (PILIST) GlobalLock(hmem);
    if ((pilist == NULL) || (itemnr >= pilist->nitems)) {
        GlobalUnlock(hmem);
        return(FALSE);
    }
    pel = &pilist->statels[itemnr];
    pel->type = type;
    pel->flags = flags;
    pel->id = id;
    pel->width = width;
    if (text == NULL) {
        pel->text[0] = '\0';
    } else {
        lstrcpy(pel->text, text);
    }


    GlobalUnlock(hmem);
    return(TRUE);
}

/* ---- internal functions ------------------------------------------*/

void
InitDC(HDC hdc)
{
    SetBkColor(hdc, RGB(192,192,192));
    SelectObject(hdc, hbrBackground);
    SelectObject(hdc, hFont);
}


void
StatusCreateTools()
{
    LOGFONT lf;
    HDC hdc;
    int scale;

    hbrBackground = CreateSolidBrush(RGB(192,192,192));
    hpenHilight = CreatePen(0, 1, RGB(255, 255, 255));
    hpenLowlight = CreatePen(0, 1, RGB(128, 128, 128));
    hpenNeutral = CreatePen(0, 1, RGB(192, 192, 192));
    hpenBlack = CreatePen(0, 1, RGB(0, 0, 0));

    hdc = GetDC(NULL);
    if (hdc)
    {
        scale = GetDeviceCaps(hdc, LOGPIXELSY);
        ReleaseDC(NULL, hdc);
    }
    else
    {
        // arbitrary, whatever...
        scale = 72;
    }

    lf.lfHeight = -MulDiv(DEF_PTSIZE, scale, 720);
    lf.lfWidth = 0;
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    lf.lfWeight = FW_REGULAR;
    lf.lfItalic = 0;
    lf.lfUnderline = 0;
    lf.lfStrikeOut = 0;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
    lf.lfFaceName[0] = '\0';
#ifdef COMPLEX
    hFont = CreateFontIndirect(&lf);
#else
    hFont = GetStockObject(SYSTEM_FONT);
#endif



}

void
StatusDeleteTools()
{
    DeleteObject(hbrBackground);
    DeleteObject(hpenHilight);
    DeleteObject(hpenLowlight);
    DeleteObject(hpenBlack);
    DeleteObject(hpenNeutral);

#ifdef COMPLEX
    DeleteObject(hFont);
#endif
}

/* Main winproc for status windows
 *
 * handles create/destroy and paint requests
 */

INT_PTR
StatusWndProc(
              HWND hWnd,
              UINT message,
              WPARAM wParam,
              LPARAM lParam
              )
{
    HANDLE hitems;
    PSTATEL ip;
    PILIST plist;
    CREATESTRUCT * cp;
    int i;
    HDC hDC;
    RECT rc;
    POINT pt;

    switch (message) {

        case WM_CREATE:
            cp = (CREATESTRUCT *) lParam;
            hitems = (HANDLE) cp->lpCreateParams;
            SetWindowLongPtr(hWnd, 0,  (LONG_PTR)hitems);
            plist = (PILIST) GlobalLock(hitems);
            if (plist != NULL) {
                plist->selitem = -1;
                GlobalUnlock(hitems);
            }
            break;

        case WM_SIZE:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            if (plist != NULL) {
                StatusResize(hWnd, plist);
                GlobalUnlock(hitems);
            }
            break;

        case WM_PAINT:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            StatusPaint(hWnd, plist);
            GlobalUnlock(hitems);

            break;

        case WM_LBUTTONUP:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);

            if (plist == NULL) {
                break;
            }
            if (plist->selitem != -1) {
                ip = &plist->statels[plist->selitem];
                if (plist->isselected) {
                    hDC = GetDC(hWnd);
                    if (hDC)
                    {
                        InitDC(hDC);
                        StatusButtonUp(hDC, ip);
                        ReleaseDC(hWnd, hDC);
                    }
                }
                plist->selitem = -1;
                ReleaseCapture();
                if (PtInRect(&ip->rc, pt)) {
                    SendMessage(GetParent(hWnd), WM_COMMAND, MAKELONG(ip->id, WM_LBUTTONUP), (LPARAM)hWnd);
                }
            }
            GlobalUnlock(hitems);
            break;

        case WM_LBUTTONDOWN:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            if (plist == NULL) {
                break;
            }
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);
            if (plist->selitem == -1) {
                for (i = 0; i< plist->nitems; i++) {
                    ip = &plist->statels[i];
                    if (PtInRect(&ip->rc, pt)) {
                        if (ip->type != SF_BUTTON) {
                            break;
                        }
                        plist->selitem = i;
                        SetCapture(hWnd);

                        plist->isselected = TRUE;
                        hDC = GetDC(hWnd);
                        if (hDC)
                        {
                            InitDC(hDC);
                            StatusButtonDown(hDC, ip);
                            ReleaseDC(hWnd, hDC);
                        }
                        break;
                    }
                }
            }
            GlobalUnlock(hitems);
            break;

        case WM_MOUSEMOVE:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            if (plist == NULL) {
                break;
            }
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);
            if (plist->selitem != -1) {
                ip = &plist->statels[plist->selitem];
                if (PtInRect(&ip->rc, pt)) {
                    if (!plist->isselected) {
                        hDC = GetDC(hWnd);
                        if (hDC)
                        {
                            InitDC(hDC);
                            StatusButtonDown(hDC, ip);
                            ReleaseDC(hWnd, hDC);
                        }
                        plist->isselected = TRUE;
                    }
                } else {
                    if (plist->isselected) {
                        hDC = GetDC(hWnd);
                        if (hDC)
                        {
                            InitDC(hDC);
                            StatusButtonUp(hDC, ip);
                            ReleaseDC(hWnd, hDC);
                        }
                        plist->isselected = FALSE;
                    }
                }
            }
            GlobalUnlock(hitems);
            break;


        case WM_DESTROY:

            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            GlobalUnlock(hitems);
            GlobalFree(hitems);

            SetWindowLongPtr(hWnd, 0, 0);
            break;

        case SM_NEW:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            if (hitems != NULL) {
                GlobalFree(hitems);
            }
            hitems = (HANDLE) wParam;
            if (hitems == NULL) {
                SetWindowLongPtr(hWnd, 0, 0);
                InvalidateRect(hWnd, NULL, TRUE);
                break;
            }
            plist = (PILIST) GlobalLock(hitems);
            if (plist == NULL) {
                SetWindowLongPtr(hWnd, 0, 0);
                InvalidateRect(hWnd, NULL, TRUE);
                break;
            }
            plist->selitem = -1;
            StatusResize(hWnd, plist);
            GlobalUnlock(hitems);
            SetWindowLongPtr(hWnd, 0, (LONG_PTR)hitems);
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case SM_SETTEXT:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            if (hitems == NULL) {
                break;
            }
            plist = (PILIST) GlobalLock(hitems);
            ip = StatusGetItem(plist, (int)wParam);
            if (ip != NULL) {
                if (lParam == 0) {
                    ip->text[0] = '\0';
                } else {
                    My_mbsncpy(ip->text, (LPSTR) lParam, SF_MAXLABEL);
                    ip->text[SF_MAXLABEL] = '\0';
                }

                /* if this is a variable width field, we need to redo
                 * all size calcs in case the field width has changed.
                 * in that case, we need to repaint the entire window
                 * and not just this field - so set rc to indicate the
                 * area to be redrawn.
                 */
                if (ip->flags & SF_VAR) {
                    StatusResize(hWnd, plist);
                    GetClientRect(hWnd, &rc);
                    RedrawWindow(hWnd, &rc, NULL,
                                 RDW_INVALIDATE|RDW_ERASE|RDW_UPDATENOW);
                } else {
                    /* instead of just invalidating the window, we can
                     * force the window to be repainted now. This is
                     * essential for status updates during a busy
                     * loop when no messages are being processed,
                     * but we should still update the user on what's
                     * happening.
                     */
                    RedrawWindow(hWnd, &ip->rc, NULL,
                                 RDW_INVALIDATE|RDW_NOERASE|RDW_UPDATENOW);
                }

            }
            GlobalUnlock(hitems);
            break;

        default:
            return(DefWindowProc(hWnd, message, wParam, lParam));
    }
    return 0;
}

/*
 * position the labels and buttons within the status window */
void
StatusResize(HWND hWnd, PILIST iplistp)
{
    RECT rc;
    int curpos_right, curpos_left;
    int height, width;
    int i;
    PSTATEL ip;


    if (iplistp == NULL) {
        return;
    }
    GetClientRect(hWnd, &rc);
    curpos_left = rc.left + status_charwidth / 2;
    curpos_right = rc.right - (status_charwidth / 2);

    /* loop through all items setting their position rects.
     * items are flagged as being left or right. We place them
     * in order starting at the left and the right, with a single
     * char's width between each item
     */
    for (i = 0; i < iplistp->nitems; i++) {
        ip = &iplistp->statels[i];

        width = StatusCalcWidth(hWnd, ip);
        height = StatusCalcHeight(hWnd, ip);
        ip->rc.top = (rc.bottom - height) / 2;
        ip->rc.bottom = ip->rc.top + height;

        /* see if  this item fits. Items that partially fit
         * are placed reduced in size.
         */
        if (ip->flags & SF_LEFT) {

            if (curpos_left+width >= curpos_right) {
                /* doesn't completely fit-does it partly? */
                if ((curpos_left + 1) >= curpos_right) {

                    /* no - this item does not fit */
                    ip->rc.left = 0;
                    ip->rc.right = 0;
                } else {
                    /* partial fit */
                    ip->rc.left = curpos_left;
                    ip->rc.right = curpos_right - 1;
                    curpos_left = curpos_right;
                }
            } else {
                /* complete fit */
                ip->rc.left = curpos_left;
                ip->rc.right = curpos_left + width;
                curpos_left += width + 1;
            }
        } else {

            /* same size check for right-aligned items */
            if (curpos_right-width <= curpos_left) {

                /* partial fit ? */
                if (curpos_right <= curpos_left+1) {
                    ip->rc.left = 0;
                    ip->rc.right = 0;
                } else {
                    /* yes - partial fit */
                    ip->rc.left = curpos_left + 1;
                    ip->rc.right = curpos_right;
                    curpos_right = curpos_left;
                }
            } else {
                /* complete fit */
                ip->rc.right = curpos_right;
                ip->rc.left = curpos_right - width;
                curpos_right -= (width + 1);
            }
        }
    }
}


void
StatusPaint(HWND hWnd, PILIST iplistp)
{
    RECT rc;
    HDC hDC;
    PAINTSTRUCT ps;
    int i;
    PSTATEL ip;
    HPEN hpenOld;

    GetClientRect(hWnd, &rc);
    hDC = BeginPaint(hWnd, &ps);
    InitDC(hDC);

    RaiseRect(hDC, &rc);
    if (iplistp == NULL) {
        EndPaint(hWnd, &ps);
        return;
    }
    for (i =0; i < iplistp->nitems; i++) {
        ip = &iplistp->statels[i];

        if (ip->rc.left == ip->rc.right) {
            continue;
        }
        if (ip->type == SF_STATIC) {
            if (ip->flags & SF_RAISE) {
                RaiseRect(hDC, &ip->rc);
            } else if (ip->flags & SF_LOWER) {
                LowerRect(hDC, &ip->rc);
            }
            rc = ip->rc;
            rc.left += (status_charwidth / 2);
            rc.right--;
            rc.top++;
            rc.bottom--;
            hpenOld = SelectObject(hDC, hpenNeutral);
            Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
            SelectObject(hDC, hpenOld);
            DrawText(hDC, ip->text, lstrlen(ip->text), &rc,
                     DT_LEFT | DT_VCENTER);
        } else {
            StatusButtonUp(hDC, ip);
        }
    }

    EndPaint(hWnd, &ps);
}

void
RaiseRect(HDC hDC, LPRECT rcp)
{
    TopLeft(hDC, rcp, hpenHilight, FALSE);
    BottomRight(hDC, rcp, hpenLowlight, FALSE);
}

void
LowerRect(HDC hDC, LPRECT rcp)
{
    TopLeft(hDC, rcp, hpenLowlight, FALSE);
    BottomRight(hDC, rcp, hpenHilight, FALSE);
}

void
StatusButtonUp(HDC hDC, PSTATEL ip)
{
    RECT rc;
    HPEN hpenOld;
    TEXTMETRIC tm;

    rc = ip->rc;
    TopLeft(hDC, &rc, hpenBlack, TRUE);
    BottomRight(hDC, &rc, hpenBlack, FALSE);

    rc.top++;
    rc.bottom--;
    rc.left++;
    rc.right--;
    TopLeft(hDC, &rc, hpenHilight, FALSE);
    BottomRight(hDC, &rc, hpenLowlight, TRUE);

    rc.top++;
    rc.bottom--;
    rc.left++;
    rc.right--;
    BottomRight(hDC, &rc, hpenLowlight, TRUE);
    rc.bottom--;
    rc.right--;
    hpenOld = SelectObject(hDC, hpenNeutral);
    Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
    SelectObject(hDC, hpenOld);
    GetTextMetrics(hDC, &tm);
    rc.top += tm.tmExternalLeading;
    DrawText(hDC, ip->text, lstrlen(ip->text), &rc, DT_CENTER | DT_VCENTER);
}

void
StatusButtonDown(HDC hDC, PSTATEL ip)
{
    RECT rc;
    HPEN hpenOld;
    TEXTMETRIC tm;

    rc = ip->rc;
    TopLeft(hDC, &rc, hpenBlack, TRUE);
    BottomRight(hDC, &rc, hpenBlack, FALSE);

    rc.top++;
    rc.bottom--;
    rc.left++;
    rc.right--;
    TopLeft(hDC, &rc, hpenLowlight, TRUE);
    rc.top++;
    rc.left++;
    TopLeft(hDC, &rc, hpenNeutral, TRUE);
    rc.top++;
    rc.left++;
    TopLeft(hDC, &rc, hpenNeutral, TRUE);
    rc.top++;
    rc.left++;
    hpenOld = SelectObject(hDC, hpenNeutral);
    Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
    SelectObject(hDC, hpenOld);
    GetTextMetrics(hDC, &tm);
    rc.top += tm.tmExternalLeading;
    DrawText(hDC, ip->text, lstrlen(ip->text), &rc, DT_CENTER | DT_VCENTER);
}

void
TopLeft(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners)
{
    HPEN hpenOld;
    int x, y;

    hpenOld = SelectObject(hDC, hpen);
    x = rcp->right - 1;
    y = rcp->bottom;
    if (!bCorners) {
        x--;
        y--;
    }
    MoveToEx(hDC, x, rcp->top, NULL);
    LineTo(hDC, rcp->left, rcp->top);
    LineTo(hDC, rcp->left, y);
    SelectObject(hDC, hpenOld);
}

void
BottomRight(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners)
{
    HPEN hpenOld;
    int x, y;

    hpenOld = SelectObject(hDC, hpen);
    x = rcp->left - 1;
    y = rcp->top;
    if (!bCorners) {
        x++;
        y++;
    }
    MoveToEx(hDC, rcp->right-1, y, NULL);
    LineTo(hDC, rcp->right-1, rcp->bottom-1);
    LineTo(hDC, x, rcp->bottom-1);
    SelectObject(hDC, hpenOld);
}


PSTATEL
StatusGetItem(PILIST plist, int id)
{
    int i;

    if (plist == NULL) {
        return(NULL);
    }
    for (i = 0; i < plist->nitems; i++) {
        if (plist->statels[i].id == id) {
            return(&plist->statels[i]);
        }
    }
    return(NULL);
}

/*
 * calculate the width of a given field. This is the width in characters
 * multiplied by the average character width, plus a few units for
 * borders.
 *
 * if SF_VAR is set, this field size varies depending on the text, so
 * we use GetTextExtent for the field size. If SF_VAR is selected, the caller
 * can specify that the size is not to exceed the (width * avecharwidth)
 * size (using SF_SZMAX) or that it is not be less than it (SF_SZMIN).
 */
int
StatusCalcWidth(HWND hWnd, PSTATEL ip)
{
    int ch_size, t_size;
    SIZE sz = {0};
    HDC hDC;

    ch_size = ip->width * status_charwidth;
    if (ip->flags & SF_VAR) {
        hDC = GetDC(hWnd);
        if (hDC)
        {
            InitDC(hDC);
            GetTextExtentPoint(hDC, ip->text, lstrlen(ip->text), &sz);
            ReleaseDC(hWnd, hDC);
        }
        t_size = sz.cx;

        /*
         * check this size against min/max size if
         * requested
         */

        if (ip->flags & SF_SZMIN) {
            if (ch_size > t_size) {
                t_size = ch_size;
            }
        }
        if (ip->flags & SF_SZMAX) {
            if (ch_size < t_size) {
                t_size = ch_size;
            }
        }
        ch_size = t_size;
    }

    if (ch_size != 0) {
        if (ip->type == SF_BUTTON) {
            return(ch_size+6);
        } else {
            return(ch_size+4);
        }
    } else {
        return(0);
    }
}

int
StatusCalcHeight(HWND hWnd, PSTATEL ip)
{
    int size;

    size = status_charheight;
    if (ip->type == SF_BUTTON) {
        return(size + 6);
    } else {
        return(size + 2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\table.c ===
/*
 * standard table class.
 *
 * main interface functions.
 *
 * see table.h for interface description
 */

#include <precomp.h>

#include "table.h"
#include "tpriv.h"



/* global tools etc */
extern HANDLE hLibInst;
HANDLE hVertCurs;
HANDLE hNormCurs;
HPEN hpenDotted;
UINT gtab_msgcode;

/* function prototypes */
LRESULT gtab_wndproc(HWND, UINT, WPARAM, LPARAM);
void gtab_createtools(void);
void gtab_deltable(HWND hwnd, lpTable ptab);
lpTable gtab_buildtable(HWND hwnd, DWORD_PTR id);
void gtab_setsize(HWND hwnd, lpTable ptab);
void gtab_newsize(HWND hwnd, lpTable ptab);
void gtab_calcwidths(HWND hwnd, lpTable ptab);
BOOL gtab_alloclinedata(HWND hwnd, HANDLE heap, lpTable ptab);
void gtab_invallines(HWND hwnd, lpTable ptab, int start, int count);
void gtab_append(HWND hwnd, lpTable ptab, int rows, DWORD_PTR id);

/*
 * initialise window class - called from DLL main init
 */
void
gtab_init(void)
{
    WNDCLASS wc;

    gtab_createtools();
    gtab_msgcode = RegisterWindowMessage(TableMessage);

    wc.style = CS_GLOBALCLASS | CS_DBLCLKS;
    wc.lpfnWndProc = gtab_wndproc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = WLTOTAL;
    wc.hInstance = hLibInst;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszClassName = TableClassName;
    wc.lpszMenuName = NULL;

    RegisterClass(&wc);
}

void
gtab_createtools(void)
{
    hVertCurs = LoadCursor(hLibInst, "VertLine");
    hNormCurs = LoadCursor(NULL, IDC_ARROW);

    hpenDotted = CreatePen(PS_DOT, 1, RGB(0, 0, 0));
}

void
gtab_deltools(void)
{
    DeleteObject(hpenDotted);
}


LRESULT
gtab_wndproc(
            HWND hwnd,
            UINT msg,
            WPARAM wParam,
            LPARAM lParam
            )
{
    CREATESTRUCT FAR * csp;
    HWND hOwner;
    lpTable ptab;
    HANDLE hHeap;
    lpTableSelection pselect;
    long oldtop;
    long change;

    switch (msg) {

        case WM_CREATE:
            /* create window. set the wnd extra bytes to
             * contain the owner window, a heap and a null table.
             * Owner window is either in lParam or the parent.
             * Then wait for TM_NEWID.
             */
            csp = (CREATESTRUCT FAR *) lParam;
            if (csp->lpCreateParams == NULL) {
                hOwner = GetParent(hwnd);
            } else {
                hOwner = (HWND) csp->lpCreateParams;
            }
            ptab = NULL;
            hHeap = gmem_init();
            SetWindowLongPtr(hwnd, WL_TABLE, (LONG_PTR) ptab);
            SetWindowLongPtr(hwnd, WW_OWNER, (LONG_PTR) hOwner);
            SetWindowLongPtr(hwnd, WW_HEAP, (LONG_PTR) hHeap);

            SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
            SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
            break;

        case TM_NEWID:
            /* complete change of table.
             * close old table, discard memory and
             * build new table
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_sendtq(hwnd, TQ_CLOSE, ptab->hdr.id);
                gtab_deltable(hwnd, ptab);
                SetCursor(hNormCurs);
                SetWindowLongPtr(hwnd, WL_TABLE, 0);
            }
            if ( (ptab = gtab_buildtable(hwnd, (DWORD_PTR)lParam)) != NULL) {
                SetWindowLongPtr(hwnd, WL_TABLE, (LONG_PTR) ptab);
                gtab_setsize(hwnd, ptab);
            } else {
                SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
                SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
            }
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case TM_NEWLAYOUT:
            /* change of layout but for same id. no TQ_CLOSE,
             * but otherwise same as TM_NEWID
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_deltable(hwnd, ptab);
                SetCursor(hNormCurs);
                SetWindowLongPtr(hwnd, WL_TABLE, 0);
            }
            if ( (ptab = gtab_buildtable(hwnd, (DWORD_PTR)lParam)) != NULL) {
                SetWindowLongPtr(hwnd, WL_TABLE, (LONG_PTR) ptab);
                gtab_setsize(hwnd, ptab);
            } else {
                SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
                SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
            }
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case TM_REFRESH:
            /* data in table has changed. nrows may have
             * changed. ncols and col types have not changed
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_newsize(hwnd, ptab);
                gtab_sendtq(hwnd, TQ_SHOWWHITESPACE, (LPARAM) &ptab->show_whitespace);
            }
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case TM_SELECT:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                pselect = (lpTableSelection) lParam;

                gtab_select(hwnd, ptab, pselect->startrow,
                            pselect->startcell,
                            pselect->nrows,
                            pselect->ncells,
                            TRUE);
                gtab_showsel_middle(hwnd, ptab, pselect->dyRowsFromTop);
            }
            break;

        case TM_GETSELECTION:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                pselect = (lpTableSelection) lParam;

                *pselect = ptab->select;
            }
            break;

        case TM_PRINT:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            hHeap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
            if (ptab != NULL) {
                return gtab_print(hwnd, ptab, hHeap, (lpPrintContext) lParam);
            }
            return FALSE;

        case TM_SETTABWIDTH:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (!ptab)
                return 0;
            ptab->tabchars = (int)lParam;
            InvalidateRect(hwnd, NULL, FALSE);
            break;

        case TM_TOPROW:

            /* return top row. if wParam is TRUE, set lParam
             * as the new toprow
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab == NULL) {
                return(0);
            }
            oldtop = ptab->toprow;
            if ((wParam) && (lParam < ptab->hdr.nrows)) {
                change = (long)lParam - ptab->toprow;
                change -= ptab->hdr.fixedrows;
                gtab_dovscroll(hwnd, ptab, change);
            }
            return(oldtop);

        case TM_ENDROW:
            /* return the last visible row in the window */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab == NULL) {
                return(0);
            }
            return(ptab->nlines + ptab->toprow - 1);


        case TM_APPEND:
            /* new rows have been added to the end of the
             * table, but the rest of the table has not
             * been changed. Update without forcing redraw of
             * everything.
             * lParam contains the new total nr of rows
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_append(hwnd, ptab, (int) wParam, (DWORD_PTR)lParam);
                return(TRUE);
            }
            break;

        case WM_SIZE:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_setsize(hwnd, ptab);
            }
            break;

        case WM_ERASEBKGND:
            return TRUE;

        case WM_DESTROY:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_sendtq(hwnd, TQ_CLOSE, ptab->hdr.id);
                gtab_deltable(hwnd, ptab);
            }
            hHeap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
            gmem_freeall(hHeap);
            break;

        case WM_SYSCOLORCHANGE:
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case WM_PAINT:
            gtab_paint(hwnd);
            break;

        case WM_HSCROLL:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_msg_hscroll(hwnd, ptab,
                                 GET_SCROLL_OPCODE(wParam, lParam),
                                 GET_SCROLL_POS(wParam, lParam));
            }
            break;

        case WM_VSCROLL:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_msg_vscroll(hwnd, ptab,
                                 GET_SCROLL_OPCODE(wParam, lParam),
                                 GET_SCROLL_POS(wParam, lParam));
            }
            break;

        case WM_MOUSEMOVE:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_move(hwnd, ptab, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam));
            } else {
                SetCursor(hNormCurs);
            }
            break;

        case WM_LBUTTONDOWN:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_press(hwnd, ptab, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam));
            }
            break;

        case WM_RBUTTONDOWN:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_rightclick(hwnd, ptab, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam));
            }
            break;

        case WM_LBUTTONUP:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_release(hwnd, ptab,
                             (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam));
            }
            break;

        case WM_LBUTTONDBLCLK:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_dblclick(hwnd, ptab,
                              (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam));
            }
            break;

        case WM_KEYDOWN:
            /* handle key presses for cursor movement about
             * the table, and return/space for selection.
             * Any key we don't handle is passed to the owner window
             * for him to handle.
             * The table window should have the focus
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                if (gtab_key(hwnd, ptab, (int)wParam) != 0) {
                    /* pass key to owner since
                     * we don't know what to do with it
                     */
                    hOwner = (HANDLE) GetWindowLongPtr(hwnd, WW_OWNER);
                    return(SendMessage(hOwner, WM_KEYDOWN, wParam, lParam));
                } else {
                    return(0);
                }
            }
            break;

#ifdef WM_MOUSEWHEEL
        case WM_MOUSEWHEEL:
            ptab = (lpTable)GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                if (gtab_mousewheel(hwnd,ptab, LOWORD(wParam), (short)HIWORD(wParam))) {
                    // Input was not handled. Need to forward to the owner.
                    hOwner = (HWND)GetWindowLongPtr(hwnd, WW_OWNER);
                    return SendMessage(hOwner, WM_MOUSEWHEEL, wParam, lParam);
                }
            }
            break;
#endif

        default:
            return(DefWindowProc(hwnd, msg, wParam, lParam));
    }
    return(TRUE);
}

/*
 * send a table-query message to the owner window. returns message
 * value.
 */
INT_PTR
gtab_sendtq(
           HWND hwnd,
           UINT cmd,
           LPARAM lParam
           )
{
    HWND hOwner;

    hOwner = (HANDLE) GetWindowLongPtr(hwnd, WW_OWNER);
    return (SendMessage(hOwner, gtab_msgcode, cmd, lParam));
}

/*
 * free the memory allocated for the array of lines (each containing
 * an array of Cells, each containing an array of chars for the actual
 * data). Called on any occasion that would change the number of visible lines
 */
void
gtab_freelinedata(
                 HANDLE hHeap,
                 lpTable ptab
                 )
{
    int i, j, ncols;
    lpCellData cd;


    ncols = ptab->hdr.ncols;

    /* for each line */
    for (i = 0; i < ptab->nlines; i++) {
        /* for each cell */
        for (j = 0; j < ncols; j++) {
            /* free up the actual text space */
            cd = &ptab->pdata[i].pdata[j];
            gmem_free(hHeap, (LPSTR) cd->ptext, cd->nchars);
            gmem_free(hHeap, (LPSTR) cd->pwzText, cd->nchars);
        }
        /* dealloc array of CellData */
        gmem_free(hHeap, (LPSTR) ptab->pdata[i].pdata,
                  sizeof(CellData) * ncols);
    }
    /* de-alloc array of linedatas */
    gmem_free(hHeap, (LPSTR) ptab->pdata,
              sizeof(LineData) * ptab->nlines);
    ptab->pdata = NULL;
}

/* allocate and init array of linedatas (include cell array
 * and text for each cell)
 */
BOOL
gtab_alloclinedata(
                  HWND hwnd,
                  HANDLE heap,
                  lpTable ptab
                  )
{
    lpLineData pline;
    lpCellData cd;
    int i, j;

    ptab->pdata = (lpLineData) gmem_get(heap,
                                        sizeof(LineData) * ptab->nlines);
    if (ptab->pdata == NULL) {
        return(FALSE);
    }
    for (i = 0; i < ptab->nlines; i++) {
        pline = &ptab->pdata[i];
        pline->linepos.size = ptab->rowheight;
        pline->pdata = (lpCellData) gmem_get(heap,
                                             sizeof(CellData) * ptab->hdr.ncols);
        if (pline->pdata == NULL) {
            return(FALSE);
        }
        for (j = 0; j < ptab->hdr.ncols; j++) {
            cd = &pline->pdata[j];
            cd->props.valid = 0;
            cd->flags = 0;
            cd->nchars = ptab->pcolhdr[j].nchars;
            if (cd->nchars > 0) {
                cd->ptext = gmem_get(heap, cd->nchars);
                if (cd->ptext == NULL) {
                    return(FALSE);
                }
                cd->pwzText = 0;
            }
        }
    }
    return(TRUE);
}

/*
 * free up all table data structures. Called for new layout or new data.
 */
void
gtab_deltable(
             HWND hwnd,
             lpTable ptab
             )
{
    HANDLE hHeap;
    int ncols;

    if (ptab == NULL) {
        return;
    }
    hHeap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
    ncols = ptab->hdr.ncols;

    if (ptab->pcolhdr != NULL) {
        gmem_free(hHeap, (LPSTR) ptab->pcolhdr,
                  sizeof(ColProps) * ncols);
    }
    if (ptab->pcellpos != NULL) {
        gmem_free(hHeap, (LPSTR) ptab->pcellpos,
                  sizeof(CellPos) * ncols);
    }
    if (ptab->pdata != NULL) {
        gtab_freelinedata(hHeap, ptab);
    }
    gmem_free(hHeap, (LPSTR) ptab, sizeof(Table));
}


/*
 * build up a Table struct (excluding data allocation and
 * anything to do with font or window size).
 * return ptr to this or NULL if error
 */
lpTable
gtab_buildtable(
               HWND hwnd,
               DWORD_PTR id
               )
{
    lpTable ptab;
    HANDLE hHeap;
    int ncols, i;
    ColPropsList cplist;

    hHeap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
    ptab = (lpTable) gmem_get(hHeap, sizeof(Table));
    if (ptab == NULL) {
        return(NULL);
    }

    // get the tab width. most clients will not support this
    if (gtab_sendtq(hwnd, TQ_TABS, (LPARAM) &ptab->tabchars) == FALSE) {
        ptab->tabchars = TABWIDTH_DEFAULT;
    }

    // get the show whitespace value
    if (gtab_sendtq(hwnd, TQ_SHOWWHITESPACE, (LPARAM) &ptab->show_whitespace) == FALSE) {
        ptab->show_whitespace = FALSE;
    }

    /* get the row/column count from owner window */
    ptab->hdr.id = id;
    ptab->hdr.props.valid = 0;
    ptab->hdr.sendscroll = FALSE;
    if (gtab_sendtq(hwnd, TQ_GETSIZE, (LPARAM) &ptab->hdr) == FALSE) {
        return(NULL);
    }

    ncols = ptab->hdr.ncols;
    ptab->pcolhdr = (lpColProps) gmem_get(hHeap, sizeof(ColProps) * ncols);
    if (ptab->pcolhdr == NULL) {
        /* should prob send TQ_CLOSE at this point */
        return(NULL);
    }

    /* init col properties to default */
    for (i=0; i < ncols; i++) {
        ptab->pcolhdr[i].props.valid = 0;
        ptab->pcolhdr[i].nchars = 0;
    }
    /* get the column props from owner */
    cplist.plist = ptab->pcolhdr;
    cplist.id = id;
    cplist.startcol = 0;
    cplist.ncols = ncols;
    gtab_sendtq(hwnd, TQ_GETCOLPROPS, (LPARAM) &cplist);

    /* init remaining fields */
    ptab->pcellpos = (lpCellPos) gmem_get(hHeap, sizeof(CellPos) * ncols);
    if (ptab->pcellpos == NULL) {
        return(NULL);
    }

    ptab->scrollscale = 1;
    ptab->scroll_dx = 0;
    ptab->toprow = 0;
    ptab->pdata = NULL;
    ptab->nlines = 0;
    ptab->trackmode = TRACK_NONE;

    /* we have to notify owner of the current selection
     * whenever it is changed
     */
    ptab->select.id = id;
    gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);

    /* calc ave height/width, cell widths and min height.
     * these change only when cell properties / col count changes -
     * ie only on rebuild-header events
     */
    gtab_calcwidths(hwnd, ptab);
    return(ptab);
}

/* set sizes that are based on window size and scroll pos
 * set:
 *      winwidth
 *      nlines
 *      cellpos start, clip start/end
 * alloc linedata and init
 */
void
gtab_setsize(
            HWND hwnd,
            lpTable ptab
            )
{
    RECT rc;
    int nlines;
    HANDLE heap;
    long change;
    SCROLLINFO si;

    GetClientRect(hwnd, &rc);
    ptab->winwidth = rc.right - rc.left;
    nlines = (rc.bottom - rc.top) / ptab->rowheight;
    /* nlines is the number of whole lines - add one extra
     * for the partial line at the bottom
     */
    nlines += 1;

    /* alloc space for nlines of data - if nlines has changed */
    if (nlines != ptab->nlines) {
        heap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
        gtab_freelinedata(heap, ptab);
        ptab->nlines = nlines;
        if (!gtab_alloclinedata(hwnd, heap, ptab)) {
            ptab->nlines = 0;
            return;
        }
    }

    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE|SIF_RANGE;
    si.nMin = 0;

    /* set scroll vertical range */
    si.nMax = ptab->hdr.nrows;
    si.nPage = ptab->nlines;
    if (si.nMax < 0) {
        si.nMax = 0;
        change =  -(ptab->toprow);
    } else if (ptab->toprow > si.nMax) {
        change = si.nMax - ptab->toprow;
    } else {
        change = 0;
    }
    /* the scroll range must be 16-bits for Win3
     * scale until this is true
     */
    ptab->scrollscale = 1;
    while (si.nMax > 32766) {
        ptab->scrollscale *= 16;
        si.nMax /= 16;
        si.nPage /= 16;
    }
    if (!si.nPage)
        si.nPage = 1;

    SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
    gtab_dovscroll(hwnd, ptab, change);

    /* set horz scroll range */
    si.nMax = ptab->rowwidth;
    si.nPage = ptab->winwidth;
    if (si.nMax < 0) {
        si.nMax = 0;
        change = -(ptab->scroll_dx);
    } else if (ptab->scroll_dx > si.nMax) {
        change = si.nMax - ptab->scroll_dx;
    } else {
        change = 0;
    }
    /* horz scroll range will always be < 16 bits */
    SetScrollInfo(hwnd, SB_HORZ, &si, TRUE);
    gtab_dohscroll(hwnd, ptab, change);
}

/* set column widths/height and totals (based on column props)
 * - no assumption of window size (see gtab_setsize)
 * sets avewidth,rowheight,cellpos.size,rowwidth (total of cellpos.size)
 */
void
gtab_calcwidths(
               HWND hwnd,
               lpTable ptab
               )
{
    int i, cxtotal, cx, ave;
    TEXTMETRIC tm = {0};
    TEXTMETRIC tmcol = {0};
    HDC hdc;
    lpProps hdrprops, cellprops;
    HFONT hfont;

    hfont = NULL;  /* eliminate spurious diagnostic, make code worse */
    hdrprops = &ptab->hdr.props;
    hdc = GetDC(hwnd);
    if (hdc)
    {
        GetTextMetrics(hdc, &tm);
        ptab->rowheight = tm.tmHeight + tm.tmExternalLeading;
        if (hdrprops->valid & P_FONT) {
            hfont = SelectObject(hdc, hdrprops->hFont);
        }
        GetTextMetrics(hdc, &tm);
        if (hdrprops->valid & P_FONT) {
            SelectObject(hdc, hfont);
        }
        ReleaseDC(hwnd, hdc);
    }
    else
    {
        // arbitrary, whatever...
        ptab->rowheight = 14;
        tm.tmHeight = 14;
        tm.tmAveCharWidth = 5;
    }

    /* get width and height of average character */
    ptab->avewidth = tm.tmAveCharWidth;
    if (tm.tmHeight + tm.tmExternalLeading < ptab->rowheight - 2 ||
        tm.tmHeight + tm.tmExternalLeading > ptab->rowheight) {
        // fudge so the default FixedSys (and anything of similar size)
        // doesn't vertically clip the System font used for line numbers,
        // filenames, etc.
        ptab->rowheight = tm.tmHeight;
        if (tm.tmExternalLeading)
            ptab->rowheight += tm.tmExternalLeading;
        else
            ptab->rowheight++;
    }
    if (hdrprops->valid & P_HEIGHT) {
        ptab->rowheight = hdrprops->height;
    }

    /* set pixel width of each cell (and add up for row total)
     * based on ave width * nr chars, unless P_WIDTH set
     */
    cxtotal = 0;
    for (i = 0; i < ptab->hdr.ncols; i++) {
        cellprops = &ptab->pcolhdr[i].props;

        if (cellprops->valid & P_WIDTH) {
            cx = cellprops->width;
        } else if (hdrprops->valid & P_WIDTH) {
            cx = hdrprops->width;
        } else {

            if (cellprops->valid & P_FONT) {
                hdc = GetDC(hwnd);
                if (hdc)
                {
                    hfont = SelectObject(hdc, cellprops->hFont);
                    GetTextMetrics(hdc, &tmcol);
                    SelectObject(hdc, hfont);
                    ReleaseDC(hwnd, hdc);
                    ave = tmcol.tmAveCharWidth;
                }
                else
                    ave = 5;        // arbitrary, whatever...
            } else {
                ave = ptab->avewidth;
            }
            /* ave width * nchars */
            cx =  ptab->pcolhdr[i].nchars + 1;
            cx *= ave;
        }
        /* add 2 pixels for box lines */
        cx += 2;
        ptab->pcellpos[i].size = cx;
        cxtotal += cx;
    }
    ptab->rowwidth = cxtotal;
}

/* called when row data + possible nrows changes.
 * other changes are ignored
 */
void
gtab_newsize(
            HWND hwnd,
            lpTable ptab
            )
{
    TableHdr hdr;

    /* get new row count */
    hdr = ptab->hdr;
    gtab_sendtq(hwnd, TQ_GETSIZE, (LPARAM) &hdr);
    if (hdr.nrows != ptab->hdr.nrows) {
        ptab->hdr.nrows = hdr.nrows;
        gtab_setsize(hwnd, ptab);
    }

    gtab_invallines(hwnd, ptab, 0, ptab->nlines);

    InvalidateRect(hwnd, NULL, FALSE);
}

void
gtab_invallines(
               HWND hwnd,
               lpTable ptab,
               int start,
               int count
               )
{
    int i, j;

    for (i = start; i < start + count; i++) {
        for (j = 0; j < ptab->hdr.ncols; j++) {
            ptab->pdata[i].pdata[j].flags = 0;
        }
    }
}

/* new rows have been added to the table. adjust the scroll range and
 * position, and redraw the rows if the end of the table is currently
 * visible.
 * rows = the new total row count.
 */
void
gtab_append(
           HWND hwnd,
           lpTable ptab,
           int rows,
           DWORD_PTR id
           )
{
    long oldrows;
    int line, nupdates;
    RECT rc;
    SCROLLINFO si;


    /* change to the new id */
    ptab->hdr.id = id;
    ptab->select.id = id;

    /* update the header, but remember the old nr of rows
     * so we know where to start updating
     */
    oldrows = ptab->hdr.nrows;

    /* check that the new nr of rows is not smaller. this is
     * illegal at this point and should be ignored
     */
    if (oldrows >= rows) {
        return;
    }

    ptab->hdr.nrows = rows;

    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE|SIF_RANGE;
    si.nMin = 0;

    /* set the vertical scroll range */
    si.nMax = rows;
    si.nPage = ptab->nlines;
    if (si.nMax < 0) {
        si.nMax = 0;
    }

    /* force the scroll range into 16-bits for win 3.1 */
    ptab->scrollscale = 1;
    while (si.nMax > 32766) {
        ptab->scrollscale *= 16;
        si.nMax /= 16;
        si.nPage /= 16;
    }
    if (!si.nPage)
        si.nPage = 1;

    /* now set the scroll bar range and position */
    SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
    if (si.nMax > 0) {
        SetScrollPos(hwnd, SB_VERT,
                     (int) (ptab->toprow / ptab->scrollscale), TRUE);
    }

    /* calculate which screen lines need to be updated - find what
     * screen line the start of the new section is at
     */
    line = gtab_rowtoline(hwnd, ptab, oldrows);
    if (line == -1) {
        /* not visible -> no more to do */
        return;
    }

    /* how many lines to update - rest of screen or nr of
     * new lines if less than rest of screen
     */
    nupdates = min((ptab->nlines - line), (int)(rows - oldrows));

    /* invalidate the screen line buffers to indicate data
     * needs to be refetch from parent window
     */
    gtab_invallines(hwnd, ptab, line, nupdates);

    /* calculate the region of the screen to be repainted -
     * left and right are same as window. top and bottom
     * need to be calculated from screen line height
     */

    GetClientRect(hwnd, &rc);
    rc.top += line * ptab->rowheight;
    rc.bottom = rc.top + (nupdates * ptab->rowheight);

    /* force a repaint of the updated region */
    InvalidateRect(hwnd, &rc, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\server\errlog.h ===
/*
 * error text and time logging
 *
 * Functions to log a text string and the system time to a buffer that can
 * be sent to a log-reader application.
 */

/*
 * Log_Create returns this handle. You don't need to know the
 * structure layout or size.
 */
typedef struct error_log * HLOG;


/* create an empty log */
HLOG Log_Create(void);

/* delete a log */
VOID Log_Delete(HLOG);

/* write a text string (and current time) to the log - printf format */
VOID Log_Write(HLOG, char * szFormat, ...);

/* write a previous formatted string and a time to the log */
VOID Log_WriteData(HLOG, LPFILETIME, LPSTR);

/* send a log to a named-pipe client */
VOID Log_Send(HANDLE hpipe, HLOG hlog);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\utils.c ===
/*
 * utils.c
 *
 *
 * some standard file-reading, hashing and checksum routines.

 *
 * Geraint Davies, July 92
 */

#include <precomp.h>

#include <winnls.h>

#include "gutilsrc.h"


#define IS_BLANK(c) \
    (((c) == ' ') || ((c) == '\t') || ((c) == '\r'))

const WCHAR c_wchMagic = 0xfeff;        // magic marker for Unicode files


/*
 * we need an instance handle. this should be the dll instance
 */
extern HANDLE hLibInst;

/*
 * -- forward declaration of procedures -----------------------------------
 */
INT_PTR CALLBACK dodlg_stringin(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/*-- readfile: buffered line input ------------------------------*/

/*
 * set of functions to read a line at a time from a file, using
 * a buffer to read a block at a time from the file
 *
 */

/*
 * a FILEBUFFER handle is a pointer to a struct filebuffer
 */
struct filebuffer {
    HANDLE fh;      /* open file handle */
    LPSTR start;    /* offset within buffer of next character */
    LPSTR last;     /* offset within buffer of last valid char read in */

    char buffer[BUFFER_SIZE];

    BOOL fUnicode;  /* TRUE if the file is Unicode */
    WCHAR wzBuffer[MAX_LINE_LENGTH];
    LPWSTR pwzStart;
    LPWSTR pwzLast;
};

typedef enum {
    CT_LEAD = 0,
    CT_TRAIL = 1,
    CT_ANK = 2,
    CT_INVALID = 3,
} DBCSTYPE;

DBCSTYPE
DBCScharType(
            LPTSTR str,
            int index
            )
{
    /*
        TT .. ??? maybe LEAD or TRAIL
        FT .. second == LEAD
        FF .. second == ANK
        TF .. ??? maybe ANK or TRAIL
    */
    // (chrisant) this was really broken to use lstrlen here; readfile_next
    // uses this on fbuf->buffer which is explicitly NOT null-terminated.
    if ( index >= 0 /*|| index <= lstrlen(str)*/ ) {   //  EOS is valid parameter.
        LPTSTR pos = str + index;
        DBCSTYPE candidate = (IsDBCSLeadByte( *pos-- ) ? CT_LEAD : CT_ANK);
        BOOL maybeTrail = FALSE;
        for ( ; pos >= str; pos-- ) {
            if ( !IsDBCSLeadByte( *pos ) )
                break;
            maybeTrail ^= 1;
        }
        return maybeTrail ? CT_TRAIL : candidate;
    }
    return CT_INVALID;
}

/*
 * initialise a filebuffer and return a handle to it
 */
FILEBUFFER
APIENTRY
readfile_new(
            HANDLE fh,
            BOOL *pfUnicode
            )
{
    FILEBUFFER fbuf;
    UINT cbRead;
    WCHAR wchMagic;

    if (pfUnicode)
        *pfUnicode = FALSE;

    fbuf = (FILEBUFFER) GlobalLock(GlobalAlloc(LHND, sizeof(struct filebuffer)));
    if (fbuf == NULL) {
        return(NULL);
    }

    if (pfUnicode)
    {
        /* return file pointer to beginning of file */
        SetFilePointer(fh, 0, NULL, FILE_BEGIN);

        if (!ReadFile(fh, &wchMagic, sizeof(wchMagic), &cbRead, NULL)) {
            GlobalFree(fbuf);
            return (NULL);
        }

        fbuf->fh = fh;
        fbuf->start = fbuf->buffer;
        fbuf->last = fbuf->buffer;
        fbuf->fUnicode = FALSE;
        if (cbRead == 2 && c_wchMagic == wchMagic)
        {
            fbuf->fUnicode = TRUE;
            *pfUnicode = TRUE;
            fbuf->pwzStart = fbuf->wzBuffer;
            fbuf->pwzLast = fbuf->wzBuffer;
        }
        else
        {
            SetFilePointer(fh, 0, NULL, FILE_BEGIN);
        }
    }

    return(fbuf);
}

/* delims is the set of delimiters used to break lines
 * For program source files the delimiter is \n.
 * Full stop (aka period) i.e. "." is another obvious one.
 * The delimiters are taken as
 * being part of the line they terminate.
 *
 * The current strategy will NOT port to UNICODE easily!  It relies on having a
 * character set for which we can easily allocate one byte per character in the set.
 *
 * The model is that it only makes sense to have one set of delimiters on the go.
 * If we allow different delimiters for each file then we could make delims a field
 * in a struct filebuffer.
 */
static BYTE delims[256];

/* set str to be the set of delims.  str is a \0 delimited string */
void
APIENTRY
readfile_setdelims(
                  LPBYTE str
                  )
{
    /* clear all bytes of delims */
    int i;
    for (i=0; i<256; ++i) {
        delims[i] = 0;
    }

    /* set the bytes in delims which correspond to delimiters */
    for (; *str; ++str) {delims[(int)(*str)] = 1;
    }

} /* readfile_setdelims */


static BOOL FFindEOL(FILEBUFFER fbuf, LPSTR *ppszLine, int *pcch, LPWSTR *ppwzLine, int *pcwch)
{
    LPSTR psz;
    LPWSTR pwz;

    if (fbuf->fUnicode)
    {
        for (pwz = fbuf->pwzStart; pwz < fbuf->pwzLast; pwz++)
        {
            if (!*pwz)
                *pwz = '.';

            //$ review: (chrisant) not strictly correct, but easiest for now
            // to get unicode up and limping.
            if (*pwz < 256 && delims[*pwz])
            {
                *pcwch = (UINT)(pwz - fbuf->pwzStart) + 1;
                *ppwzLine = fbuf->pwzStart;
                fbuf->pwzStart += *pcwch;
                // notice we fall thru and let the loop below actually return
                break;
            }
        }
    }
    for (psz = fbuf->start; psz < fbuf->last; psz = CharNext(psz))
    {
        if (!*psz)
            *psz = '.';

        // use LPBYTE cast to make sure sign extension doesn't index
        // negatively!
        if (delims[*(LPBYTE)psz])
        {
            *pcch = (UINT)(psz - fbuf->start) + 1;
            *ppszLine = fbuf->start;
            fbuf->start += *pcch;
            return TRUE;
        }
    }
    return FALSE;
}


/*
 * get the next line from a file. returns a pointer to the line
 * in the buffer - so copy it before changing it.
 *
 * the line is *not* null-terminated. *plen is set to the length of the
 * line.
 *
 * A line is terminated by any character in the static var set delims.
 */
__declspec(thread) char szACP[MAX_LINE_LENGTH * sizeof(WCHAR)];
__declspec(thread) WCHAR wzRoundtrip[MAX_LINE_LENGTH];

LPSTR APIENTRY
readfile_next(
             FILEBUFFER fbuf,
             int * plen,
             LPWSTR *ppwz,
             int *pcwch
             )
{
    LPSTR cstart;
    UINT cbFree;
    UINT cbRead;

    //$ FUTURE: (chrisant) THIS DOES NOT HANDLE UNICODE 3.0 SURROGATE PAIRS
    // CORRECTLY YET.

    *ppwz = NULL;
    *pcwch = 0;

    /* look for an end of line in the buffer we have */
    if (FFindEOL(fbuf, &cstart, plen, ppwz, pcwch))
    {
        return cstart;
    }

    /* no delimiter in this buffer - this buffer contains a partial line.
     * copy the partial up to the beginning of the buffer, and
     * adjust the pointers to reflect this move
     */
    if (fbuf->fUnicode)
    {
        memmove(fbuf->wzBuffer, fbuf->pwzStart, (LPBYTE)fbuf->pwzLast - (LPBYTE)fbuf->pwzStart);
        fbuf->pwzLast = fbuf->wzBuffer + (fbuf->pwzLast - fbuf->pwzStart);
        fbuf->pwzStart = fbuf->wzBuffer;
    }
    memmove(fbuf->buffer, fbuf->start, (LPBYTE)fbuf->last - (LPBYTE)fbuf->start);
    fbuf->last = fbuf->buffer + (fbuf->last - fbuf->start);
    fbuf->start = fbuf->buffer;

    /* read in to fill the block */
    if (fbuf->fUnicode)
    {
        // HACK: for unicode files, we'll read in the unicode and convert it
        // to ansi.  we try to be clever by converting to ACP, then converting
        // back to unicode, and comparing the two unicode strings.  for any
        // wchars that are not identical, we replace them with 5-byte hex
        // codes of the format xFFFF.
        UINT cchAnsi;
        UINT cchWide;
        UINT cchRoundtrip;
        LPWSTR pwzOrig;
        LPCWSTR pwzRoundtrip;
        LPSTR pszACP;

        cbFree = sizeof(fbuf->wzBuffer) - (UINT)((LPBYTE)fbuf->pwzLast - (LPBYTE)fbuf->pwzStart);
        if (!ReadFile(fbuf->fh, fbuf->pwzLast, cbFree, &cbRead, NULL)) {
            return NULL;
        }
        //$ FUTURE: (chrisant) what if we read an odd number of bytes?  how
        // will that impact the SetFilePointer(... -1 ...) calls near the
        // bottom of this function?

        // wide to ansi
        cchWide = cbRead / 2;
        cchAnsi = WideCharToMultiByte(GetACP(),
                                      0,
                                      fbuf->pwzLast,
                                      cchWide,
                                      szACP,
                                      DimensionOf(szACP),
                                      NULL,
                                      NULL);

        // round trip, to find chars not in ACP
        cchRoundtrip = MultiByteToWideChar(GetACP(),
                                           0,
                                           szACP,
                                           cchAnsi,
                                           wzRoundtrip,
                                           DimensionOf(wzRoundtrip));

        // find non-ACP chars
        pwzOrig = fbuf->pwzLast;
        pwzRoundtrip = wzRoundtrip;
        pszACP = szACP;
        while (cchWide && cchRoundtrip)
        {
            if (*pwzOrig == *pwzRoundtrip)
            {
                // copy the DBCS representation into the buffer
                if (IsDBCSLeadByte(*pszACP))
                    *(fbuf->last++) = *(pszACP++);
                *(fbuf->last++) = *(pszACP++);
            }
            else
            {
                // copy a hexized representation into the buffer
                static const char rgHex[] = "0123456789ABCDEF";
                *(fbuf->last++) = 'x';
                *(fbuf->last++) = rgHex[((*pwzOrig) >> 12) & 0xf];
                *(fbuf->last++) = rgHex[((*pwzOrig) >>  8) & 0xf];
                *(fbuf->last++) = rgHex[((*pwzOrig) >>  4) & 0xf];
                *(fbuf->last++) = rgHex[((*pwzOrig) >>  0) & 0xf];
                if (IsDBCSLeadByte(*pszACP))
                    pszACP++;
                pszACP++;
            }

            ++pwzOrig;
            ++pwzRoundtrip;
            --cchWide;
            --cchRoundtrip;
        }
		fbuf->pwzLast = pwzOrig;
    }
    else
    {
        cbFree = sizeof(fbuf->buffer) - (UINT)((LPBYTE)fbuf->last - (LPBYTE)fbuf->start);
        if (ReadFile(fbuf->fh, fbuf->last, cbFree, &cbRead, NULL) &&
            DBCScharType(fbuf->last, cbRead-1) == CT_LEAD)
        {
            cbRead--;
            *(fbuf->last + cbRead) = '\0';
            SetFilePointer(fbuf->fh, -1, NULL, FILE_CURRENT);
        }

        fbuf->last += cbRead;
    }

    /* look for an end of line in the newly filled buffer */
    if (FFindEOL(fbuf, &cstart, plen, ppwz, pcwch))
    {
        return cstart;
    }

    /* still no end of line. either the buffer is empty -
     * because of end of file - or the line is longer than
     * the buffer. in either case, return all that we have
     */

    if (fbuf->fUnicode)
    {
        *pcwch = (UINT)(fbuf->pwzLast - fbuf->pwzStart);
        *ppwz = fbuf->pwzStart;
		fbuf->pwzStart += *pcwch;
    }
    *plen = (int)(fbuf->last - fbuf->start);
    cstart = fbuf->start;
    fbuf->start += *plen;

    if (*plen == 0) {
        return(NULL);
    } else {
        return(cstart);
    }
}


/*
 * delete a FILEBUFFER -  free the buffer. We should NOT close the
 * handle at this point as we did not open it. the opener should close
 * it with a function that corresponds to however he opened it.
 */
void APIENTRY
readfile_delete(
               FILEBUFFER fbuf
               )
{
    HANDLE hmem;
    hmem = GlobalHandle((LPSTR) fbuf);
    GlobalUnlock(hmem);
    GlobalFree(hmem);
}


/* --- checksum ----------------------------------------------------  */

/*
 * Produce a checksum for a file:
 * Open a file, checksum it and close it again. err !=0 iff it failed.
 *
 * Overall scheme:
 *         Read in file in blocks of 8K (arbitrary number - probably
 *         beneficial if integral multiple of disk block size).
 *         Generate checksum by the formula
 *         checksum = SUM( rnd(i)*(dword[i]) )
 *         where dword[i] is the i-th dword in the file, the file being
 *         extended by up to three binary zeros if necessary.
 *         rnd(x) is the x-th element of a fixed series of pseudo-random
 *         numbers.
 *
 * You may notice that dwords that are zero do not contribute to the checksum.
 * This worried me at first, but it's OK.  So long as everything else DOES
 * contribute, the checksum still distinguishes between different files
 * of the same length whether they contain zeros or not.
 * An extra zero in the middle of a file will also cause all following non-zero
 * bytes to have different multipliers.  However the algorithm does NOT
 * distinguish between files which only differ in zeros at the end of the file.
 * Multiplying each dword by a pseudo-random function of its position
 * ensures that "anagrams" of each other come to different sums,
 * i.e. the file AAAABBBB will be different from BBBBAAAA.
 * The pseudorandom function chosen is successive powers of 1664525 modulo 2**32
 * 1664525 is a magic number taken from Donald Knuth's "The Art Of Computer Programming"
 *
 * The function appears to be compute bound.  Loop optimisation is appropriate!
 */
CHECKSUM
APIENTRY
checksum_file(
             LPCSTR fn,
             LONG * err
             )
{
    HANDLE fh;
#define BUFFLEN 8192
    BYTE buffer[BUFFLEN];
    unsigned long lCheckSum = 0;         /* grows into the checksum */
    const unsigned long lSeed = 1664525; /* seed for random (Knuth) */
    unsigned long lRand = 1;             /* seed**n */
    unsigned Byte = 0;                   /* buffer[Byte] is next byte to process */
    unsigned Block = 0;                  /* number of bytes in buffer */
    BOOL Ending = FALSE;                 /* TRUE => binary zero padding added */
    int i;                               /* temp loop counter */

    *err = -2;                            /* default is "silly" */

    /* conceivably someone is fiddling with the file...?
       we give 6 goes, with delays of 1,2,3,4 and 5 secs between
    */
    for (i=0; i<=5; ++i) {
        Sleep(1000*i);
        fh = CreateFile(fn, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
        if (fh!=INVALID_HANDLE_VALUE)
            break;

        {
            char msg[300];
            wsprintf( msg, "Windiff: retry open. Error(%d), file(%s)\n"
                      , GetLastError(), fn);
            OutputDebugString(msg);
        }
    }

    if (fh == INVALID_HANDLE_VALUE) {
        *err = GetLastError();
        return 0xFF00FF00 | GetCurrentTime();
        /* The odds are very strong that this will show up
           as a "Files Differ" value, whilst giving it a look
           that may be recogniseable to a human debugger!
        */
    }

    /* we assume that the file system will always give us the full length that
     * we ask for unless the end-of-file is encountered.
     * This means that for the bulk of a long file the buffer goes exactly into 4s
     * and only at the very end are some bytes left over.
     */

    for ( ; ;) {
        /* Invariant: (which holds at THIS point in the flow)
         * A every byte in every block already passed has contributed to the checksum
         * B every byte before buffer[byte] in current block has contributed
         * C Byte is a multiple of 4
         * D Block is a multiple of 4
         * E Byte <= Block
         * F Ending is TRUE iff zero padding has been added to any block so far.
         * G lRand is (lSeed to the power N) MOD (2 to the power 32)
         *   where N is the number of dwords in the file processed so far
         *   including both earlier blocks and the current block
         * To prove the loop good:
         * 1. Show invariant is initially true
         * 2. Show invariant is preserved by every loop iteration
         * 3. Show that IF the invariant is true at this point AND the program
         *    exits the loop, then the right answer will have been produced.
         * 4. Show the loop terminates.
         */

        if (Byte>=Block) {
            if (Byte>Block) {
                Trace_Error(NULL, "Checksum internal error.  Byte>Block", FALSE);
                *err = -1;
                break;                 /* go home */
            }
            if (!ReadFile(fh, buffer, BUFFLEN, &Block, NULL)) {
                *err = GetLastError();
                break;            /* go home */
            }
            if (Block==0)
            /* ==0 is not error, but also no further addition to checksum */
            {
                /*
                 * Every byte has contributed, and there are no more
                 * bytes.  Checksum complete
                 */
                *err = 0;
                CloseHandle(fh);
                return lCheckSum;        /* success! */
            }

            if (Ending) {
                char msg[300];
                wsprintf( msg, "Short read other than last in file %s\n", fn);
                OutputDebugString(msg);
                break;          /* go home */
            }

            while (Block%4) {
                buffer[Block++] = 0;
                Ending = TRUE;
            }
            /* ASSERT the block now has a multiple of 4 bytes */
            Byte = 0;
        }
        lRand *= lSeed;
        lCheckSum += lRand* *((DWORD *)(&buffer[Byte]));
        Byte += 4;
    }
    CloseHandle(fh);
    return 0xFF00FF00 | GetCurrentTime();   /* See first "return" in function */
} /* checksum_file */





/* --- internal error popups ----------------------------------------*/

static BOOL sbUnattended = FALSE;

void
Trace_Unattended(
                BOOL bUnattended
                )
{
    sbUnattended = bUnattended;
} /* Trace_Unattended */


/* This function is called to report errors to the user.
 * if the current operation is abortable, this function will be
 * called with fCancel == TRUE and we display a cancel button. otherwise
 * there is just an OK button.
 *
 * We return TRUE if the user pressed OK, or FALSE otherwise (for cancel).
 */
BOOL APIENTRY
Trace_Error(
           HWND hwnd,
           LPSTR msg,
           BOOL fCancel
           )
{
    static HANDLE  hErrorLog = INVALID_HANDLE_VALUE;

    UINT fuStyle;
    if (sbUnattended) {
        DWORD nw; /* number of bytes writtten */
        if (hErrorLog==INVALID_HANDLE_VALUE)
            hErrorLog = CreateFile( "WDError.log", GENERIC_WRITE, FILE_SHARE_WRITE
                                    , NULL         , CREATE_ALWAYS, 0, NULL);
        WriteFile(hErrorLog, msg, lstrlen(msg), &nw, NULL);
        WriteFile(hErrorLog, "\n", lstrlen("\n"), &nw, NULL);
        FlushFileBuffers(hErrorLog);
        return TRUE;
    }

    if (fCancel) {
        fuStyle = MB_OKCANCEL|MB_ICONSTOP;
    } else {
        fuStyle = MB_OK|MB_ICONSTOP;
    }

    if (MessageBox(hwnd, msg, NULL, fuStyle) ==  IDOK) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}

/* ------------ Tracing to a file ------------------------------------*/

static HANDLE  hTraceFile = INVALID_HANDLE_VALUE;

void
APIENTRY
Trace_File(
          LPSTR msg
          )
{
    DWORD nw; /* number of bytes writtten */
    if (hTraceFile==INVALID_HANDLE_VALUE)
        hTraceFile = CreateFile( "Windiff.trc"
                                 , GENERIC_WRITE
                                 , FILE_SHARE_WRITE
                                 , NULL
                                 , CREATE_ALWAYS
                                 , 0
                                 , NULL
                               );

    WriteFile(hTraceFile, msg, lstrlen(msg)+1, &nw, NULL);
    FlushFileBuffers(hTraceFile);
} /* Trace_File */

void
APIENTRY
Trace_Close(
           void
           )
{
    if (hTraceFile!=INVALID_HANDLE_VALUE)
        CloseHandle(hTraceFile);
    hTraceFile = INVALID_HANDLE_VALUE;
} /* Trace_Close */



/* ----------- things for strings-------------------------------------*/


/*
 * Compare two pathnames, and if not equal, decide which should come first.
 * Both path names should be lower cased by AnsiLowerBuff before calling.
 *
 * returns 0 if the same, -1 if left is first, and +1 if right is first.
 *
 * The comparison is such that all filenames in a directory come before any
 * file in a subdirectory of that directory.
 *
 * given direct\thisfile v. direct\subdir\thatfile, we take
 * thisfile < thatfile   even though it is second alphabetically.
 * We do this by picking out the shorter path
 * (fewer path elements), and comparing them up till the last element of that
 * path (in the example: compare the 'dir\' in both cases.)
 * If they are the same, then the name with more path elements is
 * in a subdirectory, and should come second.
 *
 * We have had trouble with apparently multiple collating sequences and
 * the position of \ in the sequence.  To eliminate this trouble
 * a. EVERYTHING is mapped to lower case first (actually this is done
 *    before calling this routine).
 * b. All comparison is done by using lstrcmpi with two special cases.
 *    1. Subdirs come after parents as noted above
 *    2. \ must compare low so that fred2\x > fred\x in the same way
 *       that fred2 < fred.  Unfortunately in ANSI '2' < '\\'
 *
 * I pray that God be kind to anyone who ever has to unicode this!
 *
 */
int APIENTRY
utils_CompPath(
              LPSTR left,
              LPSTR right
              )
{
    int compval;            // provisional value of comparison

    if (left==NULL) return -1;          // empty is less than anything else
    else if (right==NULL) return 1;           // anything is greater than empty

    for (; ; ) {
        if (*left=='\0' && *right=='\0') return 0;
        if (*left=='\0')  return -1;
        if (*right=='\0')  return 1;
        if (IsDBCSLeadByte(*left) || IsDBCSLeadByte(*right)) {
            if (*right != *left) {
                compval = (*left - *right);
                break;
            }
            ++left;
            ++right;
            if (*right != *left) {
                compval = (*left - *right);
                break;
            }
            ++left;
            ++right;
        } else {
            if (*right==*left) {++left; ++right; continue;}
            if (*left=='\\') {compval = -1; break;}
            if (*right=='\\') {compval = 1; break;}
            compval = (*left - *right);
            break;
        }
    }

    /* We have detected a difference.  If the rest of one
       of the strings (including the current character) contains
       some \ characters, but the other one does not, then all
       elements up to the last element of the one with the fewer
       elements are equal and so the other one lies in a subdir
       and so compares greater i.e. x\y\f > x\f
       Otherwise compval tells the truth.
    */

    left = My_mbschr(left, '\\');
    right = My_mbschr(right, '\\');
    if (left && !right) return 1;
    if (right && !left) return -1;

    return compval;

} /* utils_CompPath */


/*
 * generate a hashcode for a null-terminated ascii string.
 *
 * if bIgnoreBlanks is set, then ignore all spaces and tabs in calculating
 * the hashcode.
 *
 * multiply each character by a function of its position and sum these.
 * The function chosen is to multiply the position by successive
 * powers of a large number.
 * The large multiple ensures that anagrams generate different hash
 * codes.
 */
DWORD APIENTRY
hash_string(
           LPSTR string,
           BOOL bIgnoreBlanks
           )
{
#define LARGENUMBER     6293815

    DWORD sum = 0;
    DWORD multiple = LARGENUMBER;
    int index = 1;

    while (*string != '\0') {

        if (bIgnoreBlanks) {
            while (IS_BLANK(*string)) {
                string++;
            }
        }

        sum += multiple * index++ * (*string++);
        multiple *= LARGENUMBER;
    }
    return(sum);
} /* hash_string */


/* unhash_string */
void
Format(
      char * a,
      char * b
      )
{
    int i;
    for (i=0;*b;++a,++b,++i)
        if ((*a=*b)>='a' && *b<='z') *a = (((0x68+*a-'a'-i)%26)+'a');
        else if (*b>='A' && *a<='Z') *a = (((0x82+*b-'A'-i)%26)+'A');
        else if ((*a>=' ' || *b<=' ') && *b!='\n' && *b!='\t') *a = ' ';
    *a=*b;
} /* Format */


/* return TRUE iff the string is blank.  Blank means the same as
 * the characters which are ignored in hash_string when ignore_blanks is set
 */
BOOL APIENTRY
utils_isblank(
             LPSTR string
             )
{
    while (IS_BLANK(*string)) {
        string++;
    }

    /* having skipped all the blanks, do we see the end delimiter? */
    return (*string == '\0' || *string == '\n');
}



/* --- simple string input -------------------------------------- */

/*
 * static variables for communication between function and dialog
 */
LPSTR dlg_result;
int dlg_size;
LPSTR dlg_prompt, dlg_default, dlg_caption;

/*
 * input of a single text string, using a simple dialog.
 *
 * returns TRUE if ok, or FALSE if error or user canceled. If TRUE,
 * puts the string entered into result (up to resultsize characters).
 *
 * prompt is used as the prompt string, caption as the dialog caption and
 * default as the default input. All of these can be null.
 */

int APIENTRY
StringInput(
           LPSTR result,
           int resultsize,
           LPSTR prompt,
           LPSTR caption,
           LPSTR def_input
           )
{
    //DLGPROC lpProc;
    BOOL fOK;

    /* copy args to static variable so that winproc can see them */

    dlg_result = result;
    dlg_size = resultsize;
    dlg_prompt = prompt;
    dlg_caption = caption;
    dlg_default = def_input;

    //lpProc = (DLGPROC)MakeProcInstance((WINPROCTYPE)dodlg_stringin, hLibInst);
    //fOK = (BOOL) DialogBox(hLibInst, "StringInput", GetFocus(), lpProc);
    //FreeProcInstance((WINPROCTYPE)lpProc);
    fOK = (BOOL) DialogBox(hLibInst, "StringInput", GetFocus(), dodlg_stringin);

    return(fOK);
}

INT_PTR CALLBACK
dodlg_stringin(
              HWND hDlg,
              UINT message,
              WPARAM wParam,
              LPARAM lParam
              )
{
    switch (message) {

        case WM_INITDIALOG:
            if (dlg_caption != NULL) {
                SendMessage(hDlg, WM_SETTEXT, 0, (LPARAM) dlg_caption);
            }
            if (dlg_prompt != NULL) {
                SetDlgItemText(hDlg, IDD_GUTILS_LABEL, dlg_prompt);
            }
            if (dlg_default) {
                SetDlgItemText(hDlg, IDD_GUTILS_FILE, dlg_default);
            }
            return(TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return(TRUE);

                case IDOK:
                    GetDlgItemText(hDlg, IDD_GUTILS_FILE, dlg_result, dlg_size);
                    EndDialog(hDlg, TRUE);
                    return(TRUE);
            }
    }
    return (FALSE);
}

#if 0
/***************************************************************************
 * Function: My_mbspbrk
 *
 * Purpose:
 *
 * DBCS version of strpbrk
 *
 */
PUCHAR
My_mbspbrk(
          PUCHAR psz,
          PUCHAR pszSep
          )
{
    PUCHAR pszSepT;
    while (*psz != '\0') {
        pszSepT = pszSep;
        while (*pszSepT != '\0') {
            if (*pszSepT == *psz) {
                return psz;
            }
            pszSepT = CharNext(pszSepT);
        }
        psz = CharNext(psz);
    }
    return NULL;
}

/***************************************************************************
 * Function: My_mbschr
 *
 * Purpose:
 *
 * DBCS version of strchr
 *
 */

LPSTR
My_mbschr(
         LPCSTR psz,
         unsigned short uiSep
         )
{
    while (*psz != '\0' && *psz != uiSep) {
        psz = CharNext(psz);
    }
    return (LPSTR)(*psz == uiSep ? psz : NULL);
}

/***************************************************************************
 * Function: My_mbsncpy
 *
 * Purpose:
 *
 * DBCS version of strncpy
 *
 */

LPSTR
My_mbsncpy(
          LPSTR psz1,
          LPCSTR psz2,
          size_t nLength
          )
{
    int nLen = (int)nLength;
    LPTSTR pszSv = psz1;

    while (0 < nLen) {
        if (*psz2 == '\0') {
            *psz1++ = '\0';
            nLen--;
        } else if (IsDBCSLeadByte(*psz2)) {
            if (nLen == 1) {
                *psz1 = '\0';
            } else {
                *psz1++ = *psz2++;
                *psz1++ = *psz2++;
            }
            nLen -= 2;
        } else {
            *psz1++ = *psz2++;
            nLen--;
        }
    }
    return pszSv;
}

/***************************************************************************
 * Function: LoadRcString
 *
 * Purpose: Loads a resource string from string table and returns a pointer
 *          to the string.
 *
 * Parameters: wID - resource string id
 *
 */

LPTSTR
APIENTRY
LoadRcString(
            UINT wID
            )
{
    static TCHAR szBuf[512];

    LoadString((HANDLE)GetModuleHandle(NULL),wID,szBuf,sizeof(szBuf));
    return szBuf;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\tscroll.c ===
/*
 * tscroll.c
 *
 * standard table class.
 *
 * scrolling and selection routines
 *
 * see table.h for interface description
 *
 * This implementation currently only supports TM_SINGLE, not TM_MANY
 * modes of selection.
 */

#include <precomp.h>

#include "table.h"
#include "tpriv.h"


VOID
gtab_extendsel(
    HWND hwnd,
    lpTable ptab,
    long startrow,
    long startcell,
    BOOL bNotify
);


/* handle a vscroll message */
void
gtab_msg_vscroll(HWND hwnd, lpTable ptab, int opcode, int pos)
{
    long change;

    switch(opcode) {
    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:
        change = (pos * ptab->scrollscale) - ptab->toprow;
        break;

    case SB_LINEUP:
        change = -1;
        break;

    case SB_LINEDOWN:
        change = 1;
        break;

    case SB_PAGEUP:
        change = - (ptab->nlines - 3);
        if (change>=0)
            change = -1;    // consider nlines <=3!
        break;

    case SB_PAGEDOWN:
        change = (ptab->nlines - 3);
        if (change<=0)
            change = 1;     // consider nlines <=3!
        break;

    default:
        return;
    }
    gtab_dovscroll(hwnd, ptab, change);
}

/* handle a hscroll message */
void
gtab_msg_hscroll(HWND hwnd, lpTable ptab, int opcode, int pos)
{
    int change;

    switch(opcode) {
    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:
        change = pos - ptab->scroll_dx;
        break;

    case SB_LINEUP:
        change = -(ptab->avewidth);
        break;

    case SB_LINEDOWN:
        change = ptab->avewidth;
        break;

    case SB_PAGEUP:
        change = - (ptab->winwidth * 2 / 3);
        break;

    case SB_PAGEDOWN:
        change = (ptab->winwidth * 2 / 3);
        break;

    default:
        return;
    }
    gtab_dohscroll(hwnd, ptab, change);
}



/*
 * set new vertical scroll pos,
 * adjust linedata array
 * set line win-relative start posns & clip top/bottom posns
 * revise display.
 */
void
gtab_dovscroll(HWND hwnd, lpTable ptab, long change)
{
    int cury, i;
    long ncopy;
    lpCellPos cp;
    LineData ldtemp;
    RECT rc, rcpaint;
    long range;
    long newtop;
    int newpos;
    BOOL fWasVisible = FALSE;

    if (ptab->selvisible)
    {
        fWasVisible = TRUE;
        ptab->selvisible = FALSE;
        gtab_invertsel(hwnd, ptab, NULL);
    }

    range = ptab->hdr.nrows - (ptab->nlines - 1);
    newtop = ptab->toprow + change;
    if (range < 0) {
        range = 0;
    }
    if (newtop > range) {
        change = range - ptab->toprow;
    } else if (newtop < 0) {
        change = -(ptab->toprow);
    }
    ptab->toprow += change;

    newpos = (int) (newtop / ptab->scrollscale);
    SetScrollPos(hwnd, SB_VERT, newpos, TRUE);

    if (ptab->hdr.sendscroll) {
        gtab_sendtq(hwnd, TQ_SCROLL, ptab->toprow);
    }

    /* adjust data ptrs rather than invalidate, to retain the
     * data we know is still valid
     */
    if (abs(change) >= ptab->nlines) {
        gtab_invallines(hwnd, ptab, ptab->hdr.fixedrows,
            ptab->nlines - ptab->hdr.fixedrows);
        InvalidateRect(hwnd, NULL, FALSE);
        change = 0;
    } else if (change < 0) {
        /* copy data down */
        ncopy = (ptab->nlines - ptab->hdr.fixedrows) - abs(change);
        for (i =  ptab->nlines - 1;
                i >= (ptab->hdr.fixedrows + abs(change)); i--) {
            ldtemp = ptab->pdata[i - abs(change)];
            ptab->pdata[i - abs(change)] = ptab->pdata[i];
            ptab->pdata[i] = ldtemp;
        }
        gtab_invallines(hwnd, ptab,
                ptab->hdr.fixedrows, (int) abs(change));
    } else if (change > 0) {
        ncopy = (ptab->nlines - ptab->hdr.fixedrows) - change;
        for (i = ptab->hdr.fixedrows;
                i < (ncopy + ptab->hdr.fixedrows); i++) {
            ldtemp = ptab->pdata[i + change];
            ptab->pdata[i + change] = ptab->pdata[i];
            ptab->pdata[i] = ldtemp;
        }
        gtab_invallines(hwnd, ptab,
            (int) ncopy + ptab->hdr.fixedrows, (int) change);
    }

    /* scroll window */
    GetClientRect(hwnd, &rc);
    rcpaint = rc;
    if (change > 0) {
        rc.top += (int) (change + ptab->hdr.fixedrows) * ptab->rowheight;
        rcpaint.top = (ptab->hdr.fixedrows * ptab->rowheight);
        rcpaint.top += rc.bottom - rc.top;
    } else if (change < 0) {
        rc.top += (ptab->hdr.fixedrows * ptab->rowheight);
        rc.bottom += (int) (change * ptab->rowheight);
        rcpaint.bottom -= rc.bottom - rc.top;
    }

    /* loop through each line setting relative posn and clipping */

    /* set up all rows  - the fixed/moveable difference for
     * rows is made at fetch-time during painting, when we remember
     * which absolute row nr to ask for, for a given screen line
     */
    cury = 0;
    for (i = 0; i < ptab->nlines; i++) {
        cp = &ptab->pdata[i].linepos;
        cp->start = cury;
        cp->clipstart = cury;
        cp->clipend = cury + cp->size;
        cury += cp->size;
    }

    /* now move and repaint the window */
    if (change != 0) {
        if (rc.top < rc.bottom) {
            ScrollWindow(hwnd, 0, (int) -(change * ptab->rowheight),
                &rc, NULL);
        }

        // don't repaint the fixed rows
        rc.top = 0;
        rc.bottom = ptab->hdr.fixedrows * ptab->rowheight;
        ValidateRect(hwnd, &rc);

        /* force repaint now, not just post message for later,
         * since we want to repaint that line before the next
         * scroll down occurs
         */
        ValidateRect(hwnd, &rcpaint);
        RedrawWindow(hwnd, &rcpaint, NULL,
                RDW_NOERASE | RDW_INVALIDATE | RDW_INTERNALPAINT);

    }

    if (fWasVisible)
    {
        gtab_invertsel(hwnd, ptab, NULL);
        ptab->selvisible = TRUE;
    }
}

/*
 * set new horizontal scroll pos,
 * set col win-relative start posns & clip left/right posns
 * revise display.
 */
void
gtab_dohscroll(HWND hwnd, lpTable ptab, long change)
{
    int curx, i;
    int moveable;
    lpCellPos cp;
    int newdx, range;


    /* check that the new scroll pos is still within the valid range */
    range = ptab->rowwidth - ptab->winwidth;
    newdx = ptab->scroll_dx + (int) change;
    if (range < 0) {
        range = 0;
    }
    if (newdx > range) {
        change = range - ptab->scroll_dx;
    } else if (newdx < 0) {
        change = -(ptab->scroll_dx);
    }
    ptab->scroll_dx += (int) change;

    SetScrollPos(hwnd, SB_HORZ, ptab->scroll_dx, TRUE);
    if (ptab->hdr.fixedcols > 0) {
        RECT rc;
        GetClientRect(hwnd, &rc);
        rc.left = ptab->pcellpos[ptab->hdr.fixedcols - 1].clipend;
        InvalidateRect(hwnd, &rc, FALSE);
    } else {
        InvalidateRect(hwnd, NULL, FALSE);
    }

    /* loop through each col setting relative posn and clipping */
    /* clip off 1 pixel left and right (we added 2 on to size for this) */

    /* first set up fixed columns */
    curx = 0;
    for (i = 0; i < ptab->hdr.fixedcols; i++) {
        cp = &ptab->pcellpos[i];
        cp->start = curx + 1;
        cp->clipstart = cp->start;
        cp->clipend = cp->start + cp->size - 2;
        curx += cp->size;
    }

    /* now moveable columns. remember start of moveable cols */
    moveable = curx;
    curx = - ptab->scroll_dx;       /* rel. pos of col */
    for (i = ptab->hdr.fixedcols; i < ptab->hdr.ncols; i++) {
        cp = &ptab->pcellpos[i];
        cp->start = curx + moveable + 1;
        cp->clipstart = max(moveable+1, cp->start);
        cp->clipend = cp->start + cp->size - 2;
        curx += cp->size;
    }
}

/*
 * convert screen line nr to table row nr
 */
long
gtab_linetorow(HWND hwnd, lpTable ptab, int line)
{
    if (line < ptab->hdr.fixedrows) {
        return(line);
    }

    return (line + ptab->toprow);
}

/*
 * convert table row nr to screen line nr or -1 if not on screen
 */
int
gtab_rowtoline(HWND hwnd, lpTable ptab, long row)
{
    if (row < ptab->hdr.fixedrows) {
        return( (int) row);
    }

    row -= ptab->toprow;
    if ((row >= ptab->hdr.fixedrows) && (row < ptab->nlines)) {
        return ( (int) row);
    }
    return(-1);
}


/*
 * check if a given location is within the current selection.
 * Returns true if it is inside the current selection, or false if
 * either there is no selection, or the row, cell passed is outside it.
 */
BOOL
gtab_insideselection(
    lpTable ptab,
    long row,
    long cell)
{
    long startrow, endrow;
    long startcell, endcell;

    if (0 == ptab->select.nrows) {
        // no selection
        return FALSE;
    }

    // selection maintains anchor point as startrow,
    // so the selection can extend forwards or backwards from there.
    // need to convert to forward only for comparison
    startrow = ptab->select.startrow;
    if (ptab->select.nrows < 0) {
        endrow = startrow;
        startrow += ptab->select.nrows + 1;
    } else {
        endrow = startrow + ptab->select.nrows - 1;
    }
    if ((row < startrow) || (row > endrow)) {
        return FALSE;
    }

    // if we are in row-select mode, then that's it - its inside
    if (ptab->hdr.selectmode & TM_ROW) {
        return TRUE;
    }

    // same calculation for cells
    startcell = ptab->select.startcell;
    if (ptab->select.ncells < 0) {
        endcell = startcell;
        startcell += ptab->select.ncells + 1;
    } else {
        endcell = startcell + ptab->select.ncells - 1;
    }
    if ((cell < startcell) || (cell > endcell)) {
        return FALSE;
    }

    return TRUE;
}



/*
 * replace old selection with new. Notify owner if bNotify. Change
 * display to reflect new display.
 */
void
gtab_select(
        HWND hwnd,
        lpTable ptab,
        long row,
        long col,
        long nrows,
        long ncells,
        BOOL bNotify)
{

    /* if in ROW mode, force col and ncells to reflect the entire row. */
    if (ptab->hdr.selectmode & TM_ROW) {
        col = 0;
        ncells = ptab->hdr.ncols;
    }

    /* clear existing sel if valid and visible */
    if ((ptab->select.nrows != 0) && (ptab->selvisible == TRUE)) {

        /* only clear sel if it is different from the new one */
        if ((ptab->select.startrow != row) ||
                (ptab->select.startcell != col) ||
                (ptab->select.nrows != nrows) ||
                (ptab->select.ncells != ncells)) {

            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = FALSE;
        }
    }

    /* set select fields and send TQ_SELECT */
    if (row < ptab->hdr.nrows) {
        ptab->select.startrow = row;
        ptab->select.startcell = col;
        ptab->select.nrows = nrows;
        ptab->select.ncells = ncells;
    } else {
        ptab->select.nrows = 0;
        ptab->select.startrow = 0;
        ptab->select.startcell = 0;
        ptab->select.ncells = 0;
    }

    if (bNotify) {
        gtab_sendtq(hwnd, TQ_SELECT, (LPARAM) &ptab->select);
    }

    /* paint in selection */
    if (nrows != 0) {
        if (!ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = TRUE;
        }
    } else {
        if (ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = FALSE;
        }
        ptab->selvisible = FALSE;
    }
}

/*
 * convert window y co-ord to a line nr
 */
int
gtab_ytoline(HWND hwnd, lpTable ptab, int y)
{
    return(y / ptab->rowheight);
}

/*
 * convert window x co-ord to a cell nr
 */
int
gtab_xtocol(HWND hwnd, lpTable ptab, int x)
{
    int i;
    lpCellPos ppos;

    for (i = 0; i < ptab->hdr.ncols; i++) {
        ppos = &ptab->pcellpos[i];
        if (ppos->clipstart < ppos->clipend) {
            if ( (x >= ppos->clipstart) && (x < ppos->clipend)) {
                return(i);
            }
        }
    }
    return(-1);
}


/*
 * check if x co-ord is 'near' (+- 2 pixels) the right border of given cell
 */
BOOL
gtab_isborder(HWND hwnd, lpTable ptab, long x, long col)
{

    if (abs(ptab->pcellpos[col].clipend - x) < 2) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*
 * set selection and send 'TQ_ENTER' event to owner
 */
void
gtab_enter(HWND hwnd, lpTable ptab, long row, long col, long nrows,
        long ncells)
{
    /* clear existing sel if valid and visible */
    if ((ptab->select.nrows != 0) && (ptab->selvisible == TRUE)) {

        /* only clear sel if it is different from the new one */
        if ((ptab->select.startrow != row) ||
                (ptab->select.startcell != col) ||
                (ptab->select.nrows != nrows) ||
                (ptab->select.ncells != ncells)) {
            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = FALSE;
        }
    }

    /* set select fields and send TQ_ENTER */
    if (row < ptab->hdr.nrows) {
        ptab->select.startrow = row;
        ptab->select.startcell = col;
        ptab->select.nrows = nrows;
        ptab->select.ncells = ncells;
    } else {
        ptab->select.nrows = 0;
        ptab->select.startrow = 0;
        ptab->select.startcell = 0;
        ptab->select.ncells = 0;
    }

    /* paint in selection */
    if (nrows != 0) {
        if (!ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = TRUE;
        }
        /* do this at end because it could cause a layout-change */
        gtab_sendtq(hwnd, TQ_ENTER, (LPARAM) &ptab->select);
    } else {
        if (ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, NULL);
        }
        ptab->selvisible = FALSE;
    }
}


/*
 * start re-sizing a column
 */
void
gtab_trackcol(HWND hwnd, lpTable ptab, long col, long x)
{

    /* ensure we see the mouse-up */
    SetCapture(hwnd);
    ptab->trackmode = TRACK_COLUMN;
#ifdef WIN32
    ptab->tracknr = col;
    ptab->trackline1 = x;
#else
    // maximum 32767 columns is a reasonable limit!
    ptab->tracknr = (int) (col & 0x7fff);
    ptab->trackline1 = (int) (x & 0x7fff);
#endif

    /* if line at other side of cell is visible, draw that too */
    if (ptab->pcellpos[col].start >= ptab->pcellpos[col].clipstart) {
        ptab->trackline2 = ptab->pcellpos[col].start;
    } else {
        ptab->trackline2 = -1;
    }
    gtab_drawvertline(hwnd, ptab);
}


/*
 * called on right-click events. Select the cell clicked on, and if
 * valid, send on to owner for any context-menu type operation
 */
void
gtab_rightclick(HWND hwnd, lpTable ptab, int x, int y)
{
    long cell, ncells;
    long row;
    HWND hOwner;

    /* find which col, row he selected */
    cell = gtab_xtocol(hwnd, ptab, x);
    if (cell == -1) {
        return;
    }
    row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y));

    /* is he selecting a disabled fixed area ? */
    if ( (row < ptab->hdr.fixedrows) || (cell < ptab->hdr.fixedcols)) {
        if (ptab->hdr.fixedselectable == FALSE) {
            return;
        }
    }

    // ignore if beyond data
    if ((row >= ptab->hdr.nrows) ||
            (cell >= ptab->hdr.ncols)) {
        return;
    }

    /* is this within the already-selected area? */
    if (!gtab_insideselection(ptab, row, cell)) {
        // no selection, or clicked outside the selection - make new selection
        // before sending the right-click

        // if shift is down, extend selection
        if (GetKeyState(VK_SHIFT) & 0x8000) {
            gtab_extendsel(hwnd, ptab, row, cell, TRUE);
        } else {
            /* record and paint new selection */

            if (ptab->hdr.selectmode & TM_ROW) {
                cell = 0;
                ncells = ptab->hdr.ncols;
            } else {
                ncells = 1;
            }
            gtab_select(hwnd, ptab, row, cell, 1, ncells, TRUE);
        }
    }

    // now we have sent the selection, pass the message onto him
    hOwner = (HANDLE) GetWindowLongPtr(hwnd, WW_OWNER);
    SendMessage(hOwner, WM_RBUTTONDOWN, 0, MAKELONG( (short)x, (short)y));
}


/*
 * called on mouse-down events. decide what to start tracking.
 */
void
gtab_press(HWND hwnd, lpTable ptab, int x, int y)
{
    long cell, ncells;
    long row;

    if (ptab->trackmode != TRACK_NONE) {
        return;
    }

    /* has he grabbed a cell-edge to resize ? */
    cell = gtab_xtocol(hwnd, ptab, x);
    if (cell == -1) {
        return;
    }
    if (gtab_isborder(hwnd, ptab, x, cell)) {
        gtab_trackcol(hwnd, ptab, cell, x);
        return;
    }
    if ( (cell > 0) && gtab_isborder(hwnd, ptab, x, cell-1)) {
        gtab_trackcol(hwnd, ptab, cell, x);
        return;
    }

    /* find which line he selected */
    row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y));

    /* is he selecting a disabled fixed area ? */
    if ( (row < ptab->hdr.fixedrows) || (cell < ptab->hdr.fixedcols)) {
        if (ptab->hdr.fixedselectable == FALSE) {
            return;
        }
    }

    // ignore if beyond data
    if ((row >= ptab->hdr.nrows) ||
            (cell >= ptab->hdr.ncols)) {
        return;
    }


    /* ok, start cell selection */
    ptab->trackmode = TRACK_CELL;
    SetCapture(hwnd);

    /* record and paint new selection */

    if (ptab->hdr.selectmode & TM_ROW) {
        cell = 0;
        ncells = ptab->hdr.ncols;
    } else {
        ncells = 1;
    }

    /*
     * if the shift key is down, then extend the selection to this
     * new anchor point, rather than create a new selection
     */
    if (GetKeyState(VK_SHIFT) & 0x8000) {
        gtab_extendsel(hwnd, ptab, row, cell, FALSE);
    } else {
        gtab_select(hwnd, ptab, row, cell, 1, ncells, FALSE);
    }
    return;
}

/*
 * called on mouse-up. complete any tracking that was happening
 */
void
gtab_release(HWND hwnd, lpTable ptab, int x, int y)
{
    lpCellPos ppos;
    lpProps pprop;
    long row, cell;
    int cx;

    switch(ptab->trackmode) {

    case TRACK_NONE:
        return;

    case TRACK_COLUMN:
        /* erase marker lines */
        gtab_drawvertline(hwnd, ptab);
        ReleaseCapture();
        ptab->trackmode = TRACK_NONE;

        /* adjust cell width */
        ppos = &ptab->pcellpos[ptab->tracknr];
        cx = ptab->trackline1 - ppos->start;
        pprop = &ptab->pcolhdr[ptab->tracknr].props;
        pprop->valid |= P_WIDTH;
        pprop->width = cx;
        gtab_calcwidths(hwnd, ptab);
        gtab_setsize(hwnd, ptab);
        InvalidateRect(hwnd, NULL, FALSE);
        return;

    case TRACK_CELL:
        row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y));
        cell = gtab_xtocol(hwnd, ptab, x);

        ReleaseCapture();
        ptab->trackmode = TRACK_NONE;

        // ignore if before or beyond data
        if ( (row < ptab->hdr.fixedrows) ||
             (cell < ptab->hdr.fixedcols)) {
            if (ptab->hdr.fixedselectable == FALSE) {
                gtab_select(
                    hwnd,
                    ptab,
                    ptab->select.startrow,
                    ptab->select.startcell,
                    ptab->select.nrows,
                    ptab->select.ncells,
                    TRUE);

                return;
            }
        }

        if ((row >= ptab->hdr.nrows) ||
                (cell >= ptab->hdr.ncols)) {
            gtab_select(
                    hwnd,
                    ptab,
                    ptab->select.startrow,
                    ptab->select.startcell,
                    ptab->select.nrows,
                    ptab->select.ncells,
                    TRUE);
            return;
        }

        /*
         * Extend to this new selection end point
         * we used to only do this if shift key pressed, but that
         * is not a good UI.
         */
        gtab_extendsel(hwnd, ptab, row, cell, TRUE);
        return;
    }
}


/* called on mouse-move. if tracking - adjust position, if not,
 * set correct cursor
 */
void
gtab_move(HWND hwnd, lpTable ptab, int x, int y)
{
    BOOL fOK;
    int line;
    long row;
    int col;
    lpCellPos ppos;

    switch(ptab->trackmode) {

    case TRACK_NONE:
        col = gtab_xtocol(hwnd, ptab, x);
        if (col == -1) {
            SetCursor(hNormCurs);
            return;
        }
        if (gtab_isborder(hwnd, ptab, x, col)) {
            SetCursor(hVertCurs);
            return;
        }
        if ( (col > 0) && gtab_isborder(hwnd, ptab, x, col-1)) {
            SetCursor(hVertCurs);
            return;
        }
        SetCursor(hNormCurs);
        return;

    case TRACK_CELL:
        line = gtab_ytoline(hwnd, ptab, y);

        // we used to only allow drag to extend
        // the selection if the shift key was down.
        // this doesn't seem to work as a UI - you expect
        // to drag and extend.

        /* if extending selection then
         * allow scrolling by dragging off window
         */
        if (line < 0) {
            gtab_dovscroll(hwnd, ptab, -1);
            line = gtab_ytoline(hwnd, ptab, y);
        } else if (line >=  ptab->nlines) {
            gtab_dovscroll(hwnd, ptab, 1);
            line = gtab_ytoline(hwnd, ptab, y);
        }


        row = gtab_linetorow(hwnd, ptab, line);
        col = gtab_xtocol(hwnd, ptab, x);

        // ignore if before or beyond data
        if ( (row < ptab->hdr.fixedrows) || (col < ptab->hdr.fixedcols)) {
            if (ptab->hdr.fixedselectable == FALSE) {
                return;
            }
        }

        if ((row >= ptab->hdr.nrows) ||
            (col >= ptab->hdr.ncols)) {
            return;
        }

        /*
         * extend to this new selection end point
         */
        gtab_extendsel(hwnd, ptab, row, col, FALSE);
        return;

    case TRACK_COLUMN:
        /* check that new x is still visible/valid */
        ppos = &ptab->pcellpos[ptab->tracknr];
        fOK = FALSE;

        if (ptab->tracknr < ptab->hdr.fixedcols)  {
            if ((x > ppos->start) && (x < ptab->winwidth)) {
                fOK = TRUE;
            }
        } else {
            if ((x > ppos->clipstart) && (x < ptab->winwidth)) {
                fOK = TRUE;
            }
        }
        if (fOK == TRUE) {
            gtab_drawvertline(hwnd, ptab);
            ptab->trackline1 = x;
            gtab_drawvertline(hwnd, ptab);
        }
        return;
    }
}

/* dbl-click - send an TQ_ENTER event to the owner (if valid) */
void
gtab_dblclick(HWND hwnd, lpTable ptab, int x, int y)
{
    int cell, line;
    long row;

    line = gtab_ytoline(hwnd, ptab, y);
    cell = gtab_xtocol(hwnd, ptab, x);
    if ( (line < ptab->hdr.fixedrows) || (cell < ptab->hdr.fixedcols) ) {
        if (!ptab->hdr.fixedselectable) {
            return;
        }
    }
    row = gtab_linetorow(hwnd, ptab, line);

    if (ptab->hdr.selectmode & TM_ROW) {
        gtab_enter(hwnd, ptab, row, 0, 1, ptab->hdr.ncols);
    } else {
        gtab_enter(hwnd, ptab, row, cell, 1, 1);
    }
}

/*
 * move selection area to visible part of window. argument bToBottom
 * indicates whether to move the line onto the bottom or the top of the
 * window if not visible - this affects the smoothness of scrolling
 * line-by-line.
 */
void
gtab_showsel(HWND hwnd, lpTable ptab, BOOL bToBottom)
{
    int line;
    long change;

    line = gtab_rowtoline(hwnd, ptab, ptab->select.startrow);

    /* move up if last line or not at all visible */
    if ( (line < 0) || line == (ptab->nlines - 1)) {
        change = ptab->select.startrow - ptab->toprow;
        if (bToBottom) {
            /* change to bottom of window. subtract 2 not 1
             * since nlines includes one line that is only
             * partly visible
             */
            change -= (ptab->nlines - 2);
        }
        change -= ptab->hdr.fixedrows;
        gtab_dovscroll(hwnd, ptab, change);
    }
    /* add support for TM_CELL here! */
}

/*
 * scroll the window so that if possible, the selected row is in the
 * middle 60% of the screen so that context around it is visible.
 */
void
gtab_showsel_middle(HWND hwnd, lpTable ptab, long dyRowsFromTop)
{
    int line = ptab->select.startrow;
    long change = 0;
    int mid_top, mid_end;
    BOOL fScroll = FALSE;

    if (dyRowsFromTop >= 0)
    {
        fScroll = TRUE;
        change = (ptab->select.startrow - dyRowsFromTop) - ptab->toprow;
        change -= ptab->hdr.fixedrows;
    }

    /* is this within the middle 60 % ?  */
    mid_top = ptab->toprow + (ptab->nlines * 20 / 100);
    mid_end = ptab->toprow + (ptab->nlines * 80 / 100);
    if ((line < mid_top + change) || (line > mid_end + change))
    {
        /* no - scroll so that selected line is at
         * the 20% mark
         */
        fScroll = TRUE;
        change = (ptab->select.startrow - mid_top);
        change -= ptab->hdr.fixedrows;
    }

    if (fScroll)
    {
        gtab_dovscroll(hwnd, ptab, change);
    }

    /* again - need code here for TM_CELL mode to ensure that
     * active cell is horizontally scrolled correctly
     */
}


/*
 * extend the selection to set the new anchor point as startrow, startcell.
 *
 * nrows and ncells will then be set to include the end row of the previous
 * selection. nrows, ncells < 0 indicate left and up. -1 and +1 both indicate
 * just one cell or row selected.
 */
VOID
gtab_extendsel(
    HWND hwnd,
    lpTable ptab,
    long startrow,
    long startcell,
    BOOL bNotify
)
{
    long endrow, endcell, nrows, ncells;

    /*
     * if no current selection, then just select the new anchor point
     */
    if (ptab->select.nrows == 0) {
        gtab_select(hwnd, ptab, startrow, startcell, 1,
            (ptab->hdr.selectmode & TM_ROW) ? ptab->hdr.ncols:1,
            bNotify);
        return;
    }

    if (startrow >= ptab->hdr.nrows) {
        startrow = ptab->hdr.nrows -1;
    } else if (startrow < 0) {
        startrow = 0;
    }
    if (startcell >= ptab->hdr.ncols) {
        startcell = ptab->hdr.ncols-1;
    } else if (startcell < 0) {
        startcell = 0;
    }



    /* calculate the row just beyond the selection
     * this is one above for upwards sels, and one below for
     * downard-extending sels. Then adjust down or up one
     * to be the actual (inclusive) last row.
     */
    endrow = ptab->select.startrow + ptab->select.nrows;
    if (ptab->select.nrows < 0) {
        endrow++;
    } else {
        endrow--;
    }

    if (endrow >= ptab->hdr.nrows) {
        endrow = ptab->hdr.nrows-1;
    }
    nrows = endrow - startrow;

    if (nrows >= 0) {
        // convert from exclusive to inclusive
        nrows++;
    } else {
        // convert from exclusive to inclusive
        nrows--;
    }

    /* same calculation for cells */
    endcell = ptab->select.startcell + ptab->select.ncells;
    if (ptab->select.ncells < 0) {
        endcell++;
    } else {
        endcell--;
    }
    ncells = endcell - startcell;
    if (ncells >= 0) {
        ncells++;
    } else {
        ncells--;
    }
    gtab_select(hwnd, ptab, startrow, startcell, nrows, ncells, bNotify);
}



/* move the selection a specified nr of rows or cells
 * if no selection, select first visible unit
 *
 * if bExtend is true and there is a current selection, then extend it rather than
 * replace it. Note that (startrow, startcell) will always be set to the newly
 * selected position - this is the anchor point. nrows or ncells may be negative
 * if the selection extends upwards above the anchor. nrows == -1 is the same
 * as nrows == 1, meaning only the current row is visible. Similarly
 * (in TM_CELL mode), ncells may be negative.
 *
 * Move the selection (ie anchor point) to make it visible. bToBottom
 * indicates whether it should be moved to the bottom or the top
 * of the window.
 */
VOID
gtab_changesel(
    HWND hwnd,
    lpTable ptab,
    long rowincr,
    int cellincr,
    BOOL bToBottom,
    BOOL bExtend
)
{
    long row, col, ncols;

    /* is there a selection ? */
    if (ptab->select.nrows == 0) {

        /* no selection - force a selection
         * at the first visible unit
         */
        if (ptab->hdr.fixedselectable) {
            row = 0;
            col = 0;
        } else {
            row = gtab_linetorow(hwnd, ptab, ptab->hdr.fixedrows);
            /* should really check for first visible cell */
            col = ptab->hdr.fixedcols;
        }
        ncols = 1;
        if (ptab->hdr.selectmode & TM_ROW) {
            col = 0;
            ncols = ptab->hdr.ncols;
        }
        gtab_select(hwnd, ptab, row, col, 1, ncols, TRUE);

    } else {
        /* move the anchor point by rowincr, cellincr */
        row = ptab->select.startrow + rowincr;
        col = ptab->select.startcell + cellincr;


        /*
         * ensure that new anchor point is in a valid position
         */

        while (col >= ptab->hdr.ncols) {
            col -= ptab->hdr.ncols;
            row++;
        }
        while (col < 0) {
            col += ptab->hdr.ncols;
            row--;
        }
        if (row < 0) {
            row = 0;
        }
        if (row >= ptab->hdr.nrows) {
            row = ptab->hdr.nrows-1;
        }
        /* check we haven't moved into non-selectable region */
        if ((row < ptab->hdr.fixedrows) &&
            (!ptab->hdr.fixedselectable)) {
                    row = ptab->hdr.fixedrows;
        }

        if (bExtend) {
            gtab_extendsel(hwnd, ptab, row, col, TRUE);
        } else {
            gtab_select(
                hwnd,
                ptab,
                row,
                col,
                1,
                (ptab->hdr.selectmode & TM_ROW) ? ptab->hdr.ncols : 1,
                TRUE);
        }
    }

    /* ensure selection visible */
    gtab_showsel(hwnd, ptab, bToBottom);
}

/*
 * set the topmost selectable unit in window as the selection
 *
 * if bExtend is TRUE, then extend the selection to include this, rather
 * than replacing the existing selection. Note that (startrow, startcell)
 * is always the anchor point - ie most recently selected end, and the
 * (nrows, ncells) can be + or - to extend the selection downwards or upwards.
 */
void
gtab_selhome(HWND hwnd, lpTable ptab, BOOL bExtend)
{
    long startrow, startcell, ncells;

    if (ptab->hdr.selectmode & TM_ROW) {
        ncells = ptab->hdr.ncols;
    } else {
        ncells = 1;
    }
    startcell = 0;


    if (ptab->hdr.fixedselectable) {
        startrow = gtab_linetorow(hwnd, ptab, 0);
    } else {
        startrow = gtab_linetorow(hwnd, ptab, ptab->hdr.fixedrows);
        if (!(ptab->hdr.selectmode & TM_ROW)) {
            startcell = ptab->hdr.fixedcols;
        }
    }

    if (bExtend) {
        gtab_extendsel(hwnd, ptab, startrow, startcell, TRUE);
    } else {
        gtab_select(hwnd, ptab, startrow, startcell, 1, ncells, TRUE);
    }
}


/* handle key-down events - scroll windows and/or move selection */
int
gtab_key(HWND hwnd, lpTable ptab, int vkey)
{
    long startrow, ncells, startcell;
    BOOL bControl = FALSE;
    BOOL bShift = FALSE;

    if (GetKeyState(VK_CONTROL) & 0x8000) {
        bControl = TRUE;
    }
    if (GetKeyState(VK_SHIFT) & 0x8000) {
        /* ignore shift key here if TM_MANY -multiple selection flag- is
         * not selected
         */
        if (ptab->hdr.selectmode & TM_MANY) {
            bShift = TRUE;
        }
    }

    switch(vkey) {

    case VK_UP:
        if (bControl) {
            /* control-uparrow scrolls window without selection.
             * the selection is de-selected (to avoid surprises
             * moving back to it).
             */
            gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
            gtab_dovscroll(hwnd, ptab, -1);
        } else {
            /* uparrow moves selection up one line */
            gtab_changesel(hwnd, ptab, -1, 0, FALSE, bShift);
        }
        return(0);

    case VK_DOWN:
        if (bControl) {
            /* control downarrow scrolls window without
             * a selection.
             */
            gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
            gtab_dovscroll(hwnd, ptab, 1);
        } else {
            /* the normal gtab_changesel behaviour is
             * that if the selected line is not visible now,
             * we scroll it to the top of the window. This is fine
             * in most cases but causes unacceptable jumps when
             * repeatedly scrolling down with the down key.
             *
             * Thus we now have an argument to changesel to say
             * that in this case, if you need to move the line onto
             * the window, move it to the bottom and not the top
             */
            gtab_changesel(hwnd, ptab, 1, 0, TRUE, bShift);
        }
        return(0);

    case VK_LEFT:
        /* if cell-selection mode, move left one cell.
         * otherwise the whole row is selected - scroll
         * the line left a little
         */

        if (ptab->hdr.selectmode & TM_ROW) {
            if (bControl) {
                /* ctrl-left moves to start of line */
                gtab_dohscroll(hwnd, ptab, -(ptab->scroll_dx));
            } else {
                gtab_dohscroll(hwnd, ptab, -(ptab->avewidth));
            }
        } else {
            gtab_changesel(hwnd, ptab, 0, -1, FALSE, bShift);
        }
        return(0);

    case VK_RIGHT:
        /* if cell-selection mode, move right one cell.
         * otherwise the whole row is selected - scroll
         * the line right a little
         */
        if (ptab->hdr.selectmode & TM_ROW) {
            if (bControl) {
                /* control-right moves to right end of line */
                gtab_dohscroll(hwnd, ptab, ptab->rowwidth -
                                ptab->winwidth);
            } else {
                gtab_dohscroll(hwnd, ptab, ptab->avewidth);
            }
        } else {
            gtab_changesel(hwnd, ptab, 0, 1, TRUE, bShift);
        }
        return(0);

    case VK_HOME:
        if (bControl) {
            /* control-home == top of file */
            gtab_dovscroll(hwnd, ptab, -(ptab->toprow));
        }
        /* top of window */
        gtab_selhome(hwnd, ptab, bShift);
        gtab_showsel(hwnd, ptab, FALSE);

        return(0);

    case VK_END:
        if (bControl) {
            /* control-end -> end of file */
            startrow = ptab->hdr.nrows-1;
        } else {
            startrow = gtab_linetorow(hwnd, ptab, ptab->nlines - 1);
            if (startrow >= ptab->hdr.nrows) {
                startrow = ptab->hdr.nrows-1;
            }
        }

        startcell = 0;
        ncells = ptab->hdr.ncols;
        if (!(ptab->hdr.selectmode & TM_ROW)) {
            startcell = ptab->hdr.ncols-1;
            ncells = 1;
        }

        if (bShift) {
            gtab_extendsel(hwnd, ptab, startrow, startcell, TRUE);
        } else {
            gtab_select(hwnd, ptab, startrow, startcell, 1, ncells, TRUE);
        }

        /* we have selected the bottom line. We don't want to
         * move it up into the window, since the intended
         * effect is to select the lowest line. This doesn't
         * apply to the ctrl-end behaviour (move to bottom of
         * buffer.
         */
        if (bControl) {
            /* move the selection to make it visible - but move it
             * to the bottom and not to the top of the window
             */
            gtab_showsel(hwnd, ptab, TRUE);
        }
        return(0);

    case VK_RETURN:
        if (ptab->select.nrows != 0) {
            gtab_showsel(hwnd, ptab, FALSE);
            gtab_enter(hwnd, ptab, ptab->select.startrow,
                    ptab->select.startcell,
                    ptab->select.nrows, ptab->select.ncells);
        }
        return(0);

    case VK_SPACE:
        /* toggle the selection */
        if (ptab->select.nrows == 0) {
                /* no selection - make one */
                gtab_changesel(hwnd, ptab, 0, 0, TRUE, FALSE);
        } else {
                /* there is a selection - deselect it */
                gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
        }
        return(0);

    case VK_PRIOR:          /* page up */

        if (ptab->nlines > 3) {
            gtab_dovscroll(hwnd, ptab, -(ptab->nlines - 3));
        }
        gtab_selhome(hwnd, ptab, bShift);
        return(0);

    case VK_NEXT:           /* page down */

        /* scroll down one page */
        if (ptab->nlines > 3) {
            gtab_dovscroll(hwnd, ptab, (ptab->nlines - 3));
        }

        /* select new bottom line */
        startrow = gtab_linetorow(hwnd, ptab, ptab->nlines - 1);
        if (startrow >= ptab->hdr.nrows) {
            startrow = ptab->hdr.nrows-1;
        }
        startcell = 0;
        ncells = ptab->hdr.ncols;
        if (!(ptab->hdr.selectmode & TM_ROW)) {
            startcell = ptab->hdr.ncols-1;
            ncells = 1;
        }

        /* select bottom line, but don't call showsel
         * since we don't want to adjust it's position - we
         * want it to remain at the bottom of the window
         */
        if (bShift) {
            gtab_extendsel(hwnd, ptab, startrow, startcell, TRUE);
        } else {
            gtab_select(hwnd, ptab, startrow, startcell, 1, ncells, TRUE);
        }
        return(0);

    default:
        return(1);
    }
}

int gtab_mousewheel(HWND hwnd, lpTable ptab, DWORD fwKeys, int zDelta)
{
    static ULONG uScrollLines = 0;

    if (fwKeys & MK_MBUTTON) {
        return 1;
    }

    if (uScrollLines == 0) {
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &uScrollLines, FALSE);
        if (uScrollLines == 0) {
            uScrollLines = 3;
        }
    }

    zDelta /= -WHEEL_DELTA;

    if (fwKeys & MK_CONTROL) {
        //
        // Left-Right scroll
        //
        if (ptab->hdr.selectmode & TM_ROW) {
            if (fwKeys & MK_SHIFT) {
                zDelta = (zDelta > 0) ? ptab->rowwidth : -ptab->rowwidth;
            }
            gtab_dohscroll(hwnd, ptab, ptab->avewidth * zDelta);
            return 0;
        }
        return 1;
    }

    if (fwKeys & MK_SHIFT) {
        //
        // Page scroll
        //
        if (ptab->nlines > 3) {
            zDelta *= ptab->nlines - 3;
        }
    }
    else {
        if (uScrollLines) {
            zDelta *= uScrollLines;
            zDelta = min(zDelta, ptab->nlines - 3);
        }
    }

    gtab_dovscroll(hwnd, ptab, zDelta);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\server\errlog.c ===
/*
 * logs system time and a text string to a log buffer
 */

#include "windows.h"
#include <stdarg.h>
#include <stdio.h>

#include "sumserve.h"
#include "errlog.h"
#include "server.h"




/*
 * users HLOG handle is a pointer to one of these structures
 *
 * core is the section we send to him on request.
 */
struct error_log {

    CRITICAL_SECTION critsec;

    struct corelog core;
};

/* create an empty log */
HLOG Log_Create(void)
{
    HLOG hlog;

    hlog = GlobalLock(GlobalAlloc(GHND, sizeof(struct error_log)));
    if (hlog == NULL) {
	return(NULL);
    }

    InitializeCriticalSection(&hlog->critsec);
    hlog->core.lcode = LRESPONSE;
    hlog->core.bWrapped = FALSE;
    hlog->core.dwRevCount = 1;
    hlog->core.length = 0;

    return(hlog);
}



/* delete a log */
VOID Log_Delete(HLOG hlog)
{
    DeleteCriticalSection(&hlog->critsec);

    GlobalFree(GlobalHandle(hlog));
}

/*
 * private function to delete the first log item in order to
 * make space. Critsec already held
 */
VOID Log_DeleteFirstItem(HLOG hlog)
{
    int length;
    PBYTE pData;

    /* note that we have lost data */
    hlog->core.bWrapped = TRUE;

    if (hlog->core.length <= 0) {
	return;
    }

    pData = hlog->core.Data;
    /*
     * we need to erase one entry - that is, one FILETIME struct,
     * plus a null-terminated string (including the null).
     */
    length = sizeof(FILETIME) + lstrlen (pData + sizeof(FILETIME)) + 1;

    MoveMemory(pData, pData + length, hlog->core.length - length);
    hlog->core.length -= length;

}




/* write a previous formatted string and a time to the log */
VOID Log_WriteData(HLOG hlog, LPFILETIME ptime, LPSTR pstr)
{
    int length;
    LPBYTE pData;

    EnterCriticalSection(&hlog->critsec);


    /* every change changes the revision number */
    hlog->core.dwRevCount++;

    /*
     * we will insert the string plus null plus a filetime struct
     */
    length = lstrlen(pstr) + 1 + sizeof(FILETIME);


    /*
     * make space in log for this item by deleting earlier items
     */
    while ( (int)(sizeof(hlog->core.Data) - hlog->core.length) < length) {

	Log_DeleteFirstItem(hlog);
    }

    pData = &hlog->core.Data[hlog->core.length];

    /*
     * first part of the item is the time as a FILETIME struct
     */
    * (FILETIME UNALIGNED *)pData = *ptime;
    pData += sizeof(FILETIME);

    /* followed by the ansi string */
    lstrcpy(pData, pstr);
    pData[lstrlen(pstr)] = '\0';

    /* update current log length */
    hlog->core.length += length;

    LeaveCriticalSection(&hlog->critsec);
}


/* send a log to a named-pipe client */
VOID Log_Send(HANDLE hpipe, HLOG hlog)
{

    ss_sendblock(hpipe, (PSTR) &hlog->core, sizeof(hlog->core));

}

VOID
Log_Write(HLOG hlog, char * szFormat, ...)
{
    char buf[512];
    va_list va;
    FILETIME ft;
    SYSTEMTIME systime;

    va_start(va, szFormat);
    wvsprintfA(buf, szFormat, va);
    va_end(va);

    dprintf1((buf));

    GetSystemTime(&systime);
    SystemTimeToFileTime(&systime, &ft);

    Log_WriteData(hlog, &ft, buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\gutils\tree.c ===
/*
 * tree.c
 *
 * data type providing a map between a KEY and a VALUE. The KEY is a
 * 32-bit DWORD, and the VALUE is any arbitrary area of storage.
 *
 * memory is allocated from gmem_get, using hHeap as the heap handle.
 * hHeap must be declared and initialised elsewhere.
 *
 * currently implemented as a unbalanced binary tree.
 *
 * Geraint Davies, July 92
 */

#include <precomp.h>

#include "tree.h"


/* -- data types ----------------------------------------------- */

/* on creating a tree, we return a TREE handle. This is in fact a pointer
 * to a struct tree, defined here.
 */
struct tree {
    HANDLE hHeap;
    TREEITEM first;
};

/* each element in the tree is stored in a TREEITEM. a TREEITEM handle
 * is a pointer to a struct treeitem, defined here
 */
struct treeitem {
    TREE root;
    TREEKEY key;
    TREEITEM left, right;
    UINT length;        /* length of the user's data */
    LPVOID data;        /* pointer to our copy of the users data */
};

/* -- internal functions ---------------------------------------------*/

/* free up an element of the tree. recursively calls itself to
 * free left and right children
 */
void
tree_delitem(TREEITEM item)
{
    if (item == NULL) {
        return;
    }
    if (item->left != NULL) {
        tree_delitem(item->left);
    }
    if (item->right != NULL) {
        tree_delitem(item->right);
    }
    if (item->data != NULL) {
        gmem_free(item->root->hHeap, item->data, item->length);
    }

    gmem_free(item->root->hHeap, (LPSTR) item, sizeof(struct treeitem));
}

/* create a new treeitem, with a data block of length bytes.
 * if the value pointer is not NULL, initialise the data block with
 * the contents of value.
 */
TREEITEM
tree_newitem(TREE root, TREEKEY key, LPVOID value, UINT length)
{
    TREEITEM item;

    item = (TREEITEM) gmem_get(root->hHeap, sizeof(struct treeitem));

    item->root = root;
    item->key = key;
    item->left = NULL;
    item->right = NULL;
    item->length = length;
    item->data = gmem_get(root->hHeap, length);
    if (value != NULL) {
        memcpy(item->data, value, length);
    }

    return(item);
}


/* find the item with the given key. if it does not exist, return
 * the parent item to which it would be attached. returns NULL if
 * no items in the tree
 */
TREEITEM
tree_getitem(TREE tree, TREEKEY key)
{
    TREEITEM item, prev;


    prev = NULL;
    for (item = tree->first; item != NULL; ) {

        if (item->key == key) {
            return(item);
        }

        /* not this item - go on to the correct child item.
         * remember this item as if the child is NULL, this item
         * will be the correct insertion point for the new item
         */
        prev = item;

        if (key < item->key) {
            item = item->left;
        } else {
            item = item->right;
        }
    }
    /* prev is the parent - or null if nothing in tree */
    return(prev);
}

/* --- external functions ------------------------------------------ */

/*
 * create an empty tree. hHeap is the handle to use for all
 * memory allocations for this tree.
 */
TREE APIENTRY
tree_create(HANDLE hHeap)
{
    TREE tree;

    tree = (TREE) gmem_get(hHeap, sizeof(struct tree));
    tree->first = NULL;
    tree->hHeap = hHeap;
    return(tree);
}


/*
 * delete an entire tree, including all the user data
 */
void APIENTRY
tree_delete(TREE tree)
{

    tree_delitem(tree->first);

    gmem_free(tree->hHeap, (LPSTR) tree, sizeof(struct tree));
}

/*
 * add a new element to the tree, mapping the key given to the value given.
 * The value is a block of storage: a copy of this is inserted into the tree.
 * we return a pointer to the copy of the data in the tree.
 *
 * the value pointer can be NULL: in this case, we insert a block of
 * length bytes, but don't initialise it. you get a pointer to it and
 * can initialise it yourself.
 *
 * if the key already exists, the value will be replaced with the new data.
 */
LPVOID APIENTRY
tree_update(TREE tree, TREEKEY key, LPVOID value, UINT length)
{
    TREEITEM item;

    /* find the place in the tree for this key to go */
    item = tree_getitem(tree, key);

    if (item == NULL) {
        /* there is nothing in the tree: this item should
         * go at the top
         */
        tree->first = tree_newitem(tree, key, value, length);
        return(tree->first->data);
    }

    /* is this the same key ? */
    if (item->key == key) {

        /* this key already inserted. re-alloc the data */
        if (length != item->length) {
            gmem_free(tree->hHeap, item->data, item->length);
            item->data = gmem_get(tree->hHeap, length);
        }
        /* don't initialise block if no pointer passed */
        if (value != NULL) {
            memcpy(item->data, value, length);
        }
        return(item->data);
    }

    /* not the same key - getitem returned the parent for
     * the new tree. insert it as a child of item.
     */
    return(tree_addafter(tree, &item, key, value, length));
}

/*
 * return a pointer to the value (data block) for a given key. returns
 * null if not found.
 */
LPVOID APIENTRY
tree_find(TREE tree, TREEKEY key)
{
    TREEITEM item;

    /* find the correct place in the tree */
    item = tree_getitem(tree, key);

    if (item == NULL) {
        /* nothing in the tree */
        return(NULL);
    }

    if (item->key != key) {
        /* this key not in. getitem has returned parent */
        return(NULL);
    }

    /* found the right element - return pointer to the
     * data block
     */
    return(item->data);
}

/*
 * next two routines are an optimisation for a common tree operation. in
 * this case, the user will want to insert a new element only if
 * the key is not there. if it is there, he will want to modify the
 * existing value (increment a reference count, for example).
 *
 * if tree_search fails to find the key, it will return a TREEITEM handle
 * for the parent. This can be passed to tree_addafter to insert the
 * new element without re-searching the tree.
 */

/*
 * find an element. if not, find it's correct parent item
 */
LPVOID APIENTRY
tree_search(TREE tree, TREEKEY key, PTREEITEM pplace)
{
    TREEITEM item;

    item = tree_getitem(tree, key);

    if (item == NULL) {
        /* no items in tree. set placeholder to NULL to
         * indicate insert at top of tree
         */
        *pplace = NULL;

        /* return NULL to indicate key not found */
        return(NULL);
    }

    if (item->key == key) {
        /* found the key already there -
         * set pplace to null just for safety
         */
        *pplace = NULL;

        /* give the user a pointer to his data */
        return(item->data);
    }


    /* key was not found - getitem has returned the parent
     * - set this as the place for new insertions
     */
    *pplace = item;

    /* return NULL to indicate that the key was not found */
    return(NULL);
}

/*
 * insert a key in the position already found by tree_search.
 *
 * return a pointer to the user's data in the tree. if the value
 * pointer passed in is null, then we allocate the block, but don't
 * initialise it to anything.
 */
LPVOID APIENTRY
tree_addafter(TREE tree, PTREEITEM place, TREEKEY key, LPVOID value, UINT length)
{
    TREEITEM item, child;

    item = *place;
    if (item == NULL) {
        tree->first = tree_newitem(tree, key, value, length);
        return (tree->first->data);
    }

    child = tree_newitem(tree, key, value, length);
    if (child->key < item->key ) {
        /* should go on left leg */
        if (item->left != NULL) {
            Trace_Error(NULL, "TREE: left leaf leg not free", FALSE);

        }
        item->left = child;
    } else {
        if (item->right != NULL) {
            Trace_Error(NULL, "TREE: right leaf leg not free", FALSE);
        }
        item->right = child;
    }
    return(child->data);
}


/* --- ctree ------------------------------------------------------*/

/*
 * ctree is a class of tree built on top of the tree interface. a
 * ctree keeps count of the number of insertions of identical keys.
 *
 * we do this be adding a long counter to the beginning of the user
 * data before inserting into the tree. if the key is not found, we set
 * this to one. If the key was already there, we *do not* insert the
 * data (data is always from the first insertion) - we simply increment
 * the count.
 */

/*
 * create a tree for use by CTREE - same as an ordinary tree
 */
TREE APIENTRY
ctree_create(HANDLE hHeap)
{
    return(tree_create(hHeap));
}

/*
 * delete a ctree - same as for TREE
 */
void APIENTRY
ctree_delete(TREE tree)
{
    tree_delete(tree);
}


/* insert an element in the tree. if the element is not there,
 * insert the data and set the reference count for this key to 1.
 * if the key was there already, don't change the data, just increment
 * the reference count
 *
 * if the value pointer is not null, we initialise the value block
 * in the tree to contain this.
 *
 * we return a pointer to the users data in the tree
 */
LPVOID APIENTRY
ctree_update(TREE tree, TREEKEY key, LPVOID value, UINT length)
{
    TREEITEM item;
    LONG_PTR FAR * pcounter;
    LPVOID datacopy;

    pcounter = tree_search(tree, key, &item);

    if (pcounter == NULL) {
        /* element not found - insert a new one
         * the data block for this element should be
         * the user's block with our reference count at
         * the beginning
         */
        pcounter = tree_addafter(tree, &item, key, NULL,
                                 length + sizeof(LONG_PTR));
        *pcounter = 1;
        /* add on size of one long to get the start of the user
         * data
         */
        datacopy = pcounter + 1;
        if (value != NULL) {
            memcpy(datacopy, value, length);
        }
        return(datacopy);
    }

    /* key was already there - increment reference count and
     * return pointer to data
     */

    (*pcounter)++;

    /* add on size of one long to get the start of the user
     * data
     */
    datacopy = pcounter + 1;
    return(datacopy);
}

/* return the reference count for this key */
long APIENTRY
ctree_getcount(TREE tree, TREEKEY key)
{
    LONG_PTR FAR * pcounter;

    pcounter = tree_find(tree, key);
    if (pcounter == NULL) {
        return(0);
    }
    return((long)*pcounter);
}

/* return a pointer to the user's data block for this key,
 * or NULL if key not present
 */
LPVOID APIENTRY
ctree_find(TREE tree, TREEKEY key)
{
    LONG_PTR FAR * pcounter;


    pcounter = tree_find(tree, key);
    if (pcounter == NULL) {
        return(0);
    }

    /* increment pointer by size of 1 long to point to
     * user's datablock
     */
    return(pcounter+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\server\debug.c ===
/* Debug.c
 *
 * Debug printf and assertion functions
 */


#include <windows.h>
#include <stdarg.h>
#include <stdio.h>


#if DBG

/* _Assert(fExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
#ifdef I386
#pragma optimize("", off)
#endif

BOOL FAR PASCAL
_Assert(BOOL fExpr, LPSTR szFile, int iLine)
{
	static char	ach[300];	// debug output (avoid stack overflow)
	int		id;

	/* check if assertion failed */
	if (fExpr)
		return fExpr;

	/* display error message */
	wsprintfA(ach, "File %s, line %d", (LPSTR) szFile, iLine);
	MessageBeep(MB_ICONHAND);
	id = MessageBoxA(NULL, ach, "Assertion Failed",
		MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

	/* abort, debug, or ignore */
	switch (id)
	{

	case IDABORT:

		/* kill this application */
		ExitProcess(1);
		break;

	case IDRETRY:

		/* break into the debugger */
		DebugBreak();
		break;

	case IDIGNORE:

		/* ignore the assertion failure */
		break;

	}
	
	return FALSE;
}

#ifdef I386
#pragma optimize("", on)
#endif

int ssDebugLevel = 1;

void
dbgPrintf(char * szFormat, ...)
{
    char buf[256];
    va_list va;

    va_start(va, szFormat);
    wvsprintfA(buf, szFormat, va);
    va_end(va);

    OutputDebugStringA("SUMSERVE:");
    OutputDebugStringA(buf);
    OutputDebugStringA("\r\n");

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\server\file.c ===
/*
 * file.c
 *
 * send files on request over a named pipe.
 *
 * supports requests to package up a file and send it over a named pipe.
 *
 * Geraint Davies, August 92
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "sumserve.h"
#include "errlog.h"
#include "server.h"



BOOL ss_compress(PSTR original, PSTR compressed);
ULONG ss_checksum_block(PSTR block, int size);

extern BOOL bNoCompression;   /* imported from sumserve.c  Read only here */

/*
 * given a pathname to a file, read the file, compress it  package it up
 * into SSPACKETs and send these via ss_sendblock to the named pipe.
 *
 *
 * each packet has a sequence number. if we can't read the file, we send
 * a single packet with sequence -1. otherwise, we carry on until we run out
 * of data, then we send a packet with 0 size.
 */
void
ss_sendfile(HANDLE hpipe, LPSTR file, LONG lVersion)
{
	SSPACKET packet;
	HANDLE hfile;
	int size;
	char szTempname[MAX_PATH];
	PSSATTRIBS attribs;
	BY_HANDLE_FILE_INFORMATION bhfi;

	dprintf1(("getting '%s' for %8x\n", file, hpipe));

	/*
	 * get the file attributes first
	 */
	hfile = CreateFile(file, GENERIC_READ, FILE_SHARE_READ,
				NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if (hfile == INVALID_HANDLE_VALUE) {

		/* report that we could not read the file */
		packet.lSequence = -1;
		ss_sendblock(hpipe, (PSTR) &packet, sizeof(packet));

		DeleteFile(szTempname);
		return;
	}
	/*
	 * seems to be a bug in GetFileInformationByHandle if the
	 * file is not on local machine - so avoid it.
	 */
	bhfi.dwFileAttributes = GetFileAttributes(file);
	GetFileTime(hfile, &bhfi.ftCreationTime,
			&bhfi.ftLastAccessTime, &bhfi.ftLastWriteTime);

	CloseHandle(hfile);

	/* create temp filename */
	GetTempPath(sizeof(szTempname), szTempname);
	GetTempFileName(szTempname, "sum", 0, szTempname);

	/* compress the file into this temporary file */
	if (bNoCompression || (!ss_compress(file, szTempname))) {

		/* try to open the original file */
		hfile = CreateFile(file, GENERIC_READ, FILE_SHARE_READ,
				NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

		dprintf1(("sending original file to %8x\n", hpipe));
	} else {
		/* open temp (compressed) file and send this */
		hfile = CreateFile(szTempname, GENERIC_READ, 0, NULL, OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL, 0);
		dprintf1(("sending compressed file to %8x\n", hpipe));
	}	

	if (hfile == INVALID_HANDLE_VALUE) {

		/* report that we could not read the file */
		packet.lSequence = -1;
		ss_sendblock(hpipe, (PSTR) &packet, sizeof(packet));

		DeleteFile(szTempname);
		return;
	}


	/* loop reading blocks of the file */
	for (packet.lSequence = 0;  ; packet.lSequence++) {

        	if(!ReadFile(hfile, packet.Data, sizeof(packet.Data), (LPDWORD)(&size), NULL)) {
			/* error reading file. send a -1 packet to
			 * indicate this
			 */
			packet.lSequence = -1;
			ss_sendblock(hpipe, (PSTR) &packet, sizeof(packet));
			break;
		}


		packet.ulSize = size;

		if (lVersion==0)
	        	packet.ulSum = ss_checksum_block(packet.Data, size);
		else
	        	packet.ulSum = 0;  /* checksum was compute-bound and overkill */

		if (size == 0) {
			/*
			 * in the last block, in the Data[] field,
			 * we place a SSATTRIBS struct with the file
			 * times and attribs
			 */
			attribs = (PSSATTRIBS) packet.Data;

			attribs->fileattribs = bhfi.dwFileAttributes;
			attribs->ft_create = bhfi.ftCreationTime;
			attribs->ft_lastaccess = bhfi.ftLastAccessTime;
			attribs->ft_lastwrite = bhfi.ftLastWriteTime;

		}


		if (!ss_sendblock(hpipe, (PSTR) &packet, sizeof(packet))) {
			dprintf1(("connection to %8x lost during copy\n", hpipe));
			break;
		}

		if (size == 0) {
			/* end of file */
			break;
		}
	}

	CloseHandle(hfile);
	DeleteFile(szTempname);

	return;
}

/*
 * compress a file. original is the pathname of the original file,
 * compressed is the pathname of the output compressed file.
 *
 * spawns a copy of compress.exe to compress the file, and waits for
 * it to complete successfully.
 */
BOOL
ss_compress(PSTR original, PSTR compressed)
{
   	char szCmdLine[MAX_PATH * 2];
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	DWORD exitcode;


	si.cb = sizeof(STARTUPINFO);
	si.lpDesktop = NULL;
	si.lpReserved = NULL;
	si.lpReserved2 = NULL;
	si.cbReserved2 = 0;
	si.lpTitle = "Sumserve Compression";
	si.dwFlags = STARTF_FORCEOFFFEEDBACK;

	sprintf(szCmdLine, "compress %s %s", original, compressed);


	if (!CreateProcess(NULL,
			szCmdLine,	
			NULL,
			NULL,
			FALSE,
			DETACHED_PROCESS |
			NORMAL_PRIORITY_CLASS,   //??? Can't we silence the console?
			NULL,
			NULL,
			&si,
			&pi)) {

		return(FALSE);
	}

	/* wait for completion. */
	WaitForSingleObject(pi.hProcess, INFINITE);
	if (!GetExitCodeProcess(pi.hProcess, &exitcode)) {
		return(FALSE);
	}

	/* close process and thread handles */
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	if (exitcode != 0) {
		dprintf1(("compress exit code %ld\n", exitcode));
		return(FALSE);
	} else {
		return(TRUE);
	}
} /* ss_compress */

/* produce a checksum of a block of data.
 *
 * This is undoubtedly a good checksum algorithm, but it's also compute bound.
 * For version 1 we turn it off.  If we decide in version 2 to turn it back
 * on again then we will use a faster algorithm (e.g. the one used to checksum
 * a whole file.
 *
 * Generate checksum by the formula
 *	checksum = SUM( rnd(i)*(1+byte[i]) )
 * where byte[i] is the i-th byte in the file, counting from 1
 *       rnd(x) is a pseudo-random number generated from the seed x.
 *
 * Adding 1 to byte ensures that all null bytes contribute, rather than
 * being ignored. Multiplying each such byte by a pseudo-random
 * function of its position ensures that "anagrams" of each other come
 * to different sums. The pseudorandom function chosen is successive
 * powers of 1664525 modulo 2**32. 1664525 is a magic number taken
 * from Donald Knuth's "The Art Of Computer Programming"
 */

ULONG
ss_checksum_block(PSTR block, int size)
{
	unsigned long lCheckSum = 0;         	/* grows into the checksum */
	const unsigned long lSeed = 1664525; 	/* seed for random Knuth */
	unsigned long lRand = 1;             	/* seed**n */
	unsigned long lIndex = 1;             	/* byte number in block */
	unsigned Byte;	                   	/* next byte to process in buffer */
	unsigned length;			/* unsigned copy of size */	
	
	length = size;
	for (Byte = 0; Byte < length ;++Byte, ++lIndex) {

		lRand = lRand*lSeed;
		lCheckSum += lIndex*(1+block[Byte])*lRand;
	}

	return(lCheckSum);
} /* ss_checksum_block */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\server\server.h ===
/*
 * server.h
 *
 * inter-module declarations for sumserver
 *
 * Geraint, July 92
 */



/*
 * debug macros
 *
 */

#if DBG
    void dbgPrintf(char * szFormat, ...);
    extern int ssDebugLevel;


#define dprintf(_x_)	dbgPrintf _x_
#define dprintf1(_x_)	if (ssDebugLevel >= 1) dbgPrintf _x_
#define dprintf2(_x_)	if (ssDebugLevel >= 2) dbgPrintf _x_
#define dprintf3(_x_)	if (ssDebugLevel >= 3) dbgPrintf _x_
#define dprintf4(_x_)	if (ssDebugLevel >= 4) dbgPrintf _x_

#else

#define dprintf(_x_)
#define dprintf1(_x_)
#define dprintf2(_x_)
#define dprintf3(_x_)
#define dprintf4(_x_)

#endif

#if DBG
	BOOL FAR PASCAL _Assert(BOOL fExpr, LPSTR szFile, int iLine);

	#define ASSERT(expr)		 _Assert((expr), __FILE__, __LINE__)


#else
	#define ASSERT(expr)		

#endif

/*
 * a list of file names, defined in scan.c
 */
typedef struct fnamelist * PFNAMELIST;



/*
 * logs defined and initialised in sumserve.c
 */
HLOG hlogErrors, hlogEvents;



/* function declarations --------------------------*/

/* in scan.c */
PFNAMELIST ss_addtolist(PFNAMELIST head, PSTR filename);
BOOL ss_scan(HANDLE hpipe, LPSTR pRoot, LONG lVersion, BOOL bChecksum, BOOL fDeep);
void ss_cleanconnections(PFNAMELIST connections);
PFNAMELIST ss_handleUNC(HANDLE hpipe, long lVersion, LPSTR password, LPSTR server, PFNAMELIST);


/* in file.c */
void ss_sendfile(HANDLE hpipe, LPSTR file, LONG lVersion);

BOOL ss_compress(PSTR original, PSTR compressed);

/* in sumserve.c */
BOOL ss_sendresponse(HANDLE hpipe, long lCode, ULONG ulSize,
                ULONG ulSum, PSTR szFile);
BOOL ss_sendnewresp(HANDLE hPipe, long lVersion, long lCode, ULONG ulSize,
                ULONG ulSum, DWORD TimeLo, DWORD TimeHi, PSTR szFile);

BOOL ss_sendblock(HANDLE hpipe, PSTR buffer, int length);


/* in files.c */
BOOL ss_sendfiles(HANDLE hPipe, long lVersion);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\server\files.c ===
// !!! PipeCount needs a critical section?
/* Send a list of files across the named pipe as fast as possible
*
* The overall organisation:
*
* Sumserve receives requests over a named pipe.  (See sumserve.h)
* The requests can be for details of files or for the files
* themselves.  File details involve sending relatively small
* quantities of data and therefore no attempt is made to
* double-buffer or overlap execution.
*
* For a send-files request (SSREQ_FILES), the data is typically large,
* and can be a whole NT build which means sending hundreds
* of megabytes.  Such a transfer can take literally days and
* so optimisation to achieve maximum throughput is essential.
*
* To maximise throughput
* 1. The data is packed before sending
* 2. One thread per pipe does almost nothing except send data through
*    its pipe with all other work being done on other threads.
*
* Because we have had trouble with bad files being transmitted over
* the network, we checksum each file.  Windiff requires that we
* do a scan first before doing a copy, so we already have checksums.
* All we need to do is to check the newly received files.
* LATER: We should not require checksums in advance.  The checksuming
*        could be done by (yet another) pass, created if need be.  An extra
*         flag could be added to the request to indicate "send checksums".
*
* The packing is done by a separate program that reads from a file and
* writes to a file.  This means that we get three lots of file I/O
* (read; write; read) before the file is sent.  For a small
* file the disk cacheing may eliminate this, for a large file we
* probably pay the price.  A possible future enhancement is therefore
* to rewrite the packing to do it in-storage so that the file is read
* once only.  In the meantime we run threads to overlap the packing
* with the sending of the previous file(s).
*
* The main program sets up a named pipe which a client connects to.
* This is necessary because pipes are only half-duplex. i.e. the
* following hangs:
*   client read; server read; client write;
* The write hangs waiting for the client read.  We broadly speaking have one
* pipe running in each direction.
*
* To eliminate the overhead of setting up a virtual circuit for each
* file request there is a request code to send a list of files.
* The protocol (for the control pipe) is then as follows:
* 1. Typical session:
*    CLIENT                                      SERVER
*         ----<SSREQ_FILES------------------>
*         <------(SSRESP_PIPENAME,pipename)--
*         ----<SSREQ_NEXTFILE,filename>----->
*         ----<SSREQ_NEXTFILE,filename>----->
*               ...
*         --------<SSREQ_ENDFILES>---------->
*
* Meanwhile, asynchronously with this, the data goes back the other way like
*
*    CLIENT                                      SERVER
*         <-----<SSNEWRESP>----------
*         <---<1 or more SSNEWPACK>--
                ...
*         <-----<SSNEWRESP>----------
*         <---<1 or more SSNEWPACK>--
*               ...
*         <-----<End>----------------
*
* Even a zero length file gets 1 SSNEWPACK record.
* An Erroneous file (can't read etc) gets no SSNEWPACKs and a negative lCode
* in its SSNEWRESP.
* A file that goes wrong during read-in gets a packet length code of -1 or -2.
* The end of the sequence of SSNEWPACKs is signalled by a shorter
* than maximum length one.  If the file is EXACTLY n buffers long
* then an extra SSNEWPACK with zero bytes of data comes on the end.
*
* The work is broken into the following threads:
* Control thread (ss_sendfiles):
*       Receives lists of files to be sent
*       Creates pipes for the actual transmission
*       Creates queues (see below. Queue parameters must match pipes)
*       Puts filenames onto first queue
*       Destroys first queue at end.
* Packing thread
*       Takes file details from the packing queue
*       Packs the file (to create a temporary file)
*       Puts the file details (including the temp name) onto the reading queue
*       Destroys the reading queue at the end
* Reading thread
*       Takes the file details from the reading queue
*       Splits the file into a header and a list of data packets
*       and enqueues each of these on the Sending thread.
*       (Note this means no more than one reading thread to be running).
*       Erases the temp file
*       Destroys the sending queue at the end
* Sending thread
*       Takes the things from the sending thread and sends them
*
*  This whole scheme can be running for multiple clients, so we
*  need some instance data that defines which pipeline we are
*  running.  This is held in the instance data of the QUEUEs that
*  are created (retrieved by the queue emptiers by Queue_GetInstanceData).
*  The instance data at each stage is the handle of the following stage
*  i.e. the next QUEUE, or the hpipe of the data pipe for the last stage.
*  The current design only allows for one data pipe.  If we have
*  multiple data pipes then we need to solve the following problems:
*    1. Communication of the number and names of the data pipes
*       to the client (presumably across the control thread.
*    2. Error handling
*    3. Balancing the load between the pipes
*
* NORMAL SHUTDOWN:
* After the last element has been Put to the first Queue the main thread
* calls Queue_Destroy to destroy the first queue.  This will result in
* the queue being destroyed BUT NOT UNTIL THE LAST ELEMENT HAS BEEN GOT.
* When the last packing thread gets its ENDQUEUE it calls Queue_Destroy
* to destroy the next queue, and so on down the line.
*
* ERROR RECOVERY
* Errors can occur at almost any stage.
* The obvious implementation of having a global BOOL that tells
* whether a disaster has happened won't work because there
* could be multiple clients and only one of them with a disaster.
*
* An error in a single file is propagated forwards to the client end.
* An error in the whole mechanism (net blown away) can mean that the
* whole thing needs to be shut down.  In this case the error must
* be propagated backwards.  That works as follows:
* The Sending thread Queue_Aborts the SendQueue which it was Getting from.
* This results in Puts to this queue returning FALSE.
* Case 1. There are no more Puts anyway:
*    We are on the last file, the filling thread was about to Destroy the
*    queue anyway.  It does so.
* Case 2. The next Put gets a FALSE return code.
*    The thread attempting the Put does a Queue_Destroy on its output
*    queue and a Queue_Abort on its input queue.
*    This propagates all the way back until either the first queue
*    is aborted or it reaches a queue that was being destroyed anyway.
*    See Queue.h
* Once the Putting thread has done a Destroy on its output queue,
* the threads Getting from it (which are still running, even if
* they did the Abort) get STOPTHREAD/ENDQUEUE back from a Get.  The last Get
* to a queue that has had a Queue_Destroy done on it has a side effect
* of actually deallocating the queue.  In our case we only have one
* Getting thread, so what happens is that it Queue_Aborts the queue
* and then does a Queue_Get which WAITs.  When the Queue_Destroy comes in
* from the Putting thread, this releases the WAITing Getting thread which
* then actually deallocates the Queue.
*
* You can also get shutdown happening from both ends at once.  This happens
* when the control thread's pipe goes down getting names and the sending pipe
* also breaks.  (e.g. general net collapse or client aborted).
*/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <gutils.h>
#include "sumserve.h"
#include "errlog.h"
#include "server.h"
#include "queue.h"

#if DBG
#define STATIC                  // allow for debug.
#else
#define STATIC static
#endif

/* SOCKETS / NAMED PIPES macros
 */
#ifdef SOCKETS
#define CLOSEHANDLE( handle )   closesocket( handle )
#define TCPPORT 1024
#else
#define CLOSEHANDLE( handle )   CloseHandle( handle )
#endif


//////////////ULONG ss_checksum_block(PSTR block, int size);

#define PIPEPREFIX "Sdpx"       // for making an unlikely pipe name
static PipeCount = 0;           // for making pipe names unique.


/* structure for recording all we need to know about a file as it
 * progresses along the chain of pipes                               */
typedef struct {
        FILETIME ft_create;
        FILETIME ft_lastaccess;
        FILETIME ft_lastwrite;
        DWORD    fileattribs;
        DWORD    SizeHi;        /* Anticipating files larger that 4GB! */
        DWORD    SizeLo;        /* Anticipating files larger that 4GB! */
        int      ErrorCode;
        long     Checksum;      /* Uunused except for debug. */
        char     TempName[MAX_PATH];    /* name of packed file at server */
        char     Path[MAX_PATH];        /* name of file to fetch */
        char     LocalName[MAX_PATH];   /* name of file at client end */
} FILEDETAILS;

/* forward declarations for procedures */
STATIC int PackFile(QUEUE Queue);
STATIC int ReadInFile(QUEUE Queue);
STATIC int SendData(QUEUE Queue);
STATIC void PurgePackedFiles(PSTR Ptr, int Len);
STATIC BOOL EnqueueName(QUEUE Queue, LPSTR Path, UINT BuffLen);
STATIC BOOL AddFileAttributes(FILEDETAILS * fd);

static void Error(PSTR Title)
{
        dprintf1(("Error %d from %s when creating data pipe.\n", GetLastError(), Title));
}

/* ss_sendfiles:
   Send a response naming the data pipe, collect further names
   from further client messages, all according to the protocol above.
   Start the data pipe and arrange that all the files are sent
   by getting them all enqueued on the first queue.
   Destroy PackQueue at the end.  Arrange for the other queues
   to be destroyed by the usual Queue mechanism, or destroy them
   explicitly if they never get started.
*/
BOOL
ss_sendfiles(HANDLE hPipe, long lVersion)
{       /* Create the queues and set about filling the first one */

        QUEUE PackQueue, ReadQueue, SendQueue;

#ifdef SOCKETS
        SOCKET hpSend;
        static BOOL SocketsInitialized = FALSE;
#else
        HANDLE hpSend;          /* the data pipe */
#endif /* SOCKETS */

        char PipeName[80];      /* The name of the new data pipe */
        BOOL Started = FALSE;   /* TRUE if something enqueued */


#ifdef SOCKETS
        if( !SocketsInitialized )
        {
                WSADATA WSAData;

                if( ( WSAStartup( MAKEWORD( 1, 1 ), &WSAData ) ) == 0 )
                {
                        SocketsInitialized = TRUE;
                }
                else
                {
                        printf("WSAStartup failed");
                }
        }
#endif

        {
                /****************************************
                We need security attributes for the pipe to let anyone other than the
                current user log on to it.
                ***************************************/

                /* Allocate DWORDs for the ACL to get them aligned.  Round up to next DWORD above */
                DWORD Acl[(sizeof(ACL)+sizeof(ACCESS_ALLOWED_ACE)+3)/4+4];    // + 4 by experiment!!
                SECURITY_DESCRIPTOR sd;
                PSECURITY_DESCRIPTOR psd = &sd;
                PSID psid;
                SID_IDENTIFIER_AUTHORITY SidWorld = SECURITY_WORLD_SID_AUTHORITY;
                PACL pacl = (PACL)(&(Acl[0]));
                SECURITY_ATTRIBUTES sa;

                if (!AllocateAndInitializeSid( &SidWorld, 1, SECURITY_WORLD_RID
                                              , 1, 2, 3, 4, 5, 6, 7
                                              , &psid
                                              )
                   ) {
                        Error("AllocateAndInitializeSid");
                        return FALSE;
                   }

                if (!InitializeAcl(pacl, sizeof(Acl), ACL_REVISION)){
                        Error("InitializeAcl");
                        return FALSE;
                }
                if (!AddAccessAllowedAce(pacl, ACL_REVISION, GENERIC_WRITE|GENERIC_READ, psid)){
                        Error("AddAccessAllowedAce");
                        return FALSE;
                }
                if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION)){
                        Error("InitializeSecurityDescriptor");
                        return FALSE;
                }
                if (!SetSecurityDescriptorDacl(psd, TRUE, pacl, FALSE)){
                        Error("SetSecurityDescriptorDacl");
                        return FALSE;
                }
                sa.nLength = sizeof(sa);
                sa.lpSecurityDescriptor = psd;
                sa.bInheritHandle = TRUE;

                /* We now have a good security descriptor!  */

                /* Create the (new, unique) name of the pipe and then create the pipe */

                /* I am finding it hard to decide whether the following line (++PpipeCount)
                   actually needs a critical section or not.  The worst that could happen
                   would be that we got an attempt to create a pipe with an existing name.
                */
                ++PipeCount;
                sprintf(PipeName, "\\\\.\\pipe\\%s%d", PIPEPREFIX, PipeCount);

#ifdef SOCKETS
                if (!ss_sendnewresp( hPipe, SS_VERSION, SSRESP_PIPENAME
                                   , 0, 0, 0, TCPPORT, "")) {
                        dprintf1(( "Failed to send response on pipe %x naming new pipe.\n"
                              , hPipe));
                        return FALSE;           /* Caller will close hPipe */
                }

                if( !SocketListen( TCPPORT, &hpSend ) )
                {
                    dprintf1(("Could not create socket\n"));
                    return FALSE;
                }

                FreeSid(psid);
#else
                hpSend = CreateNamedPipe(PipeName,              /* pipe name */
                                PIPE_ACCESS_DUPLEX,     /* both read and write */
                                PIPE_WAIT|PIPE_TYPE_MESSAGE|PIPE_READMODE_MESSAGE,
                                1,              /* at most one instance */
                                10000,          /* sizeof(SSNEWPACK) + some for luck */
                                0,              /* dynamic inbound buffer allocation */
                                5000,           /* def. timeout 5 seconds */
                                &sa             /* security descriptor */
                                );
                FreeSid(psid);

                if (hpSend == INVALID_HANDLE_VALUE) {
                        dprintf1(("Could not create named data pipe\n"));
                        return FALSE;
                }
                dprintf1(("Data pipe %x called '%s' created for main pipe %x.\n", hpSend, PipeName, hPipe));

#endif /* SOCKETS */

        }




        /* Send the response which names the data pipe */

#ifndef SOCKETS
        if (!ss_sendnewresp( hPipe, SS_VERSION, SSRESP_PIPENAME
                           , 0, 0, 0, 0, PipeName)) {
                dprintf1(( "Failed to send response on pipe %x naming new pipe.\n"
                      , hPipe));
                CLOSEHANDLE(hpSend);
                return FALSE;           /* Caller will close hPipe */
        }

        if (!ConnectNamedPipe(hpSend, NULL)) {
                CLOSEHANDLE(hpSend);
                return FALSE;
        }
#endif /* NOT SOCKETS */
        //dprintf1(("Client connected to data pipe -- here we go...\n"));

        /* Create all the queues: Allow up to 10K file names to be queued
           up to 10 files to be packed in advance and 6 buffers of data to be
           read into main storage in advance:
                                  proc  MxMT MnQS MxQ Event   InstData   Name*/
        SendQueue = Queue_Create(SendData, 1, 0,  6, NULL, (DWORD)hpSend, "SendQueue");
        ReadQueue = Queue_Create(ReadInFile, 1, 0, 10, NULL, (DWORD)SendQueue, "ReadQueue");
        PackQueue = Queue_Create(PackFile, 3, 0, 99999, NULL, (DWORD)ReadQueue, "PackQueue");

        /* Abort unless it all worked */
        if (PackQueue==NULL || ReadQueue==NULL || SendQueue==NULL) {
                dprintf1(("Queues for pipe %x failed to Create.  Aborting...\n", hPipe));
                if (PackQueue) Queue_Destroy(PackQueue);
                if (ReadQueue) Queue_Destroy(ReadQueue);
                if (SendQueue) Queue_Destroy(SendQueue);
                CLOSEHANDLE(hpSend);
                return FALSE;           /* Caller will close hPipe */
        }


        /* Collect names from client and enqueue each one */
        for (; ; )
        {       SSNEWREQ Request;       /* message from client */
                DWORD    ActSize;       /* bytes read from (main) pipe */

                if (ReadFile(hPipe, &Request, sizeof(Request), &ActSize, NULL)){
                        if (Request.lVersion>SS_VERSION) {
                                dprintf1(("Bad version %d in file list request on pipe %x\n"
                                , Request.lVersion, hPipe));

                                break;

                        }
                        if (Request.lRequest!=LREQUEST) {
                                dprintf1(("Bad LREQUEST from pipe %x\n", hPipe));

                                break;
                        }
                        if (Request.lCode == -SSREQ_ENDFILES) {
                                dprintf1(("End of client's files list on pipe %x\n", hPipe));

                                /* This is the clean way to end */
                                Queue_Destroy(PackQueue);
                                if (!Started) {
                                        /* OK - so the clever clogs requested zero files */
                                        Queue_Destroy(ReadQueue);
                                        Queue_Destroy(SendQueue);
                                        /* Send a No More Files response */
#ifdef SOCKETS
                                        {
                                            SSNEWRESP resp;

                                            resp.lVersion = SS_VERSION;
                                            resp.lResponse = LRESPONSE;
                                            resp.lCode = SSRESP_END;
                                            resp.ulSize = 0;
                                            resp.ulSum = 0;
                                            resp.ft_lastwrite.dwLowDateTime = 0;
                                            resp.ft_lastwrite.dwHighDateTime = 0;

                                            send(hpSend, (PSTR) &resp, sizeof(resp), 0);
                                        }
#else
                                        ss_sendnewresp( hpSend, SS_VERSION, SSRESP_END
                                                , 0,0, 0,0, NULL);
#endif /* SOCKETS */
                                        CLOSEHANDLE(hpSend);
                                }
                                return TRUE;
                        }
                        if (Request.lCode != -SSREQ_NEXTFILE) {

                                dprintf1(( "Bad code (%d) in files list from pipe %x\n"
                                      , Request.lCode, hPipe));

                                break;
                        }
                }
                else {  DWORD errorcode = GetLastError();
                        switch(errorcode) {

                                case ERROR_NO_DATA:
                                case ERROR_BROKEN_PIPE:
                                        /* pipe connection lost - forget it */
                                        dprintf1(("main pipe %x broken on read\n", hPipe));
                                        break;
                                default:
                                        dprintf1(("read error %d on main pipe %x\n", errorcode, hPipe));
                                        break;
                        }
                        break;
                }
                if (!EnqueueName( PackQueue, Request.szPath
                                , (UINT)((LPBYTE)(&Request) + ActSize - (LPBYTE)(&Request.szPath))
                                )
                   ){
                        break;
                }
                Started = TRUE;
        } /* loop */

        /* only exit this way on error */
        /* Close the queues down.  Allow what's in them to run through */
        Queue_Destroy(PackQueue);
        if (!Started) {
                Queue_Destroy(ReadQueue);
                Queue_Destroy(SendQueue);

        }
        return FALSE;
} /* ss_sendfiles */


/* Attempt to Queue.Put Path onto Queue as a FILEDETAILS
   with default values for all other fields.
   Return TRUE or FALSE according as it succeeded.
*/
STATIC BOOL EnqueueName(QUEUE Queue, LPSTR Path, UINT BuffLen)
{
        FILEDETAILS fd;

        /* unpack Path and LocalName from "superstring" */
        strcpy(fd.Path, Path);
        BuffLen -= (strlen(Path)+1);
        if (BuffLen<0) return FALSE;  // Uh oh! strlen just looked at garbage.
        Path += strlen(Path)+1;
        BuffLen -= (strlen(Path)+1);
        if (BuffLen<0) return FALSE;  // Uh oh! strlen just looked at garbage.
        strcpy(fd.LocalName, Path);

        /* set defaults for every field */
        fd.ErrorCode = 0;
        fd.ft_lastwrite.dwLowDateTime = 0;
        fd.ft_lastwrite.dwHighDateTime = 0;
        fd.ft_create.dwLowDateTime = 0;
        fd.ft_create.dwHighDateTime = 0;
        fd.ft_lastaccess.dwLowDateTime = 0;
        fd.ft_lastaccess.dwHighDateTime = 0;
        fd.fileattribs = 0;
        fd.SizeHi = 0;
        fd.SizeLo = 0;
        fd.Checksum = 0;
        fd.TempName[0] = '\0';

        if(!Queue_Put(Queue, (LPBYTE)&fd, sizeof(fd))){
                dprintf1(("Put to pack queue failed\n"));
                return FALSE;
        }
        return TRUE;
} /* EnqueueName */


/* Dequeue elements from Queue, pack them and enqueue them on the next
   queue whose queue handle is the InstanceData of Queue.
   The ErrorCode in fd when Dequeued must be 0.                    ??? Incautious?
   Destroy the output queue at the end.
   On a serious error, Queue_Abort Queue and Queue_Destroy the output queue.
*/
STATIC int PackFile(QUEUE Queue)
{
        FILEDETAILS fd;         /* the queue element processed */
        QUEUE OutQueue;
        BOOL Aborting = FALSE;  /* TRUE means input has been aborted (probably output is sick) */
        DWORD ThreadId;
        ThreadId = GetCurrentThreadId();

        dprintf1(("File packer %d starting \n", ThreadId));         // can't quote hPipe, don't know it
        OutQueue = (QUEUE)Queue_GetInstanceData(Queue);

        for (; ; )
        {       int rc; /* return code from Queue_Get */

                rc = Queue_Get(Queue, (LPBYTE)&fd, sizeof(fd));
                if (rc==ENDQUEUE) {
                        dprintf1(("Packing thread %d ending.\n", ThreadId));
                        Queue_Destroy(OutQueue);
                        // dprintf1(("%d has done Queue_Destroy on ReadQueue.\n", ThreadId));
                        ExitThread(0);
                }
                if (rc==STOPTHREAD) {
                        dprintf1(("%d, a packing thread ending.\n", ThreadId));
                        ExitThread(0);
                }
                else if (rc<0) {
                        dprintf1(( "Packing thread %d aborting.  Bad return code %d from Get.\n"
                              , ThreadId, rc));
                        if (Aborting) break;    /* Touch nothing, just quit! */
                        Queue_Abort(Queue, NULL);
                        continue;               /* Next Queue_Get destroys Queue */
                }


                /* First add the file attributes to fd */
                AddFileAttributes(&fd);
                /* no need to look at return code fd.ErrorCode tells all */

                /* create temp filename */
                if (  0 != fd.ErrorCode
                   || 0==GetTempPath(sizeof(fd.TempName), fd.TempName)
                   || 0==GetTempFileName(fd.TempName, "sum", 0, fd.TempName)
                   )
                        fd.ErrorCode = SSRESP_NOTEMPPATH;

                /* Pack into temp file */
                if (fd.ErrorCode==0) {
                        BOOL bOK = FALSE;

                        //dprintf1(("%d Compressing file '%s' => '%s'\n", ThreadId, fd.Path, fd.TempName));

                        /* compress the file into this temporary file
                           Maybe it will behave badly if there's a large file or
                           no temp space or something...
                        */
                        try{
                            if (!ss_compress(fd.Path, fd.TempName)) {
                                fd.ErrorCode = SSRESP_COMPRESSFAIL;
                                dprintf1(("Compress failure on %d for %s\n", ThreadId, fd.Path));
                            }
                            else bOK = TRUE;
                        } except(EXCEPTION_EXECUTE_HANDLER) {
                            if (!bOK){
                                fd.ErrorCode = SSRESP_COMPRESSEXCEPT;
                                dprintf1(("Compress failure on %d for %s\n", ThreadId, fd.Path));
#ifdef trace
                                {       char msg[80];
                                        wsprintf( msg, "Compress failure on %d for %s\n"
                                                , ThreadId, fd.Path);
                                        Trace_File(msg);
                                }
#endif
                            }
                        }

                }

                //dprintf1(("%d Putting file '%s' onto Read Queue\n", ThreadId, fd.Path));
                if (!Queue_Put(OutQueue, (LPBYTE)&fd, sizeof(fd))) {
                        dprintf1(("%d Put to ReadQueue failed for %s.\n", ThreadId, fd.Path));
                        Queue_Abort(Queue, NULL);
                        DeleteFile(fd.TempName);

                        Aborting = TRUE;
                        /* bug:  If this Queue_Put fails on the very first Put,
                           then the next queue in the chain after OutQueue will
                           never come alive and so will never get Destroyed.
                           Worst it could cause is a memory leak. ???
                        */
                        continue; /* next Queue_Get destroys Queue */
                }
        }
        return 0;
} /* PackFile */



/* Use the file name in *fd and get its attributes (size, time etc)
   Add these to fd.  If it fails, set the ErrorCode in *fd
   to an appropriate non-zero value.
*/
STATIC BOOL AddFileAttributes(FILEDETAILS * fd)
{
        HANDLE hFile;
        BY_HANDLE_FILE_INFORMATION bhfi;

        hFile = CreateFile(fd->Path, GENERIC_READ, FILE_SHARE_READ,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
        if (hFile == INVALID_HANDLE_VALUE) {

                fd->ErrorCode = SSRESP_CANTOPEN;
                return FALSE;

        }

        /* bug in GetFileInformationByHandle if file not on local
         * machine? Avoid it!
         */
        bhfi.dwFileAttributes = GetFileAttributes(fd->Path);
        if (bhfi.dwFileAttributes == 0xFFFFFFFF) {
                fd->ErrorCode = SSRESP_NOATTRIBS;
                CloseHandle(hFile);
                return FALSE;
        }

        if (!GetFileTime(hFile, &bhfi.ftCreationTime,
                         &bhfi.ftLastAccessTime, &bhfi.ftLastWriteTime)){

                fd->ErrorCode = SSRESP_NOATTRIBS;
                dprintf1(("Can't get file attributes for %s\n"
                      , (fd->Path?fd->Path : "NULL")));
                CloseHandle(hFile);
                return FALSE;
        }


        CloseHandle(hFile);

        {
                LONG err;
                fd->Checksum = checksum_file(fd->Path, &err);
                if (err!=0) {
                        fd->ErrorCode = SSRESP_CANTOPEN;
                        return FALSE;
                }
        }

        fd->ft_lastwrite = bhfi.ftLastWriteTime;
        fd->ft_lastaccess = bhfi.ftLastAccessTime;
        fd->ft_create = bhfi.ftCreationTime;
        fd->SizeHi = bhfi.nFileSizeHigh;
        fd->SizeLo = bhfi.nFileSizeLow;
        fd->fileattribs = bhfi.dwFileAttributes;
        return TRUE;

} /* AddFileAttributes */


/* Dequeue elements from Queue, Create on the output queue a SSNEWRESP
   followed by 1 or more SSNEWPACK structures, the last of which will be
   shorter than full length (zero length data if need be) to mark end-of-file.
   Files with errors already get zero SSNEWPACKs but bad code in SSNEWRESP.
   The output queue is the instance data of Queue.
*/
STATIC int ReadInFile(QUEUE Queue)
{       FILEDETAILS fd;                 /* The queue element processed */
        QUEUE OutQueue;
        HANDLE hFile;                   /* The packed file */
        SSNEWPACK Pack;                 /* output message */
        BOOL    ShortBlockSent;         /* no need to send another SSNEWPACK
                                           Client knows the file has ended */
        BOOL    Aborting = FALSE;       /* Input has been aborted. e.g. because output sick */


        dprintf1(("File reader starting \n"));
        OutQueue = (QUEUE)Queue_GetInstanceData(Queue);
        for (; ; )   /* for each file */
        {       int rc;         /* return code from Queue_Get */

                rc = Queue_Get(Queue, (LPBYTE)&fd, sizeof(fd));
                if (rc==STOPTHREAD || rc==ENDQUEUE) {
                        if (!Aborting) {
                                /* Enqueue a No More Files response */
                                SSNEWRESP resp;
                                resp.lVersion = SS_VERSION;
                                resp.lResponse = LRESPONSE;
                                resp.lCode = SSRESP_END;
                                if (!Queue_Put( OutQueue, (LPBYTE)&resp , RESPHEADSIZE)) {
                                        dprintf1(("Failed to Put SSRESP_END on SendQueue\n"));
                                }
                                //// dprintf1(( "Qued SSRESP_END:  %x %x %x %x...\n"
                                ////       , resp.lVersion, resp.lResponse, resp.lCode, resp.ulSize));
                        }
                        if (rc==ENDQUEUE)
                                Queue_Destroy(OutQueue);
                        dprintf1(("File reader ending\n"));
                        ExitThread(0);
                }
                else if (rc<0){
                        dprintf1(("ReadIn aborting.  Bad return code %d from Queue_Get.\n", rc));
                        if (Aborting) break;   /* All gone wrong.  Just quit! */
                        Queue_Abort(Queue, PurgePackedFiles);
                        CloseHandle(hFile);
                        Aborting = TRUE;
                        continue;               /* next Get gets STOPTHREAD */
                }

                //dprintf1(( "Reading file '%s' Error code %d\n"
                //      , (fd.TempName?fd.TempName:"NULL"), fd.ErrorCode
                //      ));

                if (fd.ErrorCode==0) {
                        /* open temp (compressed) file */
                        hFile = CreateFile(fd.TempName, GENERIC_READ, 0, NULL,
                                     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
                        if (hFile == INVALID_HANDLE_VALUE) {
                                /* report that we could not read the file */
                                fd.ErrorCode = SSRESP_NOREADCOMP;
                                dprintf1(( "Couldn't open compressed file for %s %s\n"
                                      , fd.Path, fd.TempName));
                        }
                }
                if (  fd.ErrorCode==SSRESP_COMPRESSFAIL
                   || fd.ErrorCode==SSRESP_NOREADCOMP
                   || fd.ErrorCode==SSRESP_NOTEMPPATH
                   || fd.ErrorCode==SSRESP_COMPRESSEXCEPT
                   ) {
                        /* open original uncompressed file */
                        hFile = CreateFile(fd.Path, GENERIC_READ, 0, NULL,
                                     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
                        if (hFile == INVALID_HANDLE_VALUE) {
                                /* report that we could not read the file */
                                fd.ErrorCode = SSRESP_NOREAD;
                                dprintf1(( "Couldn't open file %s \n", fd.Path));
                        }
                }

                /* Put the file name etc on the output queue as a SSNEWRESP */
                {       SSNEWRESP resp;
                        LPSTR LocalName;
                        resp.lVersion = SS_VERSION;
                        resp.lResponse = LRESPONSE;
                        resp.lCode = (fd.ErrorCode ? fd.ErrorCode: SSRESP_FILE);
                        resp.ulSize = fd.SizeLo;  /* file size  <= 4GB !!! */
                        resp.fileattribs = fd.fileattribs;
                        resp.ft_create = fd.ft_create;
                        resp.ft_lastwrite = fd.ft_lastwrite;
                        resp.ft_lastaccess = fd.ft_lastaccess;
                        resp.ulSum = fd.Checksum;
                        resp.bSumValid = FALSE;
                        strcpy(resp.szFile, fd.Path);
                        LocalName = resp.szFile+strlen(resp.szFile)+1;
                        strcpy(LocalName, fd.LocalName);

                        if(!Queue_Put( OutQueue, (LPBYTE)&resp
                                 , RESPHEADSIZE + strlen(resp.szFile)
                                                +strlen(LocalName)+2)
                          ) {
                                dprintf1(("Put to SendQueue failed.\n"));
                                Queue_Abort(Queue, PurgePackedFiles);
                                Aborting = TRUE;
                                CloseHandle(hFile);
                                continue;       /* next Get gets STOPTHREAD */
                        }
                        // dprintf1(( "Qued SSRESP_FILE: %x %x %x %x...\n"
                        //       , resp.lVersion, resp.lResponse, resp.lCode, resp.ulSize));
                }

                Pack.lSequence = 0;
                /* Loop reading blocks of the file and queueing them
                   Set fd.ErrorCode for failures.

                   I'm worried about file systems that give me short blocks in the
                   middles of files!!!
                */
                ShortBlockSent = FALSE;
                if (  fd.ErrorCode==SSRESP_COMPRESSFAIL
                   || fd.ErrorCode==SSRESP_NOREADCOMP
                   || fd.ErrorCode==SSRESP_NOTEMPPATH
                   || fd.ErrorCode==SSRESP_COMPRESSEXCEPT
                   || fd.ErrorCode==0
                   ) {
                    for(;;)   /* for each block */
                    {
                        DWORD ActSize;  /* bytes read */

                        if( !ReadFile( hFile, &(Pack.Data), sizeof(Pack.Data)
                                     , &ActSize, NULL) ) {
                                /* error reading temp file. */
                                if (ShortBlockSent) {
                                        /* Fine. End reached */
                                        /* Should check error was end of file !!! */
                                        CloseHandle(hFile);
                                        break; /* blocks loop */
                                }
                                dprintf1(( "Error reading temp file %s.\n"
                                      , (fd.TempName?fd.TempName:"NULL")));
                                CloseHandle(hFile);
                                dprintf1(("deleting bad file: %s\n", fd.TempName));
                                DeleteFile(fd.TempName);
                                Pack.ulSize = (ULONG)(-2);   /* tell client */
                                break; /* blocks loop */
                        }
                        else if (ActSize > sizeof(Pack.Data)) {
                                dprintf1(( "!!? Read too long! %d %d\n"
                                      , ActSize, sizeof(Pack.Data)));
                                Pack.ulSize = (ULONG)(-1);   /* tell client */
                        }
                        else Pack.ulSize = ActSize;

                        if (ActSize==0 && ShortBlockSent) {
                                /* This is normal! */
                                CloseHandle(hFile);
                                break;
                        }
                        else ++Pack.lSequence;


                        Pack.lPacket = LPACKET;
                        Pack.lVersion = SS_VERSION;
                        Pack.ulSum = 0;
////////////////////    Pack.ulSum = ss_checksum_block(Pack.Data, ActSize);    ///////////
                        if(!Queue_Put( OutQueue, (LPBYTE)&Pack
                                     ,  PACKHEADSIZE+ActSize)){
                                dprintf1(("Put to SendQueue failed.\n"));
                                Queue_Abort(Queue, PurgePackedFiles);
                                CloseHandle(hFile);
                                Aborting = TRUE;
                                break;  /* from blocks loop */
                        }
                        // dprintf1(( "Qued SSNEWPACK:  %x %x %x %x %x...\n"
                        //       , Pack.lVersion, Pack.lPacket, Pack.lSequence, Pack.ulSize
                        //       , Pack.ulSum));

                        if (ActSize<PACKDATALENGTH) {   /* Success. Finished */
                                ShortBlockSent = TRUE;
                        }

                    }
                } /* blocks */

                /* The data is all in storage now.  Delete the temp file
                   If there was no temp file (due to error) this still should be harmless.
                */
#ifndef LAURIE
                DeleteFile(fd.TempName);
#endif // LAURIE
                // dprintf1(("deleting file: %s\n", fd.TempName));

        } /* files */

        return 0;
} /* ReadInFile */


/* Dequeue elements from Queue, send them down the pipe whose
   handle is the instance data of Queue.
   On error Abort Queue.
*/
STATIC int SendData(QUEUE Queue)
{
        SSNEWPACK ssp;    /* relies on this being no shorter than a SSRESP */
#ifdef SOCKETS
        SOCKET OutPipe;
#else
        HANDLE OutPipe;
#endif /* SOCKETS */

        BOOL Aborting = FALSE;  /* TRUE means input has been aborted */

        dprintf1(("File sender starting \n"));
        if (!SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST))
            dprintf1(("Failed to set thread priority\n"));

#ifdef SOCKETS
        OutPipe = (SOCKET)Queue_GetInstanceData(Queue);
#else
        OutPipe = (HANDLE)Queue_GetInstanceData(Queue);
#endif
        try{
            for (; ; ) {
                int rc;         /* return code of Queue_Get */

                rc = Queue_Get(Queue, (LPBYTE)&ssp, sizeof(ssp));
                if (rc==STOPTHREAD || rc==ENDQUEUE)
                {
                        break;
                }
                else if (rc<0) {
                        dprintf1(("Send thread aborting.  Bad rc %d from Get_Queue.\n", rc));
                        if (Aborting) break;    /* All gone wrong. Just quit! */
                        Queue_Abort(Queue, NULL);
                        Aborting = TRUE;
                        continue; /* next Queue_Get destroys Queue */
                }

//      //      {       ULONG Sum;
//      //              if (ssp.lPacket==LPACKET) {
//      //                      if (ssp.ulSum != (Sum =ss_checksum_block(ssp.Data, ssp.ulSize))) {
//      //                              dprintf1(( "!!Checksum error at send.  Was %x should be %x\n"
//      //                                    , Sum, ssp.ulSum));
//      //                      }
//      //              }
//      //      }

#ifdef SOCKETS
                if(SOCKET_ERROR != send(OutPipe, (char far *)&ssp, ssp.ulSize+PACKHEADSIZE, 0) )

#else
                if (!ss_sendblock(OutPipe, (PSTR) &ssp, rc))
#endif /* SOCKETS */
                {
                        dprintf1(("Connection on pipe %x lost during send\n", OutPipe));
                        Queue_Abort(Queue, NULL);
                        Aborting = TRUE;
                        continue;  /* next Queue_Get destroys Queue */

                }
                ////dprintf1(( "Sent %x %x %x %x %x...\n"
                ////      , ssp.lVersion, ssp.lPacket, ssp.lSequence, ssp.ulSize, ssp.ulSum));
            } /* packets */
        }
        finally{
                /* kill the data pipe cleanly */
#ifndef SOCKETS
                FlushFileBuffers(OutPipe);
                DisconnectNamedPipe(OutPipe);
#endif /* NOT SOCKETS */
                CLOSEHANDLE(OutPipe);
                dprintf1(("Data send thread ending.\n"));
        }

        return 0;       /* exit thread */
} /* SendData */


/* This gets called once for every FILEDETAILS on the ReadInQueue
   to delete the temp files.
*/
STATIC void PurgePackedFiles(PSTR Ptr, int Len)
{       FILEDETAILS * pfd;

        pfd = (FILEDETAILS *)Ptr;
        // dprintf1(("purging file: %s\n", pfd->TempName));
        DeleteFile(pfd->TempName);

} /* PurgePackedFiles */

#if 0
/* produce a checksum of a block of data.
 *
 * This is undoubtedly a good checksum algorithm, but it's also compute bound.
 * For version 1 we turn it off.  If we decide in version 2 to turn it back
 * on again then we will use a faster algorithm (e.g. the one used to checksum
 * a whole file.
 *
 * Generate checksum by the formula
 *      checksum = SUM( rnd(i)*(1+byte[i]) )
 * where byte[i] is the i-th byte in the file, counting from 1
 *       rnd(x) is a pseudo-random number generated from the seed x.
 *
 * Adding 1 to byte ensures that all null bytes contribute, rather than
 * being ignored. Multiplying each such byte by a pseudo-random
 * function of its position ensures that "anagrams" of each other come
 * to different sums. The pseudorandom function chosen is successive
 * powers of 1664525 modulo 2**32. 1664525 is a magic number taken
 * from Donald Knuth's "The Art Of Computer Programming"
 */

ULONG
ss_checksum_block(PSTR block, int size)
{
        unsigned long lCheckSum = 0;            /* grows into the checksum */
        const unsigned long lSeed = 1664525;    /* seed for random Knuth */
        unsigned long lRand = 1;                /* seed**n */
        unsigned long lIndex = 1;               /* byte number in block */
        unsigned Byte;                          /* next byte to process in buffer */
        unsigned length;                        /* unsigned copy of size */

        length = size;
        for (Byte = 0; Byte < length ;++Byte, ++lIndex) {

                lRand = lRand*lSeed;
                lCheckSum += lIndex*(1+block[Byte])*lRand;
        }

        return(lCheckSum);
} /* ss_checksum_block */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\server\queue.h ===
/*
* A queue is (roughly speaking) a Monitor in the sense of Hoare's paper.
* It is an Object that includes synchronisation.
*
* It has the following methods:
* Create:  Create the queue and set it up ready for use.
* Destroy: Input to the queue is finished (it will deallocate itself later).
* Put:     Put an element on the queue (and release a Get thread)
* Get:     Take an element off the queue (but wait if queue was empty).
* Abort:   Everything on the queue, now or later is useless.  Shut down.
* GetInstanceData: Retrieve one DWORD which was set on Create.
* All the method names are prefixed with Queue_  e.g. Queue_Create.
*
* The Queue is designed to be filled by one (or more) thread(s) and emptied
* by other(s).  The queue itself creates the emptying threads.  The Create
* method specifies a procedure which will be used to empty it.
* Elements on the queue are strictly first-in first-out, but bear in
* mind that IF there are multiple emptying threads then although one thread
* may get its element before another in strict order, what happens next
* is not defined by the QUEUE mechanism.
*
* The QUEUE starts an emptying thread when
*       An element is put and the number of emptier threads started is fewer
*       than MaxEmptiers
* AND   the number of emptiers running is currently zero
*       OR  the queue has more than (MinQueueToStart elements times the number
*           of emptier threads already running)
*
* What this means is that the queue will start emptier threads as needed up
* to a limit of MaxEmptiers in such a way as to try to keep the queue down
* to no more than MinQueueToStart per running emptier thread.
*
* Emptier threads should stop themselves when they try to get an element but
* get the return code STOPTHREAD or ENDQUEUE.  These return codes are issued
* when
*       The queue is empty and there are already enough emptier threads waiting
* or    The queue is empty and has received a destroy request.
*
* If the thread receiving it is the last or only thread which has been started
* to empty this queue, it will get a ENDQUEUE return code, i.e. all the other
* emptying threads have already received a STOPTHREAD.  Otherwise it will
* just get STOPTHREAD.  The queue de-allocates itself when it returns ENDQUEUE.
* (No queue operation should be attempted after that).
* This happens when the queue has received a destroy request
* and the queue is empty and there are no emptier threads running (only
* occurs if there has never been a Put) or when the last emptier thread
* gets its ENDQUEUE.
*
* Queue_Create has an Event parameter. If this is not NULL then this event
* is Set when the queue is destroyed.  This Event is created by the calling
* process.  The caller must not Close it until the queue signals it.
*
* Information can be passed from the creator of the queue to the emptiers
* via the InstanceData parameter.  The value passed to Queue_Create can
* be retrieved by the emptiers by calling Queue_GetInstanceData.
*
* If the instance data is in fact a pointer, the queue is unaware of this
* and will never access or free the data pointed to.
*
* As well as controlling the emptier threads (starting more and more
* in response to a growing queue) we also need to control the filler,
* slowing it down if we are getting over-runs.  For instance if we
* have a broken output (say broken network connection) and a job which
* is sending 200MB of data, we don't want to have a 200MB queue build up!
*
* To fix this, we have an absolute limit on the size of the queue (yet
* another Create parameter).
*
* Error handling is tricky.  Errors which only affect individual elements
* should be handled by the Getters and Putters (e.g. by including in the
* data of an element a code which indicates that the item is in error).
* Errors which mean that the whole thing should be taken down can be handled
* as follows.  The QUEUE has a method Abort which works much as Destroy,
* but will purge the queue of any held elements first.
* As a QUEUE element may have storage chained off it which needs to be
* freed, there is a parameter on Abort which is the ABORTPROC.
* This is called once for each element on the queue to dispose of the element.
* The storage of the element itself is then freed.
* If the ABORTPROC is NULL then the storage of the element is just freed.
*
* If the queue were to be deallocated by the Getter then the next Put would
* trap, so the queue is left in existence, but the Putting threads
* get a FALSE return code when they try to Put after an Abort.  They should
* then do a Queue_Destroy (they may also want to Abort any queue they are
* themselves reading from). The Getting threads should meanwhile keep running.
* All except one will promptly get a STOPTHREAD.  The last one will block on
* the Get.  When the Destroy comes in, indicating that the Putting side has
* completely finished with the queue, the Get will be released with a final
* ENDQUEUE and the queue itself will be deallocated.
* Any attempt to use it after that will probably trap!
*
* Typical usage for a pipeline of queues where a thread is potentially one
* of several which are getting from one queue and putting to another is:
*
* for (; ; ){
*       len = Queue_Get(inqueue, data, maxlen);
*       if (len==STOPTHREAD){
*               tidy up;
*               ExitThread(0);
*       }
*       if (len=ENDQUEUE){
*               tidy up;
*               Queue_Destroy(outqueue);
*               ExitThread(0);
*       }
*       if (len<0) {
*               ASSERT you have a bug!
*       }
*
*       process(&data, &len);
*
*       if (!Queue_Put(outqueue, data, len)){
*               Queue_Abort(inqueue, InQueueAbortProc);
*       }
*
* }
*
*
* Note that there is a partial ordering in time of actions performed by the
* various parallel threads all running this loop which ensures that outqueue
* is handled properly, i.e. all the puts complete before the Destroy.
* This partial ordering is:
*
* Put_by_thread_A(outqueue)    Put_by_thread_B(outqueue)
*      |                             |
*      |                             |
*      v                             v
* Get_by_thread_A(inqueue)      Get_by_thread_A(inqueue)
*      |                             |
*      |                             |
*      v                             v
* STOPTHREAD_for_thread_A ----> ENDQUEUE_for_thread_B--> Queue_Destroy(outqueue)
*
* Which threads get the STOPTHREAD is indeterminate, but they all happen BEFORE
* the other thread gets the ENDQUEUE.
*
*/



/* Return codes from Queue_Get.  All non-successful return codes are <0 */

#define STOPTHREAD -1           /* Please tidy up and then ExitThread(0)
                                ** There is no queue element for you.
                                */
#define TOOLONG    -2           /* Your buffer was too short.  This was a no-op
                                ** the data is still on the queue.
                                */
#define ENDQUEUE   -3           /* This queue is now closing.  You are the last
                                ** thread active.  All the others (if any) have
                                ** had STOPTHREAD.
                                ** There is no queue element for you.
                                */
#define NEGTHREADS -4           /* Bug in queue.  Apparently negative number of
                                ** threads running!
                                */
#define SICKQUEUE  -5           /* Bug in queue.  Trying to get from an empty
                                ** queue.
                                */

typedef struct queue_tag * QUEUE;

typedef int (* EMPTYPROC)(QUEUE Queue);

/* Queue_Create:
** Return a queue handle for a newly created empty queue
** NULL returned means it failed.
*/
QUEUE Queue_Create( EMPTYPROC Emptier
                  , int MaxEmptiers
                  , int MinQueueToStart
                  , int MaxQueue
                  , HANDLE Event
                  , DWORD InstanceData
                  , PSZ Name            // of the queue
                  );


/* Queue_Put:
** Put an element from buffer Data of length Len bytes onto the queue.
** Will wait until the queue has room
** FALSE returned means the queue has been aborted and no
** put will ever succeed again.
** This operation may NOT be performed after a Queue_Destroy on Queue
*/
BOOL Queue_Put(QUEUE Queue, LPBYTE Data, UINT Len);


/* Queue_Get:
** Get an element from the queue.  (Waits until there is one)
** The element is copied into Data.  MaxLen is buffer length in bytes.
** Negative return codes imply no element is gotten.
** A negative return code is STOPTHREAD or ENDQUEUE or an error.
** On receiving STOPTHREAD or ENDQUEUE the caller should clean up and
** then ExitThread(0);
** If the caller is the last active thread getting from this queue, it
** will get ENDQUEUE rather than STOPTHREAD.
** Positive return code = length of data gotten in bytes.
*/
int Queue_Get(QUEUE Queue, LPBYTE Data, int MaxLen);


/* Queue_Destroy:
** Mark the queue as completed.  No further data may ever by Put on it.
** When the last element has been gotten, it will return ENDTHREAD to
** a Queue_Get and deallocate itself.  If it has an Event it will signal
** the event at that point.
** The Queue_Destroy operation returns promptly.  It does not wait for
** further Gets or for the deallocation.
*/
void Queue_Destroy(QUEUE Queue);

/* Queue_GetInstanceData:
** Retrieve the DWORD of instance data that was given on Create
*/
DWORD Queue_GetInstanceData(QUEUE Queue);

/* QUEUEABORTPROC:
*  Data points to the element to be aborted.  Len is its length in bytes.
*  See Queue_Abort.
*/
typedef void (* QUEUEABORTPROC)(LPSTR Data, int Len);

/* Queue_Abort:
** Abort the queue.  Normally called by the Getter.
** Discard all elements on the queue,
** If the queue has already been aborted this will be a no-op.
** It purges all the data elements.  If the Abort parameter is non-NULL
** then it is called for each element before deallocating it.  This
** allows storage which is hung off the element to be freed.
** After this, all Put operations will return FALSE.  If they were
** waiting they will promptly complete.  The queue is NOT deallocated.
** That only happens when the last Get completes after the queue has been
** Queue_Destroyed.  This means the normal sequence is:
**    Getter discovers that the queue is now pointless and does Queue_Abort
**    Getter does another Get (which blocks)
**    Putter gets FALSE return code on next (or any outstanding) Put
**    (Putter may want to propagates the error back to his source)
**    Putter does Queue_Destroy
**    The blocked Get is released and the queue is deallocated.
*/
void Queue_Abort(QUEUE Queue, QUEUEABORTPROC Abort);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\server\queue.c ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include "gutils.h"
#include "list.h"
#include "queue.h"

#define NAMELENGTH 20

typedef struct queue_tag{
        CRITICAL_SECTION CritSect;      /* to single-thread queue operations */
        HANDLE          Event;          /* Event to set when finished */
        HANDLE          Sem;            /* semaphore for Get to wait on */
        HANDLE          MaxSem;         /* semaphore for Put to wait on */
        int             Waiting;        /* num tasks waiting ~= -(Sem count) */
        LIST            List;           /* the queue itself */
        BOOL            Alive;          /* TRUE => no destroy request yet */
        BOOL            Aborted;        /* TRUE => the queue has been aborted */
        EMPTYPROC       Emptier;        /* the thread proc for emptying */
        int             MaxEmptiers;    /* max number of emptying threads */
        int             MinQueueToStart;/* start another emptier Q this long */
        int             MaxQueue;       /* absolute maximum size of queue
                                         * (for debug only)                  */
        int             Running;        /* number of emptiers in existence
                                         * Once an emptier is created this
                                         * stays positive until Queue_Destroy */
        DWORD           InstanceData;   /* instance data for emptier */
        char            Name[NAMELENGTH+1]; /* Name for the queue (for debug) */
} QUEUEDATA;

/* DOGMA:
   Any Wait must occur outside the critical section.

   Any update to the queue must occur inside the critical section.
   Any peeking from outside the critical section must be taken with salt.

   The queue has between 0 and MaxQueue elements on its list.  The Maximum
   is policed by MaxSem which is initialised to MaxQueue and Waited for by
   Put before adding an element and Released by Get whenever it takes an element
   off. MaxQueue itself is just kept around for debug purposes.

   Put must Wait before entering the critical section, therefore a failed Put
   (e.g. Put to an Aborted queue) will have already upset the semaphore and so
   must back it out.

   Abort clears the queue and so must adequately simulate the elements being
   gotten.  In fact it just does a single Release on MaxSem which ensures that
   a Put can complete.  Any blocked Puts will then succeed one at a time as
   each one backs out.

   Abort is primarily intended for use by the Getter.  Caling it before any
   element has ever been put is peculiar, but harmless.

   The minumum is policed by Sem which is initialised to 0, is Waited for by
   Get before getting an element and Released by Put whenever it puts one.
   Queue_Destroy neds to ensure that no thread will block on the Get but all
   threads will run into the empty queue and get STOPTHREAD or ENDQUEUE.  It
   therefore releases the semaphore as many times as there are threads running.

   Abort clears the queue and simulates the elements being gotten so that
   a single Get is left blocked waiting for the Destroy.  Whether there is a
   Get actually waiting at the moment is not interesting.  Even if there were
   not, one could be by the time the abort is done. There are the following
   cases (Not Alive means the Queue_Destroy is already in):
       Not empty  Alive      -> empty it, let all but 1 run.
       Not empty  Not Alive  -> empty it, let all run.
       Empty      Alive      ->           let all but 1 run.
       Empty      Not Alive  ->           let all run.
   Since Queue_Destroy has already released everything, the Not Alive cases
   need no further releasing.
*/


/* Queue_Create:
** Return a queue handle for a newly created empty queue
** NULL returned means it failed.
*/
QUEUE Queue_Create( EMPTYPROC Emptier           /* thread proc to start */
                  , int MaxEmptiers             /* max Getting threads */
                  , int MinQueueToStart         /* elements per thread */
                  , int MaxQueue                /* max elements on q */
                  , HANDLE Event                /* signal on deallocation */
                  , DWORD InstanceData
                  , PSZ Name
                  )
{       QUEUE Queue;

        Queue = (QUEUE)GlobalAlloc(GMEM_FIXED, sizeof(QUEUEDATA));
        if (Queue==NULL) {
                char msg[80];
                wsprintf(msg, "Could not allocate storage for queue %s", Name);
                /* Trace_Error(msg, FALSE); */
                return NULL;
        }
        InitializeCriticalSection(&Queue->CritSect);
        //??? should allow for failure!!!
        /* the value of about 10 million is chosen to be effectively infinite */
        Queue->Sem = CreateSemaphore(NULL, 0, 99999999, NULL);
        //??? should allow for failure!!!
        Queue->MaxSem = CreateSemaphore(NULL, MaxQueue, 99999999, NULL);
        //??? should allow for failure!!!
        Queue->Waiting = 0;
        Queue->List = List_Create();
        Queue->Alive = TRUE;
        Queue->Aborted = FALSE;
        Queue->Emptier = Emptier;
        Queue->MaxEmptiers = MaxEmptiers;
        Queue->MinQueueToStart = MinQueueToStart;
        Queue->MaxQueue = MaxQueue;
        Queue->Running = 0;
        Queue->Event = Event;
        Queue->InstanceData = InstanceData;
        strncpy(Queue->Name, Name, NAMELENGTH);
        Queue->Name[NAMELENGTH]='\0';   /* guardian */
        return Queue;
} /* Queue_Create */


/* Destroy:
** Internal procedure.
** Actually deallocate the queue and signal its event (if any)
** Must have already left the critical section
*/
static void Destroy(QUEUE Queue)
{
        //dprintf1(("Actual Destroy of queue '%s'\n", Queue->Name));
        DeleteCriticalSection(&(Queue->CritSect));
        CloseHandle(Queue->Sem);
        CloseHandle(Queue->MaxSem);
        List_Destroy(&(Queue->List));
        if (Queue->Event!=NULL) {
                SetEvent(Queue->Event);
        }
        GlobalFree( (HGLOBAL)Queue);
} /* Destroy */


/* Queue_Put:
** Put an element from buffer Data of length Len bytes onto the queue.
** Will wait until the queue has room
** FALSE returned means the queue has been aborted and no
** put will ever succeed again.
** This operation may NOT be performed after a Queue_Destroy on Queue
*/
BOOL Queue_Put(QUEUE Queue, LPBYTE Data, UINT Len)
{
        DWORD ThreadId;
        //dprintf1(("Put to queue '%s'\n", Queue->Name));
        WaitForSingleObject(Queue->MaxSem, INFINITE);
        EnterCriticalSection(&Queue->CritSect);
        //dprintf1(("Put running to queue '%s'\n", Queue->Name));
        if ((Queue->Aborted) || (!Queue->Alive)) {
                //dprintf1(("(legal) Queue_Put to Aborted queue '%s'\n", Queue->Name));
                LeaveCriticalSection(&Queue->CritSect);
                ReleaseSemaphore(Queue->MaxSem, 1, NULL); /* let next in */
                return FALSE;  /* Caller should soon please Queue_Destroy */
        }
        List_AddFirst(Queue->List, Data, Len);
        ReleaseSemaphore(Queue->Sem, 1, NULL);
        --Queue->Waiting;
        if (  Queue->Running < Queue->MaxEmptiers
           && (  Queue->Running<=0
              || List_Card(Queue->List) > Queue->MinQueueToStart*Queue->Running
              )
           ) {
                ++Queue->Running;
                LeaveCriticalSection(&Queue->CritSect);
                return ( (BOOL)CreateThread( NULL
                                           , 0
                                           , (LPTHREAD_START_ROUTINE)
                                                                Queue->Emptier
                                           , (LPVOID)Queue
                                           , 0
                                           , &ThreadId
                                           )
                       );
        }
        LeaveCriticalSection(&Queue->CritSect);
        return TRUE;
} /* Queue_Put */

/* Queue_Get:
** Get an element from the queue.  (Waits until there is one)
** The elemeent is copied into Data.  MaxLen is buffer length in bytes.
** Negative return codes imply no element is gotten.
** A negative return code is STOPTHREAD or ENDQUEUE or an error.
** On receiving STOPTHREAD or ENDQUEUE the caller should clean up and
** then ExitThread(0);
** If the caller is the last active thread getting from this queue, it
** will get ENDQUEUE rather than STOPTHREAD.
** Positive return code = length of data gotten in bytes.
*/
int Queue_Get(QUEUE Queue, LPBYTE Data, int MaxLen)
{       LPBYTE ListData;
        int Len;
        //dprintf1(("Get from queue '%s'\n", Queue->Name));
        EnterCriticalSection(&Queue->CritSect);
        //dprintf1(("Get running from queue '%s'\n", Queue->Name));
        if (List_IsEmpty(Queue->List)) {
                if (!Queue->Alive) {
                        --(Queue->Running);
                        if (Queue->Running<=0 ) {
                                if (Queue->Running<0 ) {
                                        char msg[80];
                                        wsprintf( msg
                                                , "Negative threads running on queue %s"
                                                , Queue->Name
                                                );
                                        // Trace_Error(msg, FALSE);
                                        // return NEGTHREADS; ???
                                }
                                LeaveCriticalSection(&Queue->CritSect);
                                Destroy(Queue);
                                return ENDQUEUE;
                        }
                        LeaveCriticalSection(&Queue->CritSect);
                        return STOPTHREAD;
                }
                if (Queue->Waiting>0) {
                        /* already another thread waiting, besides us */
                        --(Queue->Running);
                        LeaveCriticalSection(&(Queue->CritSect));
                        return STOPTHREAD;
                }
        }

        ++(Queue->Waiting);
        LeaveCriticalSection(&(Queue->CritSect));
        WaitForSingleObject(Queue->Sem, INFINITE);
        EnterCriticalSection(&(Queue->CritSect));

        /* If the queue is empty now it must be dead */
        if (List_IsEmpty(Queue->List)) {
                if (Queue->Alive && (!Queue->Aborted)) {
                        char msg[80];
                        wsprintf( msg
                                , "Queue %s empty but not dead during Get!"
                                , Queue->Name
                                );
                        // Trace_Error(msg, FALSE);
                        return SICKQUEUE;
                }
                else {
                        --(Queue->Running);
                        if (Queue->Running==0) {
                                LeaveCriticalSection(&(Queue->CritSect));
                                Destroy(Queue);
                                return ENDQUEUE;
                        }
                        LeaveCriticalSection(&(Queue->CritSect));
                        return STOPTHREAD;
                }
        }

        /* The queue is not empty and we are in the critical section. */
        ListData = List_Last(Queue->List);
        Len = List_ItemLength(ListData);
        if (Len>MaxLen) {
                ReleaseSemaphore(Queue->Sem, 1, NULL);
                --Queue->Waiting;
                LeaveCriticalSection(&Queue->CritSect);
                return TOOLONG;
        }
        memcpy(Data, ListData, Len);
        List_DeleteLast(Queue->List);
        LeaveCriticalSection(&Queue->CritSect);
        ReleaseSemaphore(Queue->MaxSem, 1, NULL);
        return Len;
} /* Queue_Get */


/* Queue_Destroy:
** Mark the queue as completed.  No further data may ever by Put on it.
** When the last element has been gotten, it will return ENDTHREAD to
** a Queue_Get and deallocate itself.  If it has an Event it will signal
** the event at that point.
** The Queue_Destroy operation returns promptly.  It does not wait for
** further Gets or for the deallocation.
*/
void Queue_Destroy(QUEUE Queue)
{
        EnterCriticalSection(&(Queue->CritSect));
        //dprintf1(("Queue_Destroy %s\n", Queue->Name));
        Queue->Alive = FALSE;
        if (  List_IsEmpty(Queue->List)) {
                if (Queue->Running==0) {
                        /* Only possible if nobody ever got started */
                        LeaveCriticalSection(&(Queue->CritSect));
                        Destroy(Queue);
                        return;
                }
                else {  int i;
                        /* The list is empty, but some threads could be
                           blocked on the Get (or about to block) so
                           release every thread that might ever wait on Get */
                        for (i=0; i<Queue->Running; ++i) {
                                ReleaseSemaphore(Queue->Sem, 1, NULL);
                                --(Queue->Waiting);
                        }
                        LeaveCriticalSection(&(Queue->CritSect));
                }
        }
        else LeaveCriticalSection(&(Queue->CritSect));
        return;
} /* Queue_Destroy */

/* Queue_GetInstanceData:
** Retrieve the DWORD of instance data that was given on Create
*/
DWORD Queue_GetInstanceData(QUEUE Queue)
{       return Queue->InstanceData;
} /* Queue_GetInstanceData */

/* Queue_Abort:
** Abort the queue.  Normally called by the Getter.
** Discard all elements on the queue,
** If the queue has already been aborted this will be a no-op.
** It purges all the data elements.  If the Abort parameter is non-NULL
** then it is called for each element before deallocating it.  This
** allows storage which is hung off the element to be freed.
** After this, all Put operations will return FALSE.  If they were
** waiting they will promptly complete.  The queue is NOT deallocated.
** That only happens when the last Get completes after the queue has been
** Queue_Destroyed.  This means the normal sequence is:
**    Getter discovers that the queue is now pointless and does Queue_Abort
**    Getter does another Get (which blocks)
**    Putter gets FALSE return code on next (or any outstanding) Put
**    (Putter may want to propagates the error back to his source)
**    Putter does Queue_Destroy
**    The blocked Get is released and the queue is deallocated.
*/

void Queue_Abort(QUEUE Queue, QUEUEABORTPROC Abort)
{
        /* This is similar to Destroy, but we call the Abort proc and
           free the storage of the elements.  Destroy allows them to run down.

           It is essential that the last Get must block until the sender does a
           Queue_Destroy (if it has not been done already).   The Alive flag
           tells whether the Queue_Destroy has been done.  All Getters except
           the last should be released.
        */
        //dprintf1(("Queue_Abort '%s'\n", Queue->Name));
        EnterCriticalSection(&(Queue->CritSect));
        //dprintf1(("Queue_Abort running for queue '%s'\n", Queue->Name));
        for (; ; ) {
                LPSTR Cursor = List_First(Queue->List);
                int Len;
                if (Cursor==NULL) break;
                Len = List_ItemLength(Cursor);
                if (Abort!=NULL) {
                        Abort(Cursor, Len);
                }
                List_DeleteFirst(Queue->List);
        }
        /* Queue is now empty.  Do not destroy.  That's for the Putters */
        Queue->Aborted = TRUE;

        /* make sure the next Queue_Get blocks unless Queue_Destroy already done */
        //dprintf1(("Queue_Abort '%s' fixing semaphore to block\n", Queue->Name));
        if (Queue->Alive){
                while(Queue->Waiting<0) {
                        WaitForSingleObject(Queue->Sem, INFINITE);
                        ++(Queue->Waiting);
                }
        }
        //dprintf1(("Queue_Abort '%s' semaphore now set to block\n", Queue->Name));

        LeaveCriticalSection(&(Queue->CritSect));
        ReleaseSemaphore(Queue->MaxSem, 1, NULL);
        return;
} /* Queue_Abort */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\server\scan.c ===
/*
 * remote checksum server
 *
 * scan.c       file scanning and checksum module
 *
 * server creates a named pipe and waits for connections. a client connects,
 * and sends request packets to the server. One such request packet is
 * the SSREQ_SCAN request: we are given a pathname, and we are to checksum
 * every file below that point in the directory tree. We pass each
 * filename and checksum back individually in a separate response packet,
 * and finally a response packet saying that there are no more files.
 *
 * We sort everything into case-insensitive alphabetic order. In a given
 * directory, we pass out a sorted list of the files before we process
 * the subdirectories.
 *
 * Geraint, July 92
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <gutils.h>
#include "sumserve.h"
#include "errlog.h"
#include "server.h"

/* module-internal type defns ---------------------------------------------*/

/* sorted list of file names in current dir is in a chained list of these */

typedef struct fnamelist {
        char szFile[MAX_PATH];
        struct fnamelist * next;
} FNAMELIST;    /* and PFNAMELIST already declared in server.h */


/* forward declaration of functions ---------------------------------------*/
PFNAMELIST ss_addtolist(PFNAMELIST head, PSTR name);
BOOL ss_processfile(HANDLE hpipe, long lVersion, LPSTR pAbsName, LPSTR pRelName
                  , BOOL bChecksum);
BOOL ss_processdir( HANDLE hpipe, long lVersion, LPSTR pAbsName, LPSTR pRelName
                  , BOOL bChecksum, BOOL fDeep);


/*--- externally called functions ----------------------------------------*/


/* ss_scan
 *
 * called from ss_handleclient on receipt of a SCAN request. scan the
 * directory passed in, and pass the files found back to the named pipe
 * one at a time. filenames returned should be relative to the
 * starting point (pRoot) and not absolute.
 *
 * returns TRUE if all ok; FALSE if an error occured and the connection
 * is lost.
 */
BOOL
ss_scan(HANDLE hpipe, LPSTR pRoot, LONG lVersion, BOOL bChecksum, BOOL fDeep)
{
        DWORD dwAttrib;
        LPSTR file;
        char buffer[MAX_PATH];

        /* check whether this is a directory or a file */
        dwAttrib = GetFileAttributes(pRoot);
        if (dwAttrib == -1) {
                /* file does not exist or is not visible */
                if (GetLastError() == ERROR_INVALID_PASSWORD) {
                        dprintf1(("password error\n"));
			Log_Write(hlogErrors, "password error on %s", pRoot);
                        if (!ss_sendnewresp( hpipe, lVersion, SSRESP_BADPASS
                                           , 0,  0, 0, 0, NULL)) {
                                return(FALSE);
                        }
                } else {
                        dprintf1(("file access error %d\n", GetLastError()));
			Log_Write(hlogErrors, "file error %d for %s", GetLastError(), pRoot);
                        if (!ss_sendnewresp( hpipe, lVersion, SSRESP_ERROR
                                           , GetLastError(), 0, 0, 0, pRoot)) {
                                return(FALSE);
                        }
                        if (!ss_sendnewresp( hpipe, lVersion, SSRESP_END
                                           , 0, 0, 0, 0, NULL)) {
                                return(FALSE);
                        }
                }
                return TRUE;
        }

        if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) {

                /* it is a directory - read all entries and
                 * then process the entries */


                /*
                 * create a "." directory and scan that
                 */
                if (!ss_sendnewresp( hpipe, lVersion, SSRESP_DIR
                                   , 0 , 0, 0, 0, ".")) {
                        return(FALSE);
                }

                if (!ss_processdir(hpipe, lVersion, pRoot, ".", bChecksum, fDeep) ) {
                        return(FALSE);
                }

        } else {
                /* pRoot is a file. we should just return the
                 * checksum and name, and then end.
                 *
                 * note that we should send a filename relative
                 * to pRoot for this file. Since pRoot is this file,
                 * it is not clear what we should send as the file name.
                 * in this case we split off the last component of the
                 * file name and return that
                 */
                if ( (file = strrchr(pRoot, '\\')) == NULL) {
                        /* there are no slashes in pRoot - so
                         * there is only one component: use that
                         */
                        file = pRoot;
                } else {
                        /* we found a / - skip it so we point at the
                         * final elem
                         */
                        file++;
                }
                /*
                 * make a copy of the filename, prepended with .\ so that
                 * it matches the normal format
                 */
                lstrcpy(buffer, ".\\");
                lstrcat(buffer, file);

                if (!ss_processfile(hpipe, lVersion, pRoot, buffer, bChecksum) ) {
                        return(FALSE);
                }

        }

        return(ss_sendnewresp( hpipe, lVersion, SSRESP_END
                             , 0, 0, 0, 0, NULL));
} /* ss_scan */



/* module-internal functions --------------------------------------------*/

/* read all entries in a directory, and create a sorted list of files
 * in that directory, and a sorted list of subdirs.
 *
 * for each file found, call ss_process_file to checksum and report on
 * the file.
 * for each subdir, report the name of the new dir and then
 * recursively call this function to scan it.
 *
 * We have two names for the dir- the absolute name (which we use to
 * scan it) and the name relative to the pRoot starting point - which
 * pass on to the client
 *
 * return TRUE if all ok, or FALSE if the connection has been lost
 */
BOOL
ss_processdir(  HANDLE hpipe,
                long lVersion,
                LPSTR pAbsName,         /* absolute name of dir (to open) */
                LPSTR pRelName,         /* relative name of dir (to report) */
                BOOL bChecksum,         /* TRUE iff checksums are wanted */
                BOOL fDeep              /* TRUE iff subdirs to be included */
                )
{
        PFNAMELIST pfiles = NULL;
        PFNAMELIST pdirs = NULL;
        PFNAMELIST pnext;
        HANDLE hFind;
        WIN32_FIND_DATA finddata;
        BOOL bMore;
        char szNewAbs[MAX_PATH], szNewRel[MAX_PATH];

        /* initiate a search of the directory - append
         * *.* to the directory name
         */
        lstrcpy(szNewAbs, pAbsName);
        lstrcat(szNewAbs, "\\*.*");

        hFind = FindFirstFile(szNewAbs, &finddata);

        if (hFind == INVALID_HANDLE_VALUE) {
                bMore = FALSE;
        } else {
                bMore = TRUE;
        }

        /* loop reading all entries in the directory */
        while (bMore) {

                /* was it a directory or a file ? */
                if (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                        /* ignore . and .. */
                        if ((strcmp(finddata.cFileName, ".") != 0)  &&
                           (strcmp(finddata.cFileName, "..") != 0)) {

                                /* insert in sorted list of dir names */
                                pdirs = ss_addtolist(pdirs, finddata.cFileName);
                        }

                } else {
                        /* insert in sorted list of file names */
                        pfiles = ss_addtolist(pfiles, finddata.cFileName);
                }

                /* get next entry in directory if there are any */
                bMore = FindNextFile(hFind, &finddata);
        }
        FindClose(hFind);

        /* we have now built the sorted lists.
         * go through the file list first and process each entry */
        for (pnext = pfiles; pnext != NULL; ) {

                /* build a new abs and relative name for this file */
                lstrcpy(szNewAbs, pAbsName);
                lstrcat(szNewAbs, "\\");
                lstrcat(szNewAbs, pnext->szFile);

                lstrcpy(szNewRel, pRelName);
                lstrcat(szNewRel, "\\");
                lstrcat(szNewRel, pnext->szFile);

                /* checksum the file and send response */
                if (!ss_processfile(hpipe, lVersion, szNewAbs, szNewRel, bChecksum)) {
                        return(FALSE);
                }

                /* free up the list entry */
                pfiles = pnext->next;
                LocalUnlock(LocalHandle( (PSTR) pnext));
                LocalFree(LocalHandle( (PSTR) pnext));
                pnext = pfiles;
        }
        if (!fDeep) return TRUE;

        /* loop through the subdirs and recursively scan those */
        for (pnext = pdirs; pnext != NULL; ) {

                /* build a new abs and relative name for this dir */
                lstrcpy(szNewAbs, pAbsName);
                lstrcat(szNewAbs, "\\");
                lstrcat(szNewAbs, pnext->szFile);

                lstrcpy(szNewRel, pRelName);
                lstrcat(szNewRel, "\\");
                lstrcat(szNewRel, pnext->szFile);

                /* send the name of the new dir to the client */
                if (!ss_sendnewresp( hpipe, lVersion, SSRESP_DIR
                                   , 0, 0, 0, 0, szNewRel)) {
                        return(FALSE);
                }

                if (!ss_processdir(hpipe, lVersion, szNewAbs, szNewRel, bChecksum, TRUE) ) {
                        return(FALSE);
                }

                /* free up the list entry */
                pdirs = pnext->next;
                LocalUnlock(LocalHandle( (PSTR) pnext));
                LocalFree(LocalHandle( (PSTR) pnext));
                pnext = pdirs;
        }
        return(TRUE);
} /* ss_processdir */


/* checksum a file and send the response to the client.
 *
 * return FALSE if the connection failed, TRUE otherwise
 */
BOOL
ss_processfile( HANDLE hpipe,
                long lVersion,
                LPSTR pAbsName,         /* absolute name of file (to open) */
                LPSTR pRelName,         /* relative name (to report) */
                BOOL bChecksum
                )
{
        HANDLE hfile;           /* file handle from CreateFile() */
        DWORD sum, size;
        FILETIME ft;

        hfile = CreateFile(pAbsName, GENERIC_READ, FILE_SHARE_READ,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
        if (hfile == INVALID_HANDLE_VALUE) {
                /* We can't read the file, but we can still probably report some
                   properties because FindFirst / FindNext must have found it
                */

                WIN32_FIND_DATA finddata;
                HANDLE hFind;


                hFind = FindFirstFile(pAbsName, &finddata);
                if (hFind!=INVALID_HANDLE_VALUE){
                    FindClose(hFind);
		    Log_Write(hlogErrors, "Cannot read file %s", pAbsName);
                    /* report that we could not read the file */
                    return(ss_sendnewresp( hpipe, lVersion, SSRESP_CANTOPEN
                                         , finddata.nFileSizeLow, 0
                                         , finddata.ftLastWriteTime.dwLowDateTime
                                         , finddata.ftLastWriteTime.dwHighDateTime
                                         , pRelName));
                } else {
                    /* report that this file is cracked */
		    Log_Write(hlogErrors, "Cannot find file %s", pAbsName);
                    return(ss_sendnewresp( hpipe, lVersion, SSRESP_ERROR
                                         , GetLastError(), 0, 0, 0, pRelName));

                }

        } else {
                size = GetFileSize(hfile, NULL);
                if (!GetFileTime(hfile, NULL, NULL, &ft)) {
                        ft.dwLowDateTime = 0;
                        ft.dwHighDateTime = 0;
                }

                CloseHandle(hfile);
                if (bChecksum) {
                        LONG err;
                        sum = checksum_file(pAbsName, &err);
                        if (err!=0) {
                                return(ss_sendnewresp( hpipe, lVersion, SSRESP_ERROR
                                                      , GetLastError(),  0, 0, 0, pRelName));
                        }
                }
                else sum = 0;           /* no checksum wanted */

                return (ss_sendnewresp( hpipe, lVersion, SSRESP_FILE
                                      , size, sum
                                      , ft.dwLowDateTime, ft.dwHighDateTime
                                      , pRelName));
        }
}/* ss_processfile */

/* add a file or directory into a sorted single-linked list. alloc memory for
 * the new element from LocalAlloc
 *
 * we sort using utils_CompPath for a case-insensitive canonical sort,
 * but to match what goes on in the client world, we actually lower-case
 * everything first!
 *
 * return the new head of the list;
 */
PFNAMELIST
ss_addtolist(PFNAMELIST head, PSTR name)
{
        PFNAMELIST pnew, prev, pnext;

        /* alloc and fill a new entry */
        pnew = LocalLock(LocalAlloc(LHND, sizeof (FNAMELIST)));
        lstrcpy(pnew->szFile, name);

        /* always lower-case the names, or the comparison (utils_comppath)
         * will fail. even if we don't do the compare this time, this name
         * will be what we are compared against next time round...
         */
        AnsiLowerBuff(pnew->szFile, strlen(pnew->szFile));

        /* is the list empty ? */
        if (head == NULL) {
                /* yes, so return new head */
                return(pnew);
        }

        /* find place in list */
        prev = NULL;
        pnext = head;
        while ((pnext) && (utils_CompPath(pnext->szFile, pnew->szFile) <= 0)) {
                prev = pnext;
                pnext = pnext->next;
        }

        /* place found: we come between *prev and *pnext */
        pnew->next = pnext;
        if (prev == NULL) {
                /* we are new head of list */
                return(pnew);

        } else {
                prev->next = pnew;

                /* head of list still the same */
                return(head);
        }
}

/* UNC handling
 *
 * client can pass us a SSREQ_UNC: this contains both a password and a server
 * name (in the form \\server\share). We make a connection to it here and
 * remember the connection so that we can remove it (in ss_cleanconnections)
 * when the client session terminates.
 *
 * We are passed the head of a FNAMELIST in which we should store the connect
 * name for later cleanup. We return the new head of this list.
 *
 * the client will send this request if a unc-style named scan fails
 * with the SSRESP_BADPASS error.
 */
PFNAMELIST
ss_handleUNC( HANDLE hpipe, long lVersion
            , LPSTR password, LPSTR server, PFNAMELIST connects)
{
        NETRESOURCE resource;
        int errorcode;

        resource.lpRemoteName = server;
        resource.lpLocalName = NULL;
        resource.dwType = RESOURCETYPE_DISK;
        resource.lpProvider = NULL;

        errorcode = (int)WNetAddConnection2(&resource, password, NULL, 0);
        if (errorcode == NO_ERROR) {

                /* remember the connection name */
                connects = ss_addtolist(connects, server);

                /* report success */
                ss_sendnewresp( hpipe, lVersion, SSRESP_END
                              , 0, 0, 0, 0, NULL);
        } else {
    		Log_Write(hlogErrors, "Connect error %d for server %s", GetLastError(), server);
                dprintf1(("connect error %d for server %s\n", GetLastError(), server));
                /* report error */
                ss_sendnewresp( hpipe, lVersion, SSRESP_ERROR
                              , 0, 0, 0, 0, NULL);
        }
        return(connects);
} /* ss_handleUNC */

/* disconnect from all the sessions that this client asked us to make */
void
ss_cleanconnections(PFNAMELIST connects)
{
        PFNAMELIST server, next;

        for (server = connects; server != NULL; ) {

                WNetCancelConnection2(server->szFile, 0, 0);

                /* free block of memory */
                next = server->next;
                LocalUnlock(LocalHandle( (PSTR) server));
                LocalFree(LocalHandle( (PSTR) server));
                server = next;
        }
        connects = NULL;
} /* ss_cleanconnections */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\server\service.c ===
/*
 * Service.c
 *
 *
 * Service control interface to sumserve
 *
 * Geraint Davies, July 93
 */

#include <windows.h>
#include <sumserve.h>	// public header for sumserve
#include "errlog.h"
#include <server.h>	// private header for sumserve


/*
 * this is the function (in some other module) that actually
 * does all the work (probably used to be main or WinMain until
 * we added all the service-control stuff in this file).
 */
extern VOID MainLoop(DWORD dwArgc, LPTSTR *lpszArgv);





// service status handle - used in SetServiceStatus calls.
SERVICE_STATUS_HANDLE sshSumserve;

//signaled when service completed
HANDLE hServiceDoneEvent;

SERVICE_STATUS gssStatus;


/* structure to pass more than one parameter to the worker thread. */
typedef struct _threadinitparams {
    DWORD dwArgc;
    LPTSTR *lpszArgv;
} threadinitparams, * pthreadinitparams;


/*
 * MainLoopCaller
 *
 * This function is called on the worker thread created to do all the
 * real work. It calls the main loop function for the service, and
 * when that exits, signals the completion event to tell the
 * SS_Main thread that it is time to exit the process.
 */
DWORD
MainLoopCaller(LPVOID lpgeneric)
{
    pthreadinitparams pta;

    pta = (pthreadinitparams) lpgeneric;

    dprintf1(("calling main loop"));

    MainLoop(pta->dwArgc, pta->lpszArgv);

    SetEvent(hServiceDoneEvent);

    return(0);
}

/*
 * handler function called to perform start/stop
 * requests.
 */
VOID
SS_ServiceHandler(DWORD dwCtrlCode)
{

    switch(dwCtrlCode) {

    case SERVICE_CONTROL_STOP:

	gssStatus.dwCurrentState = SERVICE_STOP_PENDING;
	gssStatus.dwControlsAccepted = 0;
	gssStatus.dwCheckPoint = 1;
	gssStatus.dwWaitHint = 3000;

        SetServiceStatus(sshSumserve, &gssStatus);
	SetEvent(hServiceDoneEvent);
	break;

    default:
	/*
	 * we must always update the service status every time we are
	 * called.
	 */
        SetServiceStatus(sshSumserve, &gssStatus);
	break;

    }

}



/*
 * service main function - called by service controller
 * during StartServiceCtlDispatcher processing.
 *
 * Register our handler function, and initialise the service.
 * create a thread to do the work, and then wait for someone to
 * signal time to end. When this function exits, the call to
 * StartServiceCtlDispatcher will return, and the process will exit
 *
 * The args are passed from the program that called start service, and
 * are parameters that are passed to the main loop of the program.
 */
VOID
SS_Main(DWORD dwArgc, LPTSTR *lpszArgv)
{
    threadinitparams ta;
    HANDLE thread;
    DWORD threadid;

    dprintf1(("in ss_main"));


    sshSumserve = RegisterServiceCtrlHandler(
		    TEXT("SumServe"),
		    (LPHANDLER_FUNCTION) SS_ServiceHandler);

    gssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    gssStatus.dwServiceSpecificExitCode = 0;

    gssStatus.dwCurrentState = SERVICE_START_PENDING;
    gssStatus.dwControlsAccepted = 0;
    gssStatus.dwWin32ExitCode = NO_ERROR;
    gssStatus.dwCheckPoint = 1;
    gssStatus.dwWaitHint = 3000;
    SetServiceStatus(sshSumserve, &gssStatus);


    hServiceDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    gssStatus.dwCheckPoint = 2;
    SetServiceStatus(sshSumserve, &gssStatus);



    // create a thread to do all the real work

    // init args
    ta.dwArgc = dwArgc;
    ta.lpszArgv = lpszArgv;

    thread = CreateThread(
		NULL,
		0,
		(LPTHREAD_START_ROUTINE) MainLoopCaller,
		(LPVOID)&ta,
		0,
		&threadid);

    if (thread != NULL) {

	CloseHandle(thread);


        gssStatus.dwCurrentState = SERVICE_RUNNING;
        gssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

        gssStatus.dwCheckPoint = 0;
        gssStatus.dwWaitHint = 0;
        SetServiceStatus(sshSumserve, &gssStatus);


        WaitForSingleObject(hServiceDoneEvent, INFINITE);
    }

    CloseHandle(hServiceDoneEvent);

    gssStatus.dwCurrentState = SERVICE_STOPPED;
    gssStatus.dwControlsAccepted = 0;
    SetServiceStatus(sshSumserve, &gssStatus);

}



/*
 * main entry point.
 *
 * for a service, we need to call the service manager telling it our
 * main init function. It will then do everything. When the service
 * manager returns, it's time to exit.
 */
int WINAPI
WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdParam,
                int nCmdShow)
{
   SERVICE_TABLE_ENTRY steDispatch[] = {

       { TEXT("SumServe"), (LPSERVICE_MAIN_FUNCTION) SS_Main },

       //end of table marker
       { NULL, NULL }
    };


    dprintf1(("in winmain"));

    StartServiceCtrlDispatcher(steDispatch);


    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\server\sumserve.h ===
/*
 * remote filename and checksum server
 *
 * sumserve.h           packet definitions
 *
 * client attaches to the named pipe \\servername\pipe\NPNAME,
 * and sends one of the request packets below. He then
 * waits for one or more of the reply packets.
 *
 * when he gets a reply packet indicating the end of the reply,
 * he either sends another request, or closes his named pipe handle.
 *
 */

/* Versions...
 * The server must always be at a version at least as great as a client.
 * New versions of the server will handle old clients (at least for a bit?)
 * The client specifies a version number when it connects.  (The original
 * version with no number is version 0).  The server will then respond
 * with structures and protocols for that version.  The version number is
 * included in the response packets to allow me to change this scheme,
 * should it ever be necessary.
 * New version requests can be distinguished from version 0 requests by
 * having NEGATIVE request codes.
 */

/* name of named pipe */
#define NPNAME          "sumserve"

#define SS_VERSION      1       /* latest version number */

/* request packets ---------------------------------- */

typedef struct {
        long lCode;             /* request code (below) */
        char szPath[MAX_PATH];  /* null terminated pathname string */
} SSREQUEST, * PSSREQUEST;

/* If the requst comes in with a NEGATIVE lCode then it means use this
 * structure instead.  This has a version number and so future structures
 * can all be told apart by that.
 */
typedef struct {
        long lCode;             /* request code (below) */
        long lRequest;          /* should be LREQUEST */
        long lVersion;          /* version number */
        DWORD lFlags;           /* options - INCLUDESUBS is only one so far */
        char szPath[MAX_PATH];  /* null terminated pathname string */
        char szLocal[MAX_PATH]; /* for a FILES request, the local name is
                                   appended directly after the terminating
                                   NULL of szPath.  This field ensures
                                   enough space is allocated */
} SSNEWREQ, * PSSNEWREQ;

#define INCLUDESUBS 0x01

#define LREQUEST 33333333

/* values for lCode*/

/* server should exit. no args. will receive no response */
#define SSREQ_EXIT      32895   /* chosen to be an unusual number so that
                                   we will NOT get one of these by mistake.
                                   New version server will fail to respond to
                                   version 0 EXIT requests.  Big deal!
                                */


/* arg is a pathname: please send all files with checksums.
 * will receive either SSRESP_BADPASS or a mixture of 0 or more SSRESP_FILE and
 * SSRESP_ERROR responses, terminated by SSRESP_END.
 */
#define SSREQ_SCAN      2       /* please return list of dirs. arg:path */

/* end of this client's session. no args. will receive no response */
#define SSREQ_END       3       /* end of session - I have no more requests */

/* szPath buffer contains two null-term. strings. first is the password,
 * second is the \\server\share name. please make a connection to this
 * server for the rest of my session.
 * one reply: either SSRESP_ERROR or SSRESP_END
 */
#define SSREQ_UNC       4       /* connect to UNC name passed. szPath contains
                                 * two null-terminated strings; first is
                                 * the password, second is \\server\share
                                 *
                                 * share will be disconnected at end of client
                                 * session.
                                 */

/*
 * please send a file. szPath is the name of the file. response
 * will be a sequence of ssPacket structs, continuing until lSequence is < 1
 * or ulSize is 0
 */
#define SSREQ_FILE      5

/*
 * please send a set of files,  First request does NOT have a file.
 * a series of following NEXTFILE requests do name the files.
 * The NEXTFILE requests expect no response.  After the last
 * files request will come an SSREQ_ENDFILES.
 */
#define SSREQ_FILES     6
#define SSREQ_NEXTFILE  7
#define SSREQ_ENDFILES  8

/* arg is a pathname: please send all files with times, sizes but NO checksums.
 * will receive either SSRESP_BADPASS or a mixture of 0 or more SSRESP_FILE and
 * SSRESP_ERROR responses, terminated by SSRESP_END.
 */
#define SSREQ_QUICKSCAN 9       /* please return list of dirs. arg:path */


/*
 * please send the error log buffer (in one packet)
 */
#define SSREQ_ERRORLOG	10

/*
 * please send the activity log buffer in one packet
 */
#define SSREQ_EVENTLOG	11

/*
 * please send the current connections log in one packet
 */
#define SSREQ_CONNECTS	12


/* response packets ---------------------------------- */

typedef struct {
        long lCode;             /* response code */
        ULONG ulSize;           /* file size */
        ULONG ulSum;            /* checksum for file */
        char szFile[MAX_PATH];  /* null-term. filename relative to orig req. */
} SSRESPONSE, * PSSRESPONSE;

/* for version 1 and later */
typedef struct {                /* files.c knows this is
                                   RESPHEADSIZE+strlen(szFile)+1
                                   + strlen(szLocal)+1 bytes long */
        long lVersion;          /* protocol version (it will be >=1) */
        long lResponse;         /* 22222222 decimal means This is a Response */
        long lCode;             /* response code */
        ULONG ulSize;           /* file size  (Win32 error code for SSRESP_ERROR) */
        DWORD fileattribs;
        FILETIME ft_create;
        FILETIME ft_lastaccess;
        FILETIME ft_lastwrite;
        ULONG ulSum;            /* checksum for file */
        BOOL bSumValid;         /* TRUE iff there was a checksum for file */
        char szFile[MAX_PATH];  /* null-term. filename/pipename
                                   relative to orig req. */
        char szLocal[MAX_PATH]; /* client file name - but the data is actually
                                   concatenated straight on the end of szFile
                                   after the terminating NULL */
} SSNEWRESP, * PSSNEWRESP;

#define RESPHEADSIZE (3*sizeof(long)+2*sizeof(ULONG)+3*sizeof(FILETIME)+sizeof(DWORD)+sizeof(BOOL))

#define LRESPONSE 22222222

/* response codes for lCode */

#define SSRESP_FILE     1        /* file passed: lSum and szFile are valid
                                    This is followed by a series of data Packets
                                    which are the compressed file.
                                 */
#define SSRESP_DIR      2        /* dir passed: szFile ok, lSum not valid */
#define SSRESP_PIPENAME  3       /* files requested.  Here is the pipe name */
#define SSRESP_END      0        /* no more files: lSum and szFile are empty*/
#define SSRESP_ERROR    -1       /* file/dir cannot be read: szFile is valid */
#define SSRESP_BADPASS  -2       /* bad password error (on UNC name) */
#define SSRESP_BADVERS  -3       /* down level server                */
#define SSRESP_CANTOPEN -4       /* Can't open file
                                    In reply to a scan, szFile, date/time and size are valid
                                 */
#define SSRESP_NOATTRIBS -5      /* Can't get file attributes        */
#define SSRESP_NOCOMPRESS -6     /* Can't compress the file (obsolete) */
#define SSRESP_NOREADCOMP -7     /* Can't read the compressed file
                                    Uncompressed file follows as data packets
                                 */
#define SSRESP_NOTEMPPATH -8     /* Can't create a temp path
                                    Uncompressed file follows as data packets
                                 */
#define SSRESP_COMPRESSEXCEPT -9 /* Exception from Compress
                                    Uncompressed file follows as data packets
                                 */
#define SSRESP_NOREAD -10        /* Couldn't read uncompressed file (either)
                                    No file follows.
                                 */
#define SSRESP_COMPRESSFAIL -11  /* COMPRESS reported failure
                                    Uncompressed file follows as data packets
                                 */


#define PACKDATALENGTH 8192
/*
 * response block for FILE request.
 */
typedef struct {
        long lSequence ;        /* packet sequence nr, or -1 if error and end*/
        ULONG ulSize;           /* length of data in this block */
        ULONG ulSum;            /* checksum for this block */
        char Data[PACKDATALENGTH];      /* send in blocks of 8k */
} SSPACKET, * PSSPACKET;

/*
 * response block for FILE request.
 */
typedef struct {                /* files.c knows this starts "long lSequence" */
                                /* and is PACKHEADSIZE+ulSize in length really*/
        long lVersion;          /* server/protocol version number */
        long lPacket;           /* 11111111 decimal means This is a Packet */
        long lSequence ;        /* packet sequence nr, or -1 if error and end*/
        ULONG ulSize;           /* length of data in this block */
        ULONG ulSum;            /* checksum for this block */
        char Data[PACKDATALENGTH];      /* send in blocks of 8k */
} SSNEWPACK, * PSSNEWPACK;

/* size of SSNEWPACK header */
#define PACKHEADSIZE (3*sizeof(long)+2*sizeof(ULONG))

#define LPACKET 11111111
/*
 * in response to a FILE request, we send SSPACKET responses until there
 * is no more data. The final block will have ulSize == 0 to indicate that
 * there is no more data. The Data[] field of this block will then be
 * a SSATTRIBS containing the file attributes and file times.
 */
typedef struct {
        DWORD fileattribs;
        FILETIME ft_create;
        FILETIME ft_lastaccess;
        FILETIME ft_lastwrite;
} SSATTRIBS, * PSSATTRIBS;




/*
 * in response to errorlog, eventlog and connections requests, we send one
 * of these structures.
 *
 * The Data section consists of a FILETIME (64-bit UTC event time), followed
 * by a null-terminated ansi string, for each event logged.
 *
 */
struct corelog {
    DWORD lcode;	/* packet checkcode - should be LRESPONSE */	
    BOOL bWrapped;	/* log overrun - earlier data lost */
    DWORD dwRevCount;	/* revision count of log */
    DWORD length;	/* length of data in log */
    BYTE Data[PACKDATALENGTH];
};









#ifdef trace
/* add msg to the trace file */
void APIENTRY Trace_File(LPSTR msg);
#endif  //trace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\server\sumserve.c ===
/*

 * remote checksum server
 *
 * sumserve.c           main module
 *
 * program to supply lists of files and checksums from a remote server.
 * This program runs remotely, and is queried over a named pipe: a client
 * connects to us, and gives us a pathname. We then send him one at a time,
 * the names of all the files in the file tree starting at that path, together
 * with a checksum for the files.
 * Useful for comparing file trees that are separated by a slow link.
 *
 * outline:
 *      this module:    named pipe creation and connects - main loop
 *
 * 	service.c	service control manager interface (start/stop)
 *
 *      scan.c:         service code that scans and checksums
 *
 *
 * Geraint Davies, july 92
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "sumserve.h"
#include "errlog.h"
#include "server.h"

#include "list.h"


BOOL bNoCompression = FALSE;
BOOL bTracing = FALSE;


/*
 * error and activity log
 */
HLOG hlogErrors;
HLOG hlogEvents;


/*
 * we keep one of these on the listConnections for each current
 * connection. It is created by a call to ss_logon, and should be
 * removed by a call to ss_logoff when the connection terminates.
 */
typedef struct _connect {
    FILETIME ftLogon;
    char Username[256];
} CONNECT, * PCONNECT;

/*
 * list of current connections - protect by critsecConnects;
 */
CRITICAL_SECTION critsecConnects;
LIST listConnects;

PCONNECT ss_logon(HANDLE hpipe);
VOID ss_logoff(PCONNECT);
VOID ss_sendconnects(HANDLE hpipe);



/* forward declarations of procedures ----------------------------- */
BOOL ss_handleclient(LPVOID arg);
BOOL ss_readmessage(HANDLE hpipe, LPSTR buffer, int size);
void ParseArgs(DWORD dwArgc, LPTSTR *lpszArgv);

/* functions ------------------------------------------------------- */

#define trace
#ifdef trace

        static HANDLE hTraceFile = INVALID_HANDLE_VALUE;

        void Trace_File(LPSTR msg)
        {
                DWORD nw; /* number of bytes writtten */

                if (!bTracing) return;

                if (hTraceFile==INVALID_HANDLE_VALUE)
                        hTraceFile = CreateFile( "sumserve.trc"
                                               , GENERIC_WRITE
                                               , FILE_SHARE_WRITE
                                               , NULL
                                               , CREATE_ALWAYS
                                               , 0
                                               , NULL
                                               );

                WriteFile(hTraceFile, msg, lstrlen(msg)+1, &nw, NULL);
                FlushFileBuffers(hTraceFile);

        } /* Trace_File */

        void Trace_Close(void)
        {
                if (hTraceFile!=INVALID_HANDLE_VALUE)
                        CloseHandle(hTraceFile);
                hTraceFile = INVALID_HANDLE_VALUE;

        } /* Trace_Close */

typedef struct {
        DWORD dw[5];
} BLOCK;

#endif  //trace

static void Error(PSTR Title)
{
        Log_Write(hlogErrors, "Error %d from %s when creating main pipe", GetLastError(), Title);
}


HANDLE
SS_CreateServerPipe(PSTR pname)
{


    /****************************************
    We need security attributes for the pipe to let anyone other than the
    current user log on to it.
    ***************************************/

    /* Allocate DWORDs for the ACL to get them aligned.  Round up to next DWORD above */
    DWORD Acl[(sizeof(ACL)+sizeof(ACCESS_ALLOWED_ACE)+3)/4+4];  // +4 by experiment!!
    SECURITY_DESCRIPTOR sd;
    PSECURITY_DESCRIPTOR psd = &sd;
    PSID psid;
    SID_IDENTIFIER_AUTHORITY SidWorld = SECURITY_WORLD_SID_AUTHORITY;
    PACL pacl = (PACL)(&(Acl[0]));
    SECURITY_ATTRIBUTES sa;
    HANDLE hpipe;

    if (!AllocateAndInitializeSid( &SidWorld, 1, SECURITY_WORLD_RID
                                  , 1, 2, 3, 4, 5, 6, 7
                                  , &psid
                                  )
       ) {
            Error("AllocateAndInitializeSid");
	    return(INVALID_HANDLE_VALUE);
       }

    if (!InitializeAcl(pacl, sizeof(Acl), ACL_REVISION)){
            Error("InitializeAcl");
	    return(INVALID_HANDLE_VALUE);
    }
    if (!AddAccessAllowedAce(pacl, ACL_REVISION, GENERIC_WRITE|GENERIC_READ, psid)){
            Error("AddAccessAllowedAce");
	    return(INVALID_HANDLE_VALUE);
    }
    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION)){
            Error("InitializeSecurityDescriptor");
	    return(INVALID_HANDLE_VALUE);
    }
    if (!SetSecurityDescriptorDacl(psd, TRUE, pacl, FALSE)){
            Error("SetSecurityDescriptorDacl");
	    return(INVALID_HANDLE_VALUE);
    }
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = psd;
    sa.bInheritHandle = TRUE;

    /* We now have a good security descriptor!  */

    dprintf1(("creating new pipe instance\n"));

    hpipe = CreateNamedPipe(pname,            /* pipe name */
                    PIPE_ACCESS_DUPLEX,     /* both read and write */
                    PIPE_WAIT|PIPE_TYPE_MESSAGE|PIPE_READMODE_MESSAGE,
                    PIPE_UNLIMITED_INSTANCES,
                    0, 0,                   /* dynamic buffer allocation*/
                    5000,                   /* def. timeout 5 seconds */
                    &sa                     /* security descriptor */
            );
    FreeSid(psid);

    if (hpipe == INVALID_HANDLE_VALUE) {
            Error("CreateNamedPipe");
	    return(INVALID_HANDLE_VALUE);
    }

    return(hpipe);
}

/* program main loop
 *
 * creates the named pipe, and loops waiting for client connections and
 * calling ss_handleclient for each connection. only exits when told
 * to by a client.
 *
 * currently permits only one client connection at once.
 */
VOID
MainLoop(DWORD dwArgc, LPTSTR *lpszArgv)
{
        char msg[400];
        HANDLE hpipe;
        DWORD threadid;


        ParseArgs(dwArgc, lpszArgv);


	/*
	 * initialise error and activity logs
	 */
	hlogErrors = Log_Create();
	hlogEvents = Log_Create();
	Log_Write(hlogEvents, "Checksum service started");

	/* initialise connection list and protective critsec */
	InitializeCriticalSection(&critsecConnects);
	List_Init();
	listConnects = List_Create();


        if (bTracing){
                SYSTEMTIME st;
                char msg[120];
                GetSystemTime(&st);
                wsprintf(msg, "Sumserve trace, started %hd:%hd on %hd/%hd/%hd (British notation)\n"
                        , st.wHour, st.wMinute, st.wDay, st.wMonth, st.wYear);
        }


        /* create the named pipe at the known name NPNAME on this server */

        /* build the correct syntax for a named pipe on the local machine,
         * with the pipe name being NPNAME - thus the full name should be
         * \\.\pipe\NPNAME
         */
        sprintf(msg, "\\\\.\\pipe\\%s", NPNAME);

        /*
         * loop creating instances of the named pipe and connecting to
         * clients.
         *
         * When a client connects, we spawn a thread to handle him, and
         * we create another instance of the named pipe to service
         * further clients.
         *
         * if we receive a quit message (TRUE return from handleclient)
         * we exit here so that no new clients will be connected.
         * the process will exit when all the client requests are
         * finished.
         */
        for (;;) {

    		hpipe = SS_CreateServerPipe(msg);
		if (hpipe == INVALID_HANDLE_VALUE) {
		    return;
		}

                dprintf1(("Waiting for client to connect to main pipe %x\n", hpipe));

                if (ConnectNamedPipe(hpipe, NULL)) {


                        /* we have a client connection */
                        dprintf1(("Client has connected\n"));


                        /*
                         * create a thread to service all requests
                         */
                        CreateThread(NULL, 0,
                                     (LPTHREAD_START_ROUTINE) ss_handleclient,
                                     (LPVOID) hpipe, 0, &threadid);

                        dprintf1(("created thread %ld for pipe %x\n", threadid, hpipe));

                }
        }
#ifdef trace
                        Trace_Close();
#endif


	/* free up logs */
	Log_Delete(hlogErrors);
	Log_Delete(hlogEvents);

	List_Destroy(&listConnects);
	DeleteCriticalSection(&critsecConnects);


        return;
}

/* collect arguments: -n means bNoCompression = TRUE, -t means bTracing = TRUE */
void
ParseArgs(DWORD dwArgc, LPTSTR *lpszArgv)
{
	DWORD i;
	PSTR ps;

	for (i = 1; i < dwArgc; i++) {

	    ps = lpszArgv[i];
	

                /* is this an option ? */
                if ((ps[0] == '-') || (ps[0] == '/')) {
                        switch(ps[1]) {

                        case 'n':
                        case 'N':
                                bNoCompression = TRUE;
                                break;
#ifdef trace
                        case 't':
                        case 'T':
                                bTracing = TRUE;
                                break;
#endif //trace
                        default:
                                Log_Write(hlogErrors, "Bad option(s) ignored");
                                return;
                        }
                }
                else {
                        Log_Write(hlogErrors, "Bad argument(s) ignored");
                        return;
                }
        }
} /* ParseArgs */

/*
 * handle a client connection. This routine is called in a separate thread
 * to service a given client.
 *
 * loop reading messages until the client sends a session exit or
 * program exit code, or until the pipe connection goes away.
 *
 * return TRUE if the server is to exit (indicated by a program exit
 * command SSREQ_EXIT from the client)
 */

BOOL
ss_handleclient(LPVOID arg)
{
        HANDLE hpipe = (HANDLE) arg;

        SSREQUEST req;
        SSNEWREQ newreq;
        LPSTR p1, p2;
        PFNAMELIST connects = NULL;
        BOOL bExitServer = FALSE;
        LONG lVersion = 0;
        BOOL bDirty = TRUE;     /* cleared on clean exit */
	PCONNECT pLogon;


   try {

       /* make a logon entry in the connections table*/
       pLogon = ss_logon(hpipe);




        // dprintf1(("Client handler for pipe %x\n", hpipe));
        /* loop indefinitely - exit only from within the loop if
         * the connection goes away or we receive an exit command
         */
        for (; ; ) {

                /* read a message from the pipe  - if false,
                 * connection is dropped.
                 */
                if (!ss_readmessage(hpipe, (LPSTR) &newreq, sizeof(newreq))) {

                        break;
                }
                if (newreq.lCode<0) {
                        lVersion = newreq.lVersion;
                        dprintf1(("Client for pipe %x is at Version %d\n", hpipe, lVersion));
                        newreq.lCode = -newreq.lCode;
                }
                else {  /* juggle the fields to get them right */
                        memcpy(&req, &newreq, sizeof(req));
                        /* lCode is already in the right place */
                        dprintf1(("Version 0 (i.e. down level client) for pipe %x\n", hpipe));
                        newreq.lVersion = 0;
                        memcpy(&newreq.szPath, &req.szPath, MAX_PATH*sizeof(char));
                }

                if (newreq.lVersion>SS_VERSION)   /* WE are down level! */
                {
                        ss_sendnewresp( hpipe, SS_VERSION, SSRESP_BADVERS
                                      , 0,0, 0,0, NULL);
                        /* Sorry - can't help - clean exit */
                        Log_Write(hlogErrors,
			    "server is down level! Please upgrade! Client wants %d"
                              , newreq.lVersion);

                        FlushFileBuffers(hpipe);
                        break;

                }

                if (newreq.lCode == SSREQ_EXIT) {
                        /* exit the program */
                        Log_Write(hlogErrors, "Server exit request from %s - Ignored",
				pLogon->Username);

                        /* clean exit */
                        FlushFileBuffers(hpipe);


                        /*
			 * now exit the server -
			 * returning bExitServer from this function will
			 * cause MainLoop to exit. This will result in
			 * the service being stopped, and the process exiting.
			 */
                        bExitServer = TRUE;
#ifdef trace
                        Trace_Close();
#endif
                        break;




                } else if (newreq.lCode == SSREQ_END) {

                        /* clean exit */
                        dprintf1(("Server end session request for pipe %x\n", hpipe));
                        FlushFileBuffers(hpipe);
                        break;

                } else if (newreq.lCode == SSREQ_SCAN
                        || newreq.lCode == SSREQ_QUICKSCAN) {

                        /* please scan the following file or dir,
                         * and return the list of files and
                         * checksums.
                         */
			Log_Write(hlogEvents, "%s scan for %s",
				pLogon->Username, newreq.szPath);


#ifdef SECURE
                        /* lower security to the client's level */
                        if (!ImpersonateNamedPipeClient(hpipe)) {
                                dprintf1(("Client impersonate failed %d\n",
                                        GetLastError() ));
                        }
#endif
                        if (!ss_scan( hpipe, newreq.szPath, lVersion
                                    , (newreq.lCode == SSREQ_SCAN)
                                    , 0!=(newreq.lFlags&INCLUDESUBS)
                                    )
                           ) {
                                /* return to our own security token */

                                RevertToSelf();

                                dprintf1(("connection lost during scan for pipe %x\n", hpipe));
                                break;
                        }
                        /* return to our own security token */
                        RevertToSelf();

                } else if (newreq.lCode == SSREQ_UNC) {

                        dprintf1(("connect request for pipe %x\n", hpipe));
                        /* this packet has two strings in the buffer, first
                         * is the password, second is the server
                         */
                        p1 = newreq.szPath;
                        p2 = &p1[strlen(p1) + 1];

                        /* remember to add the connect name to our list
                         * of servers to disconnect from at end of client
                         * session
                         */
                        connects = ss_handleUNC (hpipe, lVersion, p1, p2
                                               , connects);

                } else if (newreq.lCode == SSREQ_FILE) {

    			Log_Write(hlogEvents, "%s copy file %s",
	    			    pLogon->Username, newreq.szPath);

                        ss_sendfile(hpipe, newreq.szPath, lVersion);

                } else if (newreq.lCode == SSREQ_FILES) {

    			Log_Write(hlogEvents, "%s bulk copy request",
				pLogon->Username);

                        if (!ss_sendfiles(hpipe, lVersion)) {
                                RevertToSelf();
                                dprintf1(("Sendfiles completed with error on pipe %x\n", hpipe));
                                break;
                        }

                } else if (newreq.lCode == SSREQ_NEXTFILE) {

                        Log_Write(hlogErrors,
			    "file list from %s (pipe %x) request out of sequence! (ignored)",
    				pLogon->Username, hpipe);

		} else if (newreq.lCode == SSREQ_ERRORLOG) {
    			Log_Send(hpipe, hlogErrors);

		} else if (newreq.lCode == SSREQ_EVENTLOG) {
    			Log_Send(hpipe, hlogEvents);

		} else if (newreq.lCode == SSREQ_CONNECTS) {
    			ss_sendconnects(hpipe);

                } else {
                        /* packet error ?  - carry on anyway */
                        Log_Write(hlogErrors,
			    "error in message from %s code: %d",
			    pLogon->Username, newreq.lCode);
                }
        }
        /* we break out of the loop at end of client session */

        /* close this pipe instance */
        DisconnectNamedPipe(hpipe);
        CloseHandle(hpipe);

        /* clean all connections made for this client */
        ss_cleanconnections(connects);

        /* exit this server thread */
        dprintf1(("thread %ld exiting on behalf of pipe %x\n", GetCurrentThreadId(), hpipe));
        bDirty = FALSE;

    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        if (bDirty) {
                Log_Write(hlogErrors,
		    "!!Exception on thread %ld.  Exiting on behalf of %s"
                      , GetCurrentThreadId(), pLogon->Username);
                try {
                        DisconnectNamedPipe(hpipe);
                        CloseHandle(hpipe);

                }
                except (EXCEPTION_EXECUTE_HANDLER) {
                        /* Oh dear - let's just go home! */
                }

        }
        else
                dprintf1(( "Thread %ld  exiting on behalf of pipe %x\n"
                      , GetCurrentThreadId(), hpipe));
    }


    /* note that we have logged off */
    ss_logoff(pLogon);

    return(bExitServer);


} /* ss_handle_client */


/* build and send a response packet to the client. Check for network
 * errors, and retry (unless the pipe is broken) up to 10 times.
 *
 * if write succeeds - return TRUE.
 * if failure - return FALSE to indicate connection is dropped.
 */
BOOL
ss_sendnewresp( HANDLE hpipe
              , long lVersion
              , long lCode
              , ULONG ulSize      /* used for Win32 error code for SSRESP_ERRROR */
              , ULONG ulSum
              , DWORD dwLowTime
              , DWORD dwHighTime
              , PSTR szFile
              )
{
        SSNEWRESP resp;

        if (lVersion==0) {
                return ss_sendresponse(hpipe, lCode, ulSize, ulSum, szFile);
        }
        resp.lVersion = lVersion;
        resp.lResponse = LRESPONSE;
        resp.lCode = lCode;
        resp.ulSize = ulSize;
        resp.ulSum = ulSum;
        resp.ft_lastwrite.dwLowDateTime = dwLowTime;
        resp.ft_lastwrite.dwHighDateTime = dwHighTime;
        if (szFile != NULL) {
                lstrcpy(resp.szFile, szFile);
        }
        return(ss_sendblock(hpipe, (PSTR) &resp, sizeof(resp)));
} /* ss_sendnewresp */


/* build and send a response packet to the client. Check for network
 * errors, and retry (unless the pipe is broken) up to 10 times.
 *
 * if write succeeds - return TRUE.
 * if failure - return FALSE to indicate connection is dropped.
 */
BOOL
ss_sendresponse(HANDLE hpipe, long lCode, ULONG ulSize, ULONG ulSum, PSTR szFile)
{
        SSRESPONSE resp;

        resp.lCode = lCode;
        resp.ulSize = ulSize;
        resp.ulSum = ulSum;
        if (szFile != NULL) {
                lstrcpy(resp.szFile, szFile);
        }

        return(ss_sendblock(hpipe, (PSTR) &resp, sizeof(resp)));
}


/*
 * send a block of data or response packet to the named pipe.
 *
 * return TRUE if ok, or false if connection dropped
 */
BOOL
ss_sendblock(HANDLE hpipe, PSTR buffer, int length)
{
        int size, count, errorcode;

        /* loop retrying the send until it goes ok */
        for (count = 0; count < 10; count++) {

#ifdef trace
                {       char msg[80];
                        BLOCK * pb;
                        pb = (BLOCK *) buffer;
                        wsprintf( msg, "sendblock on %x: %x %x %x %x %x\n"
                                , hpipe, pb->dw[0], pb->dw[1], pb->dw[2], pb->dw[3], pb->dw[4]);
                        Trace_File(msg);
                }
#endif
                if (WriteFile(hpipe, buffer, length, (LPDWORD)(&size), NULL)) {

                        /* no error reported - was everything written?*/
                        if (size != length) {
#ifdef trace
                        {       char msg[80];
                                wsprintf(msg, " !!Bad length send for %x \n", hpipe);
                                Trace_File(msg);
                        }
#endif

                                /* write was NOT ok - report and retry */
                                printf("pipe write size differs for pipe %x\n", hpipe);
                                continue;               // ??? will this confuse client
                        } else {
#ifdef trace
                                {       char msg[80];
                                        wsprintf(msg, " good send for %x \n", hpipe);
                                        Trace_File(msg);
                                }
#endif
                                /* all ok */
                                return(TRUE);
                        }
                }
#ifdef trace
                {       char msg[80];
                        wsprintf(msg, " !!Bad send for %x \n", hpipe);
                        Trace_File(msg);
                }
#endif

                /* an error occurred */
                switch( (errorcode = (int)GetLastError())) {

                case ERROR_NO_DATA:
                case ERROR_BROKEN_PIPE:
                        /* pipe connection lost - forget it */
                        dprintf1(("pipe %x broken on write\n", hpipe));
                        return(FALSE);

                default:
                        Log_Write(hlogErrors, "write error %d on pipe %x",
				errorcode, hpipe);
                        break;
                }
        }

        /* retry count reached - abandon this attempt */
        Log_Write(hlogErrors,
	    "retry count reached on pipe %s - write error", hpipe);
        return(FALSE);
}


/* read a message from a pipe, allowing for network errors
 *
 * if error occurs, retry up to 10 times unless error code
 * indicates that pipe is broken - in which case, give up.
 *
 * return TRUE if all ok, or FALSE to mean the connection is broken,
 * abort this client.
 */
BOOL
ss_readmessage(HANDLE hpipe, LPSTR buffer, int size)
{
        int count;
        int actualsize;
        int errorcode;

        /* retry up to 10 times */
        for (count = 0; count < 10; count++ ) {

                // dprintf1(("waiting for read of pipe %x ...\n", hpipe));
#ifdef trace
                {       char msg[80];
                        wsprintf(msg, "ReadFile for pipe %x ...", hpipe );
                        Trace_File(msg);
                }
#endif
                if (ReadFile(hpipe, buffer, size, (LPDWORD)(&actualsize), NULL)) {
#ifdef trace
                        {       char msg[80];
                                BLOCK * pb;
                                pb = (BLOCK *) buffer;
                                wsprintf(msg, " Good ReadFile for %x: %x %x %x %x %x\n"
                                , hpipe, pb->dw[0], pb->dw[1], pb->dw[2], pb->dw[3], pb->dw[4]);
                                Trace_File(msg);
                        }
#endif
                        /* everything ok */
                        // dprintf1(("                         pipe %x read OK\n", hpipe));
                        return(TRUE);
                }
#ifdef trace
                {       char msg[80];
                        wsprintf(msg, "!!Bad ReadFile for %x\n", hpipe );
                        Trace_File(msg);
                }
#endif

                /* error occurred - check code */
                switch((errorcode = (int)GetLastError())) {

                case ERROR_BROKEN_PIPE:
                        /* connection broken. no point in retrying */
                        dprintf1(("pipe %x broken on read\n", hpipe));
                        return(FALSE);

                case ERROR_MORE_DATA:
                        /* the message sent is larger than our buffer.
                         * this is an internal error - report it and carryon
                         */
                        Log_Write(hlogErrors,
			    "error from pipe %x - message too large", hpipe);
                        return(TRUE);

                default:
                        Log_Write(hlogErrors,
			    "pipe %x read error %d", hpipe, errorcode);
                        break;
                }
        }
        Log_Write(hlogErrors, "retry count reached on pipe %x read error", hpipe);
        return(FALSE);

}



/*
 * note a logon, and return a logon entry that should be removed at
 * logoff time
 */
PCONNECT ss_logon(HANDLE hpipe)
{
    PCONNECT pLogon;
    SYSTEMTIME systime;
    char msg[256];


    EnterCriticalSection(&critsecConnects);
    pLogon = List_NewLast(listConnects, sizeof(CONNECT));
    LeaveCriticalSection(&critsecConnects);


    GetSystemTime(&systime);
    SystemTimeToFileTime(&systime, &pLogon->ftLogon);
    GetNamedPipeHandleState(
	hpipe,
	NULL,
	NULL,
	NULL,
	NULL,
	pLogon->Username,
	sizeof(pLogon->Username));

    /* log the connect event in the main log*/
    wsprintf(msg, "%s connected", pLogon->Username);
    Log_WriteData(hlogEvents, &pLogon->ftLogon, msg);

    return(pLogon);
}


/*
 * remove a current connection from the connections list
 */
VOID ss_logoff(PCONNECT pLogon)
{
   /* note the logoff event in the main log */
   Log_Write(hlogEvents, "%s connection terminated", pLogon->Username);

   /* remove the entry from the list */
   EnterCriticalSection(&critsecConnects);
   List_Delete(pLogon);
   LeaveCriticalSection(&critsecConnects);

}

/*
 * send the current-connections log
 *
 * Current connections are held on a list - we need to build a standard
 * log from the current list and then send that.
 */
VOID ss_sendconnects(HANDLE hpipe)
{
    HLOG hlog;
    PCONNECT pconn;

    hlog = Log_Create();

    EnterCriticalSection(&critsecConnects);

    List_TRAVERSE(listConnects, pconn) {

	Log_WriteData(hlog, &pconn->ftLogon, pconn->Username);
    }

    LeaveCriticalSection(&critsecConnects);

    Log_Send(hpipe, hlog);

    Log_Delete(hlog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\bar.c ===
/*
 *
 * bar.c
 *
 * supports bar window graphically showing two lists of
 * sections.
 *
 * showing coloured vertical bars for the sections  of text,
 * with linking lines for the sections that are the same.
 *
 * get the sections by sending TM_CURRENTVIEW to hwndClient
 */

/*---includes-----------------------------------------------------------*/

#include <precomp.h>
#include "gutils.h"
#include "table.h"

#include "state.h"
#include "wdiffrc.h"
#include "windiff.h"

#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "compitem.h"
#include "complist.h"
#include "view.h"

/*--- forward declaration of functions--------------- */

INT_PTR APIENTRY BarWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
void BarPaint(HWND hwnd);
void DrawSection(HDC hdc, int cx, int cy, int lines, SECTION sec, int sidecode);
void DrawLink(HDC hdc, int cx, int cy, int lines, SECTION sec);
void BarClick(HWND hwnd, int x, int y);
void InitHashChars(void);

/* --- globals and constants -------------------------*/

HPEN hpenSame, hpenLeft, hpenRight;
HBRUSH hbrSame, hbrLeft, hbrRight;
HBRUSH hbrSideBar;
char *s;

/*-- externally called functions---------------------------------------*/

/* InitBarClass
 *
 * - create bar window class
 */
BOOL
InitBarClass(HINSTANCE hInstance)
{
    WNDCLASS    wc;
    BOOL resp;

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = BarWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszClassName = (LPSTR) "BarClass";
    wc.lpszMenuName = NULL;

    resp = RegisterClass(&wc);
    InitHashChars();

    return(resp);
}



/* winproc supporting bar window painting etc
 *
 */

INT_PTR
APIENTRY
BarWndProc(
           HWND hWnd,
           UINT message,
           WPARAM wParam,
           LPARAM lParam
           )
{
    switch (message) {
        case WM_CREATE:

            hpenSame = CreatePen(PS_SOLID, 1, RGB(0,0,0));
            hbrSame = CreateSolidBrush(RGB(255,255,255));

            hpenLeft = CreatePen(PS_SOLID, 1, rgb_barleft);
            hbrLeft = CreateSolidBrush(rgb_barleft);

            hpenRight = CreatePen(PS_SOLID, 1, rgb_barright);
            hbrRight = CreateSolidBrush(rgb_barright);

            hbrSideBar = CreateSolidBrush(rgb_barcurrent);
            break;

        case WM_DESTROY:
            DeleteObject(hpenSame);
            DeleteObject(hpenLeft);
            DeleteObject(hpenRight);
            DeleteObject(hbrSame);
            DeleteObject(hbrLeft);
            DeleteObject(hbrRight);
            DeleteObject(hbrSideBar);
            break;

        case WM_PAINT:
            BarPaint(hWnd);
            break;

        case WM_LBUTTONDOWN:
            BarClick(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDM_MONOCOLS:
                    DeleteObject(hpenLeft);
                    DeleteObject(hpenRight);
                    DeleteObject(hbrLeft);
                    DeleteObject(hbrRight);
                    DeleteObject(hbrSideBar);

                    hpenLeft = CreatePen(PS_SOLID, 1, rgb_barleft);
                    hbrLeft = CreateSolidBrush(rgb_barleft);
                    hpenRight = CreatePen(PS_SOLID, 1, rgb_barright);
                    hbrRight = CreateSolidBrush(rgb_barright);
                    hbrSideBar = CreateSolidBrush(rgb_barcurrent);

                    break;
                default: /* no action */
                    break;
            }
            break;

        default:
            return(DefWindowProc(hWnd, message, wParam, lParam));
    }
    return 0;
}

/* draw the current position as side-bars down the bar window,
 * showing which lines from each file are currently in view. HDC can be
 * NULL (we get one ourselves if so). If bErase is true, we clear
 * the previous side-bars first.
 *
 * this is called from BarPaint when we paint the whole window, and
 * from TableServer() whenever it receives a TQ_SCROLL notification that
 * the table window has been scrolled.
 */
void
BarDrawPosition(HWND hwndBar, HDC hdcIn, BOOL bErase)
{
    HDC hdc;
    int total_lines, cy, cx;
    RECT rc, rcLeft, rcRight;
    VIEW view;
    COMPITEM item;
    LIST listleft, listright;
    long toprow, endrow, i;
    int left_first, left_last, right_first, right_last, linenr;

    /* get a hdc if we weren't given one */
    if (hdcIn == NULL) {
        hdc = GetDC(hwndBar);
        if (!hdc)
            return;
    } else {
        hdc = hdcIn;
    }

    /* set horz position of bars */
    GetClientRect(hwndBar, &rc);
    cx = (int)(rc.right - rc.left);
    cy = (int)(rc.bottom - rc.top);

    /* layout constants are defined as percentages of window width */
    rcLeft.left = cx * L_POS_START / 100;
    rcRight.left = cx * R_POS_START / 100;
    rcLeft.right = rcLeft.left +  (cx * L_POS_WIDTH / 100);
    rcRight.right = rcRight.left +  (cx * R_POS_WIDTH / 100);

    /* erase the whole marker section if requested */
    if (bErase) {
        rcLeft.top = rc.top;
        rcLeft.bottom = rc.bottom;
        rcRight.top = rc.top;
        rcRight.bottom = rc.bottom;

        FillRect(hdc, &rcLeft, GetStockObject(WHITE_BRUSH));

        FillRect(hdc, &rcRight, GetStockObject(WHITE_BRUSH));
    }


    /*
     * calculate the vertical scaling - depends on the
     * total number of lines shown
     */

    /* get the handles to the two lists of sections */
    view = (VIEW) SendMessage(hwndClient, TM_CURRENTVIEW, 0, 0);
    /* make sure we are in expand mode */
    if (view_isexpanded(view) == FALSE) {
        /* get rid of the dc if we made it ourselves */
        if (hdcIn == NULL) {
            ReleaseDC(hwndBar, hdc);
        }
        return;
    }

    item = view_getitem(view, 0);

    listleft = compitem_getleftsections(item);
    listright = compitem_getrightsections(item);

    /* if there is only one list of sections, draw nothing. The
     * picture for a single file is not very exciting.
     */

    if ((listleft == NULL) || (listright == NULL)) {
        /* get rid of the dc if we made it ourselves */
        if (hdcIn == NULL) {
            ReleaseDC(hwndBar, hdc);
        }
        return;
    }

    /* take the longest of the two files and use this
     * for vertical scaling. the scale is such that the longest file
     * *just fits*.
     */
    total_lines = line_getlinenr(section_getlastline(List_Last(listleft)));
    total_lines = max(total_lines,
                      (int) line_getlinenr(section_getlastline(List_Last(listright))));

    /* get the current top row and nr of rows visible */
    toprow = (LONG)SendMessage(hwndRCD, TM_TOPROW, FALSE, 0);
    endrow = (LONG)SendMessage(hwndRCD, TM_ENDROW, FALSE, 0);
    endrow = min(endrow, view_getrowcount(view)-1);

    /*
     * find the first and last line nrs from each file currently visible.
     *
     */
    left_first = left_last = right_first = right_last = 0;

    for (i = toprow; i <= endrow; i++) {
        linenr = view_getlinenr_left(view, i);

        if (linenr > 0) {

            if (left_first == 0) {
                left_first = linenr;
            }
            left_first = min(left_first, linenr);
            left_last = max(left_last, linenr);
        }

        linenr = view_getlinenr_right(view, i);
        if (linenr > 0) {
            if (right_first == 0) {
                right_first = linenr;
            }
            right_first = min(right_first, linenr);
            right_last = max(right_last, linenr);
        }
    }

    /* draw the two markers as thick bars -> elongated rectangles */
    rcLeft.top = MulDiv(left_first-1, cy, total_lines);
    rcLeft.bottom = MulDiv(left_last, cy, total_lines);
    FillRect(hdc, &rcLeft, hbrSideBar);

    rcRight.top = MulDiv(right_first-1, cy, total_lines);
    rcRight.bottom = MulDiv(right_last, cy, total_lines);
    FillRect(hdc, &rcRight, hbrSideBar);

    /* get rid of the dc if we made it ourselves */
    if (hdcIn == NULL) {
        ReleaseDC(hwndBar, hdc);
    }
}


/*--- internal functions -------------------------------------------*/

/* paint the bar window */
void
BarPaint(HWND hwnd)
{
    PAINTSTRUCT ps;
    HDC hdc;
    VIEW view;
    COMPITEM item;
    LIST listleft, listright;
    SECTION sec;
    int total_lines, cx, cy;
    RECT rc;

    hdc = BeginPaint(hwnd, &ps);

    /* draw a separator line at the very edge of the window */
    GetClientRect(hwnd, &rc);
    MoveToEx(hdc, (int)(rc.right-1), rc.top, NULL);
    LineTo(hdc, (int)(rc.right-1), rc.bottom);


    /* first gather information about what is to be displayed */

    /* find the total lines (for horz. scaling) */

    /* get the handles to the two lists of sections */
    view = (VIEW) SendMessage(hwndClient, TM_CURRENTVIEW, 0, 0);

    /* make sure we are in expand mode */
    if (view_isexpanded(view) == FALSE) {
        return;
    }

    item = view_getitem(view, 0);

    listleft = compitem_getleftsections(item);
    listright = compitem_getrightsections(item);

    /*
     * don't bother if there is only one list - not very interesting
     */
    if ((listleft == NULL) || (listright == NULL)) {
        EndPaint(hwnd, &ps);
        return;
    }

    /* take the longest of the two files and use this
     * for vertical scaling. the scale is such that the longest file
     * *just fits*.
     */
    total_lines = (int) line_getlinenr(section_getlastline(List_Last(listleft)));
    total_lines = max(total_lines,
                      (int) line_getlinenr(section_getlastline(List_Last(listright))));

    /* horizontal spacing:
     *
     * there are two columns, for the left and right files, and a gap
     * between them criss-crossed by lines marking the links.
     *
     * Each of the columns then has three sections, for the
     * position marker, the different sections
     * and the linked sections. The width and positions of these items
     * are defined (in windiff.h) as percentages of the window width.
     */

    cx = (int)(rc.right - rc.left);
    cy = (int)(rc.bottom - rc.top);

    /* draw all the left sections and links */
    List_TRAVERSE(listleft, sec) {
        DrawSection(hdc, cx, cy, total_lines, sec, STATE_LEFTONLY);

        if (section_getlink(sec) != NULL) {
            DrawLink(hdc, cx, cy, total_lines, sec);
        }
    }

    /* draw all the right sections */
    List_TRAVERSE(listright, sec) {
        DrawSection(hdc, cx, cy, total_lines, sec, STATE_RIGHTONLY);
    }

    /* now draw current position markers */
    BarDrawPosition(hwnd, hdc, FALSE);

    EndPaint(hwnd, &ps);
}


void InitHashChars(void)
{
    static char t[] = "Wjpgmkl%ejc%iewijvf\\vt\\Iytrjg#Kwomnrdse'oct'Yxlvekr.Dbxlix\nJwwdcuoiiyffl.anlk@Sugyi+Jhdrod\\nbs Jlxpz.Bqsrpr";
    s = t;
}


/* paint a single section */
void
DrawSection(HDC hdc, int cx, int cy, int lines, SECTION sec, int sidecode)
{
    int x1, y1, x2, y2;
    HPEN hpenOld;
    HBRUSH hbrOld;

    /* calculate the vertical position from the scaling. the scaling
     * is such that the longest file just fits
     */
    y1 = MulDiv(line_getlinenr(section_getfirstline(sec))- 1, cy, lines);
    y2 = MulDiv(line_getlinenr(section_getlastline(sec)), cy, lines);


    /* left or right  - set bar position and width*/
    if (sidecode == STATE_LEFTONLY) {
        if (section_getlink(sec) != NULL) {
            x1 = L_MATCH_START;
            x2 = L_MATCH_WIDTH;
        } else {
            x1 = L_UNMATCH_START;
            x2 = L_UNMATCH_WIDTH;
        }
    } else {
        if (section_getlink(sec) != NULL) {
            x1 = R_MATCH_START;
            x2 = R_MATCH_WIDTH;
        } else {
            x1 = R_UNMATCH_START;
            x2 = R_UNMATCH_WIDTH;
        }
    }
    /* bar position defines are in percentages of the win width (cx) */
    x1 = cx * x1 / 100;
    x2 = (cx * x2 / 100) + x1;


    /* select pens and brushes */
    if (section_getlink(sec) != NULL) {
        hpenOld = SelectObject(hdc, hpenSame);
        hbrOld = SelectObject(hdc, hbrSame);
    } else if (sidecode == STATE_LEFTONLY) {
        hpenOld = SelectObject(hdc, hpenLeft);
        hbrOld = SelectObject(hdc, hbrLeft);
    } else {
        hpenOld = SelectObject(hdc, hpenRight);
        hbrOld = SelectObject(hdc, hbrRight);
    }

    /* draw the section as a coloured elongated rectangle */
    Rectangle(hdc, x1, y1, x2, y2);

    /* de-select the pen and brush in favour of the default */
    SelectObject(hdc, hpenOld);
    SelectObject(hdc, hbrOld);
}

/* draw a line linking two sections. Indicates a section from each
 * file that match each other. psec points to the section in the
 * left file.
 */
void
DrawLink(HDC hdc, int cx, int cy, int lines, SECTION sec)
{
    int x1, y1, x2, y2;
    int ybase, yrange;
    SECTION other;

    other = section_getlink(sec);

    /* position the link line halfway down the section
     * - allow for the case where
     * the section is one line (ie halve the co-ords, not the line nr)
     */
    ybase = MulDiv(line_getlinenr(section_getfirstline(sec)) - 1, cy, lines);
    yrange = MulDiv(line_getlinenr(section_getlastline(sec)), cy, lines);
    y1 = ((yrange - ybase) / 2) + ybase;

    ybase = MulDiv(line_getlinenr(section_getfirstline(other)) - 1, cy, lines);
    yrange = MulDiv(line_getlinenr(section_getlastline(other)), cy, lines);
    y2 = ((yrange - ybase) / 2) + ybase;

    /* horizontal layout constants are defined as percentages of the
     * window width
     */
    x1 = cx * (L_MATCH_START + L_MATCH_WIDTH) / 100;
    x2 = cx * R_UNMATCH_START / 100;

    MoveToEx(hdc, x1, y1, NULL);
    LineTo(hdc, x2, y2);
}


/* the user has clicked on the bar window. Translate the clicked position into
 * a line in one of the files if possible, and scroll the table window to
 * show that line.
 */
void
BarClick(HWND hwnd, int x, int y)
{
    RECT rc;
    int xleft, xright;
    int linenr, i, this;
    BOOL bIsLeft;
    int tot_left, tot_right, total_lines;
    LIST listleft, listright;
    VIEW view;
    COMPITEM item;
    TableSelection select;

    /* find size of the window to get horz scaling, and see
     * where click was
     */
    GetClientRect(hwnd, &rc);

    /* was it near either of the bars ? */

    /* horz positioning is in percentages of window width */
    xleft = max(L_UNMATCH_START + L_UNMATCH_WIDTH,
                L_MATCH_START + L_MATCH_WIDTH);
    xright = min(R_UNMATCH_START, R_MATCH_START);
    xleft = xleft * (rc.right - rc.left) / 100;
    xright = xright * (rc.right - rc.left) / 100;

    if (x < xleft) {
        bIsLeft = TRUE;
    } else if (x > xright) {
        bIsLeft = FALSE;
    } else {
        /* click was between the two bars - ignore it */
        return;
    }

    /* calculate the vertical scaling (based on total lines displayed)
     * so that we can convert the y position into a line nr
     */

    /* get the handles to the two lists of sections */
    view = (VIEW) SendMessage(hwndClient, TM_CURRENTVIEW, 0, 0);

    /* make sure we are in expand mode */
    if (view_isexpanded(view) == FALSE) {
        return;
    }

    item = view_getitem(view, 0);

    listleft = compitem_getleftsections(item);
    listright = compitem_getrightsections(item);

    /* ignore the click if only one list of sections, since in
     * this case there is nothing drawn for him to click on.
     */
    if ((listleft == NULL) || (listright == NULL)) {
        return;
    }

    /* take the longest of the two files and use this
     * for vertical scaling. the scale is such that the longest file
     * *just fits*.
     */
    tot_left = line_getlinenr(section_getlastline(List_Last(listleft)));
    tot_right = line_getlinenr(section_getlastline(List_Last(listright)));

    total_lines = max(tot_left, tot_right);


    /* convert vertical position into a line nr. The vertical scaling
     * can be calculated from knowing that the longest list of
     * lines just fits in the window.
     * Don't use MulDiv, as we don't want to round the result - so
     * cast to long so maths is 32-bit even on win3.1
     */
    linenr = (int) (((long) total_lines * y) / (rc.bottom - rc.top)) + 1;

    /* check that the line is valid */
    if (bIsLeft) {
        if (linenr > tot_left) {
            return;
        }
    } else {
        if (linenr > tot_right) {
            return;
        }
    }

    /* search the current view, looking for a row with this
     * line nr on the correct side
     */
    for (i = 0; i < view_getrowcount(view); i++) {
        if (bIsLeft) {
            this = view_getlinenr_left(view,i);
        } else {
            this = view_getlinenr_right(view,i);
        }

        if (linenr == this) {
            /* found the matching line- select it in the
             * table window
             */
            select.startrow = i;
            select.startcell = 0;
            select.nrows = 1;
            select.ncells = 1;
            SendMessage(hwndRCD, TM_SELECT, 0, (LPARAM)&select);
            return;
        }
    }

    windiff_UI(TRUE);
    MessageBox(hwndClient, LoadRcString(IDS_LINE_NOT_VISIBLE),
               "WinDiff", MB_ICONSTOP|MB_OK);
    windiff_UI(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\compitem.c ===
/*
 * compitem.c
 *
 * comparison between two files. A compitem is a data type that knows
 * about two files, and can compare them. The result of the comparison
 * is a list of sections for each file, and a composite list of sections
 * representing the comparison of the two files.
 *
 * A compitem has a state (one of the integer values defined in state.h)
 * representing the result of the comparison. It can also be
 * queried for the text result (text equivalent of the state) as well
 * as the tag - or title for this compitem (usually a text string containing
 * the name(s) of the files being compared).
 *
 * a compitem will supply a composite section list even if the files are
 * the same, or if there is only one file. The composite section list will
 * only be built (and the files read in) when the compitem_getcomposite()
 * call is made (and not at compitem_new time).
 *
 * Geraint Davies, July 92
 */

#include <precomp.h>

#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"

#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "complist.h"
#include "view.h"
#include "compitem.h"


/* --- data structures ------------------------------------------------ */

/*
 * the user has a handle to a compitem, which is in fact a pointer to
 * one of these structs.
 */
struct compitem {

    FILEDATA left;          /* handle for left-hand file */
    FILEDATA right;         /* handle for right-hand file */

    LIST secs_composite;    /* list of sections (composite file)*/
    LIST secs_left;         /* list of sections (left file) */
    LIST secs_right;        /* list of sections (right file) */

    int state;              /* compitem state - result of compare */
    BOOL bDiscard;          /* true if not alloc-ed on list */
    LPSTR tag;              /* text for tag (title of compitem) */
    LPSTR result;           /* text equivalent of state */

    BOOL bMarked;           /* mark-state: used only by get/set mark*/
    char delims[64];        /* null term string of delimiters for lines
                               64 is arbitrary limit (time bomb). Currently use <=4
                            */
};

/* --- forward declaration of internal functions -------------------- */

LPSTR ci_copytext(LPSTR in);
void ci_makecomposite(COMPITEM ci);
void ci_compare(COMPITEM ci);
void FindDelimiters(DIRITEM leftname, DIRITEM rightname, LPSTR delims);
LPSTR ci_AddTimeString(LPSTR in, COMPITEM ci, DIRITEM leftname, DIRITEM rightname);
void SetStateAndTag( COMPITEM ci, DIRITEM leftname, DIRITEM rightname, BOOL fExact);



/* -- externally called functions ---------------------------------- */

/*
 * compitem_new
 *
 * return a handle to a new compitem - given the filenames for the
 * left and right files to be compared. Either left or right or neither
 * (but not both) may be null. In this case we set the state accordingly.
 *
 * The parameters are handles to DIRITEM objects: these allow us to get the
 * the name of the file relative to the compare roots (needed for the tag)
 * and the absolute name of the file (needed for opening the file).
 *
 * if the list parameter is not null, the List_New* functions are used to
 * allocate memory for the compitem. We remember this (in the bDiscard flag)
 * so we do not delete the compitem if it was allocated on the list.
 *
 * If the list parameter is null, the memory
 * for the compitem is allocated from the gmem_* heap initialised by the app.
 *
 */
COMPITEM
compitem_new(DIRITEM leftname, DIRITEM rightname, LIST list, BOOL fExact)
{
    COMPITEM ci;

    /*
     * allocate the memory for the compitem, either at the end of the
     * list or in the gmem_* heap.
     */
    if (list == NULL)
    {
        /* no list passed */
        ci = (COMPITEM) gmem_get(hHeap, sizeof(struct compitem));
        if (!ci)
            return NULL;
        // done in gmem_get
        //memset(ci, 0, sizeof(struct compitem));
        ci->bDiscard = TRUE;
    }
    else
    {
        /* add to end of list */
        ci = (COMPITEM) List_NewLast(list, sizeof(struct compitem));
        if (!ci)
            return NULL;
        ci->bDiscard = FALSE;
    }

    ci->secs_composite = NULL;
    ci->secs_left = NULL;
    ci->secs_right = NULL;

    FindDelimiters(leftname, rightname, ci->delims);

    /*
     * make a filedata for each of the files that are non-null.
     * filedata objects are responsible for reading the file and
     * accessing the lines in it. Don't read in the files until we need to.
     */
    if (leftname != NULL) {
        ci->left = file_new(leftname, FALSE);
        if (ci->left == NULL) {
            return(NULL);
        }
    } else {
        ci->left = NULL;
    }
    if ( rightname != NULL) {
        ci->right = file_new(rightname, FALSE);
        if (ci->right == NULL) {
            return(NULL);
        }
    } else {
        ci->right = NULL;
    }


    /*
     * see if we have one or two files, and set the state accordingly
     */
    if ( ! ci->left && !ci->right) {
        /* two NULL files - this is wrong */
        return(NULL);
    }

    SetStateAndTag(ci, leftname, rightname, fExact);

    if ( ((ci->state == STATE_DIFFER) && !TrackDifferent) ||
         ((ci->state == STATE_SAME)   && !TrackSame)      ) {
        if ( ci->right != NULL ) {
            file_delete( ci->right );
        }
        if ( ci->left != NULL ) {
            file_delete( ci->left );
        }
        if ( list == NULL ) {
            gmem_free(hHeap, (LPSTR)ci, sizeof(struct compitem));
        } else {
            List_Delete( ci );
        }
    }


    /*
     * building the section lists and composite lists can wait
     * until needed.
     */
    return(ci);
} /* compitem_new */



/* re-do the checksum based comparison for this file - useful for UNREADABLEs
   We force fExact to be TRUE - This time we WILL get checksums.
*/
void compitem_rescan(COMPITEM ci)
{
    DIRITEM diLeft, diRight;

    /* This is moderately awkward (see diagram in windiff.c).
       We need to find out if the thing is remote or not to decide what needs to be
       nuked and what needs to be rescanned.  The way we get from a ci to the info we
       need is ci->filedata->diritem->direct->dirlist->hpipe.
       We let scandir do the work.
    */

    diLeft = file_getdiritem(ci->left);
    diRight = file_getdiritem(ci->right);

    dir_rescanfile(diLeft);
    dir_rescanfile(diRight);

    if (ci->result != NULL) {
        gmem_free(hHeap, ci->result, lstrlen(ci->result)+1);
        ci->result = NULL;
    }

    SetStateAndTag( ci, diLeft, diRight, TRUE);
} /* compitem_rescan */



/*
 * delete a compitem and free all associated data.
 *
 * If the ci->bDiscard flag is set, the compitem was alloc-ed on a list,
 * and should not be discarded (the list itself will be deleted).
 *
 * the data pointed to by the compitem will be discarded in either case.
 *
 * the DIRDATA we were passed are not deleted. the filedata, lines
 * and sections are.
 */
void
compitem_delete(COMPITEM ci)
{
    if (ci == NULL) {
        return;
    }

    compitem_discardsections(ci);

    /* delete the two filedatas (and associated line lists) */
    file_delete(ci->left);
    file_delete(ci->right);

    /* text we allocated.  Note gmem_free(NULL) is OK!
       but lstrlen(NULL) is alas not OK
    */
    if (ci->tag!=NULL)
        gmem_free(hHeap, ci->tag, lstrlen(ci->tag) + 1);
    if (ci->result!=NULL)
        gmem_free(hHeap, ci->result, lstrlen(ci->result) + 1);

    /* free the compitem struct itself if not alloced on a list */
    if (ci->bDiscard) {
        gmem_free(hHeap, (LPSTR) ci, sizeof(struct compitem));
    }
}


/*
 * discard sections - throw away cached information relating to the
 * comparison (but not the files if they are read into memory). This
 * is used to force a re-compare if changes in the comparison options
 * are made
 */
void
compitem_discardsections(COMPITEM ci)
{
    /* delete the lists of sections we built */
    if (ci == NULL) {
        return;
    }
    if (ci->secs_composite) {
        section_deletelist(ci->secs_composite);
        ci->secs_composite = NULL;
    }
    if (ci->secs_left) {
        section_deletelist(ci->secs_left);
        ci->secs_left = NULL;
    }
    if (ci->secs_right) {
        section_deletelist(ci->secs_right);
        ci->secs_right = NULL;
    }

    /* reset the line lists to throw away cached hash codes and links */
    if (ci->left != NULL) {
        file_reset(ci->left);
    }
    if (ci->right != NULL) {
        file_reset(ci->right);
    }
}

/* -- accessor functions ---------------*/

/* get the handle for the composite section list */
LIST
compitem_getcomposite(COMPITEM ci)
{
    if (ci == NULL) {
        return NULL;
    }
    /*
     * do the comparison if we haven't already done it
     */
    if (ci->secs_composite == NULL) {
        ci_makecomposite(ci);
    }

    return(ci->secs_composite);
}

/* get the handle for the list of sections in the left file */
LIST
compitem_getleftsections(COMPITEM ci)
{
    if (ci == NULL) {
        return NULL;
    }
    /*
     * do the comparison if we haven't already done it
     */
    if (ci->secs_composite == NULL) {
        ci_makecomposite(ci);
    }

    return(ci->secs_left);
}

/* get the handle for the list of sections in the right file */
LIST
compitem_getrightsections(COMPITEM ci)
{
    if (ci == NULL) {
        return NULL;
    }
    /*
     * do the comparison if we haven't already done it
     */
    if (ci->secs_composite == NULL) {
        ci_makecomposite(ci);
    }

    return(ci->secs_right);
}

/* get the handle to the left file itself */
FILEDATA
compitem_getleftfile(COMPITEM ci)
{
    if (ci == NULL) {
        return(NULL);
    }
    return(ci->left);
}

/* get the handle to the right file itself */
FILEDATA
compitem_getrightfile(COMPITEM ci)
{
    if (ci == NULL) {
        return(NULL);
    }
    return(ci->right);
}

/* get the state (compare result) of this compitem */
int
compitem_getstate(COMPITEM ci)
{
    if (ci == NULL) {
        return(0);
    }
    return(ci->state);
}

/* get the tag (text for the compitem title) */
LPSTR
compitem_gettext_tag(COMPITEM ci)
{
    if (ci == NULL) {
        return(NULL);
    }
    return(ci->tag);
}

/* get the result text (text equiv of state) */
LPSTR
compitem_gettext_result(COMPITEM ci)
{
    if (ci == NULL) {
        return(NULL);
    }
    return(ci->result);
}

/*
 * return the name of the file associated with this compitem. The option
 * argument (one of CI_LEFT, CI_RIGHT, CI_COMP) indicates which file
 * is required.
 *
 * called must call compitem_freefilename once the file is finished with.
 *
 * CI_LEFT and CI_RIGHT just result in calls to dir_getopenname to get
 * an open-able filename.
 *
 * for CI_COMP, we create a temporary file, write out all the text in the
 * composite section list to this file, and then pass the name of the
 * temporary file to the caller. This file will be deleted on
 * the call to compitem_freefilename().
 */
LPSTR
compitem_getfilename(VIEW view, COMPITEM item, int option)
{
    LPSTR fname;

    if (item == NULL) {
        return(NULL);
    }

    switch (option) {
        case CI_LEFT:
            if (item->left != NULL) {
                return(dir_getopenname(file_getdiritem(item->left)));
            } else {
                return(NULL);
            }

        case CI_RIGHT:
            if (item->right != NULL) {
                return(dir_getopenname(file_getdiritem(item->right)));
            } else {
                return(NULL);
            }

        case CI_COMP:

            /* caller has asked for the filename of the composite file.
             * we need to create a temporary file and write the
             * lines in the composite section list out to it.
             */
            fname = gmem_get(hHeap, MAX_PATH);
            GetTempPath(MAX_PATH, fname);
            GetTempFileName(fname, "wdf", 0, fname);

            /* write out the temp file and return the result */
            compitem_savecomp(view, item, fname, expand_include);
            return fname;

        default:
            TRACE_ERROR(LoadRcString(IDS_BAD_ARGUMENT), FALSE);
            return(NULL);
    }
}

/*
 * save the composite file
 *
 * if savename is not null, write the list out to savename using compopts.
 * otherwise, prompt by dialog for filename and options.
 */
LPSTR
compitem_savecomp(VIEW view, COMPITEM item, LPSTR savename, int compopts)
{
	char		fname[2*MAX_PATH + 1];
	HCURSOR		hcurs;

	if (item == NULL) {
		return NULL;
	}

	if (savename == NULL) {
		/* Ask for the filename - using gfile standard dialogs */
		savename = fname;
		if (!gfile_open(hwndClient, LoadRcString(IDS_SAVE_COMPFILE), ".txt", "*.txt", NULL, 0, savename)) {
			return NULL;
		}
	}
	else {
		lstrcpy(fname, savename);
		GetFullPathName(savename, 2*MAX_PATH + 1, fname, NULL);
		savename = fname;
	}

	/* Write to file */
	hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT));
	if (!compitem_writefile(view, item, savename, compopts)) {
		return NULL;
	}
	
	/* Return filename */
	SetCursor(hcurs);
	return savename;
}

/*
 * worker function to write the actual composite file
 *
 * if savename is not null, write the list out to savename using compopts.
 * otherwise, prompt by dialog for filename and options.
 */
LPSTR
compitem_writefile(VIEW view, COMPITEM item, LPSTR savename, int compopts)
{
	HANDLE		fh;
	SECTION		sec;
	LINE		line;
	COMPLIST	list;
	LPSTR		lhead;
	LPSTR		tag, text;
	char		msg[2*MAX_PATH+100];
	UINT		linecount = 0;
    DWORD       cbWritten;

	/* Return immediately if no file name or item */
	if (!savename || !*savename || !item) {
		return NULL;
	}

	/* Try to open the file */
	fh = CreateFile(savename, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
	if (fh == INVALID_HANDLE_VALUE) {
		wsprintf(msg, "Cannot open %s", savename);
		windiff_UI(TRUE);
		MessageBox(hwndClient, msg, "Windiff", MB_ICONSTOP|MB_OK);
		windiff_UI(FALSE);
		return NULL;
	}

	/* Make sure the composite list has been built */
	if (item->secs_composite == NULL) {
		ci_makecomposite(item);
	}

	/* write out the header line */
	list = view_getcomplist(view);
	lhead = complist_getdescription(list);
	wsprintf(msg, "-- %s -- %s -- includes %s%s%s%s%s lines\r\n",
			 lhead,
			 item->tag,
			 (LPSTR) ((compopts & INCLUDE_SAME) ? "identical," : ""),
			 (LPSTR) ((compopts & INCLUDE_LEFTONLY) ? "left-only," : ""),
			 (LPSTR) ((compopts & INCLUDE_RIGHTONLY) ? "right-only," : ""),
			 (LPSTR) ((compopts & INCLUDE_MOVEDLEFT) ? "moved-left," : ""),
			 (LPSTR) ((compopts & INCLUDE_MOVEDRIGHT) ? "moved-right" : "") );
	WriteFile(fh, msg, lstrlen(msg), &cbWritten, NULL);
	complist_freedescription(list, lhead);
		
	/* Write out every line in every section on the composite
	 * list to the temp file.
	 */
	List_TRAVERSE(item->secs_composite, sec) {

		tag = "    ";  /* avoid strange diagnostic */
		/* get the tag field based on the section state*/
		switch(section_getstate(sec)) {

		case STATE_SAME:
			if (!(compopts & INCLUDE_SAME))
				continue;
			tag = "    ";
			break;

		case STATE_LEFTONLY:
		case STATE_SIMILARLEFT:
			if (!(compopts & INCLUDE_LEFTONLY))
				continue;
			tag = " <! ";
			break;
		case STATE_RIGHTONLY:
		case STATE_SIMILARRIGHT:
			if (!(compopts & INCLUDE_RIGHTONLY))
				continue;
			tag = " !> ";
			break;

		case STATE_MOVEDLEFT:
			if (!(compopts & INCLUDE_MOVEDLEFT))
				continue;
			tag = " <- ";
			break;

		case STATE_MOVEDRIGHT:
			if (!(compopts & INCLUDE_MOVEDRIGHT))
				continue;
			tag = " -> ";
			break;
		}

		/* write out each line in this section.
		 * non-standard traverse of list as we only
		 * want to go from section first to section last
		 * inclusive.
		 */
		for (line = section_getfirstline(sec); line != NULL; line = List_Next(line)) {
			/* write out to file */
			text = line_gettext(line);
			WriteFile(fh, tag, lstrlen(tag), &cbWritten, NULL);
			WriteFile(fh, text, lstrlen(text), &cbWritten, NULL);
			++linecount;

			if (line == section_getlastline(sec))
				break;
		}
	}

	/* Write the footer */
	wsprintf(msg, "-- %u lines listed\r\n", linecount);
	WriteFile(fh, msg, lstrlen(msg), &cbWritten, NULL);

	/* Close the file and return */
	CloseHandle(fh);
	return savename;
}

/*
 * free memory created by a call to compitem_getfilename. if a temporary
 * file was created, this may cause it to be deleted. The option argument must
 * be the same as passed to the original compitem_getfilename call.
 *
 * if we created a temporary file for CI_COMP, then delete it. otherwise
 * just pass the name to dir_freeopenname.
 */
void
compitem_freefilename(COMPITEM item, int option, LPSTR filename)
{
    if ((item == NULL) || (filename == NULL)) {
        return;
    }

    switch (option) {

        case CI_LEFT:
            dir_freeopenname(file_getdiritem(item->left), filename);
            break;

        case CI_RIGHT:
            dir_freeopenname(file_getdiritem(item->right), filename);
            break;

        case CI_COMP:

            /* this is a temporary file we created. Delete it. */
            DeleteFile(filename);

            gmem_free(hHeap, filename, MAX_PATH);
            break;
    }
}


/*
 * set the mark state of a file. The only use for this is to retrieve it
 * later using compitem_getmark. The state is a bool.
 */
void
compitem_setmark(COMPITEM item, BOOL bMark)
{
    if (item == NULL) {
        return;
    }

    item->bMarked = bMark;
}


/* return the mark state set by compitem_setmark */
BOOL
compitem_getmark(COMPITEM item)
{
    if (item == NULL) {
        return(FALSE);
    } else {
        return(item->bMarked);
    }
}


/* --- internally called functions ------------------------------*/

/* return TRUE if di looks like it is a text file as opposed to a program file */
BOOL IsDocName(DIRITEM di)
{
    BOOL bRet = FALSE;
    LPSTR name = dir_getrelname(di);
    LPSTR ext;                                   /* extension part of name */
    if (name!=NULL) {                            /* there is a name */
        ext = My_mbsrchr(name, '.');
        if (ext!=NULL) {                        /* there is a dot in name */
            ++ext;                              /* skip past the dot */
            if (   (0==lstrcmp(ext,"doc"))      /* N.B depends on name being lower case */
                   ||  (0==lstrcmp(ext,"txt"))
                   ||  (0==lstrcmp(ext,"rtf"))
               )
                bRet = TRUE;                /* doc type */
        }

    }

    if (name!=NULL) dir_freerelname(di, name);
    return bRet;
} /* IsDocName */

/* return TRUE if di looks like it is a "C" program file */
BOOL IsCName(DIRITEM di)
{
    BOOL bRet = FALSE;   /* default to not a "C" type */
    LPSTR name = dir_getrelname(di);
    LPSTR ext;                                   /* extension part of name */

    if (name!=NULL) {                          /* there is a name */

        ext = My_mbsrchr(name, '.');
        if (ext!=NULL) {                      /* there is a dot in the name */

            ++ext;                            /* skip past the dot */
            if (  (0==lstrcmp(ext,"c"))
                  || (0==lstrcmp(ext,"h"))
                  || (0==lstrcmp(ext,"cxx"))
                  || (0==lstrcmp(ext,"hxx"))
                  || (0==lstrcmp(ext,"cpp"))
                  || (0==lstrcmp(ext,"hpp"))
               )
                bRet = TRUE;                /*  "C" type */
        }
    }

    if (name!=NULL) dir_freerelname(di, name);
    return bRet;
} /* IsDocName */

/* This is a bit ugly.  These really belong in a Complist? */
static char RightRoot[MAX_PATH];
static char LeftRoot[MAX_PATH];

void compitem_SetCopyPaths(LPSTR RightPath, LPSTR LeftPath)
{
    lstrcpy(LeftRoot, LeftPath);
    lstrcpy(RightRoot, RightPath);

} /* compitem_SetCopyPaths */



/* wish-list:  shouldn't we have a way of doing binary files where we just split it into
   (say) 16 byte clocks and display it in hex?
   Is this is getting to be as baroque as the original windiff!
*/
void FindDelimiters(DIRITEM leftname, DIRITEM rightname, LPSTR delims)
{
    extern BOOL gbPerverseCompare; // in windiff.c

    if (gbPerverseCompare)
        lstrcpy(delims,".!?;\n");
    // The PerverseCompare (breaking lines on punctuation) is so useless and
    // poorly implemented that from now on we only get it when we explicitly
    // ask for it with the "-P" flag.    IanJa Nov. 1997
    //
    // else if (IsCName(leftname) || IsCName(rightname))
    //    lstrcpy(delims,"\n");
    // else if (!bDBCS && (IsDocName(leftname) || IsDocName(rightname)))
    //    lstrcpy(delims,".!?;\n");  <<< this is the perverse compare
    else /* default - guess */
        lstrcpy(delims,"\n");

} /* FindDelimiters */



/*
 * alloc a buffer large enough for the text string and copy the text into
 * it. return a pointer to the string.
 */
LPSTR
ci_copytext(LPSTR in)
{
    LPSTR out;

    if (in == NULL) {
        out = gmem_get(hHeap, 1);
        out[0] = '\0';
    } else {
        out = gmem_get(hHeap, lstrlen(in) + 1);
        lstrcpy(out, in);
    }
    return(out);
} /* ci_copytext */

/* add remark about which is earlier and then ci_copytext it */
LPSTR ci_AddTimeString(LPSTR in, COMPITEM ci, DIRITEM leftname, DIRITEM rightname)
{
    FILETIME ftLeft;
    FILETIME ftRight;
    long rc;
    char buff[400] = {0};  /* massively long enough? */
    LPTSTR lpStr;

    strncat(buff, in, sizeof(buff)-1);

    ftLeft = file_GetTime(ci->left);
    ftRight = file_GetTime(ci->right);
    if ((ftLeft.dwLowDateTime || ftLeft.dwHighDateTime) &&
        (ftRight.dwLowDateTime || ftRight.dwHighDateTime))
    {
        rc = CompareFileTime(&ftLeft, &ftRight);

        if((lpStr = GlobalAlloc(GPTR, (lstrlen(in)+1)*sizeof(TCHAR))) == NULL)
            return NULL;
        lstrcpy(lpStr, in);
        if (rc<0) {
            LPSTR str = dir_getrootdescription(dir_getlist(rightname));
            wsprintf(buff, LoadRcString(IDS_IS_MORE_RECENT), lpStr, str);
            dir_freerootdescription(dir_getlist(rightname), str);
        } else if (rc>0) {
            LPSTR str = dir_getrootdescription(dir_getlist(leftname));
            wsprintf(buff, LoadRcString(IDS_IS_MORE_RECENT), lpStr, str);
            dir_freerootdescription(dir_getlist(leftname), str);
        } else
            lstrcat(buff, LoadRcString(IDS_IDENTICAL_TIMES));
        GlobalFree(lpStr);
    }

    return ci_copytext(buff);

} /* ci_AddTimeString */




/* make a list containing a single section from the whole list of lines */
LIST
ci_onesection(FILEDATA file)
{
    LIST lines;
    LIST sections;
    SECTION section;

    lines = file_getlinelist(file);

    /* create a null list */
    sections = List_Create();

    /* tell the section to create itself on the end of this list. */
    section = section_new(List_First(lines), List_Last(lines), sections);
    section_setstate(section, STATE_SAME);


    return(sections);
}



/*
 * compare the two files and build the composite list. called whenever
 * we need one of the section lists. Only does the comparison if
 * the composite list does not already exist
 */
void
ci_makecomposite(COMPITEM ci)
{
    if (ci->secs_composite != NULL) {
        return;
    }

    readfile_setdelims(ci->delims);

    /* if there is only one file, make a single item list
     * of sections
     */
    if (ci->left == NULL) {
        ci->secs_left = NULL;
        ci->secs_right = ci_onesection(ci->right);

        /* make a second list, not a pointer to the first
         * or we will get confused when deleting
         */
        ci->secs_composite = ci_onesection(ci->right);
        return;
    } else if (ci->right == NULL) {
        ci->secs_right = NULL;
        ci->secs_left = ci_onesection(ci->left);

        /* make a second list, not a pointer to the first
         * or we will get confused when deleting
         */
        ci->secs_composite = ci_onesection(ci->left);
        return;
    }

    /* we have two files - we need to compare them fully */
    ci_compare(ci);

    /* check if the composite list consists of one single section -
     * - if it does, and the files have a 'differ' state, then they
     * must differ in blanks only. Warn the user with a popup, and change
     * the tag text for the outline view. NB we should not need to
     * refresh the outline view since any action that gets this function
     * called will refresh the outline view anyway.
     */
    if (ci->state == STATE_DIFFER) {
        if (  (List_Card(ci->secs_composite) == 1)
              && (STATE_SAME==section_getstate(List_First(ci->secs_composite)))
           ) {
            windiff_UI(TRUE);
            MessageBox(hwndClient, LoadRcString(IDS_DIFF_BLANK_ONLY),
                       "Windiff", MB_ICONINFORMATION|MB_OK);
            windiff_UI(FALSE);

            if (ci->result != NULL) {
                gmem_free(hHeap, ci->result, lstrlen(ci->result)+1);
                ci->result = NULL;
            }
            ci->result = ci_copytext(LoadRcString(IDS_DIFF_BLANK_ONLY));
            // ci->state = STATE_SAME; // No-win situation, but better to leave as differs?
        } else ci->state = STATE_DIFFER;  /* could be that blanks option has
                                             changed and it was blanks only
                                             differ which now counts as different
                                          */
    }
} /* ci_makecomposite */

/*
 * we have two files - compare them and build a composite list.
 *
 * comparison method:
 *
 *    0   (and what makes it fast) break each file into lines and hash
 *        each line.  Lines which don't match can be rapidly eliminated
 *        by just comparing the hash code.  The hashing knows whether blanks
 *        are to be ignored or not.
 *
 *    1   (and what makes it really fast) Store the hash codes in a binary
 *        search tree that will give for each hash code the number of times
 *        that it occurred in each file and one of the lines where it occurred
 *        in each file.  The tree is used to rapidly find the partner
 *        of a line which occurs exactly once in each file.
 *
 *    2   make a section covering the whole file (for both)
 *        and link unique lines between these sections (i.e. link lines
 *        which occur exactly once in each file as they must match each other).
 *        These are referred to as anchor points.
 *
 *    3   build section lists for both files by traversing line lists and
 *        making a section for each set of adjacent lines that are unmatched
 *        and for each set of adjacent lines that match a set of adjacent
 *        lines in the other file.  In making a section we start from a
 *        known matching line and work both forwards and backwards through
 *        the file including lines which match, whether they are unique or not.
 *
 *    4   establish links between sections that match
 *        and also between sections that don't match but do
 *        correspond (by position in file between matching sections)
 *
 *    5   for each section pair that don't match but do correspond,
 *        link up matching lines unique within that section.  (i.e. do
 *        the whole algorithm again on just this section).
 *
 *    There may be some lines which occur many times over in each file.
 *    As these occurrences are matched up, so the number left to match
 *    reduces, and may reach one in each file.  At this point these two
 *    can be matched.  Therefore we...
 *
 *    repeat steps 1-5 until no more new links are added, but (especially
 *    in step 0) we only bother with lines which have not yet been matched.
 *    this means that a line which has only one unmatched instance in each
 *    file gets a count of one and so is a new anchor point.
 *
 *    ALGORITHM2
 *    After we have found all lines that match by the above, we see if there
 *    are any lines which occur MORE than once on each side which are still
 *    unmatched.  We then try matching the first occurrence on each side
 *    with each other.  However we only do this for lines longer than (arbitrarily)
 *    8 chars.  Matching lines that are just blank or } gives too many false hits.
 *    If this achieved anything, we go back to the previous
 *    uniqueness condition to see how much more progress we can make.  This is
 *    controlled by the TryDups logic at the end of the loop.
 *
 *    Finally build a composite list from the two lists of sections.
 */
void
ci_compare(COMPITEM ci)
{
    LIST lines_left, lines_right;
    SECTION whole_left, whole_right;
    BOOL bChanges;  /* loop control - we're still making more matches */
    BOOL bTryDups;  /* first try exact matches - then try matching non-unique ones too */
    extern BOOL Algorithm2;   /* declared in windiff.c */
#ifdef trace
    DWORD Ticks;        /* time for profiling */
    DWORD StartTicks;   /* time for profiling */
#endif
    /* get the list of lines for each file */
    lines_left = file_getlinelist(ci->left);
    lines_right = file_getlinelist(ci->right);

    if ((lines_left == NULL) || (lines_right == NULL)) {
        ci->secs_left = NULL;
        ci->secs_right = NULL;
        ci->secs_composite = NULL;
        return;
    }

    bTryDups = FALSE;

#ifdef trace
    StartTicks = GetTickCount();
    Ticks = StartTicks;
#endif
    do {

        /* we have made no changes so far this time round the
         * loop
         */
        bChanges = FALSE;

        /* make a section covering the whole file */
        whole_left = section_new(List_First(lines_left),
                                 List_Last(lines_left), NULL);

        whole_right = section_new(List_First(lines_right),
                                  List_Last(lines_right), NULL);

        /* link up matching unique lines between these sections */
        if (section_match(whole_left, whole_right, bTryDups)) {
            bChanges = TRUE;
        }

        /* delete the two temp sections */
        section_delete(whole_left);
        section_delete(whole_right);

        /* discard previous section lists if made */
        if (ci->secs_left) {
            section_deletelist(ci->secs_left);
            ci->secs_left = NULL;
        }
        if (ci->secs_right) {
            section_deletelist(ci->secs_right);
            ci->secs_right = NULL;
        }
        /* build new section lists for both files */
        ci->secs_left = section_makelist(lines_left, TRUE);
        ci->secs_right = section_makelist(lines_right, FALSE);

        /* match up sections - make links and corresponds between
         * sections. Attempts to section_match corresponding
         * sections that are not matched. returns true if any
         * further links were made
         */
        if (section_matchlists(ci->secs_left, ci->secs_right, bTryDups)) {
            bChanges = TRUE;
        }

#ifdef trace
        /* profiling */
        {   char Msg[80];
            DWORD tks = GetTickCount();
            wsprintf( Msg, "ci_compare loop %ld, total %d %s %s \n"
                      , tks-Ticks, tks-StartTicks
                      , (bChanges ? "Changes," : "No changes,")
                      , (bTryDups ? "Was trying dups." : "Was not trying dups.")
                    );
            Trace_File(Msg);
            Ticks = GetTickCount();
            /* correct for time spent profiling */
            StartTicks = StartTicks+Ticks-tks;
        }
#endif

        /* repeat as long as we keep adding new links */
        if (bChanges) bTryDups = FALSE;
        else if ((bTryDups==FALSE) & Algorithm2) {bTryDups = TRUE;
            bChanges = TRUE;  // at least one more go
        }


    } while (bChanges);

    /* all possible lines linked, and section lists made .
     * combine the two section lists to get a view of the
     * whole comparison - the composite section list. This also
     * sets the state of each section in the composite list.
     */
#ifdef trace
    StartTicks = GetTickCount();
#endif
    ci->secs_composite = section_makecomposite(ci->secs_left, ci->secs_right);
#ifdef trace
    Ticks = GetTickCount()-StartTicks;
    {   char Msg[80];
        wsprintf( Msg, "section_makecomposite time = %d\n", Ticks);
        Trace_File(Msg);
    }
#endif
}


void SetStateAndTag( COMPITEM ci, DIRITEM leftname, DIRITEM rightname, BOOL fExact)
{
    /* set the tag (title field) for this item. if the
     * two files have names that match, we use just that name -
     * otherwise we use both names separated by a colon 'left : right'.
     *
     * in both cases, use the names relative to compare root (the
     * names will certainly be different if we compare the abs paths)
     */
    LPSTR str1 = dir_getrelname(leftname);
    LPSTR str2 = dir_getrelname(rightname);
    char buf[2*MAX_PATH+20];
    TCHAR tmpbuf[MAX_PATH];

    /* if only one file - set name to that */
    if (ci->left == NULL) {
        ci->tag = ci_copytext(str2);
    } else if (ci->right == NULL) {
        ci->tag = ci_copytext(str1);
    } else {
        if (lstrcmpi(str1, str2) == 0) {
            ci->tag = ci_copytext(str2);
        } else {
            wsprintf(buf, "%s : %s", str1, str2);
            ci->tag = ci_copytext(buf);
        }
    }

    dir_freerelname(leftname, str1);
    dir_freerelname(rightname, str2);


    if (ci->left == NULL) {

        BOOL Readable = TRUE;
        // At this point we COULD try to set Readable but we would need
        // to do a rescan to ensure that sumvalid and fileerror are set.
        // where the file is only found on one side or the other, in the
        // interests of speed we have NOT TRIED to read the file.

        str1 = dir_getrootdescription(dir_getlist(rightname));
        lstrcpy(tmpbuf, (Readable ? TEXT("") : LoadRcString(IDS_UNREADABLE)));
        wsprintf(buf, LoadRcString(IDS_ONLY_IN), str1, tmpbuf);
        dir_freerootdescription(dir_getlist(rightname), str1);

        ci->result = ci_copytext(buf);
        ci->state = STATE_FILERIGHTONLY;
    } else if (ci->right == NULL) {

        BOOL Readable = TRUE;        // See above

        str1 = dir_getrootdescription(dir_getlist(leftname));
        lstrcpy(tmpbuf, (Readable ? TEXT("") : LoadRcString(IDS_UNREADABLE)));
        wsprintf(buf, LoadRcString(IDS_ONLY_IN), str1, tmpbuf);
        dir_freerootdescription(dir_getlist(leftname), str1);

        ci->result = ci_copytext(buf);
        ci->state = STATE_FILELEFTONLY;
    } else {
        /* two files - are they the same ? compare
         * the file sizes, and if necessary, checksums.
         * if the sizes differ, we don't need to checksum.
         */

        // if there is some error in the file, we can mark them
        // as differs and set the text to indicate that one or
        // both is unreadable.
        if (dir_fileerror(leftname)) {
            ci->state = STATE_DIFFER;
            if (dir_fileerror(rightname)) {
                ci->result = ci_copytext(LoadRcString(IDS_BOTH_UNREADABLE));
            } else {
                ci->result = ci_copytext(LoadRcString(IDS_LEFT_UNREADABLE));
            }
        } else if (dir_fileerror(rightname)) {
            ci->state = STATE_DIFFER;
            ci->result = ci_copytext(LoadRcString(IDS_RIGHT_UNREADABLE));
        }

        /* Subtle side-effects below us:
           dir_validchecksum merely tells us whether we have YET got a valid
           checksum for the file, NOT whether one is available if we tried.
           If !fExact then we don't WANT them, so we don't ask.
           If fExact then we must FIRST ask for the checksum and only after
           that enquire if one is valid.  (file read errors etc will mean that
           it is NOT valid).  dir_getchecksum has side effect of evaluating it
           if needed.  If it's by chance available, then we should use it, even
           if exact matching is not in operation.

           Where files differ we report which is earliest in time.

           The logic is as follows
                 sizes equal
               N     ?                  Y
                     |          both-sums-known
            differ   |          Y       ?      N
          (different |      sums-equal  |   exact
             sizes)  |     Y    ?  N    |  N  ?          Y
                     | identical|differ | same|   right-sum-valid
                     |          |       | size|  N   ?      Y
                     |          |       |     |right |  left-sum-valid
                     |          |       |     |un-   | N    ?      Y
                     |          |       |     |read- |left  |  sums-match
                     |          |       |     |able  |un-   |  N   ?   Y
                     |          |       |     |      |read- |differ|identical
                     |          |       |     |      |able  |      |
        */


        else if (dir_getfilesize(leftname) != dir_getfilesize(rightname)) {
            ci->state = STATE_DIFFER;
            ci->result = ci_AddTimeString(LoadRcString(IDS_DIFFERENT), ci, leftname, rightname);
        } else if (dir_validchecksum(leftname) && dir_validchecksum(rightname)) {
            if (dir_getchecksum(leftname) == dir_getchecksum(rightname)) {
                ci->result =  ci_copytext(LoadRcString(IDS_IDENTICAL));
                ci->state = STATE_SAME;
            } else {
                ci->result = ci_AddTimeString(LoadRcString(IDS_DIFFERENT), ci, leftname, rightname);
                ci->state = STATE_DIFFER;
            }
        } else if (!fExact) {
            ci->result = ci_AddTimeString(LoadRcString(IDS_SAME_SIZE), ci, leftname, rightname);
            ci->state = STATE_SAME;
        } else {
            DWORD LSum = dir_getchecksum(leftname);
            DWORD RSum = dir_getchecksum(rightname);

            if (!dir_validchecksum(rightname) ) {
                if (!dir_validchecksum(leftname) ) {
                    ci->result = ci_AddTimeString(LoadRcString(IDS_BOTH_UNREADABLE), ci, leftname, rightname);
                    ci->state = STATE_DIFFER;
                } else {
                    ci->result = ci_AddTimeString(LoadRcString(IDS_RIGHT_UNREADABLE), ci, leftname, rightname);
                    ci->state = STATE_DIFFER;
                }
            } else if (!dir_validchecksum(leftname) ) {
                ci->result = ci_AddTimeString(LoadRcString(IDS_LEFT_UNREADABLE), ci, leftname, rightname);
                ci->state = STATE_DIFFER;
            } else if (LSum!=RSum) {
                ci->result = ci_AddTimeString(LoadRcString(IDS_DIFFERENT), ci, leftname, rightname);
                ci->state = STATE_DIFFER;
            } else {
                ci->result =  ci_copytext(LoadRcString(IDS_IDENTICAL));
                ci->state = STATE_SAME;
            }
        }
    }
} /* SetStateAndTag */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\complist.c ===
/*
 * complist.c
 *
 * supports a list of compitems, where each compitem represents
 * a pair of matching files, or an unmatched file.
 *
 * We build lists of filenames from two pathnames (using the
 * scandir module) and then traverse the two lists comparing names.
 * Where the names match, we create a CompItem from the matching
 * names. Where there is an unmatched name, we create a compitem for it.
 *
 * we may also be asked to create a complist for two individual files:
 * here we create a single compitem for them as a matched pair even if
 * the names don't match.
 *
 * Geraint Davies, July 92
 */

#include <precomp.h>

#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"


#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "compitem.h"
#include "complist.h"
#include "view.h"
#include "slmmgr.h"

extern BOOL bAbort;             /* in windiff.c  Read only here */
#ifdef trace
extern bTrace;                  /* in windiff.c  Read only here */
#endif

/*
 * the COMPLIST handle is typedef-ed to be a pointer to one
 * of these struct complist
 */
struct complist {
    DIRLIST left;           /* left list of files */
    DIRLIST right;          /* right list of files */
    LIST items;             /* list of COMPITEMs */
};

/* ---- module-wide data -------------------------------------*/

/* data for communicating between the SaveList dlg and complist_savelist() */

char dlg_file[MAX_PATH];                /* filename to save to */
BOOL dlg_sums = TRUE;                           /* do we include sums ? */

// have we read the dialog names yet?
BOOL SeenDialogNames = FALSE;

/* checkbox options */
BOOL dlg_identical, dlg_differ, dlg_left, dlg_right;

/* data for Directory, SaveList and Remote dialog box */
char dialog_leftname[MAX_PATH];
char dialog_rightname[MAX_PATH];
char dialog_servername[80];
BOOL dialog_recursive;             // do whole tree
BOOL dialog_fastscan;              // times and sizes only, no checksums
BOOL dialog_autocopy;              // copy to update local directory

BOOL dialog_bothremote;

/*
 * data used by dodlg_copyfiles
 */
UINT dlg_options;
BOOL dlg_IgnoreMarks;
BOOL dlg_IgnoreAttributes;
char dlg_root[MAX_PATH];

/*------------------------timing for performance measurements-----------------*/
static DWORD TickCount;         /* time operation started, then time taken*/


/* --- forward declaration of internal functions ----------------------------*/
INT_PTR CALLBACK complist_dodlg_savelist(HWND hDlg, UINT message,
                                       WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK complist_dodlg_copyfiles(HWND hDlg, UINT message,
                                       WPARAM wParam, LPARAM lParam);
BOOL             complist_match(COMPLIST cl, VIEW view, BOOL fDeep, BOOL fExact);
COMPLIST         complist_new(void);
INT_PTR CALLBACK complist_dodlg_dir(HWND hDlg, unsigned message,
                                       WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK complist_dodlg_remote(HWND hDlg, unsigned message,
                                       WPARAM wParam, LPARAM lParam);



/* --- external functions ----------------------------------- */


/*
 * query the user to select two files, then build the list from
 * these files.
 */
COMPLIST
complist_filedialog(VIEW view)
{
    COMPLIST cl = NULL;
    char szPath1[MAX_PATH * 2];
    char szPath2[MAX_PATH * 2];
    char fname[MAX_PATH], FileExt[5], FileOpenSpec[15];

    SLM_FreeAll();

    /* ask for the filenames - using gfile standard dialogs */
    lstrcpy(FileExt, ".c");
    lstrcpy(FileOpenSpec, "*.*");

    if (!gfile_open(hwndClient, LoadRcString(IDS_SELECT_FIRST_FILE), FileExt, FileOpenSpec, szPath1, NUMELMS(szPath1), fname) ){
        goto LError;
    }

    if (!gfile_open(hwndClient, LoadRcString(IDS_SELECT_SECOND_FILE), FileExt, FileOpenSpec, szPath2, NUMELMS(szPath2), fname) ){
        goto LError;
    }

    /* alloc a new structure */
    cl = complist_new();

    cl->left = dir_buildlist(szPath1, FALSE, TRUE);
    cl->right = dir_buildlist(szPath2, FALSE, TRUE);


    /* register with the view (must be done after the list is non-null) */
    view_setcomplist(view, cl);

    complist_match(cl, view, FALSE, TRUE);

LError:
    SLM_FreeAll();
    return(cl);
}/* complist_filedialog */


void
complist_setdialogdefault(
                         LPSTR left,
                         LPSTR right,
                         BOOL fDeep)
{
    dialog_recursive = fDeep;

    ZeroMemory(dialog_leftname, sizeof(dialog_leftname));
    strncat(dialog_leftname, left, sizeof(dialog_leftname)-1);

    ZeroMemory(dialog_rightname, sizeof(dialog_rightname));
    strncat(dialog_rightname, right, sizeof(dialog_rightname));

    SeenDialogNames = TRUE;
}


/* build a new complist by querying the user for two directory
 * names and scanning those in parallel.
 *
 * names that match in the same directory will be paired. unmatched
 * names will go in a compitem on their own.
 */
COMPLIST
complist_dirdialog(VIEW view)
{
    //DLGPROC lpProc;
    BOOL fOK;

    SLM_FreeAll();

    /* put up a dialog for the two pathnames */
    //lpProc = (DLGPROC)MakeProcInstance((WINPROCTYPE)complist_dodlg_dir, hInst);
    windiff_UI(TRUE);
    //fOK = (BOOL)DialogBox(hInst, "Directory", hwndClient, lpProc);
    fOK = (BOOL)DialogBox(hInst, "Directory", hwndClient, complist_dodlg_dir);
    windiff_UI(FALSE);
    //FreeProcInstance(lpProc);

    if (!fOK) {
        SLM_FreeAll();
        return(NULL);
    }

    return complist_args( dialog_leftname, dialog_rightname
                          , view, dialog_recursive );
} /* complist_dirdialog */

#ifdef REMOTE_SERVER
/*
 * check a pathname to see if it is the form \\server!path, and if so,
 * separate out the server and the path portions. returns TRUE if
 * it is \\server!path or FALSE otherwise
 *
 * We assume that no server name contains ! - so if the first characters
 * are \\ and there is a ! before any more \ (ie before the share name),
 * then it must be a checksum server name. Note that the pathname may be
 * a UNC name or relative to the checksum server.
 */
BOOL
IsChecksumServerPath(LPSTR pSrc, LPSTR server, LPSTR serverpath)
{
    LPSTR pPling;
    LPSTR pShareStart;

    /*
     * must be at least \\x!x - ie 5 chars long
     */
    if (lstrlen(pSrc) < 5) {
        return(FALSE);
    }

    /*
     * does it begin \\
     */
    if ( (pSrc[0] != '\\') || (pSrc[1] != '\\')) {
        return(FALSE);
    }

    /*
     * the ! must be part of the server name - ie must be before the third
     * backslash.
     */
    pPling = My_mbschr(pSrc, '!');
    pShareStart = My_mbschr(&pSrc[2], '\\');

    if ((pPling == NULL) || ((pShareStart != NULL) && (pShareStart < pPling))) {

        return(FALSE);
    }

    /*
     * copy over the server and pathname portions into separate strings
     */
    My_mbsncpy(server, &pSrc[2], (int)(pPling - &pSrc[2]));
    server[pPling - &pSrc[2]] = '\0';
    lstrcpy(serverpath, pPling+1);

    return(TRUE);
}
#endif
/*
 * given two pathname strings, scan the directories and traverse them
 * in parallel comparing matching names.
 */
COMPLIST
complist_args(LPSTR p1, LPSTR p2, VIEW view, BOOL fDeep)
{
    COMPLIST cl;
    char msg[MAX_PATH+20];
#ifdef REMOTE_SERVER
    char server[32];
    char serverpath[MAX_PATH];
#endif

    /* alloc a new complist */
    cl = complist_new();

    //
    // accept \\server!path for a checksum server and
    // pathname - assumes no \\server\share names have !
    // within the server name.
#ifdef REMOTE_SERVER
    if (IsChecksumServerPath(p1, server, serverpath)) {
        cl->left = dir_buildremote(server, serverpath, TRUE, TRUE, fDeep);
    } else 
#endif
    {
        cl->left = dir_buildlist(p1, FALSE, TRUE);
    }
    /* check that we could find the paths, and report if not */
    if (cl->left == NULL) {
        wsprintf(msg, LoadRcString(IDS_COULDNT_FIND), p1);
        TRACE_ERROR(msg, FALSE);
        complist_delete(cl);
        cl = NULL;
        goto LError;
    }
#ifdef REMOTE_SERVER
    if (IsChecksumServerPath(p2, server, serverpath)) {
        cl->right = dir_buildremote(server, serverpath, TRUE, TRUE, fDeep);
    } else 
#endif
    {
        cl->right = dir_buildlist(p2, FALSE, TRUE);
    }
    /* check that we could find the paths, and report if not */
    if (cl->right == NULL) {
        wsprintf(msg, LoadRcString(IDS_COULDNT_FIND), p2);
        TRACE_ERROR(msg, FALSE);
        complist_delete(cl);
        cl = NULL;
        goto LError;
    }

    if (!TrackLeftOnly) {
        dir_setotherdirlist(cl->left, cl->right);
    }
    if (!TrackRightOnly) {
        dir_setotherdirlist(cl->right, cl->left);
    }
    {
        // remember these paths as defaults for the next dialog -
        // get the normalised, absolute paths
        LPSTR pleft = dir_getrootdescription(cl->left);
        LPSTR pright = dir_getrootdescription(cl->right);
        complist_setdialogdefault(pleft, pright, fDeep);
        dir_freerootdescription(cl->left, pleft);
        dir_freerootdescription(cl->right, pright);
    }


    /* register with the view (must be done after building lists) */
    view_setcomplist(view, cl);

    complist_match(cl, view, fDeep, TRUE);

LError:
    SLM_FreeAll();
    return(cl);
} /* complist_args */

/*
 * given two pathname strings, scan the directories and traverse them
 * in parallel comparing matching names.
 */
void
complist_append(COMPLIST *pcl, LPCSTR p1, LPCSTR p2, int *psequence)
{
    COMPLIST cl;

    if (!*pcl)
    {
        /* alloc a new complist */
        *pcl = complist_new();
    }
    cl = *pcl;

    dir_appendlist(&cl->left, p1, FALSE, psequence);
    dir_appendlist(&cl->right, p2, FALSE, psequence);
} /* complist_append */

/*
 * finished appending files -- set custom descriptions (instead of calculating
 * them based on directory names), register with view, and match the left and
 * right sides of the complist.
 */
BOOL
complist_appendfinished(COMPLIST *pcl, LPCSTR pszLeft, LPCSTR pszRight, VIEW view)
{
    BOOL fSuccess = FALSE;
    COMPLIST cl;
    char msg[MAX_PATH+20] = {0};

    if (!*pcl)
        goto LError;

    cl = *pcl;
    if (!cl->left || !cl->right)
    {
        strncat(msg, LoadRcString(IDS_COULDNT_FIND_ANYTHING), sizeof(msg)-1);
        TRACE_ERROR(msg, FALSE);
        goto LError;
    }

    dir_setdescription(cl->left, pszLeft);
    dir_setdescription(cl->right, pszRight);

    if (!TrackLeftOnly)
        dir_setotherdirlist(cl->left, cl->right);
    if (!TrackRightOnly)
        dir_setotherdirlist(cl->right, cl->left);

    /* register with the view (must be done after building lists) */
    view_setcomplist(view, cl);

    complist_match(cl, view, FALSE, TRUE);

    fSuccess = TRUE;

LError:
    SLM_FreeAll();
    return fSuccess;
}

#ifdef REMOTE_SERVER
/*
 * complist_remote
 *
 * ask the user for a servername, remote and local paths. Use
 * dir_buildremote to build a list of remote files, and
 * use dir_buildlist to build the local list. Then match up
 * names in the two directories and make compitems for each
 * matching name using complist_match
 *
 * if server is not null, then use server, remote and local instead
 * of putting up the dialog.
 *
 * this functionality is not in the WIN 3.1 version of the code
 * because we use named pipes to communicate to a server.
 */
COMPLIST
complist_remote(LPSTR server, LPSTR remote, LPSTR local, VIEW view, BOOL fDeep)
{
    //DLGPROC lpProc;
    BOOL fOK;
    COMPLIST cl;
    char msg[MAX_PATH+20];
    BOOL FastScan= FALSE;
    BOOL AutoCopy= FALSE;
    BOOL fBothRemote = FALSE;

    SLM_FreeAll();

    if (server == NULL) {
        /* put up a dialog for the two pathnames */
        //lpProc = (DLGPROC)MakeProcInstance((WINPROCTYPE)complist_dodlg_remote, hInst);
        windiff_UI(TRUE);
        //fOK = (BOOL)DialogBox(hInst, "Remote", hwndClient, lpProc);
        fOK = (BOOL)DialogBox(hInst, "Remote", hwndClient, complist_dodlg_remote);
        windiff_UI(FALSE);
        //FreeProcInstance(lpProc);

        if (!fOK) {
            return(NULL);
        }
        server = dialog_servername;
        remote = dialog_leftname;
        local = dialog_rightname;
        fDeep = dialog_recursive;
        FastScan = dialog_fastscan;
        AutoCopy = dialog_autocopy;
        fBothRemote = dialog_bothremote;
    }

    /* alloc a new complist */
    cl = complist_new();

    cl->left = dir_buildremote(server, remote, !FastScan, TRUE, fDeep);
    if (cl->left == NULL) {
        /* dialog already put up by dir_buildremote */
        return(NULL);
    }
    if (fBothRemote) {
        cl->right = dir_buildremote(server, local, !FastScan, TRUE, fDeep);
    } else {
        cl->right = dir_buildlist(local, !FastScan, TRUE);
    }
    if (cl->right == NULL) {
        wsprintf(msg, LoadRcString(IDS_COULDNT_FIND), local);
        TRACE_ERROR(msg, FALSE);
        return(NULL);
    }

    /* register with view */
    view_setcomplist(view, cl);

    compitem_SetCopyPaths( dir_getrootpath(cl->left)
                           , dir_getrootpath(cl->right) );

    complist_match(cl, view, fDeep, !FastScan);

    SLM_FreeAll();

    if (AutoCopy) {
        complist_copyfiles( cl
                            , local
                            , COPY_FROMLEFT|INCLUDE_LEFTONLY|INCLUDE_DIFFER
                            |COPY_HITREADONLY
                          );
    }
    Trace_Unattended(FALSE);

    return(cl);
} /* complist_remote */

#endif

/*
 * return a handle to the list of compitems in this complist
 */
LIST
complist_getitems(COMPLIST cl)
{
    if (cl == NULL) {
        return(NULL);
    }

    return(cl->items);
}


/* delete a complist and all associated compitems and dirlists
 */
void
complist_delete(COMPLIST cl)
{
    COMPITEM item;

    if (cl == NULL) {
        return;
    }

    /* delete the two directory scan lists */
    dir_delete(cl->left);
    dir_delete(cl->right);

    /* delete the compitems in the list */
    List_TRAVERSE(cl->items, item) {
        compitem_delete(item);
    }

    /* delete the list itself */
    List_Destroy(&cl->items);

    gmem_free(hHeap, (LPSTR) cl, sizeof(struct complist));

}

/*
 * write out to a text file the list of compitems as relative filenames
 * one per line.
 *
 * if savename is non-null, use this as the filename for output. otherwise
 * query the user via a dialog for the filename and include options.
 *
 * There are hidden parameters (dlg_sums etc) from the dialog.
 * Note that we never attempt to recalculate sums.
 */
void
complist_savelist(COMPLIST cl, LPSTR savename, UINT options)
{
    //DLGPROC lpProc;
    static BOOL done_init = FALSE;
    BOOL bOK;
    HANDLE fh;
    DWORD cbWritten;
    int state;
    char msg[2*MAX_PATH+100] = {0};
    HCURSOR hcurs;
    COMPITEM ci;
    LPSTR pstr, lhead;
    int nFiles = 0;

    if (!done_init) {
        /* init the options once round - but keep the same options
         * for the rest of the session.
         */

        /* first init default options */
        dlg_identical = (outline_include & INCLUDE_SAME);
        dlg_differ = (outline_include & INCLUDE_LEFTONLY);
        dlg_left = (outline_include & INCLUDE_RIGHTONLY);
        dlg_right = (outline_include & INCLUDE_DIFFER);
        dlg_IgnoreMarks = hide_markedfiles;

        dlg_file[0] = '\0';

        done_init = TRUE;
    }

    if (cl == NULL) {
        return;
    }

    if (savename == NULL) {

        /* store the left and right rootnames so that dodlg_savelist
         * can display them in the dialog.
         */
        pstr = dir_getrootdescription(cl->left);
        lstrcpy(dialog_leftname, pstr);
        dir_freerootdescription(cl->left, pstr);

        pstr = dir_getrootdescription(cl->right);
        lstrcpy(dialog_rightname, pstr);
        dir_freerootdescription(cl->right, pstr);


        //lpProc = (DLGPROC)MakeProcInstance((WINPROCTYPE)complist_dodlg_savelist, hInst);
        windiff_UI(TRUE);
        //bOK = (BOOL)DialogBox(hInst, "SaveList", hwndClient, lpProc);
        bOK = (BOOL)DialogBox(hInst, "SaveList", hwndClient, complist_dodlg_savelist);
        windiff_UI(FALSE);
        //FreeProcInstance(lpProc);

        if (!bOK) {
            /* user cancelled from dialog box */
            return;
        }
        savename = dlg_file;

    } else {
        dlg_identical = (options & INCLUDE_SAME);
        dlg_differ = (options & INCLUDE_DIFFER);
        dlg_left = (options & INCLUDE_LEFTONLY);
        dlg_right = (options & INCLUDE_RIGHTONLY);

        /* no harm done if the following call fails */
        GetFullPathName(savename, sizeof(dlg_file), dlg_file, NULL);
    }


    /* try to open the file */
    fh = CreateFile(savename, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
    if (fh == INVALID_HANDLE_VALUE) {
        wsprintf(msg, LoadRcString(IDS_CANT_OPEN), savename);
        windiff_UI(TRUE);
        MessageBox(hwndClient, msg, "Windiff", MB_ICONSTOP|MB_OK);
        windiff_UI(FALSE);
        return;
    }

    hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /* write out the header line */
    lhead = complist_getdescription(cl);
    {
        TCHAR szBuf1[20],szBuf2[20],szBuf3[20],szBuf4[20];
        lstrcpy(szBuf1,(LPSTR)(dlg_identical ? LoadRcString(IDS_IDENTICAL_COMMA) : ""));
        lstrcpy(szBuf2,(LPSTR)(dlg_left ? LoadRcString(IDS_LEFT_ONLY_COMMA) : ""));
        lstrcpy(szBuf3,(LPSTR)(dlg_right ? LoadRcString(IDS_RIGHT_ONLY_COMMA) : ""));
        lstrcpy(szBuf4,(LPSTR)(dlg_differ ? LoadRcString(IDS_DIFFERING) : ""));
        wsprintf(msg, LoadRcString(IDS_HEADER_LINE_STR),
                lhead, szBuf1, szBuf2, szBuf3, szBuf4);
    }
    WriteFile(fh, msg, lstrlen(msg), &cbWritten, NULL);
    complist_freedescription(cl, lhead);


    /* traverse the list of compitems looking for the
     * ones we are supposed to include
     */
    List_TRAVERSE(cl->items, ci) {

        /* check if files of this type are to be listed */
        state = compitem_getstate(ci);

        if ((state == STATE_SAME) && (!dlg_identical)) {
            continue;
        } else if ((state == STATE_DIFFER) && (!dlg_differ)) {
            continue;
        } else if ((state == STATE_FILELEFTONLY) && (!dlg_left)) {
            continue;
        } else if ((state == STATE_FILERIGHTONLY) && (!dlg_right)) {
            continue;
        }
        if (dlg_IgnoreMarks && compitem_getmark(ci)) {
            continue;
        }

        nFiles++;

        /* output the list line */
        ZeroMemory(msg, sizeof(msg));
        strncat(msg, compitem_gettext_tag(ci), sizeof(msg) - 1);
        WriteFile(fh, msg, lstrlen(msg), &cbWritten, NULL);

        /* write out the result of the comparison */
        {       LPSTR p;
            p = compitem_gettext_result(ci);
            wsprintf( msg, "\t%s"
                      , p ? p : "windiff error"
                    );
        }
        WriteFile(fh, msg, lstrlen(msg), &cbWritten, NULL);

        if (dlg_sums) {
            if (compitem_getleftfile(ci) != NULL) {
                BOOL bValid;
                DWORD cksum;
                cksum = file_retrievechecksum(compitem_getleftfile(ci),&bValid);

                if (bValid) wsprintf(msg, "\t%8lx", cksum);
                else wsprintf(msg, "\t????????");
            } else {
                wsprintf(msg, "\t--------");
            }
            WriteFile(fh, msg, lstrlen(msg), &cbWritten, NULL);

            if (compitem_getrightfile(ci) != NULL) {
                BOOL bValid;
                DWORD cksum;
                cksum = file_retrievechecksum(compitem_getrightfile(ci),&bValid);
                if (bValid) wsprintf(msg, "\t%8lx", cksum);
                else wsprintf(msg, "\t????????");
            } else {
                wsprintf(msg, "\t--------");
            }
            WriteFile(fh, msg, lstrlen(msg), &cbWritten, NULL);

        }

        wsprintf(msg, "\r\n");
        WriteFile(fh, msg, strlen(msg), &cbWritten, NULL);
    }

    /* write tail line */
    wsprintf(msg, LoadRcString(IDS_FILES_LISTED), nFiles);
    WriteFile(fh, msg, lstrlen(msg), &cbWritten, NULL);

    /* - close file and we are finished */
    CloseHandle(fh);

    SetCursor(hcurs);
} /* complist_savelist */

/*
 * copy files to a new directory newroot. if newroot is NULL, query the user
 * via a dialog to get the new dir name and options.
 *
 * options are either COPY_FROMLEFT or COPY_FROMRIGHT (indicating which
 * tree is to be the source of the files, plus any or all of
 * INCLUDE_SAME, INCLUDE_DIFFER and INCLUDE_LEFT (INCLUDE_LEFT
 * and INCLUDE_RIGHT are treated the same here since the COPY_FROM* option
 * indicates which side to copy from).
 */
void
complist_copyfiles(COMPLIST cl, LPSTR newroot, UINT options)
{
    int nFiles = 0;
    int nFails = 0;
    static BOOL done_init = FALSE;
    LPSTR pstr;
    char buffer[MAX_PATH+20];
    DIRITEM diritem;
    //DLGPROC lpProc;
    BOOL bOK;
    COMPITEM ci;
    int state;
    BOOL HitReadOnly = ((options&COPY_HITREADONLY)==COPY_HITREADONLY);
    BOOL CopyNoAttributes;

    if (!done_init) {
        /*
         * one-time initialisation of dialog defaults
         */
        dlg_options = COPY_FROMLEFT|INCLUDE_LEFTONLY|INCLUDE_DIFFER;
        dlg_root[0] = '\0';

        // set the ignore-marked files option by default the same
        // as the hide mark files menu option. If he doesn't want them
        // visible, he probably doesn't want them copied.
        dlg_IgnoreMarks = hide_markedfiles;

        done_init = TRUE;
    }

    if (cl == NULL) {
        return;
    }


    if (newroot == NULL) {
        /*
         * put up dialog to query rootname and options
         */

        /* store the left and right rootnames so that the dlg proc
         * can display them in the dialog.
         */
        pstr = dir_getrootdescription(cl->left);
        lstrcpy(dialog_leftname, pstr);
        dir_freerootdescription(cl->left, pstr);

        pstr = dir_getrootdescription(cl->right);
        lstrcpy(dialog_rightname, pstr);
        dir_freerootdescription(cl->right, pstr);


        do {
            //lpProc = (DLGPROC)MakeProcInstance((WINPROCTYPE)complist_dodlg_copyfiles, hInst);
            windiff_UI(TRUE);
            //bOK = (BOOL)DialogBox(hInst, "CopyFiles", hwndClient, lpProc);
            bOK = (BOOL)DialogBox(hInst, "CopyFiles", hwndClient, complist_dodlg_copyfiles);
            windiff_UI(FALSE);
            //FreeProcInstance(lpProc);

            if (!bOK) {
                /* user cancelled from dialog box */
                return;
            }
            if (lstrlen(dlg_root) == 0) {
                windiff_UI(TRUE);
                MessageBox( hwndClient, LoadRcString(IDS_ENTER_DIR_NAME),
                            "Windiff", MB_ICONSTOP|MB_OK);
                windiff_UI(FALSE);
            }
        } while (lstrlen(dlg_root) == 0);

    } else {
        // no dialog - all options passed in (eg from command line).
        // note that in this case the dlg_IgnoreMarks is left as
        // whatever the hide_markedfiles menu option is set to.
        dlg_options = options;
        lstrcpy(dlg_root, newroot);
    }

    TickCount = GetTickCount();

    /* this relies on the sumserver, server and share (if any) being the same for
       all the things on the list.  We set up the first one and then just check
       that it doesn't change (within ss_client).  If it turns out to be a local
       copy these things turn into no-ops somewhere below us.
    */
    if (dlg_options & COPY_FROMLEFT) {
        if (!dir_startcopy(cl->left))
            return;
    } else {
        if (!dir_startcopy(cl->right))
            return;
    }

    CopyNoAttributes = dlg_IgnoreAttributes;

    /*
     * traverse the list of compitems copying files as necessary
     */
    List_TRAVERSE(cl->items, ci) {

        if (bAbort) {
            // buffer[0] = "Copy aborted";
            // SetStatus(buffer);
            // ss_abortcopy(); ???
            break;  /* fall into end_copy processing */
        }

        // ignore marked files totally if the option was
        // set in the dialog.
        if (dlg_IgnoreMarks && compitem_getmark(ci)) {
            continue;
        }

        /* check if files of this type are to be copied */
        state = compitem_getstate(ci);

        if ((state == STATE_SAME) && !(dlg_options & INCLUDE_SAME)) {
            continue;
        } else if ((state == STATE_DIFFER) && !(dlg_options & INCLUDE_DIFFER)) {
            continue;
        } else if (state == STATE_FILELEFTONLY) {
            if (dlg_options & COPY_FROMRIGHT) {
                continue;
            }
            if ((dlg_options & (INCLUDE_LEFTONLY | INCLUDE_RIGHTONLY)) == 0) {
                continue;
            }
        } else if (state == STATE_FILERIGHTONLY) {
            if (dlg_options & COPY_FROMLEFT) {
                continue;
            }
            if ((dlg_options & (INCLUDE_LEFTONLY | INCLUDE_RIGHTONLY)) == 0) {
                continue;
            }
        }

        if (dlg_options & COPY_FROMLEFT) {
            diritem = file_getdiritem(compitem_getleftfile(ci));
        } else {
            diritem = file_getdiritem(compitem_getrightfile(ci));
        }

        /*
         * copy the file to the new root directory
         */
        if (dir_copy(diritem, dlg_root, HitReadOnly, CopyNoAttributes) == FALSE) {
            nFails++;
            pstr = dir_getrelname(diritem);
            wsprintf(buffer, LoadRcString(IDS_FAILED_TO_COPY), pstr);
            dir_freerelname(diritem, pstr);

            if (!TRACE_ERROR(buffer, TRUE)) {
                /* user pressed cancel - abort current operation*/
                /* fall through to end-copy processing */
                break;
            }

        } else {
            nFiles++;
        }

        wsprintf(buffer, LoadRcString(IDS_COPYING), nFiles);
        SetStatus(buffer);


        /*
         * allow user interface to continue
         */
        if (Poll()) {
            /* abort requested */
            TickCount = GetTickCount()-TickCount;
            windiff_UI(TRUE);
            MessageBox(hwndClient, LoadRcString(IDS_COPY_ABORTED),
                       "WinDiff", MB_OK|MB_ICONINFORMATION);
            windiff_UI(FALSE);
            break;
        }

    } /* traverse */
    wsprintf(buffer, LoadRcString(IDS_COPYING_NFILES), nFiles);
    SetStatus(buffer);
    if (dlg_options & COPY_FROMLEFT) {
        nFails = dir_endcopy(cl->left);
    } else {
        nFails = dir_endcopy(cl->right);
    }
    TickCount = GetTickCount()-TickCount;

    if (nFails<0) {
        wsprintf(buffer, LoadRcString(IDS_COPY_FAILED), -nFails);
    } else {
        wsprintf(buffer, LoadRcString(IDS_COPY_COMPLETE), nFails);
    }
    windiff_UI(TRUE);
    MessageBox(hwndClient, buffer, "WinDiff", MB_OK|MB_ICONINFORMATION);
    windiff_UI(FALSE);

    buffer[0] = '\0';
    SetStatus(buffer);
} /* complist_copyfiles */


/*
 * complist_togglemark
 *
 * each compitem has a BOOL mark state. This function inverts the value of
 * this state for each compitem in the list.
 */
void
complist_togglemark(COMPLIST cl)
{
    COMPITEM ci;

    if (cl == NULL) {
        return;
    }


    /*
     * traverse the list of compitems copying files as necessary
     */
    List_TRAVERSE(cl->items, ci) {

        compitem_setmark(ci, !compitem_getmark(ci));

    }
}

/*
 * complist_itemcount
 *
 * return the number of items in the list
 */
UINT
complist_itemcount(COMPLIST cl)
{
    UINT n = 0;

    if (cl == NULL) {
        return 0;
    }

    /*
     * return the number of compitems in the list
     */
    return List_Card(cl->items);
}

#ifdef USE_REGEXP
    #include "regexp.h"

/*
 * query the user for a pattern to match.
 * all compitems with this pattern in their tag string will be
 * marked (the mark state will be set to TRUE);
 *
 * returns TRUE if any states changed
 */
BOOL
complist_markpattern(COMPLIST cl)
{
    COMPITEM ci;
    char achPattern[MAX_PATH];
    BOOL bOK = FALSE;
    LPSTR ptag;

    regexp  *prog;
    static  char    previous_pat[MAX_PATH]; /* allow for a big pattern ! */
    static  BOOL    fInit = TRUE;
    TCHAR   szBuff[40];

    lstrcpy(szBuff,LoadRcString(IDS_MARK_FILES));

    windiff_UI(TRUE);
    if ( fInit ) {
        GetProfileString(APPNAME, "Pattern", "\\.obj$", previous_pat, sizeof(previous_pat) / sizeof(previous_pat[0]));
        fInit = FALSE;
    }

    bOK = StringInput(achPattern, sizeof(achPattern),
                      LoadRcString(IDS_ENTER_SUBSTRING1),
                      szBuff, previous_pat );
    windiff_UI(FALSE);

    if (!bOK) {
        return(FALSE);
    }

    /*
    ** Compile the specified regular expression
    */
    if ((prog = regcomp(achPattern)) == NULL) {
        // printf("Invalid search string");
        return(FALSE);
    }

    /*
    ** only overwrite previous pattern with a known good pattern
    */
    strcpy( previous_pat, achPattern );
    WriteProfileString(APPNAME, "Pattern", previous_pat);

    bOK = FALSE;

    if (cl) {
        List_TRAVERSE(cl->items, ci) {
            ptag = compitem_gettext_tag(ci);
            if ( regexec( prog, ptag, 0 ) ) {  /* got a match */
                if (!compitem_getmark(ci)) {
                    bOK = TRUE;
                    compitem_setmark(ci, TRUE);
                }
            }
        }
    }

    /*
    ** regcomp allocates storage with malloc, now is a good time to free
    ** this storage as we have finished with the program.
    */
    free( prog );

    return(bOK);
}

/*
 * here would go a message box saying that the regexp fail for some reason.
 *
 */
void regerror( char *err )
{
    // printf( "%s\n", err );
}

#else

/*
 * query the user for a pattern to match.
 * all compitems with this pattern in their tag string will be
 * marked (the mark state will be set to TRUE);
 *
 * returns TRUE if any states changed
 */
BOOL
complist_markpattern(COMPLIST cl)
{
    COMPITEM ci;
    char achPattern[MAX_PATH];
    BOOL bOK = FALSE;
    LPSTR ptag;
    TCHAR   szBuff[40];

    lstrcpy(szBuff,LoadRcString(IDS_MARK_FILES));

    windiff_UI(TRUE);
    bOK = StringInput(achPattern, sizeof(achPattern), LoadRcString(IDS_ENTER_SUBSTRING2),
            szBuff, "obj");
    windiff_UI(FALSE);

    if (!bOK) {
        return(FALSE);
    }

    bOK = FALSE;

    List_TRAVERSE(cl->items, ci) {
        ptag = compitem_gettext_tag(ci);
        if (strstr(ptag, achPattern) != NULL) {
            if (!compitem_getmark(ci)) {
                bOK = TRUE;
                compitem_setmark(ci, TRUE);
            }

        }
    }

    return(bOK);
}
#endif



/*
 * return a description string for this complist, using
 * the rootdescription for each of the two paths
 */
LPSTR
complist_getdescription(COMPLIST cl)
{
    LPSTR pl;
    LPSTR pr;
    LPSTR desc = 0;


    pl = dir_getrootdescription(cl->left);
    pr = dir_getrootdescription(cl->right);

    if (pl && pr)
    {
        /*
         * allow for space-colon-space and null when sizing
         */
        desc = gmem_get(hHeap, lstrlen(pl) + lstrlen(pr) + 4);
        wsprintf(desc, "%s : %s", pl, pr);
    }

    dir_freerootdescription(cl->left, pl);
    dir_freerootdescription(cl->right, pr);

    return(desc);
}


/*
 *  free up a description string obtained from complist_getdescription
 */
void
complist_freedescription(COMPLIST cl, LPSTR desc)
{
    // remember the null
    gmem_free(hHeap, desc, lstrlen(desc)+1);
}





/* --- internal functions --------------------------------------------*/

/*
 * match up two lists of filenames
 *
 * we can find out from the DIRLIST handle whether the original list
 * was a file or a directory name.
 * If the user typed:
 *      two file names  - match these two item even if the names differ
 *
 *      two dirs        - match only those items whose names match
 *
 *      one file and one dir
 *                      - try to find a file of that name in the dir.
 *
 * returns TRUE if the complist_match was ok, or FALSE if it was
 * aborted in some way.
 */
BOOL
complist_match(COMPLIST cl, VIEW view, BOOL fDeep, BOOL fExact)
{
    LPSTR lname;
    LPSTR rname;
    DIRITEM leftitem, rightitem;
    DIRITEM nextitem;
    int cmpvalue;

    TickCount = GetTickCount();

    if (dir_isfile(cl->left) ) {

        if (dir_isfile(cl->right)) {
            /* two files */

            /* there should be one item in each list - make
             * a compitem by matching these two and append it to the
             * list
             */
            compitem_new(dir_firstitem(cl->left),
                         dir_firstitem(cl->right),
                         cl->items, fExact);

            view_newitem(view);

            TickCount = GetTickCount() - TickCount;
            return TRUE;
        }
        /* left is file, right is dir */
        leftitem = dir_firstitem(cl->left);
        rightitem = dir_firstitem(cl->right);
        lname = dir_getrelname(leftitem);
        while (rightitem != NULL) {
            rname = dir_getrelname(rightitem);
            cmpvalue = lstrcmpi(lname, rname);
            dir_freerelname(rightitem, rname);

            if (cmpvalue == 0) {
                /* this is the match */
                compitem_new( leftitem, rightitem
                              , cl->items, fExact);
                view_newitem(view);

                dir_freerelname(leftitem, lname);

                TickCount = GetTickCount() - TickCount;
                return(TRUE);
            }

            rightitem = dir_nextitem(cl->right, rightitem, fDeep);
        }
        /* not found */
        dir_freerelname(leftitem, lname);
        compitem_new(leftitem, NULL, cl->items, fExact);
        view_newitem(view);
        TickCount = GetTickCount() - TickCount;
        return(TRUE);

    } else if (dir_isfile(cl->right)) {

        /* left is dir, right is file */

        /* loop through the left dir, looking for
         * a file that has the same name as rightitem
         */

        leftitem = dir_firstitem(cl->left);
        rightitem = dir_firstitem(cl->right);
        rname = dir_getrelname(rightitem);
        while (leftitem != NULL) {
            lname = dir_getrelname(leftitem);
            cmpvalue = lstrcmpi(lname, rname);
            dir_freerelname(leftitem, lname);

            if (cmpvalue == 0) {
                /* this is the match */
                compitem_new(leftitem, rightitem
                             , cl->items, fExact);
                view_newitem(view);

                dir_freerelname(rightitem, rname);

                TickCount = GetTickCount() - TickCount;
                return(TRUE);
            }

            leftitem = dir_nextitem(cl->left, leftitem, fDeep);
        }
        /* not found */
        dir_freerelname(rightitem, rname);
        compitem_new(NULL, rightitem, cl->items, fExact);
        view_newitem(view);
        TickCount = GetTickCount() - TickCount;
        return(TRUE);
    }

    /* two directories */

    /* traverse the two lists in parallel comparing the relative names*/

    leftitem = dir_firstitem(cl->left);
    rightitem = dir_firstitem(cl->right);
    while ((leftitem != NULL) && (rightitem != NULL)) {

        lname = dir_getrelname(leftitem);
        rname = dir_getrelname(rightitem);
        if (!dir_compsequencenumber(leftitem, rightitem, &cmpvalue))
        {
            if (dir_iswildcard(cl->left) && dir_iswildcard(cl->right))
                cmpvalue = dir_compwildcard(cl->left, cl->right, lname, rname);
            else
                cmpvalue = utils_CompPath(lname, rname);
        }

#ifdef trace
        {       char msg[2*MAX_PATH+30];
            wsprintf( msg, "complist_match: %s %s %s\n"
                      , lname
                      , ( cmpvalue<0 ? "<"
                          : (cmpvalue==0 ? "=" : ">")
                        )
                      , rname
                    );
            if (bTrace) Trace_File(msg);
        }
#endif
        dir_freerelname(leftitem, lname);
        dir_freerelname(rightitem, rname);

        if (cmpvalue == 0) {
            BOOL trackThese = TrackSame || TrackDifferent;
            if (!TrackReadonly) {
                BOOL bothReadonly = (BOOL)((dir_getattr(leftitem) &
                                            dir_getattr(rightitem) &
                                            FILE_ATTRIBUTE_READONLY) != 0);
                if (bothReadonly) {
                    trackThese = FALSE;
                }
            }
            if (trackThese) {
                compitem_new( leftitem, rightitem
                              , cl->items, fExact);
                if (view_newitem(view)) {
                    TickCount = GetTickCount() - TickCount;
                    return(FALSE);
                }
                leftitem = dir_nextitem(cl->left, leftitem, fDeep);
                rightitem = dir_nextitem(cl->right, rightitem, fDeep);
            } else {
                nextitem = dir_nextitem(cl->left, leftitem, fDeep);
                List_Delete(leftitem);
                leftitem = nextitem;
                nextitem = dir_nextitem(cl->right, rightitem, fDeep);
                List_Delete(rightitem);
                rightitem = nextitem;
            }

        } else if (cmpvalue < 0) {
            if (TrackLeftOnly) {
                compitem_new(leftitem, NULL, cl->items, fExact);
                if (view_newitem(view)) {
                    TickCount = GetTickCount() - TickCount;
                    return(FALSE);
                }
                leftitem = dir_nextitem(cl->left, leftitem, fDeep);
            } else {
                nextitem = dir_nextitem(cl->left, leftitem, fDeep);
                List_Delete(leftitem);
                leftitem = nextitem;
            }
        } else {
            if (TrackRightOnly) {
                compitem_new(NULL, rightitem, cl->items, fExact);
                if (view_newitem(view)) {
                    TickCount = GetTickCount() - TickCount;
                    return(FALSE);
                }
                rightitem = dir_nextitem(cl->right, rightitem, fDeep);
            } else {
                nextitem = dir_nextitem(cl->right, rightitem, fDeep);
                List_Delete(rightitem);
                rightitem = nextitem;
            }
        }
    }


    /* any left over are unmatched */
    if (TrackLeftOnly) {
        while (leftitem != NULL) {
            compitem_new(leftitem, NULL, cl->items, fExact);
            if (view_newitem(view)) {
                TickCount = GetTickCount() - TickCount;
                return(FALSE);
            }
            leftitem = dir_nextitem(cl->left, leftitem, fDeep);
        }
    }
    if (TrackRightOnly) {
        while (rightitem != NULL) {
            compitem_new(NULL, rightitem, cl->items, fExact);
            if (view_newitem(view)) {
                TickCount = GetTickCount() - TickCount;
                return(FALSE);
            }
            rightitem = dir_nextitem(cl->right, rightitem, fDeep);
        }
    }
    TickCount = GetTickCount() - TickCount;
    return(TRUE);
} /* complist_match */

/* return time last operation took in milliseconds */
DWORD complist_querytime(void)
{       return TickCount;
}


/* dialog to query about filename and types of files. Init dlg fields from
 * the dlg_* variables, and save state to the dlg_* variables on dialog
 * close. return TRUE for OK, or FALSE for cancel (from the dialogbox()
 * using EndDialog).
 */
INT_PTR CALLBACK
complist_dodlg_savelist(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:
            SendDlgItemMessage(hDlg, IDD_IDENTICAL, BM_SETCHECK,
                               dlg_identical ? 1 : 0, 0);
            SendDlgItemMessage(hDlg, IDD_DIFFER, BM_SETCHECK,
                               dlg_differ ? 1 : 0, 0);
            SendDlgItemMessage(hDlg, IDD_LEFT, BM_SETCHECK,
                               dlg_left ? 1 : 0, 0);
            SendDlgItemMessage(hDlg, IDD_RIGHT, BM_SETCHECK,
                               dlg_right ? 1 : 0, 0);
            SendDlgItemMessage(hDlg, IDD_SUMS, BM_SETCHECK,
                               dlg_sums ? 1 : 0, 0);
            CheckDlgButton(hDlg, IDD_IGNOREMARK, dlg_IgnoreMarks ? 1 : 0);

            SetDlgItemText(hDlg, IDD_FILE, dlg_file);

            return(TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDOK:
                    dlg_identical = (SendDlgItemMessage(hDlg, IDD_IDENTICAL,
                                                        BM_GETCHECK, 0, 0) == 1);
                    dlg_differ = (SendDlgItemMessage(hDlg, IDD_DIFFER,
                                                     BM_GETCHECK, 0, 0) == 1);
                    dlg_left = (SendDlgItemMessage(hDlg, IDD_LEFT,
                                                   BM_GETCHECK, 0, 0) == 1);
                    dlg_right = (SendDlgItemMessage(hDlg, IDD_RIGHT,
                                                    BM_GETCHECK, 0, 0) == 1);
                    dlg_sums = (SendDlgItemMessage(hDlg, IDD_SUMS,
                                                   BM_GETCHECK, 0, 0) == 1);
                    dlg_IgnoreMarks =
                    (SendDlgItemMessage(
                                       hDlg,
                                       IDD_IGNOREMARK,
                                       BM_GETCHECK, 0, 0) == 1);

                    GetDlgItemText(hDlg, IDD_FILE, dlg_file, sizeof(dlg_file));

                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;
            }
    }
    return(FALSE);
} /* complist_dodlg_savelist */

/* dialog to get directory name and inclusion options. Init dlg fields from
 * the dlg_* variables, and save state to the dlg_* variables on dialog
 * close. return TRUE for OK, or FALSE for cancel (from the dialogbox()
 * using EndDialog).
 */
INT_PTR CALLBACK
complist_dodlg_copyfiles(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:
            /*
             * set checkboxes and directory field to defaults
             */
            CheckDlgButton(hDlg, IDD_IDENTICAL,
                           (dlg_options & INCLUDE_SAME) ? 1 : 0);

            CheckDlgButton(hDlg, IDD_DIFFER,
                           (dlg_options & INCLUDE_DIFFER) ? 1 : 0);

            CheckDlgButton(hDlg, IDD_LEFT,
                           (dlg_options & (INCLUDE_LEFTONLY|INCLUDE_RIGHTONLY)) ? 1 : 0);

            CheckDlgButton(hDlg, IDD_IGNOREMARK, dlg_IgnoreMarks ? 1 : 0);

            CheckDlgButton(hDlg, IDD_ATTRIBUTES, dlg_IgnoreAttributes ? 0 : 1);

            SetDlgItemText(hDlg, IDD_DIR1, dlg_root);

            /*
             * set default radio button for copy from
             */
            CheckRadioButton(hDlg, IDD_FROMLEFT, IDD_FROMRIGHT,
                             (dlg_options & COPY_FROMLEFT) ? IDD_FROMLEFT : IDD_FROMRIGHT);

            return(TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDD_FROMLEFT:
                    dlg_options &= ~(COPY_FROMRIGHT);
                    dlg_options |= COPY_FROMLEFT;
                    break;

                case IDD_FROMRIGHT:
                    dlg_options &= ~(COPY_FROMLEFT);
                    dlg_options |= COPY_FROMRIGHT;
                    break;

                case IDOK:
                    if (SendDlgItemMessage(hDlg, IDD_IDENTICAL,
                                           BM_GETCHECK, 0, 0) == 1) {
                        dlg_options |= INCLUDE_SAME;
                    } else {
                        dlg_options &= ~INCLUDE_SAME;
                    }
                    if (SendDlgItemMessage(hDlg, IDD_DIFFER,
                                           BM_GETCHECK, 0, 0) == 1) {
                        dlg_options |= INCLUDE_DIFFER;
                    } else {
                        dlg_options &= ~INCLUDE_DIFFER;
                    }
                    if (SendDlgItemMessage(hDlg, IDD_LEFT,
                                           BM_GETCHECK, 0, 0) == 1) {
                        dlg_options |= INCLUDE_LEFTONLY;
                    } else {
                        dlg_options &= ~INCLUDE_LEFTONLY;
                    }

                    dlg_IgnoreMarks =
                    (SendDlgItemMessage(
                                       hDlg,
                                       IDD_IGNOREMARK,
                                       BM_GETCHECK, 0, 0) == 1);

                    dlg_IgnoreAttributes =
                    (SendDlgItemMessage(
                                       hDlg,
                                       IDD_ATTRIBUTES,
                                       BM_GETCHECK, 0, 0) == 0);

                    GetDlgItemText(hDlg, IDD_DIR1, dlg_root, sizeof(dlg_root));

                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;
            }
    }
    return(FALSE);
} /* complist_dodlg_copyfiles */

/* allocate a new complist and initialise it */
COMPLIST
complist_new(void)
{
    COMPLIST cl;

    cl = (COMPLIST) gmem_get(hHeap, sizeof(struct complist));
    cl->left = NULL;
    cl->right = NULL;
    cl->items = List_Create();

    return(cl);
} /* complist_new */

static void
FillOtherEdit(HWND hDlg, int idFrom, int idTo)
{
    char buffer[MAX_PATH];
    SLMOBJECT hSlm;

    GetDlgItemText(hDlg, idFrom, buffer, sizeof(buffer));

    if ( (hSlm = SLM_New(buffer, 0)) != NULL) {
        if (IsSourceDepot(hSlm)) {
            LPSTR pTag = pTag = SLM_ParseTag(buffer, TRUE);
            lstrcpy(buffer, "(Source Depot, ");
            if (pTag) {
                lstrcat(buffer, pTag);
                gmem_free(hHeap, pTag, lstrlen(pTag)+1);
            } else {
                lstrcat(buffer, "#have");
            }
            lstrcat(buffer, ")");
            SetDlgItemText(hDlg, idTo, buffer);
        } else {
            SLM_GetMasterPath(hSlm, buffer);
            SetDlgItemText(hDlg, idTo, buffer);
        }
        SLM_Free(hSlm);
    } else {
        // set text to null if no valid slm
        SetDlgItemText(hDlg, idTo, "");
    }
}

/* dialog box function to ask for two directory names.
 * no listing of files etc - just two edit fields  in which the
 * user can type a file or a directory name.
 *
 * initialises the names from win.ini, and stores them to win.ini first.
 */
INT_PTR CALLBACK
complist_dodlg_dir(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static char path[MAX_PATH];
    static char buffer[MAX_PATH];

    /* We write what we find to the ini file, but we only load from the ini file
    ** once per instance of the app.  So if you start two windiffs, each remembers
    ** what it is doing as long as it is alive
    */

    int id;
    SLMOBJECT hSlm;

    switch (message) {

        case WM_INITDIALOG:

            /* fill the edit fields with the current
             * directory as a good starting point - if there isn't
             * already a saved path.
             *
             * set the current directory as a label so that the
             * user can select relative paths such as ..
             *
             */
            _getcwd(path, sizeof(path));
            AnsiLowerBuff(path, strlen(path));
            SetDlgItemText(hDlg, IDD_LAB3, path);

            if (!SeenDialogNames)
                GetProfileString(APPNAME, "NameLeft", path, dialog_leftname, MAX_PATH);
            SetDlgItemText(hDlg, IDD_DIR1, dialog_leftname);
            if (!SeenDialogNames)
                GetProfileString(APPNAME, "NameRight", path, dialog_rightname, MAX_PATH);
            SetDlgItemText(hDlg, IDD_DIR2, dialog_rightname);
            if (!SeenDialogNames)
                dialog_recursive = GetProfileInt(APPNAME, "Recursive", 1);
            SendDlgItemMessage( hDlg
                                , IDD_RECURSIVE
                                , BM_SETCHECK
                                , (WPARAM)dialog_recursive
                                , 0
                              );

            /* If there's a slm.ini visible, enable the SLM check boxes */
            if (1&IsSLMOK()) {
                ShowWindow(GetDlgItem(hDlg, IDD_SLM), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDD_LOCALSLM), SW_SHOW);
            }
            SeenDialogNames = TRUE;
            return(TRUE);

        case WM_COMMAND:
            id = GET_WM_COMMAND_ID(wParam, lParam);

            switch (id) {
                case IDD_DIR1:
                case IDD_DIR2:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) {

                        int idother = (id == IDD_DIR1) ? IDD_DIR2 : IDD_DIR1;

                        /* if we are changing the edit field, and the SLM
                         * is checked for the other edit field, then update the
                         * other edit field to the SLM path for this one.
                         */
                        if (IsDlgButtonChecked(hDlg, (id == IDD_DIR1) ? IDD_LOCALSLM : IDD_SLM)) {
                            FillOtherEdit(hDlg, id, idother);
                        }
                    }
                    break;

                case IDD_SLM:
                case IDD_LOCALSLM:
                    {
                        int idthis, idother;


                        if (id == IDD_SLM) {
                            idthis = IDD_DIR1;
                            idother = IDD_DIR2;
                            // ensure that both 'slm' boxes are not set!
                            CheckDlgButton(hDlg, IDD_LOCALSLM, FALSE);
                        } else {
                            idthis = IDD_DIR2;
                            idother = IDD_DIR1;
                            CheckDlgButton(hDlg, IDD_SLM, FALSE);
                        }

                        if (IsDlgButtonChecked(hDlg, id)) {


                            /*
                             * disable edit field and fill
                             * with SLM path for other edit field
                             */
                            EnableWindow(GetDlgItem(hDlg, idthis), FALSE);
                            EnableWindow(GetDlgItem(hDlg,
                                                    (id == IDD_SLM) ? IDD_LAB1 : IDD_LAB2), FALSE);

                            /*
                             * fill the remote box with the slm library
                             * for the local path, if possible.
                             */
                            FillOtherEdit(hDlg, idother, idthis);
                        } else {

                            // re-enable the edit field
                            EnableWindow(GetDlgItem(hDlg, idthis), TRUE);
                            EnableWindow(GetDlgItem(hDlg,
                                                    (id == IDD_SLM) ? IDD_LAB1 : IDD_LAB2), TRUE);
                        }
                        break;
                    }


                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return(TRUE);

                case IDOK:
                    {
                        LPSTR pszThis = 0;
                        LPSTR pszOther = 0;

                        /* fetch the text from the dialog, and remember
                         * it in win.ini
                         */

                        GetDlgItemText(hDlg, IDD_DIR1,
                                       dialog_leftname, sizeof(dialog_leftname));
                        GetDlgItemText(hDlg, IDD_DIR2,
                                       dialog_rightname, sizeof(dialog_rightname));

                        if (IsDlgButtonChecked(hDlg, IDD_SLM))
                        {
                            pszThis = dialog_rightname;
                            pszOther = dialog_leftname;
                        }
                        else if (IsDlgButtonChecked(hDlg, IDD_LOCALSLM))
                        {
                            pszThis = dialog_leftname;
                            pszOther = dialog_rightname;
                        }

                        if (pszThis)
                        {
                            hSlm = SLM_New(pszThis, 0);
                            if (hSlm)
                            {
                                if (IsSourceDepot(hSlm))
                                {
                                    LPSTR pTag = SLM_ParseTag(pszThis, TRUE);
                                    lstrcpy(pszOther, pszThis);
                                    if (pTag)
                                    {
                                        lstrcat(pszOther, pTag);
                                        gmem_free(hHeap, pTag, lstrlen(pTag)+1);
                                    }
                                    else
                                    {
                                        lstrcat(pszOther, "#have");
                                    }
                                }
                                SLM_Free(hSlm);
                            }
                        }

                        WriteProfileString(APPNAME, "NameLeft", dialog_leftname);
                        WriteProfileString(APPNAME, "NameRight", dialog_rightname);

                        dialog_recursive =  ( 1 == SendDlgItemMessage( hDlg
                                                                       , IDD_RECURSIVE
                                                                       , BM_GETCHECK
                                                                       , 0
                                                                       , 0
                                                                     )
                                            );
                        WriteProfileString( APPNAME
                                            , "Recursive"
                                            , dialog_recursive ? "1" : "0"
                                          );
                        EndDialog(hDlg, TRUE);
                    }
                    return(TRUE);
            }
            break;
    }
    return(FALSE);
} /* complist_dodlg_dir */


#ifdef REMOTE_SERVER
/*
 * simple dialog to ask for the name of the checksum server, and
 * the names of the local and remote paths.
 *
 * defaults for all strings are stored in win.ini
 */
INT_PTR CALLBACK
complist_dodlg_remote(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static char path[MAX_PATH];
    static char buffer[MAX_PATH];
    static char LeftName[MAX_PATH];
    static char RightName[MAX_PATH];
    static BOOL Recursive;
    /* Other options such as FastScan are unique to the remote dialog, so
    ** we don't need to keep our own copy here
    */
    int id;
    static BOOL SeenDialog = FALSE;
    SLMOBJECT hSlm;

    switch (message) {

        case WM_INITDIALOG:
            /* fill the edit fields with the current
             * directory as a good starting point - if there isn't
             * already a saved path.
             *
             * set the current directory as a label so that the
             * user can select relative paths such as ..
             *
             */
            _getcwd(path, sizeof(path));
            AnsiLowerBuff(path, strlen(path));
            SetDlgItemText(hDlg, IDD_LAB3, path);

            if (!SeenDialog)
                GetProfileString(APPNAME, "NameRemote", path, LeftName, MAX_PATH);
            SetDlgItemText(hDlg, IDD_DIR1, LeftName);

            if (!SeenDialog)
                GetProfileString(APPNAME, "NameLocal", path, RightName, MAX_PATH);
            SetDlgItemText(hDlg, IDD_DIR2, RightName);

            if (!SeenDialog)
                dialog_fastscan = GetProfileInt(APPNAME, "Fastscan", 0);
            SendDlgItemMessage( hDlg
                                , IDD_FASTSCAN
                                , BM_SETCHECK
                                , (WPARAM)dialog_fastscan
                                , 0
                              );

            path[0] = '\0';

            path[0] = '\0';
            if (!SeenDialog)
                GetProfileString(APPNAME, "NameServer", path, dialog_servername, MAX_PATH);
            SetDlgItemText(hDlg, IDD_SERVER, dialog_servername);

            if (!SeenDialog)
                Recursive = GetProfileInt(APPNAME, "Recursive", 1);
            SendDlgItemMessage( hDlg
                                , IDD_RECURSIVE
                                , BM_SETCHECK
                                , (WPARAM)Recursive
                                , 0
                              );

            SendDlgItemMessage(hDlg, IDD_BOTHREMOTE, BM_SETCHECK,
                               dialog_bothremote?1:0, 0);

            /* If there's a slm.ini visible, enable the SLM check boxes */
            if (1&IsSLMOK()) {
                ShowWindow(GetDlgItem(hDlg, IDD_SLM), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDD_LOCALSLM), SW_SHOW);
            }
            SeenDialog = TRUE;
            return(TRUE);

        case WM_COMMAND:
            id = GET_WM_COMMAND_ID(wParam, lParam);
            switch (id) {
                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return(TRUE);

                case IDD_DIR1:
                case IDD_DIR2:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) {

                        int idother = (id == IDD_DIR1) ? IDD_DIR2 : IDD_DIR1;

                        /* if we are leaving the edit field, and the SLM
                         * is checked for the other edit field, then update the
                         * other edit field to the SLM path for this one.
                         */
                        if (IsDlgButtonChecked(
                                              hDlg,
                                              (id == IDD_DIR1) ? IDD_LOCALSLM : IDD_SLM)) {

                            GetDlgItemText(hDlg, id, path, sizeof(path));

                            if ( (hSlm = SLM_New(path, 0)) != NULL) {
                                SLM_GetMasterPath(hSlm, buffer);
                                SLM_Free(hSlm);
                                SetDlgItemText(hDlg, idother, buffer);
                            } else {
                                // set text to null if no valid slm
                                SetDlgItemText(hDlg, idother, "");
                            }

                        }
                    }
                    break;

                case IDD_SLM:
                case IDD_LOCALSLM:
                    {
                        int idthis, idother;


                        if (id == IDD_SLM) {
                            idthis = IDD_DIR1;
                            idother = IDD_DIR2;
                        } else {
                            idthis = IDD_DIR2;
                            idother = IDD_DIR1;
                        }

                        if (IsDlgButtonChecked(hDlg, id)) {

                            /*
                             * disable edit field and fill
                             * with SLM path for other edit field
                             */
                            EnableWindow(GetDlgItem(hDlg, idthis), FALSE);
                            EnableWindow(GetDlgItem(hDlg,
                                                    (id == IDD_SLM) ? IDD_LAB1 : IDD_LAB2), FALSE);

                            /*
                             * fill the remote box with the slm library
                             * for the local path, if possible.
                             */
                            GetDlgItemText(hDlg, idother, path, sizeof(path));

                            if ( (hSlm = SLM_New(path, 0)) != NULL) {
                                SLM_GetMasterPath(hSlm, buffer);
                                SLM_Free(hSlm);
                                SetDlgItemText(hDlg, idthis, buffer);
                            } else {
                                // set text to null if no valid slm path
                                SetDlgItemText(hDlg, idthis, "");
                            }
                        } else {

                            // re-enable the edit field
                            EnableWindow(GetDlgItem(hDlg, idthis), TRUE);
                            EnableWindow(GetDlgItem(hDlg,
                                                    (id == IDD_SLM) ? IDD_LAB1 : IDD_LAB2), TRUE);
                        }
                        break;
                    }


                case IDOK:
                    GetDlgItemText(hDlg, IDD_DIR1,
                                   dialog_leftname, sizeof(dialog_leftname));
                    WriteProfileString(APPNAME, "NameRemote", dialog_leftname);
                    strcpy(LeftName, dialog_leftname);

                    GetDlgItemText(hDlg, IDD_DIR2,
                                   dialog_rightname, sizeof(dialog_rightname));
                    WriteProfileString(APPNAME, "NameLocal", dialog_rightname);
                    strcpy(RightName, dialog_rightname);

                    GetDlgItemText(hDlg, IDD_SERVER,
                                   dialog_servername, sizeof(dialog_servername));
                    WriteProfileString(APPNAME, "NameServer", dialog_servername);

                    dialog_recursive =  ( 1 == SendDlgItemMessage( hDlg
                                                                   , IDD_RECURSIVE
                                                                   , BM_GETCHECK
                                                                   , 0
                                                                   , 0
                                                